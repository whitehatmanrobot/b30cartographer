 = iValueInitial;
			return E_FAIL;
		}
		++nDigits;
		++pszValue;
	}


	if (nDigits == 0) {
		return E_FAIL;
	}

	if (bIsNegative) {
		iValue = -iValue;
	}

	return S_OK;
}


//*****************************************************************
// CXStringArray::Load
//
// Given an array of resource ids, load the corresponding strings
// into this CStringArray.
//
// Parameters:
//		UINT* puiResID
//			Pointer to the array of string resource ids
//
//		int nStrings
//			The number of entries in the resource id array.
//
// Returns:
//		Nothing.
//
//****************************************************************
void CXStringArray::Load(UINT* puiResID, int nStrings)
{
	// If this string array was already loaded, do nothing.
	if (GetSize() > 0) {
		return;
	}

	CString sValue;
	while (--nStrings >= 0) {
		sValue.LoadString(*puiResID++);
		Add(sValue);
	}
}



//********************************************************************
// ToBSTR
//
// Convert a COleVariant to a BSTR
//
// Parameters:
//		COleVariant& var
//			The variant to convert.
//
// Returns:
//		BSTR
//			The place where the converted value is returned.
//
// Note that the BSTR returned is owned by the COleVariant.
//*******************************************************************
BSTR ToBSTR(COleVariant& var)
{
	switch(var.vt) {
	case VT_BSTR:
		break;
	case VT_NULL:
		var = L"";
		break;
	default:
		try
		{
			var.ChangeType(VT_BSTR);
		}
		catch(CException*  )
		{
			var = L"";

		}
		break;
	}
	return var.bstrVal;
}



//***********************************************************************
// GenerateWindowID
//
// A series of unique window IDs are generated by sucessive calls to this
// method.
//
// Parameters:
//		None.
//
// Returns:
//		A unique window ID used when creating a new window.
//
//**********************************************************************
UINT GenerateWindowID()
{
	static UINT nID = 4000;
	return nID++;
}




//*************************************************************
// MakeSafeArray
//
// Make a safe array of the specified size and element type.
//
// Parameters:
//		SAFEARRAY FAR ** ppsaCreated
//			A pointer to the place to return the safe array.
//
//		VARTYPE vt
//			The type of the elements.
//
//		int nElements
//			The number of elements.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//*************************************************************
SCODE MakeSafeArray(SAFEARRAY FAR ** ppsaCreated, VARTYPE vt, int nElements)
{
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = nElements;
    *ppsaCreated = SafeArrayCreate(vt,1, rgsabound);
    return (*ppsaCreated == NULL) ? 0x80000001 : S_OK;
}




//******************************************************************
// GetViewerFont
//
// Get the "global" font used by the HMOM object viewer.  This method
// will probably be replaced when I can figure out a way to get the
// ambient font.
//
// Parameters:
//		CFont& font
//			A reference to the font to return.
//
//		LONG lfHeight
//			The desired font height.
//
//		LONG lfWeight
//			The weight of the font (FW_BOLD, FW_NORMAL, etc.)
//
// Returns:
//		Nothing.
//
//*******************************************************************
void GetViewerFont(CFont& font, LONG lfHeight, LONG lfWeight)
{
	CFont fontTmp;
	fontTmp.CreateStockObject(SYSTEM_FONT);

	LOGFONT logFont;
	fontTmp.GetObject(sizeof(LOGFONT), &logFont);
	logFont.lfWidth = 0;
	logFont.lfHeight = lfHeight;
	logFont.lfWeight = lfWeight;
	logFont.lfQuality = DEFAULT_QUALITY;
	logFont.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
	lstrcpy(logFont.lfFaceName, _T("MS Shell Dlg"));

	VERIFY(font.CreateFontIndirect(&logFont));
}



//***********************************************************************
// VariantToCString
//
// Convert a variant to a CString
//
// Parameters:
//		CString& sResult
//			The result is returned here.
//
//		VARIANT& varSrc
//			The source variant.
//
// Returns:
//		Nothing.
//
//**********************************************************************
void VariantToCString(CString& sResult, const VARIANT& varSrc)
{
	if (varSrc.vt == VT_BSTR) {
		sResult = varSrc.bstrVal;
	}
	else {
		COleVariant var(varSrc);
		ToBSTR(var);
		sResult = var.bstrVal;
	}
}



//**********************************************************************
// IsPrefix
//
// Check to see if one string is the prefix of another.
//
// Parameters:
//		[in] LPCTSTR pszPrefix
//			The prefix to check for.
//
//		[in] LPCTSTR pszValue
//			The string to examine.
//
// Returns:
//		TRUE if the pszPrefix is a prefix of sValue.
//
//**********************************************************************
BOOL IsPrefix(LPCTSTR pszPrefix, LPCTSTR pszValue)
{
	while (*pszPrefix != 0) {
		if (*pszPrefix != *pszValue) {
			return FALSE;
		}
		++pszPrefix;
		++pszValue;
	}
	return TRUE;
}



//**********************************************************************
// ClassFromCimtype
//
// Get the classname from a reference or object cimtype.
//
// Parameters:
//		[in] LPCTSTR pszPrefix
//			The prefix to check for.
//
//		[in] CString& sValue
//			The string to examine.
//
// Returns:
//		TRUE if the pszPrefix is a prefix of sValue.
//
//**********************************************************************
SCODE ClassFromCimtype(LPCTSTR pszCimtype, CString& sClass)
{
	int nchPrefix;
	CString sPrefix;

	// Check for an object type.
	sPrefix.LoadString(IDS_OBJECT_PREFIX);
	if (::IsPrefix(sPrefix, pszCimtype)) {
		nchPrefix = sPrefix.GetLength();
		sClass = pszCimtype;
		sClass = sClass.Right(sClass.GetLength() - nchPrefix);
		return S_OK;
	}

	// Check for a reference type.
	sPrefix.LoadString(IDS_REF_PREFIX);
	if (::IsPrefix(sPrefix, pszCimtype)) {
		nchPrefix = sPrefix.GetLength();
		sClass = pszCimtype;
		sClass = sClass.Right(sClass.GetLength() - nchPrefix);
		return S_OK;
	}

	return E_FAIL;
}



BOOL HasObjectPrefix(LPCTSTR psz)
{
	CString sObjectPrefix;
	sObjectPrefix.LoadString(IDS_OBJECT_PREFIX);
	BOOL bIsPrefix = IsPrefix(sObjectPrefix, psz);

	return bIsPrefix;
}





CBSTR& CBSTR::operator=(LPCTSTR psz)
{
	if (m_bstr) {
		::SysFreeString(m_bstr);
	}
	CString s(psz);
	m_bstr = s.AllocSysString();
	return *this;
}

CBSTR& CBSTR::operator=(CString& s)
{
	if (m_bstr) {
		::SysFreeString(m_bstr);
	}
	m_bstr = s.AllocSysString();
	return *this;
}

CBSTR& CBSTR::operator=(BSTR bstr)
{
	if (m_bstr) {
		::SysFreeString(m_bstr);
	}
	CString s;
	s = bstr;
	m_bstr = s.AllocSysString();
	return *this;
}


int CompareNoCase(BSTR bstr1, BSTR bstr2)
{
	if (bstr1 == bstr2) {
		return 0;
	}
	if (bstr1 == NULL) {
		return -1;
	}
	else if (bstr2 == NULL) {
		return 1;
	}

	ASSERT(bstr1 != NULL);
	ASSERT(bstr2 != NULL);

	while (TRUE) {
		WCHAR wch1;
		WCHAR wch2;

		wch1 = towupper(*bstr1);
		wch2 = towupper(*bstr2);
		if (wch1 < wch2) {
			return -1;
		}
		else if (wch1 > wch2) {
			return 1;
		}
		else if (wch1 == 0) {
			return 0;
		}

		++bstr1;
		++bstr2;
	}

}


BOOL IsEqualNoCase(BSTR bstr1, BSTR bstr2)
{
	if (bstr1 == bstr2) {
		return TRUE;
	}
	if (bstr1==NULL || bstr2==NULL) {
		return FALSE;
	}
	while (TRUE) {
		WCHAR wch1;
		WCHAR wch2;

		wch1 = towupper(*bstr1);
		wch2 = towupper(*bstr2);
		if (wch1 != wch2) {
			break;
		}
		if (wch1 == 0) {
			return TRUE;
		}

		++bstr1;
		++bstr2;
	}
	return FALSE;
}

//*******************************************************
// VtFromCimtype
//
// Map a cimtype to a the variant type that CIMOM uses to
// represent the value.
//
// Parameters:
//		[in] CIMTYPE cimtype
//			The CIMTYPE
//
//
// Returns:
//		VARTYPE
//			The variant type that CIMOM uses to represent the given
//			CIMTYPE.
//
//******************************************************
VARTYPE VtFromCimtype(CIMTYPE cimtype)
{
	BOOL bIsArray = cimtype & CIM_FLAG_ARRAY;
	cimtype = cimtype & CIM_TYPEMASK;

	VARTYPE vt = VT_NULL;
	switch(cimtype) {
	case CIM_EMPTY:
		vt = VT_NULL;
		break;
	case CIM_SINT8:
	case CIM_CHAR16:
	case CIM_SINT16:
		vt = VT_I2;
		break;
	case CIM_UINT8:
		vt = VT_UI1;
		break;
	case CIM_UINT16:
	case CIM_UINT32:
	case CIM_SINT32:
		vt = VT_I4;
		break;
	case CIM_SINT64:
	case CIM_UINT64:
	case CIM_STRING:
	case CIM_DATETIME:
	case CIM_REFERENCE:
		vt = VT_BSTR;
		break;
	case CIM_REAL32:
		vt = VT_R4;
		break;
	case CIM_REAL64:
		vt = VT_R8;
		break;
	case CIM_BOOLEAN:
		vt = VT_BOOL;
		break;
	case CIM_OBJECT:
		vt = VT_UNKNOWN;
		break;
	}
	if (bIsArray) {
		vt |= VT_ARRAY;
	}

	return vt;
}



TMapStringToLong amapCimType[] = {
	{IDS_CIMTYPE_UINT8, CIM_UINT8	},
	{IDS_CIMTYPE_SINT8,	CIM_SINT8},				// I2
	{IDS_CIMTYPE_UINT16, CIM_UINT16},			// VT_I4	Unsigned 16-bit integer
	{IDS_CIMTYPE_CHAR16, CIM_CHAR16},
	{IDS_CIMTYPE_SINT16, CIM_SINT16},			// VT_I2	Signed 16-bit integer
	{IDS_CIMTYPE_UINT32, CIM_UINT32},			// VT_I4	Unsigned 32-bit integer
	{IDS_CIMTYPE_SINT32, CIM_SINT32},			// VT_I4	Signed 32-bit integer
	{IDS_CIMTYPE_UINT64, CIM_UINT64},			// VT_BSTR	Unsigned 64-bit integer
	{IDS_CIMTYPE_SINT64, CIM_SINT64},			// VT_BSTR	Signed 64-bit integer
	{IDS_CIMTYPE_STRING, CIM_STRING},			// VT_BSTR	UCS-2 string
	{IDS_CIMTYPE_BOOL, CIM_BOOLEAN},			// VT_BOOL	Boolean
	{IDS_CIMTYPE_REAL32, CIM_REAL32},			// VT_R4	IEEE 4-byte floating-point
	{IDS_CIMTYPE_REAL64, CIM_REAL64},			// VT_R8	IEEE 8-byte floating-point
	{IDS_CIMTYPE_DATETIME, CIM_DATETIME},		// VT_BSTR	A string containing a date-time
	{IDS_CIMTYPE_REF, CIM_REFERENCE},			// VT_BSTR	Weakly-typed reference
	{IDS_CIMTYPE_OBJECT, CIM_OBJECT},	 	    // VT_UNKOWN	Weakly-typed embedded instance

	{IDS_CIMTYPE_UINT8_ARRAY, CIM_FLAG_ARRAY | CIM_UINT8	},
	{IDS_CIMTYPE_SINT8_ARRAY,	CIM_FLAG_ARRAY | CIM_SINT8 },		// I2
	{IDS_CIMTYPE_UINT16_ARRAY, CIM_FLAG_ARRAY | CIM_UINT16 },		// VT_I4	Unsigned 16-bit integer
	{IDS_CIMTYPE_CHAR16_ARRAY, CIM_FLAG_ARRAY | CIM_CHAR16},		// VT_I2
	{IDS_CIMTYPE_SINT16_ARRAY, CIM_FLAG_ARRAY | CIM_SINT16},		// VT_I2	Signed 16-bit integer
	{IDS_CIMTYPE_UINT32_ARRAY, CIM_FLAG_ARRAY | CIM_UINT32},		// VT_I4	Unsigned 32-bit integer
	{IDS_CIMTYPE_SINT32_ARRAY, CIM_FLAG_ARRAY | CIM_SINT32},			// VT_I4	Signed 32-bit integer
	{IDS_CIMTYPE_UINT64_ARRAY, CIM_FLAG_ARRAY | CIM_UINT64},		// VT_BSTR	Unsigned 64-bit integer
	{IDS_CIMTYPE_SINT64_ARRAY, CIM_FLAG_ARRAY | CIM_SINT64},		// VT_BSTR	Signed 64-bit integer
	{IDS_CIMTYPE_STRING_ARRAY, CIM_FLAG_ARRAY | CIM_STRING},		// VT_BSTR	UCS-2 string
	{IDS_CIMTYPE_BOOL_ARRAY, CIM_FLAG_ARRAY | CIM_BOOLEAN},		// VT_BOOL	Boolean
	{IDS_CIMTYPE_REAL32_ARRAY, CIM_FLAG_ARRAY | CIM_REAL32},		// VT_R4	IEEE 4-byte floating-point
	{IDS_CIMTYPE_REAL64_ARRAY, CIM_FLAG_ARRAY | CIM_REAL64},		// VT_R8	IEEE 8-byte floating-point
	{IDS_CIMTYPE_DATETIME_ARRAY, CIM_FLAG_ARRAY | CIM_DATETIME},	// VT_BSTR	A string containing a date-time
	{IDS_CIMTYPE_REF_ARRAY, CIM_FLAG_ARRAY | CIM_REFERENCE},		// VT_BSTR	Weakly-typed reference
	{IDS_CIMTYPE_OBJECT_ARRAY, CIM_FLAG_ARRAY | CIM_OBJECT}			// VT_UNKNOWN	Weakly-typed embedded instance
};

CMapStringToLong mapCimType;


//*************************************************************
// MapStringTocimtype
//
// Map a string to one of the cimom CIMTYPE values.
//
// Parameters:
//		[in] LPCTSTR pszCimtype
//			A string containing a cimtype.
//
//		[out] CIMTYPE& cimtype
//			The cimom CIMTYPE value is returned here.
//
// Returns:
//		Nothing.
//
//*************************************************************
SCODE MapStringToCimtype(LPCTSTR pszCimtype, CIMTYPE& cimtype)
{
	cimtype = CIM_EMPTY;
	if (IsPrefix(_T("object:"), pszCimtype)) {
		cimtype = CIM_OBJECT;
		return S_OK;
	}
	else if (IsPrefix(_T("ref:"), pszCimtype)) {
		cimtype = CIM_REFERENCE;
		return S_OK;
	}


	static BOOL bDidInitMap = FALSE;
	if (!bDidInitMap) {
		mapCimType.Load(amapCimType, sizeof(amapCimType) / sizeof(TMapStringToLong));
	}

	long lNewType;
	BOOL bFoundType = mapCimType.Lookup(pszCimtype, lNewType);

	if (bFoundType) {
		cimtype = (CIMTYPE) lNewType;
	}
	else {
		cimtype = CIM_EMPTY;
	}
	return cimtype;
}




//*************************************************************
// CGcType::MapCimtypeToString
//
// Map a CIMTYPE value to its closest string equivallent.  This
// function is called for properties, such as system properties, that
// do not have a cimtype qualifier and yet we still need to display
// a string value in the "type" cells.
//
// Parameters:
//		[out] CString& sCimtype
//			The string value of cimtype is returned here.
//
//		[in] CIMTYPE cimtype
//			The cimom CIMTYPE value.
//
// Returns:
//		SCODE
//			S_OK if a known cimtype is specified, E_FAIL if
//			an unexpected cimtype is encountered.
//
//*************************************************************
SCODE MapCimtypeToString(CString& sCimtype, CIMTYPE cimtype)
{
	SCODE sc = S_OK;
	BOOL bIsArray = cimtype & CIM_FLAG_ARRAY;
	cimtype &= ~CIM_FLAG_ARRAY;

	switch(cimtype) {
	case CIM_EMPTY:
		sCimtype.LoadString(IDS_CIMTYPE_EMPTY);
		break;
	case CIM_SINT8:
		sCimtype.LoadString(IDS_CIMTYPE_SINT8);
		break;
	case CIM_UINT8:
		sCimtype.LoadString(IDS_CIMTYPE_UINT8);
		break;
	case CIM_CHAR16:
		sCimtype.LoadString(IDS_CIMTYPE_CHAR16);
		break;
	case CIM_SINT16:
		sCimtype.LoadString(IDS_CIMTYPE_SINT16);
		break;
	case CIM_UINT16:
		sCimtype.LoadString(IDS_CIMTYPE_UINT16);
		break;
	case CIM_SINT32:
		sCimtype.LoadString(IDS_CIMTYPE_SINT32);
		break;
	case CIM_UINT32:
		sCimtype.LoadString(IDS_CIMTYPE_UINT32);
		break;
	case CIM_SINT64:
		sCimtype.LoadString(IDS_CIMTYPE_SINT64);
		break;
	case CIM_UINT64:
		sCimtype.LoadString(IDS_CIMTYPE_UINT64);
		break;
	case CIM_REAL32:
		sCimtype.LoadString(IDS_CIMTYPE_REAL32);
		break;
	case CIM_REAL64:
		sCimtype.LoadString(IDS_CIMTYPE_REAL64);
		break;
	case CIM_BOOLEAN:
		sCimtype.LoadString(IDS_CIMTYPE_BOOL);
		break;
	case CIM_STRING:
		sCimtype.LoadString(IDS_CIMTYPE_STRING);
		break;
	case CIM_DATETIME:
		sCimtype.LoadString(IDS_CIMTYPE_DATETIME);
		break;
	case CIM_REFERENCE:
		sCimtype.LoadString(IDS_CIMTYPE_REF);
		break;
	case CIM_OBJECT:
		sCimtype.LoadString(IDS_CIMTYPE_OBJECT);
		break;
	default:
		sCimtype.LoadString(IDS_CIMTYPE_UNEXPECTED);
		sc = E_FAIL;
		break;
	}

	return sc;
}


//*************************************************************
// CMapStringToLong::Load
//
// Given an array of TMapStringToLong entries, load the contents
// of this map so that the strings in the input array can be
// mapped to the corresponding values.
//
// Parameters:
//    TMapStringToLong* pMap
//			Pointer to an array of entries containing the resource ID of
//			a string and the corresponding value to map the string to.
//
//	  int nEntries
//			The number of entries in the array.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CMapStringToLong::Load(TMapStringToLong* pMap, int nEntries)
{
	if (m_map.GetCount() > 0) {
		return;
	}
	CString sKey;
	while (--nEntries >= 0) {
		sKey.LoadString(pMap->ids);
		m_map.SetAt(sKey, (void*) pMap->lValue);
		++pMap;
	}
}


//**************************************************************
// CMapStringToLong::Lookup
//
// Lookup the given key string and return the corresponding value.
//
// Parameters:
//		LPCTSTR key
//			The key value string to lookup
//
//		LONG& lValue
//			The place to return the value corresponding to the
//			key if the key was found.
//
// Returns:
//		TRUE = The key was found and a value was returned via lValue.
//		FALSE = The key was not found and no value was returned.
//
//**************************************************************
BOOL CMapStringToLong::Lookup( LPCTSTR key, LONG& lValue ) const
{
	void* pVoid;
	BOOL bFoundKey = m_map.Lookup(key, pVoid);
	if (bFoundKey) {
		// NOTE: EVEN UNDER Win64, WE REALLY ONLY ARE LOOKING
		// AT THE LOWER 32 BITS OF THE POINTER.  WE WERE ONLY
		// USING A PTR TO STORE OUR LONG VALUE.  THEREFORE, IT
		// IS OK FOR US TO TRUNCATE IT
		lValue = (DWORD)(DWORD_PTR)pVoid;
	}
	return bFoundKey;
}








//**********************************************************
// MapGcTypeToDisplayType
//
// Map a gridcell type to a string that is suitable for displaying
// in a cimtype grid cell.
//
// Parameters:
//		[out] CString& sDisplayType
//			Pointer to the type string that appears in the cimtype dropdown
//			combo box.
//
//		[in] const CGcType& type
//			The grid cell type.
//
// Returns:
//		Nothing.
//
//***********************************************************
void MapGcTypeToDisplayType(CString& sDisplayType, const CGcType& type)
{
	CIMTYPE cimtype = (CIMTYPE) type;

	CString sCimtype;
	sCimtype = type.CimtypeString();

	sDisplayType.Empty();
	if (cimtype & CIM_FLAG_ARRAY) {
		sDisplayType = "array of ";
	}
	sDisplayType = sDisplayType + sCimtype;
}


//**********************************************************
// MapDisplayTypeToGcType
//
// Map a display type string that appears in the cimtype drop-down
// combo into the corresponding CGcType.
//
// Parameters:
//		[out] CGcType& type
//			The grid cell type.
//
//		[in] LPCTSTR pszDisplayType
//			Pointer to the type string that appears in the cimtype dropdown
//			combo box.
//
// Returns:
//		Nothing.
//
//***********************************************************
void MapDisplayTypeToGcType(CGcType& type, LPCTSTR pszDisplayType)
{
	type.SetCellType(CELLTYPE_CIMTYPE);

	// Look for stongly typed objects and references.  If one is found,
	// set the cimtype and sCimtype strings.
	int iKeyword;
	int cch;
	CString sDisplayType;
	CString sCimtype;
	if (::IsPrefix(_T("object:"), pszDisplayType)) {
		// A strongly typed object
		type.SetCimtype(CIM_OBJECT, pszDisplayType);
	}
	else if (::IsPrefix(_T("array of object:"), pszDisplayType)) {
		sDisplayType = pszDisplayType;
		// A strongly typed object array
		iKeyword = sDisplayType.Find(_T("object:"));
		cch = sDisplayType.GetLength();
		sCimtype = sDisplayType.Right(cch - iKeyword);
		type.SetCimtype(CIM_OBJECT | CIM_FLAG_ARRAY, sCimtype);
	}
	else if (::IsPrefix(_T("ref:"), pszDisplayType)){
		type.SetCimtype(CIM_REFERENCE, pszDisplayType);
	}
	else if (::IsPrefix(_T("array of ref:"), pszDisplayType)) {
		sDisplayType = pszDisplayType;
		iKeyword = sDisplayType.Find(_T("ref:"));
		cch = sDisplayType.GetLength();
		sCimtype = sDisplayType.Right(cch - iKeyword);
		type.SetCimtype(CIM_REFERENCE | CIM_FLAG_ARRAY, sCimtype);

	}
	else {
		// Handle all of the other type strings.
		CIMTYPE cimtype;
		SCODE sc;
		sc = ::MapStringToCimtype(pszDisplayType, cimtype);
		if (SUCCEEDED(sc)) {
			type.SetCimtype(cimtype);
		}
		else {
			ASSERT(FALSE);
			type.SetCimtype(CIM_STRING);
		}
	}

}



//**********************************************
// IsEmptyString
//
// Check to see if a BSTR is all white space.
//
// Parameters:
//		[in] LPCTSTR psz
//			The string to examine.
//
// Returns:
//		BOOL
//			TRUE if the string is empty, FALSE otherwise.
//
//*********************************************
BOOL IsEmptyString(LPCTSTR psz)
{
	ASSERT(psz != NULL);
	while (isspace(*psz)) {
		++psz;
	}
	return (*psz == 0);
}







static BOOL IsHexDigit(int ch)
{
	if (isdigit(ch)) {
		return TRUE;
	}

	if (ch>='a' && ch<='f') {
		return TRUE;
	}

	if (ch>='A' && ch<='A') {
		return TRUE;
	}
	return FALSE;
}

static BOOL IsValidHexNumber(LPCTSTR pszValue)
{
	pszValue = EatWhite(pszValue);
	if ((pszValue[0] == '0') && (pszValue[1]=='x' || pszValue[1]=='X')) {
		pszValue += 2;
		while (IsHexDigit(*pszValue)) {
			++pszValue;
		}
		pszValue = EatWhite(pszValue);
		if (*pszValue == 0) {
			return TRUE;
		}
	}
	return FALSE;
}

static BOOL IsValidUnsignedNumber(LPCTSTR pszValue)
{

	pszValue = EatWhite(pszValue);
	if (*pszValue == '-') {
		return FALSE;
	}

	if (*pszValue=='+') {
		++pszValue;
	}

	pszValue = EatWhite(pszValue);

	if (!isdigit(*pszValue)) {
		return FALSE;
	}
	++pszValue;

	while (isdigit(*pszValue)) {
		++pszValue;
	}
	pszValue = EatWhite(pszValue);
	if (*pszValue == 0) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}

static BOOL IsValidSignedNumber(LPCTSTR pszValue)
{

	pszValue = EatWhite(pszValue);
	if (*pszValue == 0) {
		return FALSE;
	}

	if (*pszValue=='+' || *pszValue=='-') {
		++pszValue;
	}


	pszValue = EatWhite(pszValue);
	if (!isdigit(*pszValue)) {
		return FALSE;
	}
	++pszValue;

	while (isdigit(*pszValue)) {
		++pszValue;
	}
	pszValue = EatWhite(pszValue);
	if (*pszValue == 0) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}


#define MAX_UINT8  0x0ff
#define MIN_UINT8  0

#define MAX_SINT8  0x07f
#define MIN_SINT8 (~MAX_SINT8 & -1)


#define MAX_UINT16 0x0ffff
#define MIN_UINT16 0

#define MAX_SINT16 0x07fff
#define MIN_SINT16 (~MAX_SINT16  & -1)

#define MAX_UINT32 0x0ffffffff
#define MIN_UINT32 0

#define MAX_SINT32 0x07fffffff
#define MIN_SINT32 (~MAX_SINT32 & -1)

static BOOL IsValidCIM_SINT8(LPCTSTR pszValue)
{
	if (!IsValidSignedNumber(pszValue)) {
		return FALSE;
	}


	pszValue = EatWhite(pszValue);
	int iValue;
	int nFields = _stscanf(pszValue, _T("%d"), &iValue);

	if (nFields != 1) {
		return FALSE;
	}

	if ((iValue > MAX_SINT8) || (iValue < MIN_SINT8)) {
		return FALSE;
	}

	return TRUE;
}

static BOOL IsValidCIM_UINT8(LPCTSTR pszValue)
{
	if (!IsValidUnsignedNumber(pszValue)) {
		return FALSE;
	}


	pszValue = EatWhite(pszValue);
	unsigned int iValue;
	int nFields = _stscanf(pszValue, _T("%ud"), &iValue);

	if (nFields != 1) {
		return FALSE;
	}

	if (iValue<MIN_UINT8 || iValue > MAX_UINT8) {
		return FALSE;
	}

	return TRUE;
}





static BOOL IsValidCIM_SINT16(LPCTSTR pszValue)
{
	if (!IsValidSignedNumber(pszValue)) {
		return FALSE;
	}


	pszValue = EatWhite(pszValue);
	int iValue;
	int nFields = _stscanf(pszValue, _T("%d"), &iValue);

	if (nFields != 1) {
		return FALSE;
	}

	if ((iValue > MAX_SINT16) || (iValue < MIN_SINT16)) {
		return FALSE;
	}

	return TRUE;
}


static BOOL IsValidCIM_UINT16(LPCTSTR pszValue)
{
	if (!IsValidUnsignedNumber(pszValue)) {
		return FALSE;
	}


	pszValue = EatWhite(pszValue);
	unsigned int iValue;
	int nFields = _stscanf(pszValue, _T("%ud"), &iValue);

	if (nFields != 1) {
		return FALSE;
	}

	if (iValue<MIN_UINT16 || iValue > MAX_UINT16) {
		return FALSE;
	}

	return TRUE;
}

static BOOL IsValidCIM_SINT32(LPCTSTR pszValue)
{
	if (!IsValidSignedNumber(pszValue)) {
		return FALSE;
	}


	pszValue = EatWhite(pszValue);
	int iValue;
	int nFields = _stscanf(pszValue, _T("%d"), &iValue);

	if (nFields != 1) {
		return FALSE;
	}

	if ((iValue > MAX_SINT32) || (iValue < MIN_SINT32)) {
		return FALSE;
	}

	return TRUE;

}

static BOOL IsValidCIM_UINT32(LPCTSTR pszValue)
{
	if (!IsValidUnsignedNumber(pszValue)) {
		return FALSE;
	}


	pszValue = EatWhite(pszValue);
	unsigned long ulValue;

	SCODE sc = AToUint32(pszValue, ulValue);
	if (FAILED(sc)) {
		return FALSE;
	}


	return TRUE;
}

static BOOL IsValidCIM_SINT64(LPCTSTR pszValue)
{
	if (!IsValidSignedNumber(pszValue)) {
		return FALSE;
	}

	__int64 iValue;
	SCODE sc = AToSint64(pszValue, iValue);
	if (FAILED(sc)) {
		return FALSE;
	}

	return TRUE;
}

static BOOL IsValidCIM_UINT64(LPCTSTR pszValue)
{
	if (!IsValidUnsignedNumber(pszValue)) {
		return FALSE;
	}

	return TRUE;
}

static BOOL IsValidCIM_REAL32(LPCTSTR pszValue)
{
	pszValue = EatWhite(pszValue);
	float fltValue;
	int nFields = _stscanf(pszValue, _T("%f"), &fltValue);
	if (nFields != 1) {
		return FALSE;
	}

	return TRUE;
}


static BOOL IsValidCIM_Real64(LPCTSTR pszValue)
{
	pszValue = EatWhite(pszValue);
	float fltValue;
	int nFields = _stscanf(pszValue, _T("%f"), &fltValue);
	if (nFields != 1) {
		return FALSE;
	}

	return TRUE;
}

static BOOL IsValidCIM_Boolean(LPCTSTR pszValue)
{
	// !!!CR: Validation needs to be implemented.
	return TRUE;
}


static BOOL IsValidCIM_Datetime(LPCTSTR pszValue)
{
	// !!!CR: Validation needs to be implemented.
	return TRUE;
}


static BOOL IsValidCIM_CHAR16(LPCTSTR pszValue)
{
	return IsValidCIM_SINT16(pszValue);
}

BOOL IsValidValue(CIMTYPE cimtype, LPCTSTR pszValue, BOOL bDisplayErrorMessage)
{

	BOOL bIsValid = TRUE;
	switch(cimtype) {
	case CIM_SINT8:
		bIsValid = IsValidCIM_SINT8(pszValue);

		break;
	case CIM_UINT8:
		bIsValid = IsValidCIM_UINT8(pszValue);
		break;
	case CIM_SINT16:
		bIsValid = IsValidCIM_SINT16(pszValue);
		break;
	case CIM_UINT16:
		bIsValid = IsValidCIM_UINT16(pszValue);
		break;
	case CIM_SINT32:
		bIsValid = IsValidCIM_SINT32(pszValue);
		break;
	case CIM_UINT32:
		bIsValid = IsValidCIM_UINT32(pszValue);
		break;
	case CIM_SINT64:
		bIsValid = IsValidCIM_SINT64(pszValue);
		break;
	case CIM_UINT64:
		bIsValid = IsValidCIM_UINT64(pszValue);
		break;
	case CIM_REAL32:
		bIsValid = IsValidCIM_REAL32(pszValue);
		break;
	case CIM_REAL64:
		bIsValid = IsValidCIM_Real64(pszValue);
		break;
	case CIM_BOOLEAN:
		bIsValid = IsValidCIM_Boolean(pszValue);
		break;
	case CIM_STRING:
		bIsValid = TRUE;
		break;
	case CIM_DATETIME:
		bIsValid = IsValidCIM_Datetime(pszValue);
		break;
	case CIM_REFERENCE:
		bIsValid = TRUE;
		break;
	case CIM_CHAR16:
		bIsValid = IsValidCIM_CHAR16(pszValue);
		break;
	default:
		break;
	}

	if (!bIsValid && bDisplayErrorMessage) {
		TCHAR szBuffer[1024];
		CString sMessage;
		CString sCimtype;
		sMessage.LoadString(IDS_ERR_INVALID_VALUE);
		MapCimtypeToString(sCimtype, cimtype);

		_stprintf(szBuffer, sMessage, (LPCTSTR) sCimtype);
		HmmvErrorMsg(szBuffer,  S_OK, FALSE,  NULL, _T(__FILE__),  __LINE__);
	}

	return bIsValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\timepicker.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_TIMEPICKER_H__F2F813C3_7BC5_11D1_84F6_00C04FD7BB08__INCLUDED_)
#define AFX_TIMEPICKER_H__F2F813C3_7BC5_11D1_84F6_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TimePicker.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTimePicker window

class CTimePicker : public CWnd
{
// Construction
public:
	CTimePicker();

// Attributes
public:

// Operations
public:
	BOOL CustomCreate(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);
	virtual BOOL OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult );
	

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTimePicker)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTimePicker();

	// Generated message map functions
protected:
	//{{AFX_MSG(CTimePicker)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	void DoDateTimeChange(LPNMDATETIMECHANGE lpChange);

};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TIMEPICKER_H__F2F813C3_7BC5_11D1_84F6_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\cppgensheet.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// CppGenSheet.cpp : implementation file
//

#include "precomp.h"
#include <afxcmn.h>
#include "resource.h"
#include "wbemidl.h"
#include "moengine.h"
#include "CPPWiz.h"
#include "CPPWizCtl.h"
#include "WrapListCtrl.h"
#include "hlb.h"
#include "MyPropertyPage1.h"
#include "CppGenSheet.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/*
#define AfxDeferRegisterClass(fClass) \
	((afxRegisteredClasses & fClass) ? TRUE : AfxEndDeferRegisterClass(fClass))
#define AFX_WNDCOMMCTLS_REG     (0x0010)
extern BOOL AFXAPI AfxEndDeferRegisterClass(short fClass);
#include <afxpriv.h>

INT_PTR CCPPGenSheet::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd == NULL);

	// register common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTLS_REG));

	// finish building PROPSHEETHEADER structure
	BuildPropPageArray();

	// allow OLE servers to disable themselves
	AfxGetApp()->EnableModeless(FALSE);

	// find parent HWND
	HWND hWndTop;
	CWnd* pParentWnd = CWnd::GetSafeOwner(m_pParentWnd, &hWndTop);
	HWND hWndParent = pParentWnd->GetSafeHwnd();
	m_psh.hwndParent = hWndParent;
	BOOL bEnableParent = FALSE;
	if (pParentWnd != NULL && pParentWnd->IsWindowEnabled())
	{
		pParentWnd->EnableWindow(FALSE);
		bEnableParent = TRUE;
	}
	HWND hWndCapture = ::GetCapture();
	if (hWndCapture != NULL)
		::SendMessage(hWndCapture, WM_CANCELMODE, 0, 0);

	// setup for modal loop and creation
	m_nModalResult = 0;
	m_nFlags |= WF_CONTINUEMODAL;

	// hook for creation of window
	AfxHookWindowCreate(this);
	m_psh.dwFlags |= PSH_MODELESS;
	m_nFlags |= WF_CONTINUEMODAL;
	HWND hWnd = (HWND)::PropertySheet(&m_psh);
	m_psh.dwFlags &= ~PSH_MODELESS;
	AfxUnhookWindowCreate();

	// handle error
	if (hWnd == NULL || hWnd == (HWND)-1)
	{
		m_nFlags &= ~WF_CONTINUEMODAL;
		m_nModalResult = -1;
	}
	int nResult = m_nModalResult;
	if (m_nFlags & WF_CONTINUEMODAL)
	{
		// enter modal loop
		DWORD dwFlags = MLF_SHOWONIDLE;
		if (GetStyle() & DS_NOIDLEMSG)
			dwFlags |= MLF_NOIDLEMSG;
		nResult = RunModalLoop(dwFlags);
	}

	// hide the window before enabling parent window, etc.
	if (m_hWnd != NULL)
	{
		SetWindowPos(NULL, 0, 0, 0, 0, SWP_HIDEWINDOW|
			SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER);
	}
	if (bEnableParent)
		::EnableWindow(hWndParent, TRUE);
	if (pParentWnd != NULL && ::GetActiveWindow() == m_hWnd)
		::SetActiveWindow(hWndParent);

	// cleanup
	DestroyWindow();

	// allow OLE servers to enable themselves
	AfxGetApp()->EnableModeless(TRUE);
	if (hWndTop != NULL)
		::EnableWindow(hWndTop, TRUE);

	return nResult;
}

*/

/////////////////////////////////////////////////////////////////////////////
// CCPPGenSheet

IMPLEMENT_DYNAMIC(CCPPGenSheet, CPropertySheet)

CCPPGenSheet::CCPPGenSheet(CCPPWizCtrl* pWndParent)
	 : CPropertySheet(IDS_PROPSHT_CAPTION, NULL)
{
	// Add all of the property pages here.  Note that
	// the order that they appear in here will be
	// the order they appear in on screen.  By default,
	// the first page of the set is the active one.
	// One way to make a different property page the
	// active one is to call SetActivePage().
	m_psh.dwFlags |= (PSH_HASHELP);
	m_pParent = pWndParent;
	AddPage(&m_Page1);
	//AddPage(&m_Page2);
	AddPage(&m_Page3);
	AddPage(&m_Page4);

	m_Page1.m_psp.dwFlags |= (PSP_HASHELP);
	m_Page3.m_psp.dwFlags |= (PSP_HASHELP);
	m_Page4.m_psp.dwFlags |= (PSP_HASHELP);

	SetWizardMode();
}

CCPPGenSheet::~CCPPGenSheet()
{
}


BEGIN_MESSAGE_MAP(CCPPGenSheet, CPropertySheet)
	//{{AFX_MSG_MAP(CCPPGenSheet)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCPPGenSheet message handlers



BOOL CCPPGenSheet::OnInitDialog()
{
	// TODO: Add your specialized code here and/or call the base class

	return CPropertySheet::OnInitDialog();
}


int CCPPGenSheet::OnCreate(LPCREATESTRUCT lpCreateStruct)
{

	if (CPropertySheet::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_Page1.SetLocalParent(this);
	m_Page3.SetLocalParent(this);
	m_Page4.SetLocalParent(this);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\commondlls\hmmvgrid\utils.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#ifndef _utils_h

#include "wbemidl.h"
class CXStringArray : public CStringArray
{
public:
	~CXStringArray() { RemoveAll(); }
	void Load(UINT* puiResID, int nStrings);	
};

class CGcType;

#define CIM_TYPEMASK (~CIM_FLAG_ARRAY)

extern BSTR ToBSTR(COleVariant& var);
extern UINT GenerateWindowID();
extern SCODE MakeSafeArray(SAFEARRAY FAR ** ppsaCreated, VARTYPE vt, int nElements);
extern void GetViewerFont(CFont& font, LONG lfHeight, LONG lfWeight);
extern void VariantToCString(CString& sResult, const VARIANT& varSrc);
extern BOOL IsPrefix(LPCTSTR pszPrefix, LPCTSTR pszValue);
extern SCODE ClassFromCimtype(LPCTSTR pszCimtype, CString& sClass);
extern BOOL HasObjectPrefix(LPCTSTR psz);
extern BOOL IsEqualNoCase(BSTR bstr1, BSTR bstr2);
extern int CompareNoCase(BSTR bstr1, BSTR bstr2);
extern VARTYPE VtFromCimtype(CIMTYPE cimtype);
extern SCODE MapStringToCimtype(LPCTSTR pszCimtype, CIMTYPE& cimtype);
extern SCODE MapCimtypeToString(CString& sCimtype, CIMTYPE cimtype);
extern void MapGcTypeToDisplayType(CString& sDisplayType, const CGcType& type);
extern void MapDisplayTypeToGcType(CGcType& type, LPCTSTR pszDisplayType);
extern BOOL IsEmptyString(LPCTSTR psz);
extern BOOL IsValidValue(CIMTYPE cimtype, LPCTSTR pszValue, BOOL bDisplayErrorMessage=FALSE);
extern __int64 atoi64(LPCTSTR pszValue);
extern SCODE AToUint64(LPCTSTR& pszValue, unsigned __int64& uiValue);
extern SCODE AToSint64(LPCTSTR& pszValue, __int64& iValue);
extern void StripWhiteSpace(CString& sValue, LPCTSTR pszValue);




typedef struct {
	UINT ids;
	LONG lValue;
}TMapStringToLong;

class CMapStringToLong
{
public:
	void Load(TMapStringToLong* pMap, int nEntries);
	BOOL Lookup(LPCTSTR key, LONG& lValue ) const;

private:	
	CMapStringToPtr m_map;
};

extern TMapStringToLong amapCimType[];
extern CMapStringToLong mapCimType;


class CBSTR
{
public:
	CBSTR() {m_bstr = NULL; }
	CBSTR(LPCTSTR psz) {m_bstr = NULL; *this = psz; }
	CBSTR(CString& s) {m_bstr = NULL; *this = s; }
	~CBSTR() {if (m_bstr) {::SysFreeString(m_bstr);}} 
	CBSTR& operator=(LPCTSTR psz);
	CBSTR& operator=(CString& s);
	CBSTR& operator=(BSTR bstr);
	operator BSTR() {return m_bstr; }

private:
	BSTR m_bstr;
};


#endif _utils_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\cppwiz.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// CPPWiz.h : main header file for CPPWIZ.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCPPWizApp : See CPPWiz.cpp for implementation.

class CCPPWizApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\banner.cpp ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: banner.cpp
//
// Description:
//	This file implements the CBanner class which is a part of the Class Explorer
//	OCX.  CBanner is a subclass of the Microsoft CWnd class and performs
//	the following functions:
//		a.  Contains static label, combo box and toolbar child contols
//			which allow the user to select a namespace and add and
//			delete classes
//		b.  Handles the creation of, geometry and destruction of the child
//			contols.
//
// Part of:
//	ClassNav.ocx
//
// Used by:
//	CClassNavCtrl class
//
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

#include "precomp.h"
#include "ClassNav.h"
#include "wbemidl.h"
#include "olemsclient.h"
#include "AddDialog.h"
#include "RenameClassDialog.h"
#include "CClassTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "ClassNavCtl.h"
#include "ClassNavPpg.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include "nsentry.h"
#include "ClassNavNSEntry.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define CX_TOOLBAR_MARGIN 7
#define CY_TOOLBAR_MARGIN 7
#define CX_TOOLBAR_OFFSET 3
#define CY_TOOLBAR_OFFSET 1

// ***************************************************************************
//
// CBanner::CBanner
//
// Description:
//	  Class constructor.
//
// Parameters:
//	  CClassNavCtrl* pParent		Parent.
//
// Returns:
//	  NONE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CBanner::CBanner(CClassNavCtrl* pParent)
	:	m_pParent (pParent),
		m_bFontCreated (FALSE),
		m_nFontHeight (13),
		m_nOffset (2),
		m_pnseNameSpace (NULL),
		m_bAdding(FALSE)
{
	m_csBanner = _T("Classes in:");
}

CBanner::~CBanner()
{
	delete m_pnseNameSpace;
}

BEGIN_MESSAGE_MAP(CBanner, CWnd)
	//{{AFX_MSG_MAP(CBanner)
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_WM_CREATE()
	ON_COMMAND(ID_BUTTONADD, OnButtonadd)
	ON_COMMAND(ID_BUTTONDELETE, OnButtondelete)
	ON_COMMAND(ID_BUTTONCLASSSEARCH, OnButtonclasssearch)
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// ***************************************************************************
//
//	CBannerCWnd::SetChildControlGeometry
//
//	Description:
//		Set the geometry of the children controls based upon font size for the
//		edit and button controls.  Remainder goes to the tree control.
//
//	Parameters:
//		int cx			Width
//		int cy			Height
//
//	Returns:
//		void
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CBanner::SetChildControlGeometry(int cx, int cy)
{
	int nTextLength = GetTextLength(&m_csBanner);
	CSize csToolBar = m_cctbToolBar.GetToolBarSize();

	CRect rBannerRect = CRect(	0 + nSideMargin ,
							0 + nTopMargin ,
							cx - nSideMargin ,
							cy - nTopMargin);


	rBannerRect.NormalizeRect();

	int nNameSpaceX = rBannerRect.TopLeft().x + nTextLength + 8;

	int nToolBarX = max(nNameSpaceX + 2,
						rBannerRect.TopLeft().x +
							rBannerRect.Width() - (csToolBar.cx + 6));

	int nNameSPaceXMax = nToolBarX - 2;

	#pragma warning( disable :4244 )
	int nToolBarY = rBannerRect.TopLeft().y +
					((rBannerRect.Height() - csToolBar.cy) * .5);
	#pragma warning( default : 4244 )

	m_rNameSpace = CRect(	nNameSpaceX,
							rBannerRect.TopLeft().y - 3 ,
							nNameSPaceXMax,
							rBannerRect.BottomRight().y + 0);


	m_rToolBar = CRect(nToolBarX,
				nToolBarY - nTopMargin,
				rBannerRect.BottomRight().x  - 0,
				nToolBarY + csToolBar.cy + nTopMargin );
}

// ***************************************************************************
//
//	CBannerCWnd::GetTextLength
//
//	Description:
//		Get the length of a string using the control's font.
//
//	Parameters:
//		CString *		Text
//
//	Returns:
//		int				Length of string
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
int CBanner::GetTextLength(CString *pcsText)
{

	CSize csLength;
	int nReturn;

	CDC *pdc = CWnd::GetDC( );

	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont* pOldFont = pdc -> SelectObject( &(m_pParent -> m_cfFont) );
	csLength = pdc-> GetTextExtent( *pcsText );
	nReturn = csLength.cx;
	pdc -> SelectObject(pOldFont);

	ReleaseDC(pdc);
	return nReturn;

}

// ***************************************************************************
//
//  CBanner::PreCreateWindow
//
//	Description:
//		This VIRTUAL member function returns Initializes create struct values
//		for the custom tree control.
//
//	Parameters:
//		CREATESTRUCT& cs	A reference to a CREATESTRUCT with default control
//							creation values.
//
//	Returns:
// 		BOOL				Nonzero if the window creation should continue;
//							0 to indicate creation failure.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
BOOL CBanner::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.style = WS_CHILD | WS_VISIBLE | ES_WANTRETURN;
	cs.style &= ~WS_BORDER;

	if (!CWnd::PreCreateWindow(cs))
	{
		return FALSE;
	}

	return TRUE;

}

// ***************************************************************************
//
//  CClassTree::OnPaint
//
//	Description:
//		Paint the client area of the widow.
//
//	Parameters:
//		NONE
//
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CBanner::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	COLORREF dwBackColor = GetSysColor(COLOR_3DFACE);
	COLORREF crWhite = RGB(255,255,255);
	COLORREF crGray = GetSysColor(COLOR_3DHILIGHT);
	COLORREF crDkGray = GetSysColor(COLOR_3DSHADOW);
	COLORREF crBlack = GetSysColor(COLOR_WINDOWTEXT);


	CBrush br3DFACE(dwBackColor);
	dc.FillRect(&dc.m_ps.rcPaint, &br3DFACE);

	// Must do update to be able to over draw the border area.
	m_cctbToolBar.UpdateWindow();
	m_pnseNameSpace->RedrawWindow();

	dc.SelectObject( &(m_pParent->m_cfFont) );

	dc.SetBkMode( TRANSPARENT );

	CRect rcClipInitial;
	int nReturn = dc.GetClipBox( &rcClipInitial);
	CRect rcClip;
	CRect rcClient;
	GetClientRect(rcClient);


	// Draw the banner text that is clipped so that we don't overwrite the other stuff.
	rcClient.DeflateRect(0, 0, 11, 0);
	rcClip.IntersectRect(rcClipInitial, rcClient);
	CRgn rgnClip;
	rgnClip.CreateRectRgnIndirect( &rcClip );
	dc.SelectClipRgn( &rgnClip );
	dc.TextOut( m_nOffset + nSideMargin + 2, 9,
		(LPCTSTR) m_csBanner, m_csBanner.GetLength() );
	rgnClip.DeleteObject();

	// Draw the frame using the original clip box.
	dc.SetBkMode( OPAQUE );
	rgnClip.CreateRectRgnIndirect( &rcClipInitial );
	dc.SelectClipRgn( &rgnClip);
	DrawFrame(&dc);
	rgnClip.DeleteObject( );



	// Do not call CWnd::OnPaint() for painting messages
}

// ***************************************************************************
//
// CBanner::OnSize
//
// Description:
//	  Called by the framework after the window is being resized.
//
// Parameters:
//	  UINT nType			Specifies the type of resizing requested.
//	  int cx				Specifies the new width of the client area.
//	  int cy				Specifies the new height of the client area.
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CBanner::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);
	SetChildControlGeometry(cx, cy);
	m_cctbToolBar.MoveWindow( m_rToolBar);
	m_pnseNameSpace->MoveWindow(m_rNameSpace);

}

// ***************************************************************************
//
// CBanner::OnCreate
//
// Description:
//	  Called by the framework after the window is being created but before
//	  the window is shown.
//
// Parameters:
//	  LPCREATESTRUCT lpCreateStruct	Pointer to the structure which contains
//									default parameters.
//
// Returns:
//	  BOOL				0 if continue; -1 if the window should be destroyed.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
int CBanner::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;


	CRect crRect;
	GetClientRect( &crRect);

	if(m_cctbToolBar.Create
		(this, WS_CHILD | WS_VISIBLE  | CBRS_SIZE_FIXED) == -1)
	{
		return FALSE;
	}

	m_cctbToolBar.LoadToolBar( MAKEINTRESOURCE(IDR_TOOLBARADDDELETE) );


	SetChildControlGeometry(crRect.Width(), crRect.Height());

	m_pnseNameSpace = new CClassNavNSEntry;

	m_pnseNameSpace->SetLocalParent(m_pParent);

	if (m_pnseNameSpace->Create(NULL, NULL, WS_VISIBLE | WS_CHILD, m_rNameSpace,
		this, IDC_NSENTRY, NULL) == 0)
	{
		return FALSE;
	}


	CToolBarCtrl* ptbcToolBarCtrl = &m_cctbToolBar.GetToolBarCtrl();


	ptbcToolBarCtrl -> EnableButton(ID_BUTTONADD,FALSE);
	ptbcToolBarCtrl -> EnableButton(ID_BUTTONDELETE,FALSE);
	ptbcToolBarCtrl -> EnableButton(ID_BUTTONCLASSSEARCH,FALSE);

	// This is where we want to associate a string with
	// the tool for each button.
	CSize csToolBar = m_cctbToolBar.GetToolBarSize();

	#pragma warning( disable :4244 )
	CRect crToolBar(0,0,(int) csToolBar.cx * .3333,csToolBar.cy);
	#pragma warning( default : 4244 )

	m_cctbToolBar.GetToolTip().AddTool
		(ptbcToolBarCtrl,_T("Search for Class"),&crToolBar,1);

	#pragma warning( disable :4244 )
	crToolBar.SetRect
		((int)csToolBar.cx * .3333,0,(int) csToolBar.cx * .6666,csToolBar.cy);
	#pragma warning( default : 4244 )

	m_cctbToolBar.GetToolTip().AddTool
		(ptbcToolBarCtrl,_T("Add Class"),&crToolBar,2);

	#pragma warning( disable :4244 )
	crToolBar.SetRect
		((int) csToolBar.cx * .6666, 0, csToolBar.cx , csToolBar.cy);
 	#pragma warning( default : 4244 )

	m_cctbToolBar.GetToolTip().AddTool
		(ptbcToolBarCtrl,_T("Delete Class"),&crToolBar,3);

	return 0;
}

// ***************************************************************************
//
// CClassTree::DrawFrame
//
// Description:
//	  Draws the frame around the banner window.
//
// Parameters:
//	  CDC* pdc			Device context for drawing.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CBanner::DrawFrame(CDC* pdc)
{
	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));


	CRect rcFrame;
	GetClientRect(rcFrame);
	rcFrame.DeflateRect(nSideMargin,nTopMargin - 1);

	CRect rc;


	// Horizontal line at top
	rc.left = rcFrame.left;
	rc.right = rcFrame.right - 1;
	rc.top = rcFrame.top - 1;
	rc.bottom = rcFrame.top ;
	pdc->FillRect(rc, &br3DSHADOW);

	// Horizontal line at bottom
	rc.top = rcFrame.bottom - 1;
	rc.bottom = rcFrame.bottom ;
	pdc->FillRect(rc, &br3DHILIGHT);

	// Vertical line at left
	rc.left = rcFrame.left;
	rc.right = rcFrame.left + 1;
	rc.top = rcFrame.top;
	rc.bottom = rcFrame.bottom;
	pdc->FillRect(rc, &br3DSHADOW);

	// Vertical line at right
	rc.left = rcFrame.right - 2;
	rc.right = rcFrame.right - 1;
	pdc->FillRect(rc, &br3DHILIGHT);

}

// ***************************************************************************
//
// CClassTree::OnButtonAdd
//
// Description:
//	  Add class button handler.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CBanner::OnButtonadd()
{
	AddClass(NULL,NULL);
}

void CBanner::AddClass(CString *pcsParent, HTREEITEM hParentItem)
{
	CString csNewClass;
	CString csParent;
	int nReturn;

	m_pParent -> OnActivateInPlace(TRUE,NULL);

	if (m_bAdding == FALSE)
	{
		// Pass In
		CString csParent = pcsParent ? *pcsParent : m_pParent -> GetSelectionClassName();

		BOOL bCanChangeSelection = m_pParent->QueryCanChangeSelection(csParent);

		if (!bCanChangeSelection)
		{
			if (m_pParent ->m_bRestoreFocusToTree)
			{
				m_pParent ->m_ctcTree.SetFocus();
			}
			else
			{
				SetFocus();
			}
			return;
		}
		m_pParent -> GetAddDialog()->SetParent(csParent );
		CString csClass = _T("");
		m_pParent -> GetAddDialog()->SetNewClass(csClass);
		m_bAdding = TRUE;
	}

	m_pParent -> PreModalDialog();
	nReturn = (int) m_pParent -> GetAddDialog() -> DoModal( );
	m_pParent -> PostModalDialog();

	if (nReturn == IDCANCEL)
	{
		m_bAdding = FALSE;
		if (m_pParent ->m_bRestoreFocusToTree)
		{
			m_pParent ->m_ctcTree.SetFocus();
		}
		else
		{
			SetFocus();
		}
		return;
	}

	csParent = m_pParent -> GetAddDialog() -> GetParent();
	// Filter out leading space
	csParent.TrimLeft();
	csParent.TrimRight();

	csNewClass = 	m_pParent -> GetAddDialog() -> GetNewClass();
	csNewClass.TrimLeft();
	csNewClass.TrimRight();

	if (m_pParent ->m_bRestoreFocusToTree)
	{
		m_pParent ->m_ctcTree.SetFocus();
	}
	else
	{
		SetFocus();
	}

	COleVariant covParent(csParent);


	CString csError;

	// Pass in
	HTREEITEM hParent;

	if (csParent.GetLength() > 0)
	{
		hParent = pcsParent ? hParentItem : m_pParent -> GetSelection();
	}
	else
	{
		hParent = NULL;
	}


	IWbemClassObject *pimcoNew =
		CreateSimpleClass
		(m_pParent -> GetServices(), &csNewClass, &csParent,
		nReturn, csError);

	if (!pimcoNew)
	{
		OnButtonadd();
		return;
	}

	if (csParent.GetLength() > 0)
	{
		IWbemClassObject *pParent =
			GetClassObject (m_pParent->GetServices(),&csParent);
		if (pParent)
		{
			hParent = m_pParent->m_ctcTree.FindAndOpenObject(pParent);
			pParent->Release();
		}
	}
	else
	{
		hParent = NULL;
	}


	HTREEITEM hNew =
			m_pParent -> GetTree() -> FindObjectinChildren
				(hParent, pimcoNew);

	if (!hParent || !hNew)
	{
		HTREEITEM hItem =
			m_pParent -> GetTree() -> AddTreeObject(hParent, pimcoNew,TRUE);


		TV_INSERTSTRUCT		tvstruct;
		tvstruct.item.hItem = hParent;
		tvstruct.item.mask = TVIF_CHILDREN | TVIF_STATE;
		tvstruct.item.stateMask = TVIS_EXPANDEDONCE;
		tvstruct.item.state = TVIS_EXPANDEDONCE;
		tvstruct.item.cChildren = 1;

		m_pParent -> GetTree() -> SetItem(&tvstruct.item);


		m_pParent -> GetTree() -> Expand(hParent,TVE_EXPAND );
		m_pParent -> GetTree() -> EnsureVisible(hItem );
		m_pParent -> GetTree() -> SelectItem(hItem);
		m_pParent -> GetTree() -> SetFocus();
	}


	csNewClass = GetIWbemFullPath(m_pParent->GetServices(),pimcoNew);
	COleVariant covNewClass(csNewClass);

	if (m_pParent->m_bReadySignal)
	{
		m_pParent -> FireEditExistingClass(covNewClass);
	}

	m_bAdding = FALSE;

#ifdef _DEBUG
	afxDump <<"CBanner::OnButtonadd(): 	m_pParent -> FireEditExistingClass(covNewClass); \n";
	afxDump << "     " << csNewClass << "\n";
#endif

}

// ***************************************************************************
//
// CClassTree::OnButtonDelete
//
// Description:
//	  Delete class button handler.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CBanner::OnButtondelete()
{
	DeleteClass(NULL,NULL);
}

void CBanner::DeleteClass(CString *pcsDeleteClass, HTREEITEM hDeleteItem)
{
	m_pParent -> OnActivateInPlace(TRUE,NULL);

	HTREEITEM hSelection = hDeleteItem ? hDeleteItem : m_pParent -> GetSelection();
	HTREEITEM hParent = m_pParent -> m_ctcTree.GetParentItem(hSelection);
	CString csSelection = pcsDeleteClass ? *pcsDeleteClass : m_pParent -> GetSelectionClassName();

	BOOL bCanChangeSelection = m_pParent -> QueryCanChangeSelection(csSelection);

	if (!bCanChangeSelection)
	{
		if (m_pParent ->m_bRestoreFocusToTree)
		{
			m_pParent ->m_ctcTree.SetFocus();
		}
		else
		{
			SetFocus();
		}
		return;
	}

	m_pParent -> m_ctcTree.SelectItem(hSelection);

	BOOL bSubclasses = HasSubclasses(m_pParent->GetServices(), &csSelection, m_pParent->m_csNameSpace);
	CString csPrompt = _T("Do You Want to Delete the \"");
	csPrompt += csSelection;
	if (bSubclasses)
	{
		csPrompt+= _T("\" class and all its children?");
	}
	else
	{
		csPrompt+= _T("\" class?");
	}
	CString csError;

	int nReturn =
			::MessageBox
			( m_pParent -> GetSafeHwnd(),
			csPrompt,
			_T("Delete Class Query"),
			MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON1 |
			MB_APPLMODAL);

	if (nReturn == IDYES)
	{
		BOOL bReturn =
			DeleteAClass
			(m_pParent -> GetServices(),&csSelection);
		if (bReturn)
		{
			HTREEITEM hPreSibling =
				m_pParent -> GetTree()->GetPrevSiblingItem(hSelection);
			HTREEITEM hSibling =
				m_pParent -> GetTree()->GetNextSiblingItem(hSelection);
			m_pParent -> GetTree()->SetDeleting(TRUE);
			m_pParent -> GetTree() -> DeleteBranch(hSelection,TRUE);
			IWbemClassObject *pItem =
				hSibling ?
				(IWbemClassObject*)
					m_pParent -> GetTree() -> GetItemData(hSibling):
					(hParent ? (IWbemClassObject*)
						m_pParent -> GetTree() -> GetItemData(hParent):
						(hPreSibling? (IWbemClassObject*)
							m_pParent -> GetTree() -> GetItemData(hPreSibling):
						NULL));
			if (pItem)
			{

				if (m_pParent->m_bReadySignal)
				{
					CString csClass =
						GetIWbemFullPath(m_pParent->GetServices(),pItem);
					COleVariant covClass(csClass);
					m_pParent -> FireEditExistingClass(covClass);
				}

			}
			m_pParent -> GetTree()->SetDeleting(FALSE);

		}
	}

	if (m_pParent ->m_bRestoreFocusToTree)
	{
		m_pParent ->m_ctcTree.SetFocus();
	}
	else
	{
		SetFocus();
	}

}

CString CBanner::GetNameSpace()
{
	return m_pnseNameSpace->GetNameSpace();

}

void CBanner::SetNameSpace(CString *pcsNamespace)
{
	m_pnseNameSpace->SetNameSpace(*pcsNamespace);

}

SCODE CBanner::OpenNamespace(CString *pcsNamespace, BOOL boolNoFireEvent)
{
	BOOL bReturn =
		m_pnseNameSpace->OpenNamespace
		(*pcsNamespace,boolNoFireEvent);

	return bReturn;

}

void CBanner::NSEntryRedrawn()
{

	Invalidate();
	m_pParent->InvalidateControl();


}

void CBanner::OnButtonclasssearch()
{
	// TODO: Add your command handler code here

	m_pParent -> OnActivateInPlace(TRUE,NULL);
	m_pParent->OnPopupSearchforclass();

	if (m_pParent ->m_bRestoreFocusToTree)
	{
		m_pParent ->m_ctcTree.SetFocus();
	}
	else
	{
		SetFocus();
	}
}



void CBanner::OnKillFocus(CWnd* pNewWnd)
{
	CWnd::OnKillFocus(pNewWnd);

}

void CBanner::OnSetFocus(CWnd* pOldWnd)
{
	m_pnseNameSpace->SetFocusToEdit();

}

/*	EOF:  banner.cpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\cppgensheet.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// CppGenSheet.h : header file
//
// This class defines custom modal property sheet 
// CCPPGenSheet.
 
#ifndef __CPPGENSHEET_H__
#define __CPPGENSHEET_H__


//#include "MyPropertyPage1.h"

class CCPPWizCtrl;

/////////////////////////////////////////////////////////////////////////////
// CCPPGenSheet

class CCPPGenSheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CCPPGenSheet)

// Construction
public:
	CCPPGenSheet(CCPPWizCtrl* pParentWnd = NULL);
	CCPPWizCtrl *GetLocalParent(){return m_pParent;}
//	INT_PTR DoModal();
// Attributes
public:
	CMyPropertyPage1 m_Page1;
//	CMyPropertyPage2 m_Page2;
	CMyPropertyPage3 m_Page3;
	CMyPropertyPage4 m_Page4;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCPPGenSheet)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCPPGenSheet();

// Generated message map functions
protected:
	//{{AFX_MSG(CCPPGenSheet)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CCPPWizCtrl *m_pParent;
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __CPPGENSHEET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\cppwizctl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// CPPWizCtl.h : Declaration of the CCPPWizCtrl OLE control class.
class CCPPGenSheet;
class CMyPropertyPage1;
class CMyPropertyPage3;
class CMyPropertyPage4;


// Typedef for help ocx hinstance procedure address
typedef HWND (WINAPI *HTMLHELPPROC)(HWND hwndCaller,
								LPCTSTR pszFile,
								UINT uCommand,
								DWORD dwData);


void ErrorMsg
				(CString *pcsUserMsg, 
				SCODE sc, 
				IWbemClassObject *pErrorObject,
				BOOL bLog, 
				CString *pcsLogMsg, 
				char *szFile, 
				int nLine,
				BOOL bNotification = FALSE,
				UINT uType = MB_ICONEXCLAMATION);

void LogMsg
				(CString *pcsLogMsg, 
				char *szFile, 
				int nLine);

/////////////////////////////////////////////////////////////////////////////
// CCPPWizCtrl : See CPPWizCtl.CPP for implementation.

class CCPPWizCtrl : public COleControl
{
	DECLARE_DYNCREATE(CCPPWizCtrl)

// Constructor
public:
	CCPPWizCtrl();
	CString &GetProviderBaseName() {return m_csProviderBaseName;}
	CString &GetProviderDescription() {return m_csProviderDescription;}
	CStringArray &GetClasses(){return m_csaClassNames;}
	CStringArray &GetClassBaseNames(){return m_csaClassBaseNames;}
	CStringArray &GetClassCPPNames(){return m_csaClassCPPNames;}
	CStringArray &GetClassDescriptions()
		{return m_csaClassDescriptions;}
	CString &GetProviderOutputPath() {return m_csProviderOutputPath;}
	CString &GetProviderTLBPath() {return m_csProviderTLBPath;}
	CStringArray *&GetNonLocalProps() {return m_pcsaNonLocalProps;}
	CByteArray &GetInheritedPropIndicators() {return m_cbaInheritedPropIndicators;}
	IWbemServices *GetServices(){return m_pServices;}
	CString& GetNamespace() {return m_csNameSpace; }
	
	HRESULT GetSDKDirectory(CString &sHmomWorkingDir);
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCPPWizCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

	virtual void OnSetClientSite();

// Implementation
protected:
	~CCPPWizCtrl();
	CString m_csNameSpace;
	DECLARE_OLECREATE_EX(CCPPWizCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CCPPWizCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CCPPWizCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CCPPWizCtrl)		// Type name and misc status

	CString m_csUUID;

	CToolTipCtrl m_ttip;

	BOOL m_bInitDraw;
	HICON m_hCPPWiz;
	HICON m_hCPPWizSel;
	CImageList *m_pcilImageList;
	int m_nImage;

	BOOL m_bYesAll;
	BOOL m_bNoAll;
	
	IWbemServices *m_pServices;
	IWbemServices *InitServices
		(CString *pcsNameSpace);
	IWbemServices *GetIWbemServices(CString &rcsNamespace);

	SCODE m_sc;
	BOOL m_bUserCancel;


	BOOL OnWizard(CStringArray *pcsaClasses);
	CCPPGenSheet *m_pcgsPropertySheet;
	CString m_csProviderBaseName;
	CString m_csProviderDescription;
	CString m_csProviderOutputPath;
	CString m_csProviderTLBPath;
	CStringArray m_csaClassNames;
	CStringArray m_csaClassBaseNames;
	CStringArray m_csaClassCPPNames;
	CStringArray m_csaClassDescriptions;
	CStringArray *m_pcsaNonLocalProps;
	CByteArray m_cbaInheritedPropIndicators;

	BOOL bNewOnly;

	BOOL GenCPP(DWORD dwProvider, IWbemClassObject *pObject, int nIndex);
	CStringArray *GetPropNames
				(IWbemClassObject * pClass, 
				BOOL bNonSystem = FALSE);
	CStringArray *GetLocalPropNames
				(IWbemClassObject * pClass, 
				BOOL bNonSystem = FALSE);
	CStringArray *GetNonLocalPropNames
		(IWbemClassObject * pClass, BOOL bNonSystem);
	BOOL AttribInAttribSet
				(IWbemQualifierSet *pAttrib , CString *pcsAttrib);
	COleVariant GetPropertyValueByAttrib
				(IWbemClassObject *pObject ,  CString *pcsAttrib);
	CString GetPropertyNameByAttrib
				(IWbemClassObject *pObject , CString *pcsAttrib);
	DWORD PropertyAttribFlags(IWbemQualifierSet *pAttrib);
	BOOL IsSystemProperty(CString *pcsProp);
	COleVariant GetProperty
				(IWbemServices * pProv, 
				IWbemClassObject * pInst, 
				CString *pcsProperty);
	CString GetIWbemFullPath(IWbemClassObject *pClass);


	void InvokeHelp();

	void ReleaseErrorObject(IWbemClassObject *&rpErrorObject);

	SCODE MakeSafeArray(SAFEARRAY FAR ** pRet, VARTYPE vt, int iLen);
	SCODE PutStringInSafeArray
		(SAFEARRAY FAR * psa,CString *pcs, int iIndex);
	SCODE CCPPWizCtrl::GetStringFromSafeArray
		(SAFEARRAY FAR * psa,CString *pcs, int iIndex);

	CString GetClassName(IWbemClassObject *pClass);
	CString GetSuperClassCPPName(IWbemClassObject *pClass);
	CString GetSuperClassName(IWbemClassObject *pClass);
	CString GetBSTRProperty 
		(IWbemClassObject * pInst, CString *pcsProperty);

	//CString GetFolder();
	BOOL StringInCSA
		(CStringArray *csaSearchIn,CString *csSearchFor);

	DWORD GetControlFlags();

	void RelayEvent(UINT message, WPARAM wParam, LPARAM lParam);

	long GetPropType(IWbemClassObject *pObject,CString *pcsProp,unsigned short &uType);

	BOOL HasDateTimeSyntax
		(IWbemClassObject *pClassInt,CString *pcsPropName);

	long GetAttribBool
		(IWbemClassObject * pClassInt,
		CString *pcsPropName, 
		CString *pcsAttribName, 
		BOOL &bReturn);

	long SetAttribBool
		(IWbemClassObject * pClassInt,
		CString *pcsPropName, 
		CString *pcsAttribName, 
		BOOL bValue);

	long GetAttribBSTR
		(IWbemClassObject * pClassInt,
		CString *pcsPropName, 
		CString *pcsAttribName, 
		CString &csReturn);

	long SetAttribBSTR
		(IWbemClassObject * pClassInt,
		CString *pcsPropName, 
		CString *pcsAttribName, 
		CString *pcsValue);

	BOOL CreateProviderInstance();

	CString CreateUUID(void);

	BOOL UpdateClassQualifiers(IWbemClassObject *pClass);
	BOOL CheckForProviderQuals
			(IWbemClassObject *pClass, CString &rcsProvider);
	BOOL CreateInstanceProviderRegistration(CString &rcsPath);
	BOOL CreateMethodProviderRegistration(CString &rcsPath);

	VOID FormatPathForRAIDItem20918(CString *pcsPath);
	
// Message maps
	//{{AFX_MSG(CCPPWizCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnMove(int x, int y);
	//}}AFX_MSG
	afx_msg long FireGenerateCPPMessage (UINT uParam, LONG lParam);
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CCPPWizCtrl)
	afx_msg VARIANT GetCPPTargets();
	afx_msg void SetCPPTargets(const VARIANT FAR& newValue);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CCPPWizCtrl)
	void FireGenerateCPPs()
		{FireEvent(eventidGenerateCPPs,EVENT_PARAM(VTS_NONE));}
	void FireGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
		{FireEvent(eventidGetIWbemServices,EVENT_PARAM(VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT), lpctstrNamespace, pvarUpdatePointer, pvarServices, pvarSC, pvarUserCancel);}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CCPPWizCtrl)
	dispidCPPTargets = 1L,
	eventidGenerateCPPs = 1L,
	eventidGetIWbemServices = 2L,
	//}}AFX_DISP_ID
	};
	friend class CMyPropertyPage1;
	friend class CMyPropertyPage3;
	friend class CMyPropertyPage4;

private:
	void StripNewLines(CString& sDst, LPCTSTR pszDescription);
	void SanitizePropSetBaseName(CString& sDst);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\cppwiz.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// CPPWiz.cpp : Implementation of CCPPWizApp and DLL registration.

#include "precomp.h"
#include "CPPWiz.h"
#include "CatHelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CCPPWizApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x35e9cbd0, 0x3911, 0x11d0, { 0x8f, 0xbd, 0, 0xaa, 0, 0x6d, 0x1, 0xa } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const GUID CDECL BASED_CODE _ctlid =   { 0x35e9cbd3, 0x3911, 0x11d0,
           { 0x8f, 0xbd, 0, 0xaa, 0, 0x6d, 0x1, 0xa} };


const CATID CATID_SafeForScripting     =
   {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing  =
   {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
////////////////////////////////////////////////////////////////////////////
// CCPPWizApp::InitInstance - DLL initialization

BOOL CCPPWizApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CCPPWizApp::ExitInstance - DLL termination

int CCPPWizApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	if (FAILED( CreateComponentCategory(CATID_SafeForScripting,
               L"Controls that are safely scriptable") ))
             return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( CreateComponentCategory(
           CATID_SafeForInitializing,
           L"Controls safely initializable from persistent data") ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForScripting) ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForInitializing) ))
         return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\cppwizppg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// CPPWizPpg.cpp : Implementation of the CCPPWizPropPage property page class.

#include "precomp.h"
#include "CPPWiz.h"
#include "CPPWizPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCPPWizPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCPPWizPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CCPPWizPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCPPWizPropPage, "WBEM.CPPWizPropPage.1",
	0x35e9cbd4, 0x3911, 0x11d0, 0x8f, 0xbd, 0, 0xaa, 0, 0x6d, 0x1, 0xa)


/////////////////////////////////////////////////////////////////////////////
// CCPPWizPropPage::CCPPWizPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CCPPWizPropPage

BOOL CCPPWizPropPage::CCPPWizPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_CPPWIZ_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CCPPWizPropPage::CCPPWizPropPage - Constructor

CCPPWizPropPage::CCPPWizPropPage() :
	COlePropertyPage(IDD, IDS_CPPWIZ_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CCPPWizPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT

}


/////////////////////////////////////////////////////////////////////////////
// CCPPWizPropPage::DoDataExchange - Moves data between page and properties

void CCPPWizPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CCPPWizPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CCPPWizPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\cppwizctl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// CPPWizCtl.CPP : Implementation of the CCPPWizCtrl OLE control class.

#include "precomp.h"
#include <afx.h>
#include <rpc.h>
#include "resource.h"
#include <SHLOBJ.H>
#include <fstream.h>
#include <nddeapi.h>
#include <initguid.h>
#include "wbemidl.h"
#include "moengine.h"
#include <afxcmn.h>
#include "WrapListCtrl.h"
#include "hlb.h"
#include "MyPropertyPage1.h"
#include "CppGenSheet.h"
#include "CPPWiz.h"
#include "CPPWizCtl.h"
#include "CPPWizPpg.h"
#include "MsgDlgExterns.h"
#include "WbemRegistry.h"
#include "ReplaceProviderQuery.h"
#include "htmlhelp.h"
#include "HTMTopics.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif




#define FIREGENERATECPP WM_USER + 735


extern CCPPWizApp NEAR theApp;


IMPLEMENT_DYNCREATE(CCPPWizCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCPPWizCtrl, COleControl)
	//{{AFX_MSG_MAP(CCPPWizCtrl)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_LBUTTONUP()
	ON_WM_DESTROY()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_MOUSEMOVE()
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	ON_WM_ERASEBKGND()
	ON_WM_MOVE()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
	ON_MESSAGE(FIREGENERATECPP, FireGenerateCPPMessage )
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CCPPWizCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CCPPWizCtrl)
	DISP_PROPERTY_EX(CCPPWizCtrl, "CPPTargets", GetCPPTargets, SetCPPTargets, VT_VARIANT)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CCPPWizCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CCPPWizCtrl, COleControl)
	//{{AFX_EVENT_MAP(CCPPWizCtrl)
	EVENT_CUSTOM("GenerateCPPs", FireGenerateCPPs, VTS_NONE)
	EVENT_CUSTOM("GetIWbemServices", FireGetIWbemServices, VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CCPPWizCtrl, 1)
	PROPPAGEID(CCPPWizPropPage::guid)
END_PROPPAGEIDS(CCPPWizCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCPPWizCtrl, "WBEM.CPPWizCtrl.1",
	0x35e9cbd3, 0x3911, 0x11d0, 0x8f, 0xbd, 0, 0xaa, 0, 0x6d, 0x1, 0xa)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CCPPWizCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DCPPWiz =
		{ 0x35e9cbd1, 0x3911, 0x11d0, { 0x8f, 0xbd, 0, 0xaa, 0, 0x6d, 0x1, 0xa } };
const IID BASED_CODE IID_DCPPWizEvents =
		{ 0x35e9cbd2, 0x3911, 0x11d0, { 0x8f, 0xbd, 0, 0xaa, 0, 0x6d, 0x1, 0xa } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwCPPWizOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CCPPWizCtrl, IDS_CPPWIZ, _dwCPPWizOleMisc)

//////////////////////////////////////////////////////////////////////////////
// Global variables

long gCountWizards = 0;



int StringCmp(const void *pc1,const void *pc2)
{
	CString *pcs1 = reinterpret_cast<CString*>(const_cast<void *>(pc1));
	CString *pcs2 = reinterpret_cast<CString*>(const_cast<void *>(pc2));

	int nReturn = pcs1->CompareNoCase(*pcs2);
	return nReturn;


}

void SortCStringArray(CStringArray &rcsaArray)
{
	int i;
	int nSize = (int) rcsaArray.GetSize();

	CString *pArray = new CString [nSize];

	for (i = 0; i < nSize; i++)
	{
		pArray[i] = rcsaArray.GetAt(i);
	}

	qsort( (void *)pArray, nSize, sizeof(CString), StringCmp );

	rcsaArray.RemoveAll();

	for (i = 0; i < nSize; i++)
	{
		 rcsaArray.Add(pArray[i]);
	}

	delete [] pArray;
}

void ErrorMsg
(CString *pcsUserMsg, SCODE sc, IWbemClassObject *pErrorObject, BOOL bLog, CString *pcsLogMsg,
 char *szFile, int nLine, BOOL bNotification, UINT uType)
{
	HWND hFocus = ::GetFocus();

//	::SendMessage(hFocus,WM_KILLFOCUS,0,0);

	CString csCaption = _T("Provider Wizard Message");
	BOOL bUseErrorObject = sc != S_OK;

	BSTR bstrTemp1 = csCaption.AllocSysString();
	BSTR bstrTemp2 = pcsUserMsg->AllocSysString();
	DisplayUserMessage
		(bstrTemp1,bstrTemp2,
		sc,bUseErrorObject,uType);
	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);


	SetFocus(hFocus);

	if (bLog)
	{
		LogMsg(pcsLogMsg,  szFile, nLine);

	}

}

void LogMsg
(CString *pcsLogMsg, char *szFile, int nLine)
{


}

int CreateAndInitVar(CString csIn,char *&szOut)
{
	int nSize = (csIn.GetLength() + 1) * sizeof (TCHAR);
	szOut = new char[nSize];
	memset(szOut, 0, nSize);
	BSTR bstrTmp =  csIn.AllocSysString();
	if (csIn.IsEmpty() || !bstrTmp)
	{
		return 1;
	}
	else
	{
		int n = WideCharToMultiByte(CP_ACP, 0,
							bstrTmp , csIn.GetLength(),
							szOut, nSize - 1,
							NULL, NULL);
		SysFreeString(bstrTmp);
		return n;
	}

}

void DeleteVar(char *&szIn)
{
	delete [] szIn;
	szIn = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CCPPWizCtrl::CCPPWizCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CCPPWizCtrl

BOOL CCPPWizCtrl::CCPPWizCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to afxRegInsertable.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_CPPWIZ,
			IDB_CPPWIZ,
			afxRegInsertable | afxRegApartmentThreading,
			_dwCPPWizOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


CCPPWizCtrl::CCPPWizCtrl()
{
	InitializeIIDs(&IID_DCPPWiz, &IID_DCPPWizEvents);
	SetInitialSize (19, 16);
	m_bInitDraw = TRUE;
	m_pcilImageList = NULL;
	m_nImage = 0;
	m_pServices = NULL;
	m_pcgsPropertySheet = NULL;
	m_pcsaNonLocalProps = NULL;
	m_bYesAll = FALSE;
	m_bNoAll = FALSE;

}


/////////////////////////////////////////////////////////////////////////////
// CCPPWizCtrl::~CCPPWizCtrl - Destructor

CCPPWizCtrl::~CCPPWizCtrl()
{
	if (m_pServices)
	{
		m_pServices -> Release();
	}

	if (m_pcsaNonLocalProps)
	{
		delete [] m_pcsaNonLocalProps;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CCPPWizCtrl::OnDraw - Drawing function

void CCPPWizCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{

#ifdef _DEBUG
	afxDump << _T("CCPPWizCtrl::OnDraw\n");
#endif

	if (m_bInitDraw)
	{
		m_bInitDraw = FALSE;
		HICON m_hCPPWiz  = theApp.LoadIcon(IDI_ICONCPPWIZ16);
		HICON m_hCPPWizSel  = theApp.LoadIcon(IDI_ICONCPPWIZSEL16);

		m_pcilImageList = new CImageList();

		m_pcilImageList ->
			Create(32, 32, TRUE, 2, 2);

		int iReturn = m_pcilImageList -> Add(m_hCPPWiz);

		iReturn = m_pcilImageList -> Add(m_hCPPWizSel);

	}



	POINT pt;
	pt.x=0;
	pt.y=0;


#ifdef _DEBUG
	afxDump << "m_nImage = " << m_nImage << "\n";
#endif
	// This is needed for transparency and the correct drawing...
	m_pcilImageList -> Draw(pdc, m_nImage, pt, ILD_TRANSPARENT);
}


/////////////////////////////////////////////////////////////////////////////
// CCPPWizCtrl::DoPropExchange - Persistence support

void CCPPWizCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

}


/////////////////////////////////////////////////////////////////////////////
// CCPPWizCtrl::OnResetState - Reset control to default state

void CCPPWizCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CCPPWizCtrl::AboutBox - Display an "About" box to the user

void CCPPWizCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_CPPWIZ);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CCPPWizCtrl::PreCreateWindow - Modify parameters for CreateWindowEx

BOOL CCPPWizCtrl::PreCreateWindow(CREATESTRUCT& cs)
{
	// Add the Transparent style to the control
	// This is needed for transparency and the correct drawing...
	cs.dwExStyle |= WS_EX_TRANSPARENT;

	return COleControl::PreCreateWindow(cs);
}




int CCPPWizCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (AmbientUserMode( ))
	{
		m_pServices = NULL;

		if (m_ttip.Create(this))
		{
			m_ttip.Activate(TRUE);
			m_ttip.AddTool(this,_T("Provider Code Generator"));
		}

	}

	return 0;
}


void CCPPWizCtrl::OnSize(UINT nType, int cx, int cy)
{
	COleControl::OnSize(nType, cx, cy);


}

SCODE CCPPWizCtrl::MakeSafeArray(SAFEARRAY FAR ** pRet, VARTYPE vt, int iLen)
{
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iLen;
    *pRet = SafeArrayCreate(vt,1, rgsabound);
    return (*pRet == NULL) ? 0x80000001 : S_OK;
}

SCODE CCPPWizCtrl::PutStringInSafeArray
(SAFEARRAY FAR * psa,CString *pcs, int iIndex)
{
    long ix[2];
    ix[1] = 0;
    ix[0] = iIndex;
    HRESULT hResult = SafeArrayPutElement(psa,ix,pcs -> AllocSysString());
	return GetScode(hResult);
}

SCODE CCPPWizCtrl::GetStringFromSafeArray
(SAFEARRAY FAR * psa,CString *pcs, int iIndex)
{
	BSTR String;
    long ix[2];
    ix[1] = 0;
    ix[0] = iIndex;
    HRESULT hResult = SafeArrayGetElement(psa,ix,&String);
	*pcs = String;
	SysFreeString(String);
	return GetScode(hResult);
}


VARIANT CCPPWizCtrl::GetCPPTargets()
{
	VARIANT vaResult;
	VariantInit(&vaResult);

	int nTargets = (int) m_csaClassNames.GetSize();

	SAFEARRAY *psaTargets;
	MakeSafeArray (&psaTargets, VT_BSTR, nTargets + 1);

	// first elem is the NS.
	PutStringInSafeArray (psaTargets, &m_csNameSpace, 0);

	// 1 to x are classNames.
	for (int i = 0; i < nTargets; i++)
	{
		PutStringInSafeArray (psaTargets, &m_csaClassNames.GetAt(i), i + 1);
	}

	vaResult.vt = VT_ARRAY | VT_BSTR;
	vaResult.parray = psaTargets;
	return vaResult;
}




//**********************************************************************
// CCPPWizCtrl::StripNewLines
//
// Strip carriage return linefeeds from a string by converting them to
// to space characters.
//
// Parameters:
//		[out] CString& sDst
//			The transformed string is returned here.
//
//		[in] LPCTSTR pszSrc
//			A pointer to the source string to convert.
//
// Returns:
//		Nothing.
//
//***********************************************************************
void CCPPWizCtrl::StripNewLines(CString& sDst, LPCTSTR pszSrc)
{
	const int nchSrc = _tcslen(pszSrc);

	LPTSTR pszDst = sDst.GetBuffer(nchSrc + 1);
	while(*pszSrc) {
		if (*pszSrc==_T('\r') && *(pszSrc+1) == _T('\n')) {
			// Convert the carriage return-linefeed to a space character.
			pszSrc += 2;
			*pszDst++ = _T(' ');
		}
		else {
			// Just copy the character to the destination string
			*pszDst++ = *pszSrc++;
		}
	}
	*pszDst = 0;
	sDst.ReleaseBuffer( );
}


void CCPPWizCtrl::SetCPPTargets(const VARIANT FAR& newValue)
{


	int n = (int) m_csaClassNames.GetSize();

	m_csaClassNames.RemoveAt(0,n);

	WORD test = VT_ARRAY|VT_BSTR;

	if(newValue.vt == test)
	{
		long ix[2] = {0,0};
		long lLower, lUpper;

		int iDim = SafeArrayGetDim(newValue.parray);
		SCODE sc = SafeArrayGetLBound(newValue.parray,1,&lLower);
		sc = SafeArrayGetUBound(newValue.parray,1,&lUpper);
		CString csPath;
		CString csFile;
		// If only one element it is the namespace.
		if (lUpper == 0)
		{
			CString csUserMsg =
					_T("There are no classes selected.  You must check the checkbox next to a class in the Class Tree in order to select it.");
			ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__);
			return;
		}


		ix[0] = lLower++;
		GetStringFromSafeArray
				(newValue.parray,&m_csNameSpace, ix[0]);

		m_pServices = InitServices(&m_csNameSpace);
		if (!m_pServices)
		{
			CString csUserMsg =
					_T("ConnectServer failure for ") + m_csNameSpace;
			ErrorMsg
					(&csUserMsg, m_sc, NULL, TRUE, &csUserMsg, __FILE__,
							__LINE__ - 8);
			return;
		}

		CStringArray csaSystemClassNames;

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
		{
			GetStringFromSafeArray
				(newValue.parray,&csPath, ix[0]);
			IWbemClassObject *pErrorObject = NULL;
			IWbemClassObject *phmmcoObject = NULL;
			BSTR bstrTemp = csPath.AllocSysString();
			SCODE sc =
			m_pServices ->
				GetObject
					(bstrTemp,0,NULL,&phmmcoObject,NULL);
			::SysFreeString(bstrTemp);
			if (sc == S_OK)
			{
				CString csClass = GetClassName(phmmcoObject);
				ReleaseErrorObject(pErrorObject);
				if (csClass[0] == '_' &&  csClass[1] == '_')
				{
					csaSystemClassNames.Add(csClass);
					/*CString csUserMsg =
						_T("Cannot generate CPP for system class ")
							+ csPath;
					ErrorMsg
							(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
							__LINE__ - 13);*/
				}
				else
				{
					m_csaClassNames.Add(csClass);
				}
				phmmcoObject -> Release();
			}
			else
			{
				CString csUserMsg;
				csUserMsg =  _T("Cannot get object ") + csPath;
				ErrorMsg
						(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__,
						__LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
			}
		}

		if (csaSystemClassNames.GetSize() > 0)
		{

			if (m_csaClassNames.GetSize() == 0)
			{
				CString csUserMsg =
					_T("Only system classes (classes which begin with \"__\") are selected: Cannot generate a provider for a system class.  You must select one or more non-system class.");
				ErrorMsg
						(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
						__LINE__);
				m_pServices->Release();
				m_pServices = NULL;
				SetFocus();
				return;
			}
			else
			{
				CString csUserMsg =
					_T("There are system classes (classes which begin with \"__\") selected: Cannot generate a provider for a system class.  A provider will be generated for the non-system classes.");
				ErrorMsg
						(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
						__LINE__);


			}

		}

		if (m_csaClassNames.GetSize() == 0 ||
			!OnWizard(&m_csaClassNames))
		{
			m_pServices->Release();
			m_pServices = NULL;
			SetFocus();
			return;
		}

		m_csUUID = CreateUUID();

		BOOL bCreatedProvInstance = FALSE;

		if (m_csUUID.CompareNoCase(_T("NULL UUID")) == 0)
		{
			m_csUUID.Empty();
			CString csUserMsg;
			csUserMsg =  _T("Unable to create a UUID for the provider:  Cannot create __Win32Provider instance or create class qualifiers on provided classes.");
			ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ );

		}
		else
		{
			bCreatedProvInstance = CreateProviderInstance();

		}

		DWORD dwReturn;

		CString csTempProviderDescription;
		StripNewLines(csTempProviderDescription, m_csProviderDescription);

		DWORD dwProvider =
			MOProviderOpen
			(m_csProviderBaseName ,
			csTempProviderDescription,
			m_csProviderOutputPath,
			m_csProviderTLBPath,
			NULL,
			m_csUUID.IsEmpty()?NULL:(LPCWSTR)m_csUUID);

		if (dwProvider == MO_INVALID_ID)
		{
			CString csUserMsg;
			csUserMsg =  _T("Cannot open the MO provider ");
			ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ - 10);
			m_pServices->Release();
			m_pServices = NULL;
			SetFocus();
			return;
		}

		int nClasses = (int) m_csaClassNames.GetSize();
		int i;

		for(i = 0; i < nClasses; i++)
		{
			CString csClass = m_csaClassNames.GetAt(i);
			IWbemClassObject *phmmcoObject = NULL;
			IWbemClassObject *pErrorObject = NULL;

			BSTR bstrTemp = csClass.AllocSysString();
			SCODE sc =
			m_pServices ->
				GetObject
					(bstrTemp,0,NULL, &phmmcoObject,NULL);
			::SysFreeString(bstrTemp);

			if (sc == S_OK)
			{
				BOOL bReturn = GenCPP(dwProvider, phmmcoObject,i);
				if (bCreatedProvInstance && bReturn)
				{
					BOOL bUpdatedClass =
						UpdateClassQualifiers(phmmcoObject);
				}
				phmmcoObject -> Release();
				ReleaseErrorObject(pErrorObject);
			}
			else
			{
				CString csUserMsg;
				csUserMsg =  _T("Cannot get object ") + csPath;
				ErrorMsg
						(&csUserMsg, sc,pErrorObject,TRUE, &csUserMsg, __FILE__,
						__LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
			}

		}

		dwReturn = MOProviderClose(dwProvider,TRUE);

		if (dwReturn != S_OK)
		{
			CString csUserMsg;
			csUserMsg =
				_T("An unspecified error occurred while writing the generated files. Generation aborted.");
			ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ - 8, FALSE, MB_ICONSTOP);
			MOProviderCancel(dwProvider);

		}
		else
		{
				CString csUserMsg;
				csUserMsg =  _T("Generation of files complete");
				ErrorMsg
						(&csUserMsg, S_OK, NULL, FALSE, NULL, __FILE__,
						__LINE__, TRUE, MB_ICONINFORMATION);

		}
		m_pServices->Release();
		m_pServices = NULL;

	}

	SetFocus();
	SetModifiedFlag();
}



//***************************************************************************
//
// InitServices
//
// Purpose: Initialized the namespace.
//
//***************************************************************************
IWbemServices *CCPPWizCtrl::InitServices
(CString *pcsNameSpace)
{

    IWbemServices *pSession = 0;
    IWbemServices *pChild = 0;


	CString csObjectPath;

    // hook up to default namespace
	if (pcsNameSpace == NULL)
	{
		csObjectPath = _T("root\\cimv2");
	}
	else
	{
		csObjectPath = *pcsNameSpace;
	}

    CString csUser = _T("");

    pSession = GetIWbemServices(csObjectPath);

    return pSession;
}

void CCPPWizCtrl::OnDestroy()
{
	COleControl::OnDestroy();

	delete m_pcilImageList;
	delete m_pcgsPropertySheet;

}

void CCPPWizCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default
	RelayEvent(WM_LBUTTONDOWN, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));

}

void CCPPWizCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	SetFocus();
	OnActivateInPlace(TRUE,NULL);
	RelayEvent(WM_LBUTTONUP, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));

}

void CCPPWizCtrl::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	FireGenerateCPPMessage(0,0);
}


long CCPPWizCtrl::FireGenerateCPPMessage (UINT uParam, LONG lParam)
{

	FireGenerateCPPs();
	InvalidateControl();
	return 0;
}

CString CCPPWizCtrl::GetClassName(IWbemClassObject *pClass)
{

	CString csProp = _T("__Class");
	return GetBSTRProperty(pClass,&csProp);


}

CString CCPPWizCtrl::GetSuperClassName(IWbemClassObject *pClass)
{

	CString csProp = _T("__SuperClass");
	return GetBSTRProperty(pClass,&csProp);


}

CString CCPPWizCtrl::GetSuperClassCPPName(IWbemClassObject *pClass)
{
	CString csSuperClassCPPName;

	return csSuperClassCPPName;
/*
	CString csProp = _T("__SuperClass");
	CString csSuperClass = GetBSTRProperty(pClass,&csProp);

	int i;
	for (i = 0; i < m_csaClassNames.GetSize();i++)
	{
		CString csClass = m_csaClassNames.GetAt(i);
		if (csSuperClass.CompareNoCase(csClass) == 0)
		{
			return m_csaClassCPPNames.GetAt(i);

		}

	}

	return csSuperClassCPPName;
*/

}

CString CCPPWizCtrl::GetBSTRProperty
(IWbemClassObject * pInst, CString *pcsProperty)
{
	SCODE sc;
	CString csOut;

    VARIANTARG var;
	VariantInit(&var);
    long lType;
	long lFlavor;


	BSTR bstrTemp = pcsProperty -> AllocSysString ( );
    sc = pInst->Get( bstrTemp ,0,&var,&lType,&lFlavor);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		return csOut;
	}


	if (var.vt == VT_BSTR)
		csOut = var.bstrVal;

	VariantClear(&var);
	return csOut;
}



void CCPPWizCtrl::SanitizePropSetBaseName(CString &sDst)
{
	sDst.Replace(_T(' '), _T('_'));
}




BOOL CCPPWizCtrl::GenCPP
(DWORD dwProvider, IWbemClassObject *pObject, int nIndex)
{

	CString csClass = m_csaClassNames.GetAt(nIndex);
 	CString csSuperClass = GetSuperClassCPPName(pObject);
	CString csBaseName =  m_csaClassBaseNames.GetAt(nIndex);
	CString csClassCPPName = m_csaClassCPPNames.GetAt(nIndex);
	CString csClassDescription = m_csaClassDescriptions.GetAt(nIndex);

#ifdef _DEBUG
			afxDump << "***  Class = " << csClass <<  "\n";
#endif


	// Replace spaces with '_'
	SanitizePropSetBaseName(csBaseName);

	DWORD dwClass =
		MOPropSetOpen
			(dwProvider,
			csBaseName,
			csClassDescription,
			csClass,
			NULL,
			csClassCPPName,
			csSuperClass.IsEmpty()? NULL: (LPCWSTR)csSuperClass);


	if (dwClass == MO_INVALID_ID)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot do MOPropSetOpen for object ");
		csUserMsg += csClass;
		csUserMsg +=  _T(":  Class provider qualifiers will not be added to the class.");
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 9);
		 return NULL;
	}

	SCODE sc;
	int nProps;
	// This will be able to provide only the names introduced at this
	// subclass level, not including inhertied names.

	CStringArray csaProps;

	csaProps.Append(m_pcsaNonLocalProps[nIndex]);
	CStringArray *pcsaProps = GetLocalPropNames(pObject,TRUE);
	csaProps.Append(*pcsaProps);

	delete pcsaProps;
	pcsaProps = &csaProps;

	nProps =  (pcsaProps) ? (int) pcsaProps -> GetSize() : 0;
	int i;
	IWbemQualifierSet * pAttrib = NULL;
	CString csTmp;
	BOOL bBreak = FALSE;

	for (i = 0; i < nProps; i++)
	{
		unsigned short uType;
		HRESULT hr = GetPropType(pObject,&(pcsaProps -> GetAt(i)),uType);
#ifdef _DEBUG
			afxDump << "***  uType = " << uType << "\n";
#endif

		if (hr != S_OK)
		{
			CString csUserMsg;
			csUserMsg =  _T("Cannot get property type for ") + csClass;
			ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ - 8);
		}
		else
		{
			DWORD dwType = 0;
			if (uType == VT_BOOL)
			{
				dwType = MO_PROPTYPE_BOOL;
			}
			else  if (uType == VT_I4 || uType == VT_I2 || uType == VT_UI1)
			{
				dwType = MO_PROPTYPE_DWORD;

			}
			// will need to add check for syntax qualifier
			else if (uType == CIM_DATETIME)
			{
				dwType = MO_PROPTYPE_DATETIME;

			}
			// will need to add check for syntax qualifier
			else if (uType == VT_BSTR)
			{
				dwType = MO_PROPTYPE_CHString;

			}
			pAttrib = NULL;

			BSTR bstrTemp = pcsaProps -> GetAt(i).AllocSysString();
			sc = pObject->GetPropertyQualifierSet
							(bstrTemp,
							&pAttrib);
			::SysFreeString(bstrTemp);

			if (sc != S_OK)
			{
				CString csUserMsg;
				csUserMsg =  _T("Cannot get property qualifier set ");
				csUserMsg += pcsaProps -> GetAt(i) + _T(" for object ");
				csUserMsg += GetIWbemFullPath (pObject);
				csUserMsg += _T(" property ") + pcsaProps -> GetAt(i);
				ErrorMsg
						(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
						__LINE__ - 12);
			}


			DWORD dwFlags = PropertyAttribFlags(pAttrib);
			pAttrib -> Release();
			pAttrib = NULL;
			CString csProp = pcsaProps -> GetAt(i);

			DWORD dwReturn =
				MOPropertyAdd
				(dwProvider,dwClass, csProp,
					csProp, NULL, NULL, dwType, dwFlags);

#ifdef _DEBUG
			afxDump << "***  Prop and name = " << csProp << " with dwType = " << dwType << "\n";
#endif
			//DWORD dwReturn =
			//	MOPropertyAdd
			//	(dwProvider,dwClass, (LPCSTR) pcsaProps -> GetAt(i),
			//		(LPCSTR) pcsaProps -> GetAt(i), NULL, NULL, dwType, dwFlags);
			if (dwReturn != MO_SUCCESS)
			{
				CString csUserMsg;
				csUserMsg =  _T("Cannot do MOPropertyAdd ");
				csUserMsg += pcsaProps -> GetAt(i) + _T(" for object ");
				csUserMsg += GetIWbemFullPath (pObject);
				csUserMsg += _T(" property ") + pcsaProps -> GetAt(i);
				ErrorMsg
						(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
						__LINE__ - 12);
			}
		}

	}


	return TRUE;
}

CStringArray *CCPPWizCtrl::GetPropNames
(IWbemClassObject * pClass, BOOL bNonSystem)
{
	CStringArray *pcsaReturn = NULL;
	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;

	VARIANTARG var;
	VariantInit(&var);
	CString csNull;


    sc = pClass->GetNames(NULL,0,NULL,&psa);

    if(sc == S_OK)
	{
       int iDim = SafeArrayGetDim(psa);
	   int i;
       sc = SafeArrayGetLBound(psa,1,&lLower);
       sc = SafeArrayGetUBound(psa,1,&lUpper);
	   pcsaReturn = new CStringArray;
       for(ix[0] = lLower, i = 0; ix[0] <= lUpper; ix[0]++, i++)
	   {
           BOOL bClsidSetForProp = FALSE;
           BSTR PropName;
           sc = SafeArrayGetElement(psa,ix,&PropName);
		   if (sc == S_OK)
		   {
			CString csProp = PropName;
			if (!bNonSystem || !IsSystemProperty(&csProp))
			{
				pcsaReturn -> Add(csProp);
			}
			SysFreeString(PropName);
		   }
	   }
	}
	else
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get names for ")
						+  GetIWbemFullPath (pClass);
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 32);
	}


	SafeArrayDestroy(psa);

	return pcsaReturn;
}

CStringArray *CCPPWizCtrl::GetLocalPropNames
(IWbemClassObject * pClass, BOOL bNonSystem)
{
	CStringArray *pcsaClassProps = GetPropNames(pClass,bNonSystem);

	CString csSuperClass = GetSuperClassName(pClass);

	if (!csSuperClass.IsEmpty())
	{
		IWbemClassObject *phmmcoSuper = NULL;
		IWbemClassObject *pErrorObject = NULL;

		BSTR bstrTemp = csSuperClass.AllocSysString();
		SCODE sc =
			m_pServices ->
				GetObject
					(bstrTemp,0,NULL,&phmmcoSuper,NULL);
		::SysFreeString(bstrTemp);

		if (sc != S_OK)
		{
			CString csUserMsg;
			csUserMsg =  _T("Cannot get object ") + csSuperClass;
			ErrorMsg
						(&csUserMsg, sc,pErrorObject,TRUE, &csUserMsg, __FILE__,
						__LINE__ - 8);
			ReleaseErrorObject(pErrorObject);
			return NULL;
		}
		else
		{
			ReleaseErrorObject(pErrorObject);
			CStringArray *pcsaSuperProps =
				GetPropNames(phmmcoSuper,bNonSystem);
			CStringArray *pcsaReturn = new CStringArray;
			for (int i = 0 ; i < pcsaClassProps->GetSize(); i++)
			{
				if (!StringInCSA(pcsaSuperProps,&pcsaClassProps->GetAt(i)))
				{
					pcsaReturn->Add(pcsaClassProps->GetAt(i));
				}
			}
			delete pcsaClassProps;
			delete pcsaSuperProps;
			phmmcoSuper->Release();
			return pcsaReturn;
		}
	}
	else
	{
		return pcsaClassProps;
	}
}

CStringArray *CCPPWizCtrl::GetNonLocalPropNames
(IWbemClassObject * pClass, BOOL bNonSystem)
{

	CString csSuperClass = GetSuperClassName(pClass);

	if (!csSuperClass.IsEmpty())
	{
		IWbemClassObject *phmmcoSuper = NULL;
		IWbemClassObject *pErrorObject = NULL;
		BSTR bstrTemp = csSuperClass.AllocSysString();
		SCODE sc =
			m_pServices ->
				GetObject
					(bstrTemp,0,NULL,&phmmcoSuper,NULL);
		::SysFreeString(bstrTemp);
		if (sc != S_OK)
		{
			CString csUserMsg;
			csUserMsg =  _T("Cannot get object ") + csSuperClass;
			ErrorMsg
						(&csUserMsg, sc, pErrorObject,TRUE, &csUserMsg, __FILE__,
						__LINE__ - 8);
			ReleaseErrorObject(pErrorObject);
			return NULL;
		}
		else
		{
			ReleaseErrorObject(pErrorObject);
			CStringArray *pcsaSuperProps = GetPropNames(phmmcoSuper,bNonSystem);
			phmmcoSuper->Release();
			return pcsaSuperProps;
		}
	}
	else
	{
		return NULL;
	}
}


BOOL CCPPWizCtrl::StringInCSA(CStringArray *pcsaSearchIn,CString *pcsSearchFor)
{
	for (int i = 0; i < pcsaSearchIn->GetSize(); i++)
	{
		if (pcsSearchFor->
				CompareNoCase(pcsaSearchIn->GetAt(i)) == 0)
		{
			return TRUE;
		}

	}

	return FALSE;
}


//***************************************************************************
//
// GetPropertyValueByAttrib
//
// Purpose: For an object get a property BSTR value by Qualifier.
//
//***************************************************************************
COleVariant CCPPWizCtrl::GetPropertyValueByAttrib
(IWbemClassObject *pObject ,  CString *pcsAttrib)
{
	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;
	int nProps;
	CStringArray *pcsaProps= GetPropNames(pObject);
	nProps =  pcsaProps ? (int) pcsaProps -> GetSize() : 0;
	int i;
	IWbemQualifierSet * pAttrib = NULL;
	CString csTmp;
	COleVariant covReturn;
	BOOL bBreak = FALSE;

	for (i = 0; i < nProps; i++)
	{
		BSTR bstrTemp = pcsaProps-> GetAt(i).AllocSysString();
		sc = pObject -> GetPropertyQualifierSet(bstrTemp,
						&pAttrib);
		::SysFreeString(bstrTemp);

		if (sc != S_OK)
		{
			CString csUserMsg;
			csUserMsg =  _T("Cannot get property qualifier set ");
			csUserMsg += pcsaProps -> GetAt(i) + _T(" for object ");
			csUserMsg += GetIWbemFullPath (pObject);
			csUserMsg += _T(" property ") + pcsaProps -> GetAt(i);
			ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ - 12);
		}
		else
		{
			sc = pAttrib->GetNames(0,&psa);
			if(sc == S_OK)
			{
				int iDim = SafeArrayGetDim(psa);
				sc = SafeArrayGetLBound(psa,1,&lLower);
				sc = SafeArrayGetUBound(psa,1,&lUpper);
				BSTR AttrName;
				for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
				{
					sc = SafeArrayGetElement(psa,ix,&AttrName);
					csTmp = AttrName;

					if (pcsAttrib -> CompareNoCase(csTmp)  == 0)
					{
						covReturn = GetProperty (NULL, pObject,
							&pcsaProps-> GetAt(i));
						bBreak = TRUE;
					}
					SysFreeString(AttrName);

				}
			 }
			else
			{
				CString csUserMsg;
				csUserMsg =  _T("Cannot get attribute names for ")
								+  GetIWbemFullPath (pObject);
				csUserMsg += _T(" property ") + pcsaProps-> GetAt(i);
				ErrorMsg
						(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
						__LINE__ - 30);
			}

			 pAttrib -> Release();
			 if (bBreak)
				 break;
		}
	}
	SafeArrayDestroy(psa);
	delete pcsaProps;
	return covReturn;
}

 //***************************************************************************
//
// GetPropertyNameByAttrib
//
// Purpose: For an object get a property name by Qualifier.
//
//***************************************************************************
CString CCPPWizCtrl::GetPropertyNameByAttrib
(IWbemClassObject *pObject , CString *pcsAttrib)
{
	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;
	int nProps;
	CStringArray *pcsaProps = GetPropNames(pObject);
	nProps = pcsaProps ? (int) pcsaProps -> GetSize() : 0;
	int i;
	IWbemQualifierSet *pAttrib = NULL;
	CString csTmp;
	CString csReturn;
	BOOL bBreak = FALSE;

	for (i = 0; i < nProps; i++)
	{
		BSTR bstrTemp = pcsaProps-> GetAt(i).AllocSysString();
		sc = pObject -> GetPropertyQualifierSet(bstrTemp,
						&pAttrib);
		::SysFreeString(bstrTemp);

		if (sc != S_OK)
		{
			CString csUserMsg;
			csUserMsg =  _T("Cannot get property qualifier set ");
			csUserMsg += pcsaProps -> GetAt(i) + _T(" for object ");
			csUserMsg += GetIWbemFullPath (pObject);
			csUserMsg += _T(" property ") + pcsaProps -> GetAt(i);
			ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ - 11);
		}
		else
		{
		sc = pAttrib->GetNames(0,&psa);
			if(sc == S_OK)
			{
				int iDim = SafeArrayGetDim(psa);
				sc = SafeArrayGetLBound(psa,1,&lLower);
				sc = SafeArrayGetUBound(psa,1,&lUpper);
				BSTR AttrName;
				for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
				{
					sc = SafeArrayGetElement(psa,ix,&AttrName);
					csTmp = AttrName;

					if (pcsAttrib -> CompareNoCase(csTmp)  == 0)
					{
						csReturn = pcsaProps->GetAt(i);
						bBreak = TRUE;
					}
					SysFreeString(AttrName);

				}
			 }
			 pAttrib -> Release();
			 if (bBreak)
				 break;
		}
	}
	SafeArrayDestroy(psa);
	delete pcsaProps;
	return csReturn;
}

DWORD CCPPWizCtrl::PropertyAttribFlags(IWbemQualifierSet *pAttrib)
{
	DWORD dReturn = 0;

	CString csAttrib = _T("Read");
	if (AttribInAttribSet(pAttrib, &csAttrib))
	{
		dReturn |= MO_ATTRIB_READ;
	}

	csAttrib = _T("Write");
	if (AttribInAttribSet(pAttrib, &csAttrib))
	{
		dReturn |= MO_ATTRIB_WRITE;
	}

	csAttrib = _T("Volatile");
	if (AttribInAttribSet(pAttrib, &csAttrib))
	{
		dReturn |= MO_ATTRIB_VOLATILE;
	}

	csAttrib = _T("Expensive");
	if (AttribInAttribSet(pAttrib, &csAttrib))
	{
		dReturn |= MO_ATTRIB_EXPENSIVE;
	}

	csAttrib = _T("Key");
	if (AttribInAttribSet(pAttrib, &csAttrib))
	{
		dReturn |= MO_ATTRIB_KEY;
	}

	return dReturn;
}


BOOL CCPPWizCtrl::AttribInAttribSet
(IWbemQualifierSet *pAttrib , CString *pcsAttrib)
{
	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;
	CString csTmp;
	BOOL bReturn = FALSE;
	BOOL bBreak = FALSE;

	sc = pAttrib->GetNames(0,&psa);
	if(sc == S_OK)
	{
		int iDim = SafeArrayGetDim(psa);
		sc = SafeArrayGetLBound(psa,1,&lLower);
		sc = SafeArrayGetUBound(psa,1,&lUpper);
		BSTR AttrName;
		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
		{
			sc = SafeArrayGetElement(psa,ix,&AttrName);
			csTmp = AttrName;

			if (pcsAttrib -> CompareNoCase(csTmp)  == 0)
			{
				bReturn = TRUE;
				bBreak = TRUE;
			}
			SysFreeString(AttrName);

		}
	}

	SafeArrayDestroy(psa);
	return bReturn;
}

BOOL CCPPWizCtrl::IsSystemProperty(CString *pcsProp)
{
	if (pcsProp->GetLength() > 2 &&
		(*pcsProp)[0] == '_' &&
		(*pcsProp)[1] == '_')
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}


}

COleVariant CCPPWizCtrl::GetProperty
(IWbemServices * pProv, IWbemClassObject * pInst, CString *pcsProperty)
{
	SCODE sc;
	COleVariant covOut;

    VARIANTARG var;
	VariantInit(&var);
    long lType;
	long lFlavor;

	BSTR bstrTemp =  pcsProperty -> AllocSysString ( );
    sc = pInst->Get(bstrTemp ,0,&var,&lType,&lFlavor);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
			return covOut;
	}

	covOut  = var;

	VariantClear(&var);
	return covOut;
}

void CCPPWizCtrl::ReleaseErrorObject(IWbemClassObject *&rpErrorObject)
{
	if (rpErrorObject)
	{
		rpErrorObject->Release();
		rpErrorObject = NULL;
	}


}


//***************************************************************************
//
// GetIWbemFullPath
//
// Purpose: Returns the complete path of the object.
//
//***************************************************************************
CString CCPPWizCtrl::GetIWbemFullPath(IWbemClassObject *pClass)
{

	CString csProp = _T("__Path");
	return GetBSTRProperty(pClass,&csProp);


}


BOOL CCPPWizCtrl::OnWizard(CStringArray *pcsaClasses)
{
	if (InterlockedIncrement(&gCountWizards) > 1)
	{
			CString csUserMsg =
					_T("Only one \"Provider Code Generator Wizard\" can run at a time.");
			ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__);
			InterlockedDecrement(&gCountWizards);
			return FALSE;
	}


	m_bYesAll = FALSE;
	m_bNoAll = FALSE;

	m_csProviderBaseName.Empty();
	m_csProviderDescription.Empty();
	m_csProviderOutputPath.Empty();
	m_csaClassBaseNames.RemoveAll();
	m_csaClassCPPNames.RemoveAll();
	m_csaClassDescriptions.RemoveAll();
	m_cbaInheritedPropIndicators.RemoveAll();

	CString csWorkingDirectory;

	SCODE sc = GetSDKDirectory(csWorkingDirectory);

	if SUCCEEDED(sc)
	{
		m_csProviderTLBPath = csWorkingDirectory + _T("\\include");
	}
	else
	{
		m_csProviderTLBPath = _T("");
	}


	if (m_pcsaNonLocalProps)
	{
		delete [] m_pcsaNonLocalProps;
		m_pcsaNonLocalProps = NULL;
	}

	SortCStringArray(*pcsaClasses);

	int i;
	for (i = 0; i < pcsaClasses->GetSize();i++)
	{

		m_csaClassBaseNames.Add(pcsaClasses->GetAt(i));
		CString csTmp = _T("C");
		csTmp += pcsaClasses->GetAt(i);
		m_csaClassCPPNames.Add(csTmp);
		m_csaClassDescriptions.Add(_T(""));
		m_cbaInheritedPropIndicators.Add(0);
	}

	if (m_pcgsPropertySheet)
	{
		delete m_pcgsPropertySheet;
		m_pcgsPropertySheet = NULL;
	}

	m_pcgsPropertySheet = new
						CCPPGenSheet(this);
	m_pcgsPropertySheet->SetWizardMode();

	PreModalDialog();
	int nReturn = (int) m_pcgsPropertySheet->DoModal();
	PostModalDialog();

	InterlockedDecrement(&gCountWizards);

	if (nReturn == ID_WIZFINISH)
	{
		return TRUE;
	}
	else
	{
		delete m_pcgsPropertySheet;
		m_pcgsPropertySheet = NULL;
		return FALSE;
	}

}

DWORD CCPPWizCtrl::GetControlFlags()
{
    return COleControl::GetControlFlags(); // | windowlessActivate;
}

void CCPPWizCtrl::RelayEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
      if (NULL != m_ttip.m_hWnd)
	  {
         MSG msg;

         msg.hwnd= m_hWnd;
         msg.message= message;
         msg.wParam= wParam;
         msg.lParam= lParam;
         msg.time= 0;
         msg.pt.x= LOWORD (lParam);
         msg.pt.y= HIWORD (lParam);

         m_ttip.RelayEvent(&msg);
     }
}

void CCPPWizCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	RelayEvent(WM_MOUSEMOVE, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));

	COleControl::OnMouseMove(nFlags, point);
}

HRESULT  CCPPWizCtrl::GetSDKDirectory(CString &sHmomWorkingDir)
{
	sHmomWorkingDir.Empty();
	HKEY hkeyLocalMachine;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hkeyLocalMachine);
	if (lResult != ERROR_SUCCESS) {
		return E_FAIL;
	}

	HKEY hkeyHmomCwd;

	lResult = RegOpenKeyEx(
				hkeyLocalMachine,
				_T("SOFTWARE\\Microsoft\\WBEM"),
				0,
				KEY_READ | KEY_QUERY_VALUE,
				&hkeyHmomCwd);

	if (lResult != ERROR_SUCCESS) {
		RegCloseKey(hkeyLocalMachine);
		return E_FAIL;
	}

	unsigned long lcbValue = 1024;
	LPTSTR pszWorkingDir = sHmomWorkingDir.GetBuffer(lcbValue);

	unsigned long lType;
	lResult = RegQueryValueEx(
				hkeyHmomCwd,
				_T("SDK Directory"),
				NULL,
				&lType,
				(unsigned char*) (void*) pszWorkingDir,
				&lcbValue);


	sHmomWorkingDir.ReleaseBuffer();
	RegCloseKey(hkeyHmomCwd);
	RegCloseKey(hkeyLocalMachine);

	if (lResult != ERROR_SUCCESS) {
		sHmomWorkingDir.Empty();
		return E_FAIL;
	}

	return S_OK;
}

HRESULT CCPPWizCtrl::GetPropType(IWbemClassObject *pObject,CString *pcsProp,unsigned short & uType)
{
	// This will have to look at syntax qualifier for things like MO_PROPTYPE_DATETIME.
	// DATETIME is the syntax qualifier.

	long lType;
	if (HasDateTimeSyntax (pObject,pcsProp))
	{
		uType = MO_PROPTYPE_DATETIME;
		return S_OK;
	}

	COleVariant varProp;
	long lFlavor;

	BSTR bstrTemp = pcsProp->AllocSysString();
	SCODE sc = pObject->Get(bstrTemp, 0, &varProp,&lType,&lFlavor);
	::SysFreeString(bstrTemp);

	uType = (unsigned short) lType;

	return sc;

}


BOOL CCPPWizCtrl::HasDateTimeSyntax
(IWbemClassObject *pClassInt,CString *pcsPropName)
{
    SCODE sc;
	CString csAttValue;

    IWbemQualifierSet * pAttribSet = NULL;

	BSTR bstrTemp = pcsPropName -> AllocSysString();
    sc = pClassInt->GetPropertyQualifierSet(bstrTemp,
					&pAttribSet);
	::SysFreeString(bstrTemp);

    if (sc != S_OK)
	{
		return FALSE;
	}

	VARIANTARG var;
	VariantInit(&var);

	long lReturn;
	CString csAttribName = _T("syntax");

	bstrTemp = csAttribName.AllocSysString();
    sc = pAttribSet->Get(bstrTemp, 0,
		&var,&lReturn);
	::SysFreeString(bstrTemp);

	BOOL bReturn = FALSE;

	if (sc == S_OK)
	{
		csAttValue = var.bstrVal;
		if (csAttValue.CompareNoCase(_T("datetime")) == 0)
		{
			bReturn =  TRUE;
		}
		else
		{
			bReturn =  FALSE;
		}
		pAttribSet->Release();
		VariantClear(&var);

	}
	else
	{
		pAttribSet->Release();
		bReturn =  FALSE;
	}

    return bReturn;
}

CString CCPPWizCtrl::CreateUUID(void)
{
    static TCHAR szUUID[50] ;
    UUID RawUUID ;
#ifdef _UNICODE
	 TCHAR *pszSysUUID ;
#endif
#ifndef _UNICODE
	 unsigned char *pszSysUUID ;
#endif


    // Make sure we don't return anything twice
    //=========================================

    _tcscpy(szUUID, _T("NULL UUID")) ;

    // Generate the new UUID
    //======================

    if(UuidCreate(&RawUUID) == RPC_S_OK && UuidToString(&RawUUID, &pszSysUUID) == RPC_S_OK) {

        _tcscpy(szUUID, (const TCHAR *) pszSysUUID) ;
        RpcStringFree(&pszSysUUID) ;
    }

    return szUUID ;
}

long CCPPWizCtrl::GetAttribBool
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName,
 BOOL &bReturn)
{
    SCODE sc;
    IWbemQualifierSet * pAttribSet = NULL;
    if(pcsPropName != NULL)   // Property Qualifier
	{
		BSTR bstrTemp = pcsPropName -> AllocSysString();
        sc = pClassInt->GetPropertyQualifierSet
				(bstrTemp,
				&pAttribSet);
		::SysFreeString(bstrTemp);
	}
    else	// A class Qualifier
	{
        sc = pClassInt->GetQualifierSet(&pAttribSet);
	}

	if (sc != S_OK)
	{
		return sc;
	}

	VARIANTARG var;
	VariantInit(&var);
	var.vt =  VT_BOOL;

	BSTR bstrTemp = pcsAttribName -> AllocSysString();
    sc = pAttribSet->Get
			(bstrTemp, 0, &var, NULL);
	::SysFreeString(bstrTemp);


	if (sc == S_OK)
	{
		bReturn = V_BOOL(&var);
	}

    pAttribSet->Release();
    VariantClear(&var);
    return sc;
}

long CCPPWizCtrl::SetAttribBool
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName,
 BOOL bValue)
{
    SCODE sc;
    IWbemQualifierSet * pAttribSet = NULL;
    if(pcsPropName != NULL)   // Property Qualifier
	{
		BSTR bstrTemp = pcsPropName -> AllocSysString();
        sc = pClassInt->GetPropertyQualifierSet
				(bstrTemp,
				&pAttribSet);
		::SysFreeString(bstrTemp);
	}
    else	// A class Qualifier
	{
        sc = pClassInt->GetQualifierSet(&pAttribSet);
	}

	if (sc != S_OK)
	{
		CString csName =
			GetIWbemFullPath(pClassInt);
		CString csUserMsg;
		csUserMsg =  _T("Cannot get the qualifier set for ");
		if (pcsPropName != NULL)
		{
			csUserMsg += _T(" the ") + *pcsPropName + _T(" property of ");
		}
		csUserMsg += csName;

		ErrorMsg
					(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		return sc;
	}

	VARIANTARG var;
	VariantInit(&var);
	var.vt =  VT_BOOL;
	var.boolVal = bValue ? VARIANT_TRUE : VARIANT_FALSE;

	BSTR bstrTemp = pcsAttribName -> AllocSysString();
    sc = pAttribSet->
			Put(bstrTemp,
				&var,
				WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
				WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS
				);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		CString csName =
			GetIWbemFullPath(pClassInt);
		CString csUserMsg;
		csUserMsg =  _T("Cannot put qualifier ") + *pcsAttribName + _T(" for ");
		if (pcsPropName != NULL)
		{
			csUserMsg += _T(" the ") + *pcsPropName + _T(" property of ");
		}
		csUserMsg += csName;

		ErrorMsg
					(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
	}

    pAttribSet->Release();
    VariantClear(&var);
    return sc;
}

long CCPPWizCtrl::GetAttribBSTR
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName,
 CString &csReturn)
{
    SCODE sc;
    IWbemQualifierSet *pAttribSet = NULL;
    if(pcsPropName != NULL)   // Property Qualifier
	{
		BSTR bstrTemp = pcsPropName -> AllocSysString();
        sc = pClassInt->GetPropertyQualifierSet
				(bstrTemp,
				&pAttribSet);
		::SysFreeString(bstrTemp);
	}
    else	// A class Qualifier
	{
        sc = pClassInt->GetQualifierSet(&pAttribSet);
	}

	if (sc != S_OK)
	{
		csReturn.Empty();
		return sc;
	}

	VARIANTARG var;
	VariantInit(&var);

	BSTR bstrTemp = pcsAttribName -> AllocSysString();
    sc = pAttribSet->Get(bstrTemp, 0, &var,NULL);
	::SysFreeString(bstrTemp);

	if (sc == S_OK && var.vt == VT_BSTR)
	{
		csReturn = var.bstrVal;
	}
	else
	{
		csReturn.Empty();
	}


    pAttribSet->Release();
    VariantClear(&var);
    return sc;
}


long CCPPWizCtrl::SetAttribBSTR
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName,
 CString *pcsValue)
{
    SCODE sc;
    IWbemQualifierSet *pAttribSet = NULL;

    if(pcsPropName != NULL)   // Property Qualifier
	{
		BSTR bstrTemp = pcsPropName -> AllocSysString();
        sc = pClassInt->GetPropertyQualifierSet
				(bstrTemp,
				&pAttribSet);
		::SysFreeString(bstrTemp);
	}
    else	// A class Qualifier
	{
        sc = pClassInt->GetQualifierSet(&pAttribSet);
	}

	if (sc != S_OK)
	{
		CString csName =
			GetIWbemFullPath(pClassInt);
		CString csUserMsg;
		csUserMsg =  _T("Cannot get the qualifier set for ");
		if (pcsPropName != NULL)
		{
			csUserMsg += _T(" the ") + *pcsPropName + _T(" property of ");
		}
		csUserMsg += csName;

		ErrorMsg
					(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		return sc;
	}

	VARIANTARG var;
	VariantInit(&var);
	var.vt =  VT_BSTR;
	var.bstrVal = pcsValue->AllocSysString();

	BSTR bstrTemp = pcsAttribName -> AllocSysString();
    sc = pAttribSet->Put
		(	bstrTemp,
			&var,
			WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
			WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS
			);
	::SysFreeString(bstrTemp);


	if (sc != S_OK)
	{
		CString csName =
			GetIWbemFullPath(pClassInt);
		CString csUserMsg;
		csUserMsg =  _T("Cannot put qualifier ") + *pcsAttribName + _T(" for ");
		if (pcsPropName != NULL)
		{
			csUserMsg += _T(" the ") + *pcsPropName + _T(" property of ");
		}
		csUserMsg += csName;

		ErrorMsg
					(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ );
	}

    pAttribSet->Release();
    VariantClear(&var);
    return sc;
}


BOOL CCPPWizCtrl::CreateProviderInstance()
{
	IWbemClassObject *pNewInstance = 0;
	IWbemClassObject *pClass = 0;
	IWbemClassObject *pErrorObject = NULL;

	CString csClass = _T("__Win32provider");

	BSTR bstrTemp = csClass.AllocSysString();
	SCODE sc = m_pServices->GetObject
		(bstrTemp, 0, NULL, &pClass, NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get the __Win32Provider class object.  A __Win32Provider instance will not be created for the new provider and");
		csUserMsg +=  _T(" the classes provided by the new provider will not have provider class qualifiers added to them.");
		ErrorMsg
					(&csUserMsg, sc, pErrorObject,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		ReleaseErrorObject(pErrorObject);
		return NULL;
	}

	ReleaseErrorObject(pErrorObject);

	sc = pClass->SpawnInstance(0, &pNewInstance);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot spawn instance of the __Win32provider class.  A __Win32Provider instance will not be created for the new provider and");
		csUserMsg +=  _T(" the classes provided by the new provider will not have provider class qualifiers added to them.");
		ErrorMsg
					(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		pClass->Release();
		return NULL;
	}

	pClass->Release();

	VARIANTARG var;

	CString csProp;

	csProp = _T("Name");
	VariantInit(&var);
	var.vt = VT_BSTR;
	var.bstrVal = m_csProviderBaseName.AllocSysString();

	bstrTemp = csProp.AllocSysString();
	sc = pNewInstance->Put(bstrTemp, 0, &var, 0);
	::SysFreeString(bstrTemp);

	VariantClear(&var);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot Put Name property of the __Win32provider class instance.");
		ErrorMsg
					(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
	}

	csProp = _T("CLSID");
	CString csUUID = _T("{") + m_csUUID + _T("}");
	VariantInit(&var);
	var.vt = VT_BSTR;
	var.bstrVal = csUUID.AllocSysString();

	bstrTemp = csProp.AllocSysString();
	sc = pNewInstance->Put(bstrTemp, 0, &var, 0);
	::SysFreeString(bstrTemp);

	VariantClear(&var);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot Put ProviderCLSID property of the __Win32provider class instance.");
		ErrorMsg
					(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
	}

	sc = GetServices()->PutInstance
		(pNewInstance , WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot PutInstance of the __Win32provider class.  A __Win32Provider instance will not be created for the new provider and");
		csUserMsg +=  _T(" the classes provided by the new provider will not have provider class qualifiers added to them.");
		ErrorMsg
					(&csUserMsg, sc, pErrorObject,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		ReleaseErrorObject(pErrorObject);
		pNewInstance->Release();
		return NULL;
	}

	ReleaseErrorObject(pErrorObject);

	pNewInstance->Release();


	pNewInstance = 0;
	CString csRelPath = _T("__Win32provider.name=\"") + m_csProviderBaseName + _T("\"");

	bstrTemp = csRelPath.AllocSysString();
	sc = m_pServices->GetObject
		(bstrTemp, 0, NULL, &pNewInstance, NULL);
	::SysFreeString(bstrTemp);


	if (sc == S_OK)
	{
		CString csPath = GetIWbemFullPath(pNewInstance);
		FormatPathForRAIDItem20918(&csPath);
		CreateInstanceProviderRegistration(csPath);
		CreateMethodProviderRegistration(csPath);
		pNewInstance->Release();
	}
	else
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get path to the new __Win32Provoider instance.  An __InstanceProviderRegistration and __MethodProviderRegistration instance will not be created for the new provider.");
		ErrorMsg
					(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
	}

	return TRUE;

}

VOID CCPPWizCtrl::FormatPathForRAIDItem20918(CString *pcsPath)
{
// Yes, boys and girls this is a hack for RAID item 20918.
	if ((*pcsPath)[2] == '.')
	{
		return;
	}

	CString csReturn = "\\\\.\\";

	int nLen = pcsPath->GetLength();

	int i;
	for (i = 2; i < nLen; i++)
	{
		if((*pcsPath)[i] == '\\')
		{
			csReturn += pcsPath->Right(nLen - (i + 1));
			*pcsPath = csReturn;
			return;
		}
	}


}

BOOL CCPPWizCtrl::CreateInstanceProviderRegistration(CString &rcsPath)
{
	IWbemClassObject *pNewInstance = 0;
	IWbemClassObject *pClass = 0;
	IWbemClassObject *pErrorObject = NULL;

	CString csClass = _T("__InstanceProviderRegistration");

	BSTR bstrTemp = csClass.AllocSysString();
	SCODE sc = m_pServices->GetObject
		(bstrTemp, 0, NULL, &pClass, NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get the __InstanceProviderRegistration class.  An __InstanceProviderRegistration instance will not be created for the new provider.");
		ErrorMsg
					(&csUserMsg, sc, pErrorObject,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		ReleaseErrorObject(pErrorObject);
		return NULL;
	}

	ReleaseErrorObject(pErrorObject);

	sc = pClass->SpawnInstance(0, &pNewInstance);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot spawn instance of the __InstanceProviderRegistration class.  An __InstanceProviderRegistration instance will not be created for the new provider.");
		ErrorMsg
					(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		pClass->Release();
		return NULL;
	}

	pClass->Release();

	VARIANTARG var;

	CString csProp;

	csProp = _T("Provider");
	VariantInit(&var);
	var.vt = VT_BSTR;
	var.bstrVal = rcsPath.AllocSysString();

	bstrTemp = csProp.AllocSysString();
	sc = pNewInstance->Put(bstrTemp, 0, &var, 0);
	::SysFreeString(bstrTemp);

	VariantClear(&var);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot Put Provider property of the __InstanceProviderRegistration class instance.");
		ErrorMsg
					(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		ReleaseErrorObject(pErrorObject);
		pNewInstance->Release();
		return NULL;
	}

	csProp = _T("SupportsGet");
	VariantInit(&var);
	var.vt = VT_BOOL;
	var.boolVal = VARIANT_TRUE;

	bstrTemp = csProp.AllocSysString();
	sc = pNewInstance->Put(bstrTemp, 0, &var, 0);
	::SysFreeString(bstrTemp);

	VariantClear(&var);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot Put SupportsGet property of the __InstanceProviderRegistration class instance.");
		ErrorMsg
					(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		ReleaseErrorObject(pErrorObject);
		pNewInstance->Release();
		return NULL;
	}


	csProp = _T("SupportsEnumeration");
	VariantInit(&var);
	var.vt = VT_BOOL;
	var.boolVal = VARIANT_TRUE;

	bstrTemp = csProp.AllocSysString();
	sc = pNewInstance->Put(bstrTemp, 0, &var, 0);
	::SysFreeString(bstrTemp);

	VariantClear(&var);

	csProp = _T("SupportsDelete");
	VariantInit(&var);
	var.vt = VT_BOOL;
	var.boolVal = VARIANT_TRUE;

	bstrTemp = csProp.AllocSysString();
	sc = pNewInstance->Put(bstrTemp, 0, &var, 0);
	::SysFreeString(bstrTemp);

	VariantClear(&var);

	csProp = _T("SupportsPut");
	VariantInit(&var);
	var.vt = VT_BOOL;
	var.boolVal = VARIANT_TRUE;

	bstrTemp = csProp.AllocSysString();
	sc = pNewInstance->Put(bstrTemp, 0, &var, 0);
	::SysFreeString(bstrTemp);

	VariantClear(&var);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot Put SupportsEnumeration property of the __InstanceProviderRegistration class instance.");
		ErrorMsg
					(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		ReleaseErrorObject(pErrorObject);
		pNewInstance->Release();
		return NULL;
	}


	sc = GetServices()->PutInstance
		(pNewInstance , WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot PutInstance of the __InstanceProviderRegistration class.  An __InstanceProviderRegistration instance will not be created for the new provider.");
		ErrorMsg
					(&csUserMsg, sc, pErrorObject,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		ReleaseErrorObject(pErrorObject);
		pNewInstance->Release();
		return NULL;
	}

	ReleaseErrorObject(pErrorObject);
	pNewInstance->Release();
	return TRUE;

}

BOOL CCPPWizCtrl::CreateMethodProviderRegistration(CString &rcsPath)
{
	IWbemClassObject *pNewInstance = 0;
	IWbemClassObject *pClass = 0;
	IWbemClassObject *pErrorObject = NULL;

	CString csClass = _T("__MethodProviderRegistration");

	BSTR bstrTemp = csClass.AllocSysString();
	SCODE sc = m_pServices->GetObject
		(bstrTemp, 0, NULL, &pClass, NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get the __MethodProviderRegistration class.  A __MethodProviderRegistration instance will not be created for the new provider.");
		ErrorMsg
					(&csUserMsg, sc, pErrorObject,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		ReleaseErrorObject(pErrorObject);
		return NULL;
	}

	ReleaseErrorObject(pErrorObject);

	sc = pClass->SpawnInstance(0, &pNewInstance);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot spawn instance of the __MethodProviderRegistration class.  A __MethodProviderRegistration instance will not be created for the new provider.");
		ErrorMsg
					(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		pClass->Release();
		return NULL;
	}

	pClass->Release();

	VARIANTARG var;

	CString csProp;

	csProp = _T("Provider");
	VariantInit(&var);
	var.vt = VT_BSTR;
	var.bstrVal = rcsPath.AllocSysString();

	bstrTemp = csProp.AllocSysString();
	sc = pNewInstance->Put(bstrTemp, 0, &var, 0);
	::SysFreeString(bstrTemp);

	VariantClear(&var);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot Put Provider property of the __MethodProviderRegistration class instance.");
		ErrorMsg
					(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
	}


	sc = GetServices()->PutInstance
		(pNewInstance , WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot PutInstance of the __MethodProviderRegistration class.  A __MethodProviderRegistration instance will not be created for the new provider.");
		ErrorMsg
					(&csUserMsg, sc, pErrorObject,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		ReleaseErrorObject(pErrorObject);
		pNewInstance->Release();
		return NULL;
	}

	ReleaseErrorObject(pErrorObject);
	pNewInstance->Release();
	return TRUE;

}

BOOL CCPPWizCtrl::UpdateClassQualifiers(IWbemClassObject *pClass)
{

	CString csProviderName;
	BOOL bClassHasProviderQuals =
		m_bYesAll? false :
		CheckForProviderQuals(pClass,csProviderName);


	BOOL bSetQuals = FALSE;

	if (!m_bNoAll && bClassHasProviderQuals )
	{
		CReplaceProviderQuery crpqDialog;

		CString csClassName = GetClassName(pClass);

		CString csMessage =
			_T("The dynamic provider ") + csProviderName;
		csMessage += _T(" provides the class ") + csClassName;
		csMessage += _T(".  Do you want to replace it with the new dynamic provider ");
		csMessage += m_csProviderBaseName + _T("?");

		crpqDialog.SetMessage(&csMessage);
		int nReturn = (int) crpqDialog.DoModal();

		if (nReturn == 1)
		{
			bSetQuals = TRUE;
		}
		if (nReturn == 2)
		{
			bSetQuals = TRUE;
			m_bYesAll = TRUE;
		}
		if (nReturn == 4 || nReturn == 0)
		{
			m_bNoAll = TRUE;

		}

	}

	if (m_csProviderBaseName.CompareNoCase(csProviderName) == 0)
	{
		// If the provider name did not change, there is no reason to do a put on
		// the "provider" qualifier again.
		bClassHasProviderQuals = FALSE;
	}


	if (bClassHasProviderQuals == FALSE ||
		bSetQuals == TRUE)
	{
		CString csProp = _T("provider");
		SCODE sc =
			SetAttribBSTR
				(pClass,NULL,&csProp,&m_csProviderBaseName);

		csProp = _T("dynamic");
		sc = SetAttribBool(pClass,NULL,&csProp,TRUE);

		IWbemClassObject *pErrorObject = NULL;
		sc = GetServices()->PutClass(pClass,WBEM_FLAG_UPDATE_ONLY,NULL, NULL);
		if (sc != S_OK)
		{
			CString csClassName = GetClassName(pClass);
			CString csUserMsg;
			csUserMsg =  _T("Cannot PutClass for class ") + csClassName;
			csUserMsg +=  _T(".  The class will not have provider class qualifiers added to it.");
			ErrorMsg
					(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__,
					__LINE__ );
			ReleaseErrorObject(pErrorObject);
			return FALSE;
		}
		ReleaseErrorObject(pErrorObject);

	}
	return TRUE;
}

BOOL CCPPWizCtrl::CheckForProviderQuals
(IWbemClassObject *pClass, CString &rcsProvider)
{
	CString csProp = _T("provider");
	SCODE sc =
		GetAttribBSTR
			(pClass,NULL,&csProp,rcsProvider);

	BOOL bReturn;

	if (sc == S_OK)
	{
		bReturn = TRUE;
	}
	else
	{
		bReturn = FALSE;
	}

	return bReturn;

}

IWbemServices *CCPPWizCtrl::GetIWbemServices
(CString &rcsNamespace)
{
	IUnknown *pServices = NULL;

	BOOL bUpdatePointer= FALSE;

	m_sc = S_OK;
	m_bUserCancel = FALSE;

	VARIANT varUpdatePointer;
	VariantInit(&varUpdatePointer);
	varUpdatePointer.vt = VT_I4;
	if (bUpdatePointer == TRUE)
	{
		varUpdatePointer.lVal = 1;
	}
	else
	{
		varUpdatePointer.lVal = 0;
	}

	VARIANT varService;
	VariantInit(&varService);

	VARIANT varSC;
	VariantInit(&varSC);

	VARIANT varUserCancel;
	VariantInit(&varUserCancel);

	FireGetIWbemServices
		((LPCTSTR)rcsNamespace,  &varUpdatePointer,  &varService, &varSC,
		&varUserCancel);

	if (varService.vt & VT_UNKNOWN)
	{
		pServices = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}

	varService.punkVal = NULL;

	VariantClear(&varService);

	if (varSC.vt == VT_I4)
	{
		m_sc = varSC.lVal;
	}
	else
	{
		m_sc = WBEM_E_FAILED;
	}

	VariantClear(&varSC);

	if (varUserCancel.vt == VT_BOOL)
	{
		m_bUserCancel = varUserCancel.boolVal;
	}

	VariantClear(&varUserCancel);

	VariantClear(&varUpdatePointer);

	IWbemServices *pRealServices = NULL;
	if (m_sc == S_OK && !m_bUserCancel)
	{
		pRealServices = reinterpret_cast<IWbemServices *>(pServices);
	}

	return pRealServices;
}

void CCPPWizCtrl::InvokeHelp()
{

	CString csPath;
	WbemRegString(SDK_HELP, csPath);

	CString csData = idh_provcodegen;


	HWND hWnd = NULL;

	try
	{
		HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD_PTR) (LPCTSTR) csData);
		if (!hWnd)
		{
			CString csUserMsg;
			csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");

			ErrorMsg
					(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		}

	}

	catch( ... )
	{
		// Handle any exceptions here.
		CString csUserMsg;
		csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");

		ErrorMsg
				(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
	}



}

BOOL CCPPWizCtrl::PreTranslateMessage(MSG* lpMsg)
{
	// TODO: Add your specialized code here and/or call the base class

	BOOL bDidTranslate;

	bDidTranslate = COleControl::PreTranslateMessage(lpMsg);

	if (bDidTranslate)
	{
		return bDidTranslate;
	}

	if  (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_RETURN)
	{
		PostMessage(FIREGENERATECPP,0,0);
	}


	if ((lpMsg->message == WM_KEYUP || lpMsg->message == WM_KEYDOWN) &&
		lpMsg->wParam == VK_TAB)
	{
		return FALSE;
	}

	return PreTranslateInput (lpMsg);
}

void CCPPWizCtrl::OnKillFocus(CWnd* pNewWnd)
{
#ifdef _DEBUG
	afxDump << _T("CCPPWizCtrl::OnKillFocus\n");
#endif

	COleControl::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	OnActivateInPlace(FALSE,NULL);
	m_nImage = 0;
	InvalidateControl();

}

void CCPPWizCtrl::OnSetFocus(CWnd* pOldWnd)
{

#ifdef _DEBUG
	afxDump << _T("CCPPWizCtrl::OnSetFocus\n");
#endif

	COleControl::OnSetFocus(pOldWnd);

	// TODO: Add your message handler code here
	OnActivateInPlace(TRUE,NULL);
	m_nImage = 1;
	InvalidateControl();

}

BOOL CCPPWizCtrl::OnEraseBkgnd(CDC* pDC)
{

#ifdef _DEBUG
	afxDump << _T("CCPPWizCtrl::OnEraseBkgnd\n");
#endif

	// This is needed for transparency and the correct drawing...
	CWnd*  pWndParent;       // handle of our parent window
	POINT  pt;

	pWndParent = GetParent();
	pt.x       = 0;
	pt.y       = 0;
	MapWindowPoints(pWndParent, &pt, 1);
	OffsetWindowOrgEx(pDC->m_hDC, pt.x, pt.y, &pt);
	::SendMessage(pWndParent->m_hWnd, WM_ERASEBKGND, (WPARAM)pDC->m_hDC, 0);
	SetWindowOrgEx(pDC->m_hDC, pt.x, pt.y, NULL);

	return 1;
}



void CCPPWizCtrl::OnSetClientSite()
{
	// This is needed for transparency and the correct drawing...
	m_bAutoClip = TRUE;
	COleControl::OnSetClientSite();
}

void CCPPWizCtrl::OnMove(int x, int y)
{
	COleControl::OnMove(x, y);

	// TODO: Add your message handler code here
	InvalidateControl();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\dlgreplacefile.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// DlgReplaceFile.cpp : implementation file
//

#include "precomp.h"
#include "cppwiz.h"
#include "DlgReplaceFile.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgReplaceFile dialog


CDlgReplaceFile::CDlgReplaceFile(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgReplaceFile::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgReplaceFile)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDlgReplaceFile::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgReplaceFile)
	DDX_Control(pDX, IDC_EDIT_FILENAMES, m_edtFilenames);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgReplaceFile, CDialog)
	//{{AFX_MSG_MAP(CDlgReplaceFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgReplaceFile message handlers


int CDlgReplaceFile::QueryReplaceFiles(CStringArray& saFiles)
{
	int nFiles = (int) saFiles.GetSize();
	if (nFiles <= 0) {
		return IDOK;
	}

	m_psaFilenames = &saFiles;
	int iResult = (int) DoModal();
	return iResult;
}

BOOL CDlgReplaceFile::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO: Add extra initialization here


	int nFiles = (int) m_psaFilenames->GetSize();
	for (int iFile = 0; iFile < nFiles; ++iFile) {
		m_edtFilenames.SetSel(-1, -1);

		LPCTSTR pszFilename = (*m_psaFilenames)[iFile];
		m_edtFilenames.ReplaceSel(pszFilename);
		m_edtFilenames.SetSel(-1, -1);
		m_edtFilenames.ReplaceSel(_T("\r\n"));
	}



	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\cppwizppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// CPPWizPpg.h : Declaration of the CCPPWizPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CCPPWizPropPage : See CPPWizPpg.cpp.cpp for implementation.

class CCPPWizPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CCPPWizPropPage)
	DECLARE_OLECREATE_EX(CCPPWizPropPage)

// Constructor
public:
	CCPPWizPropPage();

// Dialog Data
	//{{AFX_DATA(CCPPWizPropPage)
	enum { IDD = IDD_PROPPAGE_CPPWIZ };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CCPPWizPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\dlgreplacefilequery.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// DlgReplaceFileQuery.cpp : implementation file
//
// This file implements a dialog that informs the user that a provider
// already exists and asks whether or not it should be replaced.
//
// Origionally, this file also implemented the file replacement query
// dialog, but since then a new class in DlgReplaceFile.cpp implements
// this functionality.
//
//

#include "precomp.h"
#include "cppwiz.h"
#include "DlgReplaceFileQuery.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgReplaceFileQuery dialog


CDlgReplaceFileQuery::CDlgReplaceFileQuery(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgReplaceFileQuery::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgReplaceFileQuery)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDlgReplaceFileQuery::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgReplaceFileQuery)
	DDX_Control(pDX, IDC_STAT_REPLACEFILE, m_statReplaceMessage);
	//}}AFX_DATA_MAP
}


int CDlgReplaceFileQuery::QueryReplaceProvider(LPCTSTR pszClass)
{
	m_sTitle = _T("Provider Already Exists");

	int cch = _tcslen(pszClass);
	cch += 128 * sizeof(TCHAR);	// Some extra space for the constant part of the string.
	LPTSTR pszDst = m_sMessage.GetBuffer(cch);\
	_stprintf(pszDst, _T("A provider for class %s already exists.  Do you want to replace it?"), pszClass);
	m_sMessage.ReleaseBuffer();


	int iResult = (int) DoModal();

//	enum {DLGREPLACE_YES, DLGREPLACE_YESALL, DLGREPLACE_CANCEL};

	return iResult;
}


BEGIN_MESSAGE_MAP(CDlgReplaceFileQuery, CDialog)
	//{{AFX_MSG_MAP(CDlgReplaceFileQuery)
	ON_BN_CLICKED(ID_YESALL, OnYesall)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgReplaceFileQuery message handlers

void CDlgReplaceFileQuery::OnYesall()
{
	// TODO: Add your control notification handler code here
	EndDialog(DLGREPLACE_YESALL);
}

void CDlgReplaceFileQuery::OnOK()
{
	// TODO: Add extra validation here
	EndDialog(DLGREPLACE_YES);

}

void CDlgReplaceFileQuery::OnCancel()
{
	// TODO: Add extra cleanup here
	EndDialog(DLGREPLACE_CANCEL);
}

BOOL CDlgReplaceFileQuery::OnInitDialog()
{
	CDialog::OnInitDialog();
	SetWindowText(m_sTitle);

	m_statReplaceMessage.SetWindowText(m_sMessage);


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\dlgreplacefile.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_DLGREPLACEFILE_H__20D23197_BD51_11D2_B34B_00105AA680B8__INCLUDED_)
#define AFX_DLGREPLACEFILE_H__20D23197_BD51_11D2_B34B_00105AA680B8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgReplaceFile.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgReplaceFile dialog

class CDlgReplaceFile : public CDialog
{
// Construction
public:
	CDlgReplaceFile(CWnd* pParent = NULL);   // standard constructor
	int QueryReplaceFiles(CStringArray& saFiles);

// Dialog Data
	//{{AFX_DATA(CDlgReplaceFile)
	enum { IDD = IDD_REPLACEFILE };
	CEdit	m_edtFilenames;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgReplaceFile)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgReplaceFile)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CStringArray* m_psaFilenames;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGREPLACEFILE_H__20D23197_BD51_11D2_B34B_00105AA680B8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#endif //_UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\dlgreplacefilequery.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_DLGREPLACEFILEQUERY_H__F655E007_87FA_11D2_B334_00105AA680B8__INCLUDED_)
#define AFX_DLGREPLACEFILEQUERY_H__F655E007_87FA_11D2_B334_00105AA680B8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgReplaceFileQuery.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgReplaceFileQuery dialog

enum {DLGREPLACE_YES, DLGREPLACE_YESALL, DLGREPLACE_CANCEL};
class CDlgReplaceFileQuery : public CDialog
{
// Construction
public:
	CDlgReplaceFileQuery(CWnd* pParent = NULL);   // standard constructor
	int QueryReplaceProvider(LPCTSTR pszClass);

// Dialog Data
	//{{AFX_DATA(CDlgReplaceFileQuery)
	enum { IDD = IDD_REPLACE_QUERY };
	CStatic	m_statReplaceMessage;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgReplaceFileQuery)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgReplaceFileQuery)
	afx_msg void OnYesall();
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	
private:
	CString m_sMessage;
	CString m_sTitle;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGREPLACEFILEQUERY_H__F655E007_87FA_11D2_B334_00105AA680B8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\mypropertypage1.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MyPropertyPage1.cpp : implementation file
//
#include "precomp.h"
#include  <io.h>
#include  <stdio.h>
#include  <stdlib.h>
#include <direct.h>
#include "resource.h"
#include <SHLOBJ.H>
#include "wbemidl.h"
#include <afxcmn.h>
#include "moengine.h"
#include "CPPWiz.h"
#include "CPPWizCtl.h"
#include <afxcmn.h>
#include "WrapListCtrl.h"
#include "hlb.h"
#include "MyPropertyPage1.h"
#include "CppGenSheet.h"
#include "DlgReplaceFileQuery.h"
#include "DlgReplacefile.h"
#include "logindlg.h"
#include <wbemidl.h>



#define MAX_CLASS_DESCRIPTION 2047
#define MAX_CLASS_NAME 511


#define QUERY_TIMEOUT 10000
#define NMAKE_MAX_PATH 247


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define IDH_actx_WBEM_Developer_Studio 200

IMPLEMENT_DYNCREATE(CMyPropertyPage1, CPropertyPage)
IMPLEMENT_DYNCREATE(CMyPropertyPage2, CPropertyPage)
IMPLEMENT_DYNCREATE(CMyPropertyPage3, CPropertyPage)
IMPLEMENT_DYNCREATE(CMyPropertyPage4, CPropertyPage)

BOOL IsValidCPPClassName(CString csCPPClass)
{

	if (csCPPClass.IsEmpty())
	{
		return FALSE;
	}
	else if (isdigit(csCPPClass[0]))
	{

		return FALSE;
	}

	for (int i = 0; i < csCPPClass.GetLength(); i++)
	{
		TCHAR tcTest = csCPPClass[i];
		TCHAR a = 'a';
		TCHAR z = 'z';
		TCHAR A = 'A';
		TCHAR Z = 'Z';
		TCHAR Underscore = '_';
		BOOL bTest = (	isdigit(tcTest) ||
						tcTest >=  a && tcTest <= z ||
						tcTest >= A && tcTest <= Z ||
						tcTest == Underscore);
		if (bTest == 0)
		{
			return FALSE;
		}

	}

	return TRUE;


}

int GetCBitmapWidth(const CBitmap & cbm)
{

	BITMAP bm;
	cbm.GetObject(sizeof(BITMAP),&bm);
	return bm.bmWidth;
}

int GetCBitmapHeight(const CBitmap & cbm)
{
	BITMAP bm;
	cbm.GetObject(sizeof(BITMAP),&bm);
	return bm.bmHeight;
}


HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPCTSTR lpString,
                           HPALETTE FAR* lphPalette)
{
    HRSRC  hRsrc;
    HGLOBAL hGlobal;
    HBITMAP hBitmapFinal = NULL;
    LPBITMAPINFOHEADER  lpbi;
    HDC hdc;
    int iNumColors;

    if (hRsrc = FindResource(hInstance, lpString, RT_BITMAP))
       {
       hGlobal = LoadResource(hInstance, hRsrc);
       lpbi = (LPBITMAPINFOHEADER)LockResource(hGlobal);

       hdc = GetDC(NULL);
       *lphPalette =  CreateDIBPalette ((LPBITMAPINFO)lpbi, &iNumColors);
       if (*lphPalette)
          {
			SelectPalette(hdc,*lphPalette,FALSE);
			RealizePalette(hdc);
          }

       hBitmapFinal = CreateDIBitmap(hdc,
                   (LPBITMAPINFOHEADER)lpbi,
                   (LONG)CBM_INIT,
                   (LPSTR)lpbi + lpbi->biSize + iNumColors *
sizeof(RGBQUAD),

                   (LPBITMAPINFO)lpbi,
                   DIB_RGB_COLORS );

       ReleaseDC(NULL,hdc);
       UnlockResource(hGlobal);
       FreeResource(hGlobal);
       }
    return (hBitmapFinal);
}

HPALETTE CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors)
{
   LPBITMAPINFOHEADER  lpbi;
   LPLOGPALETTE     lpPal;
   HANDLE           hLogPal;
   HPALETTE         hPal = NULL;
   int              i;

   lpbi = (LPBITMAPINFOHEADER)lpbmi;
   if (lpbi->biBitCount <= 8)
       *lpiNumColors = (1 << lpbi->biBitCount);
   else
       *lpiNumColors = 0;  // No palette needed for 24 BPP DIB

   if (*lpiNumColors)
      {
      hLogPal = GlobalAlloc (GHND, sizeof (LOGPALETTE) +
                             sizeof (PALETTEENTRY) * (*lpiNumColors));
      lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
      lpPal->palVersion    = 0x300;
      lpPal->palNumEntries = (WORD)*lpiNumColors; // NOTE: lpiNumColors should NEVER be greater than 256 (1<<8 from above)

      for (i = 0;  i < *lpiNumColors;  i++)
         {
         lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
         lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
         lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
         lpPal->palPalEntry[i].peFlags = 0;
         }
      hPal = CreatePalette (lpPal);
      GlobalUnlock (hLogPal);
      GlobalFree   (hLogPal);
   }
   return hPal;
}


CPalette *GetResourcePalette(HINSTANCE hInstance, LPCTSTR lpString,
                           HPALETTE FAR* lphPalette)
{
    HRSRC  hRsrc;
    HGLOBAL hGlobal;
    HBITMAP hBitmapFinal = NULL;
    LPBITMAPINFOHEADER  lpbi;
    HDC hdc;
    int iNumColors;
	CPalette *pcpReturn = NULL;

    if (hRsrc = FindResource(hInstance, lpString, RT_BITMAP))
       {
       hGlobal = LoadResource(hInstance, hRsrc);
       lpbi = (LPBITMAPINFOHEADER)LockResource(hGlobal);

       hdc = GetDC(NULL);
       pcpReturn = CreateCPalette ((LPBITMAPINFO)lpbi, &iNumColors);
	   }
	return pcpReturn;
}


CPalette *CreateCPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors)
{
   LPBITMAPINFOHEADER  lpbi;
   LPLOGPALETTE     lpPal;
   HANDLE           hLogPal;
   HPALETTE         hPal = NULL;
   int              i;
   CPalette *pcpReturn;

   lpbi = (LPBITMAPINFOHEADER)lpbmi;
   if (lpbi->biBitCount <= 8)
       *lpiNumColors = (1 << lpbi->biBitCount);
   else
       *lpiNumColors = 0;  // No palette needed for 24 BPP DIB

   if (*lpiNumColors)
      {
      hLogPal = GlobalAlloc (GHND, sizeof (LOGPALETTE) +
                             sizeof (PALETTEENTRY) * (*lpiNumColors));
      lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
      lpPal->palVersion    = 0x300;
      lpPal->palNumEntries = (WORD)*lpiNumColors; // NOTE: lpiNumColors should NEVER be greater than 256 (1<<8 from above)

      for (i = 0;  i < *lpiNumColors;  i++)
         {
         lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
         lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
         lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
         lpPal->palPalEntry[i].peFlags = 0;
         }
	  pcpReturn = new CPalette;
      pcpReturn ->CreatePalette(lpPal);
      GlobalUnlock (hLogPal);
      GlobalFree   (hLogPal);
   }

   return pcpReturn;
}


BOOL StringInArray
(CStringArray *&rpcsaArrays, CString *pcsString, int nIndex)
{
	for (int i = 0; i < rpcsaArrays[nIndex].GetSize(); i++)
	{
		if (pcsString->CompareNoCase(rpcsaArrays[nIndex].GetAt(i)) == 0)
		{
			return TRUE;
		}

	}

	return FALSE;

}

BOOL TryToFindShare(CString *pcsDir)
{
	// Need to append *.* to the share because FindFirstFile will not
	// find shares but will find files in shares, even empty shares.

	CString csTemp = *pcsDir + _T("\\*.*");

	WIN32_FIND_DATA wfdFile;
	HANDLE hFile =
		FindFirstFile(
			(LPCTSTR) csTemp, &wfdFile);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}
	else
	{

		return TRUE;
	}
}


BOOL TryToFindDirectory(CString *pcsDir)
{
	if (pcsDir->GetLength() < 3 && pcsDir->GetLength() >= 2 && (*pcsDir)[1] == ':')
	{
		UINT  uDriveType = GetDriveType((LPCTSTR) *pcsDir);

		if (!(uDriveType == DRIVE_UNKNOWN  || uDriveType ==DRIVE_NO_ROOT_DIR))
		{
			return TRUE;
		}
	}

	if (pcsDir->GetLength() > 2 && (*pcsDir)[0] == '\\' && (*pcsDir)[1] == '\\')
	{
		// We have a UNC name like \\foocomputer\sharename.
		return TryToFindShare(pcsDir);

	}

	WIN32_FIND_DATA wfdFile;
	HANDLE hFile =
		FindFirstFile(
			(LPCTSTR) *pcsDir, &wfdFile);

	int n = pcsDir->ReverseFind('\\');

	CString csFile;

	if (n == -1)
	{
		csFile = *pcsDir;
	}
	else
	{
		csFile = pcsDir->Right((pcsDir->GetLength() - 1) - n);
	}


	if (csFile.CompareNoCase(wfdFile.cFileName) != 0)
	{
		return FALSE;
	}

	if (hFile == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	BOOL bValue = wfdFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;

	return wfdFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
}

BOOL IsDriveValid(CWnd *pcwnd, CString *pcsDir, BOOL bRetry)
{
	if (pcsDir->GetLength() < 3 && pcsDir->GetLength() >= 2 && (*pcsDir)[1] == ':')
	{
		UINT  uDriveType = GetDriveType((LPCTSTR) *pcsDir);

		if (!(uDriveType == DRIVE_UNKNOWN  || uDriveType == DRIVE_NO_ROOT_DIR || uDriveType == DRIVE_CDROM))
		{
			CString csFile = *pcsDir + _T("f45b789");
			SECURITY_ATTRIBUTES saTemp;
			saTemp.nLength = sizeof(SECURITY_ATTRIBUTES);
			saTemp.lpSecurityDescriptor = NULL;
			saTemp.bInheritHandle = TRUE;

			HANDLE hTemp = CreateFile
							((LPCTSTR) csFile,
							GENERIC_WRITE,
							FILE_SHARE_WRITE,
							&saTemp,
							CREATE_ALWAYS,
							FILE_ATTRIBUTE_NORMAL,
							NULL);

			if (hTemp == INVALID_HANDLE_VALUE)
			{
				if (!bRetry)
				{
					return FALSE;
				}

				CString csPrompt = _T("Drive ") + *pcsDir + _T(" may not be ready.");
				int nReturn =
				pcwnd -> MessageBox
				( csPrompt,
				_T("Retry or Cancel"),
				MB_ICONQUESTION | MB_RETRYCANCEL  |
				MB_APPLMODAL);
				if (nReturn == IDRETRY)
				{
					return IsDriveValid(pcwnd, pcsDir, bRetry);
				}
				else
				{
					return FALSE;
				}
			}

			FlushFileBuffers(hTemp);
			CloseHandle(hTemp);

			BOOL bDelete = DeleteFile(csFile);
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL TryToCreateDirectory (CString &csOutputDir, int nIndex)
{
	CString csDir;
	CString Next;

	CString csSearch = csOutputDir.Mid(nIndex);
	int n = csSearch.Find('\\');
	if (n == -1)
	{
		n = csOutputDir.GetLength();
	}

	csDir = csOutputDir.Left(n + nIndex);
	BOOL bReturn = CreateDirectory((LPCTSTR) csDir, NULL);
	if (n == csOutputDir.GetLength())
	{
		return bReturn;
	}
	else
	{
		return TryToCreateDirectory (csOutputDir, n + nIndex + 1);
	}


}


int TryToCreateDirectory
(CWnd *pcwnd, CString &csOutputDir)
{
	CString csPrompt;
	csPrompt = _T("Directory \"") + csOutputDir + _T("\" does not exist.  ");
	csPrompt += _T("Do you wish to create it?");
	int nReturn =
		pcwnd -> MessageBox
		( csPrompt,
		_T("Create Directory?"),
		MB_YESNO  | MB_ICONQUESTION | MB_DEFBUTTON1 |
		MB_APPLMODAL);
	if (nReturn == IDYES)
	{
		BOOL bReturn = CreateDirectory((LPCTSTR) csOutputDir, NULL);
		if (!bReturn)
		{
			BOOL bReturn = TryToCreateDirectory (csOutputDir,0);
			if (bReturn)
			{
				return IDYES;
			}
			else
			{
				if (!bReturn)
				{
					CString csUserMsg;
					csUserMsg =  _T("Could not create directory \"") + csOutputDir;
					csUserMsg += _T("\".  ");
					csUserMsg += _T("Please enter another directory name or \"Cancel\" out of the Provider Wizard.");

					ErrorMsg
						(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
						__LINE__ );

				}
				return IDNO;
			}
		}
		else
		{
			return IDYES;
		}
	}
	else
	{
		return IDNO;
	}
}



//***********************************************************
// IsValidFilename
//
// Validate a base filename.  Note that this validation method
// is not intended to work with a complete path.
//
// Parameters;
//		[in] CString &csFilename
//			The base filename (not a full path).
//
//		[in] CString& csExtions
//			The filename extension.
//
// Returns:
//		TRUE if the filename is valid, FALSE otherwise.
//
//*************************************************************
BOOL IsValidFilename(CString &csFilename, CString &csExtension, CWnd *pParent, BOOL &bNoTemp)
{
	bNoTemp = FALSE;

	if (csFilename.SpanExcluding(_T(" ")).GetLength() == 0)
	{
		return FALSE;
	}

	if (csFilename.Find(_T(':')) != -1) {
		return FALSE;
	}

	if (csFilename.Find(_T('\\')) != -1) {
		return FALSE;
	}

	if (csFilename.Find(_T('/')) != -1) {
		return FALSE;
	}

	// For some reason the windows explorer won't let you rename or delete files that
	// are too long (that's probably their bug).
	int nFilenameLength;
	nFilenameLength = csFilename.GetLength();
	nFilenameLength += csExtension.GetLength();
	nFilenameLength += 1;
	if (nFilenameLength > NMAKE_MAX_PATH) {
		return FALSE;
	}



	TCHAR szTempPath[_MAX_PATH];
	DWORD dwReturn = GetTempPath(_MAX_PATH,szTempPath);
	DWORD dwError = GetLastError();
	CString csTempDir;
	if (dwReturn > 0)
	{
		csTempDir = szTempPath;
	}
	else
	{
		bNoTemp = TRUE;
		return FALSE;
	}

	if (!csTempDir.IsEmpty())
	{
		if (csTempDir[csTempDir.GetLength() - 1] == '\\')
		{
			csTempDir = csTempDir.Left(csTempDir.GetLength() - 1);
		}
		BOOL bTemp = TryToFindDirectory(&csTempDir);

		if (!bTemp)
		{
			CString csUserMsg;
			csUserMsg =  _T("The temporary directory \"") + csTempDir;
			csUserMsg +=  _T("\" does not exist.  Do you wish to create it?");
			int nReturn =
				pParent -> MessageBox
				(
				csUserMsg,
				_T("Create Directory?"),
				MB_YESNO  | MB_ICONQUESTION | MB_DEFBUTTON1 |
				MB_APPLMODAL);
			if (nReturn == IDNO)
			{
				bNoTemp = TRUE;
				return FALSE;
			}

			BOOL bCreated = TryToCreateDirectory (csTempDir, 0);

			if (!bCreated)
			{
				CString csUserMsg;
				csUserMsg =  _T("Could not create directory \"") + csTempDir;
				csUserMsg += _T("\".  ");
				csUserMsg += _T("Please try to create a temporary directory by that name outside of the Provider Wizard.");

				ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ );
				bNoTemp = TRUE;
				return FALSE;

			}
		}
	}

	CString csFile = csTempDir + _T("\\");

	csFile += csFilename + csExtension;
	SECURITY_ATTRIBUTES saTemp;
	saTemp.nLength = sizeof(SECURITY_ATTRIBUTES);
	saTemp.lpSecurityDescriptor = NULL;
	saTemp.bInheritHandle = TRUE;

	HANDLE hTemp = CreateFile
					((LPCTSTR) csFile,
					GENERIC_WRITE,
					FILE_SHARE_WRITE,
					&saTemp,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	BOOL bIsValid = TRUE;

	if (hTemp == INVALID_HANDLE_VALUE)
	{
		bIsValid = FALSE;
		return bIsValid;
	}

	FlushFileBuffers(hTemp);
	CloseHandle(hTemp);

	BOOL bDelete = DeleteFile(csFile);

	return bIsValid;
}

void InitializeLogFont
(LOGFONT &rlfFont, CString csName, int nHeight, int nWeight)
{
	_tcscpy(rlfFont.lfFaceName, (LPCTSTR) csName);
	rlfFont.lfWeight = nWeight;
	rlfFont.lfHeight = nHeight;
	rlfFont.lfEscapement = 0;
	rlfFont.lfOrientation = 0;
	rlfFont.lfWidth = 0;
	rlfFont.lfItalic = FALSE;
	rlfFont.lfUnderline = FALSE;
	rlfFont.lfStrikeOut = FALSE;
	rlfFont.lfCharSet = ANSI_CHARSET;
	rlfFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
	rlfFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	rlfFont.lfQuality = DEFAULT_QUALITY;
	rlfFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
}


CRect OutputTextString
(CPaintDC *pdc, CWnd *pcwnd, CString *pcsTextString, int x, int y,
 CString *pcsFontName = NULL, int nFontHeight = 0, int nFontWeigth = 0)
{
	CRect crReturn;
	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont cfFont;
	CFont* pOldFont = NULL;
	TEXTMETRIC tmFont;

	if (pcsFontName)
	{
		LOGFONT lfFont;
		InitializeLogFont
			(lfFont, *pcsFontName, nFontHeight * 10, nFontWeigth);

		cfFont.CreatePointFontIndirect(&lfFont, pdc);

		pOldFont = pdc -> SelectObject( &cfFont );
	}

	pdc->GetTextMetrics(&tmFont);

	pdc->SetBkMode( TRANSPARENT );

	pdc->TextOut( x, y, *pcsTextString, pcsTextString->GetLength());

	CSize csText = pdc->GetTextExtent( *pcsTextString);

	crReturn.TopLeft().x = x;
	crReturn.TopLeft().y = y;
	crReturn.BottomRight().x = x + csText.cx;
	crReturn.BottomRight().y = y + csText.cy;

	pdc->SetBkMode( OPAQUE );

	if (pcsFontName)
	{
		pdc -> SelectObject(pOldFont);
	}

	 return crReturn;
}

void OutputTextString
(CPaintDC *pdc, CWnd *pcwnd, CString *pcsTextString, int x, int y,
 CRect &crExt, CString *pcsFontName = NULL, int nFontHeight = 0,
 int nFontWeigth = 0)
{

	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont cfFont;
	CFont* pOldFont = NULL;

	if (pcsFontName)
	{
		LOGFONT lfFont;
		InitializeLogFont
			(lfFont, *pcsFontName, nFontHeight * 10, nFontWeigth);

		cfFont.CreatePointFontIndirect(&lfFont, pdc);

		pOldFont = pdc -> SelectObject( &cfFont );
	}

	pdc->SetBkMode( TRANSPARENT );

	CRect crBounds(x,y,x + crExt.Width(), y + crExt.Height());
	pdc->DrawText(*pcsTextString, crBounds,DT_WORDBREAK);

	pdc->SetBkMode( OPAQUE );

	if (pcsFontName)
	{
		pdc -> SelectObject(pOldFont);
	}

	 return;
}


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage1 property page

CMyPropertyPage1::CMyPropertyPage1() : CPropertyPage(CMyPropertyPage1::IDD)
{
	//{{AFX_DATA_INIT(CMyPropertyPage1)
	//}}AFX_DATA_INIT
	m_pParent = NULL;
	m_pcilImageList = NULL;
	m_bInitDraw = TRUE;
	m_pcphImage = NULL;

}

CMyPropertyPage1::~CMyPropertyPage1()
{
	delete m_pcilImageList;
}

void CMyPropertyPage1::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyPropertyPage1)
	DDX_Control(pDX, IDC_STATICMAINEXTENT, m_staticMainExt);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyPropertyPage1, CPropertyPage)
	//{{AFX_MSG_MAP(CMyPropertyPage1)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage2 property page

CMyPropertyPage2::CMyPropertyPage2() : CPropertyPage(CMyPropertyPage2::IDD)
{
	//{{AFX_DATA_INIT(CMyPropertyPage2)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pParent = NULL;

}

CMyPropertyPage2::~CMyPropertyPage2()
{
}

void CMyPropertyPage2::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyPropertyPage2)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyPropertyPage2, CPropertyPage)
	//{{AFX_MSG_MAP(CMyPropertyPage2)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage3 property page

CMyPropertyPage3::CMyPropertyPage3() : CPropertyPage(CMyPropertyPage3::IDD)
{
	//{{AFX_DATA_INIT(CMyPropertyPage3)
	//}}AFX_DATA_INIT
	m_pParent = NULL;
	m_pcilImageList = NULL;
	m_pcilStateImageList = NULL;
	m_nCurSel = -1;
	m_nNonLocalProps = 0;
	m_bFirstActivate = TRUE;
}

CMyPropertyPage3::~CMyPropertyPage3()
{

}

void CMyPropertyPage3::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyPropertyPage3)
	DDX_Control(pDX, IDC_STATICPAGE3EXT, m_staticPage3Ext);
	DDX_Control(pDX, IDC_CHECKOVERRIDE, m_cbOverRide);
	DDX_Control(pDX, IDC_LISTPROPERTIES, m_clcProperties);
	DDX_Control(pDX, IDC_LIST1, m_clClasses);
	DDX_Control(pDX, IDC_EDIT3, m_ceDescription);
	DDX_Control(pDX, IDC_EDIT2, m_ceCPPClass);
	DDX_Control(pDX, IDC_EDIT1, m_ceBaseFile);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyPropertyPage3, CPropertyPage)
	//{{AFX_MSG_MAP(CMyPropertyPage3)
	ON_WM_CREATE()
	ON_EN_CHANGE(IDC_EDIT1, OnChangeEditBaseFileName)
	ON_LBN_SELCHANGE(IDC_LIST1, OnSelchangeList1)
	ON_EN_CHANGE(IDC_EDIT2, OnChangeEditCPPName)
	ON_EN_CHANGE(IDC_EDIT3, OnChangeEditDescription)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_CHECKOVERRIDE, OnCheckoverride)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage4 property page

CMyPropertyPage4::CMyPropertyPage4() : CPropertyPage(CMyPropertyPage4::IDD)
{
	//{{AFX_DATA_INIT(CMyPropertyPage4)
	//}}AFX_DATA_INIT
	m_pParent = NULL;
	m_bFirstActivate = TRUE;
}

CMyPropertyPage4::~CMyPropertyPage4()
{
}

void CMyPropertyPage4::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyPropertyPage4)
	DDX_Control(pDX, IDC_STATICPAGE4EXT, m_staticPage4Ext);
	DDX_Control(pDX, IDC_PROVIDERNAME, m_ceProviderName);
	DDX_Control(pDX, IDC_EDITPROVIDERDESCRIPTION, m_ceProviderDescription);
	DDX_Control(pDX, IDC_EDITTLBDIR, m_ceTlbDir);
	DDX_Control(pDX, IDC_EDITCPPDIR, m_ceCPPDir);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyPropertyPage4, CPropertyPage)
	//{{AFX_MSG_MAP(CMyPropertyPage4)
	ON_WM_CREATE()
	ON_BN_CLICKED(IDC_BUTTONCPPDIR, OnButtoncppdir)
	ON_BN_CLICKED(IDC_BUTTONTLBDIR, OnButtontlbdir)
	ON_EN_CHANGE(IDC_EDITCPPDIR, OnChangeEditcppdir)
	ON_EN_CHANGE(IDC_EDITTLBDIR, OnChangeEdittlbdir)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()



int CMyPropertyPage4::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_pParent = reinterpret_cast<CCPPGenSheet *>
					(GetLocalParent());

	return 0;
}

BOOL CMyPropertyPage4::OnSetActive()
{
	// TODO: Add your specialized code here and/or call the base class
	m_pParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
	CWnd *pBack = GetLocalParent()->GetDlgItem(ID_WIZBACK);
	if (pBack)
	{
		pBack->ShowWindow(SW_SHOW);
	}
	CWnd *pFinish = GetLocalParent()->GetDlgItem(ID_WIZFINISH);


	if (m_bFirstActivate == FALSE)
	{
		return CPropertyPage::OnSetActive();
	}
	m_bFirstActivate = FALSE;

	CString csProviderOutputPath =  m_pParent->GetLocalParent()->
									GetProviderOutputPath();

	CString csProviderTLBPath =  m_pParent->GetLocalParent()->
									GetProviderTLBPath();

	TCHAR buffer[_MAX_PATH];

	CString csWorkingDirectory;

	SCODE sc = m_pParent->GetLocalParent()->
				GetSDKDirectory(csWorkingDirectory);


	/* Try the WBEM subdir */
	if (csWorkingDirectory.GetLength() > 0)
	{
		if (csProviderTLBPath.IsEmpty())
		{
			m_ceTlbDir.SetWindowText(csWorkingDirectory);
		}
		else
		{
			m_ceTlbDir.SetWindowText((LPCTSTR)csProviderTLBPath);
		}

		if (csProviderOutputPath.IsEmpty())
		{
			m_ceCPPDir.SetWindowText(csWorkingDirectory);
		}
		else
		{
			m_ceCPPDir.SetWindowText((LPCTSTR)csProviderOutputPath);
		}

	}
	 /* Else get the current working directory: */
	else if(_tgetcwd ( buffer, _MAX_PATH ) != NULL )
	{
		if (csProviderTLBPath.IsEmpty())
		{
			m_ceTlbDir.SetWindowText(buffer);
		}
		else
		{
			m_ceTlbDir.SetWindowText((LPCTSTR)csProviderTLBPath);
		}

		if (csProviderOutputPath.IsEmpty())
		{
			m_ceCPPDir.SetWindowText(buffer);
		}
		else
		{
			m_ceCPPDir.SetWindowText((LPCTSTR)csProviderOutputPath);
		}
	}

	m_ceProviderName.SetWindowText(_T("NewProv"));

	return CPropertyPage::OnSetActive();
}


CString CMyPropertyPage4::GetFolder()
{
	CString csDir;

	IMalloc *pimMalloc = NULL;

	HRESULT hr = CoGetMalloc(MEMCTX_TASK,&pimMalloc);

	BROWSEINFO bi;
    LPTSTR lpBuffer;
    //LPITEMIDLIST pidlPrograms;  // PIDL for Programs folder
    LPITEMIDLIST pidlBrowse;    // PIDL selected by user

    // Allocate a buffer to receive browse information.
    if ((lpBuffer = (LPTSTR) pimMalloc->Alloc(MAX_PATH)) == NULL)
	{
		pimMalloc->Release();
        return csDir;
	}



    // Fill in the BROWSEINFO structure.
    bi.hwndOwner = this->GetSafeHwnd();
    bi.pidlRoot = NULL; // pidlPrograms;
    bi.pszDisplayName = lpBuffer;
    bi.lpszTitle = _T("Select a Directory");
    bi.ulFlags = BIF_RETURNONLYFSDIRS;
    bi.lpfn = NULL;
    bi.lParam = 0;

    // Browse for a folder and return its PIDL.
    pidlBrowse = SHBrowseForFolder(&bi);
    if (pidlBrowse != NULL) {

		if (SHGetPathFromIDList(pidlBrowse,lpBuffer))
		{
			csDir = lpBuffer;
		}
        // Free the PIDL returned by SHBrowseForFolder.
        pimMalloc->Free(pidlBrowse);
    }

    // Clean up.
    pimMalloc->Free(lpBuffer);
	pimMalloc->Release();
	return csDir;

}



BOOL CMyPropertyPage1::OnSetActive()
{
	// TODO: Add your specialized code here and/or call the base class
	m_pParent->SetWizardButtons(PSWIZB_NEXT);
	CWnd *pBack = GetParent()->GetDlgItem(ID_WIZBACK);

	if (pBack)
	{
		pBack->ShowWindow(SW_HIDE);
	}

	CWnd *pHelp = GetLocalParent()->GetDlgItem(IDHELP);
	if (pHelp)
	{
		pHelp->SetWindowText(_T("&Help"));
	}


	return CPropertyPage::OnSetActive();
}

int CMyPropertyPage1::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_pParent = reinterpret_cast<CCPPGenSheet *>
					(GetLocalParent());

	// TODO: Add your specialized creation code here

	return 0;
}

BOOL CMyPropertyPage2::OnSetActive()
{
	// TODO: Add your specialized code here and/or call the base class
	m_pParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	return CPropertyPage::OnSetActive();
}

int CMyPropertyPage2::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_pParent = reinterpret_cast<CCPPGenSheet *>
					(GetLocalParent());

	// TODO: Add your specialized creation code here

	return 0;
}

BOOL CMyPropertyPage3::OnSetActive()
{
	// TODO: Add your specialized code here and/or call the base class
	m_pParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	CWnd *pBack = GetLocalParent()->GetDlgItem(ID_WIZBACK);
	if (pBack)
	{
		pBack->ShowWindow(SW_SHOW);
	}

	if (m_bFirstActivate == FALSE)
	{
		return CPropertyPage::OnSetActive();
	}

	m_bFirstActivate = FALSE;


	CStringArray &rcsaClasses =
		m_pParent->GetLocalParent()->GetClasses();

	//OnSelchangeList1();

	int i;
	m_clClasses.ResetContent();

	for (i = 0; i < rcsaClasses.GetSize();i++)
	{
		if (m_clClasses.FindString( -1, (LPCTSTR)rcsaClasses.GetAt(i))
				==  LB_ERR)
		{
			m_clClasses.AddString
				((LPCTSTR)rcsaClasses.GetAt(i));
		}
	}

	OnSelchangeList1();

	SetListLocalProperties
		(&rcsaClasses.GetAt(m_nCurSel));

	return CPropertyPage::OnSetActive();
}

int CMyPropertyPage3::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_pParent = reinterpret_cast<CCPPGenSheet *>
					(GetLocalParent());



	return 0;
}


void CMyPropertyPage1::OnPaint()
{
	CPaintDC dc(this); // device context for painting


	if (!m_pcphImage)
	{
		HBITMAP hBitmap;
		HPALETTE hPalette;
		BITMAP bm;

		WORD wRes = MAKEWORD(IDB_BITMAPMAIN,0);
		hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

		GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
		m_nBitmapW = bm.bmWidth;
		m_nBitmapH  = bm.bmHeight;

		m_pcphImage = new CPictureHolder();
		m_pcphImage->CreateFromBitmap(hBitmap, hPalette );

	}

	CRect rcMainExt;
	m_staticMainExt.GetWindowRect(&rcMainExt);
	ScreenToClient(rcMainExt);

	if(m_pcphImage->GetType() != PICTYPE_NONE &&
	   m_pcphImage->GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(m_pcphImage->m_pPict
		   && SUCCEEDED(m_pcphImage->m_pPict->get_hPal((unsigned int *)&hpal)))

		{

			HPALETTE hpSave = SelectPalette(dc.m_hDC,(HPALETTE)hpal,TRUE);

			dc.RealizePalette();

			dc.FillRect(&rcMainExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			m_pcphImage->Render(&dc, rcMainExt, rcMainExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	//CRect rcFrame(0,0,m_nBitmapW,m_nBitmapH);
	CRect rcFrame(	rcMainExt.TopLeft().x,
					rcMainExt.TopLeft().y,
					rcMainExt.BottomRight().x,
					rcMainExt.BottomRight().y);
	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));

	CString csFont = _T("MS Shell Dlg");


	CString csOut = _T("Welcome to the");

	CRect crOut = OutputTextString
		(&dc, this, &csOut, 45, 54, &csFont, 8, FW_BOLD);

	csOut = _T("Provider Code Generator Wizard");

	csFont = _T("MS Shell Dlg");

	crOut =  OutputTextString
		(&dc, this, &csOut, crOut.TopLeft().x + 15, crOut.BottomRight().y + 8,
		&csFont, 16, FW_BOLD);

	csOut = _T("This wizard generates C++ code that you can customize to create a dynamic instance provider for the selected class or classes.");


	CPoint cpRect(crOut.TopLeft().x, crOut.BottomRight().y + 15);

	crOut.TopLeft().x = 0;
	crOut.TopLeft().y = 0;
	crOut.BottomRight().x = rcMainExt.BottomRight().x - cpRect.x;
	crOut.BottomRight().y = rcMainExt.BottomRight().y - cpRect.y;

	csFont = _T("MS Shell Dlg");

	OutputTextString
		(&dc, this, &csOut, cpRect.x, cpRect.y, crOut, &csFont, 8, FW_NORMAL);

	// Do not call CPropertyPage::OnPaint() for painting messages
}

void CMyPropertyPage3::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_BITMAPPAGE,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );

	CRect rcPage3Ext;
	m_staticPage3Ext.GetWindowRect(&rcPage3Ext);
	ScreenToClient(rcPage3Ext);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{
			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,TRUE);

			dc.RealizePalette();

			dc.FillRect(&rcPage3Ext, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcPage3Ext, rcPage3Ext);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame(rcPage3Ext);

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));


	CString csFont = _T("MS Shell Dlg");

	CString csOut = _T("Specify names and properties");

	CRect crOut = OutputTextString
		(&dc, this, &csOut, 8, 1, &csFont, 8, FW_BOLD);

	csOut = _T("For each class, specify the base name for the C++ files that will be generated as well as the name for");

	csOut += _T(" the C++ class.  If you want to override any inherited properties of the class, select the properties you");

	csOut += _T(" want to override.");

	CPoint cpRect(crOut.TopLeft().x + 15, crOut.BottomRight().y + 1);

	crOut.TopLeft().x = 0;
	crOut.TopLeft().y = 0;
	crOut.BottomRight().x = rcPage3Ext.BottomRight().x - cpRect.x;
	crOut.BottomRight().y = rcPage3Ext.BottomRight().y - cpRect.y;

	OutputTextString
		(&dc, this, &csOut, cpRect.x, cpRect.y, crOut, &csFont, 8, FW_NORMAL);


	// Do not call CPropertyPage::OnPaint() for painting messages
}

void CMyPropertyPage3::OnChangeEditBaseFileName()
{
	int nIndex = m_clClasses.GetCurSel();
	if (nIndex == -1)
	{
		nIndex = 0;
	}
	CString csText;
	m_ceBaseFile.GetWindowText(csText);
	CStringArray &rcsaClassBaseNames =
		m_pParent->GetLocalParent()->GetClassBaseNames();
	rcsaClassBaseNames.SetAt(nIndex,(LPCTSTR) csText);

}



//******************************************************
// CMyPropertyPage3::BasenameIsUnique
//
// All basenames must be unique because the moengine is not smart
// enough to generate multiple providers into the same file.  This
// implies that we need to check to see if a basename (for the cppfile)
// corresponding to a class will be unique prior to changing the basename.
//
// This method checks for uniqueness.
//
// Parameters:
//		None.
//
// Returns:
//		BOOL
//			TRUE if the name is unique, FALSE otherwise.
//
//***********************************************************
BOOL CMyPropertyPage3::BasenameIsUnique()
{
	if (m_nCurSel < 0) {
		// If there is no current selection, then we don't have to worry about
		// a duplicate basename being copied back into the array.
		return TRUE;
	}

	CString sName;
	m_ceBaseFile.GetWindowText(sName);

	CStringArray &saNames = m_pParent->GetLocalParent()->GetClassBaseNames();
	int nEntries = (int) saNames.GetSize();
	for (int iEntry=0; iEntry < nEntries; ++iEntry) {
		if (iEntry != m_nCurSel) {
			CString& sNameFromArray = saNames.GetAt(iEntry);
			if (sName.CompareNoCase(sNameFromArray) == 0) {
				TCHAR szPrompt[1024];
				_stprintf(szPrompt, _T("Base file name \"%s\" is used for another class.  Please enter a unique base file name for this class."), sName);

				MessageBox(
					szPrompt,
					_T(""),
					MB_ICONEXCLAMATION | MB_OK  |
					MB_APPLMODAL);

				return FALSE;
			}
		}
	}
	return TRUE;
}






BOOL CMyPropertyPage3::ValidateClassName()
{
	CString csText;
	m_ceCPPClass.GetWindowText(csText);

	if (csText.GetLength() > MAX_CLASS_NAME) {

		CString csUserMsg;
		csUserMsg =  _T("Class name is too long.");
		ErrorMsg
				(&csUserMsg, 0, NULL, FALSE, &csUserMsg, __FILE__,
				__LINE__ - 9);

		return FALSE;
	}

	return TRUE;

}


BOOL CMyPropertyPage3::ValidateClassDescription()
{
	CString csText;
	m_ceDescription.GetWindowText(csText);

	if (csText.GetLength() > MAX_CLASS_DESCRIPTION) {
		CString csUserMsg;
		csUserMsg =  _T("Class description is too long.");
		ErrorMsg
				(&csUserMsg, 0, NULL, FALSE, &csUserMsg, __FILE__,
				__LINE__ - 9);

		return FALSE;
	}

	return TRUE;
}


void CMyPropertyPage3::OnSelchangeList1()
{
	if (!ValidateClassName()) {
		m_clClasses.SetCurSel(m_nCurSel);
		return;
	}

	if (!ValidateClassDescription()) {
		m_clClasses.SetCurSel(m_nCurSel);
		return;
	}


	int nIndex = m_clClasses.GetCurSel();



	if (nIndex == -1 && m_nCurSel == -1)
	{
		nIndex = 0;
		m_nCurSel = 0;
		m_clClasses.SetSel( 0,  TRUE );
	}
	else if (nIndex == -1)
	{
		nIndex = m_nCurSel;
		m_clClasses.SetSel( nIndex,  TRUE );
	}
	else
	{
		int nItems = m_clClasses.GetCount();
		if (nItems > 0)
		{
			if (!BasenameIsUnique()) {
				m_clClasses.SetCurSel(m_nCurSel);
				return;
			}
		}

		m_nCurSel = nIndex;
	}



	CStringArray &rcsaClasses =
		m_pParent->GetLocalParent()->GetClasses();
	CStringArray &rcsaClassBaseNames =
		m_pParent->GetLocalParent()->GetClassBaseNames();
	CStringArray &rcsaClassCPPNames =
		m_pParent->GetLocalParent()->GetClassCPPNames();
	CStringArray &rcsaClassDescriptions =
		m_pParent->GetLocalParent()->GetClassDescriptions();
	CByteArray &rcbaInheritedPropIndicators =
		m_pParent->GetLocalParent()->GetInheritedPropIndicators();




	m_ceBaseFile.SetWindowText(rcsaClassBaseNames.GetAt(nIndex));

	m_ceCPPClass.SetWindowText(rcsaClassCPPNames.GetAt(nIndex));

	m_ceDescription.SetWindowText(rcsaClassDescriptions.GetAt(nIndex));

	SetListLocalProperties(&rcsaClasses.GetAt(nIndex));

	CStringArray *&rpcsaNonLocalProps=
			GetLocalParent() -> GetLocalParent()->
					GetNonLocalProps();

	if(rcbaInheritedPropIndicators.GetAt(nIndex) == 1)
	{
			m_cbOverRide.SetCheck(1);
			SetListNonLocalProperties(&rcsaClasses.GetAt(nIndex));
	}
	else
	{
			m_cbOverRide.SetCheck(0);
	}

	if (!CheckForNonLocalProperties(&rcsaClasses.GetAt(nIndex)))
	{
		m_cbOverRide.EnableWindow(FALSE);
	}
	else
	{
		m_cbOverRide.EnableWindow(TRUE);
	}

}

int CMyPropertyPage3::GetSelectedClass()
{
	int nIndex = m_clClasses.GetCurSel();
	if (nIndex == -1)
	{
		return 0;
	}
	return nIndex;
}

void CMyPropertyPage3::OnChangeEditCPPName()
{
	int nIndex = m_clClasses.GetCurSel();
	if (nIndex == -1)
	{
		nIndex = 0;
	}
	CString csText;
	m_ceCPPClass.GetWindowText(csText);
	CStringArray &rcsaClassCPPNames =
		m_pParent->GetLocalParent()->GetClassCPPNames();
	rcsaClassCPPNames.SetAt(nIndex,(LPCTSTR) csText);
}


void CMyPropertyPage3::OnChangeEditDescription()
{
	// !!!CR: Need to limit the description text.
	int nIndex = m_clClasses.GetCurSel();
	if (nIndex == -1)
	{
		nIndex = 0;
	}
	CString csText;
	m_ceDescription.GetWindowText(csText);
	CStringArray &rcsaClassDescriptions =
		m_pParent->GetLocalParent()->GetClassDescriptions();
	rcsaClassDescriptions.SetAt(nIndex,(LPCTSTR) csText);

}

void CMyPropertyPage4::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_BITMAPPAGE,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );

	CRect rcPage4Ext;
	m_staticPage4Ext.GetWindowRect(&rcPage4Ext);
	ScreenToClient(rcPage4Ext);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{

			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,TRUE);

			dc.RealizePalette();

			//CRect rcBitmap(0, 0, m_nBitmapW, m_nBitmapH);
			dc.FillRect(&rcPage4Ext, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcPage4Ext, rcPage4Ext);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame(rcPage4Ext);

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));

	CString csFont = _T("MS Shell Dlg");

	CString csOut = _T("Save provider");

	CRect crOut = OutputTextString
		(&dc, this, &csOut, 8, 10, &csFont, 8, FW_BOLD);


	csOut = _T("Specify a name and description for the provider, then specify where you want to save it.  Click \"Finish\"");
	csOut += _T(" to generate the C++ code.");


	CPoint cpRect(crOut.TopLeft().x + 15, crOut.BottomRight().y + 1);

	crOut.TopLeft().x = 0;
	crOut.TopLeft().y = 0;
	crOut.BottomRight().x = rcPage4Ext.BottomRight().x - cpRect.x;
	crOut.BottomRight().y = rcPage4Ext.BottomRight().y - cpRect.y;

	OutputTextString
		(&dc, this, &csOut, cpRect.x, cpRect.y, crOut, &csFont, 8, FW_NORMAL);

	// Do not call CPropertyPage::OnPaint() for painting messages
}

void CMyPropertyPage4::OnButtoncppdir()
{
	CString csFolder = GetFolder();
	if (!csFolder.IsEmpty())
	{
		 m_ceCPPDir.SetWindowText((LPCTSTR) csFolder);

	}
}

void CMyPropertyPage4::OnButtontlbdir()
{
	CString csFolder = GetFolder();
	if (!csFolder.IsEmpty())
	if (!csFolder.IsEmpty())
	{
		 m_ceTlbDir.SetWindowText((LPCTSTR) csFolder);

	}



}

void CMyPropertyPage4::OnChangeEditcppdir()
{
	CString csText;
	m_ceCPPDir.GetWindowText(csText);
	m_pParent->GetLocalParent()->GetProviderOutputPath() = csText;
}

void CMyPropertyPage4::OnChangeEdittlbdir()
{
	CString csText;
	m_ceTlbDir.GetWindowText(csText);
	m_pParent->GetLocalParent()->GetProviderTLBPath() = csText;
}

BOOL CMyPropertyPage3::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	CBitmap cbmChecks;

	cbmChecks.LoadBitmap(IDB_BITMAPCHECKS);

	m_pcilImageList = new CImageList();

	m_pcilImageList -> Create (16, 16, ILC_MASK, 6, 0);

	m_pcilImageList -> Add(&cbmChecks,RGB (255,0,0));

	cbmChecks.DeleteObject();


	m_clcProperties.SetImageList(m_pcilImageList, LVSIL_SMALL);

	LV_COLUMN lvCol;
	lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvCol.fmt = LVCFMT_LEFT;   // left-align column
	lvCol.cx = 48;             // width of column in pixels
	lvCol.iSubItem = 0;
	lvCol.pszText = _T("Include");

	int nReturn =
		m_clcProperties.InsertColumn( 0, &lvCol);



	lvCol.fmt = LVCFMT_LEFT;   // left-align column
	lvCol.cx = 200;             // width of column in pixels
	lvCol.iSubItem = 1;
	lvCol.pszText = _T("Properties");

	nReturn =
		m_clcProperties.InsertColumn( 1,&lvCol);

	int nItems = m_clcProperties.GetItemCount();

	m_clcProperties.SetLocalParent(this);

	m_pParent->GetLocalParent()-> m_pcsaNonLocalProps =
		new CStringArray[ (int) m_pParent->GetLocalParent()->GetClasses().GetSize()];

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CMyPropertyPage3::SetListLocalProperties(CString *pcsClass)
{
	IWbemClassObject *phmmcoObject = NULL;
	IWbemClassObject *pErrorObject = NULL;

	BSTR bstrTemp = pcsClass->AllocSysString();
	SCODE sc =
			m_pParent->GetLocalParent()->GetServices() ->
				GetObject
					(bstrTemp,0,NULL,&phmmcoObject,NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get class object ") + *pcsClass;
		ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 9);
		m_pParent->GetLocalParent()->ReleaseErrorObject(pErrorObject);
		return;
	}

	m_pParent->GetLocalParent()->ReleaseErrorObject(pErrorObject);
	int i;

	int n = m_clcProperties.GetItemCount() - 1;
	for (i = n; i >=0; i--)
	{
		m_clcProperties.DeleteItem(i);
	}

	m_clcProperties.UpdateWindow();


	CStringArray *pcsaLocalProps =
		m_pParent->GetLocalParent()->
			GetLocalPropNames(phmmcoObject,TRUE);

	if (pcsaLocalProps)
	{
		for (i = 0; i < pcsaLocalProps->GetSize();i++)
		{
			AddPropertyItem(&pcsaLocalProps->GetAt(i),0);
		}
		delete pcsaLocalProps;
	}

	m_clcProperties.m_nFocusItem = -1;
}

BOOL CMyPropertyPage3::CheckForNonLocalProperties(CString *pcsClass)
{
	IWbemClassObject *phmmcoObject = NULL;
	IWbemClassObject *pErrorObject = NULL;
	BOOL bReturn = FALSE;

	BSTR bstrTemp = pcsClass->AllocSysString();
	SCODE sc =
			m_pParent->GetLocalParent()->GetServices() ->
				GetObject
					(bstrTemp,0,NULL,&phmmcoObject,NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get class object ") + *pcsClass;
		ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 9);
		m_pParent->GetLocalParent()->ReleaseErrorObject(pErrorObject);
		return bReturn;
	}

	m_pParent->GetLocalParent()->ReleaseErrorObject(pErrorObject);
	CStringArray *pcsaNonLocalProps =
		m_pParent->GetLocalParent()->
			GetNonLocalPropNames(phmmcoObject,TRUE);

	if (pcsaNonLocalProps && pcsaNonLocalProps->GetSize() > 0)
	{
		bReturn = TRUE;
		delete pcsaNonLocalProps;
	}

	return bReturn;

}

void CMyPropertyPage3::SetListNonLocalProperties(CString *pcsClass)
{
	IWbemClassObject *phmmcoObject = NULL;
	IWbemClassObject *pErrorObject = NULL;

	BSTR bstrTemp = pcsClass->AllocSysString();
	SCODE sc =
			m_pParent->GetLocalParent()->GetServices() ->
				GetObject
					(bstrTemp,0,NULL,&phmmcoObject,NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get class object ") + *pcsClass;
		ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 9);
		m_pParent->GetLocalParent()->ReleaseErrorObject(pErrorObject);
		return;
	}

	m_pParent->GetLocalParent()->ReleaseErrorObject(pErrorObject);
	// Props that have already been selected.
	CStringArray *&rpcsaNonLocalProps=
			GetLocalParent() -> GetLocalParent()->
					GetNonLocalProps();

	CStringArray *pcsaNonLocalProps =
		m_pParent->GetLocalParent()->
			GetNonLocalPropNames(phmmcoObject,TRUE);


	int i;
	if (pcsaNonLocalProps)
	{
		m_nNonLocalProps = (int) pcsaNonLocalProps->GetSize();
		for (i = 0; i < pcsaNonLocalProps->GetSize();i++)
		{
			if(StringInArray
				(rpcsaNonLocalProps,
				&pcsaNonLocalProps->GetAt(i), GetSelectedClass()))
			{
				AddPropertyItem(&pcsaNonLocalProps->GetAt(i),2);
			}
			else
			{
				AddPropertyItem(&pcsaNonLocalProps->GetAt(i),1);
			}
		}
		delete pcsaNonLocalProps;
	}

}

void CMyPropertyPage3::AddPropertyItem(CString *pcsProp, int nImage)
{

	LV_ITEM lvItem;

	lvItem.mask = LVIF_IMAGE | LVIF_TEXT;//| LVIF_STATE;
	lvItem.pszText = _T(" ");
	lvItem.iItem = m_clcProperties.GetItemCount();
	lvItem.iSubItem = 0;
	lvItem.iImage = nImage;


	int nItem;
	nItem = m_clcProperties.InsertItem (&lvItem);


	lvItem.mask = LVIF_TEXT ;
	lvItem.pszText =  const_cast<TCHAR *>((LPCTSTR) *pcsProp);
	lvItem.iItem = nItem;
	lvItem.iSubItem = 1;

	m_clcProperties.SetItem (&lvItem);

}


void CMyPropertyPage3::OnDestroy()
{
	CPropertyPage::OnDestroy();

	delete m_pcilImageList;
	delete m_pcilStateImageList;

}

void CMyPropertyPage3::OnCheckoverride()
{
	CStringArray &rcsaClasses =
		m_pParent->GetLocalParent()->GetClasses();
	CByteArray &rcbaInheritedPropIndicators =
		m_pParent->GetLocalParent()->GetInheritedPropIndicators();

	if (m_cbOverRide.GetCheck())
	{
		rcbaInheritedPropIndicators.SetAt(m_nCurSel, 1);
		SetListNonLocalProperties
			(&rcsaClasses.GetAt(m_nCurSel));
	}
	else if (m_nNonLocalProps > 0)
	{
		rcbaInheritedPropIndicators.SetAt(m_nCurSel, 0);
		CStringArray *&rpcsaNonLocalProps=
			GetLocalParent() -> GetLocalParent()->
					GetNonLocalProps();
		int nClassIndex = GetSelectedClass();
		if (rpcsaNonLocalProps[nClassIndex].GetSize() > 0)
		{
			rpcsaNonLocalProps[nClassIndex].RemoveAll();
		}
		m_clcProperties.DeleteFromEnd(m_nNonLocalProps);
		m_nNonLocalProps = 0;
	}


}



void CMyPropertyPage4::LeavingPage()
{

	CString csProviderName;
	m_ceProviderName.GetWindowText(csProviderName);
	CString &rcsProviderName =
		m_pParent -> GetLocalParent() ->
			GetProviderBaseName();
	rcsProviderName = csProviderName;

	CString csProviderDescription;
	m_ceProviderDescription.GetWindowText(csProviderDescription);
	CString &rcsProviderDescription =
		m_pParent -> GetLocalParent() ->
			GetProviderDescription();
	rcsProviderDescription = csProviderDescription;

	CString csProviderOutputPath;
	m_ceCPPDir.GetWindowText(csProviderOutputPath);
	CString &rcsProviderOutputPath =
		m_pParent -> GetLocalParent() ->
			GetProviderOutputPath();
	rcsProviderOutputPath = csProviderOutputPath;

	CString csProviderTLBPath;
	m_ceTlbDir.GetWindowText(csProviderTLBPath);
	CString &rcsProviderTLBPath =
		m_pParent -> GetLocalParent() ->
			GetProviderTLBPath();
	rcsProviderTLBPath = csProviderTLBPath;
}


LRESULT CMyPropertyPage4::OnWizardBack()
{
	// TODO: Add your specialized code here and/or call the base class
	LeavingPage();
	return CPropertyPage::OnWizardBack();
}

LRESULT CMyPropertyPage4::OnWizardNext()
{
	// TODO: Add your specialized code here and/or call the base class
	LeavingPage();
	return CPropertyPage::OnWizardNext();
}



//********************************************************************************
// CMyPropertyPage4::CanWriteFile
//
// Check to see if it is OK to overwrite an existing file.  Put up the appropriate
// dialogs and message boxes to ask the user if he wants to replace the file, and
// so on.
//
// Parameters:
//		[out] CStringArray& saOverwrite
//			If the file already exists its path is added to the saOverwrite array.
//			This makes it possible to put up a single dialog later with a list of
//			all the files that will have to be overwritten.  The user can then choose
//			whether or not he or she wants to continue.
//
//			This is necessary because it is not possible to control which files
//			the moengine will generate on a file by file basis since it generates
//			all files corresponding to a given class as an indivisible unit.
//
//		[in, out] BOOL& bYesAll
//			This flag will be set to TRUE if the user clicks "yes to all" in the
//			dialog when asked whether or not the file should be replaced.  Othewise
//			the value of this flag is not altered.
//
//		[in] LPCTSTR pszPath
//			The full path to the file.
//
// Returns:
//		BOOL
//			TRUE if the file can be overwritten or if the file did not exist, FALSE otherwise.
//
//*********************************************************************************
BOOL CMyPropertyPage4::CanWriteFile(CStringArray& saOverwrite, BOOL& bYesAll, LPCTSTR pszPath)
{


	int nPathLen = _tcslen(pszPath);

	ASSERT(NMAKE_MAX_PATH <= _MAX_PATH);
	if (nPathLen > NMAKE_MAX_PATH - 1)
	{
		CString csUserMsg;
		csUserMsg =  _T("File path is too long \"");
		csUserMsg += pszPath;
		csUserMsg += _T("\".");
		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ );
		return FALSE;
	}


	BOOL bFileExists = _taccess(pszPath, 0 ) != -1;
	if (!bFileExists) {
		return TRUE;
	}

	// Check to see if we have write permission to the file.
	if((_taccess(pszPath, 2 )) == -1 )
	{
		CString csUserMsg;
		csUserMsg =  _T("File does not have write permission\n: ");
		csUserMsg += pszPath;
		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);
		return FALSE;
	}


	if (!bYesAll) {
		saOverwrite.Add(pszPath);

#if 0
		// Check to see if we are replacing an existing file.  If so, ask the user
		// whether or not the file should be replaced.
		CDlgReplaceFileQuery dlg;
		int iResult = dlg.QueryReplaceFile(pszPath);
		if (iResult == DLGREPLACE_YESALL) {
			bYesAll = TRUE;
		}
		if (iResult == DLGREPLACE_CANCEL) {
			return FALSE;
		}
#endif //0
	}
	return TRUE;
}




//********************************************************************************
// CMyPropertyPage4::CanWriteProviderCoreFiles
//
// Check to see if it is OK to write the core provider files.  These files include
//     maindll.cpp
//	   NewProvider.h
//	   NewProvider.cpp
//	   NewProvider.mak
//	   NewProvider.def
//
// where "NewProvider" is the provider name.
//
//
// Parameters:
//		[out] CString& saReplace
//			A list of the files that already exist and will have to be replaced is returned
//			in this array.

//		[in, out] BOOL& bYesAll
//			This flag will be set to TRUE if the user clicks "yes to all" in the
//			dialog when asked whether or not the file should be replaced.  Othewise
//			the value of this flag is not altered.
//
//		[in] const CString& sOutputDir
//			The output directory.
//
//		[in] const CString& sProviderName
//			The provider name.
//
// Returns:
//		BOOL
//			TRUE if all of the above files can be written, FALSE if the user cancelled.
//
//*********************************************************************************
BOOL CMyPropertyPage4::CanWriteProviderCoreFiles(CStringArray& saReplace, BOOL& bYesAll, const CString& sOutputDir, const CString& sProviderName)
{
	BOOL bCanWriteFile;
	CString sProviderPath = sOutputDir + _T("\\") + sProviderName;

	CString sPath;
	sPath = sProviderPath + _T(".mof");
	bCanWriteFile = CanWriteFile(saReplace, bYesAll, sPath);
	if (!bCanWriteFile) {
		return FALSE;
	}

	sPath = sProviderPath + _T(".def");
	bCanWriteFile = CanWriteFile(saReplace, bYesAll, sPath);
	if (!bCanWriteFile) {
		return FALSE;
	}

	sPath = sProviderPath + _T(".mak");
	bCanWriteFile = CanWriteFile(saReplace, bYesAll, sPath);
	if (!bCanWriteFile) {
		return FALSE;
	}

	sPath = sOutputDir;
	sPath += _T("\\maindll.cpp");
	bCanWriteFile = CanWriteFile(saReplace, bYesAll, sPath);
	if (!bCanWriteFile) {
		return FALSE;
	}


	return TRUE;
}

BOOL CMyPropertyPage4::CanCreateProvider(BOOL& bYesAll, LPCTSTR pszClass)
{
	CString sQuery;
	sQuery = _T("select * from __Win32Provider where Name=\"");
	sQuery += pszClass;
	sQuery += _T("\"");

	IWbemServices *pServices = m_pParent->GetLocalParent()->GetServices();
	ASSERT(pServices != NULL);
	if (pServices == NULL) {
		return TRUE;
	}



	IEnumWbemClassObject* pEnum = NULL;
	COleVariant varQuery(sQuery);
	COleVariant varQueryLang(_T("WQL"));
	SCODE sc;
	sc = pServices->ExecQuery(varQueryLang.bstrVal, varQuery.bstrVal, WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pEnum);

	if (FAILED(sc)) {
		return TRUE;
	}


	CString& sNamespace = m_pParent->GetLocalParent()->GetNamespace();
	SetEnumInterfaceSecurity(sNamespace, pEnum, pServices);

	// Now we will enumerate all of the objects that reference this object.
	// These objects will either be associations or "inref" classes that
	// have a property that references this object.
	int nRefs = 0;
	unsigned long nReturned;
	pEnum->Reset();
	IWbemClassObject* pcoRef;

	BOOL bProviderExistsForClass = FALSE;
	sc = pEnum->Next(QUERY_TIMEOUT, 1, &pcoRef, &nReturned);
	if (SUCCEEDED(sc)) {
		if (nReturned > 0) {
			bProviderExistsForClass = TRUE;
		}
	}
	pEnum->Release();
	if (bProviderExistsForClass) {

		CDlgReplaceFileQuery dlg;
		int iResult = dlg.QueryReplaceProvider(pszClass);
		if (iResult == DLGREPLACE_YESALL) {
			bYesAll = TRUE;
		}
		if (iResult == DLGREPLACE_CANCEL) {
			return FALSE;
		}
	}

	return TRUE;


}






BOOL CMyPropertyPage4::OnWizardFinish()
{
	// TODO: Add your specialized code here and/or call the base class
	LeavingPage();

	CString csProviderName;
	m_ceProviderName.GetWindowText(csProviderName);
	csProviderName.TrimLeft();
	csProviderName.TrimRight();
	CString csExtension = _T(".odl");


	BOOL bNoTemp;
	if (!(csProviderName.Find(':') == -1) || !IsValidFilename(csProviderName,csExtension,this, bNoTemp))
	{
		CString csUserMsg;
		if (!bNoTemp)
		{
			csUserMsg =  _T("Invalid provider name: \"") + csProviderName;
			csUserMsg += _T("\".");
		}
		else
		{
			csUserMsg =  _T("Temporary directory does not exist");
		}
		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ );
		return 0;
	}
	else
	{
		if (!(csProviderName.Find(' ') == -1))
		{
			CString csUserMsg;
			csUserMsg =  _T("Embedded spaces are not allowed in a provider name.");
			ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ );
		return 0;
		}
	}


	CString csOutputDir;
	CString csTLBDir;

	m_ceCPPDir.GetWindowText(csOutputDir);
	m_ceTlbDir.GetWindowText(csTLBDir);

	csOutputDir.TrimLeft();
	csOutputDir.TrimRight();

	int i;
	int nRemove = 0;
	for (i = csOutputDir.GetLength() - 1; i >= 0; i--)
	{
		if (csOutputDir[i] == '\\')
		{
			nRemove++;
		}
		else
		{
			break;
		}

	}

	if (nRemove > 0)
	{
		csOutputDir = csOutputDir.Left((csOutputDir.GetLength()) - nRemove);
	}

	m_ceCPPDir.SetWindowText(csOutputDir);

	int nLen = csOutputDir.GetLength();
	if (nLen == 0)
	{
		CString csUserMsg = _T("Please enter an output directory name or \"Cancel\" out of the Provider Wizard.");
		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);
		return 0;

	}

	if (!IsDriveValid(reinterpret_cast<CWnd *>(this),&csOutputDir,FALSE))
	{
		CString csUserMsg;
		csUserMsg =  _T("Drive \"")  + csOutputDir + _T("\" is not ready or valid.");
		csUserMsg += _T("  Please enter another drive name, make the drive ready, or \"Cancel\" out of the Provider Wizard.");
		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);
		return 0;
	}

	if (!TryToFindDirectory (&csOutputDir))
	{
		if (csOutputDir.GetLength() > 2 && csOutputDir[0] == '\\' && csOutputDir[1] == '\\')
		{
			// Cannot create shares
			CString csUserMsg;
			csUserMsg =  _T("Can not create the share \"") + csOutputDir + _T("\".  ") ;
			csUserMsg += _T("Please enter an existing share or \"Cancel\" out of the MOF Wizard.");
			ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 6);
			return 0;

		}

		CString csError;
		int nReturn = TryToCreateDirectory
			(reinterpret_cast<CWnd *>(this),csOutputDir);
		if (nReturn == IDNO)
		{
			return 0;
		}
		else if (nReturn != IDYES)
		{
			CString csUserMsg;
			csUserMsg =  _T("Could not create a directory named \"") + csOutputDir;
			csUserMsg += _T("\".  ");
			csUserMsg += _T("Please enter another directory name or \"Cancel\" out of the Provider Wizard.");
			ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 6);
			return 0;

		}
	}

#if 0
	// bug#58924 - When we install on the PSDK, csTLBDir is pointing to the wrong place
	// HOWEVER, WE DON'T USE THE 'TLB Dir' FOR ANYTHING ANY MORE, SO THERE IS NO POINT
	// COMPLAINGING TO THE USER THAT IT DOES NOT EXIST
	if((_taccess((LPCTSTR) csTLBDir, 0 )) != -1 )
	{
      if((_taccess((LPCTSTR) csTLBDir, 2 )) == -1 )
	  {
		  CString csUserMsg;
			csUserMsg =  _T("Directory Does Not Have Write Permission: ") + csTLBDir;
			ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 6);
			return 0;
	  }
	}
	else
	{
		CString csUserMsg;
		csUserMsg =  _T("The ") + csTLBDir;
		csUserMsg +=  _T(" directory does not exist.  You will not be able to compile the provider code without the files contained in that directory.  Do you wish to continue?");
		int nReturn =
			MessageBox
			( csUserMsg,
			_T("Continue with Finish?"),
			MB_YESNO  | MB_ICONQUESTION | MB_DEFBUTTON1 |
			MB_APPLMODAL);
		if (nReturn == IDNO)
		{
			return 0;
		}
	}
#endif


	CStringArray saReplace;
	BOOL bYesAll = FALSE;

	if (!CanWriteProviderCoreFiles(saReplace, bYesAll, csOutputDir, csProviderName)) {
		return 0;
	}

	CString csFullPath;
	BOOL bCanWriteFile;

	CStringArray &rcsaClassBaseNames =
		m_pParent->GetLocalParent()->GetClassBaseNames();

	CFile file;

	CString csIncludePath;
	BOOL bCanCreateProvider;
	for (i = 0; i < rcsaClassBaseNames.GetSize(); i++)
	{
		csFullPath = csOutputDir + "\\";
		csFullPath += rcsaClassBaseNames.GetAt(i);
		csIncludePath = csFullPath;

		csFullPath += ".cpp";
		csIncludePath += ".h";

		// Test here for file existance.
		bCanWriteFile = CanWriteFile(saReplace, bYesAll, csFullPath);

		if (!bCanWriteFile) {
			return 0;
		}

		bCanWriteFile = CanWriteFile(saReplace, bYesAll, csIncludePath);
		if (!bCanWriteFile) {
			return 0;
		}

		bCanCreateProvider = CanCreateProvider(bYesAll, rcsaClassBaseNames.GetAt(i));
	}

	int nReplace = (int) saReplace.GetSize();
	if (nReplace > 0) {

		// Check to see if we are replacing an existing file.  If so, ask the user
		// whether or not the file should be replaced.
		CDlgReplaceFile dlg;
		int iResult = dlg.QueryReplaceFiles(saReplace);
		if (iResult == DLGREPLACE_YESALL) {
			bYesAll = TRUE;
		}
		if (iResult == DLGREPLACE_CANCEL) {
			return FALSE;
		}


	}


	return CPropertyPage::OnWizardFinish();
}

void CMyPropertyPage1::OnDestroy()
{
	CPropertyPage::OnDestroy();

	delete m_pcphImage;

}

LRESULT CMyPropertyPage1::OnWizardNext()
{
	// TODO: Add your specialized code here and/or call the base class

	return CPropertyPage::OnWizardNext();
}

LRESULT CMyPropertyPage3::OnWizardNext()
{

	if (!ValidateClassName()) {
		return - 1;
	}

	if (!ValidateClassDescription()) {
		return - 1;
	}



	if (!BasenameIsUnique()) {
		return -1;
	}


	// TODO: Add your specialized code here and/or call the base class
	BOOL bStayOnPage = FALSE;
	CString csExtension = _T(".cpp");

	CStringArray &rcsaClasses =
		m_pParent->GetLocalParent()->GetClasses();

	CStringArray &rcsaClassBaseNames =
		m_pParent->GetLocalParent()->GetClassBaseNames();

	CStringArray &rcsaClassCPPNames =
		m_pParent->GetLocalParent()->GetClassCPPNames();

	int i;
	for (i = 0; i < rcsaClassBaseNames.GetSize(); i++)
	{
		CString csTemp = rcsaClassBaseNames.GetAt(i);
		csTemp.TrimLeft();
		csTemp.TrimRight();
		rcsaClassBaseNames.SetAt(i,csTemp);
		CString csText = rcsaClassBaseNames.GetAt(i);
		BOOL bNoTemp;
		BOOL bValid = IsValidFilename(csText,csExtension,this, bNoTemp);
		if (!bValid)
		{
			CString csClass = rcsaClasses.GetAt(i);
			CString csUserMsg;
			if (!bNoTemp)
			{
				csUserMsg =  _T("Invalid base file name: \"") + csText;
				csUserMsg += _T("\" for class  ") + csClass + _T(".");
			}
			else
			{
				csUserMsg =  _T("Temporary directory does not exist.");
			}
			ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ );
			bStayOnPage = TRUE;
		}

		csTemp = rcsaClassCPPNames.GetAt(i);
		csTemp.TrimLeft();
		csTemp.TrimRight();
		rcsaClassCPPNames.SetAt(i,csTemp);
		CString csCPPClassName = rcsaClassCPPNames.GetAt(i);

		if (!IsValidCPPClassName(csCPPClassName))
		{
			CString csClass = rcsaClasses.GetAt(i);
			CString csUserMsg;
			csUserMsg =  _T("Invalid CPP class name: \"") + csCPPClassName;
			csUserMsg += _T("\" for class  ") + csClass + _T(".");
			ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ );
			bStayOnPage = TRUE;
		}


	}


	if (bStayOnPage)
	{
		return -1;
	}


	return CPropertyPage::OnWizardNext();
}

void CMyPropertyPage1::OnHelp()
{
	m_pParent->GetLocalParent()->InvokeHelp();
}

void CMyPropertyPage3::OnHelp()
{
	m_pParent->GetLocalParent()->InvokeHelp();
}

void CMyPropertyPage4::OnHelp()
{
	m_pParent->GetLocalParent()->InvokeHelp();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\hlb.h ===
//****************************************************************************

// File:

//

//     HLB.H

//

// Purpose:

//

//     Provides the declaration for the CHorzListBox class.

//

// Development Team:

//

//     James Rhodes

//

// Written by Microsoft Product Support Services, Languages Developer Support

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//****************************************************************************

#ifndef HLB_H
#define HLB_H

#include <afxtempl.h>

typedef CArray<int,int> CIntArray;

/////////////////////////////////////////////////////////////////////////////
// CHorzListBox window

class CHorzListBox : public CListBox
{
// Construction
public:
	CHorzListBox();

// Attributes
protected:
	BOOL m_bLocked;
	CIntArray m_arrExtents;
	int m_nLongestExtent;
	int m_nTabStops;
	int* m_lpTabStops;

// Operations
public:
	void LockHExtentUpdate();
	void UnlockHExtentUpdate();
	void UpdateHExtent();

protected:
	void InsertNewExtent(INT_PTR nItem, LPCTSTR lpszStr);
	void InsertNewExtent(INT_PTR nItem, LPCTSTR lpszStr, CDC* pDC);
	void InitTabStops();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHorzListBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHorzListBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CHorzListBox)
	//}}AFX_MSG
	afx_msg LRESULT OnAddString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnInsertString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDeleteString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSetTabStops(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\mypropertypage1.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MyPropertyPage1.h : header file
//

#ifndef __MYPROPERTYPAGE1_H__
#define __MYPROPERTYPAGE1_H__

class CCPPGenSheet;
class CImageList;

int GetCBitmapWidth(const CBitmap & cbm);
int GetCBitmapHeight(const CBitmap & cbm);
HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPCTSTR lpString,
                           HPALETTE FAR* lphPalette);
HPALETTE CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors);
CPalette *CreateCPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors);
/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage1 dialog

class CMyPropertyPage1 : public CPropertyPage
{
	DECLARE_DYNCREATE(CMyPropertyPage1)

// Construction
public:
	CMyPropertyPage1();
	~CMyPropertyPage1();
	void SetLocalParent(CCPPGenSheet *pParent) {m_pParent = pParent;}
	CCPPGenSheet *GetLocalParent() {return m_pParent;}

// Dialog Data
	//{{AFX_DATA(CMyPropertyPage1)
	enum { IDD = IDD_PROPPAGE1 };
	CStatic	m_staticMainExt;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertyPage1)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMyPropertyPage1)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	//}}AFX_MSG
	afx_msg void OnHelp();
	DECLARE_MESSAGE_MAP()
	CCPPGenSheet *m_pParent;
	CImageList *m_pcilImageList;
	BOOL m_bInitDraw;
	int m_nBitmapH;
	int m_nBitmapW;
	CPictureHolder *m_pcphImage;


};


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage2 dialog

class CMyPropertyPage2 : public CPropertyPage
{
	DECLARE_DYNCREATE(CMyPropertyPage2)

// Construction
public:
	CMyPropertyPage2();
	~CMyPropertyPage2();
	void SetLocalParent(CCPPGenSheet *pParent) {m_pParent = pParent;}
	CCPPGenSheet *GetLocalParent() {return m_pParent;}

// Dialog Data
	//{{AFX_DATA(CMyPropertyPage2)
	enum { IDD = IDD_PROPPAGE2 };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertyPage2)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMyPropertyPage2)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG 
	DECLARE_MESSAGE_MAP()
	CCPPGenSheet *m_pParent;
	CPictureHolder *m_pcphImage;


};


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage3 dialog

class CMyPropertyPage3 : public CPropertyPage
{
	DECLARE_DYNCREATE(CMyPropertyPage3)

// Construction
public:
	CMyPropertyPage3();
	~CMyPropertyPage3();
	void SetLocalParent(CCPPGenSheet *pParent) {m_pParent = pParent;}
	CCPPGenSheet *GetLocalParent() {return m_pParent;}
	int GetSelectedClass();
// Dialog Data
	//{{AFX_DATA(CMyPropertyPage3)
	enum { IDD = IDD_PROPPAGE3 };
	CStatic	m_staticPage3Ext;
	CButton	m_cbOverRide;
	CWrapListCtrl	m_clcProperties;
	CStatic	m_cs5;
	CStatic	m_cs4;
	CStatic	m_cs3;
	CStatic	m_cs2;
	CStatic	m_cs1;
	CHorzListBox m_clClasses;
	CEdit	m_ceDescription;
	CEdit	m_ceCPPClass;
	CEdit	m_ceBaseFile;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertyPage3)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMyPropertyPage3)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnChangeEditBaseFileName();
	afx_msg void OnSelchangeList1();
	afx_msg void OnChangeEditCPPName();
	afx_msg void OnChangeEditDescription();
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnCheckoverride();
	afx_msg void OnPaint();
	//}}AFX_MSG
	afx_msg void OnHelp();
	DECLARE_MESSAGE_MAP()
	BOOL m_bFirstActivate;
	CCPPGenSheet *m_pParent;
	int m_nBitmapH;
	int m_nBitmapW;
	int m_nCurSel;
	int m_nNonLocalProps;
	CImageList *m_pcilImageList;
	CImageList *m_pcilStateImageList;
	CPoint m_cpButtonUp;
	void SetListLocalProperties(CString *pcsClass);
	void SetListNonLocalProperties(CString *pcsClass);
	void AddPropertyItem(CString *pcsProp, int nImage);
	BOOL CheckForNonLocalProperties(CString *pcsClass);
	CPictureHolder *m_pcphImage;

private:
	BOOL BasenameIsUnique();
	BOOL ValidateClassDescription();
	BOOL ValidateClassName();



};


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage4 dialog

class CMyPropertyPage4 : public CPropertyPage
{
	DECLARE_DYNCREATE(CMyPropertyPage4)

// Construction
public:
	CMyPropertyPage4();
	~CMyPropertyPage4();
	void SetLocalParent(CCPPGenSheet *pParent) {m_pParent = pParent;}
	CCPPGenSheet *GetLocalParent() {return m_pParent;}

// Dialog Data
	//{{AFX_DATA(CMyPropertyPage4)
	enum { IDD = IDD_PROPPAGE4 };
	CStatic	m_staticPage4Ext;
	CEdit	m_ceProviderName;
	CEdit	m_ceProviderDescription;
	CEdit	m_ceTlbDir;
	CEdit	m_ceCPPDir;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertyPage4)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnWizardFinish();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMyPropertyPage4)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnButtoncppdir();
	afx_msg void OnButtontlbdir();
	afx_msg void OnChangeEditcppdir();
	afx_msg void OnChangeEdittlbdir();
	afx_msg void OnPaint();
	//}}AFX_MSG
	afx_msg void OnHelp();
	DECLARE_MESSAGE_MAP()
	BOOL m_bFirstActivate;
	CString GetFolder();
	CCPPGenSheet *m_pParent;
	int m_nBitmapH;
	int m_nBitmapW;
	void LeavingPage();
	CPictureHolder *m_pcphImage;

private:
	BOOL CanWriteFile(CStringArray& saReplace, BOOL& bYesAll, LPCTSTR pszPath);
	BOOL CanWriteProviderCoreFiles(CStringArray& saReplace, BOOL& bYesAll, const CString& sOutputDir, const CString& sProviderName);
	BOOL CanCreateProvider(BOOL& bYesAll, LPCTSTR pszClass);
};



#endif // __MYPROPERTYPAGE1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\replaceproviderquery.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ReplaceProviderQuery.cpp : implementation file
//

#include "precomp.h"
#include "cppwiz.h"
#include "ReplaceProviderQuery.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CReplaceProviderQuery dialog


CReplaceProviderQuery::CReplaceProviderQuery(CWnd* pParent /*=NULL*/)
	: CDialog(CReplaceProviderQuery::IDD, pParent)
{
	//{{AFX_DATA_INIT(CReplaceProviderQuery)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CReplaceProviderQuery::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CReplaceProviderQuery)
	DDX_Control(pDX, IDC_STATICMSG, m_cstaticMessage);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CReplaceProviderQuery, CDialog)
	//{{AFX_MSG_MAP(CReplaceProviderQuery)
	ON_BN_CLICKED(IDC_BUTTONNO, OnButtonno)
	ON_BN_CLICKED(IDC_BUTTONNOALL, OnButtonnoall)
	ON_BN_CLICKED(IDC_BUTTONYES, OnButtonyes)
	ON_BN_CLICKED(IDC_BUTTONYESALL, OnButtonyesall)
	ON_BN_CLICKED(IDCANCEL, OnButtoncancel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CReplaceProviderQuery::SetMessage(CString *pcsMessage)
{
	m_csMessage = *pcsMessage;

}

/////////////////////////////////////////////////////////////////////////////
// CReplaceProviderQuery message handlers

void CReplaceProviderQuery::OnButtonno()
{
	// TODO: Add your control notification handler code here
	 EndDialog( 3 );
}

void CReplaceProviderQuery::OnButtonnoall()
{
	// TODO: Add your control notification handler code here
	 EndDialog( 4 );
}

void CReplaceProviderQuery::OnButtonyes()
{
	// TODO: Add your control notification handler code here
	 EndDialog( 1 );
}

void CReplaceProviderQuery::OnButtonyesall()
{
	// TODO: Add your control notification handler code here
	 EndDialog( 2 );

}

void CReplaceProviderQuery::OnButtoncancel()
{
	// TODO: Add your control notification handler code here
	 EndDialog( 0 );

}

BOOL CReplaceProviderQuery::OnInitDialog()
{
	CDialog::OnInitDialog();

	m_cstaticMessage.SetWindowText(m_csMessage);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\cathelp.cpp ===
//=--------------------------------------------------------------------------=

// CatHelp.Cpp

//=--------------------------------------------------------------------------=

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "precomp.h"

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\hlb.cpp ===
//****************************************************************************

// File:

//

//     HLB.CPP

//

// Purpose:

//

//     Implementation file for class CHorzListBox.

//

// Functions:

//

//  CHorzListBox::CHorzListBox          Constructs a CHorzListBox

//  CHorzListBox::~CHorzListBox         Destructor

//  CHorzListBox::LockHExtentUpdate     Pauses automatic updating of the

//                                      horizontal scroll bar

//  CHorzListBox::UnlockHExtentUpdate   Restores automatic updating of

//                                      the horizontal scroll bar

//  CHorzListBox::UpdateHExtent         Updates the horizontal scroll bar

//                                      extent after LockHExtentUpdate has

//                                      been called

//  CHorzListBox::InsertNewExtent       Internal utility function used to

//                                      maintain the extent array

//  CHorzListBox::InitTabStops          Internal tab stop init function

//  CHorzListBox::OnAddString           Intercepts LB_ADDSTRING msg

//  CHorzListBox::OnInsertString        Intercepts LB_INSERTSTRING msg

//  CHorzListBox::OnDeleteString        Intercepts LB_DELETESTRING msg

//  CHorzListBox::OnSetTabStops         Intercepts LB_SETTABSTOPS msg

//

// Development Team:

//

//     James Rhodes

//

// Written by Microsoft Product Support Services, Languages Developer Support

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//****************************************************************************

#include "precomp.h"
#include "HLB.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHorzListBox

//***********************************************************************
// Function:
//
//     CHorzListBox::CHorzListBox()
//
// Purpose:
//
//     Constructs a CHorzListBox object
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
CHorzListBox::CHorzListBox()
{
	m_bLocked = FALSE;      // start out in auto mode
	m_nLongestExtent = 0;   // tracks longest extent, initially 0
	m_nTabStops = 0;        // no tab stops
	m_lpTabStops = NULL;    // array of tab stops
}

//***********************************************************************
// Function:
//
//     CHorzListBox::~CHorzListBox()
//
// Purpose:
//
//     Destructs a CHorzListBox object
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
CHorzListBox::~CHorzListBox()
{
	if (m_lpTabStops != NULL)
		delete m_lpTabStops;
}

//***********************************************************************
// Function:
//
//     CHorzListBox::LockHExtentUpdate()
//
// Purpose:
//
//     Stops auto updating of horizontal extent
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
void CHorzListBox::LockHExtentUpdate()
{
	m_bLocked = TRUE;
}

//***********************************************************************
// Function:
//
//     CHorzListBox::UnlockHExtentUpdate()
//
// Purpose:
//
//     Turns auto updating back on
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
void CHorzListBox::UnlockHExtentUpdate()
{
	m_bLocked = FALSE;
}

//***********************************************************************
// Function:
//
//     CHorzListBox::UpdateHExtent()
//
// Purpose:
//
//     Updates horizontal extent when auto updating has been turned off
//     for some period.
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
void CHorzListBox::UpdateHExtent()
{
	m_arrExtents.RemoveAll();
	m_nLongestExtent = 0;
	int nCount = GetCount();

	CDC* pDC = GetDC();
	HFONT hFont = (HFONT)SendMessage(WM_GETFONT);
	CFont *pFont = CFont::FromHandle(hFont);
	ASSERT(pFont);
	CFont* pPrevFont = pDC->SelectObject(pFont);
	CString str;

	for(int i=0; i<nCount; i++)
	{
		GetText(i, str);
		InsertNewExtent(i, str, pDC);
	}

	SetHorizontalExtent(m_nLongestExtent);
	pDC->SelectObject(pPrevFont);
	ReleaseDC(pDC);
}

//***********************************************************************
// Function:
//
//     CHorzListBox::InsertNewExtent() PROTECTED
//
// Purpose:
//
//     Used to update the extent array when a new item is added
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
void CHorzListBox::InsertNewExtent(INT_PTR nItem, LPCTSTR lpszStr, CDC* pDC)
{
	if (NULL == m_lpTabStops)
		InitTabStops();

    CSize newExtent;
    if (GetStyle() & LBS_USETABSTOPS)
	    newExtent = pDC->GetTabbedTextExtent(lpszStr, _tcslen(lpszStr),
		    m_nTabStops, m_lpTabStops);
    else
        newExtent = pDC->GetTextExtent(lpszStr, _tcslen(lpszStr));

	newExtent.cx += 6;
	m_arrExtents.InsertAt(nItem, newExtent.cx);

	if (newExtent.cx > m_nLongestExtent)
	{
		m_nLongestExtent = newExtent.cx;
	}
}

void CHorzListBox::InsertNewExtent(INT_PTR nItem, LPCTSTR lpszStr)
{
	if (m_bLocked)
		return;

	CDC* pDC = GetDC();
	HFONT hFont = (HFONT)SendMessage(WM_GETFONT);
	CFont *pFont = CFont::FromHandle(hFont);
	ASSERT(pFont);
	CFont* pPrevFont = pDC->SelectObject(pFont);
	InsertNewExtent(nItem, lpszStr, pDC);
	SetHorizontalExtent(m_nLongestExtent);
	pDC->SelectObject(pPrevFont);
	ReleaseDC(pDC);
}

//***********************************************************************
// Function:
//
//     CHorzListBox::InitTabStops() PROTECTED
//
// Purpose:
//
//     Initializes tab stops
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
void CHorzListBox::InitTabStops()
{
	int nDefault = 2;
	SetTabStops(1, &nDefault);
}

BEGIN_MESSAGE_MAP(CHorzListBox, CListBox)
	//{{AFX_MSG_MAP(CHorzListBox)
	//}}AFX_MSG_MAP
	ON_MESSAGE( LB_ADDSTRING, OnAddString )
	ON_MESSAGE( LB_INSERTSTRING, OnInsertString )
	ON_MESSAGE( LB_DELETESTRING, OnDeleteString )
	ON_MESSAGE( LB_SETTABSTOPS, OnSetTabStops )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHorzListBox message handlers

//***********************************************************************
// Function:
//
//     CHorzListBox::OnAddString()
//
// Purpose:
//
//     Intercepts the LB_ADDSTRING message to update the horizontal extent
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
LRESULT CHorzListBox::OnAddString(WPARAM, LPARAM lParam)
{
	LRESULT lResult = Default();
	if (LB_ERR == lResult || LB_ERRSPACE == lResult) // check for error first!
		return lResult;

	InsertNewExtent(lResult, (LPCTSTR)lParam);
	return lResult;
}

//***********************************************************************
// Function:
//
//     CHorzListBox::OnInsertString()
//
// Purpose:
//
//     Intercepts the LB_INSERTSTRING message to update the horizontal extent
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
LRESULT CHorzListBox::OnInsertString(WPARAM, LPARAM lParam)
{
	LRESULT lResult = Default();
	if (LB_ERR == lResult || LB_ERRSPACE == lResult) // check for error first!
		return lResult;

	InsertNewExtent(lResult, (LPCTSTR)lParam);
	return lResult;
}

//***********************************************************************
// Function:
//
//     CHorzListBox::OnDeleteString()
//
// Purpose:
//
//     Intercepts the LB_DELETESTRING message to update the horizontal extent
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
LRESULT CHorzListBox::OnDeleteString(WPARAM wParam, LPARAM)
{
	LRESULT lResult = Default();
	if (LB_ERR == lResult) // check for error first!
		return lResult;

	if (m_bLocked) // don't do anything if locked
		return lResult;

	int nExtent = m_arrExtents[wParam];
	m_arrExtents.RemoveAt(wParam);
	if (nExtent >= m_nLongestExtent)
	{
		m_nLongestExtent = 0;
		for(int i = 0; i<lResult; i++)
		{
			if (m_arrExtents[i] > m_nLongestExtent)
				m_nLongestExtent = m_arrExtents[i];
		}
	}
	SetHorizontalExtent(m_nLongestExtent);

	return lResult;
}

//***********************************************************************
// Function:
//
//     CHorzListBox::OnSetTabStops()
//
// Purpose:
//
//     Intercepts the LB_SETTABSTOPS message to update tab stop array
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
LRESULT CHorzListBox::OnSetTabStops(WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult = Default();
	if (!lResult)
		return lResult;

	// a-jeffc: Win64 NOTE: We are casting a 64bit value to a 32 bit value,
	// BUT, we will NEVER have more that 4 billion tab stops, so this should
	// be fine.
	m_nTabStops = (int)wParam;

	if (NULL != m_lpTabStops)
	{
		delete [] m_lpTabStops;
		m_lpTabStops = NULL;
	}

	if (m_nTabStops > 0)
	{
		m_lpTabStops = new int[m_nTabStops];
		memcpy(m_lpTabStops, (void*)lParam, m_nTabStops * sizeof(int));

		CDC* pDC = GetDC();
		HFONT hFont = (HFONT)SendMessage(WM_GETFONT);
		CFont *pFont = CFont::FromHandle(hFont);
		ASSERT(pFont);
		CFont* pPrevFont = pDC->SelectObject(pFont);
		CSize size;

		GetTextExtentPoint32(pDC->GetSafeHdc(),
			_T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"),
			52, &size);

		pDC->SelectObject(pPrevFont);
		ReleaseDC(pDC);

		int aveCharWidth = (size.cx/26 +1)/2;

		for(int i=0; i<m_nTabStops; i++)
			m_lpTabStops[i] = (m_lpTabStops[i] * aveCharWidth + 2)/4;
	}

	if (!m_bLocked)
		UpdateHExtent(); // tabs changed, recalc everything!

	return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\replaceproviderquery.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_REPLACEPROVIDERQUERY_H__4FD68F41_BCC7_11D0_9626_00C04FD9B15B__INCLUDED_)
#define AFX_REPLACEPROVIDERQUERY_H__4FD68F41_BCC7_11D0_9626_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ReplaceProviderQuery.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CReplaceProviderQuery dialog

class CReplaceProviderQuery : public CDialog
{
// Construction
public:
	CReplaceProviderQuery(CWnd* pParent = NULL);   // standard constructor
	void SetMessage(CString *pcsMessage);
// Dialog Data
	//{{AFX_DATA(CReplaceProviderQuery)
	enum { IDD = IDD_DIALOGQUALQUERY };
	CStatic	m_cstaticMessage;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CReplaceProviderQuery)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CString m_csMessage;

	// Generated message map functions
	//{{AFX_MSG(CReplaceProviderQuery)
	afx_msg void OnButtonno();
	afx_msg void OnButtonnoall();
	afx_msg void OnButtonyes();
	afx_msg void OnButtonyesall();
	virtual BOOL OnInitDialog();
	virtual void OnButtoncancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REPLACEPROVIDERQUERY_H__4FD68F41_BCC7_11D0_9626_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cppwiz.rc
//
#define IDS_CPPWIZ                      1
#define IDD_ABOUTBOX_CPPWIZ             1
#define IDB_CPPWIZ                      1
#define IDI_ABOUTDLL                    1
#define IDS_CPPWIZ_PPG                  2
#define ID_YESALL                       3
#define IDS_CPPWIZ_PPG_CAPTION          100
#define IDD_PROPPAGE_CPPWIZ             100
#define IDS_PROPSHT_CAPTION             102
#define IDD_PROPPAGE1                   103
#define IDS_NO_HTML_PAGE                103
#define IDD_PROPPAGE2                   104
#define IDD_PROPPAGE3                   105
#define IDD_PROPPAGE4                   106
#define IDI_CPPWIZ                      201
#define IDC_LIST1                       201
#define IDI_CPPWIZSEL                   202
#define IDB_PP1                         202
#define IDC_EDIT1                       202
#define IDD_DIALOG1                     203
#define IDC_EDIT2                       203
#define IDC_EDIT3                       204
#define IDC_RADIO1                      205
#define IDB_PP3                         205
#define IDC_RADIO2                      206
#define IDB_PP4                         206
#define IDC_LIST2                       207
#define IDC_LISTPROPERTIES              207
#define IDB_BITMAPCHECKS                207
#define IDC_STATIC1                     208
#define IDI_ICONCPPWIZ16                208
#define IDC_STATIC2                     209
#define IDI_ICONCPPWIZSEL16             209
#define IDB_BITMAPPAGE                  209
#define IDC_STATIC3                     210
#define IDB_BITMAPMAIN                  210
#define IDC_STATIC4                     211
#define IDD_DIALOGQUALQUERY             211
#define IDC_STATIC5                     212
#define IDI_ICONQUESTION                212
#define IDC_BUTTONCPPDIR                213
#define IDD_REPLACE_QUERY               213
#define IDC_BUTTONTLBDIR                214
#define IDD_REPLACEFILE                 214
#define IDC_EDITCPPDIR                  215
#define IDC_EDITTLBDIR                  216
#define IDC_PROVIDERNAME                217
#define IDC_EDITPROVIDERDESCRIPTION     218
#define IDC_CHECKOVERRIDE               219
#define IDC_BUTTONYES                   221
#define IDC_BUTTONYESALL                222
#define IDC_BUTTONNO                    223
#define IDC_BUTTONNOALL                 224
#define IDC_STATICMSG                   225
#define IDC_STATICMAINBMP               226
#define IDC_STATICMAINEXTENT            227
#define IDC_STATICPAGE3EXT              228
#define IDC_STATICPAGE4EXT              229
#define IDC_STAT_REPLACEFILE            230
#define IDC_EDIT_FILENAMES              231

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        215
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         232
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\wraplistctrl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WrapListCtrl.h : header file
//

class CMyPropertyPage3;
/////////////////////////////////////////////////////////////////////////////
// CWrapListCtrl window

class CWrapListCtrl : public CListCtrl
{
// Construction
public:
	CWrapListCtrl();
	void SetLocalParent(CMyPropertyPage3 *pParent)
		{m_pParent = pParent;}
	void DeleteFromEnd(int nNumber);
// Attributes
public:

// Operations
public:
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWrapListCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWrapListCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CWrapListCtrl)
	afx_msg void OnItemchanging(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSetfocus(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocus(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydown(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	CPoint m_cpMouseDown;
	BOOL m_bLeftButtonDown;
	CMyPropertyPage3 *m_pParent;
	int m_nFocusItem;
	void FlipIcon(int nItem,  BOOL bFoucs = FALSE);
	BOOL FocusIcon(int nItem, BOOL bFocus);
	void UpdateClassNonLocalPropList
		(int nItem, CString *pcsProp, BOOL bInsert);

	friend class CMyPropertyPage3;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\cppwiz\wraplistctrl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WrapListCtrl.cpp : implementation file
//

#include "precomp.h"
#include "resource.h"
#include "wbemidl.h"
#include "moengine.h"
#include "CPPWiz.h"
#include <afxcmn.h>
#include <afxcmn.h>
#include "CPPWizCtl.h"
#include "WrapListCtrl.h"
#include "hlb.h"
#include "MyPropertyPage1.h"
#include "CppGenSheet.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWrapListCtrl



CWrapListCtrl::CWrapListCtrl()
{
	m_nFocusItem = -1;
	m_bLeftButtonDown = FALSE;
}

CWrapListCtrl::~CWrapListCtrl()
{
}


BEGIN_MESSAGE_MAP(CWrapListCtrl, CListCtrl)
	//{{AFX_MSG_MAP(CWrapListCtrl)
	ON_NOTIFY_REFLECT(LVN_ITEMCHANGING, OnItemchanging)
	ON_NOTIFY_REFLECT(NM_CLICK, OnClick)
	ON_WM_LBUTTONDOWN()
	ON_WM_CREATE()
	ON_NOTIFY_REFLECT(NM_SETFOCUS, OnSetfocus)
	ON_NOTIFY_REFLECT(LVN_ITEMCHANGED, OnItemchanged)
	ON_NOTIFY_REFLECT(NM_KILLFOCUS, OnKillfocus)
	ON_NOTIFY_REFLECT(LVN_KEYDOWN, OnKeydown)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWrapListCtrl message handlers

void CWrapListCtrl::OnItemchanging(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

	*pResult = TRUE;
}

void CWrapListCtrl::OnClick(NMHDR* pNMHDR, LRESULT* pResult)
{
	// TODO: Add your control notification handler code here
	UINT uFlags = 0;

	m_bLeftButtonDown = FALSE;

	int nItem = HitTest(m_cpMouseDown, &uFlags);

	if (LVHT_ONITEMICON  & uFlags)
	{
		if (m_nFocusItem != -1)
		{
			FocusIcon(m_nFocusItem,FALSE);
		}
		FlipIcon(nItem,TRUE);
	}

	m_nFocusItem = nItem;

	*pResult = 0;
}

void CWrapListCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default
	m_cpMouseDown = point;
	m_bLeftButtonDown = TRUE;
	CListCtrl::OnLButtonDown(nFlags, point);
}

void CWrapListCtrl::UpdateClassNonLocalPropList
(int nItem, CString *pcsProp, BOOL bInsert)
{
	CStringArray *&rpcsaNonLocalProps=
		m_pParent-> GetLocalParent() -> GetLocalParent()->
			GetNonLocalProps();
	int nClassIndex = m_pParent-> GetSelectedClass();
	if (bInsert)
	{
		rpcsaNonLocalProps[nClassIndex].Add(*pcsProp);
	}
	else
	{
		for (int i = 0;
			 i < rpcsaNonLocalProps[nClassIndex].GetSize();
			 i++)
		{
			if (pcsProp->
				CompareNoCase
				(rpcsaNonLocalProps[nClassIndex].GetAt(i))
				== 0)
			{
				rpcsaNonLocalProps[nClassIndex].RemoveAt(i,1);
				break;
			}

		}
	}
}

void CWrapListCtrl::FlipIcon(int nItem, BOOL bFocus)
{
	if (nItem >= GetItemCount())
	{
		return;
	}

	LV_ITEM lvItem0;
	LV_ITEM lvItem1;

	lvItem0.iItem = nItem;
	lvItem0.iSubItem = 0;
	lvItem0.mask = LVIF_IMAGE | LVIF_STATE;

	GetItem(&lvItem0);

	int iImage = lvItem0.iImage;

	TCHAR cBuf[MAX_PATH];
	TCHAR *pBuf = reinterpret_cast<TCHAR *>(&cBuf);

	lvItem1.iItem = nItem;
	lvItem1.iSubItem = 1;
	lvItem1.mask = LVIF_TEXT;
	lvItem1.pszText = pBuf;
	lvItem1.cchTextMax = MAX_PATH - 1;

	GetItem(&lvItem1);

	DeleteItem(nItem);

	CString csProp = pBuf;
	if (iImage == 1 || iImage == 3)
	{
		if (bFocus)
		{
			m_nFocusItem = nItem;
			lvItem0.iImage = 4;
			UpdateClassNonLocalPropList(nItem,&csProp,TRUE);

		}
		else
		{
			lvItem0.iImage = 2;
			UpdateClassNonLocalPropList(nItem,&csProp,TRUE);
		}

	}
	else if (iImage == 2 || iImage == 4)
	{
		if (bFocus)
		{
			m_nFocusItem = nItem;
			lvItem0.iImage = 3;
			UpdateClassNonLocalPropList(nItem,&csProp,FALSE);
		}
		else
		{
			lvItem0.iImage = 1;
			UpdateClassNonLocalPropList(nItem,&csProp,FALSE);

		}

	}
	else if (iImage == 0 || iImage == 5)
	{
		if (bFocus)
		{
			m_nFocusItem = nItem;
			lvItem0.iImage = 5;
		}
		else
		{
			lvItem0.iImage = 0;
		}

	}

	int nNewItem;
	nNewItem = InsertItem (&lvItem0);


	lvItem1.iItem = nNewItem;
	lvItem1.iSubItem = 1;
	lvItem1.mask = LVIF_TEXT;
	lvItem1.pszText = pBuf;
	lvItem1.cchTextMax = MAX_PATH - 1;

	BOOL bReturn = SetItem(&lvItem1);

	RedrawItems(nItem,nItem);
	Update(nItem);
	UpdateWindow();


	int nTopIndex = GetTopIndex();
	int nCountPerPage = GetCountPerPage();
	if (nItem < nTopIndex || nItem > nTopIndex + nCountPerPage)
	{
		EnsureVisible(nItem,FALSE);
	}
}


BOOL CWrapListCtrl::FocusIcon(int nItem, BOOL bFocus)
{
	if (nItem >= GetItemCount())
	{
		return FALSE;
	}

	LV_ITEM lvItem0;
	LV_ITEM lvItem1;

	lvItem0.iItem = nItem;
	lvItem0.iSubItem = 0;
	lvItem0.mask = LVIF_IMAGE | LVIF_STATE;

	GetItem(&lvItem0);

	int iImage = lvItem0.iImage;

	TCHAR cBuf[MAX_PATH];
	TCHAR *pBuf = reinterpret_cast<TCHAR *>(&cBuf);

	lvItem1.iItem = nItem;
	lvItem1.iSubItem = 1;
	lvItem1.mask = LVIF_TEXT;
	lvItem1.pszText = pBuf;
	lvItem1.cchTextMax = MAX_PATH - 1;

	GetItem(&lvItem1);

	DeleteItem(nItem);

	CString csProp = pBuf;
	if (iImage == 1 || iImage == 3)
	{
		if (bFocus)
		{
			m_nFocusItem = nItem;
			lvItem0.iImage = 3;
		}
		else
		{
			lvItem0.iImage = 1;
		}

	}
	else if (iImage == 2 || iImage == 4)
	{
		if (bFocus)
		{
			m_nFocusItem = nItem;
			lvItem0.iImage = 4;
		}
		else
		{
			lvItem0.iImage = 2;
		}

	}
	else if (iImage == 0 || iImage == 5)
	{
		if (bFocus)
		{
			m_nFocusItem = nItem;
			lvItem0.iImage = 5;
		}
		else
		{
			lvItem0.iImage = 0;
		}

	}

	int nNewItem;
	nNewItem = InsertItem (&lvItem0);


	lvItem1.iItem = nNewItem;
	lvItem1.iSubItem = 1;
	lvItem1.mask = LVIF_TEXT;
	lvItem1.pszText = pBuf;
	lvItem1.cchTextMax = MAX_PATH - 1;

	BOOL bReturn = SetItem(&lvItem1);

	RedrawItems(nItem,nItem);
	Update(nItem);
	UpdateWindow();

	int nTopIndex = GetTopIndex();
	int nCountPerPage = GetCountPerPage();
	if (nItem < nTopIndex || nItem > nTopIndex + nCountPerPage)
	{
		EnsureVisible(nItem,FALSE);
	}

	return TRUE;
}

void CWrapListCtrl::DeleteFromEnd(int nNumber)
{
	int nItems = GetItemCount();

	if (nNumber <= nItems)
	{
		for (int i = nItems - 1; i >= nItems - nNumber; i--)
		{
			DeleteItem(i);

		}

	}
	UpdateWindow();

	m_nFocusItem = -1;

}

int CWrapListCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{

	lpCreateStruct->style = lpCreateStruct->style &
		LVS_NOSORTHEADER;

	if (CListCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO: Add your specialized creation code here

	return 0;
}

void CWrapListCtrl::OnSetfocus(NMHDR* pNMHDR, LRESULT* pResult)
{
	// TODO: Add your control notification handler code here

	if (m_bLeftButtonDown)
	{
		return;
	}

	int nCount = GetItemCount();


	if (nCount == 0)
	{
		m_nFocusItem = -1;
		return;
	}

	if (m_nFocusItem == -1)
	{
		BOOL bFocus = FocusIcon(0, TRUE);
		int nIndex = 1;
		while (!bFocus)
		{
			if (nIndex >= nCount)
			{
				break;
			}
			bFocus = FocusIcon(nIndex++, TRUE);
		}
	}
	else
	{
		FocusIcon(m_nFocusItem, TRUE);

	}
	*pResult = 0;
}

void CWrapListCtrl::OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

	*pResult = 0;
}

void CWrapListCtrl::OnKillfocus(NMHDR* pNMHDR, LRESULT* pResult)
{
	// TODO: Add your control notification handler code here
	if (m_nFocusItem != -1)
	{
		FocusIcon(m_nFocusItem, FALSE);
	}
	*pResult = 0;
}

void CWrapListCtrl::OnKeydown(NMHDR* pNMHDR, LRESULT* pResult)
{
	LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;
	// TODO: Add your control notification handler code here
	WORD nKey = pLVKeyDow->wVKey;

	int nFocus = m_nFocusItem;
	int nCount = GetItemCount();
	BOOL bFocus = FALSE;
	switch (nKey)
	{
	case VK_LEFT:
	case VK_UP:
	case VK_PRIOR:
		if (nFocus > 0)
		{
			FocusIcon(m_nFocusItem,FALSE);
			bFocus = FocusIcon(nFocus - 1, TRUE);
			if (bFocus)
			{
				m_nFocusItem = nFocus - 1;
			}
			else
			{
				FocusIcon(m_nFocusItem,TRUE);
			}
		}
		break;
	case VK_DOWN:
	case VK_NEXT:
	case VK_RIGHT:
		if (nFocus < nCount - 1)
		{
			FocusIcon(m_nFocusItem,FALSE);
			FocusIcon(nFocus + 1, TRUE);
			m_nFocusItem = nFocus + 1;
		}
		break;

	case VK_HOME:
		FocusIcon(m_nFocusItem,FALSE);
		bFocus = FocusIcon(0, TRUE);
		if (bFocus)
		{
			m_nFocusItem = 0;
		}
		else
		{
			EnsureVisible(0,FALSE);
			m_nFocusItem = 0;
		}
		break;
	case VK_END:
		FocusIcon(m_nFocusItem,FALSE);
		FocusIcon(nCount- 1, TRUE);
		m_nFocusItem = nCount- 1;
		break;
	case VK_SPACE:
		FlipIcon(m_nFocusItem,TRUE);
		break;
	default:
		break;
	}
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\eventregedit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// EventRegEdit.cpp : Implementation of CEventRegEditApp and DLL registration.

#include "precomp.h"
#include "EventRegEdit.h"
#include "cathelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CEventRegEditApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xda25b02, 0x2962, 0x11d1, { 0x96, 0x51, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const GUID CDECL BASED_CODE _ctlid =   { 0xda25b05, 0x2962, 0x11d1,
           {0x96, 0x51, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b} };

const CATID CATID_SafeForScripting     =
   {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing  =
   {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
////////////////////////////////////////////////////////////////////////////
// CEventRegEditApp::InitInstance - DLL initialization

BOOL CEventRegEditApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CEventRegEditApp::ExitInstance - DLL termination

int CEventRegEditApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	if (FAILED( CreateComponentCategory(CATID_SafeForScripting,
               L"Controls that are safely scriptable") ))
             return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( CreateComponentCategory(
           CATID_SafeForInitializing,
           L"Controls safely initializable from persistent data") ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForScripting) ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForInitializing) ))
         return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\eventregedit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_EVENTREGEDIT_H__0DA25B0B_2962_11D1_9651_00C04FD9B15B__INCLUDED_)
#define AFX_EVENTREGEDIT_H__0DA25B0B_2962_11D1_9651_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// EventRegEdit.h : main header file for EVENTREGEDIT.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CEventRegEditApp : See EventRegEdit.cpp for implementation.

class CEventRegEditApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EVENTREGEDIT_H__0DA25B0B_2962_11D1_9651_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\classinstancetree.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_CLASSINSTANCETREE_H__5F781751_45A1_11D1_9658_00C04FD9B15B__INCLUDED_)
#define AFX_CLASSINSTANCETREE_H__5F781751_45A1_11D1_9658_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ClassInstanceTree.h : header file
//
class CEventRegEditCtrl;
class CTreeCwnd;
/////////////////////////////////////////////////////////////////////////////
// CClassInstanceTree window

class CClassInstanceTree : public CTreeCtrl
{
// Construction
public:
	CClassInstanceTree();
	void InitContent();
	void ClearContent();
	void SetActiveXParent(CEventRegEditCtrl *pActiveXParent);
	BOOL IsItemAClass(HTREEITEM hItem);
	void DeleteTreeInstanceItem(HTREEITEM hItem,BOOL bQuietly = FALSE);
// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClassInstanceTree)
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CClassInstanceTree();

	// Generated message map functions
protected:
	CEventRegEditCtrl *m_pActiveXParent;
	CImageList *m_pcilImageList;
	HTREEITEM InsertTreeItem
		(	HTREEITEM hParent,
			LPARAM lparam,
			CString *pcsText ,
			BOOL bClass,
			BOOL bChildren);
	void ClearTree();
	void ClearBranch(HTREEITEM hItem);
	HTREEITEM AddClassToTree(CString &csClass);
	HTREEITEM AddClassChildren(HTREEITEM hItem);
	BOOL m_bReExpanding;
	BOOL m_bInitExpanding;

	UINT_PTR m_uiTimer;
	BOOL m_bMouseDown;
	BOOL m_bKeyDown;

	// Tool Tips
	CToolTipCtrl m_ttip;
	CString m_csToolTipString;
	BOOL m_bReCacheTools;
	void RelayEvent(UINT message, WPARAM wParam, LPARAM lParam);
	// Tool Tip recaching
	void UnCacheTools();
	void UnCacheTools(HTREEITEM hItem);
	void ReCacheTools();
	void ReCacheTools(HTREEITEM hItem);

	CMenu m_cmContext;
	CPoint m_cpRButtonUp;

	void RefreshBranch(HTREEITEM hItem);
	void RefreshBranch();

	BOOL m_bDoubleClick;

	//{{AFX_MSG(CClassInstanceTree)
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnItemexpanding(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemexpanded(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSetfocus(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydown(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG
	afx_msg LRESULT SelectTreeItem(WPARAM, LPARAM);

	DECLARE_MESSAGE_MAP()

	friend class CTreeCwnd;
	friend class CEventRegEditCtrl;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLASSINSTANCETREE_H__5F781751_45A1_11D1_9658_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\classinstancetree.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ClassInstanceTree.cpp : implementation file
//

#include "precomp.h"
#include "wbemidl.h"
#include "util.h"
#include "resource.h"
#include "PropertiesDialog.h"
#include "EventRegEdit.h"
#include "EventRegEditCtl.h"
#include "ClassInstanceTree.h"
#include "ListFrame.h"
#include "ListFrameBaner.h"
#include "ListViewEx.h"
#include "RegistrationList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define KBSelectionTimer 1000
#define UPDATESELECTEDITEM WM_USER + 400

extern CEventRegEditApp theApp;


void CALLBACK EXPORT  SelectItemAfterDelay
		(HWND hWnd,UINT nMsg,WPARAM nIDEvent, ULONG dwTime)
{
	::PostMessage(hWnd,UPDATESELECTEDITEM,0,0);

}

/////////////////////////////////////////////////////////////////////////////
// CClassInstanceTree

CClassInstanceTree::CClassInstanceTree()
{
	m_bReExpanding = NULL;
	m_bInitExpanding = NULL;
	m_pActiveXParent = NULL;
	m_pcilImageList = NULL;
	m_cpRButtonUp.x = 0;
	m_cpRButtonUp.y = 0;
	m_bMouseDown = FALSE;
	m_bKeyDown = FALSE;
	m_uiTimer = 0;
	m_bDoubleClick = FALSE;
}

CClassInstanceTree::~CClassInstanceTree()
{
}


BEGIN_MESSAGE_MAP(CClassInstanceTree, CTreeCtrl)
	//{{AFX_MSG_MAP(CClassInstanceTree)
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, OnItemexpanding)
	ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelchanged)
	ON_NOTIFY_REFLECT(TVN_ITEMEXPANDED, OnItemexpanded)
	ON_WM_MOUSEMOVE()
	ON_WM_HSCROLL()
	ON_WM_SIZE()
	ON_WM_VSCROLL()
	ON_WM_RBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_SETFOCUS()
	ON_NOTIFY_REFLECT(NM_SETFOCUS, OnSetfocus)
	ON_NOTIFY_REFLECT(TVN_KEYDOWN, OnKeydown)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
	ON_WM_CONTEXTMENU()
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
	ON_MESSAGE( UPDATESELECTEDITEM,SelectTreeItem)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClassInstanceTree message handlers


void CClassInstanceTree::SetActiveXParent(CEventRegEditCtrl *pActiveXParent)
{
	m_pActiveXParent = pActiveXParent;
	pActiveXParent->m_pTree = this;
}

void CClassInstanceTree::OnDestroy()
{
	if (m_uiTimer)
	{
		KillTimer( m_uiTimer );
		m_uiTimer = 0;
	}

	ClearContent();

	CImageList *pImageList =
		GetImageList (TVSIL_NORMAL);

	if (pImageList && pImageList->m_hImageList)
	{
		pImageList -> DeleteImageList();
//		delete pImageList;
	}

	CTreeCtrl::OnDestroy();

	// TODO: Add your message handler code here

}

int CClassInstanceTree::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CTreeCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO: Add your specialized creation code here
	int iReturn;

	HICON hIconClass = theApp.LoadIcon(IDI_ICONCLASS);
	HICON hIconInstance = theApp.LoadIcon(IDI_ICONINSTANCE);


	m_pcilImageList = new CImageList();

	m_pcilImageList ->
		Create(16, 16, TRUE, 2, 2);

	iReturn = m_pcilImageList -> Add(hIconClass);
	iReturn = m_pcilImageList -> Add(hIconInstance);


	// This image list is maintained by the ctreectrl.
	CImageList *pcilOld  = SetImageList
		(m_pcilImageList,TVSIL_NORMAL);
	delete pcilOld;

	if (!m_ttip.Create(this))
	{
		TRACE0("Unable to create tip window.");
	}
	else
	{
		m_ttip.Activate(TRUE);
	}

	return 0;
}

BOOL CClassInstanceTree::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Add your specialized code here and/or call the base class
	cs.style &= ~TVS_EDITLABELS;

	return CTreeCtrl::PreCreateWindow(cs);
}

void CClassInstanceTree::InitContent()
{
	ClearContent();
	CString csClass = m_pActiveXParent->GetCurrentModeClass();
	HTREEITEM hItem = AddClassToTree(csClass);
	if (hItem)
	{
		SelectItem(hItem);
		AddClassChildren(hItem);
	}

	m_bReCacheTools = TRUE;
}

HTREEITEM CClassInstanceTree::AddClassToTree(CString &csClass)
{
	IWbemServices *pServices = m_pActiveXParent->GetServices();

	IWbemClassObject *pClass =
		GetClassObject (pServices, &csClass, FALSE);

	HTREEITEM hItem = NULL;

	if (!pClass)
	{
		return hItem;
	}

	CString csPath = pClass ? GetIWbemFullPath(pClass) : "";
	CStringArray *pcsaClassArray = new CStringArray;
	pcsaClassArray->Add(csPath);
	CString csClassOrInstance = "C";
	pcsaClassArray->Add(csClassOrInstance);
	pcsaClassArray->Add(csClass);

	pClass->Release();

	hItem = InsertTreeItem
		(NULL, (LPARAM) pcsaClassArray, &csClass , TRUE, FALSE);

	return hItem;
}

HTREEITEM CClassInstanceTree::AddClassChildren(HTREEITEM hItem)
{
	IWbemServices *pServices = m_pActiveXParent->GetServices();


	if (!hItem)
	{
		return NULL;
	}

	CStringArray *pcsaItem
		= reinterpret_cast<CStringArray *>(GetItemData( hItem ));

	if (!pcsaItem)
	{
		return NULL;
	}

	if (pcsaItem->GetAt(1).CompareNoCase(_T("C")) != 0)
	{
		return NULL;
	}

	CString csClass = pcsaItem->GetAt(2);

	CPtrArray cpaClasses;
	SCODE sc = GetClasses(pServices,&csClass,cpaClasses, m_pActiveXParent->m_csNamespace);

	if (sc != S_OK)
	{
		return NULL;
	}

	CPtrArray cpaInstances;
	sc = GetInstances(pServices, &csClass, cpaInstances, FALSE);

	if (sc != S_OK)
	{
		return NULL;
	}

	if (cpaClasses.GetSize() > 0 || cpaInstances.GetSize() > 0)
	{
		TV_INSERTSTRUCT		tvstruct;
		tvstruct.item.hItem = hItem;
		tvstruct.item.mask = TVIF_CHILDREN;
		tvstruct.item.cChildren = 1;
		SetItem(&tvstruct.item);
	}

	CString csClassOrInstance;

	int i;
	for (i = 0; i < cpaClasses.GetSize(); i++)
	{
		IWbemClassObject *pObject =
			reinterpret_cast<IWbemClassObject *>(cpaClasses.GetAt(i));
		if (pObject)
		{
			CString csPath = GetIWbemFullPath(pObject);
			CString csClass = GetIWbemClass(pObject);
			CStringArray *pcsaClassArray = new CStringArray;
			pcsaClassArray->Add(csPath);
			csClassOrInstance = "C";
			pcsaClassArray->Add(csClassOrInstance);
			pcsaClassArray->Add(csClass);
			InsertTreeItem
			(hItem, (LPARAM) pcsaClassArray, &csClass , TRUE, FALSE);
			pObject->Release();
		}
	}

	for (i = 0; i < cpaInstances.GetSize(); i++)
	{
		IWbemClassObject *pObject =
			reinterpret_cast<IWbemClassObject *>(cpaInstances.GetAt(i));
		if (pObject)
		{
			CString csPath = GetIWbemFullPath(pObject);
			CString csRelPath = GetIWbemRelativePath(pObject);
			CStringArray *pcsaInstanceArray = new CStringArray;
			pcsaInstanceArray->Add(csPath);
			csClassOrInstance = "I";
			pcsaInstanceArray->Add(csClassOrInstance);
			InsertTreeItem
			(hItem, (LPARAM) pcsaInstanceArray, &csRelPath , FALSE, FALSE);
			pObject->Release();
		}
	}

	if (cpaClasses.GetSize() == 0 && cpaInstances.GetSize() == 0)
	{
		TV_INSERTSTRUCT		tvstruct;
		tvstruct.item.hItem = hItem;
		tvstruct.item.mask = TVIF_CHILDREN;
		tvstruct.item.cChildren = 0;
		SetItem(&tvstruct.item);
	}

	SortChildren(hItem);

	return hItem;
}

void CClassInstanceTree::ClearContent()
{
	if (m_uiTimer)
	{
		KillTimer( m_uiTimer );
		m_uiTimer = 0;
	}

	m_bMouseDown = FALSE;
	m_bKeyDown = FALSE;
	ClearTree();
}

HTREEITEM CClassInstanceTree::InsertTreeItem
(HTREEITEM hParent, LPARAM lparam, CString *pcsText , BOOL bClass, BOOL bChildren)
{
	int iBitmap = bClass ? 0 : 1;

	TV_INSERTSTRUCT tvinsert;
	HTREEITEM h1;

	tvinsert.hParent = hParent;
	tvinsert.hInsertAfter = TVI_LAST;
	tvinsert.item.mask =	TVIF_TEXT | TVIF_SELECTEDIMAGE |
							TVIF_PARAM | TVIF_IMAGE |
							TVIF_CHILDREN;
	tvinsert.item.hItem = NULL;
	tvinsert.item.cchTextMax = pcsText->GetLength() + 1;
	tvinsert.item.cChildren = bChildren? 1 : 0;
	tvinsert.item.lParam = lparam;
	tvinsert.item.iImage = iBitmap;
	tvinsert.item.iSelectedImage = iBitmap;
	tvinsert.item.pszText = const_cast<TCHAR *>
							((LPCTSTR) *pcsText);
	h1 =  InsertItem(&tvinsert);

	m_bReCacheTools = TRUE;

	return h1;
}

void CClassInstanceTree::ClearTree()
{
	UnCacheTools();

	HTREEITEM hItem = GetRootItem();

	if (!hItem)
	{
		return;
	}

	ClearBranch(hItem);

	CStringArray *pcsaItem = NULL;

	HTREEITEM hSib = GetNextSiblingItem(hItem);
	while (hSib)
	{
		pcsaItem
			= reinterpret_cast<CStringArray *>(GetItemData( hSib ));
		SetItemData(hSib,NULL);
		delete pcsaItem;

		ClearBranch(hSib);
		hSib = GetNextSiblingItem(hSib);
	}

	DeleteAllItems();
}

void CClassInstanceTree::ClearBranch(HTREEITEM hItem)
{
	if (!hItem)
	{
		return;
	}

	CStringArray *pcsaItem
		= reinterpret_cast<CStringArray *>(GetItemData( hItem ));

	SetItemData(hItem,NULL);
	delete pcsaItem;

	if (!ItemHasChildren (hItem))
	{
		return;
	}

	HTREEITEM hChild = GetChildItem(hItem);
	while (hChild)
	{
		ClearBranch(hChild);
		hChild = GetNextSiblingItem(hChild);
	}
}

void CClassInstanceTree::OnItemexpanding(NMHDR* pNMHDR, LRESULT* pResult)
{
	if (m_bReExpanding || m_bInitExpanding || m_bDoubleClick)
	{
		*pResult = TRUE;
		m_bDoubleClick = FALSE;
		return;
	}

	CWaitCursor wait;


	NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pNMHDR;
	HTREEITEM hItem = pnmtv->itemNew.hItem;

	if (!hItem)
	{
		*pResult = 1;
		return;
	}

	if (pnmtv ->action == TVE_COLLAPSE)
	{
		*pResult = 0;
		//m_pActiveXParent -> InvalidateControl();
		return;
	}

	HTREEITEM hChild = GetChildItem(hItem);

	if (pnmtv -> itemNew.state & TVIS_EXPANDEDONCE && hChild)
	{
		// if we have children make then visible.
		m_bReExpanding = TRUE;

		while (hChild)
		{
			EnsureVisible(hChild);
			if (hChild)
			{
				hChild = GetNextSiblingItem(hChild);
			}
		}
		*pResult = 0;
		//m_pActiveXParent -> InvalidateControl();
		m_bReExpanding = FALSE;
		return;
	}
	else if (hChild)
	{
		m_bInitExpanding = TRUE;

		while (hChild)
		{
			AddClassChildren(hChild);
			EnsureVisible(hChild);
			if (hChild)
			{
				hChild = GetNextSiblingItem(hChild);
			}
		}
		*pResult = 0;
		//m_pActiveXParent -> InvalidateControl();
		m_bInitExpanding = FALSE;
	}
	else
	{
		*pResult = 0;
	}

	//m_pActiveXParent -> InvalidateControl();
}

void CClassInstanceTree::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

	HTREEITEM hItem = pNMTreeView->itemNew.hItem;

	if (!hItem)
	{
		*pResult = 1;
		return;
	}

	CStringArray *pcsaItem
		= reinterpret_cast<CStringArray *>(GetItemData( hItem ));

	if (pcsaItem && !m_bKeyDown)
	{
		m_pActiveXParent -> TreeSelectionChanged(*pcsaItem);
	}

	*pResult = 0;
}

/*if (!m_bTimeInit && m_bKeyDown)
	{
		m_ctKeyDown = CTime::GetCurrentTime();
		m_bTimeInit = TRUE;
	}
	else

	CTime endTime = CTime::GetCurrentTime();

    CTimeSpan elapsedTime = endTime - m_ctKeyDown;*/

void CClassInstanceTree::RelayEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
      if (NULL != m_ttip.m_hWnd)
	  {
         MSG msg;

         msg.hwnd= m_hWnd;
         msg.message= message;
         msg.wParam= wParam;
         msg.lParam= lParam;
         msg.time= 0;
         msg.pt.x= LOWORD (lParam);
         msg.pt.y= HIWORD (lParam);

         m_ttip.RelayEvent(&msg);
     }
}

void CClassInstanceTree::ReCacheTools()
{

	HTREEITEM hItem = GetRootItem( );

	if (hItem == NULL)
		return;

	ReCacheTools(hItem);


}

void CClassInstanceTree::ReCacheTools(HTREEITEM hItem)
{
	HTREEITEM hChild;

	if (hItem == NULL)
		return;

    hChild = GetChildItem(  hItem );
	while (hChild)
	{
		ReCacheTools(hChild);
		hChild = GetNextSiblingItem(hChild);
	}

	BOOL bVisible;
	BOOL bToolInfo;
	CRect cr;
	CToolInfo ctiInfo;

	if (bToolInfo = m_ttip.GetToolInfo(ctiInfo , this, (UINT_PTR) hItem))
	{
		m_ttip.DelTool(this, (UINT_PTR) hItem);
	}


	if (bVisible = GetItemRect( hItem, &cr, TRUE))
	{
		CStringArray *pcsaItemData =
			reinterpret_cast<CStringArray *> (GetItemData(hItem));
		CString csData = pcsaItemData -> GetAt(0);
		if (!csData.IsEmpty())
		{
			m_csToolTipString =  csData.Left(255);
			m_ttip.AddTool (this,m_csToolTipString,&cr,(UINT_PTR) hItem);

		}
	}
}

void CClassInstanceTree::UnCacheTools()
{

	HTREEITEM hItem = GetRootItem( );

	if (hItem == NULL)
		return;

	UnCacheTools(hItem);


}

void CClassInstanceTree::UnCacheTools(HTREEITEM hItem)
{
	HTREEITEM hChild;

	if (hItem == NULL)
		return;

    hChild = GetChildItem(  hItem );
	while (hChild)
	{
		UnCacheTools(hChild);
		hChild = GetNextSiblingItem(hChild);
	}

	BOOL bToolInfo;
	CRect cr;
	CToolInfo ctiInfo;
	if (NULL != m_ttip.m_hWnd &&
		(bToolInfo = m_ttip.GetToolInfo(ctiInfo , this, (UINT_PTR) hItem)))
	{
		m_ttip.DelTool(this, (UINT_PTR) hItem);
	}


}

void CClassInstanceTree::OnItemexpanded(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
	m_bReCacheTools = TRUE;
	*pResult = 0;
}

LRESULT CClassInstanceTree::SelectTreeItem(WPARAM, LPARAM)
{
	m_bMouseDown = FALSE;;
	m_bKeyDown = FALSE;

	if (m_uiTimer)
	{
		KillTimer( m_uiTimer );
		m_uiTimer = 0;
	}

	HTREEITEM hItem =	GetSelectedItem();

	if (!hItem)
	{
		return 0;
	}

	CStringArray *pcsaItem
		= reinterpret_cast<CStringArray *>(GetItemData( hItem ));

	if (pcsaItem)
	{
		m_pActiveXParent -> TreeSelectionChanged(*pcsaItem);
		//m_pActiveXParent -> InvalidateControl();
	}

	return 0;
}

void CClassInstanceTree::OnMouseMove(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default
	if (m_bReCacheTools && NULL != m_ttip.m_hWnd)
	{
		m_bReCacheTools = FALSE;
		ReCacheTools();
	}

	if (NULL != m_ttip.m_hWnd)
	{
		RelayEvent(WM_MOUSEMOVE, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));
	}

	CTreeCtrl::OnMouseMove(nFlags, point);
}

void CClassInstanceTree::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	// TODO: Add your message handler code here and/or call default

	CTreeCtrl::OnHScroll(nSBCode, nPos, pScrollBar);
	m_bReCacheTools = TRUE;
}

void CClassInstanceTree::OnSize(UINT nType, int cx, int cy)
{
	CTreeCtrl::OnSize(nType, cx, cy);

	// TODO: Add your message handler code here
	m_bReCacheTools = TRUE;
}

void CClassInstanceTree::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	// TODO: Add your message handler code here and/or call default

	CTreeCtrl::OnVScroll(nSBCode, nPos, pScrollBar);
	m_bReCacheTools = TRUE;
}


void CClassInstanceTree::RefreshBranch()
{
	UINT hitFlags = 0;
    HTREEITEM hItem = NULL;

    hItem = HitTest( m_cpRButtonUp, &hitFlags ) ;
	m_cpRButtonUp.x = 0;
	m_cpRButtonUp.y = 0;
    if (hItem && hitFlags & (TVHT_ONITEM))
	{
		RefreshBranch(hItem);
	}
}


void CClassInstanceTree::RefreshBranch(HTREEITEM hItem)
{

	CWaitCursor wait;

	UnCacheTools();
	m_bReCacheTools = TRUE;

	Expand(hItem,TVE_COLLAPSE);

	if (ItemHasChildren (hItem))
	{
		HTREEITEM hChild = GetChildItem(hItem);
		while (hChild)
		{
			ClearBranch(hChild);
			HTREEITEM hChildNext = GetNextSiblingItem(hChild);
			DeleteItem( hChild);
			hChild = hChildNext;
		}

	}

	AddClassChildren(hItem);

	if (ItemHasChildren (hItem))
	{
		HTREEITEM hChild = GetChildItem(hItem);
		while (hChild)
		{
			CStringArray *pcsaItem
				= reinterpret_cast<CStringArray *>(GetItemData( hChild ));

			if (pcsaItem->GetAt(1).CompareNoCase(_T("C")) == 0)
			{
				AddClassChildren(hChild);
				HTREEITEM hChildNext = GetNextSiblingItem(hChild);
				hChild = hChildNext;
			}
			else
			{
				HTREEITEM hChildNext = GetNextSiblingItem(hChild);
				hChild = hChildNext;
			}
		}
	}

}


void CClassInstanceTree::OnContextMenu(CWnd* pWnd, CPoint point)
{
    HTREEITEM hItem ;

	CPoint cpClient;

	if (point.x == -1 && point.y == -1)
	{
		CRect crClient;
		GetClientRect(&crClient);
		hItem = GetSelectedItem();
		if (hItem)
		{
			RECT rect;
			BOOL bRect = GetItemRect(hItem,&rect, TRUE );
			POINT p;
			p.x = rect.left + 2;
			p.y = rect.top + 2;
			if (bRect && crClient.PtInRect(p))
			{
				cpClient.x = rect.left + 2;
				cpClient.y = rect.top + 2;
			}
			else
			{
				cpClient.x = 0;
				cpClient.y = 0;
			}

		}
		point = cpClient;
		m_cpRButtonUp = cpClient;
		ClientToScreen(&point);

	}
	else
	{
		cpClient = point;
		ScreenToClient(&cpClient);
		m_cpRButtonUp = cpClient;
	}

	VERIFY(m_cmContext.LoadMenu(IDR_MENUCONTEXT));

	CMenu* pPopup = m_cmContext.GetSubMenu(0);

	CWnd* pWndPopupOwner = m_pActiveXParent;

	pPopup->TrackPopupMenu
		(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y,
		pWndPopupOwner);

	m_cmContext.DestroyMenu();
}

void CClassInstanceTree::OnRButtonDown(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default
}

void CClassInstanceTree::OnKeydown(NMHDR* pNMHDR, LRESULT* pResult)
{

		TV_KEYDOWN* pTVKeyDown = (TV_KEYDOWN*)pNMHDR;

	switch (pTVKeyDown->wVKey)
	{
	case VK_LEFT:
	case VK_RIGHT:
	case VK_UP:
	case VK_DOWN:
	case VK_NEXT:
	case VK_PRIOR:
	case VK_HOME:
	case VK_END:
		if (m_uiTimer)
		{
			KillTimer( m_uiTimer );
			m_uiTimer = 0;
		}
		m_uiTimer = SetTimer
			(KBSelectionTimer,
			KBSelectionTimer,
			SelectItemAfterDelay);
		m_bKeyDown = TRUE;
		m_bMouseDown = FALSE;
		break;
	default:
		m_bKeyDown = FALSE;
		m_bMouseDown = TRUE;
		break;

	};

	*pResult = 0;

}

void CClassInstanceTree::OnLButtonUp(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default
	m_bMouseDown = TRUE;
	m_bKeyDown = FALSE;
	CTreeCtrl::OnLButtonUp(nFlags, point);
}



void CClassInstanceTree::OnSetFocus(CWnd* pOldWnd)
{
	CTreeCtrl::OnSetFocus(pOldWnd);

	// TODO: Add your message handler code here
	m_pActiveXParent->m_bRestoreFocusToTree = TRUE;
	m_pActiveXParent->m_bRestoreFocusToCombo = FALSE;
	m_pActiveXParent->m_bRestoreFocusToNamespace = FALSE;
	m_pActiveXParent->m_bRestoreFocusToList = FALSE;
	m_pActiveXParent->OnActivateInPlace(TRUE,NULL);
}

void CClassInstanceTree::OnSetfocus(NMHDR* pNMHDR, LRESULT* pResult)
{
	// TODO: Add your control notification handler code here
	m_pActiveXParent->m_bRestoreFocusToTree = TRUE;
	m_pActiveXParent->m_bRestoreFocusToCombo = FALSE;
	m_pActiveXParent->m_bRestoreFocusToNamespace = FALSE;
	m_pActiveXParent->m_bRestoreFocusToList = FALSE;
	*pResult = 0;
}

BOOL CClassInstanceTree::IsItemAClass(HTREEITEM hItem)
{
	CStringArray *pcsaItem
			= reinterpret_cast<CStringArray *>(GetItemData( hItem ));

	if (!pcsaItem)
	{
		return FALSE;
	}

	if (pcsaItem->GetAt(1).CompareNoCase(_T("C")) == 0)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}

}

void CClassInstanceTree::DeleteTreeInstanceItem(HTREEITEM hItem, BOOL bQuietly)
{
	CStringArray *pcsaItem
			= reinterpret_cast<CStringArray *>(GetItemData( hItem ));

	if (!pcsaItem)
	{
		return;
	}

	CString csFirst = pcsaItem->GetAt(0);


	IWbemClassObject *pObject =
		GetClassObject(m_pActiveXParent->GetServices(),&csFirst,TRUE);

	if (!pObject)
	{
		if (!bQuietly)
		{
			CString csUserMsg =
				_T("Cannot get object: ") + csFirst;
			ErrorMsg(&csUserMsg,S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__);
		}
		HTREEITEM hParent = GetParentItem(hItem);
		SelectItem(hParent);
		RefreshBranch(hParent);
		Expand(hParent,TVE_EXPAND);
		return;
	}

	CString csPrompt = _T("Do You Want to Delete the \"");
	csPrompt += csFirst;
	csPrompt+= _T("\" instance");
	CString csError;

	BOOL bAssociations = m_pActiveXParent->m_pList->AreThereRegistrations();

	if (bAssociations)
	{
		csPrompt += _T(" and all of its registrations?");
	}
	else
	{
		csPrompt += _T("?");
	}

	CString csTitle = bAssociations?
		_T("Delete Instance and Registration Query") :
		_T("Delete Instance Query");

	int nReturn =
			::MessageBox
			(m_pActiveXParent->GetSafeHwnd(),
			csPrompt,
			csTitle,
			MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON1 |
			MB_APPLMODAL);

	if (nReturn == IDYES)
	{
		CString csTargetRole;
		CString csAssocClass = _T("__FilterToConsumerBinding");
		CPtrArray *pcpaRegistrations =
			m_pActiveXParent->m_pList->GetReferences
			(csFirst, csTargetRole, csAssocClass);

		if (!pcpaRegistrations)
		{
			HTREEITEM hParent = GetParentItem(hItem);
			SelectItem(hParent);
			RefreshBranch(hParent);
			Expand(hParent,TVE_EXPAND);
			return;
		}

		CStringArray csaRegistrations;
		int i;
		for (i = 0; i < pcpaRegistrations->GetSize(); i++)
		{
			IWbemClassObject *pObject =
				reinterpret_cast<IWbemClassObject *>
				(pcpaRegistrations->GetAt(i));
			if (pObject)
			{
				csaRegistrations.Add(GetIWbemFullPath(pObject));
				pObject->Release();
			}
		}
		delete pcpaRegistrations;
		SCODE sc;
		for (i = 0; i < csaRegistrations.GetSize(); i++)
		{
			BSTR bstrTemp = csaRegistrations.GetAt(i).AllocSysString();
			sc =
				m_pActiveXParent->GetServices()->DeleteInstance
				(bstrTemp,0,NULL,NULL);
			::SysFreeString(bstrTemp);
		}

		BSTR bstrTemp = csFirst.AllocSysString();
		sc =
			m_pActiveXParent->GetServices()->DeleteInstance(bstrTemp,0,NULL,NULL);
		::SysFreeString(bstrTemp);

		if (sc != S_OK)
		{
			CString csUserMsg = _T("Cannot delete instance ");
			csUserMsg += csFirst;
			ErrorMsg(&csUserMsg,sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__);
		}
		else
		{
			HTREEITEM hParent = GetParentItem(hItem);
			SelectItem(hParent);
			RefreshBranch(hParent);
			Expand(hParent,TVE_EXPAND);
		}

	}


}

void CClassInstanceTree::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult)
{

	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

	HTREEITEM hItem = GetSelectedItem();
	BOOL bClass = IsItemAClass(hItem);

	m_pActiveXParent->m_hContextItem = hItem;

	if (bClass)
	{
		m_pActiveXParent->OnViewclassprop();
	}
	else
	{
		m_pActiveXParent->OnEditinstprop();
	}

	m_bDoubleClick = TRUE;

	*pResult = 0;
}

void CClassInstanceTree::OnKillFocus(CWnd* pNewWnd)
{
	CTreeCtrl::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	m_pActiveXParent->m_bRestoreFocusToTree = TRUE;
	m_pActiveXParent->m_bRestoreFocusToCombo = FALSE;
	m_pActiveXParent->m_bRestoreFocusToNamespace = FALSE;
	m_pActiveXParent->m_bRestoreFocusToList = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\eventregeditctl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// EventRegEditCtl.cpp : Implementation of the CEventRegEditCtrl ActiveX Control class.

#include "precomp.h"
#include "wbemidl.h"
#include "MsgDlgExterns.h"
#include "util.h"
#include "resource.h"
#include "PropertiesDialog.h"
#include "EventRegEdit.h"
#include "EventRegEditCtl.h"
#include "EventRegEditPpg.h"
#include "SelectView.h"
#include "TreeFrame.h"
#include "TreeFrameBanner.h"
#include "ClassInstanceTree.h"
#include "ListFrame.h"
#include "ListFrameBaner.h"
#include "ListFrameBannerStatic.h"
#include "ListCwnd.h"
#include "ListViewEx.h"
#include "RegistrationList.h"
#include "ListBannerToolbar.h"
#include "nsentry.h"
#include "RegEditNavNSEntry.h"
#include "logindlg.h"
#include "InitNamespaceNSEntry.h"
#include "InitNamespaceDialog.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define SELECTVIEWCHILD 1
#define TREEFRAMECHILD 2
#define LISTFRAMECHILD 3

IMPLEMENT_DYNCREATE(CEventRegEditCtrl, COleControl)

#define LEFT_PANE_PERCENT .50
#define LEFT_PANE_MIN 150

#define VIEW_TOP 5

#define TREE_FRAME_LEFT 10



/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CEventRegEditCtrl, COleControl)
	//{{AFX_MSG_MAP(CEventRegEditCtrl)
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_WM_CREATE()
	ON_WM_SETFOCUS()
	ON_WM_ACTIVATE()
	ON_COMMAND(ID_MENUITEMREFRESH, OnMenuitemrefresh)
	ON_UPDATE_COMMAND_UI(ID_MENUITEMREFRESH, OnUpdateMenuitemrefresh)
	ON_COMMAND(ID_EDITINSTPROP, OnEditinstprop)
	ON_UPDATE_COMMAND_UI(ID_EDITINSTPROP, OnUpdateEditinstprop)
	ON_COMMAND(ID_VIEWCLASSPROP, OnViewclassprop)
	ON_UPDATE_COMMAND_UI(ID_VIEWCLASSPROP, OnUpdateViewclassprop)
	ON_COMMAND(ID_NEWINSTANCE, OnNewinstance)
	ON_UPDATE_COMMAND_UI(ID_NEWINSTANCE, OnUpdateNewinstance)
	ON_COMMAND(ID_DELETEINSTANCE, OnDeleteinstance)
	ON_UPDATE_COMMAND_UI(ID_DELETEINSTANCE, OnUpdateDeleteinstance)
	ON_COMMAND(ID_VIEWINSTPROP, OnViewinstprop)
	ON_UPDATE_COMMAND_UI(ID_VIEWINSTPROP, OnUpdateViewinstprop)
	ON_COMMAND(ID_REGISTER, OnRegister)
	ON_UPDATE_COMMAND_UI(ID_REGISTER, OnUpdateRegister)
	ON_COMMAND(ID_UNREGISTER, OnUnregister)
	ON_UPDATE_COMMAND_UI(ID_UNREGISTER, OnUpdateUnregister)
	ON_WM_KEYUP()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
	ON_MESSAGE(INITNAMESPACE, InitNamespace )
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CEventRegEditCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CEventRegEditCtrl)
	DISP_PROPERTY_EX(CEventRegEditCtrl, "NameSpace", GetNameSpace, SetNameSpace, VT_BSTR)
	DISP_PROPERTY_EX(CEventRegEditCtrl, "RootFilterClass", GetRootFilterClass, SetRootFilterClass, VT_BSTR)
	DISP_PROPERTY_EX(CEventRegEditCtrl, "RootConsumerClass", GetRootConsumerClass, SetRootConsumerClass, VT_BSTR)
	DISP_PROPERTY_EX(CEventRegEditCtrl, "ViewMode", GetViewMode, SetViewMode, VT_BSTR)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CEventRegEditCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CEventRegEditCtrl, COleControl)
	//{{AFX_EVENT_MAP(CEventRegEditCtrl)
	EVENT_CUSTOM("GetIWbemServices", FireGetIWbemServices, VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CEventRegEditCtrl, 1)
	PROPPAGEID(CEventRegEditPropPage::guid)
END_PROPPAGEIDS(CEventRegEditCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CEventRegEditCtrl, "WBEM.EventRegCtrl.1",
	0xda25b05, 0x2962, 0x11d1, 0x96, 0x51, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CEventRegEditCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DEventRegEdit =
		{ 0xda25b03, 0x2962, 0x11d1, { 0x96, 0x51, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const IID BASED_CODE IID_DEventRegEditEvents =
		{ 0xda25b04, 0x2962, 0x11d1, { 0x96, 0x51, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwEventRegEditOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CEventRegEditCtrl, IDS_EVENTREGEDIT, _dwEventRegEditOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CEventRegEditCtrl::CEventRegEditCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CEventRegEditCtrl

BOOL CEventRegEditCtrl::CEventRegEditCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_EVENTREGEDIT,
			IDB_EVENTREGEDIT,
			afxRegApartmentThreading,
			_dwEventRegEditOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CEventRegEditCtrl::CEventRegEditCtrl - Constructor

CEventRegEditCtrl::CEventRegEditCtrl()
{
	InitializeIIDs(&IID_DEventRegEdit, &IID_DEventRegEditEvents);

	m_pServices = NULL;
	m_sc = S_OK;
	m_bUserCancel = FALSE;
	m_bMetricSet = FALSE;
	m_bChildSizeSet = FALSE;
	m_bJustSetMode = TRUE;

	m_csFontName = _T("MS Shell Dlg");
	m_nFontHeight = 8; // point size
	m_nFontWeight = (short) FW_NORMAL;

	m_csaModes.Add(_T("Consumers"));
	m_csaModes.Add(_T("Filters"));
	m_csaModes.Add(_T("Timers"));
	m_csaModes.Add(_T(""));

	m_csaRegistrationStrings.Add(_T("Filters registered to "));
	m_csaRegistrationStrings.Add(_T("Consumers registered to "));
	m_csaRegistrationStrings.Add(_T(""));

	m_csaLastTreeSelection.Add(_T(""));
	m_csaLastTreeSelection.Add(_T(""));
	m_csaLastTreeSelection.Add(_T(""));

	m_iMode = NONE;

	m_pTree = NULL;
	m_pTreeFrame = NULL;
	m_pTreeFrameBanner = NULL;

	m_pList = NULL;
	m_pListFrame = NULL;
	m_pListFrameBanner = NULL;

	m_bOpeningNamespace = FALSE;

	m_bClassSelected = TRUE;

	m_hContextItem = NULL;

	m_bNamespaceInit = FALSE;
	m_bValidatedRootClasses = FALSE;

	AfxEnableControlContainer();

	m_bRestoreFocusToTree = TRUE;
	m_bRestoreFocusToCombo = FALSE;
	m_bRestoreFocusToNamespace = FALSE;
	m_bRestoreFocusToList = FALSE;

	// TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CEventRegEditCtrl::~CEventRegEditCtrl - Destructor

CEventRegEditCtrl::~CEventRegEditCtrl()
{
	if (m_pServices)
	{
		m_pServices->Release();
		m_pServices = NULL;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CEventRegEditCtrl::OnDraw - Drawing function

void CEventRegEditCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{

	if (!m_hWnd)
	{
		return;
	}

	// So we can count on fundamental display characteristics.
	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	COLORREF crBackColor = GetSysColor(COLOR_3DFACE);
	COLORREF crWhite = RGB(255,255,255);
	COLORREF crGray = GetSysColor(COLOR_3DHILIGHT);
	COLORREF crDkGray = GetSysColor(COLOR_3DSHADOW);
	COLORREF crBlack = GetSysColor(COLOR_WINDOWTEXT);

	CRect rcOutline(rcBounds);
	CBrush cbBackGround;
	cbBackGround.CreateSolidBrush(crBackColor);
	CBrush *cbSave = pdc -> SelectObject(&cbBackGround);
	pdc ->FillRect(&rcOutline, &cbBackGround);
	pdc -> SelectObject(cbSave);

	if (m_bOpeningNamespace)
	{
		return;
	}


	if (!m_bNamespaceInit)
	{
		m_bNamespaceInit = TRUE;
		m_bOpeningNamespace = TRUE;
		PostMessage(INITNAMESPACE,0,0);
	}

}


/////////////////////////////////////////////////////////////////////////////
// CEventRegEditCtrl::DoPropExchange - Persistence support

void CEventRegEditCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	PX_String(pPX, _T("NameSpace"), m_csNamespaceInit, _T(""));
	PX_String(pPX, _T("ViewMode"), m_csMode, _T("Filters"));
	PX_String(pPX, _T("RootFilterClass"), m_csRootFilterClass, _T("__EventFilter"));
	PX_String(pPX, _T("RootConsumerClass"), m_csRootConsumerClass, _T("__EventConsumer"));

	if (pPX->IsLoading())
	{
		if (m_csMode.CompareNoCase(GetModeString(CONSUMERS)) == 0)
		{
			m_csMode = GetModeString(CONSUMERS);
			m_csRegistrationString = GetRegistrationString(CONSUMERS);
			m_iMode = CONSUMERS;
		}
		else 	if (m_csMode.CompareNoCase(GetModeString(TIMERS)) == 0)
		{
			m_csMode = GetModeString(TIMERS);
			m_csRegistrationString = GetRegistrationString(TIMERS);
			m_iMode = TIMERS;
		}
		else
		{
			m_csMode = GetModeString(FILTERS);
			m_csRegistrationString = GetRegistrationString(FILTERS);
			m_iMode = FILTERS;
		}

		m_csaClasses.Add(m_csRootConsumerClass);
		m_csaClasses.Add(m_csRootFilterClass);
		m_csaClasses.Add(_T("__TimerInstruction"));
		m_csaClasses.Add(_T(""));

	}

}


/////////////////////////////////////////////////////////////////////////////
// CEventRegEditCtrl::OnResetState - Reset control to default state

void CEventRegEditCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CEventRegEditCtrl::AboutBox - Display an "About" box to the user

void CEventRegEditCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_EVENTREGEDIT);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CEventRegEditCtrl message handlers

BSTR CEventRegEditCtrl::GetNameSpace()
{
	CString strResult;
	// TODO: Add your property handler here
	if (m_csNamespaceInit.IsEmpty())
	{
		strResult = m_csNamespace;
	}
	else
	{
		strResult = m_csNamespaceInit;
	}

	return strResult.AllocSysString();
}

void CEventRegEditCtrl::SetNameSpace(LPCTSTR lpszNewValue)
{
	if (!AmbientUserMode( ) || !GetSafeHwnd( ))
	{
		m_csNamespace = lpszNewValue;
		return;
	}

	IWbemServices *pTmp;

	CString csNamespace = lpszNewValue;
	pTmp = GetIWbemServices(csNamespace);

	m_csNamespaceInit.Empty();
	m_bNamespaceInit = TRUE;

	if (pTmp)
	{
		// Notify others that namespace has been changed.
		ClearChildren();
		if (m_pServices)
		{
			m_pServices->Release();
			m_pServices = NULL;
		}
		m_pTreeFrameBanner->m_pcnseNamespace->OpenNamespace(csNamespace, TRUE);
		m_pServices=pTmp;
		if (!m_bValidatedRootClasses)
		{
			m_bValidatedRootClasses = TRUE;
			CString csBaseClass = _T("__EventConsumer");
			IWbemClassObject *pObject = GetClassObject(m_pServices,&m_csRootConsumerClass,TRUE);
			if (pObject && IsObjectOfClass(csBaseClass,pObject))
			{
				pObject->Release();
				pObject = NULL;
			}
			else
			{
				m_csRootConsumerClass = csBaseClass;
			}

			m_csaClasses.SetAt(0,m_csRootConsumerClass);
			if (pObject)
			{
				pObject->Release();
			}

			pObject = GetClassObject(m_pServices,&m_csRootFilterClass,TRUE);
			csBaseClass = _T("__EventFilter");
			if (pObject && IsObjectOfClass(csBaseClass,pObject))
			{
				pObject->Release();
				pObject = NULL;
			}
			else
			{
				m_csRootFilterClass = csBaseClass;

			}

			m_csaClasses.SetAt(1,m_csRootFilterClass);

			if (pObject)
			{
				pObject->Release();
			}

		}

		m_csNamespace = csNamespace;
		InitChildren();
		m_pTreeFrameBanner->UpdateWindow();
		m_pTreeFrameBanner->RedrawWindow();
	}
	else if (!m_bUserCancel)
	{
		if (m_sc == 0x8001010e)
		{
			CString csUserMsg =
						_T("You cannot open another Event Registration window.  Please close this web page.");

			//ErrorMsg
			//		(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 10);
			CString csTitle = _T("WBEM Event Registration");
			MessageBox(csUserMsg,csTitle);
		}
		else
		{
			ClearChildren();
			//CString csUserMsg=
			//			_T("Cannot open namespace ") + csNamespace;
			//csUserMsg +=
			//		_T(".") ;

			//ErrorMsg
			//	(&csUserMsg, m_sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__);
		}
	}
	else if (m_bUserCancel)
	{
		ClearChildren();
		m_bUserCancel = FALSE;
	}


	SetModifiedFlag();
	InvalidateControl();

}

BOOL CEventRegEditCtrl::DestroyWindow()
{
	// TODO: Add your specialized code here and/or call the base class
	return COleControl::DestroyWindow();
}

void CEventRegEditCtrl::OnDestroy()
{
	COleControl::OnDestroy();

	// Destroy all the children here.
	DestroyChildren();
}

void CEventRegEditCtrl::OnSize(UINT nType, int cx, int cy)
{
	COleControl::OnSize(nType, cx, cy);

	if (m_bChildSizeSet)
	{
		SetChildGeometry(cx, cy);

		m_pTreeFrame->SetWindowPos
			(NULL,m_crTreeFrame.left,m_crTreeFrame.top,
			m_crTreeFrame.Width(),
			m_crTreeFrame.Height(),SWP_FRAMECHANGED);

		m_pListFrame->SetWindowPos
			(NULL,m_crListFrame.left,m_crListFrame.top,
			m_crListFrame.Width(),
			m_crListFrame.Height(),SWP_FRAMECHANGED);

		m_pTreeFrame->RedrawWindow(m_crTreeFrame);
		m_pTreeFrame->UpdateWindow();

		m_pListFrame->RedrawWindow(m_crListFrame);
		m_pListFrame->UpdateWindow();

	}

}

int CEventRegEditCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	CreateControlFont();

	// Create all the children here.

	CreateChildren();

	InvalidateControl();
	return 0;
}

// ***************************************************************************
//
// CEventRegEditCtrl::CreateControlFont
//
// Description:
//	  Create the font used by the control and get the font metrics.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CEventRegEditCtrl::CreateControlFont()
{

	if (!m_bMetricSet) // Create the font used by the control.
	{
		CDC *pdc = CWnd::GetDC( );

		pdc -> SetMapMode (MM_TEXT);
		pdc -> SetWindowOrg(0,0);

		LOGFONT lfFont;
		InitializeLogFont
			(lfFont, m_csFontName,m_nFontHeight * 10, m_nFontWeight);

		m_cfFont.CreatePointFontIndirect(&lfFont, pdc);

		CWnd::SetFont ( &m_cfFont , FALSE);
		CFont* pOldFont = pdc -> SelectObject( &m_cfFont );
		pdc->GetTextMetrics(&m_tmFont);
		pdc -> SelectObject(pOldFont);

		m_bMetricSet = TRUE;

		ReleaseDC(pdc);
	}

}

// ***************************************************************************
//
// CEventRegEditCtrl::InitializeLogFont
//
// Description:
//	  Fill in LOGFONT structure.
//
// Parameters:
//	  LOGFONT &rlfFont	Structure to fill in.
//	  CString csName	Font name.
//	  int nHeight		Font height.
//	  int nWeight		Font weight.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CEventRegEditCtrl::InitializeLogFont
(LOGFONT &rlfFont, CString csName, int nHeight, int nWeight)
{
	_tcscpy(rlfFont.lfFaceName, (LPCTSTR) csName);
	rlfFont.lfWeight = nWeight;
	rlfFont.lfHeight = nHeight;
	rlfFont.lfEscapement = 0;
	rlfFont.lfOrientation = 0;
	rlfFont.lfWidth = 0;
	rlfFont.lfItalic = FALSE;
	rlfFont.lfUnderline = FALSE;
	rlfFont.lfStrikeOut = FALSE;
	rlfFont.lfCharSet = ANSI_CHARSET;
	rlfFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
	rlfFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	rlfFont.lfQuality = DEFAULT_QUALITY;
	rlfFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
}

LRESULT CEventRegEditCtrl::InitNamespace(WPARAM, LPARAM)
{

	if (!AmbientUserMode( ) || !GetSafeHwnd( ))
	{
		return 0;
	}


	if (m_csNamespaceInit.IsEmpty())
	{
		PreModalDialog();
		CInitNamespaceDialog cindInitNamespace;

		cindInitNamespace.m_pParent = this;
		int nReturn = (int) cindInitNamespace.DoModal();

		PostModalDialog();

		if (nReturn == IDOK)
		{
			m_csNamespaceInit = cindInitNamespace.GetNamespace();
		}
	}

	if (m_csNamespaceInit.GetLength() > 0)
	{
		SetNameSpace(m_csNamespaceInit);
		m_csNamespaceInit.Empty();
	}

	m_bOpeningNamespace=FALSE;
	InvalidateControl();
	return 0;
}

IWbemServices *CEventRegEditCtrl::GetIWbemServices
(CString &rcsNamespace)
{
	IUnknown *pServices = NULL;

	BOOL bUpdatePointer= FALSE;

	m_sc = S_OK;
	m_bUserCancel = FALSE;

	VARIANT varUpdatePointer;
	VariantInit(&varUpdatePointer);
	varUpdatePointer.vt = VT_I4;
	if (bUpdatePointer == TRUE)
	{
		varUpdatePointer.lVal = 1;
	}
	else
	{
		varUpdatePointer.lVal = 0;
	}

	VARIANT varService;
	VariantInit(&varService);

	VARIANT varSC;
	VariantInit(&varSC);

	VARIANT varUserCancel;
	VariantInit(&varUserCancel);

	FireGetIWbemServices
		((LPCTSTR)rcsNamespace,  &varUpdatePointer,  &varService, &varSC,
		&varUserCancel);

	if (varService.vt & VT_UNKNOWN)
	{
		pServices = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}

	varService.punkVal = NULL;

	VariantClear(&varService);

	if (varSC.vt ==  VT_I4)
	{
		m_sc = varSC.lVal;
	}
	else
	{
		m_sc = WBEM_E_FAILED;
	}

	VariantClear(&varSC);

	if (varUserCancel.vt == VT_BOOL)
	{
		m_bUserCancel = varUserCancel.boolVal;
	}

	VariantClear(&varUserCancel);

	VariantClear(&varUpdatePointer);

	IWbemServices *pRealServices = NULL;
	if (m_sc == S_OK && !m_bUserCancel)
	{
		pRealServices = reinterpret_cast<IWbemServices *>(pServices);
	}

	InvalidateControl();
	return pRealServices;
}

void CEventRegEditCtrl::CreateChildren()
{
	int cx;
	int cy;

	GetControlSize(&cx, &cy);
	SetChildGeometry(cx,cy);
	m_bChildSizeSet= TRUE;

	m_pTreeFrame = new CTreeFrame;

	m_pTreeFrame->SetActiveXParent(this);

	BOOL bReturn =
		m_pTreeFrame->Create
		(	NULL,_T("TreeFrame"),WS_CHILD|WS_VISIBLE,
			m_crTreeFrame,
			this,
			TREEFRAMECHILD);

	if (!bReturn)
	{
		CString csUserMsg =
							_T("Cannot create TreeFrame CWnd.");
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
		return;
	}

	m_pTreeFrame->CWnd::SetFont ( &m_cfFont , FALSE);

	m_pTreeFrameBanner->EnableButtons(FALSE,FALSE,FALSE);

	m_pTree->CWnd::SetFont ( &m_cfFont , FALSE);

	m_pListFrame = new CListFrame;

	m_pListFrame->SetActiveXParent(this);

	bReturn =
		m_pListFrame->Create
		(	NULL,_T("ListFrame"),WS_CHILD|WS_VISIBLE,
			m_crListFrame,
			this,
			LISTFRAMECHILD);


	if (!bReturn)
	{
		CString csUserMsg =
							_T("Cannot create ListFrame CWnd.");
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
		return;
	}


	m_pListFrame->CWnd::SetFont ( &m_cfFont , FALSE);
	m_pListFrame->m_pBanner->m_pStatic->CWnd::SetFont ( &m_cfFont , FALSE);
	m_pList->SetActiveXParent(this);
	m_pList->CWnd::SetFont ( &m_cfFont , FALSE);

	m_pListFrameBanner->EnableButtons(FALSE,FALSE);

	m_PropertiesDialog.m_pActiveXParent = this;

}

void CEventRegEditCtrl::DestroyChildren()
{

	if (m_pTreeFrame)
	{
		m_pTreeFrame->DestroyWindow();
		delete m_pTreeFrame;
		m_pTreeFrame=NULL;
	}

	if (m_pListFrame)
	{
		m_pListFrame->DestroyWindow();
		delete m_pListFrame;
		m_pListFrame=NULL;
	}

}

void CEventRegEditCtrl::ClearChildren()
{
	m_pTreeFrameBanner->m_pSelectView->ClearContent();
	m_pTreeFrame->ClearContent();
	m_pListFrame->ClearContent();
}

void CEventRegEditCtrl::InitChildren()
{
	m_pTreeFrameBanner->m_pSelectView->InitContent();
	m_pTreeFrame->InitContent();
	if (m_pTree->GetRootItem())
	{
		m_pListFrame->InitContent();
	}
}

void CEventRegEditCtrl::SetChildGeometry(int cx,int cy)
{

#pragma warning( disable :4244 )
	int nLeftPaneRight = cx * LEFT_PANE_PERCENT;
#pragma warning( default :4244 )

	int nComboHeight = (m_tmFont.tmHeight) + 5;

	m_crTreeFrame.left = min(nLeftPaneRight,TREE_FRAME_LEFT);
	m_crTreeFrame.right = nLeftPaneRight;
	m_crTreeFrame.top = min(cy,VIEW_TOP);
	m_crTreeFrame.bottom = max(cy - 10, m_crTreeFrame.top);

	m_crListFrame.left = min(nLeftPaneRight + 10, cx);
	m_crListFrame.right = max (m_crListFrame.left, cx - 10);
	m_crListFrame.top = m_crTreeFrame.top;
	m_crListFrame.bottom = m_crTreeFrame.bottom;

}

void CEventRegEditCtrl::SetMode(int iMode, BOOL bDoIt)
{
	if (GetMode() != iMode || bDoIt)
	{
		m_iMode = iMode;
		m_bJustSetMode = TRUE;
		m_pTreeFrame->InitContent();
		m_pTreeFrame->UpdateWindow();
		m_pTreeFrame->RedrawWindow();
		m_pList->SetButtonState();
	}
}

CString CEventRegEditCtrl::GetModeString(int nMode)
{
	if (nMode >= 0 && nMode <= 2)
	{
		return m_csaModes.GetAt(nMode);
	}
	else
	{
		return "";
	}
}

CString CEventRegEditCtrl::GetRegistrationString(int nMode)
{
	if (nMode >= 0 && nMode <= 2)
	{
		return m_csaRegistrationStrings.GetAt(nMode);
	}
	else
	{
		return "";
	}

}

CString CEventRegEditCtrl::GetModeClass(int nMode)
{
	if (nMode >= 0 && nMode <= 2)
	{
		return m_csaClasses.GetAt(nMode);
	}
	else
	{
		return "";
	}
}

void CEventRegEditCtrl::TreeSelectionChanged(CStringArray &csaItemData)
{
	CString csTooltip;
	BOOL bClassSelectedSave = m_bClassSelected;

	/* 0 = none, 1 = clear list, 2 = set list, 3 = checks only */
	int nUpdateOperation = 0;

	CString csClassorInstance = csaItemData.GetAt(1);
	CString csClassorInstanceSave = m_csaLastTreeSelection.GetAt(1);

	if (m_bJustSetMode)
	{
		m_bJustSetMode = FALSE;
		nUpdateOperation = 2;
	}
	else if (csaItemData.GetAt(0).CompareNoCase(m_csaLastTreeSelection.GetAt(0)) != 0)
	{
		if (csaItemData.GetAt(1).CompareNoCase(_T("C")) == 0 &&
			m_csaLastTreeSelection.GetAt(1).CompareNoCase(_T("C")) == 0)
		{
			nUpdateOperation = 0;
		}
		else
		{
			if (m_csaLastTreeSelection.GetAt(1).CompareNoCase(_T("C")) == 0)
			{
				nUpdateOperation = 2;
			}
			else if (csaItemData.GetAt(1).CompareNoCase(_T("C")) == 0 &&
					m_csaLastTreeSelection.GetAt(1).CompareNoCase(_T("")) != 0)
			{
				nUpdateOperation = 1;
			}
			else if (m_csaLastTreeSelection.GetAt(1).CompareNoCase(_T("I")) == 0)
			{
				nUpdateOperation = 3;
			}
			else
			{
				nUpdateOperation = 2;
			}
		}

	}
	else
	{
		nUpdateOperation = 0;
	}




	if (csaItemData.GetAt(1).CompareNoCase(_T("C")) == 0)
	{
		csTooltip = _T("View class properties");
		CString csClass = csaItemData.GetAt(0);
		IWbemClassObject *pObject = GetClassObject (GetServices(),&csClass);

		if (!pObject)
		{
			m_pTreeFrameBanner->EnableButtons(FALSE,FALSE,FALSE);
			return;
		}

		if (IsClassAbstract(pObject))
		{
			m_pTreeFrameBanner->EnableButtons(FALSE,TRUE,FALSE);
		}
		else
		{
			m_pTreeFrameBanner->EnableButtons(TRUE,TRUE,FALSE);
		}
		pObject->Release();
		m_pTreeFrameBanner->SetPropertiesTooltip(csTooltip);
		m_bClassSelected = TRUE;
	}
	else
	{
		csTooltip = _T("Edit instance properties");
		m_pTreeFrameBanner->EnableButtons(FALSE,TRUE,TRUE);
		m_pTreeFrameBanner->SetPropertiesTooltip(csTooltip);
		m_bClassSelected = FALSE;
	}

	m_csaTreeSelection.SetAtGrow(0,csaItemData.GetAt(0));
	m_csaTreeSelection.SetAtGrow(1,csaItemData.GetAt(1));

	if (csaItemData.GetSize() > 2)
	{
		m_csaTreeSelection.SetAtGrow(2,csaItemData.GetAt(2));
	}

	/* 0 = none, 1 = clear list, 2 = set list, 3 = checks only */
	if (nUpdateOperation == 1)
	{
		m_pListFrame->ClearContent();
	}
	else if (nUpdateOperation == 2)
	{
		m_pListFrame->InitContent();
	}
	else if (nUpdateOperation == 3)
	{
		m_pListFrame->InitContent(TRUE,FALSE);
	}

	for (int i = 0; i < csaItemData.GetSize(); i++)
	{
		m_csaLastTreeSelection.SetAt(i,csaItemData.GetAt(i));
	}

}


void CEventRegEditCtrl::ButtonTreeProperties()
{

	CString csFirst = m_csaTreeSelection.GetAt(0);
	CString csSecond = m_csaTreeSelection.GetAt(1);

	m_PropertiesDialog.m_csPath = csFirst;
	m_PropertiesDialog.m_bClass = csSecond.CompareNoCase(_T("C")) == 0;
	m_PropertiesDialog.m_bNew = FALSE;

	if (m_PropertiesDialog.m_bClass)
	{
		m_PropertiesDialog.m_csClass = m_csaTreeSelection.GetAt(2);
	}
	else
	{
		m_PropertiesDialog.m_csClass = _T("");
	}

	m_PropertiesDialog.m_bViewOnly = FALSE;

	PreModalDialog();
	m_PropertiesDialog.DoModal();
	PostModalDialog();

}

void CEventRegEditCtrl::ButtonListProperties(CString *pcsPath)
{
	m_PropertiesDialog.m_csPath = *pcsPath;
	m_PropertiesDialog.m_bClass = FALSE;
	m_PropertiesDialog.m_bNew = FALSE;
	m_PropertiesDialog.m_csClass = _T("");
	m_PropertiesDialog.m_bViewOnly = TRUE;

	PreModalDialog();
	m_PropertiesDialog.DoModal();
	PostModalDialog();


}



void CEventRegEditCtrl::ButtonNew()
{
	CString csFirst = m_csaTreeSelection.GetAt(0);
	CString csSecond = m_csaTreeSelection.GetAt(1);
	CString csThird = m_csaTreeSelection.GetAt(2);


	m_PropertiesDialog.m_csClass = csFirst;
	m_PropertiesDialog.m_csPath = _T("");
	m_PropertiesDialog.m_bClass = FALSE;
	m_PropertiesDialog.m_bNew = TRUE;
	m_PropertiesDialog.m_bViewOnly = FALSE;

	PreModalDialog();
	int nReturn = (int) m_PropertiesDialog.DoModal();
	PostModalDialog();

	if (nReturn == IDOK)
	{
		HTREEITEM hItem = m_pTree->GetSelectedItem();
		m_pTree->RefreshBranch(hItem);
		m_pTree->Expand(hItem,TVE_EXPAND);
	}


}

void CEventRegEditCtrl::ButtonDelete()
{
	HTREEITEM hItem = m_pTree->GetSelectedItem();
	if (hItem)
	{
		m_pTree->DeleteTreeInstanceItem(hItem);
	}

	m_pList->SetButtonState();

}

void CEventRegEditCtrl::OnSetFocus(CWnd* pOldWnd)
{
	COleControl::OnSetFocus(pOldWnd);

	// TODO: Add your message handler code here

}

void CEventRegEditCtrl::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized)
{
	COleControl::OnActivate(nState, pWndOther, bMinimized);

	// TODO: Add your message handler code here

}

void CEventRegEditCtrl::PassThroughGetIWbemServices
(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
	FireGetIWbemServices
		(lpctstrNamespace,
		pvarUpdatePointer,
		pvarServices,
		pvarSC,
		pvarUserCancel);
}

void CEventRegEditCtrl::OnMenuitemrefresh()
{
	// TODO: Add your command handler code here
	m_pTree->RefreshBranch();
	m_pTree->SetFocus();

}

void CEventRegEditCtrl::OnUpdateMenuitemrefresh(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here
	UINT hitFlags = 0;
    HTREEITEM hItem = NULL;

    hItem = m_pTree->HitTest( m_pTree->m_cpRButtonUp, &hitFlags ) ;

	if (hItem && hitFlags & (TVHT_ONITEM))
	{

		CStringArray *pcsaItem
			= reinterpret_cast<CStringArray *>(m_pTree->GetItemData( hItem ));

		if (pcsaItem->GetAt(1).CompareNoCase(_T("C")) != 0)
		{
			pCmdUI -> Enable(FALSE);
		}
		else
		{
			pCmdUI -> Enable(TRUE);
		}
	}
	else
	{
		pCmdUI -> Enable(FALSE);
	}
}

BOOL CEventRegEditCtrl::PreTranslateMessage(MSG* pMsg)
{
	CWnd* pWndFocus = GetFocus();
	TCHAR szClass[40];
	// TODO: Add your specialized code here and/or call the base class
	switch (pMsg->message)

	{
	case WM_KEYDOWN:
	case WM_KEYUP:
			if (pMsg->wParam == VK_TAB)
		{
			if (m_bRestoreFocusToTree)
			{
				m_pTree->SetFocus();
			}
			else if (m_bRestoreFocusToCombo)
			{
				m_pTreeFrameBanner->m_pSelectView->SetFocus();
			}
			else if (m_bRestoreFocusToNamespace)
			{
				m_pTreeFrameBanner->m_pcnseNamespace->SetFocus();
			}
			else if (m_bRestoreFocusToList)
			{
				m_pList->SetFocus();
			}
			return COleControl::PreTranslateMessage(pMsg);
		}

		szClass[0] = TCHAR('\0');
		if (pWndFocus != NULL && IsChild(pWndFocus))
		{
			GetClassName(pWndFocus->m_hWnd, szClass, 39) ;
		}

		if (_tcsicmp(szClass, _T("SysTreeView32")) == 0 && pMsg->wParam == VK_ESCAPE)
		{
			return FALSE;
		}
		else if (_tcsicmp(szClass, _T("SysListView32")) == 0 && pMsg->wParam == VK_ESCAPE)
		{
			return FALSE;
		}
		else if (_tcsicmp(szClass, _T("ComboBox")) == 0 && pMsg->wParam == VK_ESCAPE)
		{
			return FALSE;
		}

		break;

	}

	BOOL bReturn = COleControl::PreTranslateMessage(pMsg);
	return bReturn;
}

BOOL CEventRegEditCtrl::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	// TODO: Add your specialized code here and/or call the base class

	return COleControl::OnNotify(wParam, lParam, pResult);
}


void CEventRegEditCtrl::OnNotifyInstanceCreated(LPCTSTR lpctstrPath)
{
	if (GetMode() == TIMERS)
	{
	}


}

void CEventRegEditCtrl::OnEditinstprop()
{
	// TODO: Add your command handler code here
		HTREEITEM hItem = m_hContextItem;
	m_hContextItem = NULL;

	CStringArray *pcsaItem
		= reinterpret_cast<CStringArray *>(m_pTree->GetItemData( hItem ));

	if (!pcsaItem)
	{
		return;
	}

	m_PropertiesDialog.m_csPath = pcsaItem->GetAt(0);
	m_PropertiesDialog.m_bClass = FALSE;
	m_PropertiesDialog.m_bNew = FALSE;

	m_PropertiesDialog.m_csClass = _T("");
	m_PropertiesDialog.m_bViewOnly = FALSE;

	PreModalDialog();
	m_PropertiesDialog.DoModal();
	PostModalDialog();
	m_pTree->SetFocus();

}

void CEventRegEditCtrl::OnUpdateEditinstprop(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here
	UINT hitFlags = 0;
    HTREEITEM hItem = NULL;

    hItem = m_pTree->HitTest( m_pTree->m_cpRButtonUp, &hitFlags ) ;

	if (hItem && hitFlags & (TVHT_ONITEM))
	{

		BOOL bClass = m_pTree->IsItemAClass(hItem);

		if (bClass)
		{
			pCmdUI -> Enable(FALSE);
		}
		else
		{
			m_hContextItem = hItem;
			pCmdUI -> Enable(TRUE);
		}
	}
	else
	{
		pCmdUI -> Enable(FALSE);
	}
}

void CEventRegEditCtrl::OnViewclassprop()
{
	// TODO: Add your command handler code here
	HTREEITEM hItem = m_hContextItem;
	m_hContextItem = NULL;

	CStringArray *pcsaItem
		= reinterpret_cast<CStringArray *>(m_pTree->GetItemData( hItem ));

	if (!pcsaItem)
	{
		return;
	}

	m_PropertiesDialog.m_csPath = pcsaItem->GetAt(0);
	m_PropertiesDialog.m_bClass = TRUE;
	m_PropertiesDialog.m_bNew = FALSE;

	m_PropertiesDialog.m_csClass = pcsaItem->GetAt(2);
	m_PropertiesDialog.m_bViewOnly = FALSE;

	PreModalDialog();
	m_PropertiesDialog.DoModal();
	PostModalDialog();
	m_pTree->SetFocus();

}

void CEventRegEditCtrl::OnUpdateViewclassprop(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here
	UINT hitFlags = 0;
    HTREEITEM hItem = NULL;

    hItem = m_pTree->HitTest( m_pTree->m_cpRButtonUp, &hitFlags ) ;

	if (hItem && hitFlags & (TVHT_ONITEM))
	{

		BOOL bClass = m_pTree->IsItemAClass(hItem);

		if (!bClass)
		{
			pCmdUI -> Enable(FALSE);
		}
		else
		{
			m_hContextItem = hItem;
			pCmdUI -> Enable(TRUE);
		}
	}
	else
	{
		pCmdUI -> Enable(FALSE);
	}
}

void CEventRegEditCtrl::OnNewinstance()
{
	// TODO: Add your command handler code here

	HTREEITEM hItem = m_hContextItem;
	m_hContextItem = NULL;

	CStringArray *pcsaItem
		= reinterpret_cast<CStringArray *>(m_pTree->GetItemData( hItem ));

	if (!pcsaItem)
	{
		return;
	}

	CString csFirst = pcsaItem->GetAt(0);
	CString csSecond = pcsaItem->GetAt(1);
	CString csThird = pcsaItem->GetAt(2);


	m_PropertiesDialog.m_csClass = csFirst;
	m_PropertiesDialog.m_csPath = _T("");
	m_PropertiesDialog.m_bClass = FALSE;
	m_PropertiesDialog.m_bNew = TRUE;
	m_PropertiesDialog.m_bViewOnly = FALSE;

	PreModalDialog();
	int nReturn = (int) m_PropertiesDialog.DoModal();
	PostModalDialog();

	if (nReturn == IDOK)
	{
		m_pTree->RefreshBranch(hItem);
		m_pTree->Expand(hItem,TVE_EXPAND);
	}
	m_pTree->SetFocus();

}

void CEventRegEditCtrl::OnUpdateNewinstance(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here
	UINT hitFlags = 0;
    HTREEITEM hItem = NULL;

    hItem = m_pTree->HitTest( m_pTree->m_cpRButtonUp, &hitFlags ) ;

	if (!hItem)
	{
		pCmdUI -> Enable(FALSE);
		return;
	}

	BOOL bClass = m_pTree->IsItemAClass(hItem);

	if (hItem && hitFlags & (TVHT_ONITEM))
	{
		pCmdUI -> Enable(bClass);
	}
	else
	{
		pCmdUI -> Enable(FALSE);
	}
}

void CEventRegEditCtrl::OnDeleteinstance()
{
	// TODO: Add your command handler code here
	HTREEITEM hItem = m_hContextItem;
	m_hContextItem = NULL;
	if (hItem)
	{
		m_pTree->DeleteTreeInstanceItem(hItem);
	}

	m_pTree->SetFocus();

}

void CEventRegEditCtrl::OnUpdateDeleteinstance(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here
	UINT hitFlags = 0;
    HTREEITEM hItem = NULL;

    hItem = m_pTree->HitTest( m_pTree->m_cpRButtonUp, &hitFlags ) ;

	if (hItem && hitFlags & (TVHT_ONITEM))
	{

		BOOL bClass = m_pTree->IsItemAClass(hItem);

		if (bClass)
		{
			pCmdUI -> Enable(FALSE);
		}
		else
		{
			m_hContextItem = hItem;
			pCmdUI -> Enable(TRUE);
		}
	}
	else
	{
		pCmdUI -> Enable(FALSE);
	}
}

void CEventRegEditCtrl::OnViewinstprop()
{
	// TODO: Add your command handler code here
	UINT uFlags = 0;

	int nItem  = m_pList->GetListCtrl().HitTest
		( m_pList->m_cpRButtonUp, &uFlags);

	CString csPath;
	LV_ITEM lvi;

	lvi.mask = LVIF_PARAM;
	lvi.iItem = nItem;
	lvi.iSubItem = 0;

	BOOL bReturn = m_pList->GetListCtrl().GetItem(&lvi);
	if (bReturn)
	{
		CString *pcsSelected =
					reinterpret_cast<CString *>(lvi.lParam);

		csPath = pcsSelected->Mid(1);
		ButtonListProperties(&csPath);
	}
	m_pTree->SetFocus();

}

void CEventRegEditCtrl::OnUpdateViewinstprop(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here
	if (m_pList->GetListCtrl().GetSelectedCount() == 1)
	{
		pCmdUI -> Enable(TRUE);
	}
	else
	{
		pCmdUI -> Enable(FALSE);
	}
}

void CEventRegEditCtrl::OnRegister()
{
	// TODO: Add your command handler code here
	UINT uFlags = 0;

	int nItem  = m_pList->GetListCtrl().HitTest
		( m_pList->m_cpRButtonUp, &uFlags);
	m_pList->RegisterSelections();

}

void CEventRegEditCtrl::OnUpdateRegister(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here
	UINT nState =
		m_pListFrameBanner->m_pToolBar->GetToolBarCtrl().GetState(ID_BUTTONCHECKED);

	if (nState & TBSTATE_CHECKED)
	{
		pCmdUI -> Enable(FALSE);
	}
	else
	{
		if (m_pList->GetListCtrl().GetSelectedCount() > 0)
		{
			pCmdUI -> Enable(TRUE);
		}
		else
		{
			pCmdUI -> Enable(FALSE);
		}
	}
}

void CEventRegEditCtrl::OnUnregister()
{
	// TODO: Add your command handler code here
	m_pList->UnregisterSelections();
}

void CEventRegEditCtrl::OnUpdateUnregister(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here
	UINT nState =
		m_pListFrameBanner->m_pToolBar->GetToolBarCtrl().GetState(ID_BUTTONCHECKED);

	if (nState & TBSTATE_CHECKED &&
		(m_pList->GetListCtrl().GetSelectedCount() > 0))
	{
		pCmdUI -> Enable(TRUE);
	}
	else
	{
		pCmdUI -> Enable(FALSE);
	}
}

BSTR CEventRegEditCtrl::GetRootFilterClass()
{
	return m_csRootFilterClass.AllocSysString();
}

void CEventRegEditCtrl::SetRootFilterClass(LPCTSTR lpszNewValue)
{
	CString csRootFilterClass = lpszNewValue;

	if (!AmbientUserMode( ) || !GetSafeHwnd( ) || !m_pServices)
	{
		m_csRootFilterClass = csRootFilterClass;
		return;
	}

	m_csRootFilterClass = csRootFilterClass;

	IWbemClassObject *pObject = GetClassObject(m_pServices,&m_csRootFilterClass,TRUE);
	CString csBaseClass = _T("__EventFilter");
	if (pObject && IsObjectOfClass(csBaseClass,pObject))
	{
		pObject->Release();
		pObject = NULL;
	}
	else
	{
		m_csRootFilterClass = csBaseClass;

	}

	m_csaClasses.SetAt(1,m_csRootFilterClass);

	if (pObject)
	{
		pObject->Release();
	}

	m_iMode = m_pTreeFrameBanner->m_pSelectView->GetCurSel();
	SetMode(m_iMode,TRUE);
}

BSTR CEventRegEditCtrl::GetRootConsumerClass()
{
	return m_csRootConsumerClass.AllocSysString();
}

void CEventRegEditCtrl::SetRootConsumerClass(LPCTSTR lpszNewValue)
{
	CString csRootConsumerClass = lpszNewValue;

	if (!AmbientUserMode( ) || !GetSafeHwnd( ) || !m_pServices)
	{
		m_csRootConsumerClass = csRootConsumerClass;
		return;
	}

	m_csRootConsumerClass = csRootConsumerClass;

	CString csBaseClass = _T("__EventConsumer");
	IWbemClassObject *pObject = GetClassObject(m_pServices,&m_csRootConsumerClass,TRUE);
	if (pObject && IsObjectOfClass(csBaseClass,pObject))
	{
		pObject->Release();
		pObject = NULL;
	}
	else
	{
		m_csRootConsumerClass = csBaseClass;

	}

	m_csaClasses.SetAt(0,m_csRootConsumerClass);

	if (pObject)
	{
		pObject->Release();
	}

	m_iMode = m_pTreeFrameBanner->m_pSelectView->GetCurSel();
	SetMode(m_iMode,TRUE);
}

BSTR CEventRegEditCtrl::GetViewMode()
{
	CString strResult = GetModeString(m_iMode);
	// TODO: Add your property handler here

	return strResult.AllocSysString();
}

void CEventRegEditCtrl::SetViewMode(LPCTSTR lpszNewValue)
{
	m_csMode = lpszNewValue;

	if (m_csMode.CompareNoCase(GetModeString(CONSUMERS)) == 0)
	{
		m_csMode = GetModeString(CONSUMERS);
		m_csRegistrationString = GetRegistrationString(CONSUMERS);
		m_iMode = CONSUMERS;
	}
	else if (m_csMode.CompareNoCase(GetModeString(FILTERS)) == 0)
	{
		m_csMode = GetModeString(FILTERS);
		m_csRegistrationString = GetRegistrationString(FILTERS);
		m_iMode = FILTERS;
	}
	else if (m_csMode.CompareNoCase(GetModeString(TIMERS)) == 0)
	{
		m_csMode = GetModeString(TIMERS);
		m_csRegistrationString = GetRegistrationString(TIMERS);
		m_iMode = TIMERS;
	}
	else
	{
		m_csMode = GetModeString(CONSUMERS);
		m_csRegistrationString = GetRegistrationString(CONSUMERS);
		m_iMode = CONSUMERS;
	}


	if (!AmbientUserMode( ) || !GetSafeHwnd( ))
	{
		return;
	}

	CString csMode = lpszNewValue;
	// TODO: Add your property handler here
	if (csMode.CompareNoCase(GetModeString(CONSUMERS)) == 0)
	{
		SetMode(CONSUMERS,TRUE);
	}
	else if (csMode.CompareNoCase(GetModeString(FILTERS)) == 0)
	{
		SetMode(FILTERS,TRUE);
	}
	else if (csMode.CompareNoCase(GetModeString(TIMERS)) == 0)
	{
		SetMode(TIMERS,TRUE);
	}
	else
	{
		SetMode(CONSUMERS, TRUE);
	}

	SetModifiedFlag();
}

BOOL CEventRegEditCtrl::IsClassSelected()
{
	if (m_csaTreeSelection.GetSize() > 0)
	{
		return m_csaTreeSelection.GetAt(1).CompareNoCase(_T("C")) == 0;
	}
	else
	{
		return FALSE;
	}

}

void CEventRegEditCtrl::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// TODO: Add your message handler code here and/or call default

	COleControl::OnKeyUp(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\eventregeditppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_EVENTREGEDITPPG_H__0DA25B15_2962_11D1_9651_00C04FD9B15B__INCLUDED_)
#define AFX_EVENTREGEDITPPG_H__0DA25B15_2962_11D1_9651_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// EventRegEditPpg.h : Declaration of the CEventRegEditPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CEventRegEditPropPage : See EventRegEditPpg.cpp.cpp for implementation.

class CEventRegEditPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CEventRegEditPropPage)
	DECLARE_OLECREATE_EX(CEventRegEditPropPage)

// Constructor
public:
	CEventRegEditPropPage();

// Dialog Data
	//{{AFX_DATA(CEventRegEditPropPage)
	enum { IDD = IDD_PROPPAGE_EVENTREGEDIT };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CEventRegEditPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EVENTREGEDITPPG_H__0DA25B15_2962_11D1_9651_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\eventregeditctl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_EVENTREGEDITCTL_H__0DA25B13_2962_11D1_9651_00C04FD9B15B__INCLUDED_)
#define AFX_EVENTREGEDITCTL_H__0DA25B13_2962_11D1_9651_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// EventRegEditCtl.h : Declaration of the CEventRegEditCtrl ActiveX Control class.

#define INITNAMESPACE WM_USER + 1

class CSelectView;
class CTreeFrame;
class CTreeFrameBanner;
class CClassInstanceTree;
class CPropertiesDialog;
class CListFrame;
class CListFrameBaner;
class CRegistrationList;
class CRegEditNSEntry;


/////////////////////////////////////////////////////////////////////////////
// CEventRegEditCtrl : See EventRegEditCtl.cpp for implementation.

class CEventRegEditCtrl : public COleControl
{
	DECLARE_DYNCREATE(CEventRegEditCtrl)

// Constructor
public:
	CEventRegEditCtrl();
	IWbemServices *GetServices() {return m_pServices;}
	CString GetServiceNamespace() {return m_csNamespace;}
	CFont *GetControlFont() { return &m_cfFont; }
	enum {CONSUMERS = 0, FILTERS, TIMERS, NONE};
	void SetMode(int iMode, BOOL bDoIt = FALSE);
	int GetMode() {return m_iMode;}
	BOOL Modeless() {return GetMode() == NONE;}
	BOOL IsClassSelected();
	CString GetModeString(int nMode);
	CString GetRegistrationString(int nMode);
	CString GetCurrentModeString() {return m_csaModes.GetAt(GetMode());}
	CString GetModeClass(int nMode);
	CString GetCurrentModeClass() {return m_csaClasses.GetAt(GetMode());}
	CString GetCurrentRegistrationString() {return m_csaRegistrationStrings.GetAt(GetMode());}
	void ButtonTreeProperties();
	void ButtonListProperties(CString *pcsPath);
	void ButtonNew();
	void ButtonDelete();
	void PassThroughGetIWbemServices
		(	LPCTSTR lpctstrNamespace,
			VARIANT FAR* pvarUpdatePointer,
			VARIANT FAR* pvarServices,
			VARIANT FAR* pvarSC,
			VARIANT FAR* pvarUserCancel);
	CString GetTreeSelectionPath()
	{	if (m_csaTreeSelection.GetSize() > 0)
		{
			return m_csaTreeSelection.GetAt(0);
		}
		return "";
	}
	void OnNotifyInstanceCreated(LPCTSTR lpctstrPath);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEventRegEditCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual BOOL DestroyWindow();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	int m_iMode;
	CString m_csMode;
	BOOL m_bJustSetMode;
	~CEventRegEditCtrl();
	CString m_csNamespace;
	CString m_csNamespaceInit;
	BOOL m_bNamespaceInit;
	BOOL m_bValidatedRootClasses;
	CStringArray m_csaModes;
	CStringArray m_csaClasses;
	CStringArray m_csaRegistrationStrings;
	CString m_csRegistrationString;
	BOOL m_bClassSelected;
	BOOL m_sc;
	BOOL m_bUserCancel;
	IWbemServices *m_pServices;
	IWbemServices *GetIWbemServices(CString &rcsNamespace);
	BOOL m_bMetricSet;
	CString m_csFontName;
	short m_nFontHeight;
	short m_nFontWeight;
	CFont m_cfFont;
	TEXTMETRIC m_tmFont;


	BOOL m_bChildSizeSet;
	//CRect m_crSelectView;
	CRect m_crTreeFrame;
	CRect m_crListFrame;

	CTreeFrame *m_pTreeFrame;
	CTreeFrameBanner *m_pTreeFrameBanner;
	CClassInstanceTree *m_pTree;
	CListFrame *m_pListFrame;
	CListFrameBaner *m_pListFrameBanner;
	CRegistrationList *m_pList;

	CString m_csRootFilterClass;
	CString m_csRootConsumerClass;

	void SetChildGeometry(int cx,int cy);
	void CreateControlFont();
	void InitializeLogFont
		(LOGFONT &rlfFont, CString csName, int nHeight, int nWeight);
	void CreateChildren();
	void DestroyChildren();
	void ClearChildren();
	void InitChildren();

	void TreeSelectionChanged(CStringArray &csaItemData);
	CStringArray m_csaTreeSelection;
	CStringArray m_csaLastTreeSelection;

	BOOL m_bRestoreFocusToTree;
	BOOL m_bRestoreFocusToCombo;
	BOOL m_bRestoreFocusToNamespace;
	BOOL m_bRestoreFocusToList;

	DECLARE_OLECREATE_EX(CEventRegEditCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CEventRegEditCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CEventRegEditCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CEventRegEditCtrl)		// Type name and misc status

	friend class CSelectView;
	friend class CTreeFrame;
	friend class CTreeFrameBanner;
	friend class CClassInstanceTree;
	friend class CListFrame;
	friend class CListFrameBaner;
	friend class CRegistrationList;
	friend class CRegEditNSEntry;

	BOOL m_bOpeningNamespace;

	CPropertiesDialog m_PropertiesDialog;

	HTREEITEM m_hContextItem;

// Message maps
	//{{AFX_MSG(CEventRegEditCtrl)
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnMenuitemrefresh();
	afx_msg void OnUpdateMenuitemrefresh(CCmdUI* pCmdUI);
	afx_msg void OnEditinstprop();
	afx_msg void OnUpdateEditinstprop(CCmdUI* pCmdUI);
	afx_msg void OnViewclassprop();
	afx_msg void OnUpdateViewclassprop(CCmdUI* pCmdUI);
	afx_msg void OnNewinstance();
	afx_msg void OnUpdateNewinstance(CCmdUI* pCmdUI);
	afx_msg void OnDeleteinstance();
	afx_msg void OnUpdateDeleteinstance(CCmdUI* pCmdUI);
	afx_msg void OnViewinstprop();
	afx_msg void OnUpdateViewinstprop(CCmdUI* pCmdUI);
	afx_msg void OnRegister();
	afx_msg void OnUpdateRegister(CCmdUI* pCmdUI);
	afx_msg void OnUnregister();
	afx_msg void OnUpdateUnregister(CCmdUI* pCmdUI);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	afx_msg LRESULT InitNamespace(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CEventRegEditCtrl)
	afx_msg BSTR GetNameSpace();
	afx_msg void SetNameSpace(LPCTSTR lpszNewValue);
	afx_msg BSTR GetRootFilterClass();
	afx_msg void SetRootFilterClass(LPCTSTR lpszNewValue);
	afx_msg BSTR GetRootConsumerClass();
	afx_msg void SetRootConsumerClass(LPCTSTR lpszNewValue);
	afx_msg BSTR GetViewMode();
	afx_msg void SetViewMode(LPCTSTR lpszNewValue);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CEventRegEditCtrl)
	void FireGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarService, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
		{FireEvent(eventidGetIWbemServices,EVENT_PARAM(VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT), lpctstrNamespace, pvarUpdatePointer, pvarService, pvarSC, pvarUserCancel);}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CEventRegEditCtrl)
	dispidNameSpace = 1L,
	dispidRootFilterClass = 2L,
	dispidRootConsumerClass = 3L,
	dispidViewMode = 4L,
	eventidGetIWbemServices = 1L,
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EVENTREGEDITCTL_H__0DA25B13_2962_11D1_9651_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\eventregeditppg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// EventRegEditPpg.cpp : Implementation of the CEventRegEditPropPage property page class.

#include "precomp.h"
#include "EventRegEdit.h"
#include "EventRegEditPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CEventRegEditPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CEventRegEditPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CEventRegEditPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CEventRegEditPropPage, "WBEM.EventRegPropPage.1",
	0xda25b06, 0x2962, 0x11d1, 0x96, 0x51, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// CEventRegEditPropPage::CEventRegEditPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CEventRegEditPropPage

BOOL CEventRegEditPropPage::CEventRegEditPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_EVENTREGEDIT_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CEventRegEditPropPage::CEventRegEditPropPage - Constructor

CEventRegEditPropPage::CEventRegEditPropPage() :
	COlePropertyPage(IDD, IDS_EVENTREGEDIT_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CEventRegEditPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CEventRegEditPropPage::DoDataExchange - Moves data between page and properties

void CEventRegEditPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CEventRegEditPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CEventRegEditPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\initnamespacedialog.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// InitNamespaceDialog.cpp : implementation file
//

#include "precomp.h"
#include "wbemidl.h"
#include "MsgDlgExterns.h"
#include "util.h"
#include "resource.h"
#include "PropertiesDialog.h"
#include "EventRegEdit.h"
#include "EventRegEditCtl.h"
#include "nsentry.h"
#include "InitNamespaceNSEntry.h"
#include "InitNamespaceDialog.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void CenterWindowInOwner(CWnd *pWnd,CRect &rectMove)
{
	if (!pWnd)
	{
		return;
	}

	CWnd *pOwner = pWnd->GetOwner();

	if (!pOwner)
	{
		return;
	}

	CRect rectOwner;
	pOwner->GetWindowRect(&rectOwner);

	CRect rect;
	pWnd->GetWindowRect(&rect);

	if (rectOwner.Width() < rect.Width())
	{
		long delta = (long) ((rectOwner.Width() - rect.Width()) * .5);
		rectMove.left = rectOwner.left + delta;
		rectMove.right = rectOwner.right - delta;
	}
	else
	{
		long delta = (long) ((rect.Width() - rectOwner.Width()) * .5);
		rectMove.left = rectOwner.left - delta;
		rectMove.right = rectOwner.right + delta;
	}

	if (rectOwner.Height() < rect.Height())
	{
		long delta = (long) ((rectOwner.Height() - rect.Height()) * .5);
		rectMove.top = rectOwner.top + delta;
		rectMove.bottom = rectOwner.bottom - delta;
	}
	else
	{
		long delta = (long) ((rect.Height() - rectOwner.Height()) * .5);
		rectMove.top = rectOwner.top - delta;
		rectMove.bottom = rectOwner.bottom + delta;

	}

}
/////////////////////////////////////////////////////////////////////////////
// CInitNamespaceDialog dialog

#define INITIALIZE_INIT_NAMESPACE WM_USER + 400

CInitNamespaceDialog::CInitNamespaceDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CInitNamespaceDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CInitNamespaceDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInit = FALSE;
}


void CInitNamespaceDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInitNamespaceDialog)
	DDX_Control(pDX, IDC_NSENTRYCTRLINITNAMESPACE, m_cnseInitNamespace);
	//}}AFX_DATA_MAP

	if (!m_bInit)
	{
		m_bInit = TRUE;
		PostMessage(INITIALIZE_INIT_NAMESPACE,0,0);
	}
}

LRESULT CInitNamespaceDialog::InitNamespace(WPARAM, LPARAM)
{
	if (!m_cnseInitNamespace.GetSafeHwnd())
	{
		PostMessage(INITIALIZE_INIT_NAMESPACE,0,0);
		return 0;
	}
	else
	{
		m_cnseInitNamespace.SetNamespaceText(_T("root\\CIMV2"));
		m_cnseInitNamespace.SetFocusToEdit();
		return 0;
	}

}

BEGIN_MESSAGE_MAP(CInitNamespaceDialog, CDialog)
	//{{AFX_MSG_MAP(CInitNamespaceDialog)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	ON_MESSAGE(INITIALIZE_INIT_NAMESPACE, InitNamespace )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInitNamespaceDialog message handlers

BEGIN_EVENTSINK_MAP(CInitNamespaceDialog, CDialog)
    //{{AFX_EVENTSINK_MAP(CInitNamespaceDialog)
	ON_EVENT(CInitNamespaceDialog, IDC_NSENTRYCTRLINITNAMESPACE, 3 /* GetIWbemServices */, OnGetIWbemServicesNsentryctrlinitnamespace, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

BOOL CInitNamespaceDialog::OnInitDialog()
{
	CDialog::OnInitDialog();
	m_cnseInitNamespace.SetLocalParent(m_pParent);
	m_cnseInitNamespace.ClearOnLoseFocus(0);

	CRect rectMove;
	CenterWindowInOwner(this,rectMove);

	SetWindowPos(&wndTop,
				rectMove.left,
				rectMove.top,
				rectMove.Width(),
				rectMove.Height(),
				SWP_NOSIZE | SWP_NOMOVE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CInitNamespaceDialog::OnOK()
{
	// TODO: Add extra validation here
			CWnd* pWndFocus = GetFocus();
	TCHAR szClass[140];
	int n = GetClassName(pWndFocus->m_hWnd, szClass, 139);

	CString csText = m_cnseInitNamespace.GetNamespaceText();
	csText.TrimLeft();
	csText.TrimRight();

	BSTR bstrNamespace = csText.AllocSysString();
	m_cnseInitNamespace.OpenNamespace(bstrNamespace, FALSE);
	SysFreeString(bstrNamespace);
}

void CInitNamespaceDialog::OnCancel()
{
	// TODO: Add extra cleanup here

	CDialog::OnCancel();
}

void CInitNamespaceDialog::OnGetIWbemServicesNsentryctrlinitnamespace
(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
	// TODO: Add your control notification handler code here
	m_pParent->PassThroughGetIWbemServices
		(lpctstrNamespace,
		pvarUpdatePointer,
		pvarServices,
		pvarSC,
		pvarUserCancel);
}

void CInitNamespaceDialog::OnDestroy()
{
	if (!m_cnseInitNamespace.GetSafeHwnd())
	{
		CDialog::OnDestroy();
		return;
	}

	m_bValid = m_cnseInitNamespace.IsTextValid();
	m_csNamespace = m_cnseInitNamespace.GetNamespaceText();

	CDialog::OnDestroy();

	// TODO: Add your message handler code here

}

BOOL CInitNamespaceDialog::PreTranslateMessage(MSG* lpMsg)
{
	// TODO: Add your specialized code here and/or call the base class
	switch (lpMsg->message)
	{
	case WM_KEYDOWN:
	case WM_KEYUP:
		if (lpMsg->wParam == VK_RETURN)
		{
			CWnd* pWndFocus = GetFocus();
			TCHAR szClass[140];
			int n = GetClassName(pWndFocus->m_hWnd, szClass, 139);

			if (pWndFocus &&
				IsChild(pWndFocus) &&
				n > 0 &&
				_tcsicmp(szClass, _T("EDIT")) == 0)
			{
				pWndFocus->SendMessage(lpMsg->message, lpMsg->wParam, lpMsg->lParam);
				return TRUE;
			}
		}
		if (lpMsg->wParam == VK_ESCAPE)
		{
			if (lpMsg->message == WM_KEYUP)
			{
				return TRUE;
			}
			PostMessage(WM_CLOSE, 0, 0);
			return TRUE;

		}

		break;
	}

	return CDialog::PreTranslateMessage(lpMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\initnamespacedialog.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{AFX_INCLUDES()
#include "nsentry.h"
//}}AFX_INCLUDES
#if !defined(AFX_INITNAMESPACEDIALOG_H__6BB4B5F4_9356_11D1_966E_00C04FD9B15B__INCLUDED_)
#define AFX_INITNAMESPACEDIALOG_H__6BB4B5F4_9356_11D1_966E_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// InitNamespaceDialog.h : header file
//
class CEventRegEditCtrl;
class CInitNamespaceNSEntry;
/////////////////////////////////////////////////////////////////////////////
// CInitNamespaceDialog dialog

class CInitNamespaceDialog : public CDialog
{
// Construction
public:
	CInitNamespaceDialog(CWnd* pParent = NULL);   // standard constructor
	CString GetNamespace() {return m_csNamespace;}
// Dialog Data
	//{{AFX_DATA(CInitNamespaceDialog)
	enum { IDD = IDD_DIALOGINITNAMESPACE };
	CInitNamespaceNSEntry	m_cnseInitNamespace;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInitNamespaceDialog)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CEventRegEditCtrl *m_pParent;
	CString m_csNamespace;
	BOOL m_bValid;
	BOOL m_bInit;
	// Generated message map functions
	//{{AFX_MSG(CInitNamespaceDialog)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnGetIWbemServicesNsentryctrlinitnamespace(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);
	afx_msg void OnDestroy();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	afx_msg LRESULT InitNamespace(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
	friend class CEventRegEditCtrl;
	friend class CInitNamespaceNSEntry;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INITNAMESPACEDIALOG_H__6BB4B5F4_9356_11D1_966E_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\initnamespacensentry.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved


#include "precomp.h"
#include "wbemidl.h"
#include "MsgDlgExterns.h"
#include "util.h"
#include "resource.h"
#include "PropertiesDialog.h"
#include "EventRegEdit.h"
#include "EventRegEditCtl.h"
#include "nsentry.h"
#include "InitNamespaceNSEntry.h"
#include "InitNamespaceDialog.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CInitNamespaceNSEntry

IMPLEMENT_DYNCREATE(CInitNamespaceNSEntry,CNSEntry)

CInitNamespaceNSEntry::CInitNamespaceNSEntry()
{
	m_pParent = NULL;

}

BEGIN_MESSAGE_MAP(CInitNamespaceNSEntry, CNSEntry)
	//{{AFX_MSG_MAP(CInitNamespaceNSEntry)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BEGIN_EVENTSINK_MAP(CInitNamespaceNSEntry, CNSEntry)
    //{{AFX_EVENTSINK_MAP(CInitNamespaceNSEntry)
	ON_EVENT_REFLECT(CInitNamespaceNSEntry, 1 , OnNameSpaceChanged, VTS_BSTR VTS_BOOL)
	ON_EVENT_REFLECT(CInitNamespaceNSEntry, 2 , OnNameSpaceRedrawn, VTS_NONE)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

void CInitNamespaceNSEntry::OnNameSpaceRedrawn()
{
	m_pParent->InvalidateControl();
}


void CInitNamespaceNSEntry::OnNameSpaceChanged(LPCTSTR bstrNewNameSpace, BOOL boolValid)
{


	CInitNamespaceDialog *pParent =
		reinterpret_cast<CInitNamespaceDialog *>(GetParent());
	pParent->CDialog::OnOK();
	m_pParent->InvalidateControl();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\initnamespacensentry.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __InstNavNSEntry_H__
#define __InstNavNSEntry_H__

class CEventRegEditCtrl;

class CInitNamespaceNSEntry : public CNSEntry
{
protected:
	DECLARE_DYNCREATE(CInitNamespaceNSEntry)


	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInitNamespaceNSEntry)
	protected:
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CInitNamespaceNSEntry)
			afx_msg void OnNameSpaceChanged(LPCTSTR bstrNewNameSpace, BOOL boolValid);
			afx_msg void OnNameSpaceRedrawn();
		//	afx_msg void OnGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);
	//}}AFX_MSG
	
	DECLARE_EVENTSINK_MAP()
	DECLARE_MESSAGE_MAP()

public:
	CInitNamespaceNSEntry();
	void SetLocalParent(CEventRegEditCtrl* pParent) 
		{	m_pParent = pParent;
		}
protected:
	CEventRegEditCtrl* m_pParent;
};

#endif // __InstNavNSEntry_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\listbannertoolbar.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ListBannerToolbar.cpp : implementation file
//

#include "precomp.h"
#include "EventRegEdit.h"
#include "ListBannerToolbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define INITLISTTOOLTIP  WM_USER + 389
/////////////////////////////////////////////////////////////////////////////
// CListBannerToolbar

CListBannerToolbar::CListBannerToolbar()
{
}

CListBannerToolbar::~CListBannerToolbar()
{
}


BEGIN_MESSAGE_MAP(CListBannerToolbar, CToolBar)
	//{{AFX_MSG_MAP(CListBannerToolbar)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(INITLISTTOOLTIP, InitTooltip )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CListBannerToolbar message handlers

CSize CListBannerToolbar::GetToolBarSize()
{
	CRect rcButtons;
	CToolBarCtrl &rToolBarCtrl = GetToolBarCtrl();
	int nButtons = rToolBarCtrl.GetButtonCount();
	if (nButtons > 0) {
		CRect rcLastButton;
		rToolBarCtrl.GetItemRect(0, &rcButtons);
		rToolBarCtrl.GetItemRect(nButtons-1, &rcLastButton);
		rcButtons.UnionRect(&rcButtons, &rcLastButton);
	}
	else {
		rcButtons.SetRectEmpty();
	}

	CSize size;
	size.cx = rcButtons.Width();
	size.cy = rcButtons.Height();
	return size;
}

LRESULT CListBannerToolbar::InitTooltip(WPARAM, LPARAM)
{
	CToolBarCtrl &rToolBarCtrl = GetToolBarCtrl();

//	rToolBarCtrl.EnableButton(ID_BUTTONCHECKED,FALSE);
//	rToolBarCtrl.EnableButton(ID_BUTTONUNCHECKED,FALSE);

	// This is where we want to associate a string with
	// the tool for each button.
	CSize csToolBar = GetToolBarSize();

	#pragma warning( disable :4244 )
	CRect crToolBar(0,0,(int) csToolBar.cx * .5,csToolBar.cy);
	#pragma warning( default : 4244 )

	GetToolTip().AddTool
		(&rToolBarCtrl,_T("Register"),&crToolBar,1);

	#pragma warning( disable :4244 )
	crToolBar.SetRect
		((int)csToolBar.cx * .5,0,(int) csToolBar.cx,csToolBar.cy);
	#pragma warning( default : 4244 )

	GetToolTip().AddTool
		(&rToolBarCtrl,_T("View instance properties"),&crToolBar,2);

	return 0;
}

int CListBannerToolbar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	lpCreateStruct->style = lpCreateStruct->style |
								CBRS_TOOLTIPS | CBRS_FLYBY;
	if (CToolBar::OnCreate(lpCreateStruct) == -1)
		return -1;

	CToolBarCtrl &rToolBarCtrl = GetToolBarCtrl();

	if (!m_ttip.Create(this,TTS_ALWAYSTIP))
		TRACE0("Unable to create tip window.");
	else
	{
		m_ttip.Activate(TRUE);
		rToolBarCtrl.SetToolTips(&m_ttip );
		PostMessage(INITLISTTOOLTIP,0,0);
	}

	// TBBS_CHECKBOX
	// TBSTYLE_CHECK

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\listcwnd.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ListCwnd.cpp : implementation file
//

#include "precomp.h"
#include "wbemidl.h"
#include "MsgDlgExterns.h"
#include "util.h"
#include "resource.h"
#include "EventRegEdit.h"
#include "PropertiesDialog.h"
#include "EventRegEditCtl.h"
#include "ListFrame.h"
#include "ListFrameBaner.h"
#include "ListCwnd.h"
#include "ListViewEx.h"
#include "RegistrationList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define LISTFRAMELISTCHILD 2

/////////////////////////////////////////////////////////////////////////////
// CListCwnd

CListCwnd::CListCwnd()
{
}

CListCwnd::~CListCwnd()
{
}


BEGIN_MESSAGE_MAP(CListCwnd, CWnd)
	//{{AFX_MSG_MAP(CListCwnd)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CListCwnd message handlers

int CListCwnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO: Add your specialized creation code here
	m_pList = new CRegistrationList;

	if (!m_pList)
	{

		return -1;
	}

	m_pList->SetActiveXParent(m_pActiveXParent);

	GetClientRect(&m_crList);
	m_crList.DeflateRect(1,1);

	m_pList->Create
		(	NULL, _T("MyListView"),
			WS_CHILD | WS_VISIBLE | LVS_REPORT | LVS_OWNERDRAWFIXED
			| LVS_SHOWSELALWAYS,
			m_crList,
			this ,
			LISTFRAMELISTCHILD);


	return 0;
}

void CListCwnd::OnDestroy()
{
	CWnd::OnDestroy();

	// TODO: Add your message handler code here
	if (m_pList)
	{
		m_pList -> ClearContent();
		m_pList -> GetListCtrl().GetImageList(LVSIL_SMALL)->DeleteImageList();
		if (m_pList -> m_pcilImageList)
		{
			m_pList -> m_pcilImageList->DeleteImageList();
			delete 	m_pList -> m_pcilImageList;
		}

		delete m_pList;
		m_pList = NULL;
	}
}

void CListCwnd::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	// TODO: Add your message handler code here
	CRect rcFrame(m_crList);

	rcFrame.InflateRect(1,1,1,1);

	dc.Draw3dRect	(rcFrame.left,
					rcFrame.top,
					rcFrame.right,
					rcFrame.bottom,
					GetSysColor(COLOR_3DSHADOW),
					GetSysColor(COLOR_3DHILIGHT));

	/*if (m_pList->m_pActiveXParent->GetMode() == CEventRegEditCtrl::TIMERS ||
		m_pList->m_pActiveXParent->GetMode() == CEventRegEditCtrl::NONE)
	{
		m_pList->ShowWindow(SW_HIDE);
	}
	else
	{
		m_pList->ShowWindow(SW_SHOW);
	}*/

	// Do not call CWnd::OnPaint() for painting messages
}

void CListCwnd::InitContent(BOOL bUpdateInstances)
{
	m_pList->InitContent(bUpdateInstances);
}

void CListCwnd::ClearContent()
{
	m_pList->ClearContent();
}

void CListCwnd::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	// TODO: Add your message handler code here

	m_crList.left = 1;
	m_crList.top = 1;
	m_crList.bottom = cy - 1;
	m_crList.right = cx - 1;
	m_pList->MoveWindow(&m_crList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\listbannertoolbar.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_LISTBANNERTOOLBAR_H__14314524_4FC2_11D1_9659_00C04FD9B15B__INCLUDED_)
#define AFX_LISTBANNERTOOLBAR_H__14314524_4FC2_11D1_9659_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ListBannerToolbar.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CListBannerToolbar window

class CListBannerToolbar : public CToolBar
{
// Construction
public:
	CListBannerToolbar();
	CToolTipCtrl &GetToolTip() {return m_ttip;}
// Attributes
public:

// Operations
public:
	CSize GetToolBarSize();
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListBannerToolbar)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CListBannerToolbar();

	// Generated message map functions
protected:
	CToolTipCtrl m_ttip;
	//{{AFX_MSG(CListBannerToolbar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	afx_msg LRESULT InitTooltip(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LISTBANNERTOOLBAR_H__14314524_4FC2_11D1_9659_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\listframe.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ListFrame.cpp : implementation file
//

#include "precomp.h"
#include "wbemidl.h"
#include "MsgDlgExterns.h"
#include "util.h"
#include "resource.h"
#include "EventRegEdit.h"
#include "PropertiesDialog.h"
#include "EventRegEditCtl.h"
#include "ListFrame.h"
#include "ListFrameBaner.h"
#include "ListCwnd.h"
#include "ListViewEx.h"
#include "RegistrationList.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define LISTFRAMEBANNERCHILD 1
#define LISTFRAMETREECHILD 2

#define BANNERADDTOFONTHEIGHT 19

/////////////////////////////////////////////////////////////////////////////
// CListFrame

CListFrame::CListFrame()
{
}

CListFrame::~CListFrame()
{
}


BEGIN_MESSAGE_MAP(CListFrame, CWnd)
	//{{AFX_MSG_MAP(CListFrame)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CListFrame message handlers

int CListFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

		if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO: Add your specialized creation code here
	m_pBanner = new CListFrameBaner;

	if (!m_pBanner)
	{

		return -1;
	}

	m_pList = new CListCwnd;

	if (!m_pList)
	{

		return -1;
	}


	m_pList->SetActiveXParent(m_pActiveXParent);

	CRect rect;
	GetClientRect(&rect);

	SetChildControlGeometry(rect.Width(),rect.Height());

	m_pBanner->Create
		(	NULL,_T("ListFrameBanner"),WS_CHILD|WS_VISIBLE,
			m_crBanner,
			this,
			LISTFRAMEBANNERCHILD);

	m_pList->Create
		(	NULL, _T("MyListCwnd"),
			WS_CHILD|WS_VISIBLE,
			m_crList,
			this ,
			LISTFRAMETREECHILD);


	return 0;
}

void CListFrame::OnDestroy()
{
	CWnd::OnDestroy();

	// TODO: Add your message handler code here

	if (m_pBanner && m_pBanner->GetSafeHwnd())
	{
		m_pBanner->DestroyWindow();
		delete m_pBanner;
		m_pBanner = NULL;
	}
	else if (m_pBanner)
	{
		delete m_pBanner;
		m_pBanner = NULL;
	}

	if (m_pList && m_pList->GetSafeHwnd())
	{
		m_pList->DestroyWindow();
		delete m_pList;
		m_pList = NULL;
	}
	else if (m_pList)
	{
		delete m_pList;
		m_pList = NULL;
	}

}

void CListFrame::InitContent(BOOL bUpdateBanner, BOOL bUpdateInstances)
{
	if (bUpdateBanner)
	{
		m_pBanner->InitContent();
	}

	m_pList->InitContent(bUpdateInstances);

}

void CListFrame::ClearContent()
{
	m_pBanner->ClearContent();
	m_pList->ClearContent();
}

void CListFrame::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	// TODO: Add your message handler code here
	SetChildControlGeometry(cx,cy);
	m_pBanner->MoveWindow(m_crBanner);
	m_pList->MoveWindow(m_crList);
}

void CListFrame::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	// TODO: Add your message handler code here
	CRect rcFrame(m_crList);

	dc.Draw3dRect	(rcFrame.left,
					rcFrame.top,
					rcFrame.right,
					rcFrame.bottom,
					GetSysColor(COLOR_3DSHADOW),
					GetSysColor(COLOR_3DHILIGHT));

	m_pBanner->UpdateWindow();  // This is needed.
	m_pBanner->RedrawWindow();  // Ditto

	// Do not call CWnd::OnPaint() for painting messages
}

void CListFrame::SetChildControlGeometry(int cx, int cy)
{

	CRect rect;
	GetClientRect(&rect);

	m_crBanner = rect;
	m_crList = rect;
	int nBannerHeight = (m_pActiveXParent->m_tmFont.tmHeight) + BANNERADDTOFONTHEIGHT;

	if (m_crBanner.bottom - m_crBanner.top > nBannerHeight)
	{
		m_crBanner.bottom = nBannerHeight;
		m_crList.top = m_crBanner.bottom;
		m_crList.bottom = rect.bottom;
	}
	else
	{
		m_crBanner.bottom = m_crBanner.bottom - m_crBanner.top;
		m_crList.top = m_crBanner.bottom;
		m_crList.bottom = m_crBanner.bottom;
	}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\listcwnd.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_LISTCWND_H__14314523_4FC2_11D1_9659_00C04FD9B15B__INCLUDED_)
#define AFX_LISTCWND_H__14314523_4FC2_11D1_9659_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ListCwnd.h : header file
//
class CRegistrationList;
class CEventRegEditCtrl;
class CListFrame;
class CListFrameBaner;
/////////////////////////////////////////////////////////////////////////////
// CListCwnd window

class CListCwnd : public CWnd
{
// Construction
public:
	CListCwnd();

// Attributes
public:

// Operations
public:
	void InitContent(BOOL bUpdateInstances = TRUE);
	void ClearContent();
	void SetActiveXParent(CEventRegEditCtrl *pActiveXParent)
	{m_pActiveXParent = pActiveXParent;}
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListCwnd)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CListCwnd();

	// Generated message map functions
protected:
	CEventRegEditCtrl *m_pActiveXParent;
	CRegistrationList *m_pList;
	CRect m_crList;
	//{{AFX_MSG(CListCwnd)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	friend class CListFrameBaner;
	friend class CListFrame;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LISTCWND_H__14314523_4FC2_11D1_9659_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\listframe.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_LISTFRAME_H__14314521_4FC2_11D1_9659_00C04FD9B15B__INCLUDED_)
#define AFX_LISTFRAME_H__14314521_4FC2_11D1_9659_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ListFrame.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CListFrame window
class CEventRegEditCtrl;
class CListFrameBaner;
class CListCwnd;


class CListFrame : public CWnd
{
// Construction
public:
	CListFrame();
	void SetActiveXParent(CEventRegEditCtrl *pActiveXParent)
	{m_pActiveXParent = pActiveXParent;}
	void InitContent(BOOL bUpdateBanner = TRUE, BOOL bUpdateInstances = TRUE);
	void ClearContent();
// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListFrame)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CListFrame();

	// Generated message map functions
protected:
	int m_iMode;
	CEventRegEditCtrl *m_pActiveXParent;
	CListFrameBaner *m_pBanner;
	CListCwnd *m_pList;

	CRect m_crBanner;
	CRect m_crList;
	void SetChildControlGeometry(int cx, int cy);

	friend class CListFrameBaner;
	friend class CEventRegEditCtrl;
	//{{AFX_MSG(CListFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LISTFRAME_H__14314521_4FC2_11D1_9659_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\listframebaner.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_LISTFRAMEBANER_H__14314522_4FC2_11D1_9659_00C04FD9B15B__INCLUDED_)
#define AFX_LISTFRAMEBANER_H__14314522_4FC2_11D1_9659_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ListFrameBaner.h : header file
//
class CListBannerToolbar;
class CListFrameBannerStatic;
class CEventRegEditCtrl;
/////////////////////////////////////////////////////////////////////////////
// CListFrameBaner window

class CListFrameBaner : public CWnd
{
// Construction
public:
	CListFrameBaner();
	void InitContent();
	void ClearContent();
	void EnableButtons(BOOL bSelected, BOOL bUnselected);
	void SetPropertiesTooltip(CString &csTooltip);
// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListFrameBaner)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CListFrameBaner();

	// Generated message map functions
protected:
	void DrawFrame(CPaintDC* pdc);
	int m_iMode;
	CListBannerToolbar *m_pToolBar;
	CListFrameBannerStatic *m_pStatic;
	CSize GetTextExtent(CString *pcsText);
	void SetChildControlGeometry(int cx, int cy);
	CRect m_rToolBar;
	CRect m_rStatic;
	void SetTooltips();
	friend class CEventRegEditCtrl;
	//{{AFX_MSG(CListFrameBaner)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnButtonchecked();
	afx_msg void OnButtonlistprop();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LISTFRAMEBANER_H__14314522_4FC2_11D1_9659_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\listframebaner.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ListFrameBaner.cpp : implementation file
//

#include "precomp.h"
#include "Resource.h"
#include "wbemidl.h"
#include "MsgDlgExterns.h"
#include "util.h"
#include "resource.h"
#include "PropertiesDialog.h"
#include "EventRegEdit.h"
#include "EventRegEditCtl.h"
#include "ListFrame.h"
#include "ListFrameBaner.h"
#include "ListFrameBannerStatic.h"
#include "ListCwnd.h"
#include "ListBannerToolbar.h"
#include "ListViewEx.h"
#include "RegistrationList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define CX_TOOLBAR_MARGIN 7
#define CY_TOOLBAR_MARGIN 7
#define CX_TOOLBAR_OFFSET 3
#define CY_TOOLBAR_OFFSET 1

#define nSideMargin 0
#define nTopMargin 5
#define nTBTopMargin 7
/////////////////////////////////////////////////////////////////////////////
// CListFrameBaner

CListFrameBaner::CListFrameBaner()
{
	m_pStatic = NULL;
}

CListFrameBaner::~CListFrameBaner()
{
}


BEGIN_MESSAGE_MAP(CListFrameBaner, CWnd)
	//{{AFX_MSG_MAP(CListFrameBaner)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_COMMAND(ID_BUTTONCHECKED, OnButtonchecked)
	ON_COMMAND(ID_BUTTONLISTPROP, OnButtonlistprop)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CListFrameBaner message handlers

int CListFrameBaner::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO: Add your specialized creation code here

	CListFrame *pParent =
		reinterpret_cast<CListFrame *>(GetParent());
	CEventRegEditCtrl *pActiveXParent =
		pParent->m_pActiveXParent;
	pActiveXParent->m_pListFrameBanner = this;

	// TODO: Add your specialized creation code here
	m_pToolBar = new CListBannerToolbar;
	if(m_pToolBar->Create
		(this, WS_CHILD | WS_VISIBLE  | CBRS_SIZE_FIXED) == -1)
	{
		return FALSE;
	}

	m_pToolBar->LoadToolBar( MAKEINTRESOURCE(IDR_TOOLBARLISTFRAME) );

	int iButton = m_pToolBar->CommandToIndex(ID_BUTTONCHECKED);

	UINT uStyle = m_pToolBar->GetButtonStyle(iButton);

	m_pToolBar->SetButtonStyle(iButton, TBBS_CHECKBOX);

	uStyle = m_pToolBar->GetButtonStyle(iButton);

	int nState = m_pToolBar->GetToolBarCtrl().GetState(ID_BUTTONCHECKED);

	nState = nState & ~TBSTATE_CHECKED;

	m_pToolBar->GetToolBarCtrl().SetState
		(ID_BUTTONCHECKED, nState);

	nState =
		m_pToolBar->GetToolBarCtrl().GetState(ID_BUTTONCHECKED);

	m_pStatic = new CListFrameBannerStatic;

	if (m_pStatic->Create
		(WS_CHILD | WS_VISIBLE | ES_READONLY | ES_AUTOHSCROLL , m_rStatic, this, 1) == -1)
	{
		return FALSE;
	}

	return 0;
}

void CListFrameBaner::OnDestroy()
{
	CWnd::OnDestroy();

	// TODO: Add your message handler code here
	delete m_pToolBar;

	if (m_pStatic && m_pStatic->GetSafeHwnd())
	{
		m_pStatic->DestroyWindow();
	}

	delete m_pStatic;
}

void CListFrameBaner::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	// TODO: Add your message handler code here

	COLORREF dwBackColor = GetSysColor(COLOR_3DFACE);
	COLORREF crWhite = RGB(255,255,255);
	COLORREF crGray = GetSysColor(COLOR_3DHILIGHT);
	COLORREF crDkGray = GetSysColor(COLOR_3DSHADOW);
	COLORREF crBlack = GetSysColor(COLOR_WINDOWTEXT);


	CBrush br3DFACE(dwBackColor);
	dc.FillRect(&dc.m_ps.rcPaint, &br3DFACE);


	CListFrame *pParent =
		reinterpret_cast<CListFrame *>(GetParent());
	CEventRegEditCtrl *pActiveXParent =
		pParent->m_pActiveXParent;

	// Must do update to be able to over draw the border area.
	m_pToolBar->UpdateWindow();
	//pParent->m_pList->UpdateWindow();
	//pParent->m_pList->RedrawWindow();


	dc.SelectObject( &(pActiveXParent->m_cfFont) );

	dc.SetBkMode( TRANSPARENT );

	CRect crClip;
	CRgn crRegion;
	int nReturn = dc.GetClipBox( &crClip);

	crClip.DeflateRect(0,0,10,0);
	crRegion.CreateRectRgnIndirect( &crClip );
	dc.SelectClipRgn( &crRegion );


	if (m_iMode == CEventRegEditCtrl::CONSUMERS ||
		m_iMode == CEventRegEditCtrl::FILTERS)
	{
		CString csPath = pActiveXParent->GetTreeSelectionPath();
		int n = csPath.Find(TCHAR(':'));
		CString csRelPath = csPath.Right((csPath.GetLength() - n) - 1);
		CString csString = pActiveXParent->GetCurrentRegistrationString();
		CString csOut;
		if (csRelPath.GetLength() > 0)
		{
			csOut = csString + _T("  '") + csRelPath + _T("':");
		}
		else
		{
			csOut = _T("");
		}
		csOut = pActiveXParent->m_pList->DisplayName(csPath);
		//dc.TextOut( dc.m_ps.rcPaint.left + nSideMargin + 4, 7, csOut, csOut.GetLength() );
		m_pStatic->SetWindowText(csOut);
	}
	else
	{
		m_pStatic->SetWindowText(_T(""));
	}

	crRegion.DeleteObject( );

	dc.SetBkMode( OPAQUE );

	crClip.InflateRect(0,0,10,0);
	crRegion.CreateRectRgnIndirect( &crClip );
	dc.SelectClipRgn( &crRegion );

	DrawFrame(&dc);

	crRegion.DeleteObject( );

	// Do not call CWnd::OnPaint() for painting messages
}

void CListFrameBaner::DrawFrame(CPaintDC* pdc)
{

	CRect rcFrame(pdc->m_ps.rcPaint);
	rcFrame.DeflateRect(nSideMargin,nTopMargin);

	pdc->Draw3dRect(rcFrame.left,
					rcFrame.top - 2,
					rcFrame.right,
					rcFrame.bottom -2,
					GetSysColor(COLOR_3DSHADOW),
					GetSysColor(COLOR_3DHILIGHT));

}

void CListFrameBaner::InitContent()
{
	CListFrame *pParent =
		reinterpret_cast<CListFrame *>(GetParent());
	CEventRegEditCtrl *pActiveXParent =
		pParent->m_pActiveXParent;

	m_iMode = pActiveXParent->GetMode();

	UpdateWindow();
	RedrawWindow();
}

void CListFrameBaner::ClearContent()
{
	m_iMode = CEventRegEditCtrl::NONE;
	UpdateWindow();
	RedrawWindow();
}

void CListFrameBaner::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	// TODO: Add your message handler code here
	SetChildControlGeometry(cx, cy);
	m_pToolBar->MoveWindow( m_rToolBar);
	m_pStatic->MoveWindow(m_rStatic);
}

void CListFrameBaner::EnableButtons
(BOOL bSelected, BOOL bUnselected)
{
	CToolBarCtrl &rToolBarCtrl = m_pToolBar->GetToolBarCtrl();
	rToolBarCtrl.EnableButton(ID_BUTTONCHECKED,bSelected | bUnselected);

  	int nState = m_pToolBar->GetToolBarCtrl().GetState(ID_BUTTONCHECKED);

	if (bSelected)
	{
		nState = nState & ~TBSTATE_CHECKED;
		m_pToolBar->GetToolBarCtrl().SetState
		(ID_BUTTONCHECKED, nState);
	}
	else if (bUnselected)
	{
		nState = nState | TBSTATE_CHECKED;
		m_pToolBar->GetToolBarCtrl().SetState
		(ID_BUTTONCHECKED, nState);
	}
	else
	{
		nState = nState & ~TBSTATE_CHECKED;
		m_pToolBar->GetToolBarCtrl().SetState
		(ID_BUTTONCHECKED, nState);
	}

	SetTooltips();

	CListFrame *pParent =
		reinterpret_cast<CListFrame *>(GetParent());

	CRegistrationList *pList = pParent->m_pList->m_pList;

	UINT nSel = pList->GetListCtrl().GetSelectedCount();

	rToolBarCtrl.EnableButton(ID_BUTTONLISTPROP,nSel == 1? TRUE:FALSE);
}

void CListFrameBaner::SetChildControlGeometry(int cx, int cy)
{
	CSize csToolBar = m_pToolBar->GetToolBarSize();

	CRect rBannerRect = CRect(	0,
							0 + nTopMargin ,
							cx ,
							cy - nTopMargin);


	rBannerRect.NormalizeRect();

	int nModeX = 0;

	int nToolBarX = max(nModeX + 3,
						rBannerRect.TopLeft().x +
							rBannerRect.Width() - (csToolBar.cx + 5));

	int nNameSPaceXMax = nToolBarX - 2;

	#pragma warning( disable :4244 )
	int nToolBarY = rBannerRect.TopLeft().y +
					((rBannerRect.Height() - csToolBar.cy) * .5);
	#pragma warning( default : 4244 )

	m_rStatic = CRect(	nSideMargin + 4, 7,
							nNameSPaceXMax,
							rBannerRect.BottomRight().y + 0);


	m_rToolBar = CRect(nToolBarX,
				nToolBarY - nTBTopMargin,
				rBannerRect.BottomRight().x  + 1,
				nToolBarY + csToolBar.cy + nTopMargin);

	//nSideMargin + 4, 7
	//m_rStatic =
	//m_rStatic = CRect(nSideMargin + 4, 7 , nToolBarX - 4, m_rToolBar.bottom);
}

CSize CListFrameBaner::GetTextExtent(CString *pcsText)
{

	CListFrame *pParent =
		reinterpret_cast<CListFrame *>(GetParent());
	CEventRegEditCtrl *pActiveXParent =
		pParent->m_pActiveXParent;

	CSize csExt;

	CDC *pdc = CWnd::GetDC( );

	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont* pOldFont = pdc -> SelectObject( &(pActiveXParent -> m_cfFont) );
	csExt = pdc-> GetTextExtent( *pcsText );
	pdc -> SelectObject(pOldFont);

	ReleaseDC(pdc);
	return csExt;

}

void CListFrameBaner::OnButtonchecked()
{
	// TODO: Add your command handler code here
	CListFrame *pParent =
		reinterpret_cast<CListFrame *>(GetParent());

	CEventRegEditCtrl *pActiveXParent =
		pParent->m_pActiveXParent;

	CToolBarCtrl &rToolBarCtrl = m_pToolBar->GetToolBarCtrl();
	int nState =
		rToolBarCtrl.GetState(ID_BUTTONCHECKED);

	if ((nState & TBSTATE_CHECKED) == TBSTATE_CHECKED &&
		(nState & TBSTYLE_CHECK) == TBSTYLE_CHECK)
	{	// Register things
		pActiveXParent->m_pList->RegisterSelections();
	}
	else
	{	// Unregister things
		pActiveXParent->m_pList->UnregisterSelections();
	}

}



void CListFrameBaner::SetTooltips()
{
	CListFrame *pParent =
		reinterpret_cast<CListFrame *>(GetParent());

	CRegistrationList *pList = pParent->m_pList->m_pList;


	UINT nState =
		m_pToolBar->GetToolBarCtrl().GetState(ID_BUTTONCHECKED);

	CString csString;
	if (nState & TBSTATE_CHECKED)
	{
		csString = _T("Unregister");
	}
	else
	{
		csString = _T("Register");
	}

	CToolBarCtrl &rToolBarCtrl = m_pToolBar->GetToolBarCtrl();
	CSize csToolBar = m_pToolBar->GetToolBarSize();

#pragma warning( disable :4244 )
	CRect crToolBar(0,0,(int) csToolBar.cx * .5,csToolBar.cy);
#pragma warning( default : 4244 )

	m_pToolBar->GetToolTip().DelTool(&rToolBarCtrl,1);

	m_pToolBar->GetToolTip().AddTool
		(&rToolBarCtrl,csString,&crToolBar,1);

}

void CListFrameBaner::OnButtonlistprop()
{
	// TODO: Add your command handler code here

	CListFrame *pParent =
		reinterpret_cast<CListFrame *>(GetParent());

	CEventRegEditCtrl *pActiveXParent =
		pParent->m_pActiveXParent;

	CString csPath = pActiveXParent -> m_pList->GetSelectionPath();

	pActiveXParent->ButtonListProperties(&csPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\listframebannerstatic.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ListFrameBannerStatic.cpp : implementation file
//

#include "precomp.h"
#include "EventRegEdit.h"
#include "ListFrameBannerStatic.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CListFrameBannerStatic

CListFrameBannerStatic::CListFrameBannerStatic()
{
}

CListFrameBannerStatic::~CListFrameBannerStatic()
{
}


BEGIN_MESSAGE_MAP(CListFrameBannerStatic, CEdit)
	//{{AFX_MSG_MAP(CListFrameBannerStatic)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CListFrameBannerStatic message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\listviewex.cpp ===
// ListVwEx.cpp : implementation of the CListViewEx class

//

// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include "ListViewEx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CListViewEx

IMPLEMENT_DYNCREATE(CListViewEx, CListView)

BEGIN_MESSAGE_MAP(CListViewEx, CListView)
	//{{AFX_MSG_MAP(CListViewEx)
	ON_WM_SIZE()
	ON_WM_PAINT()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
	ON_MESSAGE(LVM_SETIMAGELIST, OnSetImageList)
	ON_MESSAGE(LVM_SETTEXTCOLOR, OnSetTextColor)
	ON_MESSAGE(LVM_SETTEXTBKCOLOR, OnSetTextBkColor)
	ON_MESSAGE(LVM_SETBKCOLOR, OnSetBkColor)
//	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK,  ColClick)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CListViewEx construction/destruction

CListViewEx::CListViewEx()
{
	m_bFullRowSel = FALSE;
	m_bClientWidthSel = TRUE;

	m_cxClient = 0;
	m_cxStateImageOffset = 0;

	m_clrText = ::GetSysColor(COLOR_WINDOWTEXT);
	m_clrTextBk = ::GetSysColor(COLOR_WINDOW);
	m_clrBkgnd = ::GetSysColor(COLOR_WINDOW);
}

CListViewEx::~CListViewEx()
{
}

BOOL CListViewEx::PreCreateWindow(CREATESTRUCT& cs)
{
	// default is report view and full row selection
	cs.style &= ~LVS_TYPEMASK;
	cs.style |= LVS_REPORT | LVS_OWNERDRAWFIXED;
	m_bFullRowSel = TRUE;

	return(CListView::PreCreateWindow(cs));
}

BOOL CListViewEx::SetFullRowSel(BOOL bFullRowSel)
{
	// no painting during change
	LockWindowUpdate();

	m_bFullRowSel = bFullRowSel;

	BOOL bRet;

	if (m_bFullRowSel)
		bRet = ModifyStyle(0L, LVS_OWNERDRAWFIXED);
	else
		bRet = ModifyStyle(LVS_OWNERDRAWFIXED, 0L);

	// repaint window if we are not changing view type
	if (bRet && (GetStyle() & LVS_TYPEMASK) == LVS_REPORT)
		Invalidate();

	// repaint changes
	UnlockWindowUpdate();

	return(bRet);
}

BOOL CListViewEx::GetFullRowSel()
{
	return(m_bFullRowSel);
}

/////////////////////////////////////////////////////////////////////////////
// CListViewEx drawing

// offsets for first and other columns
#define OFFSET_FIRST	2
#define OFFSET_OTHER	6

void CListViewEx::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	CListCtrl& ListCtrl=GetListCtrl();
	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
	CRect rcItem(lpDrawItemStruct->rcItem);
	UINT uiFlags = ILD_TRANSPARENT;
	CImageList* pImageList;
	int nItem = lpDrawItemStruct->itemID;
	CWnd *pFocus = GetFocus();
	BOOL bFocus = (pFocus == this);
	COLORREF clrTextSave, clrBkSave;
	COLORREF clrImage = m_clrBkgnd;
	static _TCHAR szBuff[(MAX_PATH * 2) + 5];
	LPCTSTR pszText;

// get item data

	LV_ITEM lvi;
	lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
	lvi.iItem = nItem;
	lvi.iSubItem = 0;
	lvi.pszText = szBuff;
	lvi.cchTextMax = sizeof((MAX_PATH * 2) + 4);
	lvi.stateMask = 0xFFFF;		// get all state flags
	ListCtrl.GetItem(&lvi);

	BOOL bSelected = (bFocus || (GetStyle() & LVS_SHOWSELALWAYS)) && lvi.state & LVIS_SELECTED;
	bSelected = bSelected || (lvi.state & LVIS_DROPHILITED);

// set colors if item is selected

	CRect rcAllLabels;
	ListCtrl.GetItemRect(nItem, rcAllLabels, LVIR_BOUNDS);

	CRect rcLabel;
	ListCtrl.GetItemRect(nItem, rcLabel, LVIR_LABEL);

	rcAllLabels.left = rcLabel.left;
	if (m_bClientWidthSel && rcAllLabels.right<m_cxClient)
		rcAllLabels.right = m_cxClient;

	if (bSelected)
	{
		clrTextSave = pDC->SetTextColor(::GetSysColor(COLOR_HIGHLIGHTTEXT));
		clrBkSave = pDC->SetBkColor(::GetSysColor(COLOR_HIGHLIGHT));

		pDC->FillRect(rcAllLabels, &CBrush(::GetSysColor(COLOR_HIGHLIGHT)));
	}
	else
		pDC->FillRect(rcAllLabels, &CBrush(m_clrTextBk));

// set color and mask for the icon

	if (lvi.state & LVIS_CUT)
	{
		clrImage = m_clrBkgnd;
		uiFlags |= ILD_BLEND50;
	}
	else if (bSelected)
	{
		clrImage = ::GetSysColor(COLOR_HIGHLIGHT);
		uiFlags |= ILD_BLEND50;
	}

// draw state icon

	UINT nStateImageMask = lvi.state & LVIS_STATEIMAGEMASK;
	if (nStateImageMask)
	{
		int nImage = (nStateImageMask>>12) - 1;
		pImageList = ListCtrl.GetImageList(LVSIL_STATE);
		if (pImageList)
		{
			pImageList->Draw(pDC, nImage,
				CPoint(rcItem.left, rcItem.top), ILD_TRANSPARENT);
		}
	}

// draw normal and overlay icon

	CRect rcIcon;
	ListCtrl.GetItemRect(nItem, rcIcon, LVIR_BOUNDS);

	pImageList = ListCtrl.GetImageList(LVSIL_SMALL);
	if (pImageList)
	{
		UINT nOvlImageMask=lvi.state & LVIS_OVERLAYMASK;
		if (rcItem.left<rcItem.right-1)
		{
#pragma warning( disable :4244 )
			int nColWidth = GetListCtrl().GetColumnWidth(0);
			int nLeft = (nColWidth - 16) / 2 ;
#pragma warning( default : 4244 )
			pDC->SetBkMode( TRANSPARENT );
			ImageList_DrawEx(pImageList->m_hImageList, lvi.iImage,
					pDC->m_hDC,rcIcon.left,rcIcon.top, 16, 16,
					m_clrBkgnd, clrImage, uiFlags | nOvlImageMask);
			pDC->SetBkMode( OPAQUE );
		}
	}

// draw item label

	ListCtrl.GetItemRect(nItem, rcItem, LVIR_LABEL);
	rcItem.right -= m_cxStateImageOffset;

	pszText = MakeShortString(pDC, szBuff,
				rcItem.right-rcItem.left, 2*OFFSET_FIRST);

	rcLabel = rcItem;
	rcLabel.left += OFFSET_FIRST;
	rcLabel.right -= OFFSET_FIRST;

	pDC->DrawText(pszText,-1,rcLabel,DT_LEFT | DT_SINGLELINE | DT_NOPREFIX | DT_NOCLIP | DT_VCENTER);

// draw labels for extra columns

	LV_COLUMN lvc;
	lvc.mask = LVCF_FMT | LVCF_WIDTH;

	for(int nColumn = 1; ListCtrl.GetColumn(nColumn, &lvc); nColumn++)
	{
		rcItem.left = rcItem.right;
		rcItem.right += lvc.cx;

		int nRetLen = ListCtrl.GetItemText(nItem, nColumn,
						szBuff, sizeof(szBuff));
		if (nRetLen == 0)
			continue;

		pszText = MakeShortString(pDC, szBuff,
			rcItem.right - rcItem.left, 2*OFFSET_OTHER);

		UINT nJustify = DT_LEFT;

		if(pszText == szBuff)
		{
			switch(lvc.fmt & LVCFMT_JUSTIFYMASK)
			{
			case LVCFMT_RIGHT:
				nJustify = DT_RIGHT;
				break;
			case LVCFMT_CENTER:
				nJustify = DT_CENTER;
				break;
			default:
				break;
			}
		}

		rcLabel = rcItem;
		rcLabel.left += OFFSET_OTHER;
		rcLabel.right -= OFFSET_OTHER;

		pDC->DrawText(pszText, -1, rcLabel,
			nJustify | DT_SINGLELINE | DT_NOPREFIX | DT_NOCLIP | DT_VCENTER);
	}

// draw focus rectangle if item has focus

	if (lvi.state & LVIS_FOCUSED && bFocus)
		pDC->DrawFocusRect(rcAllLabels);

// set original colors if item was selected

	if (bSelected)
	{
        pDC->SetTextColor(clrTextSave);
		pDC->SetBkColor(clrBkSave);
	}
}

LPCTSTR CListViewEx::MakeShortString(CDC* pDC, LPCTSTR lpszLong, int nColumnLen, int nOffset)
{
	static const _TCHAR szThreeDots[] = _T("...");

	int nStringLen = lstrlen(lpszLong);

	if(nStringLen == 0 ||
		(pDC->GetTextExtent(lpszLong, nStringLen).cx + nOffset) <= nColumnLen)
	{
		return(lpszLong);
	}

	static _TCHAR szShort[(MAX_PATH * 2) + 4];

	lstrcpy(szShort,lpszLong);
	int nAddLen = pDC->GetTextExtent(szThreeDots,sizeof(szThreeDots)).cx;

	for(int i = nStringLen-1; i > 0; i--)
	{
		szShort[i] = 0;
		if((pDC->GetTextExtent(szShort, i).cx + nOffset + nAddLen)
			<= nColumnLen)
		{
			break;
		}
	}

	lstrcat(szShort, szThreeDots);
	return(szShort);
}

void CListViewEx::RepaintSelectedItems()
{
	CListCtrl& ListCtrl = GetListCtrl();
	CRect rcItem, rcLabel;

// invalidate focused item so it can repaint properly

	int nItem = ListCtrl.GetNextItem(-1, LVNI_FOCUSED);

	if(nItem != -1)
	{
		ListCtrl.GetItemRect(nItem, rcItem, LVIR_BOUNDS);
		ListCtrl.GetItemRect(nItem, rcLabel, LVIR_LABEL);
		rcItem.left = rcLabel.left;

		InvalidateRect(rcItem, FALSE);
	}

// if selected items should not be preserved, invalidate them

	if(!(GetStyle() & LVS_SHOWSELALWAYS))
	{
		for(nItem = ListCtrl.GetNextItem(-1, LVNI_SELECTED);
			nItem != -1; nItem = ListCtrl.GetNextItem(nItem, LVNI_SELECTED))
		{
			ListCtrl.GetItemRect(nItem, rcItem, LVIR_BOUNDS);
			ListCtrl.GetItemRect(nItem, rcLabel, LVIR_LABEL);
			rcItem.left = rcLabel.left;

			InvalidateRect(rcItem, FALSE);
		}
	}

// update changes

	UpdateWindow();
}

/////////////////////////////////////////////////////////////////////////////
// CListViewEx diagnostics

#ifdef _DEBUG

void CListViewEx::Dump(CDumpContext& dc) const
{
	CListView::Dump(dc);

	dc << "m_bFullRowSel = " << (UINT)m_bFullRowSel;
	dc << "\n";
	dc << "m_cxStateImageOffset = " << m_cxStateImageOffset;
	dc << "\n";
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CListViewEx message handlers

LRESULT CListViewEx::OnSetImageList(WPARAM wParam, LPARAM lParam)
{
	if( (int) wParam == LVSIL_STATE)
	{
		int cx, cy;

		if(::ImageList_GetIconSize((HIMAGELIST)lParam, &cx, &cy))
			m_cxStateImageOffset = cx;
		else
			m_cxStateImageOffset = 0;
	}

	return(Default());
}

LRESULT CListViewEx::OnSetTextColor(WPARAM wParam, LPARAM lParam)
{
	m_clrText = (COLORREF)lParam;
	return(Default());
}

LRESULT CListViewEx::OnSetTextBkColor(WPARAM wParam, LPARAM lParam)
{
	m_clrTextBk = (COLORREF)lParam;
	return(Default());
}

LRESULT CListViewEx::OnSetBkColor(WPARAM wParam, LPARAM lParam)
{
	m_clrBkgnd = (COLORREF)lParam;
	return(Default());
}

void CListViewEx::OnSize(UINT nType, int cx, int cy)
{
	m_cxClient = cx;
	CListView::OnSize(nType, cx, cy);
}

void CListViewEx::OnPaint()
{
	// in full row select mode, we need to extend the clipping region
	// so we can paint a selection all the way to the right
	if (m_bClientWidthSel &&
		(GetStyle() & LVS_TYPEMASK) == LVS_REPORT &&
		GetFullRowSel())
	{
		CRect rcAllLabels;
		GetListCtrl().GetItemRect(0, rcAllLabels, LVIR_BOUNDS);

		if(rcAllLabels.right < m_cxClient)
		{
			// need to call BeginPaint (in CPaintDC c-tor)
			// to get correct clipping rect
			CPaintDC dc(this);

			CRect rcClip;
			dc.GetClipBox(rcClip);

			rcClip.left = min(rcAllLabels.right-1, rcClip.left);
			rcClip.right = m_cxClient;

			InvalidateRect(rcClip, FALSE);
			// EndPaint will be called in CPaintDC d-tor
		}
	}

	CListView::OnPaint();
}

void CListViewEx::OnSetFocus(CWnd* pOldWnd)
{
	CListView::OnSetFocus(pOldWnd);

	// check if we are getting focus from label edit box
	if(pOldWnd!=NULL && pOldWnd->GetParent()==this)
		return;

	// repaint items that should change appearance
	if(m_bFullRowSel && (GetStyle() & LVS_TYPEMASK)==LVS_REPORT)
		RepaintSelectedItems();
}

void CListViewEx::OnKillFocus(CWnd* pNewWnd)
{
	CListView::OnKillFocus(pNewWnd);

	// check if we are losing focus to label edit box
	if(pNewWnd != NULL && pNewWnd->GetParent() == this)
		return;

	// repaint items that should change appearance
	if(m_bFullRowSel && (GetStyle() & LVS_TYPEMASK) == LVS_REPORT)
		RepaintSelectedItems();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\listframebannerstatic.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_LISTFRAMEBANNERSTATIC_H__D67735F1_4FEE_11D1_9659_00C04FD9B15B__INCLUDED_)
#define AFX_LISTFRAMEBANNERSTATIC_H__D67735F1_4FEE_11D1_9659_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ListFrameBannerStatic.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CListFrameBannerStatic window

class CListFrameBannerStatic : public CEdit
{
// Construction
public:
	CListFrameBannerStatic();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListFrameBannerStatic)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CListFrameBannerStatic();

	// Generated message map functions
protected:
	//{{AFX_MSG(CListFrameBannerStatic)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LISTFRAMEBANNERSTATIC_H__D67735F1_4FEE_11D1_9659_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\nsentry.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "nsentry.h"

/////////////////////////////////////////////////////////////////////////////
// CNSEntry

IMPLEMENT_DYNCREATE(CNSEntry, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CNSEntry properties

CString CNSEntry::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CNSEntry::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CNSEntry operations

long CNSEntry::OpenNamespace(LPCTSTR bstrNamespace, long longNoFireEvent)
{
	SCODE result;
	static BYTE parms[] =
		VTS_BSTR VTS_I4;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		bstrNamespace, longNoFireEvent);
	return result;
}

void CNSEntry::SetNamespaceText(LPCTSTR lpctstrNamespace)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace);
}

CString CNSEntry::GetNamespaceText()
{
	CString result;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_BSTR, (void*)&result, NULL);
	return result;
}

long CNSEntry::IsTextValid()
{
	long result;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CNSEntry::ClearOnLoseFocus(long lClearOnLoseFocus)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lClearOnLoseFocus);
}

void CNSEntry::ClearNamespaceText(LPCTSTR lpctstrNamespace)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace);
}

void CNSEntry::SetFocusToEdit()
{
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CNSEntry::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\listviewex.h ===
// ListVwEx.h : interface of the CListViewEx class

//

// This class provedes a full row selection mode for the report

// mode list view control.

//

// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CListViewEx : public CListView
{
	DECLARE_DYNCREATE(CListViewEx)

// Construction
public:
	CListViewEx();

// Attributes
protected:
	BOOL m_bFullRowSel;

public:
	BOOL SetFullRowSel(BOOL bFillRowSel);
	BOOL GetFullRowSel();

	BOOL m_bClientWidthSel;

// Overrides
protected:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListViewEx)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CListViewEx();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	static LPCTSTR MakeShortString(CDC* pDC, LPCTSTR lpszLong, int nColumnLen, int nOffset);
	void RepaintSelectedItems();

// Implementation - client area width
	int m_cxClient;

// Implementation - state icon width
	int m_cxStateImageOffset;
	afx_msg LRESULT OnSetImageList(WPARAM wParam, LPARAM lParam);

// Implementation - list view colors
	COLORREF m_clrText;
	COLORREF m_clrTextBk;
	COLORREF m_clrBkgnd;
	afx_msg LRESULT OnSetTextColor(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSetTextBkColor(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSetBkColor(WPARAM wParam, LPARAM lParam);

// Generated message map functions
protected:
	//{{AFX_MSG(CListViewEx)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG
//	afx_msg void ColClick ( NMHDR * pNotifyStruct, LRESULT* result );

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\nsentry.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_NSENTRY_H__83B97A52_9E98_11D1_9671_00C04FD9B15B__INCLUDED_)
#define AFX_NSENTRY_H__83B97A52_9E98_11D1_9671_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CNSEntry wrapper class

class CNSEntry : public CWnd
{
protected:
	DECLARE_DYNCREATE(CNSEntry)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xc3db0bd3, 0x7ec7, 0x11d0, { 0x96, 0xb, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);

// Operations
public:
	long OpenNamespace(LPCTSTR bstrNamespace, long longNoFireEvent);
	void SetNamespaceText(LPCTSTR lpctstrNamespace);
	void ClearOnLoseFocus(long lClearOnLoseFocus);
	void ClearNamespaceText(LPCTSTR lpctstrNamespace);
	void SetFocusToEdit();
	CString GetNamespaceText();
	long IsTextValid();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NSENTRY_H__83B97A52_9E98_11D1_9671_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_STDAFX_H__0DA25B09_2962_11D1_9651_00C04FD9B15B__INCLUDED_)
#define AFX_STDAFX_H__0DA25B09_2962_11D1_9651_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#include <afxcview.h>

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxcmn.h>
// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0DA25B09_2962_11D1_9651_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\propertiesdialog.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// PropertiesDialog.cpp : implementation file
//

#include "precomp.h"
#include "wbemidl.h"
#include "util.h"
#include "EventRegEdit.h"
#include "resource.h"
#include "PropertiesDialog.h"
#include "EventRegEdit.h"
#include "EventRegEditCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum {EDITMODE_BROWSER=0, EDITMODE_STUDIO=1, EDITMODE_READONLY=2};

/////////////////////////////////////////////////////////////////////////////
// CPropertiesDialog dialog


CPropertiesDialog::CPropertiesDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CPropertiesDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPropertiesDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_bViewOnly = FALSE;
}


void CPropertiesDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropertiesDialog)
	DDX_Control(pDX, IDCANCEL, m_cbCancel);
	DDX_Control(pDX, IDOK, m_cbOK);
	DDX_Control(pDX, IDC_SINGLEVIEWCTRL1, m_csvProperties);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropertiesDialog, CDialog)
	//{{AFX_MSG_MAP(CPropertiesDialog)
	ON_WM_SIZE()
	ON_WM_MOVE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropertiesDialog message handlers

BOOL CPropertiesDialog::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO: Add extra initialization here

	if (m_bClass)
	{
		m_csvProperties.SetEditMode(EDITMODE_BROWSER);
		m_cbOK.ShowWindow(SW_HIDE);
	}
	else
	{
		if (m_bViewOnly == FALSE)
		{
			m_csvProperties.SetEditMode(EDITMODE_STUDIO);
			m_cbOK.ShowWindow(SW_SHOW);
		}
		else
		{
			m_csvProperties.SetEditMode(EDITMODE_BROWSER);
			m_cbOK.ShowWindow(SW_HIDE);
		}

	}

	m_csvProperties.m_pActiveXParent = m_pActiveXParent;

	CString csNamespace = m_pActiveXParent->GetServiceNamespace();
	m_csvProperties.SetNameSpace(csNamespace);

	if (m_bClass || !m_bNew || m_bViewOnly)
	{
		m_csvProperties.SelectObjectByPath(m_csPath);
	}
	else
	{
		m_csvProperties.CreateInstance(m_csClass);
	}

	CString csTitle;

	if (m_bClass && !m_bNew)
	{
		csTitle = _T("View class properties: ") + m_csPath;
	}
	else if (m_bNew && !m_bViewOnly)
	{
		csTitle = _T("Edit new instance properties") ;
	}
	else if (!m_bNew && !m_bViewOnly)
	{
		csTitle = _T("Edit instance properties : ")  + m_csPath;
	}
	else if (m_bViewOnly)
	{
		csTitle = _T("View instance properties: ") + m_csPath;
	}

	SetWindowText(csTitle);

	CacheWindowPositions();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPropertiesDialog::OnOK()
{
	// TODO: Add extra validation here

	SCODE sc = S_OK;

	if (m_cbOK.IsWindowVisible())
	{
		sc = m_csvProperties.SaveData();
	}

	if (sc == S_OK)
	{
		CDialog::OnOK();
	}
}

void CPropertiesDialog::OnSize(UINT nType, int cx, int cy)
{
	CDialog::OnSize(nType, cx, cy);

	// TODO: Add your message handler code here
	if (m_cbOK.GetSafeHwnd())
	{
		CRect crWindow;
		GetClientRect(&crWindow);

		CRect crSingleViewNew;
		crSingleViewNew.left = crWindow.left + m_nSingleViewX;
		crSingleViewNew.top = crWindow.top + m_nSingleViewY;
		crSingleViewNew.bottom = crWindow.bottom - m_nSingleViewYDelta;
		crSingleViewNew.right = crWindow.right - m_nSingleViewXDelta;
		m_csvProperties.MoveWindow(&crSingleViewNew,TRUE);


		CRect crOK;
		CRect crOKNew;
		m_cbOK.GetClientRect(&crOK);
		crOKNew.left = crWindow.right - m_nOKButtonXDelta;
		crOKNew.right = crOKNew.left + crOK.Width();
		crOKNew.top = crWindow.bottom - m_nButtonsYDelta;
		crOKNew.bottom = crOKNew.top + crOK.Height();
		m_cbOK.MoveWindow(&crOKNew,TRUE);
		m_cbOK.RedrawWindow();
		m_cbOK.UpdateWindow();

		CRect crCancel;
		CRect crCancelNew;
		m_cbCancel.GetClientRect(crCancel);
		crCancelNew.left = crWindow.right - m_nCancelButtonXDelta;
		crCancelNew.right = crCancelNew.left + crCancel.Width();
		crCancelNew.top = crWindow.bottom - m_nButtonsYDelta;
		crCancelNew.bottom = crCancelNew.top + crCancel.Height();
		m_cbCancel.MoveWindow(crCancelNew,TRUE);
		m_cbCancel.RedrawWindow();
		m_cbCancel.UpdateWindow();
	}
}

void CPropertiesDialog::OnMove(int x, int y)
{
	CDialog::OnMove(x, y);

}

void CPropertiesDialog::CacheWindowPositions()
{
	CRect crWindow;
	GetClientRect(&crWindow);
	ClientToScreen(&crWindow);

	CRect crSingleView;
	m_csvProperties.GetWindowRect(&crSingleView);

	CRect crOK;
	m_cbOK.GetWindowRect(&crOK);

	CRect crCancel;
	m_cbCancel.GetWindowRect(crCancel);

	m_nButtonsYDelta = crWindow.bottom - crOK.top;
	m_nOKButtonXDelta = crWindow.right - crOK.left;
	m_nCancelButtonXDelta = crWindow.right - crCancel.left;
	m_nSingleViewX =  crSingleView.left - crWindow.left;
	m_nSingleViewY = crSingleView.top - crWindow.top ;
	m_nSingleViewXDelta = crWindow.right - crSingleView.right;
	m_nSingleViewYDelta = crWindow.bottom - crSingleView.bottom;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\regeditnavnsentry.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved


#include "precomp.h"
#include "wbemidl.h"
#include "MsgDlgExterns.h"
#include "util.h"
#include "resource.h"
#include "PropertiesDialog.h"
#include "EventRegEdit.h"
#include "EventRegEditCtl.h"
#include "TreeFrameBanner.h"
#include "nsentry.h"
#include "RegEditNavNSEntry.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegEditNSEntry

IMPLEMENT_DYNCREATE(CRegEditNSEntry,CNSEntry)

CRegEditNSEntry::CRegEditNSEntry()
{



}

BEGIN_MESSAGE_MAP(CRegEditNSEntry, CNSEntry)
	//{{AFX_MSG_MAP(CRegEditNSEntry)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BEGIN_EVENTSINK_MAP(CRegEditNSEntry, CNSEntry)
    //{{AFX_EVENTSINK_MAP(CRegEditNSEntry)
	//}}AFX_EVENTSINK_MAP
	ON_EVENT_REFLECT(CRegEditNSEntry,1,OnNameSpaceChanged,VTS_BSTR VTS_BOOL)
	ON_EVENT_REFLECT(CRegEditNSEntry,2,OnNameSpaceRedrawn,VTS_NONE)
	ON_EVENT_REFLECT(CRegEditNSEntry,3,OnGetIWbemServices,VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	ON_EVENT_REFLECT(CRegEditNSEntry,4,OnRequestUIActive,VTS_NONE)
	ON_EVENT_REFLECT(CRegEditNSEntry,5,OnChangeFocus,VTS_I4)
END_EVENTSINK_MAP()

void CRegEditNSEntry::OnChangeFocus(long lGettingFocus)
{
	m_pParent->m_bRestoreFocusToTree = FALSE;
	m_pParent->m_bRestoreFocusToCombo = FALSE;
	m_pParent->m_bRestoreFocusToNamespace = TRUE;
	m_pParent->m_bRestoreFocusToList = FALSE;
}

void CRegEditNSEntry::OnNameSpaceChanged(LPCTSTR bstrNewNameSpace, BOOL boolValid)
{
	// TODO: Add your control notification handler code here
	if (!boolValid)
	{
		m_pParent->InvalidateControl();
		return;
	}

	CString csNameSpace = bstrNewNameSpace;
	m_pParent->SetNameSpace(csNameSpace);
	m_pParent->InvalidateControl();
}


void CRegEditNSEntry::OnNameSpaceRedrawn()
{

	m_pParent->m_pTreeFrameBanner->Invalidate();
	m_pParent->InvalidateControl();
}

void CRegEditNSEntry::OnRequestUIActive()
{
	m_pParent->OnActivateInPlace(TRUE,NULL);
}

void CRegEditNSEntry::OnGetIWbemServices
(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
	m_pParent->PassThroughGetIWbemServices
		(lpctstrNamespace,
		pvarUpdatePointer,
		pvarServices,
		pvarSC,
		pvarUserCancel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\propertiesdialog.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{AFX_INCLUDES()
#include "singleview.h"
//}}AFX_INCLUDES
#if !defined(AFX_PROPERTIESDIALOG_H__BB09DCE1_4A39_11D1_9658_00C04FD9B15B__INCLUDED_)
#define AFX_PROPERTIESDIALOG_H__BB09DCE1_4A39_11D1_9658_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PropertiesDialog.h : header file
//

struct IWbemClassObject;
class CEventRegEditCtrl;
/////////////////////////////////////////////////////////////////////////////
// CPropertiesDialog dialog

class CPropertiesDialog : public CDialog
{
// Construction
public:
	CPropertiesDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPropertiesDialog)
	enum { IDD = IDD_DIALOGPROPERTIES };
	CButton	m_cbCancel;
	CButton	m_cbOK;
	CSingleView	m_csvProperties;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropertiesDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CString m_csClass;
	CString m_csPath;
	BOOL m_bClass;
	BOOL m_bNew;
	BOOL m_bViewOnly;
	CEventRegEditCtrl *m_pActiveXParent;

	int m_nButtonsYDelta;
	int m_nOKButtonXDelta;
	int m_nCancelButtonXDelta;
	int m_nSingleViewX;
	int m_nSingleViewY;
	int m_nSingleViewXDelta;
	int m_nSingleViewYDelta;

	void CacheWindowPositions();

	// Generated message map functions
	//{{AFX_MSG(CPropertiesDialog)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnMove(int x, int y);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	friend class CEventRegEditCtrl;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPERTIESDIALOG_H__BB09DCE1_4A39_11D1_9658_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\regeditnavnsentry.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __CLASSNAVNSENTRY_H__
#define __CLASSNAVNSENTRY_H__

class CEventRegEditCtrl;

class CRegEditNSEntry : public CNSEntry
{
protected:
	DECLARE_DYNCREATE(CRegEditNSEntry)


	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRegEditNSEntry)
	protected:
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CRegEditNSEntry)
			afx_msg void OnNameSpaceChanged(LPCTSTR bstrNewNameSpace, BOOL boolValid);
			afx_msg void OnNameSpaceRedrawn() ;
			afx_msg void OnGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel) ;
			afx_msg void OnRequestUIActive() ;
			afx_msg void OnChangeFocus(long lGettingFocus);
		//}}AFX_MSG
	
	DECLARE_EVENTSINK_MAP()
	DECLARE_MESSAGE_MAP()

public:
	CRegEditNSEntry();
	void SetLocalParent(CEventRegEditCtrl* pParent) 
		{	m_pParent = pParent;
		}
protected:
	CEventRegEditCtrl* m_pParent;
};

#endif // __CLASSNAVNSENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\registrationlist.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// RegistrationList.cpp : implementation file
//

#include "precomp.h"
#include <OBJIDL.H>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include "wbemidl.h"
#include "util.h"
#include "resource.h"
#include "PropertiesDialog.h"
#include "EventRegEdit.h"
#include "EventRegEditCtl.h"
#include "ClassInstanceTree.h"
#include "ListFrame.h"
#include "ListFrameBaner.h"
#include "ListViewEx.h"
#include "RegistrationList.h"
#include "logindlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CEventRegEditApp theApp;




int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2,
    LPARAM lParamSort)
{
	DWORD dw = (DWORD) lParamSort;

	UINT nSort = LOWORD(dw);
	UINT nSortState = HIWORD(dw);

	CString *pcsParam1 = reinterpret_cast<CString *>(lParam1);
	CString *pcsParam2 = reinterpret_cast<CString *>(lParam2);

	CString csParam1 = pcsParam1->Mid(1);
	CString csParam2 = pcsParam2->Mid(1);

	if (nSort == CRegistrationList::SORTCLASS)
	{
		if (nSortState == CRegistrationList::SORTASCENDING)
		{
			return csParam1.CompareNoCase(csParam2);
		}
		else
		{
			return csParam2.CompareNoCase(csParam1);
		}
	}
	else if (nSort == CRegistrationList::SORTNAME)
	{
		CString csName1 = CRegistrationList::DisplayName(csParam1);
		CString csName2 = CRegistrationList::DisplayName(csParam2);

		if (nSortState == CRegistrationList::SORTASCENDING)
		{
			return csName1.CompareNoCase(csName2);
		}
		else
		{
			return csName2.CompareNoCase(csName1);
		}
	}
	else
	{
		if (nSortState == CRegistrationList::SORTASCENDING)
		{
			return pcsParam1->CompareNoCase(*pcsParam2);
		}
		else
		{
			return pcsParam2->CompareNoCase(*pcsParam1);
		}

	}
}

/////////////////////////////////////////////////////////////////////////////
// CRegistrationList

CRegistrationList::CRegistrationList()
{
	m_pcilImageList = NULL;
	m_nSort = SORTCLASS;
	m_nSortRegistered = SORTUNITIALIZED;
	m_nSortClass = SORTUNITIALIZED;
	m_nSortName = SORTUNITIALIZED;

}

CRegistrationList::~CRegistrationList()
{
}

BEGIN_MESSAGE_MAP(CRegistrationList, CListViewEx)
	//{{AFX_MSG_MAP(CRegistrationList)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_CONTEXTMENU()
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP

	ON_NOTIFY_REFLECT(LVN_ITEMCHANGED, OnItemchanged)
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK,  ColClick)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRegistrationList message handlers

void CRegistrationList::InitContent(BOOL bUpdateInstances)
{
	if (!bUpdateInstances &&
		(m_pActiveXParent->GetMode() != CEventRegEditCtrl::TIMERS &&
		 m_pActiveXParent->GetMode() != CEventRegEditCtrl::NONE) &&
		 !m_pActiveXParent->IsClassSelected())
	{
		ResetChecks();
		SetButtonState();
		return;
	}

	ClearContent();

	if (m_pActiveXParent->GetMode() == CEventRegEditCtrl::TIMERS ||
		m_pActiveXParent->GetMode() == CEventRegEditCtrl::NONE)
	{
		SetColText(TRUE);
		return;
	}

	m_pActiveXParent->m_pListFrameBanner->EnableButtons(FALSE,FALSE);

	if (m_pActiveXParent->IsClassSelected())
	{
		SetColText(TRUE);
		return;
	}

	SetColText(FALSE);

	int i = 0;
	CString csReg;
	CString csClass;
	CString csName;

	CString csPath =
		m_pActiveXParent->GetTreeSelectionPath();

	int n = csPath.Find(TCHAR(':'));
	CString csRelPath = csPath.Right((csPath.GetLength() - n) - 1);

	BOOL bFilters =
		m_pActiveXParent->GetMode() == CEventRegEditCtrl::FILTERS;


	CString csTarget = csPath;
	CString csTargetRole = bFilters ? _T("Filter") : _T("Consumer");
	CString csResultClass  = bFilters ?
		m_pActiveXParent->m_csRootConsumerClass : m_pActiveXParent->m_csRootFilterClass;
	CString csResultRole  = bFilters ? _T("Consumer") : _T("Filter");
	CString csAssocClass = _T("__FilterToConsumerBinding");

	CStringArray *pcsaAssociators =
		GetAssociators
		(csTarget, csTargetRole, csResultClass, csAssocClass, csResultRole);

	if (!pcsaAssociators)
	{
		BSTR bstrTemp = csTarget.AllocSysString();
		 IWbemClassObject *pInstance = NULL;
		SCODE sc = m_pActiveXParent->GetServices() -> GetObject
			(bstrTemp,0,NULL, &pInstance,NULL);
		::SysFreeString(bstrTemp);
		if (sc == S_OK)
		{
			pInstance->Release();
		}
		else
		{
			m_pActiveXParent->m_pTree->DeleteTreeInstanceItem
				(m_pActiveXParent->m_pTree->GetSelectedItem(),TRUE);

		}
		return;
	}

	CPtrArray cpaInstances;

	SCODE hResult =
		GetInstances(m_pActiveXParent->GetServices(), &csResultClass,
					cpaInstances, TRUE);

	for (i = 0; i < cpaInstances.GetSize(); i++)
	{
		IWbemClassObject *pObject =
			reinterpret_cast<IWbemClassObject *>(cpaInstances.GetAt(i));
		CString csPath =
			GetIWbemFullPath(pObject);
		CString csDisplayName = DisplayName(csPath);
		CString csClass = GetIWbemClass(pObject);
		int n =
			StringInArray
				(pcsaAssociators, &csPath, 0);

		CString *pcsPath = new CString;
		if (n >= 0)
		{
			*pcsPath = _T("R") + csPath;
			InsertRowData
				(i, TRUE, csClass, csDisplayName , pcsPath);
		}
		else
		{
			*pcsPath = _T("U") + csPath;
			InsertRowData
				(i, FALSE, csClass, csDisplayName , pcsPath);
		}
		pObject -> Release();
	}

	DoSort(FALSE);

	delete pcsaAssociators;
}

void CRegistrationList::ResetChecks()
{

	m_pActiveXParent->m_pListFrameBanner->EnableButtons(FALSE,FALSE);

	int i = 0;
	CString csReg;
	CString csClass;
	CString csName;

	CString csPath =
		m_pActiveXParent->GetTreeSelectionPath();

	int n = csPath.Find(TCHAR(':'));
	CString csRelPath = csPath.Right((csPath.GetLength() - n) - 1);

	BOOL bFilters =
		m_pActiveXParent->GetMode() == CEventRegEditCtrl::FILTERS;

	CString csTarget = csPath;
	CString csTargetRole = bFilters ? _T("Filter") : _T("Consumer");
	CString csResultClass  = bFilters ?
		m_pActiveXParent->m_csRootConsumerClass : m_pActiveXParent->m_csRootFilterClass;
	CString csResultRole  = bFilters ? _T("Consumer") : _T("Filter");
	CString csAssocClass = _T("__FilterToConsumerBinding");

	CStringArray *pcsaAssociators =
		GetAssociators
		(csTarget, csTargetRole, csResultClass, csAssocClass, csResultRole);


	if (pcsaAssociators)
	{
		for (i = 0; i < GetListCtrl().GetItemCount(); i++)
		{
			CString *pcsPath =
				reinterpret_cast<CString *>(GetListCtrl().GetItemData(i));

			csPath = pcsPath->Mid(1);

			int n =
				StringInArray
					(pcsaAssociators, &csPath, 0);

			if (n >= 0)
			{
				pcsPath->SetAt(0,'R');
				SetIconState(i, TRUE);
			}
			else
			{
				pcsPath->SetAt(0,'U');
				SetIconState(i, FALSE);
			}

		}
	}
	else
	{
		BSTR bstrTemp = csTarget.AllocSysString();
		IWbemClassObject *pInstance = NULL;
		SCODE sc = m_pActiveXParent->GetServices() -> GetObject
			(bstrTemp,0,NULL, &pInstance,NULL);
		::SysFreeString(bstrTemp);
		if (sc == S_OK)
		{
			pInstance->Release();
		}
		else
		{
			m_pActiveXParent->m_pTree->DeleteTreeInstanceItem
				(m_pActiveXParent->m_pTree->GetSelectedItem(),TRUE);

		}
		return;
	}

	GetListCtrl().UpdateWindow();
	delete pcsaAssociators;
}


void CRegistrationList::ClearContent()
{
	SetColText(TRUE);
	DeleteFromEnd(0,TRUE);
}

void CRegistrationList::SetActiveXParent(CEventRegEditCtrl *pActiveXParent)
{
	m_pActiveXParent = pActiveXParent;
	pActiveXParent->m_pList = this;
}

/*void CRegistrationList::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);

	COLORREF cr = (COLORREF)RGB(255, 255, 255);

	RECT rectFill = lpDIS->rcItem;
	rectFill.bottom += 0;

	if (lpDIS->itemID == -1)
	{
		return;
	}

	BOOL bDrawEntireAction = lpDIS->itemAction & ODA_DRAWENTIRE;
	BOOL bSelectAction = lpDIS->itemAction & ODA_SELECT;
	BOOL bFocusAction = lpDIS->itemAction & ODA_FOCUS;
	BOOL bSelectItem = lpDIS->itemState & ODS_SELECTED;
	BOOL bFocusItem = lpDIS->itemState & ODS_FOCUS;

	if (bDrawEntireAction)
	{
		DrawRowItems
			(lpDIS->itemID, rectFill,pDC);
	}

	if ((bSelectAction | bDrawEntireAction) && bSelectItem)
	{
		// item has been selected - hilite frame
		COLORREF crHilite = GetSysColor(COLOR_ACTIVECAPTION);
		CBrush br(crHilite);
		pDC->FillRect(&rectFill, &br);
		pDC->SetBkMode( TRANSPARENT );
		COLORREF crSave = pDC->GetTextColor( );
		pDC->SetTextColor(RGB(255,255,255));
		DrawRowItems
			(lpDIS->itemID, rectFill,pDC);
		pDC->SetTextColor(crSave);
		pDC->SetBkMode( OPAQUE );


	}

	if ((bSelectAction | bDrawEntireAction) && !bSelectItem)
	{
		// Item has been de-selected -- remove frame
		CBrush br(cr);
		pDC->FillRect(&rectFill, &br);
		DrawRowItems
			(lpDIS->itemID, rectFill,pDC);
	}

	if (bFocusItem)
	{
		pDC->DrawFocusRect(&lpDIS->rcItem);
	}
}

void CRegistrationList::DrawRowItems
(int nItem, RECT rectFill, CDC* pDC)
{
	RECT rectFillSave = rectFill;
	RECT rectSubItem;
	rectSubItem.left = rectFill.left;
	rectSubItem.right = rectFill.right;
	rectSubItem.top = rectFill.top;
	rectSubItem.bottom = rectFill.bottom;

	int i;
	char szBuffer[201];
	CString csBuffer;
	int colLeft = rectFill.left;

	LV_ITEM lvItem;

	for (i = 0; i < m_nCols; i++)
	{
		lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
		lvItem.iItem = nItem;
		lvItem.iSubItem = i;
		lvItem.cchTextMax = 200;
		lvItem.pszText = szBuffer;

		GetListCtrl().GetItem (&lvItem);
		csBuffer = szBuffer;
		if (csBuffer.GetLength() == 0)
		{
			break;
		}
		CSize csText = pDC->GetTextExtent(csBuffer);
		int nColWidth = GetListCtrl().GetColumnWidth(i);
		int nColWidthDraw = nColWidth - 6;

		double dCharSize = csText.cx / csBuffer.GetLength();
	#pragma warning( disable :4244 )
		int nMaxChars = (nColWidthDraw / dCharSize) - 5;
	#pragma warning( default : 4244 )

		if (csBuffer.GetLength() > nMaxChars &&
			csText.cx >= (nColWidthDraw - (.5 * dCharSize)))
		{
			CString csBufferTest = csBuffer.Left(nMaxChars - 0);
			CSize csTextTest = pDC->GetTextExtent(csBufferTest);
			if (csTextTest.cx < (nColWidthDraw - (3.0 * dCharSize)))
			{
				csBuffer = csBuffer.Left(nMaxChars + 1);
			}
			else if (csTextTest.cx > (nColWidthDraw - (2.0 * dCharSize)))
			{
				csBuffer = csBuffer.Left(nMaxChars - 1);
			}
			else
			{
				csBuffer = csBuffer.Left(nMaxChars);
			}
			csBuffer += _T("...");

		}

		rectSubItem.left = colLeft;
		rectSubItem.right = colLeft + nColWidth - 3;
		if (i == 0)
		{
			CRect crClip;
			CRgn crRegion;

			int nReturn = pDC->GetClipBox( &crClip);

			crRegion.CreateRectRgnIndirect( &crClip );
			pDC->SelectClipRgn( &crRegion );
*/
		/*	DrawIconEx( pDC->m_hDC,
#pragma warning( disable :4244 )
						(nColWidth - 10) / 2 ,
#pragma warning( default : 4244 )
						rectFillSave.top + 1,
						(lvItem.iImage == 0 ? m_hiCheck : m_hiX ),
						16,
						16,
						NULL,
						NULL,
						DI_NORMAL);*/
/*
			crRegion.DeleteObject( );


		}
		else
		{
			pDC->ExtTextOut
				(colLeft + 3,
				rectFill.top,
				ETO_CLIPPED,
				&rectSubItem,
				csBuffer,NULL);
		}
		colLeft = colLeft + nColWidth;

	}
*/
	/*lvItem.mask = LVIF_IMAGE ;
	lvItem.iItem = nItem;
	lvItem.iSubItem = 0;
	GetItem (&lvItem);

	int nColWidth = GetColumnWidth(0);

	CRect crClip;
	CRgn crRegion;

	int nReturn = pDC->GetClipBox( &crClip);

	crRegion.CreateRectRgnIndirect( &crClip );
	pDC->SelectClipRgn( &crRegion );

	DrawIconEx( pDC->m_hDC,
#pragma warning( disable :4244 )
				(nColWidth - 16) / 2 ,
#pragma warning( default : 4244 )
				rectFillSave.top + 1,
				(lvItem.iImage == 0 ? m_hiCheck : m_hiX ),
				16,
				16,
				NULL,
				NULL,
				DI_NORMAL);

	crRegion.DeleteObject( );*/

/*
}
*/
void CRegistrationList::CreateCols()
{

	LV_COLUMN lvCol;
	lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvCol.fmt = LVCFMT_LEFT;   // left-align column
	lvCol.cx = 35;             // width of column in pixels
	lvCol.iSubItem = 0;
	lvCol.pszText = _T("   ");

	int nReturn =
		GetListCtrl().InsertColumn( 0, &lvCol);

	ASSERT (nReturn != -1);

	CString csColTitle;
	int i;

	lvCol.fmt = LVCFMT_LEFT;   // left-align column
	lvCol.cx = 120;             // width of column in pixels

	i = 1;
	lvCol.iSubItem = i;
	csColTitle.Format(_T("     "),i);
	lvCol.pszText =  const_cast <TCHAR *> ((LPCTSTR) csColTitle);
	nReturn = GetListCtrl().InsertColumn( i,&lvCol);

	ASSERT (nReturn != -1);

	lvCol.cx = 400;

	i = 2;
	lvCol.iSubItem = i;
	csColTitle.Format(_T("     "),i);
	lvCol.pszText =  const_cast <TCHAR *> ((LPCTSTR) csColTitle);
	nReturn = GetListCtrl().InsertColumn( i,&lvCol);

	ASSERT (nReturn != -1);

	SetNumberCols(3);
}

void CRegistrationList::SetColText(BOOL bClean)
{

	int iMode = m_pActiveXParent->GetMode();
	CString csOne = bClean ? _T(" ") : _T("Reg");
	CString csTwo = bClean ? _T(" ") :
					(iMode == CEventRegEditCtrl::FILTERS ?
						_T("Event Consumer Class") : _T("Event Filter Class"));
	CString csThree = bClean ? _T(" ") :
					(iMode == CEventRegEditCtrl::FILTERS ?
						_T("Instance") : _T("Instance"));


	LV_COLUMN lvCol;
	lvCol.mask = LVCF_TEXT | LVCF_SUBITEM;
	lvCol.iSubItem = 0;
	lvCol.pszText = const_cast <TCHAR *> ((LPCTSTR) csOne);

	BOOL bReturn =
		GetListCtrl().SetColumn( 0, &lvCol);

	ASSERT (bReturn);

	int i;

	i = 1;
	lvCol.iSubItem = i;
	lvCol.pszText =  const_cast <TCHAR *> ((LPCTSTR)csTwo);
	bReturn = GetListCtrl().SetColumn( i,&lvCol);

	ASSERT (bReturn);

	i = 2;
	lvCol.iSubItem = i;
	lvCol.pszText =  const_cast <TCHAR *> ((LPCTSTR)csThree);
	bReturn = GetListCtrl().SetColumn( i,&lvCol);

	ASSERT (bReturn);
}

int CRegistrationList::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CListView::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO: Add your specialized creation code here
	CreateImages();
	CreateCols();

	return 0;
}

void CRegistrationList::DeleteFromEnd(int nDelFrom, BOOL bDelAll)
{

	int nItems = bDelAll ? GetListCtrl().GetItemCount(): min(nDelFrom,GetListCtrl().GetItemCount());

	if (nItems == 0)
	{
		return;
	}

	for (int i = nItems - 1; i >= 0; i--)
	{
		UINT_PTR dw =  GetListCtrl().GetItemData(i);
		if (dw)
		{
			CString *pTmp = reinterpret_cast<CString*>(dw);
			delete pTmp;
		}
		if (!bDelAll)
		{
			GetListCtrl().DeleteItem(i);
		}
	}

	if (bDelAll)
	{
		GetListCtrl().DeleteAllItems();
	}

}

void CRegistrationList::InsertRowData
(int nRow, BOOL bReg, CString &csClass, CString &csName ,
 CString *pcsData)
{
	LV_ITEM lvItem;

	CString csReg = _T("");
	lvItem.mask = LVIF_IMAGE | LVIF_TEXT | LVIF_PARAM ;
	lvItem.pszText = const_cast <TCHAR *> ((LPCTSTR) csReg);
	lvItem.iItem = nRow;
	lvItem.iSubItem = 0;
	lvItem.lParam = reinterpret_cast<LPARAM> (pcsData);
	lvItem.iImage = bReg ? 0: 1;
	int nItem;
	nItem = GetListCtrl().InsertItem (&lvItem);

	lvItem.mask = LVIF_TEXT ;
	lvItem.pszText =  const_cast<TCHAR *>((LPCTSTR) csClass);
	lvItem.iItem = nItem;
	lvItem.iSubItem = 1;

	GetListCtrl().SetItem (&lvItem);

	lvItem.mask = LVIF_TEXT ;
	lvItem.pszText =  const_cast<TCHAR *>((LPCTSTR) csName);
	lvItem.iItem = nItem;
	lvItem.iSubItem = 2;

	GetListCtrl().SetItem (&lvItem);

}

void CRegistrationList::OnDestroy()
{
	CListView::OnDestroy();

	// TODO: Add your message handler code here

}

void CRegistrationList::CreateImages()
{

	HICON hiCheck= theApp.LoadIcon(IDI_ICONCHECK);
	HICON hiX = theApp.LoadIcon(IDI_ICONX);

	m_pcilImageList = new CImageList();

	m_pcilImageList ->
			Create(16, 16, TRUE, 2, 2);

	m_pcilImageList -> Add(hiCheck);
	m_pcilImageList -> Add(hiX);

	GetListCtrl().SetImageList(m_pcilImageList, LVSIL_SMALL);
}

void CRegistrationList::SetIconState(int nItem, BOOL bCheck)
{
	LV_ITEM lvItem;

	lvItem.iItem = nItem;
	lvItem.iSubItem = 0;
	lvItem.mask = LVIF_IMAGE;
	lvItem.iImage = bCheck? 0: 1;

	GetListCtrl().SetItem(&lvItem);

}

CStringArray *CRegistrationList::GetAssociators
(CString &csTarget, CString &csTargetRole,
 CString &csResultClass, CString &csAssocClass, CString &csResultRole)
{
	CString csQuery = BuildOBJDBGetAssocsQuery
		(m_pActiveXParent->GetServices(),
		&csTarget,
		&csAssocClass,
		&csResultClass,
		&csTargetRole,
		NULL,
		NULL,
		&csResultRole,
		FALSE);

	IWbemServices* psvcFrom = m_pActiveXParent->GetServices();
	IEnumWbemClassObject *pEnum =
		ExecOBJDBQuery
		(psvcFrom, csQuery);

	if (!pEnum)
	{
		return NULL;
	}

	SetEnumInterfaceSecurity(m_pActiveXParent->m_csNamespace,pEnum, psvcFrom);

	pEnum->Reset();

	CStringArray *pcsaAssociators = new CStringArray;

	HRESULT hResult = S_OK;
	BOOL bCancel = FALSE;
	int nRes = 10;

	CPtrArray *pcpaInstances = NULL;

	pcpaInstances =
		SemiSyncEnum
		(pEnum, bCancel, hResult, nRes);

	while (pcpaInstances &&
			(hResult == S_OK ||
			hResult == WBEM_S_TIMEDOUT ||
			pcpaInstances->GetSize() > 0))

	{
		for (int i = 0; i < pcpaInstances->GetSize(); i++)
		{
			IWbemClassObject *pObject =
				reinterpret_cast<IWbemClassObject *>(pcpaInstances->GetAt(i));
			pcsaAssociators->Add
				(GetIWbemFullPath(pObject));
			pObject->Release();

		}

		delete pcpaInstances;
		pcpaInstances = NULL;

		pcpaInstances =
			SemiSyncEnum
			(pEnum, bCancel, hResult, nRes);
	}

	delete pcpaInstances;
	pEnum->Release();

	return pcsaAssociators;

}

CPtrArray *CRegistrationList::GetReferences
(CString &csTarget, CString &csTargetRole, CString &csAssocClass)
{
	CString csQuery =
		BuildOBJDBGetRefQuery
			(m_pActiveXParent->GetServices(),
			&csTarget,
			&csAssocClass,
			&csTargetRole,
			NULL,
			FALSE);


	IWbemServices* psvcFrom = m_pActiveXParent->GetServices();
	IEnumWbemClassObject *pEnum =
		ExecOBJDBQuery
		(psvcFrom, csQuery);

	if (!pEnum)
	{
		return NULL;
	}

	SetEnumInterfaceSecurity(m_pActiveXParent->m_csNamespace,pEnum, psvcFrom);

	pEnum->Reset();

	CPtrArray *pcpaReferences = new CPtrArray;

	HRESULT hResult = S_OK;
	BOOL bCancel = FALSE;
	int nRes = 10;

	CPtrArray *pcpaInstances = NULL;

	pcpaInstances =
		SemiSyncEnum
		(pEnum, bCancel, hResult, nRes);

	while (pcpaInstances &&
			(hResult == S_OK ||
			hResult == WBEM_S_TIMEDOUT ||
			pcpaInstances->GetSize() > 0))

	{
		for (int i = 0; i < pcpaInstances->GetSize(); i++)
		{
			IWbemClassObject *pObject =
				reinterpret_cast<IWbemClassObject *>(pcpaInstances->GetAt(i));
			pcpaReferences->Add
				(pObject);
		}

		delete pcpaInstances;
		pcpaInstances = NULL;

		pcpaInstances =
			SemiSyncEnum
			(pEnum, bCancel, hResult, nRes);
	}

	delete pcpaInstances;
	pEnum->Release();

	return pcpaReferences;

}


BOOL CRegistrationList::DestroyWindow()
{
	// TODO: Add your specialized code here and/or call the base class

	return CListViewEx::DestroyWindow();
}

void CRegistrationList::OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult)
{
	HTREEITEM hItem = m_pActiveXParent->m_pTree->GetSelectedItem();

	if (!hItem)
	{
		return;
	}

	CStringArray *pcsaItem
			= reinterpret_cast<CStringArray *>
				(m_pActiveXParent->m_pTree->GetItemData( hItem ));

	CString csTreeInstance = pcsaItem->GetAt(0);

	BSTR bstrTemp = csTreeInstance.AllocSysString();
	IWbemClassObject *pTreeInstance = NULL;
	SCODE sc = m_pActiveXParent->GetServices() -> GetObject
			(bstrTemp,0,NULL, &pTreeInstance,NULL);
	::SysFreeString(bstrTemp);
	if (sc == S_OK)
	{
		NM_LISTVIEW *plvNotification =
		reinterpret_cast<NM_LISTVIEW *> (pNMHDR);
		int nItem = plvNotification->iItem;
		if (nItem != -1)
		{
			UINT_PTR dw = GetListCtrl().GetItemData(nItem);
			if (dw)
			{
				CString *pcsListInstance =
					reinterpret_cast<CString*>(dw);

				BSTR bstrTemp = pcsListInstance->Mid(1).AllocSysString();
				IWbemClassObject *pListInstance = NULL;
				SCODE sc = m_pActiveXParent->GetServices() -> GetObject
					(bstrTemp,0,NULL, &pListInstance,NULL);
				::SysFreeString(bstrTemp);
				if (sc == S_OK)
				{
					pListInstance->Release();
				}
				else
				{
					GetListCtrl().DeleteItem(nItem);
					// Delet list item cause it is deleted from the  db.
					pTreeInstance->Release();
					*pResult = 1;
					SetButtonState();
					return;
				}
			}
		}
		SetButtonState();
		pTreeInstance->Release();
		*pResult = 0;
	}
	else
	{
		*pResult = 0;
		m_pActiveXParent->m_pTree->DeleteTreeInstanceItem
			(m_pActiveXParent->m_pTree->GetSelectedItem(),TRUE);
		m_pActiveXParent->m_pListFrame->UpdateWindow();
	}


}

void CRegistrationList::SetButtonState()
{
	CListCtrl& ListCtrl=GetListCtrl();
	BOOL bRegister = FALSE;
	BOOL bUnregister = FALSE;

	LV_ITEM lvi;

	for (int i = 0; i < ListCtrl.GetItemCount(); i++)
	{
		lvi.mask = LVIF_IMAGE | LVIF_STATE;
		lvi.iItem = i;
		lvi.iSubItem = 0;
		lvi.stateMask = LVIS_SELECTED ;
		BOOL bReturn = ListCtrl.GetItem(&lvi);
		if (bReturn)
		{
			//state
			//	iImage
			if ((lvi.state & LVIS_SELECTED) == LVIS_SELECTED)
			{
				if (lvi.iImage == 0)
				{
					bUnregister = TRUE;
				}
				else
				{
					bRegister = TRUE;
				}
			}
		}
		if (bRegister && bUnregister)
		{
			m_pActiveXParent->m_pListFrameBanner->EnableButtons(TRUE,TRUE);
			return;
		}
	}
	m_pActiveXParent->m_pListFrameBanner->EnableButtons(bRegister,bUnregister);
}

BOOL CRegistrationList::AreThereRegistrations()
{
	CListCtrl& ListCtrl=GetListCtrl();
	BOOL bRegister = FALSE;

	LV_ITEM lvi;

	for (int i = 0; i < ListCtrl.GetItemCount(); i++)
	{
		lvi.mask = LVIF_IMAGE;
		lvi.iItem = i;
		lvi.iSubItem = 0;
		lvi.stateMask = LVIS_SELECTED ;
		BOOL bReturn = ListCtrl.GetItem(&lvi);
		if (bReturn)
		{
			if (lvi.iImage == 0)
			{
				return TRUE;
			}
		}

	}

	return FALSE;

}

void CRegistrationList::UnregisterSelections()
{
	CListCtrl& ListCtrl=GetListCtrl();

	LV_ITEM lvi;

	CUIntArray cuiaDeletedItems;

	int i;

	for (i = 0; i < ListCtrl.GetItemCount(); i++)
	{
		lvi.mask = LVIF_IMAGE | LVIF_STATE | LVIF_PARAM ;
		lvi.iItem = i;
		lvi.iSubItem = 0;
		lvi.stateMask = LVIS_SELECTED ;
		BOOL bReturn = ListCtrl.GetItem(&lvi);
		if (bReturn)
		{
			if ((lvi.state & LVIS_SELECTED) == LVIS_SELECTED)
			{
				if (lvi.iImage == 0)
				{
					// Unregister here
					CString csResultClass =  _T("__FilterToConsumerBinding");;
					CString csTargetRole;
					CString csResultRole;
					if (m_pActiveXParent->GetMode() == CEventRegEditCtrl::FILTERS)
					{
						csTargetRole = _T("Consumer");
						csResultRole = _T("Filter");
					}
					else
					{
						csTargetRole = _T("Filter");
						csResultRole = _T("Consumer");
					}
					CString *pcsTarget =
						reinterpret_cast<CString *>(lvi.lParam);

					CString csTarget = pcsTarget->Mid(1);
					CPtrArray *pcpaReferences =
						GetReferences
						(csTarget,
						csTargetRole,
						csResultClass);
					CString csTreeSelection =
						m_pActiveXParent->GetTreeSelectionPath();

					// If the association of list item has been deleted.
					if (!pcpaReferences || pcpaReferences -> GetSize() == 0)
					{
						pcsTarget->SetAt(0,'U');
						cuiaDeletedItems.Add(i);
					}
					else
					{
						for (int n = 0; n < pcpaReferences -> GetSize(); n++)
						{
							IWbemClassObject *pInst =
								reinterpret_cast<IWbemClassObject *>
								(pcpaReferences->GetAt(n));
							CString csAssociator =
								::GetProperty
								(pInst, &csResultRole, TRUE);
							CString csReferencePath =
								GetIWbemFullPath(pInst);
							if (ArePathsEqual (csAssociator, csTreeSelection))
							{
								pInst->Release();

								BSTR bstrTemp = csReferencePath.AllocSysString();
								HRESULT sc =
									m_pActiveXParent->GetServices()->
									DeleteInstance(bstrTemp,
									0,NULL,NULL);
								::SysFreeString(bstrTemp);

								if (sc != S_OK)
								{
									CString csUserMsg =
										_T("Cannot delete instance ") + csReferencePath;
									ErrorMsg(&csUserMsg,sc, NULL, TRUE,
										&csUserMsg, __FILE__, __LINE__);
								}
								else
								{
									pcsTarget->SetAt(0,'U');
									cuiaDeletedItems.Add(i);
								}

							}
							else
							{
								pInst->Release();
							}

						}
					}

					delete pcpaReferences;
				}
			}
		}

	}

	for (i = (int) cuiaDeletedItems.GetSize() - 1; i >= 0; i--)
	{
		int nDelete = cuiaDeletedItems.GetAt(i);
		SetIconState(nDelete,FALSE);
		if (i == 0)
		{
			GetListCtrl().UpdateWindow();
		}
	}

}

void CRegistrationList::RegisterSelections()
{
	CListCtrl& ListCtrl=GetListCtrl();

	LV_ITEM lvi;

	CUIntArray cuiaNewAssocItems;

	for (int i = 0; i < ListCtrl.GetItemCount(); i++)
	{
		lvi.mask = LVIF_IMAGE | LVIF_STATE | LVIF_PARAM ;
		lvi.iItem = i;
		lvi.iSubItem = 0;
		lvi.stateMask = LVIS_SELECTED ;
		BOOL bReturn = ListCtrl.GetItem(&lvi);
		if (bReturn)
		{
			//state
			//	iImage
			if ((lvi.state & LVIS_SELECTED) == LVIS_SELECTED)
			{

				// Register here
				CString csAssocClass =  _T("__FilterToConsumerBinding");
				IWbemClassObject *pClass =
					GetClassObject
					(m_pActiveXParent->GetServices(),
					&csAssocClass,
					FALSE);
				if (!pClass)
				{
					SetButtonState();
					return;
				}

				IWbemClassObject *pNewInstance = NULL;
				SCODE sc = pClass->SpawnInstance(0, &pNewInstance);

				if (sc != S_OK)
				{
					CString csUserMsg;
					csUserMsg =
						_T("Cannot spawn instance of the __FilterToConsumerBinding class.");
					ErrorMsg
								(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
								__LINE__ );
					pClass->Release();
					SetButtonState();
					return;
				}

				CString csMyRole;
				CString csOtherRole;
				CString csMyRefClass;
				CString csOtherRefClass;
				if (m_pActiveXParent->GetMode() == CEventRegEditCtrl::FILTERS)
				{
					csMyRole = _T("Consumer");

					csMyRefClass = m_pActiveXParent->m_csRootConsumerClass;
					csOtherRefClass = m_pActiveXParent->m_csRootFilterClass;
					csOtherRole = _T("Filter");
				}
				else
				{
					csMyRole = _T("Filter");
					csMyRefClass = m_pActiveXParent->m_csRootFilterClass;
					csOtherRefClass = m_pActiveXParent->m_csRootConsumerClass;
					csOtherRole = _T("Consumer");
				}

				CString *pcsMyPath =
					reinterpret_cast<CString *>(lvi.lParam);

				CString csMyPath = pcsMyPath->Mid(1);

				CString csOtherPath =
					m_pActiveXParent->GetTreeSelectionPath();

				VARIANT v;
				VariantInit(&v);
				V_VT(&v) = VT_BSTR;

				V_BSTR(&v) = csMyPath.AllocSysString();

				BSTR bstrTemp = csMyRole.AllocSysString();
				pNewInstance->Put(bstrTemp, 0, &v, 0);
				::SysFreeString(bstrTemp);

				VariantClear(&v);

				VariantInit(&v);
				V_VT(&v) = VT_BSTR;

				V_BSTR(&v) = csOtherPath.AllocSysString();

				bstrTemp = csOtherRole.AllocSysString();
				pNewInstance->Put(bstrTemp, 0, &v, 0);
				::SysFreeString(bstrTemp);

				VariantClear(&v);

				BSTR RefProp = SysAllocString(L"csMyRole");

				sc = m_pActiveXParent->GetServices()->PutInstance
					(pNewInstance , WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

				if (sc != S_OK)
				{
					CString csUserMsg;
					csUserMsg =  _T("Cannot PutInstance of the __FilterToConsumerBinding class.");
					ErrorMsg
								(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
								__LINE__ );
					pNewInstance->Release();
					SetButtonState();
					return;
				}
				pcsMyPath->SetAt(0,'R');
				pNewInstance->Release();
				pNewInstance = NULL;
				cuiaNewAssocItems.Add(i);

			}
		}

	}

	for (i = (int) cuiaNewAssocItems.GetSize() - 1; i >= 0; i--)
	{
		int nAdd = cuiaNewAssocItems.GetAt(i);
		SetIconState(nAdd,TRUE);
		if (i == 0)
		{
			GetListCtrl().UpdateWindow();
		}
	}
}

CString CRegistrationList::DisplayName(CString &csFullpath)
{
	CObjectPathParser parser;
	ParsedObjectPath* pParsedPath = NULL;

	BSTR bstrTemp = csFullpath.AllocSysString();
	int nStatus  = parser.Parse(bstrTemp,  &pParsedPath);
	::SysFreeString(bstrTemp);

	int i = 0;

	CString csDisplayName;
	if (nStatus == 0)
	{
#pragma warning( disable :4018 )
		for (i = 0; i < pParsedPath->m_dwNumKeys; i++)
#pragma warning( default :4018 )
		{
			csDisplayName += pParsedPath->m_paKeys[i]->m_pName;
			csDisplayName += _T("=\"");
			COleVariant covValue = pParsedPath->m_paKeys[i]->m_vValue;
			covValue.ChangeType(VT_BSTR);
			csDisplayName += covValue.bstrVal;
			csDisplayName += _T("\"");
#pragma warning( disable :4018 )
			if (i < (pParsedPath->m_dwNumKeys - 1))
#pragma warning( default :4018 )
			{
				csDisplayName += _T(",");
			}
		}

	}



	if (pParsedPath)
	{
		parser.Free(pParsedPath);
	}

	return csDisplayName;

}

void CRegistrationList::ColClick ( NMHDR * pNotifyStruct, LRESULT* result )
{
	NM_LISTVIEW *plvNotification =
		reinterpret_cast<NM_LISTVIEW *> (pNotifyStruct);
	m_nSort = plvNotification->iSubItem;
	DoSort();
}

void CRegistrationList::DoSort(BOOL bFlip)
{
	DWORD dw;

	if (m_nSort == SORTREGISTERED)
	{
		if (bFlip || m_nSortRegistered == SORTUNITIALIZED)
		{
			if (m_nSortRegistered == SORTUNITIALIZED)
			{
				m_nSortRegistered = SORTASCENDING;
			}
			else if (m_nSortRegistered == SORTASCENDING)
			{
				m_nSortRegistered = SORTDECENDING;
			}
			else
			{
				m_nSortRegistered = SORTASCENDING;
			}
		}

		dw = MAKELONG(m_nSort,m_nSortRegistered);
	}
	else if (m_nSort == SORTCLASS)
	{
		if (bFlip || m_nSortClass == SORTUNITIALIZED)
			{
			if (m_nSortClass == SORTUNITIALIZED)
			{
				m_nSortClass = SORTASCENDING;
			}
			else if (m_nSortClass == SORTASCENDING)
			{
				m_nSortClass = SORTDECENDING;
			}
			else
			{
				m_nSortClass = SORTASCENDING;
			}
		}

		dw = MAKELONG(m_nSort,m_nSortClass);
	}
	else if (m_nSort == SORTNAME)
	{
		if (bFlip || m_nSortName == SORTUNITIALIZED)
		{
			if (m_nSortName == SORTUNITIALIZED)
			{
				m_nSortName = SORTASCENDING;
			}
			else if (m_nSortName == SORTASCENDING)
			{
				m_nSortName = SORTDECENDING;
			}
			else
			{
				m_nSortName = SORTASCENDING;
			}
		}

		dw = MAKELONG(m_nSort,m_nSortName);
	}

	GetListCtrl().SortItems(CompareFunc,dw);
}

CString CRegistrationList::GetSelectionPath()
{
	CListCtrl& ListCtrl=GetListCtrl();
	BOOL bRegister = FALSE;
	BOOL bUnregister = FALSE;

	LV_ITEM lvi;

	for (int i = 0; i < ListCtrl.GetItemCount(); i++)
	{
		lvi.mask = LVIF_STATE | LVIF_PARAM;
		lvi.iItem = i;
		lvi.iSubItem = 0;
		lvi.stateMask = LVIS_SELECTED ;
		BOOL bReturn = ListCtrl.GetItem(&lvi);
		if (bReturn)
		{
			//state
			//	iImage
			if ((lvi.state & LVIS_SELECTED) == LVIS_SELECTED)
			{
				CString *pcsSelected =
						reinterpret_cast<CString *>(lvi.lParam);

				CString csSelected = pcsSelected->Mid(1);
				return csSelected;
			}
		}

	}
	return _T("");

}

void CRegistrationList::OnContextMenu(CWnd* pWnd, CPoint point)
{
	// TODO: Add your message handler code here

	m_cpRButtonUp = point;

	ScreenToClient(&m_cpRButtonUp);

	VERIFY(m_cmContext.LoadMenu(IDR_MENULISTCONTEXT));

	CMenu* pPopup = m_cmContext.GetSubMenu(0);

	CWnd* pWndPopupOwner =  m_pActiveXParent;

	pPopup->TrackPopupMenu
			(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x + 4, point.y + 4,
				pWndPopupOwner);

	m_cmContext.DestroyMenu();
}



void CRegistrationList::OnSetFocus(CWnd* pOldWnd)
{
	CListViewEx::OnSetFocus(pOldWnd);

	// TODO: Add your message handler code here
	m_pActiveXParent->m_bRestoreFocusToTree = FALSE;
	m_pActiveXParent->m_bRestoreFocusToCombo = FALSE;
	m_pActiveXParent->m_bRestoreFocusToNamespace = FALSE;
	m_pActiveXParent->m_bRestoreFocusToList = TRUE;
}

void CRegistrationList::OnKillFocus(CWnd* pNewWnd)
{
	CListViewEx::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	m_pActiveXParent->m_bRestoreFocusToTree = FALSE;
	m_pActiveXParent->m_bRestoreFocusToCombo = FALSE;
	m_pActiveXParent->m_bRestoreFocusToNamespace = FALSE;
	m_pActiveXParent->m_bRestoreFocusToList = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by EventRegEdit.rc
//
#define IDS_EVENTREGEDIT                1
#define IDD_ABOUTBOX_EVENTREGEDIT       1
#define IDB_EVENTREGEDIT                1
#define IDI_ABOUTDLL                    1
#define IDS_EVENTREGEDIT_PPG            2
#define IDS_EVENTREGEDIT_PPG_CAPTION    200
#define IDD_PROPPAGE_EVENTREGEDIT       200
#define IDD_DIALOGINITNAMESPACE         218
#define IDC_CHECK1                      201
#define IDC_SINGLEVIEWCTRL1             202
#define IDC_NSENTRYCTRLINITNAMESPACE    205
#define IDR_TOOLBARTREEFRAME            208
#define IDR_TOOLBARLISTFRAME            209
#define IDI_ICONINSTANCE                210
#define IDI_ICONCLASS                   211
#define IDD_DIALOGPROPERTIES            212
#define IDI_ICONCHECK                   212
#define IDI_ICONX                       213
#define IDR_MENUCONTEXT                 214
#define IDB_BITMAP1                     216
#define IDB_BITMAP2                     217
#define IDB_BITMAPCHECK                 219
#define IDB_BITMAPX                     220
#define IDR_MENULISTCONTEXT             223
#define ID_BUTTONNEW                    32768
#define ID_BUTTONPROPERTIES             32769
#define ID_BUTTONDELETE                 32770
#define ID_MENUITEMREFRESH              32771
#define ID_BUTTONCHECKED                32774
#define ID_BUTTONUNCHECKED              32775
#define ID_BUTTONLISTPROP               32776
#define ID_EDITINSTPROP                 32777
#define ID_VIEWCLASSPROP                32778
#define ID_NEWINSTANCE                  32779
#define ID_DELETEINSTANCE               32780
#define ID_VIEWINSTPROP                 32781
#define ID_REGISTER                     32782
#define ID_UNREGISTER                   32783

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        224
#define _APS_NEXT_COMMAND_VALUE         32784
#define _APS_NEXT_CONTROL_VALUE         203
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\selectview.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// CSelectView.cpp : implementation file
//

#include "precomp.h"
#include "wbemidl.h"
#include "util.h"
#include "resource.h"
#include "PropertiesDialog.h"
#include "EventRegEdit.h"
#include "EventRegEditCtl.h"
#include "SelectView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSelectView

CSelectView::CSelectView()
{
	m_pActiveXParent=NULL;
}

CSelectView::~CSelectView()
{
}


BEGIN_MESSAGE_MAP(CSelectView, CComboBox)
	//{{AFX_MSG_MAP(CSelectView)
	ON_CONTROL_REFLECT(CBN_SELCHANGE, OnSelchange)
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectView message handlers
/////////////////////////////////////////////////////////////////////////////

void CSelectView::OnSelchange()
{
	// TODO: Add your control notification handler code here
	m_iMode = GetCurSel();
	m_pActiveXParent->SetMode(m_iMode);
}

void CSelectView::InitContent()
{
	if (m_pActiveXParent->Modeless())
	{
		ClearContent();
	}
	else
	{
		if (GetCount() == 0)
		{
			AddString(m_pActiveXParent->GetModeString(0));
			AddString(m_pActiveXParent->GetModeString(1));
			AddString(m_pActiveXParent->GetModeString(2));
		}
		SelectString(0,m_pActiveXParent->GetCurrentModeString());
	}

}

void CSelectView::ClearContent()
{
	ResetContent();
}


void CSelectView::OnSetFocus(CWnd* pOldWnd)
{
	CComboBox::OnSetFocus(pOldWnd);

	// TODO: Add your message handler code here
	m_pActiveXParent->m_bRestoreFocusToTree = FALSE;
	m_pActiveXParent->m_bRestoreFocusToCombo = TRUE;
	m_pActiveXParent->m_bRestoreFocusToNamespace = FALSE;
	m_pActiveXParent->m_bRestoreFocusToList = FALSE;
	m_pActiveXParent->OnActivateInPlace(TRUE,NULL);
}

void CSelectView::OnKillFocus(CWnd* pNewWnd)
{
	CComboBox::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	m_pActiveXParent->m_bRestoreFocusToTree = FALSE;
	m_pActiveXParent->m_bRestoreFocusToCombo = TRUE;
	m_pActiveXParent->m_bRestoreFocusToNamespace = FALSE;
	m_pActiveXParent->m_bRestoreFocusToList = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\registrationlist.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_REGISTRATIONLIST_H__14314525_4FC2_11D1_9659_00C04FD9B15B__INCLUDED_)
#define AFX_REGISTRATIONLIST_H__14314525_4FC2_11D1_9659_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// RegistrationList.h : header file
//
class CEventRegEditCtrl;
class CListCwnd;
class CClassInstanceTree;
/////////////////////////////////////////////////////////////////////////////
// CRegistrationList window

class CRegistrationList : public CListViewEx
{
// Construction
public:
	CRegistrationList();
	void InitContent(BOOL bUpdateInstances = TRUE);
	void ClearContent();
	void SetActiveXParent(CEventRegEditCtrl *pActiveXParent);
	void SetNumberCols(int nCols) {m_nCols = nCols;}
	void RegisterSelections();
	void UnregisterSelections();
	BOOL AreThereRegistrations();
	static CString DisplayName(CString &csFullpath);
	CString GetSelectionPath();
	enum {SORTREGISTERED = 0, SORTCLASS = 1, SORTNAME = 2};
	enum {SORTUNITIALIZED = 0, SORTASCENDING = 1, SORTDECENDING = 2};
// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRegistrationList)
	public:
	virtual BOOL DestroyWindow();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CRegistrationList();

	// Generated message map functions
protected:
	CEventRegEditCtrl *m_pActiveXParent;
	int m_nCols;
	CImageList *m_pcilImageList;
	//void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	//void DrawRowItems(int nItem, RECT rectFill, CDC* pDC);
	void CreateCols();
	void DeleteFromEnd(int nDelFrom = 0, BOOL bDelAll = FALSE);
	void InsertRowData
		(	int nRow, 
			 BOOL bReg, 
			CString &csClass, 
			CString &csName , 
			CString *pcsData = NULL);
	void ResetChecks();
	void CreateImages();
	void SetIconState(int nItem, BOOL bCheck);
	void SetColText(BOOL bClean);
	CStringArray *GetAssociators
		(CString &csTarget, CString &csTargetRole, 
		CString &csResultClass, CString &csAssocClass, CString &csResultRole);
	CPtrArray *GetReferences
		(CString &csTarget, CString &csTargetRole, CString &csAssocClass);

	void SetButtonState();
	
	UINT m_nSort;
	UINT m_nSortRegistered;
	UINT m_nSortClass;
	UINT m_nSortName;

	void DoSort(BOOL bFlip = TRUE);

	CMenu m_cmContext;
	CPoint m_cpRButtonUp;

	//{{AFX_MSG(CRegistrationList)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG
	afx_msg void OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void ColClick ( NMHDR * pNotifyStruct, LRESULT* result );
	DECLARE_MESSAGE_MAP()

	friend class CListCwnd;
	friend class CEventRegEditCtrl;
	friend class CClassInstanceTree;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGISTRATIONLIST_H__14314525_4FC2_11D1_9659_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\singleview.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "singleview.h"
#include "wbemidl.h"
#include "MsgDlgExterns.h"
#include "util.h"
#include "resource.h"
#include "PropertiesDialog.h"
#include "EventRegEdit.h"
#include "EventRegEditCtl.h"

BEGIN_EVENTSINK_MAP(CSingleView, CWnd)
    //{{AFX_EVENTSINK_MAP(CSingleView)
	//}}AFX_EVENTSINK_MAP
	ON_EVENT_REFLECT(CSingleView,6,OnGetIWbemServices,VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	ON_EVENT_REFLECT(CSingleView,8,OnNotifyInstanceCreated,VTS_BSTR)
END_EVENTSINK_MAP()


/////////////////////////////////////////////////////////////////////////////
// CSingleView

IMPLEMENT_DYNCREATE(CSingleView, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CSingleView properties

CString CSingleView::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CSingleView::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

long CSingleView::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

long CSingleView::GetPropertyFilter()
{
	long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CSingleView::SetPropertyFilter(long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CSingleView operations

long CSingleView::GetEditMode()
{
	long result;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::SetEditMode(long lEditMode)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lEditMode);
}

long CSingleView::RefreshView()
{
	long result;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::NotifyWillShow()
{
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CSingleView::DeleteInstance()
{
	long result;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::ExternInstanceCreated(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

void CSingleView::ExternInstanceDeleted(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x9, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

long CSingleView::QueryCanCreateInstance()
{
	long result;
	InvokeHelper(0xa, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::QueryCanDeleteInstance()
{
	long result;
	InvokeHelper(0xb, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::QueryNeedsSave()
{
	long result;
	InvokeHelper(0xc, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::QueryObjectSelected()
{
	long result;
	InvokeHelper(0xd, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString CSingleView::GetObjectPath(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xe, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::StartViewEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xf, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

long CSingleView::GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp)
{
	long result;
	static BYTE parms[] =
		VTS_PBSTR VTS_PDISPATCH;
	InvokeHelper(0x10, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		pszTitle, lpPictureDisp);
	return result;
}

CString CSingleView::GetViewTitle(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x11, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::NextViewTitle(long lPositon, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x12, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPositon, pbstrTitle);
	return result;
}

long CSingleView::PrevViewTitle(long lPosition, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x13, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition, pbstrTitle);
	return result;
}

long CSingleView::SelectView(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x14, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::StartObjectEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x15, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

CString CSingleView::GetObjectTitle(long lPos)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x16, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPos);
	return result;
}

long CSingleView::SaveData()
{
	long result;
	InvokeHelper(0x17, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::AddContextRef(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x18, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleView::ReleaseContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x19, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleView::RestoreContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1a, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleView::GetContext(long* plCtxthandle)
{
	long result;
	static BYTE parms[] =
		VTS_PI4;
	InvokeHelper(0x1b, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		plCtxthandle);
	return result;
}

long CSingleView::NextObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1c, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::PrevObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1d, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::SelectObjectByPath(LPCTSTR szObjectPath)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x1e, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szObjectPath);
	return result;
}

long CSingleView::SelectObjectByPosition(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1f, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase)
{
	long result;
	static BYTE parms[] =
		VTS_UNKNOWN VTS_UNKNOWN VTS_I4;
	InvokeHelper(0x20, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lpunkWbemServices, lpunkClassObject, bExistsInDatabase);
	return result;
}

long CSingleView::CreateInstance(LPCTSTR szClassName)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x21, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szClassName);
	return result;
}

long CSingleView::CreateInstanceOfCurrentClass()
{
	long result;
	InvokeHelper(0x22, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSingleView::OnGetIWbemServices
(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
	m_pActiveXParent->PassThroughGetIWbemServices
		(lpctstrNamespace,
		pvarUpdatePointer,
		pvarServices,
		pvarSC,
		pvarUserCancel);

}

void CSingleView::OnNotifyInstanceCreated(LPCTSTR lpctstrPath)
{
	m_pActiveXParent->OnNotifyInstanceCreated(lpctstrPath);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\treebannertoolbar.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// TreeBannerToolbar.cpp : implementation file
//

#include "precomp.h"
#include "afxpriv.h"
#include "AFXCONV.H"
#include "EventRegEdit.h"
#include "TreeBannerToolbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTreeBannerToolbar

#define INITTOOLTIP  WM_USER + 345

CTreeBannerToolbar::CTreeBannerToolbar()
{
}

CTreeBannerToolbar::~CTreeBannerToolbar()
{
}


BEGIN_MESSAGE_MAP(CTreeBannerToolbar, CToolBar)
	//{{AFX_MSG_MAP(CTreeBannerToolbar)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(INITTOOLTIP, InitTooltip )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTreeBannerToolbar message handlers
CSize CTreeBannerToolbar::GetToolBarSize()
{
	CRect rcButtons;
	CToolBarCtrl &rToolBarCtrl = GetToolBarCtrl();
	int nButtons = rToolBarCtrl.GetButtonCount();
	if (nButtons > 0) {
		CRect rcLastButton;
		rToolBarCtrl.GetItemRect(0, &rcButtons);
		rToolBarCtrl.GetItemRect(nButtons-1, &rcLastButton);
		rcButtons.UnionRect(&rcButtons, &rcLastButton);
	}
	else {
		rcButtons.SetRectEmpty();
	}

	CSize size;
	size.cx = rcButtons.Width();
	size.cy = rcButtons.Height();
	return size;
}

// ***************************************************************************
//
// CTreeBannerToolbar::OnCreate
//
// Description:
//	  Called by the framework after the window is being created but before
//	  the window is shown.
//
// Parameters:
//	  LPCREATESTRUCT lpCreateStruct	Pointer to the structure which contains
//									default parameters.
//
// Returns:
//	  BOOL				0 if continue; -1 if the window should be destroyed.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
int CTreeBannerToolbar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	lpCreateStruct->style = lpCreateStruct->style |
								CBRS_TOOLTIPS | CBRS_FLYBY;
	if (CToolBar::OnCreate(lpCreateStruct) == -1)
		return -1;

	CToolBarCtrl &rToolBarCtrl = GetToolBarCtrl();

	if (!m_ttip.Create(this,TTS_ALWAYSTIP))
		TRACE0("Unable to create tip window.");
	else
	{
		m_ttip.Activate(TRUE);
		rToolBarCtrl.SetToolTips(&m_ttip );
		PostMessage(INITTOOLTIP,0,0);
	}

	return 0;
}

LRESULT CTreeBannerToolbar::InitTooltip(WPARAM, LPARAM)
{
	CToolBarCtrl &rToolBarCtrl = GetToolBarCtrl();

	rToolBarCtrl.EnableButton(ID_BUTTONNEW,FALSE);
	rToolBarCtrl.EnableButton(ID_BUTTONDELETE,FALSE);
	rToolBarCtrl.EnableButton(ID_BUTTONPROPERTIES,FALSE);

	// This is where we want to associate a string with
	// the tool for each button.
	CSize csToolBar = GetToolBarSize();

	#pragma warning( disable :4244 )
	CRect crToolBar(0,0,(int) csToolBar.cx * .3333,csToolBar.cy);
	#pragma warning( default : 4244 )

	GetToolTip().AddTool
		(&rToolBarCtrl,_T("New instance"),&crToolBar,1);

	#pragma warning( disable :4244 )
	crToolBar.SetRect
		((int)csToolBar.cx * .3333,0,(int) csToolBar.cx * .6666,csToolBar.cy);
	#pragma warning( default : 4244 )

	GetToolTip().AddTool
		(&rToolBarCtrl,_T("Properties"),&crToolBar,2);

	#pragma warning( disable :4244 )
	crToolBar.SetRect
		((int) csToolBar.cx * .6666, 0, csToolBar.cx , csToolBar.cy);
 	#pragma warning( default : 4244 )

	GetToolTip().AddTool
		(&rToolBarCtrl,_T("Delete instance"),&crToolBar,3);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\selectview.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_VSELECTVIEW_H__E8A6E161_2B0C_11D1_9652_00C04FD9B15B__INCLUDED_)
#define AFX_VSELECTVIEW_H__E8A6E161_2B0C_11D1_9652_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SelectView.h : header file
//
class CEventRegEditCtrl;
/////////////////////////////////////////////////////////////////////////////
// CSelectView window

class CSelectView : public CComboBox
{
// Construction
public:
	CSelectView();
	void SetActiveXParent(CEventRegEditCtrl *pActiveXParent)
	{m_pActiveXParent = pActiveXParent;}
	void InitContent();
	void ClearContent();
// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectView)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CSelectView();

	// Generated message map functions
protected:
	int m_iMode;
	CEventRegEditCtrl *m_pActiveXParent;
	//{{AFX_MSG(CSelectView)
	afx_msg void OnSelchange();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VSELECTVIEW_H__E8A6E161_2B0C_11D1_9652_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\treebannertoolbar.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_TREEBANNERTOOLBAR_H__5F781752_45A1_11D1_9658_00C04FD9B15B__INCLUDED_)
#define AFX_TREEBANNERTOOLBAR_H__5F781752_45A1_11D1_9658_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TreeBannerToolbar.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTreeBannerToolbar window

class CTreeBannerToolbar : public CToolBar
{
// Construction
public:
	CTreeBannerToolbar();
	CSize GetToolBarSize();
	CToolTipCtrl &GetToolTip() {return m_ttip;}
// Attributes
public:

// Operations
public:
	CToolTipCtrl m_ttip;
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTreeBannerToolbar)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTreeBannerToolbar();

	// Generated message map functions
protected:
	//{{AFX_MSG(CTreeBannerToolbar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	afx_msg LRESULT InitTooltip(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TREEBANNERTOOLBAR_H__5F781752_45A1_11D1_9658_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\treecwnd.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// TreeCwnd.cpp : implementation file
//

#include "precomp.h"
#include "EventRegEdit.h"
#include "TreeCwnd.h"
#include "ClassInstanceTree.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define TREEFRAMETREECHILD 2

/////////////////////////////////////////////////////////////////////////////
// CTreeCwnd

CTreeCwnd::CTreeCwnd()
{
	m_pTree = NULL;
}

CTreeCwnd::~CTreeCwnd()
{
}


BEGIN_MESSAGE_MAP(CTreeCwnd, CWnd)
	//{{AFX_MSG_MAP(CTreeCwnd)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTreeCwnd message handlers

int CTreeCwnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO: Add your specialized creation code here
	m_pTree = new CClassInstanceTree;

	if (!m_pTree)
	{

		return -1;
	}

	m_pTree->SetActiveXParent(m_pActiveXParent);

	GetClientRect(&m_crTree);
	m_crTree.DeflateRect(1,1);

	m_pTree->Create
		(	WS_CHILD | WS_VISIBLE |  CS_DBLCLKS |
			TVS_SHOWSELALWAYS | TVS_HASLINES |
			TVS_LINESATROOT | TVS_HASBUTTONS,
			m_crTree,
			this ,
			TREEFRAMETREECHILD);

	return 0;
}

void CTreeCwnd::OnDestroy()
{
	CWnd::OnDestroy();

	// TODO: Add your message handler code here
	if (m_pTree && m_pTree->GetSafeHwnd())
	{
		m_pTree->DestroyWindow();
		delete m_pTree;
		m_pTree = NULL;
	}
	else if (m_pTree)
	{
		delete m_pTree;
		m_pTree = NULL;
	}

}

void CTreeCwnd::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	// TODO: Add your message handler code here

	CRect rcFrame(m_crTree);

	rcFrame.InflateRect(1,1,1,1);

	dc.Draw3dRect	(rcFrame.left,
					rcFrame.top,
					rcFrame.right,
					rcFrame.bottom,
					GetSysColor(COLOR_3DSHADOW),
					GetSysColor(COLOR_3DHILIGHT));

	// Do not call CWnd::OnPaint() for painting messages
}

void CTreeCwnd::InitContent()
{
	m_pTree->InitContent();
}

void CTreeCwnd::ClearContent()
{
	m_pTree->ClearContent();
}

void CTreeCwnd::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	// TODO: Add your message handler code here
	m_crTree.left = 1;
	m_crTree.top = 1;
	m_crTree.bottom = cy - 1;
	m_crTree.right = cx - 1;
	m_pTree->MoveWindow(&m_crTree);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\singleview.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SINGLEVIEW_H__0E705383_0307_11D2_8832_00104B2AFB46__INCLUDED_)
#define AFX_SINGLEVIEW_H__0E705383_0307_11D2_8832_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CSingleView wrapper class
class CEventRegEditCtrl;

class CSingleView : public CWnd
{
protected:
	DECLARE_DYNCREATE(CSingleView)
	DECLARE_EVENTSINK_MAP( )
public:
	CEventRegEditCtrl *m_pActiveXParent;
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x2745e5f5, 0xd234, 0x11d0, { 0x84, 0x7a, 0x0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetReadyState();
	long GetPropertyFilter();
	void SetPropertyFilter(long);

// Operations
public:
	void OnGetIWbemServices
		(	LPCTSTR lpctstrNamespace, 
			VARIANT FAR* pvarUpdatePointer, 
			VARIANT FAR* pvarServices, 
			VARIANT FAR* pvarSC, 
			VARIANT FAR* pvarUserCancel); 

	void OnNotifyInstanceCreated(LPCTSTR lpctstrPath);
	long GetEditMode();
	void SetEditMode(long lEditMode);
	long RefreshView();
	void NotifyWillShow();
	long DeleteInstance();
	void ExternInstanceCreated(LPCTSTR szObjectPath);
	void ExternInstanceDeleted(LPCTSTR szObjectPath);
	long QueryCanCreateInstance();
	long QueryCanDeleteInstance();
	long QueryNeedsSave();
	long QueryObjectSelected();
	CString GetObjectPath(long lPosition);
	long StartViewEnumeration(long lWhere);
	long GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp);
	CString GetViewTitle(long lPosition);
	long NextViewTitle(long lPositon, BSTR* pbstrTitle);
	long PrevViewTitle(long lPosition, BSTR* pbstrTitle);
	long SelectView(long lPosition);
	long StartObjectEnumeration(long lWhere);
	CString GetObjectTitle(long lPos);
	long SaveData();
	long AddContextRef(long lCtxtHandle);
	long ReleaseContext(long lCtxtHandle);
	long RestoreContext(long lCtxtHandle);
	long GetContext(long* plCtxthandle);
	long NextObject(long lPosition);
	long PrevObject(long lPosition);
	long SelectObjectByPath(LPCTSTR szObjectPath);
	long SelectObjectByPosition(long lPosition);
	long SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase);
	long CreateInstance(LPCTSTR szClassName);
	long CreateInstanceOfCurrentClass();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SINGLEVIEW_H__0E705383_0307_11D2_8832_00104B2AFB46__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\treecwnd.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_TREECWND_H__5F781753_45A1_11D1_9658_00C04FD9B15B__INCLUDED_)
#define AFX_TREECWND_H__5F781753_45A1_11D1_9658_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TreeCwnd.h : header file
//
class CClassInstanceTree;
class CEventRegEditCtrl;
/////////////////////////////////////////////////////////////////////////////
// CTreeCwnd window

class CTreeCwnd : public CWnd
{
// Construction
public:
	CTreeCwnd();

// Attributes
public:

// Operations
public:
	void InitContent();
	void ClearContent();
	void SetActiveXParent(CEventRegEditCtrl *pActiveXParent)
	{m_pActiveXParent = pActiveXParent;}
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTreeCwnd)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTreeCwnd();

	// Generated message map functions
protected:
	CEventRegEditCtrl *m_pActiveXParent;
	CClassInstanceTree *m_pTree;
	CRect m_crTree;
	//{{AFX_MSG(CTreeCwnd)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TREECWND_H__5F781753_45A1_11D1_9658_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\treeframe.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// TreeFrame.cpp : implementation file
//

#include "precomp.h"
#include "wbemidl.h"
#include "MsgDlgExterns.h"
#include "util.h"
#include "resource.h"
#include "PropertiesDialog.h"
#include "EventRegEdit.h"
#include "EventRegEditCtl.h"
#include "TreeFrame.h"
#include "TreeFrameBanner.h"
#include "TreeCwnd.h"
#include "ClassInstanceTree.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define TREEFRAMEBANNERCHILD 1
#define TREEFRAMETREECHILD 2

#define BANNERADDTOFONTHEIGHT 19
/////////////////////////////////////////////////////////////////////////////
// CTreeFrame

CTreeFrame::CTreeFrame()
{
	m_pBanner = NULL;
	m_pTree = NULL;
	m_pActiveXParent = NULL;
}

CTreeFrame::~CTreeFrame()
{
}


BEGIN_MESSAGE_MAP(CTreeFrame, CWnd)
	//{{AFX_MSG_MAP(CTreeFrame)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTreeFrame message handlers

int CTreeFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{


	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO: Add your specialized creation code here
	m_pBanner = new CTreeFrameBanner;

	if (!m_pBanner)
	{

		return -1;
	}

	m_pTree = new CTreeCwnd;

	if (!m_pTree)
	{

		return -1;
	}


	m_pTree->SetActiveXParent(m_pActiveXParent);

	CRect rect;
	GetClientRect(&rect);

	SetChildControlGeometry(rect.Width(),rect.Height());

/*	m_crBanner = rect;
	m_crTree = rect;
	int nBannerHeight = (m_pActiveXParent->m_tmFont.tmHeight) + 16;

	if (m_crBanner.bottom - m_crBanner.top > nBannerHeight)
	{
		m_crBanner.bottom = nBannerHeight;
		m_crTree.top = m_crBanner.bottom;
		m_crTree.bottom = rect.bottom;
	}
	else
	{
		m_crBanner.bottom = m_crBanner.bottom - m_crBanner.top;
		m_crTree.top = m_crBanner.bottom;
		m_crTree.bottom = m_crBanner.bottom;
	}
*/
	//m_crTree.DeflateRect(1,1);

	m_pBanner->Create
		(	NULL,_T("TreeFrameBanner"),WS_CHILD|WS_VISIBLE,
			m_crBanner,
			this,
			TREEFRAMEBANNERCHILD);

	m_pTree->Create
		(	NULL, _T("MyTreeCwnd"),WS_CHILD | WS_VISIBLE ,
			m_crTree,
			this ,
			TREEFRAMETREECHILD);


	return 0;
}

BOOL CTreeFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Add your specialized code here and/or call the base class
	cs.style = WS_CHILD | WS_VISIBLE;
	return CWnd::PreCreateWindow(cs);
}

void CTreeFrame::OnDestroy()
{
	CWnd::OnDestroy();
	if (m_pBanner && m_pBanner->GetSafeHwnd())
	{
		m_pBanner->DestroyWindow();
		delete m_pBanner;
		m_pBanner = NULL;
	}
	else if (m_pBanner)
	{
		delete m_pBanner;
		m_pBanner = NULL;
	}

	if (m_pTree && m_pTree->GetSafeHwnd())
	{
		m_pTree->DestroyWindow();
		delete m_pTree;
		m_pTree = NULL;
	}
	else if (m_pTree)
	{
		delete m_pTree;
		m_pTree = NULL;
	}

	// TODO: Add your message handler code here

}

void CTreeFrame::InitContent()
{
	m_pBanner->InitContent();
	m_pTree->InitContent();
}

void CTreeFrame::ClearContent()
{
	m_pBanner->ClearContent();
	m_pTree->ClearContent();

}

void CTreeFrame::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	// TODO: Add your message handler code here
	SetChildControlGeometry(cx,cy);
	m_pBanner->MoveWindow(m_crBanner);
	m_pTree->MoveWindow(m_crTree);
}

void CTreeFrame::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	// TODO: Add your message handler code here
	CRect rcFrame(m_crTree);

	//rcFrame.InflateRect(1,1,1,1);

	dc.Draw3dRect	(rcFrame.left,
					rcFrame.top,
					rcFrame.right,
					rcFrame.bottom,
					GetSysColor(COLOR_3DSHADOW),
					GetSysColor(COLOR_3DHILIGHT));

	m_pBanner->UpdateWindow();
	m_pBanner->RedrawWindow();

	m_pTree->UpdateWindow();
	m_pTree->RedrawWindow();

	// Do not call CWnd::OnPaint() for painting messages
}

void CTreeFrame::SetChildControlGeometry(int cx, int cy)
{

	CRect rect;
	GetClientRect(&rect);

	m_crBanner = rect;
	m_crTree = rect;
	int nBannerHeight = (m_pActiveXParent->m_tmFont.tmHeight) + BANNERADDTOFONTHEIGHT;

	if (m_crBanner.bottom - m_crBanner.top > nBannerHeight)
	{
		m_crBanner.bottom = nBannerHeight;
		m_crTree.top = m_crBanner.bottom;
		m_crTree.bottom = rect.bottom;
	}
	else
	{
		m_crBanner.bottom = m_crBanner.bottom - m_crBanner.top;
		m_crTree.top = m_crBanner.bottom;
		m_crTree.bottom = m_crBanner.bottom;
	}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\treeframebanner.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// TreeFrameBanner.cpp : implementation file
//

#include "precomp.h"
#include "Resource.h"
#include "wbemidl.h"
#include "MsgDlgExterns.h"
#include "util.h"
#include "resource.h"
#include "PropertiesDialog.h"
#include "EventRegEdit.h"
#include "EventRegEditCtl.h"
#include "ClassInstanceTree.h"
#include "SelectView.h"
#include "TreeFrameBanner.h"
#include "TreeFrame.h"
#include "TreeBannerToolbar.h"
#include "TreeCwnd.h"
#include "nsentry.h"
#include "regeditnavnsentry.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define CX_TOOLBAR_MARGIN 7
#define CY_TOOLBAR_MARGIN 7
#define CX_TOOLBAR_OFFSET 3
#define CY_TOOLBAR_OFFSET 1

#define SELECT_VIEW_LEFT 0
#define SELECT_VIEW_RIGHT 80
#define SELECT_VIEW_TOP 5
#define SELECT_VIEW_BOTTOM 100

#define NSENTRY_LEFT 0
#define NSENTRY_RIGHT 100
#define NSENTRY_TOP 5


#define SELECTVIEWCHILD 1
#define NSENTRYCHILD 1

#define nSideMargin 0
#define nTopMargin 5
#define nTBTopMargin 7


/////////////////////////////////////////////////////////////////////////////
// CTreeFrameBanner

CTreeFrameBanner::CTreeFrameBanner()
{

	m_pSelectView = NULL;
	m_pcnseNamespace = NULL;

}

CTreeFrameBanner::~CTreeFrameBanner()
{
}


BEGIN_MESSAGE_MAP(CTreeFrameBanner, CWnd)
	//{{AFX_MSG_MAP(CTreeFrameBanner)
	ON_WM_PAINT()
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_COMMAND(ID_BUTTONPROPERTIES, OnButtonproperties)
	ON_COMMAND(ID_BUTTONNEW, OnButtonnew)
	ON_COMMAND(ID_BUTTONDELETE, OnButtondelete)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTreeFrameBanner message handlers

void CTreeFrameBanner::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	COLORREF dwBackColor = GetSysColor(COLOR_3DFACE);
	COLORREF crWhite = RGB(255,255,255);
	COLORREF crGray = GetSysColor(COLOR_3DHILIGHT);
	COLORREF crDkGray = GetSysColor(COLOR_3DSHADOW);
	COLORREF crBlack = GetSysColor(COLOR_WINDOWTEXT);


	CBrush br3DFACE(dwBackColor);
	dc.FillRect(&dc.m_ps.rcPaint, &br3DFACE);


	CTreeFrame *pParent =
		reinterpret_cast<CTreeFrame *>(GetParent());
	CEventRegEditCtrl *pActiveXParent =
		pParent->m_pActiveXParent;

	// Must do update to be able to over draw the border area.
	m_pToolBar->UpdateWindow();
	m_pSelectView->RedrawWindow();
	m_pcnseNamespace->RedrawWindow();
	//pParent->m_pTree->UpdateWindow(); last
	//pParent->m_pTree->RedrawWindow(); last


	dc.SelectObject( &(pActiveXParent->m_cfFont) );

	dc.SetBkMode( TRANSPARENT );

	CRect crClip;
	CRgn crRegion;
	int nReturn = dc.GetClipBox( &crClip);

	crClip.DeflateRect(0,0,10,0);
	crRegion.CreateRectRgnIndirect( &crClip );
	dc.SelectClipRgn( &crRegion );

	if (m_csMode.GetLength() > 0)
	{
		CString csOut = _T(" in: ");
		CTreeFrame *pParent =
		reinterpret_cast<CTreeFrame *>(GetParent());
		CEventRegEditCtrl *pActiveXParent =
		pParent->m_pActiveXParent;
		int nFont = pActiveXParent->m_tmFont.tmHeight;
		dc.TextOut( m_crSelectView.right, //dc.m_ps.rcPaint.top + 12,
					dc.m_ps.rcPaint.top + (nFont - 4), csOut, csOut.GetLength() );
	}

	crRegion.DeleteObject( );

	dc.SetBkMode( OPAQUE );

	crClip.InflateRect(0,0,10,0);
	crRegion.CreateRectRgnIndirect( &crClip );
	dc.SelectClipRgn( &crRegion );

	DrawFrame(&dc);

	crRegion.DeleteObject( );

	// Do not call CWnd::OnPaint() for painting messages
}

void CTreeFrameBanner::DrawFrame(CPaintDC* pdc)
{

	CRect rcFrame(pdc->m_ps.rcPaint);
	rcFrame.DeflateRect(nSideMargin,nTopMargin);

	pdc->Draw3dRect(rcFrame.left,
					rcFrame.top - 2,
					rcFrame.right,
					rcFrame.bottom -2,
					GetSysColor(COLOR_3DSHADOW),
					GetSysColor(COLOR_3DHILIGHT));

}

void CTreeFrameBanner::InitContent()
{
	CTreeFrame *pParent =
		reinterpret_cast<CTreeFrame *>(GetParent());
	CEventRegEditCtrl *pActiveXParent =
		pParent->m_pActiveXParent;

	m_csMode = pActiveXParent->GetCurrentModeString();

	//UpdateWindow(); last
	//RedrawWindow(); last
}

void CTreeFrameBanner::ClearContent()
{
	m_csMode = "";
}

int CTreeFrameBanner::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	CTreeFrame *pParent =
		reinterpret_cast<CTreeFrame *>(GetParent());
	CEventRegEditCtrl *pActiveXParent =
		pParent->m_pActiveXParent;
	pActiveXParent->m_pTreeFrameBanner = this;

	// TODO: Add your specialized creation code here
	m_pToolBar = new CTreeBannerToolbar;
	if(m_pToolBar->Create
		(this, WS_CHILD | WS_VISIBLE  | CBRS_SIZE_FIXED) == -1)
	{
		return FALSE;
	}

	m_pToolBar->LoadToolBar( MAKEINTRESOURCE(IDR_TOOLBARTREEFRAME) );


	CRect cr;
	GetClientRect(&cr);

	SetChildControlGeometry(cr.Width(),cr.Height());


	m_pSelectView = new CSelectView;
	BOOL bReturn =
		m_pSelectView->Create
		(	CBS_DROPDOWNLIST|WS_CHILD|WS_VISIBLE,
			m_crSelectView,
			this,
			SELECTVIEWCHILD);

	if (!bReturn)
	{
		CString csUserMsg =
							_T("Cannot create SelectView combo box.");
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
		return 0;
	}

	m_pSelectView->CWnd::SetFont ( &pActiveXParent->m_cfFont , FALSE);
	m_pSelectView->SetActiveXParent(pActiveXParent);


	m_pcnseNamespace = new CRegEditNSEntry;


	if (m_pcnseNamespace->Create(NULL, NULL, WS_VISIBLE | WS_CHILD, m_crNamespace,
		this, NSENTRYCHILD, NULL) == 0)
	{
		CString csUserMsg =
							_T("Cannot create SelectView combo box.");
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
		return 0;
	}

	m_pcnseNamespace->CWnd::SetFont ( &pActiveXParent->m_cfFont , FALSE);
	m_pcnseNamespace->SetLocalParent(pActiveXParent);

	return 0;
}

void CTreeFrameBanner::OnDestroy()
{
	CWnd::OnDestroy();

	if (m_pSelectView)
	{
		m_pSelectView->DestroyWindow();
		delete m_pSelectView;
		m_pSelectView=NULL;
	}

	if (m_pcnseNamespace)
	{
		m_pcnseNamespace->DestroyWindow();
		delete m_pcnseNamespace;
		m_pcnseNamespace=NULL;
	}


	delete m_pToolBar;
	m_pToolBar;
	// TODO: Add your message handler code here

}

int CTreeFrameBanner::GetTextLength(CString *pcsText)
{

	CTreeFrame *pParent =
		reinterpret_cast<CTreeFrame *>(GetParent());
	CEventRegEditCtrl *pActiveXParent =
		pParent->m_pActiveXParent;

	CSize csLength;
	int nReturn;

	CDC *pdc = CWnd::GetDC( );

	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont* pOldFont = pdc -> SelectObject( &(pActiveXParent -> m_cfFont) );
	csLength = pdc-> GetTextExtent( *pcsText );
	nReturn = csLength.cx;
	pdc -> SelectObject(pOldFont);

	ReleaseDC(pdc);
	return nReturn;

}

void CTreeFrameBanner::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	// TODO: Add your message handler code here
	SetChildControlGeometry(cx, cy);
	m_pToolBar->MoveWindow( m_rToolBar);
	m_pSelectView->MoveWindow(m_crSelectView);
	m_pcnseNamespace->MoveWindow(m_crNamespace);

}

void CTreeFrameBanner::SetChildControlGeometry(int cx, int cy)
{
	int nTextLength = GetTextLength(&m_csMode);
	CSize csToolBar = m_pToolBar->GetToolBarSize();

	CRect rBannerRect = CRect(	0,
							0 + nTopMargin ,
							cx ,
							cy - nTopMargin);


	rBannerRect.NormalizeRect();

	//int nModeX = rBannerRect.TopLeft().x + nTextLength + 8;
	int nModeX = 0;

	int nToolBarX = max(nModeX + 3,
						rBannerRect.TopLeft().x +
							rBannerRect.Width() - (csToolBar.cx + 5));

	int nNameSPaceXMax = nToolBarX - 2;

	#pragma warning( disable :4244 )
	int nToolBarY = rBannerRect.TopLeft().y +
					((rBannerRect.Height() - csToolBar.cy) * .5);
	#pragma warning( default : 4244 )


	m_crSelectView.left = min(cx,SELECT_VIEW_LEFT);
	m_crSelectView.right = min(SELECT_VIEW_RIGHT,cx);
	m_crSelectView.top = min(cy,SELECT_VIEW_TOP);
	m_crSelectView.bottom = SELECT_VIEW_BOTTOM;

	m_rToolBar = CRect(nToolBarX,
				nToolBarY - nTBTopMargin,
				rBannerRect.BottomRight().x  + 1,
				nToolBarY + csToolBar.cy + nTopMargin);

	CString csOut = _T(" in: ");
	nTextLength = GetTextLength(&csOut);

	m_crNamespace = CRect(	min (cx,m_crSelectView.right + nTextLength),
							rBannerRect.TopLeft().y - 3 ,
							min(cx,m_rToolBar.left - 1),
							rBannerRect.BottomRight().y + 0);

	/*m_crNamespace.left = min (cx,m_crSelectView.right + nTextLength);
	//m_crNamespace.top = min (cy,m_crSelectView.top);
	m_crNamespace.top = min (cy,0);
	m_crNamespace.bottom = cy;
	m_crNamespace.right = min(cx,m_rToolBar.left - 4);*/

}

void CTreeFrameBanner::EnableButtons
(BOOL bNew, BOOL bProperties, BOOL bDelete)
{
	CToolBarCtrl &rToolBarCtrl = m_pToolBar->GetToolBarCtrl();
	rToolBarCtrl.EnableButton(ID_BUTTONNEW,bNew);
	rToolBarCtrl.EnableButton(ID_BUTTONPROPERTIES,bProperties);
	rToolBarCtrl.EnableButton(ID_BUTTONDELETE,bDelete);
}

void CTreeFrameBanner::GetButtonStates(BOOL &bNew,
										BOOL &bProperties,
										BOOL &bDelete)
{
	CToolBarCtrl &rToolBarCtrl = m_pToolBar->GetToolBarCtrl();
	bNew = rToolBarCtrl.IsButtonEnabled(ID_BUTTONNEW);
	bProperties = rToolBarCtrl.IsButtonEnabled(ID_BUTTONPROPERTIES);
	bDelete = rToolBarCtrl.IsButtonEnabled(ID_BUTTONDELETE);
}

void CTreeFrameBanner::SetPropertiesTooltip(CString &csTooltip)
{
	CToolBarCtrl &rToolBarCtrl = m_pToolBar->GetToolBarCtrl();
	CSize csToolBar = 	m_pToolBar->GetToolBarSize();

	CRect crToolBar;
	#pragma warning( disable :4244 )
	crToolBar.SetRect
		((int)csToolBar.cx * .3333,0,(int) csToolBar.cx * .6666,csToolBar.cy);
	#pragma warning( default : 4244 )

	m_pToolBar->GetToolTip().DelTool
		(&rToolBarCtrl,2);

	m_pToolBar->GetToolTip().AddTool
		(&rToolBarCtrl,csTooltip,&crToolBar,2);
}

void CTreeFrameBanner::OnButtonproperties()
{
	// TODO: Add your command handler code here
	CTreeFrame *pParent =
		reinterpret_cast<CTreeFrame *>(GetParent());
	CEventRegEditCtrl *pActiveXParent =
		pParent->m_pActiveXParent;
	pActiveXParent->ButtonTreeProperties();
	pActiveXParent->OnActivateInPlace(TRUE,NULL);
	pActiveXParent->m_pTree->SetFocus();
}

void CTreeFrameBanner::OnButtonnew()
{
	// TODO: Add your command handler code here
	CTreeFrame *pParent =
		reinterpret_cast<CTreeFrame *>(GetParent());
	CEventRegEditCtrl *pActiveXParent =
		pParent->m_pActiveXParent;
	pActiveXParent->ButtonNew();
	pActiveXParent->OnActivateInPlace(TRUE,NULL);
	pActiveXParent->m_pTree->SetFocus();
}

void CTreeFrameBanner::OnButtondelete()
{
	// TODO: Add your command handler code here
	CTreeFrame *pParent =
		reinterpret_cast<CTreeFrame *>(GetParent());
	CEventRegEditCtrl *pActiveXParent =
		pParent->m_pActiveXParent;
	pActiveXParent->ButtonDelete();
	pActiveXParent->OnActivateInPlace(TRUE,NULL);
	pActiveXParent->m_pTree->SetFocus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\treeframe.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_TREEFRAME_H__D126B0C1_4032_11D1_9656_00C04FD9B15B__INCLUDED_)
#define AFX_TREEFRAME_H__D126B0C1_4032_11D1_9656_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TreeFrame.h : header file
//
class CEventRegEditCtrl;
class CTreeFrameBanner;
class CClassInstanceTree;
class CTreeCwnd;


/////////////////////////////////////////////////////////////////////////////
// CTreeFrame window

class CTreeFrame : public CWnd
{
// Construction
public:
	CTreeFrame();
	void SetActiveXParent(CEventRegEditCtrl *pActiveXParent)
	{m_pActiveXParent = pActiveXParent;}
	void InitContent();
	void ClearContent();
// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTreeFrame)
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTreeFrame();

	// Generated message map functions
protected:
	int m_iMode;
	CEventRegEditCtrl *m_pActiveXParent;
	CTreeFrameBanner *m_pBanner;
	CTreeCwnd *m_pTree;

	CRect m_crBanner;
	CRect m_crTree;
	void SetChildControlGeometry(int cx, int cy);
	friend class CTreeFrameBanner;
	//{{AFX_MSG(CTreeFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TREEFRAME_H__D126B0C1_4032_11D1_9656_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\consumer.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __CCONSUMER__
#define __CCONSUMER__
#include "wbemprov.h"
#include "EventList.h"
#include "ContainerDlg.h"
#pragma once

class CConsumer : public IWbemUnboundObjectSink
{
public:
	CConsumer();
	~CConsumer();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHOD(IndicateToConsumer)(IWbemClassObject *pLogicalConsumer,
									long lNumObjects,
									IWbemClassObject **ppObjects);

private:

	DWORD m_cRef;
	CEventList	*m_EventList;
    CContainerDlg *m_dlg;
};
#endif __CCONSUMER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\treeframebanner.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_TREEFRAMEBANNER_H__9B55E0E3_43F2_11D1_9656_00C04FD9B15B__INCLUDED_)
#define AFX_TREEFRAMEBANNER_H__9B55E0E3_43F2_11D1_9656_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TreeFrameBanner.h : header file
//
class CEventRegEditCtrl;
class CTreeBannerToolbar;
class CSelectView;
class CRegEditNSEntry;
/////////////////////////////////////////////////////////////////////////////
// CTreeFrameBanner window

class CTreeFrameBanner : public CWnd
{
// Construction
public:
	CTreeFrameBanner();
	void InitContent();
	void ClearContent();
	void EnableButtons(BOOL bNew, BOOL bProperties, BOOL bDelete);
	void GetButtonStates(BOOL &bNew, BOOL &bProperties, BOOL &bDelete);
	void SetPropertiesTooltip(CString &csTooltip);
// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTreeFrameBanner)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTreeFrameBanner();

	// Generated message map functions
protected:
	void DrawFrame(CPaintDC* pdc);
	CString m_csMode;
	CTreeBannerToolbar *m_pToolBar;
	CSelectView *m_pSelectView;
	CRegEditNSEntry *m_pcnseNamespace;
	int GetTextLength(CString *pcsText);
	void SetChildControlGeometry(int cx, int cy);
	CRect m_rToolBar;
	CRect m_crSelectView;
	CRect m_crNamespace;
	//{{AFX_MSG(CTreeFrameBanner)
	afx_msg void OnPaint();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnButtonproperties();
	afx_msg void OnButtonnew();
	afx_msg void OnButtondelete();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CEventRegEditCtrl;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TREEFRAMEBANNER_H__9B55E0E3_43F2_11D1_9656_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\consumer.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "Consumer.h"
#include <objbase.h>
#include "Container.h"
#include "resource.h"		// main symbols

extern CContainerApp theApp;

CConsumer::CConsumer()
{
	m_cRef = 0L;
	m_EventList = NULL;

}


CConsumer::~CConsumer()
{
}


STDMETHODIMP CConsumer::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemUnboundObjectSink)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CConsumer::AddRef(void)
{
    TRACE(_T("add consumer %d\n"), m_cRef);
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CConsumer::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    TRACE(_T("consumer %d\n"), m_cRef);

    theApp.m_pConsumer = NULL;
	theApp.EvalQuitApp();
    delete this;
    return 0L;
}


STDMETHODIMP CConsumer::IndicateToConsumer(IWbemClassObject *pLogicalConsumer,
											long lNumObjects,
											IWbemClassObject **ppObjects)
{
	CContainerDlg *pDlg = NULL;
	CEventList *pEventList = NULL;

	TRACE(_T("Indicate() called\n"));

	// see if I should 'simulate' launching me.
	theApp.EvalStartApp();

	// grab some convenient ptrs into the dlg.
	CContainerApp *winApp = (CContainerApp *)AfxGetApp();
	if(winApp)
	{
		pDlg = (CContainerDlg *)winApp->m_pMainWnd;

		if(pDlg)
		{
			pEventList = &pDlg->m_EventList;
			if(pEventList)
			{
				// walk though the classObjects...
				for(int i = 0; i < lNumObjects; i++)
				{
					// output the buffer.
					pEventList->AddWbemEvent(pLogicalConsumer,
												ppObjects[i]);

					// are there REALLY events in there now?
					pDlg->UpdateCounter();

				} // endfor
			}
		}
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\util.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  util.cpp
//
//  Module: RegEvent ActiveX Control
//
//
//***************************************************************************
#include "precomp.h"
//#include <OBJIDL.H>
#include <nddeapi.h>
#include <initguid.h>
#include "wbemidl.h"
#include <genlex.h>
#include "MsgDlgExterns.h"
#include <opathlex.h>
#include <objpath.h>
#include "util.h"
#include "logindlg.h"



// *************************************************************************
// Safe array utilities
//
// VT_BSTR for strings
SCODE MakeSafeArray(SAFEARRAY FAR ** pRet, VARTYPE vt, int iLen)
{
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iLen;
    *pRet = SafeArrayCreate(vt,1, rgsabound);
    return (*pRet == NULL) ? 0x80000001 : S_OK;
}

SCODE PutStringInSafeArray
(SAFEARRAY FAR * psa,CString *pcs, int iIndex)
{
    long ix[2];
    ix[1] = 0;
    ix[0] = iIndex;
	long i = iIndex;
    HRESULT hResult = SafeArrayPutElement(psa,&i,pcs -> AllocSysString());
	return GetScode(hResult);
}

BOOL GetErrorObjectText
(IWbemClassObject *pErrorObject, CString &rcsDescription)
{
	if (!pErrorObject)
	{
		rcsDescription.Empty();
		return FALSE;
	}

	CString csProp = _T("Description");
	CString csDescription = GetBSTRProperty(pErrorObject,&csProp);
	if (csDescription.IsEmpty() || csDescription.GetLength() == 0)
	{
		rcsDescription.Empty();
		return FALSE;
	}
	else
	{
		rcsDescription = csDescription;
		return TRUE;
	}


}

CString GetBSTRProperty
(IWbemServices * pProv, IWbemClassObject * pInst,
 CString *pcsProperty)

{
	SCODE sc;

    VARIANTARG var;
	VariantInit(&var);
	long lType;
	long lFlavor;

	BSTR bstrTemp =  pcsProperty -> AllocSysString ( );
    sc = pInst->Get(bstrTemp,0,&var,&lType,&lFlavor);
	::SysFreeString(bstrTemp);

	if(sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get property value ");
		csUserMsg += _T(" for object ");
		csUserMsg += GetIWbemFullPath (pInst);
		ErrorMsg
				(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 9);
		return "";
	}


	CString csOut;
	if (var.vt == VT_BSTR)
		csOut = var.bstrVal;

	VariantClear(&var);
	return csOut;
}


//***************************************************************************
//
// CreateSimpleClass
//
// Purpose: This creates a new class with a class name and parent.
//
//***************************************************************************

IWbemClassObject *CreateSimpleClass
(IWbemServices * pProv, CString *pcsNewClass, CString *pcsParentClass, int &nError,
CString &csError )
{
	IWbemClassObject *pNewClass = NULL;
    IWbemClassObject *pParentClass = NULL;
	IWbemClassObject *pErrorObject = NULL;

   	SCODE sc;

	BSTR bstrTemp = pcsNewClass->AllocSysString();
	sc = pProv -> GetObject
		(bstrTemp  ,0,NULL, &pNewClass,NULL);
	::SysFreeString(bstrTemp);

	if (sc == S_OK)
	{
		pNewClass->Release();
		CString csUserMsg =
			_T("An error occured creating the class ") + *pcsNewClass;
		csUserMsg +=
			_T(":  Class ") + *pcsNewClass;
		csUserMsg += _T(" already exists");
		ErrorMsg
			(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 9);

		return NULL;

	}

	pcsParentClass =
		pcsParentClass->GetLength()==0? NULL: pcsParentClass;

	if (pcsParentClass)
	{
		BSTR bstrTemp = pcsParentClass->AllocSysString();
		sc = pProv -> GetObject
			(bstrTemp,0,NULL, &pParentClass,NULL);
		::SysFreeString(bstrTemp);
	}
	else
	{
		sc = pProv -> GetObject
			(NULL,0,NULL, &pParentClass,NULL);

	}


	if (sc != S_OK)
	{
		CString csUserMsg =
			_T("An error occured creating the class ") + *pcsNewClass;
		csUserMsg +=
			_T(":  Cannot create the new class because the parent class object \"") + *pcsParentClass + _T("\" does not exist.");

		ErrorMsg
			(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 8);
		ReleaseErrorObject(pErrorObject);
		return NULL;
	}

	ReleaseErrorObject(pErrorObject);

	if (pcsParentClass)
	{
		sc = pParentClass->SpawnDerivedClass(0,&pNewClass);
	}
	else
	{
		pNewClass = pParentClass;
		pNewClass->AddRef();
		sc = S_OK;
	}

	if (sc != S_OK)
	{
		pParentClass->Release();
		CString csUserMsg =
			_T("An error occured creating the class ") + *pcsNewClass;
		if (pcsParentClass)
		{
			csUserMsg +=
				_T(":  Cannot spawn derived class of ") + *pcsParentClass;
		}
		else
		{
			csUserMsg +=
				_T(":  Cannot spawn derived class");
		}

		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 9);

		return NULL;
	}

	pParentClass->Release();

	CString csTmp;

	// Init class __Class Property
	csTmp = L"__Class";
	SetProperty (pProv, pNewClass, &csTmp,pcsNewClass );

	pErrorObject = NULL;

	sc = pProv->PutClass(pNewClass,0,NULL,NULL);

	if (sc != S_OK)
	{
		CString csUserMsg=
		_T("An error occured creating the class ") + *pcsNewClass;
		csUserMsg += _T(":  Cannot PutClass on ") + *pcsNewClass;
		ErrorMsg
			(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 8);
		ReleaseErrorObject(pErrorObject);
		return NULL;
	}
	else
	{
		ReleaseErrorObject(pErrorObject);
		pNewClass->Release();
		pNewClass = NULL;
		BSTR bstrTemp = pcsNewClass->AllocSysString();
		sc = pProv -> GetObject
		( bstrTemp ,0,NULL,&pNewClass,NULL);
		::SysFreeString(bstrTemp);

		if (sc != S_OK)
		{
			CString csUserMsg=
					_T("An error occured creating the class ") + *pcsNewClass;
			csUserMsg +=
					_T(":  Cannot get the new class.\"") ;

			ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 21);
			ReleaseErrorObject(pErrorObject);
			return NULL;
		}
		ReleaseErrorObject(pErrorObject);
		return pNewClass;
	}
}

//***************************************************************************
//
// DeleteAClass
//
// Purpose: This deletes a class.
//
//***************************************************************************
BOOL DeleteAClass
(IWbemServices * pProv, CString *pcsClass)
{
	SCODE sc;
	IWbemClassObject *pErrorObject = NULL;

	BSTR bstrTemp = pcsClass->AllocSysString();
	sc =  pProv -> DeleteClass(bstrTemp,0,NULL,NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		CString csUserMsg =
						_T("Cannot delete class ") + *pcsClass;

		ErrorMsg
			(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
		ReleaseErrorObject(pErrorObject);
		return FALSE;
	}
	else
	{
		ReleaseErrorObject(pErrorObject);

		return TRUE;
	}
}

//***************************************************************************
//
// ReparentAClass
//
// Purpose: Clone a class and change its superclass..
//
//***************************************************************************
IWbemClassObject *ReparentAClass
(IWbemServices * pProv, IWbemClassObject *pimcoParent, IWbemClassObject *pimcoChild)
{

	IWbemClassObject *pimcoClone = NULL;
	IWbemClassObject *pErrorObject = NULL;
	SCODE sc;

	sc = pimcoChild -> Clone(&pimcoClone);
	if (sc != S_OK)
	{
		CString csUserMsg =
						_T("Cannot clone class ");
		CString csProp = _T("__Class");
		CString csClass;
		csClass = ::GetProperty(pimcoChild,&csProp);
		csUserMsg += csClass;
		ErrorMsg
			(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 10);
		return FALSE;
	}


	CString csProp = _T("__Class");
	CString csParentClass;
	if (pimcoParent)
	{
		csParentClass = ::GetProperty(pimcoParent,&csProp);
	}
	else
		csParentClass = "";

	csProp = _T("__SuperClass");
	BOOL bReturn = ::SetProperty (pProv, pimcoClone, &csProp, &csParentClass);

	if (bReturn)
	{
		sc = pProv -> PutClass(pimcoClone, 0, NULL,NULL);
		if (sc != S_OK)
		{
			CString csUserMsg =
							_T("Cannot PutClass ");

			ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
			ReleaseErrorObject(pErrorObject);
			return NULL;
		}
		else
		{
			ReleaseErrorObject(pErrorObject);
			return pimcoClone;
		}
	}
	else
	{

		return FALSE;
	}

}

//***************************************************************************
//
// RenameAClass
//
// Purpose: Clone a class and change its naem.
//
//***************************************************************************
IWbemClassObject *RenameAClass
(IWbemServices * pProv, IWbemClassObject *pimcoClass, CString *pcsNewName,
 BOOL bDeleteOriginal)
{

	IWbemClassObject *pimcoClone = NULL;
	IWbemClassObject *pErrorObject = NULL;
	SCODE sc;

	sc = pimcoClass -> Clone(&pimcoClone);
	if (sc != S_OK)
	{
		CString csUserMsg =
			_T("An error occured renaming a class: ");
		csUserMsg +=
					_T("Cannot clone class ");
		CString csProp = _T("__Class");
		CString csClass;
		csClass = ::GetProperty(pimcoClass,&csProp);
		csUserMsg += csClass;
		ErrorMsg
			(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 10);
		return FALSE;
	}

	CString csProp = _T("__Class");

	SetProperty (pProv, pimcoClone, &csProp, pcsNewName);

	sc = pProv -> PutClass(pimcoClone, 0, NULL,NULL);
	if (sc != S_OK)
		{
			CString csUserMsg=
				_T("An error occured renaming a class: ");
			csUserMsg +=
				_T("Cannot PutClass ");
			ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
			ReleaseErrorObject(pErrorObject);
			return NULL;
	}
	else
	{
		ReleaseErrorObject(pErrorObject);
	}


	if (bDeleteOriginal)
	{
		CString csDelete;
		csProp = _T("__Class");
		csDelete = ::GetProperty(pimcoClass,&csProp);
		pimcoClass -> Release();
		BOOL bReturn = DeleteAClass
			(pProv, &csDelete);
		if (!bReturn)
		{
			CString csUserMsg =
				_T("An error occured renaming a class: ");
			csUserMsg +=
					_T("Cannot delete the original class ");
			ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 7);
			return NULL;
		}


	}
	return pimcoClone;

}


BOOL SetProperty
(IWbemServices * pProv, IWbemClassObject * pInst,
 CString *pcsProperty, CString *pcsPropertyValue)

{
	SCODE sc;

    VARIANTARG var;
	VariantInit(&var);
    var.vt = VT_BSTR;
    var.bstrVal = pcsPropertyValue -> AllocSysString ( );
    if(var.bstrVal == NULL)
	{
        return WBEM_E_FAILED;
	}

	BSTR bstrTemp = pcsProperty -> AllocSysString ( );
    sc = pInst->Put(bstrTemp ,0,&var,NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
		{
			CString csUserMsg =
							_T("Cannot Put " + *pcsProperty);
			ErrorMsg
				(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
	}


	VariantClear(&var);
	return TRUE;
}

BOOL SetProperty
(IWbemServices * pProv, IWbemClassObject * pInst,
 CString *pcsProperty, long lValue)
{
	SCODE sc;

    VARIANTARG var;
	VariantInit(&var);
    var.vt = VT_I4;
    var.lVal = lValue;

	BSTR bstrTemp = pcsProperty -> AllocSysString ( );
    sc = pInst->Put(bstrTemp  ,0,&var,NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
			CString csUserMsg =
							_T("Cannot Put " + *pcsProperty);
			ErrorMsg
				(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
	}


	VariantClear(&var);
	return TRUE;
}



CString GetProperty
(IWbemClassObject * pInst, CString *pcsProperty, BOOL bQuietly)

{
	SCODE sc;
	CString csOut;

    VARIANTARG var;
	VariantInit(&var);
    long lType;
	long lFlavor;

	BSTR bstrTemp = pcsProperty -> AllocSysString ( );
    sc = pInst->Get( bstrTemp ,0,&var,&lType,&lFlavor);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		if (!bQuietly)
		{
			CString csUserMsg =
							_T("Cannot get a property ");
			ErrorMsg
				(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
		}
		return csOut;
	}

	if (var.vt == VT_BSTR)
		csOut = var.bstrVal;

	VariantClear(&var);
	return csOut;
}

//***************************************************************************
// Function:	GetClasses
// Purpose:		Gets classes in the database.
//***************************************************************************
SCODE GetClasses(IWbemServices * pIWbemServices, CString *pcsParent,
			   CPtrArray &cpaClasses, CString &rcsNamespace)
{
	SCODE sc;
	IEnumWbemClassObject *pIEnumWbemClassObject = NULL;
	IWbemClassObject     *pIWbemClassObject = NULL;
	IWbemClassObject     *pErrorObject = NULL;

	//CString csClass = pcsParent ? *pcsParent: _T("");
	if (pcsParent)
	{
		BSTR bstrTemp = pcsParent->AllocSysString();
		sc = pIWbemServices->CreateClassEnum
		(bstrTemp,
		WBEM_FLAG_SHALLOW, NULL, &pIEnumWbemClassObject);
		::SysFreeString(bstrTemp);
	}
	else
	{
		sc = pIWbemServices->CreateClassEnum
			(NULL,
			WBEM_FLAG_SHALLOW, NULL, &pIEnumWbemClassObject);
	}
	if (sc != S_OK)
	{
		CString csUserMsg =
							_T("Cannot create a class enumeration ");
		ErrorMsg
			(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 8);
		ReleaseErrorObject(pErrorObject);
		return sc;
	}
	else
	{
		ReleaseErrorObject(pErrorObject);
		SetEnumInterfaceSecurity(rcsNamespace,pIEnumWbemClassObject, pIWbemServices);
	}

	sc = pIEnumWbemClassObject->Reset();

	ULONG uReturned;
	int i = 0;

	pIWbemClassObject = NULL;
    while (S_OK == pIEnumWbemClassObject->Next(INFINITE, 1, &pIWbemClassObject, &uReturned) )
		{
			cpaClasses.Add(reinterpret_cast<void *>(pIWbemClassObject));
			i++;
			pIWbemClassObject = NULL;
		}

	pIEnumWbemClassObject -> Release();
	return sc;

}

//***************************************************************************
// Function:	GetAllClasses
// Purpose:		Gets all classes in the database.
//***************************************************************************
int GetAllClasses(IWbemServices * pIWbemServices, CPtrArray &cpaClasses, CString &rcsNamespace)
{
	SCODE sc;
	IEnumWbemClassObject *pIEnumWbemClassObject = NULL;
	IWbemClassObject     *pIWbemClassObject = NULL;
	IWbemClassObject     *pErrorObject = NULL;

	//CString csClass = _T("");
	sc = pIWbemServices->CreateClassEnum
		(NULL, WBEM_FLAG_DEEP, NULL, &pIEnumWbemClassObject);
	if (sc != S_OK)
	{
		CString csUserMsg= _T("Cannot get all classes ");
		ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 8);
		ReleaseErrorObject(pErrorObject);
		return 0;
	}
	else
	{
		ReleaseErrorObject(pErrorObject);
		SetEnumInterfaceSecurity(rcsNamespace,pIEnumWbemClassObject, pIWbemServices);
	}

	sc = pIEnumWbemClassObject->Reset();

	ULONG uReturned;
	int i = 0;

	pIWbemClassObject = NULL;
    while (S_OK == pIEnumWbemClassObject->Next(INFINITE, 1, &pIWbemClassObject, &uReturned) )
		{
			cpaClasses.Add(reinterpret_cast<void *>(pIWbemClassObject));
			i++;
			pIWbemClassObject = NULL;
		}

	pIEnumWbemClassObject -> Release();
	return i;

}

CStringArray *GetAllClassPaths(IWbemServices * pIWbemServices, CString &rcsNamespace)
{

	CPtrArray cpaClasses;
	int nClasses=
		GetAllClasses(pIWbemServices, cpaClasses, rcsNamespace);

	CStringArray *pcsaClassNames = new CStringArray;

	for (int i = 0; i < nClasses; i++)
	{
		IWbemClassObject *pClass =
			reinterpret_cast<IWbemClassObject *>
				(cpaClasses.GetAt(i));
		CString csProp = _T("__Path");
		CString csClass = ::GetProperty(pClass,&csProp);
		pcsaClassNames->Add(csClass);
		pClass->Release();
	}

	return pcsaClassNames;

}

//***************************************************************************
// Function:	HasSubclasses
// Purpose:		Predicate to tell if a class has any subclasses.
//***************************************************************************
BOOL HasSubclasses(IWbemServices * pIWbemServices, IWbemClassObject *pimcoClass, CString &rcsNamespace)
{
	SCODE sc;
	IEnumWbemClassObject * pIEnumWbemClassObject = NULL;
	IWbemClassObject     * pIWbemClassObject = NULL;
	IWbemClassObject     * pErrorObject = NULL;

	CString csClass = _T("__Class");
	csClass = ::GetProperty(pimcoClass,&csClass);

	BSTR bstrTemp = csClass.AllocSysString();
	sc = pIWbemServices->CreateClassEnum
		(bstrTemp, WBEM_FLAG_SHALLOW, NULL, &pIEnumWbemClassObject);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		CString csUserMsg=
							_T("Cannot create a class enumeration ");
		ErrorMsg
			(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 7);
		ReleaseErrorObject(pErrorObject);
		return FALSE;
	}
	else
	{
		ReleaseErrorObject(pErrorObject);
		SetEnumInterfaceSecurity(rcsNamespace,pIEnumWbemClassObject, pIWbemServices);
	}


	sc = pIEnumWbemClassObject->Reset();

	ULONG uReturned;
	int i = 0;

	pIWbemClassObject = NULL;
	BOOL bStop = FALSE;
    if (!bStop && S_OK == pIEnumWbemClassObject->Next(INFINITE, 1, &pIWbemClassObject, &uReturned) )
		{
			if (pIWbemClassObject)
			{
				pIWbemClassObject -> Release();
				pIWbemClassObject = NULL;
				i++;
			}
			 if (i > 0)
			 {
				 bStop = TRUE;;
			 }
		}

	pIEnumWbemClassObject -> Release();
	return i > 0? TRUE : FALSE;

}
//***************************************************************************
// Function:	HasSubclasses
// Purpose:		Predicate to tell if a class has any subclasses.
//***************************************************************************
BOOL HasSubclasses(IWbemServices * pIWbemServices, CString *pcsClass, CString &rcsNamespace)
{
	SCODE sc;
	IEnumWbemClassObject *pIEnumWbemClassObject = NULL;
	IWbemClassObject     *pIWbemClassObject = NULL;
	IWbemClassObject     *pErrorObject = NULL;

	BSTR bstrTemp = pcsClass -> AllocSysString();
	sc = pIWbemServices->CreateClassEnum
		(bstrTemp, WBEM_FLAG_SHALLOW,
		NULL,&pIEnumWbemClassObject);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		CString csUserMsg =
						_T("Cannot create a class enumeration ");
		ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 7);
		ReleaseErrorObject(pErrorObject);
		return FALSE;
	}
	else
	{
		ReleaseErrorObject(pErrorObject);
		SetEnumInterfaceSecurity(rcsNamespace,pIEnumWbemClassObject, pIWbemServices);
	}


	sc = pIEnumWbemClassObject->Reset();

	ULONG uReturned;
	int i = 0;

	pIWbemClassObject = NULL;
	BOOL bStop = FALSE;
    if (!bStop && S_OK == pIEnumWbemClassObject->Next(INFINITE,1, &pIWbemClassObject, &uReturned) )
		{
			 if (pIWbemClassObject)
			 {
				pIWbemClassObject -> Release();
				pIWbemClassObject = NULL;
				i++;
			 }
			 if (i > 0)
			 {
				 bStop = TRUE;
			 }
		}

	pIEnumWbemClassObject -> Release();
	return i > 0? TRUE : FALSE;

}

//***************************************************************************
//
// GetAttribBool
//
// Purpose: gets an Boolean Qualifier.
//
//***************************************************************************

long GetAttribBool
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName,
 BOOL &bReturn)
{
    SCODE sc;
    IWbemQualifierSet *pAttribSet = NULL;
    if(pcsPropName != NULL)   // Property Qualifier
	{
		BSTR bstrTemp = pcsPropName -> AllocSysString();
        sc = pClassInt->GetPropertyQualifierSet(bstrTemp,
					&pAttribSet);
		::SysFreeString(bstrTemp);
	}
    else	// A class Qualifier
        sc = pClassInt->GetQualifierSet(&pAttribSet);

	if (sc != S_OK)
	{
		bReturn = FALSE;
		return S_OK;
	}

	VARIANTARG var;
	VariantInit(&var);

	BSTR bstrTemp = pcsAttribName -> AllocSysString();
    sc = pAttribSet->Get(bstrTemp, 0, &var, NULL);
	::SysFreeString(bstrTemp);

	if (sc == S_OK)
		bReturn = V_BOOL(&var);
	else
		bReturn = FALSE;


    pAttribSet->Release();
    VariantClear(&var);
    return sc;
}

//***************************************************************************
//
// GetAttribBSTR
//
// Purpose: gets an BSTR Qualifier.
//
//***************************************************************************

long GetAttribBSTR
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName,
 CString &csReturn)
{
    SCODE sc;
    IWbemQualifierSet *pAttribSet = NULL;
    if(pcsPropName != NULL)   // Property Qualifier
	{
		BSTR bstrTemp = pcsPropName -> AllocSysString();
        sc = pClassInt->GetPropertyQualifierSet(bstrTemp,
					&pAttribSet);
		::SysFreeString(bstrTemp);
	}
    else	// A class Qualifier
        sc = pClassInt->GetQualifierSet(&pAttribSet);

	if (sc != S_OK)
	{
		csReturn.Empty();
		return sc;
	}

	VARIANTARG var;
	VariantInit(&var);

	BSTR bstrTemp = pcsAttribName -> AllocSysString();
    sc = pAttribSet->Get(bstrTemp, 0, &var, NULL);
	::SysFreeString(bstrTemp);


	if (sc == S_OK && var.vt == VT_BSTR)
	{
		csReturn = var.bstrVal;
	}
	else
	{
		csReturn.Empty();
	}


    pAttribSet->Release();
    VariantClear(&var);
    return sc;
}




//***************************************************************************
//
// GetIWbemFullPath
//
// Purpose: Returns the complete path of the object.
//
//***************************************************************************
CString GetIWbemFullPath(IWbemClassObject *pClass)
{

	CString csProp = _T("__Path");
	return ::GetProperty(pClass,&csProp,TRUE);
}

CString GetIWbemRelativePath(IWbemClassObject *pClass)
{

	CString csProp = _T("__RelPath");
	return ::GetProperty(pClass,&csProp,TRUE);
}

BOOL WbemObjectIdentity(CString &rcsWbem1, CString &rcsWbem2)
{
	if (rcsWbem1.CompareNoCase(rcsWbem2) == 0)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}

}

int StringInArray
(CStringArray *pcsaArray, CString *pcsString, int nIndex)
{
	int nSize = (int) pcsaArray->GetSize();

	for (int i = nIndex; i < nSize; i++)
	{
		if (pcsString->CompareNoCase(pcsaArray->GetAt(i)) == 0)
		{
			return i;
		}
	}
	return -1;
}


CString GetBSTRProperty
(IWbemClassObject * pInst, CString *pcsProperty)

{
	SCODE sc;
	CString csOut;

    VARIANTARG var;
	VariantInit(&var);
	long lType;
	long lFlavor;

	BSTR bstrTemp = pcsProperty -> AllocSysString ( );
    sc = pInst->Get(bstrTemp  ,0,&var,&lType,&lFlavor);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
	   return csOut;
	}

	if (var.vt == VT_BSTR)
		csOut = var.bstrVal;

	VariantClear(&var);
	return csOut;
}



CString GetIWbemSuperClass(IWbemClassObject *pClass)
{

	CString csProp = _T("__SuperClass");
	return GetBSTRProperty(pClass,&csProp);


}

CString GetIWbemClass(IWbemClassObject *pClass)
{

	CString csProp = _T("__Class");
	return GetBSTRProperty(pClass,&csProp);


}

IWbemClassObject *GetClassObject (IWbemServices *pProv,CString *pcsClass,BOOL bQuiet)
{
	IWbemClassObject *pClass = NULL;
	IWbemClassObject *pErrorObject = NULL;

	BSTR bstrTemp = pcsClass -> AllocSysString();
	SCODE sc =
		pProv->GetObject
			(bstrTemp,0,NULL, &pClass,NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK && bQuiet == FALSE)
	{
		CString csUserMsg=
							_T("Cannot get class ") + *pcsClass;
		ErrorMsg
			(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 7);
		ReleaseErrorObject(pErrorObject);
		return NULL;
	}

	ReleaseErrorObject(pErrorObject);

	return pClass;
}




 //***************************************************************************
//
// ObjectIdentity
//
// Purpose: Predicate to tell if two class objects are the
//			same com object.
//
//***************************************************************************
BOOL ClassIdentity(IWbemClassObject *piWbem1, IWbemClassObject *piWbem2)
{
	return (GetIWbemClass(piWbem1).CompareNoCase(GetIWbemClass(piWbem2)) == 0);
}

void ReleaseErrorObject(IWbemClassObject *&rpErrorObject)
{
	if (rpErrorObject)
	{
		rpErrorObject->Release();
		rpErrorObject = NULL;
	}


}

void ErrorMsg
(CString *pcsUserMsg, SCODE sc, IWbemClassObject *pErrorObject, BOOL bLog,
 CString *pcsLogMsg, char *szFile, int nLine, UINT uType)
{
	CString csCaption = _T("Event Registration Message");
	BOOL bErrorObject = sc != S_OK;

	BSTR bstrTemp1 = csCaption.AllocSysString();
	BSTR bstrTemp2 = pcsUserMsg->AllocSysString();
	DisplayUserMessage
		(bstrTemp1,bstrTemp2,
		sc,bErrorObject,uType);
	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);

	if (bLog)
	{
		LogMsg(pcsLogMsg,  szFile, nLine);

	}

}

void LogMsg
(CString *pcsLogMsg, char *szFile, int nLine)
{


}

BOOL ObjectInDifferentNamespace
(IWbemServices *pProv, CString *pcsNamespace, IWbemClassObject *pObject)
{

	BOOL bHasServer = FALSE;
	TCHAR c1 = (*pcsNamespace)[0];
	TCHAR c2 = (*pcsNamespace)[1];

	if (c1 == '\\' && c2 == '\\')
	{
		bHasServer = TRUE;
	}

	CString csNamespace;

	CString csPath = GetIWbemFullPath(pObject);
	CObjectPathParser parser;
	ParsedObjectPath* pParsedPath = NULL;

	BSTR bstrTemp = csPath.AllocSysString();
	int nStatus  = parser.Parse(bstrTemp,  &pParsedPath);
	::SysFreeString(bstrTemp);

	if (nStatus == 0)
	{
		if (pParsedPath->m_dwNumNamespaces > 0)
		{
			if(pParsedPath->m_pServer && bHasServer)
			{
				csNamespace = _T("\\\\");
				csNamespace += pParsedPath->m_pServer;
				csNamespace += _T("\\");
			}
			for (unsigned int i = 0; i < pParsedPath->m_dwNumNamespaces; i++)
			{
				csNamespace += pParsedPath->m_paNamespaces[i];
				if (i < pParsedPath->m_dwNumNamespaces - 1)
				{
					csNamespace += _T("\\");
				}
			}
		}
	}

	if (pParsedPath)
	{
		parser.Free(pParsedPath);
	}

	return csNamespace.CompareNoCase(*pcsNamespace) != 0;


}

CString GetHmomWorkingDirectory()
{
	CString csHmomWorkingDir;
	HKEY hkeyLocalMachine;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hkeyLocalMachine);
	if (lResult != ERROR_SUCCESS) {
		return "";
	}




	HKEY hkeyHmomCwd;

	lResult = RegOpenKeyEx(
				hkeyLocalMachine,
				_T("SOFTWARE\\Microsoft\\Wbem\\CIMOM"),
				0,
				KEY_READ | KEY_QUERY_VALUE,
				&hkeyHmomCwd);

	if (lResult != ERROR_SUCCESS) {
		RegCloseKey(hkeyLocalMachine);
		return "";
	}





	unsigned long lcbValue = 1024;
	LPTSTR pszWorkingDir = csHmomWorkingDir.GetBuffer(lcbValue);


	unsigned long lType;
	lResult = RegQueryValueEx(
				hkeyHmomCwd,
				_T("Working Directory"),
				NULL,
				&lType,
				(unsigned char*) (void*) pszWorkingDir,
				&lcbValue);


	csHmomWorkingDir.ReleaseBuffer();
	RegCloseKey(hkeyHmomCwd);
	RegCloseKey(hkeyLocalMachine);

	if (lResult != ERROR_SUCCESS)
	{
		csHmomWorkingDir.Empty();
	}

	return csHmomWorkingDir;
}

int GetPropNames(IWbemClassObject * pClass, CString *&pcsReturn)
{
	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;

	VARIANTARG var;
	VariantInit(&var);
	CString csNull;


    sc = pClass->GetNames(NULL,0,NULL,&psa);

    if(sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get property names ");
		csUserMsg += _T(" for object ");
		csUserMsg += GetIWbemFullPath (pClass);
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 10);
	}
	else
	{
       int iDim = SafeArrayGetDim(psa);
	   int i;
       sc = SafeArrayGetLBound(psa,1,&lLower);
       sc = SafeArrayGetUBound(psa,1,&lUpper);
	   pcsReturn = new CString [(lUpper - lLower) + 1];
       for(ix[0] = lLower, i = 0; ix[0] <= lUpper; ix[0]++, i++)
	   {
           BOOL bClsidSetForProp = FALSE;
           BSTR PropName;
           sc = SafeArrayGetElement(psa,ix,&PropName);
           pcsReturn[i] = PropName;
           SysFreeString(PropName);
	   }
	}

	SafeArrayDestroy(psa);

	return (lUpper - lLower) + 1;
}

//***************************************************************************
//
// GetAllKeyPropValuePairs
//
// Purpose: For an object get a all key value pairs for that object.
//
//***************************************************************************
CStringArray *GetAllKeyPropValuePairs(IWbemClassObject *pObject)
{

	CStringArray *pcsaReturn = new CStringArray;

	CString csQualifier = _T("singleton");
	BOOL bReturn;
	SCODE sc = GetAttribBool
		(pObject,NULL, &csQualifier, bReturn);

	if (sc == S_OK)
	{
		if (bReturn == TRUE)
		{
			CString csTmp = GetIWbemClass(pObject);
			pcsaReturn->Add(csTmp);
			csTmp = _T("@");
			pcsaReturn->Add(csTmp);
			return pcsaReturn;
		}
	}


	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;
	int nProps;
	CString *pcsProps;
	nProps = GetPropNames(pObject, pcsProps);
	int i;
	IWbemQualifierSet * pAttrib = NULL;
	CString csTmp;

	CString csAttrib = _T("key");
	COleVariant covValue;

	for (i = 0; i < nProps; i++)
	{
		BSTR bstrTemp = pcsProps[i].AllocSysString();
		sc = pObject -> GetPropertyQualifierSet(bstrTemp,
						&pAttrib);
		::SysFreeString(bstrTemp);

		if (sc == S_OK && pAttrib)
		{
			sc = pAttrib->GetNames(0,&psa);
			if(sc == S_OK)
			{
				int iDim = SafeArrayGetDim(psa);
				sc = SafeArrayGetLBound(psa,1,&lLower);
				sc = SafeArrayGetUBound(psa,1,&lUpper);
				BSTR AttrName;
				for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
				{
					sc = SafeArrayGetElement(psa,ix,&AttrName);
					csTmp = AttrName;

					if (csAttrib.CompareNoCase(csTmp)  == 0)
					{
						pcsaReturn->Add(pcsProps[i]);
						covValue = GetProperty (pObject, &pcsProps[i]);
						if (covValue.vt != VT_NULL)
						{
							covValue.ChangeType(VT_BSTR);
							CString csValue = covValue.bstrVal;
							pcsaReturn->Add(csValue);
						}
						else
						{
							pcsaReturn->Add(_T("<empty>"));

						}

					}
					SysFreeString(AttrName);

				}
			 }
			 pAttrib -> Release();
			 pAttrib = NULL;

		}
	}
	SafeArrayDestroy(psa);
	delete [] pcsProps;
	return pcsaReturn;
}

//***************************************************************************
// Function:	GetInstances
// Purpose:		Gets class instances in the database.
//***************************************************************************
SCODE GetInstances(	IWbemServices *pServices, CString *pcsClass,
					CPtrArray &cpaInstances, BOOL bDeep)
{
	SCODE sc;
	IEnumWbemClassObject *pIEnumWbemInstObject = NULL;
	IWbemClassObject *pIWbemInstObject = NULL;
	IWbemClassObject *pErrorObject = NULL;

	long lFlag = bDeep? WBEM_FLAG_DEEP: WBEM_FLAG_SHALLOW;

	BSTR bstrTemp = pcsClass -> AllocSysString();
	sc = pServices->CreateInstanceEnum
		(bstrTemp,
		lFlag, NULL, &pIEnumWbemInstObject);
	::SysFreeString(bstrTemp);

	if(sc != S_OK)
	{
		CString csUserMsg=  _T("Cannot get instance enumeration ");
		csUserMsg += _T(" for class ");
		csUserMsg += *pcsClass;
		ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 11);
		ReleaseErrorObject(pErrorObject);
		return sc;
	}

	ReleaseErrorObject(pErrorObject);

	sc = pIEnumWbemInstObject->Reset();

	ULONG uReturned;

    while (S_OK == pIEnumWbemInstObject->Next(INFINITE, 1, &pIWbemInstObject, &uReturned) )
		{
			cpaInstances.Add(pIWbemInstObject);
			pIWbemInstObject = NULL;
		}

	pIEnumWbemInstObject -> Release();
	return sc;

}

//***************************************************************************
//
// BuildOBJDBGetRefQuery
//
// Purpose: Build an OBJDB "GetRef" query string suitable to pass to
//			ExecQuery.
//
//***************************************************************************
CString BuildOBJDBGetRefQuery
(IWbemServices *pProv, CString *pcsTarget,
 CString *pcsResultClass, CString *pcsRoleFilter,
 CString *pcsReqAttrib, BOOL bClassOnly)
{

	CString csReturn = _T("references of {");
	csReturn += *pcsTarget;
	csReturn += _T("}");

	if (
		(pcsResultClass && !pcsResultClass->IsEmpty())  ||
		(pcsRoleFilter && !pcsRoleFilter -> IsEmpty()) ||
		(pcsReqAttrib && !pcsReqAttrib -> IsEmpty()) ||
		bClassOnly
		)
		csReturn += _T(" where");

	if (pcsResultClass && !pcsResultClass->IsEmpty())
	{
		csReturn += _T(" ResultClass=");
		csReturn += *pcsResultClass;
	}

	if (pcsRoleFilter && !pcsRoleFilter -> IsEmpty())
	{
		csReturn += _T(" Role=");
		csReturn += *pcsRoleFilter;
	}


	if (pcsReqAttrib && !pcsReqAttrib -> IsEmpty())
	{
		csReturn += _T(" RequiredQualifier=");
		csReturn += *pcsReqAttrib;
	}

	if (bClassOnly)
	{
		csReturn += _T(" ClassDefsOnly");
	}


	return csReturn;
}

//***************************************************************************
//
// BuildOBJDBGetAssocsQuery
//
// Purpose: Build an OBJDB "GetAssoc" query string suitable to pass to
//			ExecQuery.
//
//***************************************************************************
CString BuildOBJDBGetAssocsQuery
(IWbemServices *pProv, CString *pcsTargetPath,
 CString *pcsAssocClass, CString *pcsResultClass,
 CString *pcsMyRoleFilter, CString *pcsReqAttrib,
 CString *pcsReqAssocAttrib, CString *pcsResultRole,
 BOOL bClassOnly)
{

	pcsTargetPath;
	pcsAssocClass;
	pcsResultClass;


	CString csReturn = _T("associators of {");
	csReturn += *pcsTargetPath;
	csReturn += _T("}");

	if ((pcsResultClass && !pcsResultClass->IsEmpty()) ||
		(pcsMyRoleFilter && !pcsMyRoleFilter -> IsEmpty()) ||
		!pcsAssocClass->IsEmpty() ||
		(pcsReqAttrib && !pcsReqAttrib -> IsEmpty()) ||
		(pcsReqAssocAttrib && !pcsReqAssocAttrib -> IsEmpty()) ||
		bClassOnly)
		csReturn += " where";

	if (pcsAssocClass && !pcsAssocClass->IsEmpty())
	{
		csReturn += _T(" AssocClass=");
		csReturn += *pcsAssocClass;
	}

	if (pcsResultClass && !pcsResultClass->IsEmpty())
	{
		csReturn += _T(" ResultClass=");
		csReturn += *pcsResultClass;
	}

	if (pcsMyRoleFilter && !pcsMyRoleFilter -> IsEmpty())
	{
		csReturn += _T(" Role=");
		csReturn += *pcsMyRoleFilter;
	}


	if (pcsResultRole && !pcsResultRole -> IsEmpty())
	{
		csReturn += _T(" ResultRole=");
		csReturn += *pcsResultRole;
	}

	if (pcsReqAttrib && !pcsReqAttrib -> IsEmpty())
	{
		csReturn += _T(" RequiredQualifier=");
		csReturn += *pcsReqAttrib;
	}

	if (pcsReqAssocAttrib && !pcsReqAssocAttrib -> IsEmpty())
	{
		csReturn += _T(" RequiredAssocAttrib=");
		csReturn += *pcsReqAssocAttrib;
	}

	if (bClassOnly)
	{
		csReturn += _T(" ClassDefsOnly");
	}

	return csReturn;
}

//***************************************************************************
//
// ExecOBJDBQuery
//
// Purpose: Execute an OBJDB query and return class enumeration.  The caller
//			must release the enumeration when done with it.
//
//***************************************************************************
IEnumWbemClassObject *ExecOBJDBQuery
(IWbemServices * pProv, CString &csQuery)
{
	IEnumWbemClassObject *pemcoResult = NULL;
	IWbemClassObject *pErrorObject = NULL;

	CString csQueryType = _T("WQL");

	BSTR bstrTemp1 = csQueryType.AllocSysString();
	BSTR bstrTemp2 = csQuery.AllocSysString();
	SCODE sc = pProv -> ExecQuery(bstrTemp1,bstrTemp2
					,0,NULL,&pemcoResult);
	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);

	if (sc == S_OK)
	{
		ReleaseErrorObject(pErrorObject);
		return pemcoResult;
	}
	else
	{
		CString csUserMsg;
		CString csErrorAsHex;
		csErrorAsHex.Format(_T("0x%x"),sc);
		csUserMsg =  _T("ExecQuery failure: ");
		csUserMsg += csErrorAsHex;
		csUserMsg +=  _T(" for query: ");
		csUserMsg += csQuery;

		ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 28);
		ReleaseErrorObject(pErrorObject);
		return NULL;

	}

}

//***********************************************************
// CComparePaths::CompareNoCase
//
//
// Do a case insensitive comparison of two wide strings.  This
// compare works even when one or both of the string pointers are
// NULL.  A NULL pointer is taken to be less than any real string,
// even an empty one.
//
// Parameters:
//		[in] LPWSTR pws1
//			Pointer to the first string.  This pointer can be NULL.
//
//		[in] LPWSTR pws2
//			Pointer to the second string.  This pointer can be NULL.
//
// Returns:
//		int
//			Greater than zero if string1 is greater than string2.
//			Zero if the two strings are equal.
//			Less than zero if string 1 is less than string2.
//
//**************************************************************
int CComparePaths::CompareNoCase(LPWSTR pws1, LPWSTR pws2)
{
	// Handle the case where one, or both of the string pointers are NULL
	if (pws1 == NULL) {
		if (pws2 == NULL) {
			return 0;	// Two null strings are equal
		}
		else {
			return -1; // A null string is less than any real string.
		}
	}

	if (pws2 == NULL) {
		if (pws1 != NULL) {
			return 1;  // Any string is greater than a null string.
		}
	}


	ASSERT(pws1 != NULL);
	ASSERT(pws2 != NULL);

	int iResult;
	iResult = _wcsicmp( pws1, pws2);

	return iResult;
}


//***************************************************************
// CComparePath::NormalizeKeyArray
//
// The key array is normalized by sorting the KeyRef's by key name.
// After two key arrays are sorted, they can be compared without
// by iterating through the list of keys and comparing corresponding
// array entries rather than trying searching the arrays for corresponding
// key names and then comparing the key values.
//
// Parameters:
//		[in, out] ParsedObjectPath& path
//			The parsed object path containing the key array to sort.
//
// Returns:
//		Nothing. (The key array is sorted as a side effect).
//
//*****************************************************************
void CComparePaths::NormalizeKeyArray(ParsedObjectPath& path)
{
	// Do a simple bubble sort where the "KeyRefs" with the smallest
	// names are bubbled towards the top and the  the KeyRefs with the
	// largest names are bubbled toward the bottom.
	for (DWORD dwKey1 = 0; dwKey1 < path.m_dwNumKeys; ++dwKey1) {
		for (DWORD dwKey2 = dwKey1 + 1; dwKey2 < path.m_dwNumKeys; ++dwKey2) {
			ASSERT(path.m_paKeys[dwKey1] != NULL);
			KeyRef* pkr1 = path.m_paKeys[dwKey1];
			ASSERT(pkr1 != NULL);

			ASSERT(path.m_paKeys[dwKey2] != NULL);
			KeyRef* pkr2 = path.m_paKeys[dwKey2];
			ASSERT(pkr2 != NULL);

			int iResult = CompareNoCase(pkr1->m_pName, pkr2->m_pName);
			if (iResult > 0) {
				// Swap the two keys;
				path.m_paKeys[dwKey1] = pkr2;
				path.m_paKeys[dwKey2] = pkr2;
			}
		}
	}
}



//***********************************************************************
// CComparePaths::KeyValuesAreEqual
//
// Compare two key values to determine whether or not they are equal.
// To be equal, they must both be of the same type and their values
// must also be equal.
//
// Parameters:
//		[in] VARAINT& variant1
//			The first key value.
//
//		[in] VARIANT& variant2
//			The second key value.
//
// Returns:
//		TRUE if the two values are the same, FALSE otherwise.
//
//**********************************************************************
BOOL CComparePaths::KeyValuesAreEqual(VARIANT& v1, VARIANT& v2)
{
	ASSERT(v1.vt == v2.vt);
	ASSERT(v1.vt==VT_BSTR || v1.vt == VT_I4);
	ASSERT(v2.vt==VT_BSTR || v2.vt == VT_I4);


	// Key values should always be VT_BSTR or VT_I4.  We special case these
	// two types to be efficient and punt on all the other types.
	BOOL bIsEqual;
	switch(v1.vt) {
	case VT_BSTR:
		if (v2.vt == VT_BSTR) {
			bIsEqual = IsEqual(v1.bstrVal, v2.bstrVal);
			return bIsEqual;
		}
		else {
			return FALSE;
		}
		break;
	case VT_I4:
		if (v2.vt == VT_I4) {
			bIsEqual = (v1.lVal == v2.lVal);
			return bIsEqual;
		}
		else {
			return FALSE;
		}
		break;
	}


	ASSERT(FALSE);
	COleVariant var1;
	COleVariant var2;

	var1 = v1;
	var2 = v2;

	bIsEqual = (var1 == var2);
	return bIsEqual;
}


//*******************************************************************
// CComparePaths::PathsRefSameObject
//
// Compare two parsed object paths to determine whether or not they
// they reference the same object.  Note that the sever name and namespaces
// are not compared if they are missing from one of the paths.
//
// Parameters:
//		[in] ParsedObjectPath* ppath1
//			The first parsed path.
//
//		[in] ParsedObjectPath* ppath2
//			The second parsed path.
//
// Returns:
//		BOOL
//			TRUE if the two paths reference the same object, FALSE otherwise.
//
//*******************************************************************
BOOL CComparePaths::PathsRefSameObject(
	/* in */ ParsedObjectPath* ppath1,
	/* in */ ParsedObjectPath* ppath2)
{
	if (ppath1 == ppath2) {
		return TRUE;
	}
	if (ppath1==NULL || ppath2==NULL) {
		return FALSE;
	}


#if 0
	// Check to see if a server name is specified for either path
	// if so, the server name count is 1, otherwise zero.
	UINT iNamespace1 = 0;
	if (ppath1->m_pServer!=NULL) {
		if (!IsEqual(ppath1->m_pServer, L".")) {
			iNamespace1 = 1;
		}
	}

	UINT iNamespace2 = 0;
	if (ppath1->m_pServer!=NULL) {
		if (!IsEqual(ppath2->m_pServer, L".")) {
			iNamespace2 = 1;
		}
	}


	// Relative paths don't specify a server, so we assume that the server
	// for a relative path and any other path match and no further comparison is
	// necessary.
	if (iNamespace1!=0 && iNamespace2!=0) {
		if (!IsEqual(ppath1->m_pServer, ppath2->m_pServer)) {
			return FALSE;
		}
	}

	// Relative paths don't specify name spaces, so we assume that the name spaces
	// for a relative path and any other path match and no further comparison is
	// necessary.  Of course, this assumes that the namespace for a relative path
	// is indeed the same as the other path.
	if (ppath1->m_dwNumNamespaces!=0 && ppath2->m_dwNumNamespaces!=0) {
		// Check to see if one of the namespaces are different.
		if ((ppath1->m_dwNumNamespaces - iNamespace1) != (ppath2->m_dwNumNamespaces - iNamespace2)) {
			return FALSE;
		}

		while((iNamespace1 < ppath1->m_dwNumNamespaces) && (iNamespace2 < ppath2->m_dwNumNamespaces)) {

			if (!IsEqual(ppath1->m_paNamespaces[iNamespace1], ppath2->m_paNamespaces[iNamespace2])) {
				return FALSE;
			}
			++iNamespace1;
			++iNamespace2;
		}
	}


#endif //0


	// Check to see if the classes are different.
	if (!IsEqual(ppath1->m_pClass, ppath2->m_pClass)) {
		return FALSE;
	}


	// Check to see if any of the keys are different.
	if (ppath1->m_dwNumKeys  != ppath2->m_dwNumKeys) {
		return FALSE;
	}

	KeyRef* pkr1;
	KeyRef* pkr2;

	// Handle single keys as a special case since "Class="KeyValue"" should
	// be identical to "Class.keyName="KeyValue""
	if ((ppath1->m_dwNumKeys==1) && (ppath2->m_dwNumKeys==1)) {
		pkr1 = ppath1->m_paKeys[0];
		pkr2 = ppath2->m_paKeys[0];

		if (!IsEqual(pkr1->m_pName, pkr2->m_pName)) {
			if (pkr1->m_pName!=NULL && pkr2->m_pName!=NULL) {
				return FALSE;
			}
		}

		if (KeyValuesAreEqual(pkr1->m_vValue, pkr2->m_vValue)) {
			return TRUE;
		}
		else {
			return FALSE;
		}
	}


	NormalizeKeyArray(*ppath1);
	NormalizeKeyArray(*ppath2);

	for (DWORD dwKeyIndex = 0; dwKeyIndex < ppath1->m_dwNumKeys; ++dwKeyIndex) {
		ASSERT(ppath1->m_paKeys[dwKeyIndex] != NULL);
		ASSERT(ppath2->m_paKeys[dwKeyIndex] != NULL);

		pkr1 = ppath1->m_paKeys[dwKeyIndex];
		pkr2 = ppath2->m_paKeys[dwKeyIndex];


		if (!IsEqual(pkr1->m_pName, pkr2->m_pName)) {
			return FALSE;
		}

		if (!KeyValuesAreEqual(pkr1->m_vValue, pkr2->m_vValue)) {
			return FALSE;
		}

	}
	return TRUE;
}



//**************************************************************
// CComparePaths::PathsRefSameObject
//
// Check to see if two object paths point to the same object.
//
// Parameters:
//		BSTR bstrPath1
//			The first object path.
//
//		BSTR bstrPath2
//			The second object path.
//
// Returns:
//		BOOL
//			TRUE if the two paths reference the same object in
//			the database, FALSE otherwise.
//
//**************************************************************
BOOL CComparePaths::PathsRefSameObject(BSTR bstrPath1, BSTR bstrPath2)
{
	CObjectPathParser parser;

    ParsedObjectPath* pParsedPath1 = NULL;
    ParsedObjectPath* pParsedPath2 = NULL;
	int nStatus1;
	int nStatus2;

    nStatus1 = parser.Parse(bstrPath1,  &pParsedPath1);
	nStatus2 = parser.Parse(bstrPath2, &pParsedPath2);

	BOOL bRefSameObject = FALSE;
	if (nStatus1==0 && nStatus2==0) {
		bRefSameObject = PathsRefSameObject(pParsedPath1, pParsedPath2);
	}

	if (pParsedPath1) {
		parser.Free(pParsedPath1);
	}

	if (pParsedPath2) {
		parser.Free(pParsedPath2);
	}

	return bRefSameObject;
}

CPtrArray *SemiSyncEnum
(IEnumWbemClassObject *pEnum, BOOL &bCancel,
 HRESULT &hResult, int nRes)
{

	if (!pEnum)
		return NULL;

	CPtrArray *pcpaObjects = new CPtrArray;

	IWbemClassObject *pObject = NULL;
	ULONG uReturned = 0;
	hResult = S_OK;

	IWbemClassObject     **pimcoInstances = new IWbemClassObject *[nRes];

	int i;

	for (i = 0; i < nRes; i++)
	{
		pimcoInstances[i] = NULL;
	}


	hResult =
			pEnum->Next(0,nRes,pimcoInstances, &uReturned);

	int cInst = 0;

	BOOL bDone = FALSE;

	while(!bDone &&
			(hResult == S_OK || hResult == WBEM_S_TIMEDOUT || uReturned > 0))
	{

#pragma warning( disable :4018 )
		for (int i = 0; i < uReturned; i++)
#pragma warning( default : 4018 )
		{
			pcpaObjects->Add(reinterpret_cast<void *>(pimcoInstances[i]));
			pimcoInstances[i] = NULL;
		}

		cInst += uReturned;
		uReturned = 0;
		if (cInst < nRes)
		{
			hResult = pEnum->Next
				(0,nRes - cInst,pimcoInstances, &uReturned);
		}
		else
		{
			bDone = TRUE;
		}
	}

	delete[]pimcoInstances;
	return pcpaObjects;

}

CString GetClass(CString *pcsPath)
{
	CObjectPathParser parser;
	ParsedObjectPath* pParsedPath = NULL;

	BSTR bstrTemp = pcsPath->AllocSysString();
	int nStatus  = parser.Parse(bstrTemp,  &pParsedPath);
	::SysFreeString(bstrTemp);

	if (nStatus == 0)
	{
		if (pParsedPath)
		{
			CString csClass = pParsedPath->m_pClass;
			parser.Free(pParsedPath);
			return csClass;
		}

	}
	return _T("");
}

BOOL ArePathsEqual (CString csPath1, CString csPath2)
{
	CComparePaths ccpParser;
	BSTR bstrTemp1 = csPath1.AllocSysString();
	BSTR bstrTemp2 = csPath2.AllocSysString();
	BOOL bReturn = ccpParser.PathsRefSameObject
		(bstrTemp1,bstrTemp2);
	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);
	return bReturn;
}

CString GetPropertyNameByAttrib(IWbemClassObject *pObject , CString *pcsAttrib)
{
	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;
	int nProps;
	CString *pcsProps;
	nProps = GetPropNames(pObject, pcsProps);
	int i;
	IWbemQualifierSet * pAttrib = NULL;
	CString csTmp;
	CString csReturn;
	BOOL bBreak = FALSE;

	for (i = 0; i < nProps; i++)
	{
		BSTR bstrTemp = pcsProps[i].AllocSysString();
		sc = pObject -> GetPropertyQualifierSet(bstrTemp,
						&pAttrib);
		::SysFreeString(bstrTemp);

		if (sc == S_OK)
		{
			sc = pAttrib->GetNames(0,&psa);
			 if(sc == S_OK)
			{
				int iDim = SafeArrayGetDim(psa);
				sc = SafeArrayGetLBound(psa,1,&lLower);
				sc = SafeArrayGetUBound(psa,1,&lUpper);
				BSTR AttrName;
				for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
				{
					sc = SafeArrayGetElement(psa,ix,&AttrName);
					csTmp = AttrName;

					if (pcsAttrib -> CompareNoCase(csTmp)  == 0)
					{
						csReturn = pcsProps[i];
						bBreak = TRUE;
					}
					SysFreeString(AttrName);

				}
			 }
			 pAttrib -> Release();
			 if (bBreak)
				 break;
		}
	}
	SafeArrayDestroy(psa);
	delete [] pcsProps;
	return csReturn;
}


BOOL IsClassAbstract(IWbemClassObject* pObject)
{
	CString csQualifier = _T("abstract");
	BOOL bReturn;
	long sc = GetAttribBool
		(pObject,NULL, &csQualifier, bReturn);

	if (sc == S_OK)
	{
		if (bReturn)
		{
			return TRUE;
		}
	}

	return FALSE;

}

BOOL IsObjectOfClass(CString &csClass, IWbemClassObject *pObject)
{
	CString csObjectClass = GetIWbemClass(pObject);

	if (csClass.CompareNoCase((LPCTSTR) csObjectClass) == 0)
	{
		return TRUE;
	}

	CStringArray *pcsaDerivation = ClassDerivation (pObject);

	BOOL bIsSublcass = FALSE;

	for (int i = 0; i < pcsaDerivation->GetSize(); i++)
	{
		if (csClass.CompareNoCase((LPCTSTR) pcsaDerivation->GetAt(i)) == 0)
		{
			bIsSublcass = TRUE;

		}

	}

	delete pcsaDerivation;

	return bIsSublcass;


}


CStringArray *ClassDerivation (IWbemClassObject *pObject)
{
	SCODE sc;

    VARIANTARG var;
	VariantInit(&var);
	long lType;
	long lFlavor;

	CString csProp = _T("__derivation");

	BSTR bstrTemp = csProp.AllocSysString ( );
    sc = pObject->Get(bstrTemp ,0,&var,&lType,&lFlavor);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
	   return NULL;
	}

	long ix[2] = {0,0};
	long lLower, lUpper;

	int iDim = SafeArrayGetDim(var.parray);
	sc = SafeArrayGetLBound(var.parray,1,&lLower);
	sc = SafeArrayGetUBound(var.parray,1,&lUpper);
	BSTR bstrClass;
	CStringArray *pcsaReturn = new CStringArray;
	for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
	{
		sc = SafeArrayGetElement(var.parray,ix,&bstrClass);
		CString csTmp = bstrClass;
		pcsaReturn->Add(csTmp);
		SysFreeString(bstrClass);

	}

	VariantClear(&var);
	return pcsaReturn;

}
//HRESULT ConfigureSecurity(IWbemServices *pServices)
//{

	/*IUnknown *pUnknown = dynamic_cast<IUnknown *>(pServices);
	return ConfigureSecurity(pUnknown);*/
//	return S_OK;
//}

//HRESULT ConfigureSecurity(IEnumWbemClassObject *pEnum)
//{

	/*IUnknown *pUnknown = dynamic_cast<IUnknown *>(pEnum);
	return ConfigureSecurity(pUnknown);*/
//	return S_OK;
//}

//HRESULT ConfigureSecurity(IUnknown *pUnknown)
//{
    /*IClientSecurity* pCliSec;
    if(FAILED(pUnknown->QueryInterface(IID_IClientSecurity, (void**)&pCliSec)))
    {
        // no security --- probably not a proxy
        return S_OK;
    }

    HRESULT hRes =
        pCliSec->SetBlanket(pUnknown, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
        NULL, RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE,
        NULL, EOAC_NONE);

    pCliSec->Release();

	return hRes;*/
//	return S_OK;

//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\container.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Container.cpp : Defines the class behaviors for the application.
//

#include "precomp.h"
#include "resource.h"
#include "Container.h"
#include <objbase.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CContainerApp

BEGIN_MESSAGE_MAP(CContainerApp, CWinApp)
	//{{AFX_MSG_MAP(CContainerApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CContainerApp construction

CContainerApp::CContainerApp()
{
	m_clsReg = 0;
	m_pFactory = NULL;
	m_pProvider = NULL;
	m_pConsumer = NULL;
	m_dlg = NULL;
	m_maxItemsFmCL = 0;
	m_htmlHelpInst = 0;
}

CContainerApp::~CContainerApp()
{
//	delete m_dlg; // let it leak. I'm self-terminating anyway.
	m_dlg = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CContainerApp object

CContainerApp theApp;

// {DD2DB150-8D3A-11d1-ADBF-00AA00B8E05A}
static const GUID CLSID_EventViewer =
{ 0xdd2db150, 0x8d3a, 0x11d1, { 0xad, 0xbf, 0x0, 0xaa, 0x0, 0xb8, 0xe0, 0x5a } };

/////////////////////////////////////////////////////////////////////////////
// CContainerApp initialization

BOOL CContainerApp::InitInstance()
{

	// NOTE: To advertise that we can self-register, put 'OLESelfRegister'
	// in the version resource.

	// see if this is a self-Unregister call.
	TCHAR temp[128];
	TCHAR seps[] = _T(" ");
	TCHAR *token = NULL;
	bool selfRegCalled = false;
    bool COMLaunched = false;

	_tcscpy(temp, (LPCTSTR)m_lpCmdLine);
	token = _tcstok( temp, seps );
	while( token != NULL )
	{
		/* While there are tokens in "string" */
		if(_tcsicmp(token, _T("/UNREGSERVER")) == 0)
		{
			UnregisterServer();
			return FALSE;		// no use doing any more.
		}
		else if(_tcsicmp(token, _T("/REGSERVER")) == 0)
		{
			selfRegCalled = true;
		}
		else if(_tcsicmp(token, _T("-EMBEDDING")) == 0)
		{
			COMLaunched = true;
		}
	    else if(_tcsspn(token, _T("0123456789")) == _tcslen(token))
		{
			// its all numbers. use it for the maxItems.
			m_maxItemsFmCL = _ttol(token);
		}
		/* Get next token: */
		token = _tcstok( NULL, seps );
	}

	// if we got here, the unregister didn't return out and we should
	// make sure we're registered now.
	RegisterServer();
	if(selfRegCalled)
	{
		return FALSE;
	}

	AfxEnableControlContainer();
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

	HRESULT hRes;

	// OLE initialization. This is 'lighter' than OleInitialize()
	//  which also sets up DnD, etc.
	if(SUCCEEDED(CoInitialize(NULL)))
	{
		// NOTE: This sets the initial security blanket.
		hRes = CoInitializeSecurity(NULL, -1, NULL, NULL,
								RPC_C_AUTHN_LEVEL_CONNECT,
								RPC_C_IMP_LEVEL_IDENTIFY,
								NULL, 0, 0);
	}
	else // didnt CoInitialize()
	{
		AfxMessageBox(_T("CoInitialize Failed"));
		return FALSE;
	} // endif OleInitialize()

	m_pFactory = new CProviderFactory();

	if((hRes = CoRegisterClassObject(CLSID_EventViewer,
							(IUnknown *)m_pFactory,
							CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
							REGCLS_MULTIPLEUSE,
							&m_clsReg)) == S_OK)
	{
		TRACE(_T("registered\n"));
	}
	else
	{
		TRACE(_T("not registered\n"));
	}

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

    // if cimom launched me...
    if(COMLaunched)
    {
        // do the heavy dlg creation and potential
        // download in CProviderFactory::CreateInstance().
        // Doing it here takes too long; cimom times out
        // and I dont get my event.
        m_dlg = NULL;
        CreateMainUI();
    }
    else
    {
        // user launched me. No event coming so user might
        // want some UI now. :)
        CreateMainUI();
    }
	// start the pump.
	return TRUE;
}

void CContainerApp::CreateMainUI(void)
{
    if(m_dlg == NULL)
    {
   	    m_dlg = new CContainerDlg;
	    m_pMainWnd = m_dlg;

	    // display modeless UI.
	    m_dlg->Create(IDD_CONTAINER_DIALOG);
    }
}

//------------------------------------------------------
BOOL CContainerApp::OnQueryEndSession()
{
	// premature closure; play nice with COM.
	if(m_pProvider)
		CoDisconnectObject(m_pProvider, 0);

	if(m_pConsumer)
		CoDisconnectObject(m_pConsumer, 0);

	if(m_clsReg)
	{
		HRESULT hres = CoRevokeClassObject(m_clsReg);
		CoUninitialize();
		m_clsReg = 0;
	}
	return TRUE;
}

//------------------------------------------------------
void CContainerApp::EvalStartApp(void)
{
	// NOTE: restarts UI if an event comes in during
	// 'hidden' mode.
	if(m_dlg == NULL)
	{
		m_dlg = new CContainerDlg;
		m_pMainWnd = m_dlg;
		m_dlg->Create(IDD_CONTAINER_DIALOG);
	}
}

//------------------------------------------------------
void CContainerApp::EvalQuitApp(void)
{
	// NOTE: these 3 COM objs will NULL their global ptr
	// on their last release and call this routine.

	// if all COM objs are released now and the UI is hidden...
	if((m_pProvider == NULL) &&
		(m_pConsumer == NULL) &&
		(m_dlg == NULL))
	{
		// really quit the app.
		PostQuitMessage(0);
	}

	// else I just stay around awhile longer.
}

//------------------------------------------------------
int CContainerApp::ExitInstance()
{
	if(m_clsReg)
	{
		HRESULT hres = CoRevokeClassObject(m_clsReg);
		CoUninitialize();
	}

	__try
	{
		if(m_htmlHelpInst)
		{
		//	FreeLibrary(m_htmlHelpInst);
			m_htmlHelpInst = 0;
		}
	}
	__except(1)
	{}


	return CWinApp::ExitInstance();
}

//----------------------------------------------------
#define TCHAR_LEN_IN_BYTES(str)	 _tcslen(str)*sizeof(TCHAR)+sizeof(TCHAR)

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
// Note: Key setups are:
//		HKCR\CLSID\[guid]= friendly name
//		HKCR\CLSID\[guid]\LocalServer32 = exe's path.
//		HKCR\CLSID\AppID = [guid]
//		HKCR\AppID\[guid] = friendly name
//		HKCR\AppID\[guid] = 'RunAs' = "Interactive User"
//			'RunAs' is a value name; not a subkey.
//***************************************************************************
void CContainerApp::RegisterServer(void)
{
	HKEY hKey1, hKey2;

	TCHAR       wcConsID[] = _T("{DD2DB150-8D3A-11d1-ADBF-00AA00B8E05A}");
    TCHAR       wcCLSID[] = _T("CLSID\\{DD2DB150-8D3A-11d1-ADBF-00AA00B8E05A}");
    TCHAR       wcAppID[] = _T("AppID\\{DD2DB150-8D3A-11d1-ADBF-00AA00B8E05A}");
    TCHAR      wcModule[128];	// this will hold the exe's path.
	TCHAR ConsumerTextForm[] = _T("WMI Event Viewer");

	// this will allow the server to display its windows on the active desktop instead
	// of the hidden desktop where services run.
	TCHAR Interactive[] = _T("Interactive User");

	// need to register now.
	GetModuleFileName(NULL, wcModule,  128);

	//Set the "default" text under CLSID
	//==========================
	RegCreateKey(HKEY_CLASSES_ROOT, wcCLSID, &hKey1);
	RegSetValueEx(hKey1, NULL, 0, REG_SZ,
					(LPBYTE)ConsumerTextForm,
					TCHAR_LEN_IN_BYTES(ConsumerTextForm));

	// create the LocalServer32 key so the server can be found.
	RegCreateKey(hKey1, _T("LocalServer32"), &hKey2);
	RegSetValueEx(hKey2, NULL, 0, REG_SZ, (LPBYTE)wcModule, TCHAR_LEN_IN_BYTES(wcModule));
	RegSetValueEx(hKey1, _T("AppID"), 0, REG_SZ, (LPBYTE)wcConsID, TCHAR_LEN_IN_BYTES(wcConsID));

	CloseHandle(hKey2);
	CloseHandle(hKey1);

	// now do the AppID keys.
	RegCreateKey(HKEY_CLASSES_ROOT, wcAppID, &hKey1);
	RegSetValueEx(hKey1, NULL, 0, REG_SZ,
					(LPBYTE)ConsumerTextForm,
					TCHAR_LEN_IN_BYTES(ConsumerTextForm));

	// this makes the local server run on the active desktop (the one you're seeing)
	// instead of the hidden desktop that services run on (which doesn't have UI)
	RegSetValueEx(hKey1, _T("RunAs"), 0, REG_SZ, (LPBYTE)Interactive, TCHAR_LEN_IN_BYTES(Interactive));
	CloseHandle(hKey1);

}


//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************
void CContainerApp::UnregisterServer(void)
{

	TCHAR       wcConsID[] = _T("{DD2DB150-8D3A-11d1-ADBF-00AA00B8E05A}");
    TCHAR       wcCLSID[] = _T("CLSID\\{DD2DB150-8D3A-11d1-ADBF-00AA00B8E05A}");
    TCHAR       wcAppID[] = _T("AppID\\{DD2DB150-8D3A-11d1-ADBF-00AA00B8E05A}");
    HKEY hKey1;
	DWORD dwRet;

	// delete the keys under CLSID\[guid]
    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, wcCLSID, &hKey1);
    if(dwRet == NOERROR)
    {
        RegDeleteKey(hKey1, _T("LocalServer32"));
        CloseHandle(hKey1);
    }

	// delete CLSID\[guid] <default>
    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, _T("CLSID"), &hKey1);
    if(dwRet == NOERROR)
    {
        RegDeleteKey(hKey1,wcConsID);
        CloseHandle(hKey1);
    }

	// delete AppID\[guid] <default>
    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, _T("AppID"), &hKey1);
    if(dwRet == NOERROR)
    {
        RegDeleteKey(hKey1, wcConsID);
        CloseHandle(hKey1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventregedit\util.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved



IWbemServices * InitServices(CString *pcsNameSpace = NULL, IWbemLocator *pLocator = NULL);

BOOL WbemObjectIdentity(CString &rcsWbem1, CString &rcsWbem2);

int StringInArray
		(CStringArray *pcsaArray, CString *pcsString, int nIndex);

BOOL GetErrorObjectText
(IWbemClassObject *pErrorObject, CString &rcsDescription);

IWbemClassObject *CreateSimpleClass
(IWbemServices * pProv, CString *pcsNewClass, CString *pcsParentClass,
 int &nError, CString &csError );

IWbemClassObject *GetClassObject (IWbemServices *pProv,CString *pcsClass, BOOL bQuiet = FALSE);

BOOL SetProperty
(IWbemServices * pProv, IWbemClassObject * pInst, 
 CString *pcsProperty, CString *pcsPropertyValue);

BOOL SetProperty
(IWbemServices * pProv, IWbemClassObject * pInst, 
 CString *pcsProperty, long lValue);

CString GetProperty
(IWbemClassObject * pInst, CString *pcsProperty, BOOL bQuietly = FALSE);

CString GetBSTRProperty
(IWbemServices * pProv, IWbemClassObject * pInst, 
 CString *pcsProperty);

CString GetBSTRProperty
(IWbemClassObject * pInst, CString *pcsProperty);

SCODE GetClasses(IWbemServices * pIWbemServices, CString *pcsParent,
			   CPtrArray &cpaClasses, CString &rcsNamespace);

int GetAllClasses(IWbemServices * pIWbemServices, CPtrArray &cpaClasses, CString &rcsNamespace);

CStringArray *GetAllClassPaths(IWbemServices * pIWbemServices, CString &rcsNamespace);

BOOL HasSubclasses(IWbemServices * pIWbemServices, CString *pcsClass, CString &rcsNamespace);

BOOL HasSubclasses(IWbemServices * pIWbemServices, IWbemClassObject *pimcoClass, CString &rcsNamespace);

long GetAttribBSTR
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName, 
 CString &csReturn);

long GetAttribBool
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName, 
 BOOL &bReturn);

SCODE MakeSafeArray
(SAFEARRAY FAR ** pRet, VARTYPE vt, int iLen);

SCODE PutStringInSafeArray
(SAFEARRAY FAR * psa,CString *pcs, int iIndex);

BOOL DeleteAClass
(IWbemServices * pProv, CString *pcsClass);

IWbemClassObject *RenameAClass
(IWbemServices * pProv, IWbemClassObject *pimcoClass, CString *pcsNewName,
 BOOL bDeleteOriginal = FALSE);

IWbemClassObject *ReparentAClass
(IWbemServices * pProv, IWbemClassObject *pimcoParent, IWbemClassObject *pimcoChild);

CString GetIWbemFullPath(IWbemClassObject *pClass);

CString GetIWbemRelativePath(IWbemClassObject *pClass);

BOOL ClassIdentity(IWbemClassObject *piWbem1, IWbemClassObject *piWbem2);

void ReleaseErrorObject(IWbemClassObject *&rpErrorObject);

void ErrorMsg
(CString *pcsUserMsg, SCODE sc, IWbemClassObject *pErrorObject, BOOL bLog, 
 CString *pcsLogMsg, char *szFile, int nLine, UINT uType = MB_ICONEXCLAMATION);

void LogMsg
(CString *pcsLogMsg, char *szFile, int nLine);

BOOL ObjectInDifferentNamespace
(IWbemServices *pProv, CString *pcsNamespace, IWbemClassObject *pObject);

CString GetHmomWorkingDirectory();

SCODE GetInstances
(IWbemServices *pServices, CString *pcsClass, CPtrArray &cpaInstances, BOOL bDeep);

CString BuildOBJDBGetAssocsQuery
	(IWbemServices *pProv, 
	CString *pcsTargetPath, 
	CString *pcsAssocClass, 
	CString *pcsResultClass, 
	CString *pcsMyRoleFilter, 
	CString *pcsReqAttrib, 
	CString *pcsReqAssocAttrib, 
	CString *pcsResultRole, BOOL bClassOnly);

CString BuildOBJDBGetRefQuery
	(IWbemServices *pProv, 
	CString *pcsTarget, 
	CString *pcsResultClass, 
	CString *pcsRoleFilter,
	CString *pcsReqAttrib = NULL,
	BOOL bClassOnly = FALSE);

IEnumWbemClassObject *ExecOBJDBQuery
(IWbemServices * pProv, CString &csQuery);

CPtrArray *SemiSyncEnum
(IEnumWbemClassObject *pEnum, BOOL &bCancel, HRESULT &hResult, int nRes);

CString GetIWbemClass(IWbemClassObject *pClass);

CStringArray *GetAllKeyPropValuePairs(IWbemClassObject *pObject);

CString GetClass(CString *pcsPath);

BOOL ArePathsEqual (CString csPath1, CString csPath2);

CString GetPropertyNameByAttrib(IWbemClassObject *pObject , CString *pcsAttrib);

BOOL IsClassAbstract(IWbemClassObject* pObject);

CStringArray *ClassDerivation (IWbemClassObject *pObject);

BOOL IsObjectOfClass(CString &csClass, IWbemClassObject *pObject);

//HRESULT ConfigureSecurity(IUnknown *pUnknown);

struct ParsedObjectPath;

class CComparePaths
{
public:
	BOOL PathsRefSameObject(BSTR bstrPath1, BSTR bstrPath2);

private:
	int CompareNoCase(LPWSTR pws1, LPWSTR pws2);
	BOOL IsEqual(LPWSTR pws1, LPWSTR pws2) {return CompareNoCase(pws1, pws2) == 0; }
	BOOL PathsRefSameObject(ParsedObjectPath* ppath1, ParsedObjectPath* ppath2);
	void NormalizeKeyArray(ParsedObjectPath& path);
	BOOL IsSameObject(BSTR bstrPath1, BSTR bstrPath2);
	BOOL KeyValuesAreEqual(VARIANT& variant1, VARIANT& variant2);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\containerdlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ContainerDlg.h : header file
//
//{{AFX_INCLUDES()
#include "eventlist.h"
//}}AFX_INCLUDES

#if !defined(AFX_CONTAINERDLG_H__AC146508_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_)
#define AFX_CONTAINERDLG_H__AC146508_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

const int IDC_TOOLBAR = 1;

/////////////////////////////////////////////////////////////////////////////
// CContainerDlg dialog
#define WM_MY_REGISTER (WM_APP + 1)
#define WM_MY_PROPERTIES (WM_APP + 2)
#define WM_MY_CLEAR (WM_APP + 3)
#define WM_AMBUSH_FOCUS (WM_APP + 4)


#include "resource.h"
#include "EventReg.h"

class CContainerDlg : public CDialog
{
// Construction
public:
	CContainerDlg(CWnd* pParent = NULL);	// standard constructor
	virtual ~CContainerDlg();

    void UpdateCounter();

// Dialog Data
	//{{AFX_DATA(CContainerDlg)
	enum { IDD = IDD_CONTAINER_DIALOG };
	CStatic	m_itemCount;
	CButton	m_helpBtn;
	CButton	m_closeBtn;
	//}}AFX_DATA

	CEventList m_EventList;
	CToolBarCtrl m_toolbar;

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CContainerDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual void PostNcDestroy();
	//}}AFX_VIRTUAL

	DECLARE_EVENTSINK_MAP()

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CContainerDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg void OnClose();
	afx_msg void OnHelp();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	// catch the event.
	void OnSelChanged(long iSelected);
	BOOL OnToolTipNotify( UINT id, NMHDR * pNMHDR, LRESULT * pResult );
    bool NeedToUpgrade();

	EventReg *m_regDlg;

	int m_activateMe;
#define RESET_ACTIVATEME 3

	// resizing vars;
	UINT m_listSide;		// margin on each side of list.
	UINT m_listTop;			// top of dlg to top of list.
	UINT m_listBottom;		// bottom of dlg to bottom of list.
	UINT m_closeLeft;		// close btn left edge to dlg right edge.
	UINT m_helpLeft;		// close btn left edge to dlg right edge.
	UINT m_btnTop;			// btn top to dlg bottom.
	UINT m_counterTop;		// counter top to dlg bottom.
	UINT m_counterW;		// counter width
	UINT m_counterH;		// counter height

	UINT m_btnW;			// btn width
	UINT m_btnH;			// btn height
	bool m_initiallyDrawn;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONTAINERDLG_H__AC146508_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\container.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Container.h : main header file for the CONTAINER application
//

#if !defined(AFX_CONTAINER_H__AC146506_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_)
#define AFX_CONTAINER_H__AC146506_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "factory.h"
#include "provider.h"
#include "consumer.h"
#include "ContainerDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CContainerApp:
// See Container.cpp for the implementation of this class
//

class CContainerApp : public CWinApp
{
public:
	CContainerApp();
	virtual ~CContainerApp();
	HINSTANCE m_htmlHelpInst;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CContainerApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

	long m_maxItemsFmCL;
	CProviderFactory *m_pFactory;
	CProvider *m_pProvider;
	CConsumer *m_pConsumer;
	CContainerDlg *m_dlg;

	void EvalStartApp(void);
	void EvalQuitApp(void);
    // NOTE: factory calls this too.
    void CreateMainUI(void);

// Implementation

	//{{AFX_MSG(CContainerApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		afx_msg BOOL OnQueryEndSession();
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	DWORD m_clsReg;
	void RegisterServer(void);
	void UnregisterServer(void);
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONTAINER_H__AC146506_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\containerdlg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ContainerDlg.cpp : implementation file
//

#include "precomp.h"
#include "Container.h"
#include "resource.h"		// main symbols
#include "ContainerDlg.h"
#include "cvCache.h"
#include "htmlhelp.h"
#include "WbemRegistry.h"
#include "WbemVersion.h"
#include "HTMTopics.h"

extern CContainerApp theApp;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	CStatic	m_wbemVersion;
	CStatic	m_myVersion;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//---------------------------------------------
CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

//---------------------------------------------
void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	DDX_Control(pDX, IDC_WBEMVERSION, m_wbemVersion);
	DDX_Control(pDX, IDC_MYVERSION, m_myVersion);
	//}}AFX_DATA_MAP
}

//---------------------------------------------
BOOL CAboutDlg::OnInitDialog()
{
	TCHAR ver[30];

	CDialog::OnInitDialog();

	memset(ver, 0, 30);
	GetMyVersion(AfxGetInstanceHandle(), ver, 30);
	m_myVersion.SetWindowText(ver);

	memset(ver, 0, 30);
	GetCimomVersion(ver, 30);
	m_wbemVersion.SetWindowText(ver);


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//---------------------------------------------
BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////
// CContainerDlg dialog
BEGIN_EVENTSINK_MAP(CContainerDlg, CDialog)
    //{{AFX_EVENTSINK_MAP(CContainerDlg)
	//}}AFX_EVENTSINK_MAP
	ON_EVENT_REFLECT(CContainerDlg,1,OnSelChanged,VTS_I4)
END_EVENTSINK_MAP()


CContainerDlg::CContainerDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CContainerDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CContainerDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_initiallyDrawn = false;
    m_regDlg = NULL;
	m_activateMe = RESET_ACTIVATEME;
}

//---------------------------------------------------------
CContainerDlg::~CContainerDlg()
{
}

//----------------------------------------------------------
void CContainerDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CContainerDlg)
	DDX_Control(pDX, IDC_ITEMCOUNT, m_itemCount);
	DDX_Control(pDX, IDC_HELPME, m_helpBtn);
	DDX_Control(pDX, IDC_CLOSE, m_closeBtn);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CContainerDlg, CDialog)
	//{{AFX_MSG_MAP(CContainerDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_BN_CLICKED(IDC_CLOSE, OnClose)
	ON_BN_CLICKED(IDC_HELPME, OnHelp)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
	ON_NOTIFY_EX( TTN_NEEDTEXT, 0, OnToolTipNotify )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CContainerDlg message handlers
TBBUTTON buttons[] =
{
	{0, WM_MY_REGISTER, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, NULL},
	{1, WM_MY_PROPERTIES, 0, TBSTYLE_BUTTON, 0, NULL},
	{2, WM_MY_CLEAR, 0, TBSTYLE_BUTTON, 0, NULL}
};

//-----------------------------------------------------------
BOOL CContainerDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}

		// I dont support these two.
		pSysMenu->EnableMenuItem(SC_SIZE,
								MF_DISABLED|MF_GRAYED|MF_BYCOMMAND );

		pSysMenu->EnableMenuItem(SC_MAXIMIZE,
								MF_DISABLED|MF_GRAYED|MF_BYCOMMAND );
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	CRect rcBounds;

	GetClientRect(&rcBounds);
	rcBounds.left = 20;

	if(m_toolbar.Create(WS_CHILD|WS_VISIBLE|TBSTYLE_TOOLTIPS|CCS_TOP,
						rcBounds, this, IDC_TOOLBAR))
	{
		EnableToolTips();
		m_toolbar.AddBitmap(3, IDB_TOOLBAR);
		m_toolbar.AddButtons(3, buttons);
	}

	CRect rect;
	CWnd *placeHolder = GetDlgItem(IDC_PLACEHOLDER);
	placeHolder->GetWindowRect(&rect);
	ScreenToClient(&rect);
	placeHolder->DestroyWindow();

    BOOL created = false;

    // I dont need to upgrade...
    if(!NeedToUpgrade())
    {
        // try to create..
   		created = m_EventList.Create(_T("the eventlist"),
										WS_CHILD|WS_VISIBLE,
										rect, this,
										IDC_EVENTLISTCTRL);
    }

    // if it failed or I needed to upgrade anyway...
    if(!created)
    {
		// install the ocx.
		WCHAR elClsid[50];

		wcscpy(elClsid, L"{AC146530-87A5-11D1-ADBD-00AA00B8E05A}");
		CString cabPath(".");
		WbemRegString(APP_DIR, cabPath);
		cabPath += _T("\\wbemtool.cab");

		CCustomViewCache cache;
		cache.NeedComponent(elClsid, cabPath);

		// try again.
		created = m_EventList.Create(_T("the eventlist"),
										WS_CHILD|WS_VISIBLE,
										rect, this,
										IDC_EVENTLISTCTRL);
	}

	// if the control was there..
	if(created)
	{
		if(theApp.m_maxItemsFmCL != 0)
		{
	        m_EventList.SetMaxItems(theApp.m_maxItemsFmCL);
		}
#ifdef _DEBUG
//		else
//		{
//	        m_EventList.SetMaxItems(4);
//		}
#endif
		// get rid of the error label.
		placeHolder = GetDlgItem(IDC_CAB_ERROR_MSG);
		placeHolder->DestroyWindow();
		m_EventList.RedrawWindow();

		//-----------------------------------------
		// save the original position for later resizing.

		// get the bounds again.
		GetClientRect(&rcBounds);

		// NOTE: rcBounds is the dlg; rect is the list.

		// margin on each side of list.
		m_listSide = rect.left - rcBounds.left;

		// top of dlg to top of list.
		m_listTop = rect.top - rcBounds.top;

		// bottom of dlg to bottom of list.
		m_listBottom = rcBounds.Height() - rect.Height() - m_listTop;

		//-------------------------------------------
		// get the close button.
		m_closeBtn.GetWindowRect(&rect);
		ScreenToClient(&rect);

		// close btn right edge to dlg right edge.
		m_closeLeft = rcBounds.Width() - rect.left;

		// btn top to dlg bottom.
		m_btnTop = rcBounds.Height() - rect.top;

		//-------------------------------------------
		// get the close button.
		m_itemCount.GetWindowRect(&rect);
		ScreenToClient(&rect);

		// counter top to dlg bottom.
		m_counterTop = rcBounds.Height() - rect.top;
		m_counterW = rect.Width();
		m_counterH = rect.Height();

		//-------------------------------------------
		// deal with help button
		m_helpBtn.GetWindowRect(&rect);
		ScreenToClient(&rect);

		// help btn right edge to dlg right edge.
		m_helpLeft = rcBounds.Width() - rect.left;

		m_btnW = rect.Width();
		m_btnH = rect.Height();

		m_initiallyDrawn = true;
	}

    UpdateCounter();
	return TRUE;  // return TRUE  unless you set the focus to a control
}

//-----------------------------------------------
void CContainerDlg::UpdateCounter()
{
    long curCount = m_EventList.GetItemCount();

    // eat the error code.
    if(curCount < 0)
        curCount = 0;

    // if empty...
    if(curCount == 0)
    {
        m_itemCount.ShowWindow(SW_HIDE);
        m_toolbar.EnableButton(WM_MY_CLEAR, FALSE); // disable.
    }
    else
    {
        CString msg;
        CString warning;
        if(curCount >= m_EventList.GetMaxItems())
        {
            warning.LoadString(IDS_FULLLIST_MSG);
        }

        msg.Format(IDS_ITEMCOUNT_FMT, curCount, warning);
        m_itemCount.SetWindowText(msg);
        m_itemCount.ShowWindow(SW_SHOW);

	    if(!m_toolbar.IsButtonEnabled(WM_MY_CLEAR))
	    {
		    m_toolbar.EnableButton(WM_MY_CLEAR, TRUE); // enable.
	    }
    }
}

//-----------------------------------------------
bool CContainerDlg::NeedToUpgrade()
{
	LONG lResult;
	HKEY hkeyHmomCwd;
    TCHAR wcCLSID[] = _T("CLSID\\{AC146530-87A5-11D1-ADBD-00AA00B8E05A}\\Version");

	lResult = RegOpenKeyEx(HKEY_CLASSES_ROOT,
							wcCLSID, 0,
							KEY_READ | KEY_QUERY_VALUE,
							&hkeyHmomCwd);

	if(lResult != ERROR_SUCCESS)
	{
        // key not found, need to upgrade.
		return true;
	}

	WCHAR buf[20];
	unsigned long lcbValue = sizeof(buf);

	lResult = RegQueryValueEx(hkeyHmomCwd, NULL,
								NULL, NULL,
								(LPBYTE)buf, &lcbValue);

	RegCloseKey(hkeyHmomCwd);

   	if(lResult == ERROR_SUCCESS)
	{
        // upgrade if the control is 'smaller' (older)
        // than me (_BUILDNO).
//#ifdef _BUILDNO
        return(_tcscmp((const TCHAR *)&buf[2], _T("0")) < 0);
//#else
//        return(_tcscmp((const TCHAR *)&buf[2], _T("999")) < 0);
//#endif _BUILDNO

    }

    // value not found, need to upgrade.
    return true;
}

//----------------------------------------------------------
BOOL CContainerDlg::OnToolTipNotify( UINT id, NMHDR * pNMHDR, LRESULT * pResult )
{
	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *)pNMHDR;
	UINT_PTR nID =pNMHDR->idFrom;
	switch(nID)
	{
	case WM_MY_REGISTER:
		pTTT->lpszText = MAKEINTRESOURCE(IDS_TT_REGISTER);
		pTTT->hinst = AfxGetResourceHandle();
		return(TRUE);
		break;
	case WM_MY_PROPERTIES:
		pTTT->lpszText = MAKEINTRESOURCE(IDS_TT_PROPERTIES);
		pTTT->hinst = AfxGetResourceHandle();
		return(TRUE);
		break;
	case WM_MY_CLEAR:
		pTTT->lpszText = MAKEINTRESOURCE(IDS_TT_CLEARALL);
		pTTT->hinst = AfxGetResourceHandle();
		return(TRUE);
		break;
	}

	return(FALSE);
}

//-------------------------------------------------------
void CContainerDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}


// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CContainerDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

void CContainerDlg::PostNcDestroy()
{
	CDialog::PostNcDestroy();
	delete this;
}

void CContainerDlg::OnCancel()
{
	OnClose();
}

void CContainerDlg::OnClose()
{
	if(m_regDlg)
	{
		// this routine will kill off the dlg object itself.
		m_regDlg->ReallyGoAway();

		// no use for the ptr anymore.
		m_regDlg = NULL;
	}

	CString caption, threat;
	caption.LoadString(IDS_TITLE);
	threat.LoadString(IDS_WANT_TO_EXIT);

	if(MessageBox(threat, caption,
					MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2) == IDYES)
	{
		theApp.m_dlg = NULL;
		DestroyWindow();
		theApp.EvalQuitApp();
	}
}

BOOL CContainerDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
	switch(LOWORD(wParam))
	{
	case WM_MY_PROPERTIES:
		m_EventList.DoDetails();
		return TRUE;
		break;

	case WM_AMBUSH_FOCUS:
		m_activateMe--;
		TRACE(_T("ambushing focus\n"));
		if(m_activateMe == 0)
		{
			TRACE(_T("no setting focus\n"));
			SetFocus();
		}
		else
		{
			TRACE(_T("resetting the hack\n"));
			PostMessage(WM_COMMAND, WM_AMBUSH_FOCUS);
		}

		return TRUE;
		break;

	case WM_MY_REGISTER:
		{
            // doesnt exist yet...
            if(m_regDlg == NULL)
            {
                // create and display.
                m_regDlg = new EventReg(this);
                if(m_regDlg)
                {
			        m_regDlg->Create(IDD_EVENT_REG);
	                m_regDlg->ShowWindow(SW_SHOWNORMAL);
					m_activateMe = RESET_ACTIVATEME;
					//if(::IsWindow(m_hWnd)
					//	PostMessage(WM_COMMAND, WM_AMBUSH_FOCUS);
                }
            }
            else // already exists..
            {
                // want it again.
                m_regDlg->ShowWindow(SW_SHOWNORMAL);
            }
		}
		return TRUE;
		break;

	case WM_MY_CLEAR:
		m_EventList.Clear(-1);
        UpdateCounter();

		return TRUE;
		break;
	} // endswitch

	return CDialog::OnCommand(wParam, lParam);
}

//----------------------------------------------------
void CContainerDlg::OnSelChanged(long iSelected)
{
	// if nothing selected...
	if(iSelected == -1)
	{
		m_toolbar.EnableButton(WM_MY_PROPERTIES, FALSE);
	}
	else   // something selected.
	{
		m_toolbar.EnableButton(WM_MY_PROPERTIES, TRUE);
	}
}

//-------------------------------------------------------
void CContainerDlg::OnHelp()
{
	CString csPath;
	WbemRegString(SDK_HELP, csPath);

	CString csData = idh_eventviewer;
	HWND hWnd = NULL;

	try
	{
		HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD_PTR) (LPCTSTR) csData);
		if(!hWnd)
		{
			AfxMessageBox(IDS_NOHTMLHELP, MB_OK|MB_ICONSTOP);
		}
	}

	catch( ... )
	{
		// Handle any exceptions here.
		AfxMessageBox(IDS_NOHTMLHELP, MB_OK|MB_ICONSTOP);
	}
}

//-------------------------------------------------------
void CContainerDlg::OnSize(UINT nType, int cx, int cy)
{
	CDialog::OnSize(nType, cx, cy);
	if(m_initiallyDrawn)
	{
		m_itemCount.MoveWindow(m_listSide, cy - m_counterTop,
								m_counterW, m_counterH);

		m_EventList.MoveWindow(m_listSide, m_listTop,
								cx - (2 * m_listSide), cy - m_listBottom - m_listTop);

		m_closeBtn.MoveWindow(cx - m_closeLeft, cy - m_btnTop,
								m_btnW, m_btnH);

		m_helpBtn.MoveWindow(cx - m_helpLeft, cy - m_btnTop,
								m_btnW, m_btnH);

		m_itemCount.Invalidate();
		m_closeBtn.Invalidate();
		m_helpBtn.Invalidate();
		Invalidate();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\cvcache.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include <afxcmn.h>
#include "resource.h"
#include "DlgDownload.h"
#include "cvcache.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h




class CViewInfo
{
public:
	CViewInfo();
	~CViewInfo();
	void InstallComponent();

	BOOL CustomViewIsRegistered(CLSID& clsid, DWORD dwFileVersionMS, DWORD dwFileVersionLS);

	CString m_sClass;		// The target class of this viewer
    CLSID m_clsid;			// The GUID of the class viewer ActiveX control.
	DWORD m_dwFileVersionMS;  // The most significant part of the version number.
	DWORD m_dwFileVersionLS;  // The least significant part of the version number.
	COleVariant m_varCodebase; // The location of the class viewer ActiveX control.
	CString m_sTitle;		// The title that goes into the view selection combo box

private:
	SCODE DownloadCustomView(LPUNKNOWN& punk);
};


CViewInfo::CViewInfo()
{
}

CViewInfo::~CViewInfo()
{
}



//***********************************************************************
// CViewInfo::DownloadCustomView
//
// Download the custom view.
//
// Parameters:
//		[out] LPUNKNOWN& punk
//			The interface pointer to the custom view is returned here.
//
//
// Returns:
//		SCODE
//			S_OK if the custom view was downloaded and installed successfully,
//			a failure code otherwise.
//
//***********************************************************************
SCODE CViewInfo::DownloadCustomView(LPUNKNOWN& punk)
{
	SCODE sc;

	CDlgDownload dlg;
	sc = dlg.DoDownload(
			punk,
			m_clsid,
			m_varCodebase.bstrVal,
			m_dwFileVersionMS,
			m_dwFileVersionLS
			);

	return sc;
}



//************************************************************
// CViewInfo::CustomViewIsRegistered
//
// Parameters:
//		[in] CLSID& clsid
//			The class id for the custom view.
//
//		[in] DWORD dwFileVersionMS
//			The most significant part of the desired version number.
//			A value of 0xffffffff means any version.
//
//		[in] DWORD dwFileVersionLS
//			The least significant part of the desired version number.
//			A value of 0xffffffff means any version.
//
//
// Returns:
//		BOOL
//			TRUE if an OCX corresponding to the specified class id is
//			registered and the version number of the registered control
//			is the same or greater than the requested version.
//
//**************************************************************
BOOL CViewInfo::CustomViewIsRegistered(CLSID& clsid, DWORD dwFileVersionMS, DWORD dwFileVersionLS)
{
	// Read the version string from HKEY_CLASSES_ROOT\CLSID\<CLSID>\Version
	//
	// If this key exists, then we know that some version of the custom view is
	// registered, so if the file version is wildcarded, the custom view is installed.
	//
	// If a wildcard is not specified for the file version, then the installed
	// version must be the same or higher than the requested version.
	//
	HKEY hkeyClassesRoot = NULL;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_CLASSES_ROOT, &hkeyClassesRoot);
	if (lResult != ERROR_SUCCESS) {
		return FALSE;
	}




	// Construct a key path to the version key.
	LPOLESTR pwszClsid = NULL;

	SCODE sc;
	sc = StringFromCLSID(clsid, &pwszClsid);
	if(sc != S_OK)
	{
		return FALSE;
	}

	CString sVersionKey;
	sVersionKey = _T("CLSID\\{");
	sVersionKey += pwszClsid;
	sVersionKey += _T("}");
	sVersionKey += _T("\\Version");


	// Open the version key
	HKEY hkeyVersion = NULL;
	lResult = RegOpenKeyEx(
				hkeyClassesRoot,
				(LPCTSTR) sVersionKey,
				0,
				KEY_READ,
				&hkeyVersion);

	if (lResult != ERROR_SUCCESS) {
		RegCloseKey(hkeyClassesRoot);
		return FALSE;
	}


	// Read the version string
	unsigned long lcbValue = 256;
	CString sVersion;
	LPTSTR pszVersion = sVersion.GetBuffer(lcbValue);

	unsigned long lType;
	lResult = RegQueryValueEx(
				hkeyVersion,
				(LPCTSTR) _T(""),
				NULL,
				&lType,
				(unsigned char*) (void*) pszVersion,
				&lcbValue);


	sVersion.ReleaseBuffer();
	RegCloseKey(hkeyVersion);
	RegCloseKey(hkeyClassesRoot);

	if (lResult != ERROR_SUCCESS) {
		return FALSE;
	}

	// If the requested file version is ANY, then the control is registered
	if (dwFileVersionMS == ~0) {
		return TRUE;
	}




	DWORD dwFileVersionMSRegistered;
	DWORD dwFileVersionLSRegistered;
	int nFieldsConverted = 0;
	nFieldsConverted =  _stscanf(pszVersion, _T("%ld.%ld"), &dwFileVersionMSRegistered, &dwFileVersionLSRegistered);

	if (nFieldsConverted != 2) {
		return FALSE;
	}


	if (dwFileVersionMS != ~0) {
		if (dwFileVersionMSRegistered < dwFileVersionMS) {
			return FALSE;
		}

		if (dwFileVersionLS != ~0) {
			if (dwFileVersionLSRegistered < dwFileVersionLS) {
				return FALSE;
			}
		}
	}

	return TRUE;
}

//*******************************************************************************
void CViewInfo::InstallComponent()
{
	BOOL bViewIsRegistered;
	bViewIsRegistered = CustomViewIsRegistered(m_clsid, m_dwFileVersionMS, m_dwFileVersionLS);

	// its not there...
	if(!bViewIsRegistered)
	{

		// go get it.
		LPUNKNOWN punkDownload = NULL;
		SCODE sc;
		sc = DownloadCustomView(punkDownload);
		if(FAILED(sc))
		{
			if(sc != E_ABORT)
			{
				// If the download was cancelled, then the user is already aware of the
				// fact that the view is not available. If some other error occurred,
				// give the user a warning.
				AfxMessageBox(IDS_ERR_CUSTOM_VIEW_MISSING, MB_OK|MB_ICONSTOP);
			}
			return;
		}

		// throw it away. We're only installing, not using.
		if(punkDownload)
		{
			//punkDownload->Release();
			punkDownload = NULL;
		}
	}
}


//===========================================================================
CCustomViewCache::CCustomViewCache()
{
}


CCustomViewCache::~CCustomViewCache()
{
}

//------------------------------------------------------------------------------
SCODE CCustomViewCache::NeedComponent(LPWSTR szClsid, LPCTSTR szCodeBase,
									  int major, int minor)
{
	SCODE sc = 0;
	CViewInfo* pViewInfo = new CViewInfo;

	sc = CLSIDFromString((OLECHAR*) szClsid, &pViewInfo->m_clsid);
	if(sc != S_OK)
	{
		// The class ID format is not valid, so ignore this view since we
		// can't display it anyway.
		delete pViewInfo;
		return sc;
	}

	pViewInfo->m_varCodebase = szCodeBase;
	pViewInfo->m_dwFileVersionMS = major;
	pViewInfo->m_dwFileVersionLS = minor;

	//not using these two.
	pViewInfo->m_sTitle.Empty();
	pViewInfo->m_sClass.Empty();


	// Add this view info to the cache.
	pViewInfo->InstallComponent();

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\dlgdownload.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// DlgDownload.cpp : implementation file
//

#include "precomp.h"
#include <afxcmn.h>
#include "resource.h"
#include "DlgDownload.h"
#include "winerror.h"
#include "urlmon.h"
#include "download.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgDownload dialog


CDlgDownload::CDlgDownload(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgDownload::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgDownload)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT


	m_pParams = NULL;
	m_pDownload = NULL;
}


CDlgDownload::~CDlgDownload()
{
	delete m_pParams;
	delete m_pDownload;
}

void CDlgDownload::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgDownload)
	DDX_Control(pDX, IDC_ANIMATE, m_progress);
	DDX_Control(pDX, IDC_MSG, m_msg);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgDownload, CDialog)
	//{{AFX_MSG_MAP(CDlgDownload)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgDownload message handlers

void CDlgDownload::OnCancel()
{
	// TODO: Add extra cleanup here
	if (m_pDownload) {
		m_pDownload->UserCancelled();
	}
	else {
		CDialog::OnCancel();
	}

}

BOOL CDlgDownload::OnInitDialog()
{
	CDialog::OnInitDialog();

	BOOL x = m_progress.Open(IDR_AVIDOWNLOAD);

	m_pDownload = new CDownload();

	SCODE sc;
	sc = m_pDownload->DoDownload(m_pParams);
	if (sc != S_ASYNCHRONOUS) {
		EndDialog(IDOK);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



//**************************************************************
// CDlgDownload::DoDownload
//
// This method initiates the downloading of a custom view.  It
// stores all the parameters describing the component to download
// as member data, then calls DoDialog.  OnInitDialog completes
// the downloading process.
//
// Parameters:
//		[out] LPUNKNOWN& punk
//			The instance pointer for the custom view is returned here.
//
//		[in] REFCLSID clsid
//			The class id of the custom view.
//
//		[in] LPCWSTR szCodebase
//			The codebase describing the location of the custom view OCX file.
//
//		[in] DWORD dwFileVersionMS
//			The most significant word of the version number.
//
//		[in] DWORD dwFileVersionLS
//			The least significant word of the version number.
//
//
// Returns:
//		Nothing.
//
//**************************************************************
SCODE CDlgDownload::DoDownload(LPUNKNOWN& punk, REFCLSID clsid, LPCWSTR szCodebase, DWORD dwFileVersionMS, DWORD dwFileVersionLS)
{
	if (!m_pParams) {
		m_pParams = new CDownloadParams;
	}
	m_pParams->m_sc = S_OK;
	m_pParams->m_pdlg = this;
	m_pParams->m_clsid = clsid;
	m_pParams->m_szCodebase = szCodebase;
	m_pParams->m_dwFileVersionMS = dwFileVersionMS;
	m_pParams->m_dwFileVersionLS = dwFileVersionLS;

	DoModal();


	punk = m_pParams->m_punk;
	return m_pParams->m_sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\cvcache.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _cvcache_h
#define _cvcache_h
#pragma once

#define NEWEST_VERSION 0xFFFFFFFF

class CCustomViewCache
{
public:
	CCustomViewCache();
	~CCustomViewCache();

	SCODE NeedComponent(LPWSTR szClsid, LPCTSTR szCodeBase,
					  int major = NEWEST_VERSION, 
					  int minor = NEWEST_VERSION);

private:
	CString m_sTemp;
};


#endif // cvcache_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\download.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  (c) 1997 by Microsoft Corporation
//
//  download.h
//
//  Header file for the custom view downloading implementation.
//
//
//  a-larryf    05-Feb-97   Created.
//
//***************************************************************************


#ifndef _download_h
#define _download_h

#pragma once


class CDlgDownload;
class CDownloadBindStatusCallback;

class CDownloadParams
{
public:	
	// [out]
	SCODE m_sc;
	ULONG m_ulCodeInstallStatus;		// The code install status
	LPUNKNOWN m_punk;

	// [in]
	CDlgDownload* m_pdlg;
	CLSID m_clsid;
	LPCWSTR m_szCodebase;
	DWORD m_dwFileVersionMS;
	DWORD m_dwFileVersionLS;
};


class CDownload {
  public:
    CDownload();
	~CDownload();

	SCODE DoDownload(CDownloadParams* pParams);
	VOID UserCancelled();

	IBindCtx*	GetBindCtx(CDownloadBindStatusCallback *pbsc) const {
		if (pbsc == m_pbsc)
			return m_pbc;
		else
			return NULL;
	}
	CDownloadParams* m_pParams;

  private:
    IMoniker*            m_pmk;
    IBindCtx*            m_pbc;
    CDownloadBindStatusCallback* m_pbsc;
};

#endif //_download_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\dlgdownload.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_DLGDOWNLOAD_H__C9552DA1_009D_11D1_848D_00C04FD7BB08__INCLUDED_)
#define AFX_DLGDOWNLOAD_H__C9552DA1_009D_11D1_848D_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgDownload.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgDownload dialog
class CDownloadParams;
class CDownload;

class CDlgDownload : public CDialog
{
// Construction
public:
	CDlgDownload(CWnd* pParent = NULL);   // standard constructor
	~CDlgDownload();
	HRESULT DoDownload(LPUNKNOWN& punk, REFCLSID clsid, LPCWSTR szCodebase, DWORD dwFileVersionMS, DWORD dwFileVersionLS);

// Dialog Data
	//{{AFX_DATA(CDlgDownload)
	enum { IDD = IDD_DOWNLOAD };
	CAnimateCtrl	m_progress;
	CStatic			m_msg;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgDownload)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgDownload)
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CDownloadParams* m_pParams;
	CDownload* m_pDownload;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGDOWNLOAD_H__C9552DA1_009D_11D1_848D_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\eventlist.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "eventlist.h"

/////////////////////////////////////////////////////////////////////////////
// CEventList

IMPLEMENT_DYNCREATE(CEventList, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CEventList properties

long CEventList::GetMaxItems()
{
	long result;
	GetProperty(0x1, VT_I4, (void*)&result);
	return result;
}

void CEventList::SetMaxItems(long propVal)
{
	SetProperty(0x1, VT_I4, propVal);
}

long CEventList::GetItemCount()
{
	long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CEventList::SetItemCount(long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CEventList operations

void CEventList::DoDetails()
{
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CEventList::Clear(long item)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		item);
	return result;
}

long CEventList::AddWbemEvent(LPUNKNOWN logicalConsumer, LPUNKNOWN Event)
{
	long result;
	static BYTE parms[] =
		VTS_UNKNOWN VTS_UNKNOWN;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		logicalConsumer, Event);
	return result;
}

void CEventList::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\download.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  (c) 1996 by Microsoft Corporation
//
//  download.cpp
//
//  This file, in conjunction with CDlgDownload.cpp, implements custom view
//  downloading.  Downloading is initiated though the CDlgDownload class.
//
//
//  a-larryf    05-Feb-97   Created.
//
//***************************************************************************

#include "precomp.h"
#include "winerror.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "urlmon.h"
#include "download.h"
#include "resource.h"
#include <afxcmn.h>
#include "DlgDownload.h"


//**************************************************************
// GetInetStatusText
//
// This method converts an inet status code into a human readable
// string.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
void GetInetStatusText(CString& sText, SCODE sc)
{
	switch(sc) {
	case S_ASYNCHRONOUS:
		sText = "S_ASYNCHRONOUS";
		break;
	case E_PENDING:
		sText = "E_PENDING";
		break;
	case INET_E_INVALID_URL:
		sText = "INET_E_INVALID_URL";
		break;
	case INET_E_NO_SESSION:
		sText = "INET_E_NO_SESSION";
		break;
	case INET_E_CANNOT_CONNECT:
		sText = "INET_E_CANNOT_CONNECT";
		break;
	case INET_E_RESOURCE_NOT_FOUND:
		sText = "INET_E_RESOURCE_NOT_FOUND";
		break;
	case INET_E_OBJECT_NOT_FOUND:
		sText = "INET_E_OBJECT_NOT_FOUND";
		break;
	case INET_E_DATA_NOT_AVAILABLE:
		sText = "INET_E_DATA_NOT_AVAILABLE";
		break;
	case INET_E_DOWNLOAD_FAILURE:
		sText = "INET_E_DOWNLOAD_FAILURE";
		break;
	case INET_E_AUTHENTICATION_REQUIRED:
		sText = "INET_E_AUTHENTICATION_REQUIRED";
		break;
	case INET_E_NO_VALID_MEDIA:
		sText = "INET_E_NO_VALID_MEDIA";
		break;
	case INET_E_CONNECTION_TIMEOUT:
		sText = "INET_E_CONNECTION_TIMEOUT";
		break;
	case INET_E_INVALID_REQUEST:
		sText = "INET_E_INVALID_REQUEST";
		break;
	case INET_E_UNKNOWN_PROTOCOL:
		sText = "INET_E_UNKNOWN_PROTOCOL";
		break;
	case INET_E_SECURITY_PROBLEM:
		sText = "INET_E_SECURITY_PROBLEM";
		break;
	case INET_E_CANNOT_LOAD_DATA:
		sText = "INET_E_CANNOT_LOAD_DATA";
		break;
	case INET_E_CANNOT_INSTANTIATE_OBJECT:
		sText = "INET_E_CANNOT_INSTANTIATE_OBJECT";
		break;

	}
}




//===================================================================
// Class: CDownloadBindStatusCallback
//
// This class is derived from CBindStatusCallback.  Defining this
// class allows us to override various virtual methods in the base
// class to monitor the progress of downloading a custom view.
//
//====================================================================

// for m_flags
#define USER_CANCELLED	0x1

class CDownloadBindStatusCallback : public IBindStatusCallback, public ICodeInstall {
  public:
    // IUnknown methods
    STDMETHODIMP    QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef()    { return m_cRef++; }
    STDMETHODIMP_(ULONG)    Release()   { if (--m_cRef == 0) { delete this; return 0; } return m_cRef; }

    // IBindStatusCallback methods
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pFmtetc, STGMEDIUM  __RPC_FAR *pstgmed);
	STDMETHODIMP	OnObjectAvailable( REFIID riid, IUnknown* punk);

    STDMETHODIMP    OnStartBinding(DWORD grfBSCOPTION,IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                        LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);

	// ICodeInstall method(s)
    // Old method STDMETHODIMP    GetWindow(HWND *phwnd);
	STDMETHODIMP GetWindow(REFGUID rguidReason, HWND *pHwnd);
	STDMETHODIMP 	OnCodeInstallProblem(
		/* [in] */ ULONG ulStatusCode,
		/* [in] */ LPCWSTR szDestination,
		/* [in] */ LPCWSTR szSource,
		/* [in] */ DWORD dwReserved);


    // constructors/destructors
    CDownloadBindStatusCallback(CDlgDownload* pdlg, CDownload *pdl);
	~CDownloadBindStatusCallback();

 	IBinding * GetBinding() {return m_pbinding;}
    void SetWndText(LPCWSTR szText);

	BOOL HasUserCancelled() const {return (m_flags & USER_CANCELLED);}
	VOID SetUserCancelled() {m_flags |= USER_CANCELLED;}

    // data members
    DWORD           m_cRef;
    IBinding*       m_pbinding;
	CDlgDownload*	m_pdlg;
	CDownload*		m_pdl;
	DWORD			m_flags;
};


//**************************************************************
// CDownloadBindStatusCallback::CDownloadBindStatusCallback
//
// Constructor.
//
// Parameters:
//		[in] CDlgDownload* pdlg
//			Pointer to the download dialog.
//
//
//		[in] CDownload *pdl
//			Pointer to the download object.
//
// Returns:
//		Nothing.
//
//**************************************************************
CDownloadBindStatusCallback::CDownloadBindStatusCallback(
										CDlgDownload* pdlg,
										CDownload *pdl)
{
	m_pdlg = pdlg;
	m_pdl = pdl;
    m_pbinding = NULL;
    m_cRef = 1;
	m_pdl = pdl;
	m_flags = 0;

}  // CDownloadBindStatusCallback

//**************************************************************
// CDownloadBindStatusCallback::!CDownloadBindStatusCallback
//
// Destructor.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
CDownloadBindStatusCallback::~CDownloadBindStatusCallback()
{
    if (m_pbinding)
        m_pbinding->Release();
}  // ~CDownloadBindStatusCallback

//**************************************************************
// CDownloadBindStatusCallback::SetWndText
//
// I don't know why this function is here.  I need to documentation for
// CBindStatusCallback!
//
// Parameters:
//		LPCWSTR szText.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CDownloadBindStatusCallback::SetWndText(LPCWSTR szText)
{
#if 0
	CString sText;
	sText = szText;


	if (m_pdlg->m_hWnd) {
		m_pdlg->SetWindowText(sText);
	}
#endif //0
}



//**************************************************************
// CDownloadBindStatusCallback::QueryInterface
//
// Implementation for query interface.
//
// Parameters:
//		REFIID riid
//			The interface id.
//
//		void** ppv
//			Pointer to the place to return the interface pointer.
//
// Returns:
//		Nothing.
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IBindStatusCallback) {
        *ppv = (IBindStatusCallback *)this;
	}

	if (riid==IID_ICodeInstall)
		*ppv = (ICodeInstall *)this;

	if (*ppv == NULL)
    	return E_NOINTERFACE;

	((IUnknown *)*ppv)->AddRef();

	return S_OK;

}  // CDownloadBindStatusCallback::QueryInterface



//**************************************************************
// CDownloadBindStatusCallback::GetBindInfo
//
// Override the GetBindInfo method from the base class.
//
// Parameters:
//		DWORD* pgrfBINDF
//
//		BINDINFO* pbindInfo
//
// Returns:
//		SCODE
//			S_OK if successful (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    *pgrfBINDF = BINDF_ASYNCHRONOUS;
    pbindInfo->cbSize = sizeof(BINDINFO);
    pbindInfo->szExtraInfo = NULL;
    memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
    return S_OK;
}  // CDownloadBindStatusCallback::GetBindInfo



//**************************************************************
// CDownloadBindStatusCallback::OnStartBinding
//
// The base class calls this method to notify derived classes that
// binding has started. Here we just save the binding pointer.
//
// Parameters:
//		[in] DWORD grfBSCOPTION
//
//		[in] IBinding* pbinding
//			The binding pointer.
//
// Returns:
//		SCODE
//			S_OK if successful (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnStartBinding(DWORD grfBSCOPTION,IBinding* pbinding)
{
    if (pbinding != NULL) {
        pbinding->AddRef();
	}

	m_pbinding = pbinding;
    return S_OK;
}  // CDownloadBindStatusCallback::OnStartBinding



//**************************************************************
// CDownloadBindStatusCallback::GetPriority
//
// I don't know what this method does.  Check the documentation for
// urlmon to find out and update the comments when you do.
//
// Parameters:
//		[in] LONG* pnPriority
//
//
// Returns:
//		SCODE
//			E_NOTIMPL (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::GetPriority(LONG* pnPriority)
{
	return E_NOTIMPL;
}  // CDownloadBindStatusCallback::GetPriority


//**************************************************************
// CDownloadBindStatusCallback::OnProgress
//
// The base class calls this method to notify this derived class
// of the progress of the download.
//
// We update the progress bar in the download dialog each time this
// method is called.
//
// Parameters:
//		[in] ULONG ulProgress
//			The new position of the progress indicator.
//
//		[in] ULONG ulProgressMax
//			The maximum position of the progress indicator.
//
//		[in] ULONG ulStatusCode
//			The status of the download.  We need to check the documentation
//			for urlmon to see what this is.
//
//		[in] LPCWSTR szStatusText
//			A messatge that can be displayed to provide the user with
//			more information about the status of the download.
//
//
// Returns:
//		SCODE
//			NOERROR) (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnProgress(ULONG ulProgress,
													 ULONG ulProgressMax,
													 ULONG ulStatusCode,
													 LPCWSTR szStatusText)
{
	static TCHAR action[50];

	// cleanup the msg buffer.
	memset(action, 0, 200);

	// grab back ptrs to the dlg.
	CStatic& msg = m_pdl->m_pParams->m_pdlg->m_msg;

	// what happened.
	switch(ulStatusCode)
	{
    case BINDSTATUS_FINDINGRESOURCE:
		_tcscpy(action, _T("Finding"));
		break;
	case BINDSTATUS_CONNECTING:
		_tcscpy(action, _T("Connecting"));
		break;
	case BINDSTATUS_REDIRECTING:
		_tcscpy(action, _T("Redirecting"));
		break;
	case BINDSTATUS_BEGINDOWNLOADDATA:
		_tcscpy(action, _T("Begin data"));
		_stprintf(action, _T("Looking for\n %s"), szStatusText);
		msg.SetWindowText(action);
        TRACE(_T("dl %s\n"), action);
		break;
	case BINDSTATUS_DOWNLOADINGDATA:
		_tcscpy(action, _T("Downloading"));
		break;
	case BINDSTATUS_ENDDOWNLOADDATA:
		_tcscpy(action, _T("End data"));
		break;
	case BINDSTATUS_BEGINDOWNLOADCOMPONENTS:
		_tcscpy(action, _T("Begin download"));
		break;
	case BINDSTATUS_INSTALLINGCOMPONENTS:

		// only this one moves the progress bar.
		_stprintf(action, _T("Installing\n %s"), szStatusText);
		msg.SetWindowText(action);
		// I'm see 2 calls per component.
		break;
	case BINDSTATUS_ENDDOWNLOADCOMPONENTS:
		_tcscpy(action, _T("End download"));
		break;
	case BINDSTATUS_USINGCACHEDCOPY:
		_tcscpy(action, _T("using cached copy"));
		break;
	case BINDSTATUS_SENDINGREQUEST:
		_tcscpy(action, _T("Requesting"));
		break;
	case BINDSTATUS_CLASSIDAVAILABLE:
		_tcscpy(action, _T("CLSID available"));
		break;
	case BINDSTATUS_MIMETYPEAVAILABLE:
		_tcscpy(action, _T("mime available"));
		break;
	case BINDSTATUS_CACHEFILENAMEAVAILABLE:
		_tcscpy(action, _T("cache available"));
		break;
	default: break;
	} //endswitch

    return(NOERROR);
}  // CDownloadBindStatusCallback



//**************************************************************
// CDownloadBindStatusCallback::OnDataAvailable
//
// I don't know what this method does.  Check the documentation for
// urlmon to find out and update the comments when you do.
//
// Parameters:
//		DWORD grfBSC
//
//		DWORD dwSize
//
//		FORMATETC *pFmtetc
//
//		STGMEDIUM  __RPC_FAR *pstgmed
//
// Returns:
//		SCODE
//			E_NOTIMPL (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnDataAvailable(DWORD grfBSC, DWORD dwSize, FORMATETC *pFmtetc, STGMEDIUM  __RPC_FAR *pstgmed)
{
	ASSERT(TRUE); // assert that never called
    return S_OK;
}  // CDownloadBindStatusCallback::OnDataAvailable




//**************************************************************
// CDownloadBindStatusCallback::OnObjectAvailable
//
// The base class calls this method when the downloaded object is
// available.  We store a pointer to the object at this time, but
// it is premature to take down the dialog at this point as there
// will be done by a different callback that occurs later.
//
// Parameters:
//		[in] REFIID riid
//			The interface's GUID.
//
//		[in] IUnknown* punk
//			A pointer to the object instance.
//
// Returns:
//		SCODE
//			S_OK (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnObjectAvailable( REFIID riid, IUnknown* punk)
{
	m_pdl->m_pParams->m_sc = S_OK;		// Download complete
	m_pdl->m_pParams->m_punk = punk;	// This must be released somewhere.

    return S_OK;;
}  // CDownloadBindStatusCallback::OnObjectAvailable




//**************************************************************
// CDownloadBindStatusCallback::OnLowResource
//
// The base class calls this method to notify this derived class that
// resources are running low.  We ignore this warning.
//
// Parameters:
//		[in] DWORD dwReserved
//
// Returns:
//		SCODE
//			E_NOTIMPL (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    return E_NOTIMPL;
}  // CDownloadBindStatusCallback::OnLoadResource





//**************************************************************
// CDownloadBindStatusCallback::OnStopBinding
//
// The base class calls this method to notify this derived class that
// the binding is terminating.  We end the download dialog at this point.
//
// Parameters:
//		[in] HRESULT hrResult
//			S_OK if the binding was completed successfully, otherwise an
//			error code.
//
//		[in] LPCWSTR szError
//			An error message that can be displayed for the user.
//
// Returns:
//		SCODE
//			S_OK (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnStopBinding(HRESULT hrResult, LPCWSTR szError)
{
	if (FAILED(hrResult)) {
		m_pdl->m_pParams->m_sc = GetScode(hrResult);
	} else {
		m_pdl->m_pParams->m_sc = S_OK;
	}

    if (m_pbinding) {
        m_pbinding->Release();
		m_pbinding = NULL;
	}

	RevokeBindStatusCallback(m_pdl->GetBindCtx(this), this);

	m_pdl->m_pParams->m_pdlg->EndDialog(0);

    return S_OK;
}  // CDownloadBindStatusCallback::OnStopBinding




//**************************************************************
// CDownloadBindStatusCallback::OnCodeInstallProblem
//
// The base class calls this method to notify this derived class that
// there is a code installation problem.  This method returns a status
// code to indicate whether or not the installation should be aborted.
//
// Parameters:
//		[in]  ULONG ulStatusCode
//			A status code indicating what the problem was.
//
//		[in]  LPCWSTR szDestination
//			The place where the the file was being installed.
//
//		[in]  LPCWSTR szSource
//			The place where the file came from.
//
//		[in]  DWORD dwReserved
//
// Returns:
//		SCODE
//			E_ABORT if the code installation is to be aborted,
//			S_OK if the code installation should proceed if possible.
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnCodeInstallProblem(
	/* [in] */ ULONG ulStatusCode,
	/* [in] */ LPCWSTR szDestination,
	/* [in] */ LPCWSTR szSource,
	/* [in] */ DWORD dwReserved)

{
	m_pdl->m_pParams->m_ulCodeInstallStatus = ulStatusCode;

	switch (ulStatusCode) {
		case CIP_ACCESS_DENIED:
			AfxMessageBox(IDS_ERR_VIEW_INSTALL_ACCESS_DENIED, MB_OK|MB_ICONSTOP);
			return E_ABORT;

		case CIP_DISK_FULL:
			AfxMessageBox(IDS_ERR_VIEW_INSTALL_DISK_FULL, MB_OK|MB_ICONSTOP);
			return E_ABORT;

		case CIP_OLDER_VERSION_EXISTS:
			return S_OK;

		case CIP_NEWER_VERSION_EXISTS:
			return S_OK; // always update

		case CIP_TRUST_VERIFICATION_COMPONENT_MISSING:
			return S_OK; // ignore trusting, install anyway.
		case CIP_NEED_REBOOT:
			return S_OK;
		case CIP_NAME_CONFLICT:
		case CIP_EXE_SELF_REGISTERATION_TIMEOUT:
		default:
			return E_ABORT;
	}

	return S_OK;

}

//**************************************************************
// CDownloadBindStatusCallback::GetWindow
//
// I don't know what this method does.  Check the documentation for
// urlmon to find out and update the comments when you do.
//
// Parameters:
//		[in] REFGUID rguidReason
//
//		[out] HWND *phwnd
//
// Returns:
//		SCODE
//			S_OK (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::GetWindow(REFGUID rguidReason, HWND *phwnd)
{

	*phwnd = m_pdlg->m_hWnd;
    return S_OK;
}  // CDownloadBindStatusCallback::GetWindow


//**************************************************************
// CDownload::CDownload
//
// Constructor for the CDownload class.  This class doesn't do
// much other than initiate the download through the
// CDownloadBindStatusCallback class.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
CDownload::CDownload()
{
    m_pmk = 0;
    m_pbc = 0;
    m_pbsc = 0;
}  // CDownload



//**************************************************************
// CDownload::~CDownload
//
// Destructor.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
CDownload::~CDownload()
{
    if (m_pmk)
        m_pmk->Release();
    if (m_pbc)
        m_pbc->Release();
    if (m_pbsc)
        m_pbsc->Release();
}  // ~CDownload



//**************************************************************
// CDownload::UserCancelled
//
// This method is called when the user clicks the "Cancel" button
// in the download dialog.  It aborts the binding if a binding is
// in progress.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
VOID CDownload::UserCancelled()
{
	IBinding *pBinding = NULL;
	CDownloadBindStatusCallback *pbsc;

	if (!(m_pbsc->HasUserCancelled()) ) {
		pbsc = m_pbsc;
		pbsc->SetUserCancelled();
	} else {
		m_pParams->m_sc = E_ABORT; // Download cancelled
		m_pParams->m_pdlg->EndDialog(0);
		return;
	}

	if (pbsc) {
		pBinding = pbsc->GetBinding();
	}

	if (pBinding == NULL) {
		// no binding in progress, user cancelled before or after
		//download, no abort reqd.
		m_pParams->m_sc = E_ABORT; // Download cancelled
		m_pParams->m_pdlg->EndDialog(0);
 		return;
	}

	HRESULT hr = pBinding->Abort();
	SCODE sc = GetScode(hr);
	ASSERT(SUCCEEDED(sc));
}




//**************************************************************
// CDownload::DoDownload
//
// This method is called from CDlgDownload::OnInitDialog to
// download a custom view.
//
// Parameters:
//		[in, out] CDownloadParams* pParams
//			The parameters describing the component to download
//			are passed though this structure, the stautus code
//			and object instance pointer are also returned via
//			this structure.
//
// Returns:
//		SCODE
//			An ordinary status code.
//
//**************************************************************
SCODE CDownload::DoDownload(CDownloadParams* pParams)
{
	pParams->m_sc = S_OK;
	pParams->m_ulCodeInstallStatus = 0;
	pParams->m_punk = NULL;
	m_pParams = pParams;

    HRESULT hr =  NOERROR;
	CDownloadBindStatusCallback *pbsc;
	IBindCtx *pbc;


	pbsc = new CDownloadBindStatusCallback(pParams->m_pdlg, this);

	if (pbsc != NULL)
		pbsc->AddRef();
	else
		hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        hr = CreateBindCtx(0, &pbc);

    if (SUCCEEDED(hr))
            hr = RegisterBindStatusCallback(pbc, pbsc, NULL, 0);

    if (SUCCEEDED(hr)) {
        hr = CoGetClassObjectFromURL(
					pParams->m_clsid,
					pParams->m_szCodebase,
					pParams->m_dwFileVersionMS,
					pParams->m_dwFileVersionLS,
					NULL,
					pbc,
					CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
					0,
					IID_IClassFactory,
					(VOID**) &pParams->m_punk);
	}


	ASSERT(m_pbsc == NULL);

	if (!m_pbsc) {
		m_pbsc = pbsc;
		m_pbc = pbc;
	}

	SCODE sc = GetScode(hr);
    return sc;
}  // CDownload::DoDownload
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\eventreg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// EventReg.cpp : implementation file
//

#include "precomp.h"
#include "Container.h"
#include "resource.h"		// main symbols
#include "EventReg.h"
#include "cvCache.h"
#include "htmlhelp.h"
#include "WbemRegistry.h"
#include "HTMTopics.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// EventReg dialog

BEGIN_EVENTSINK_MAP(EventReg, CDialog)
    //{{AFX_EVENTSINK_MAP(EventReg)
	//}}AFX_EVENTSINK_MAP
	ON_EVENT_REFLECT(EventReg,1,OnGetIWbemServices,VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
END_EVENTSINK_MAP()


EventReg::EventReg(CWnd* pParent /*=NULL*/)
	: CDialog(EventReg::IDD, pParent)
{
	m_initiallyDrawn = false;
	//{{AFX_DATA_INIT(EventReg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_securityCtl = NULL;
	m_EventRegCtl = NULL;
}

//---------------------------------------------------------
EventReg::~EventReg()
{
}

void EventReg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(EventReg)
	DDX_Control(pDX, IDC_HELPME, m_helpBtn);
	DDX_Control(pDX, IDC_GOAWAY, m_closeBtn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(EventReg, CDialog)
	//{{AFX_MSG_MAP(EventReg)
	ON_BN_CLICKED(IDC_HELPME, OnHelp)
	ON_BN_CLICKED(IDC_GOAWAY, OnGoaway)
	ON_BN_CLICKED(IDOK, OnOK)
	ON_BN_CLICKED(IDCANCEL, OnCancel)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// EventReg message handlers

BOOL EventReg::OnInitDialog()
{
	CDialog::OnInitDialog();

	CRect rect;
	CString cabPath;
	WCHAR clsid[50];
	CCustomViewCache cache;


	CWnd *placeHolder = GetDlgItem(IDC_PLACEHOLDER2);
	placeHolder->GetWindowRect(&rect);
	ScreenToClient(&rect);
	placeHolder->DestroyWindow();

	// find the cab.
	WbemRegString(APP_DIR, cabPath);
	cabPath += _T("\\WbemTool.cab");




	m_securityCtl = new CSecurity;
	BOOL created = m_securityCtl->Create(_T("security thingy"),
										WS_CHILD,
										rect, this,
										IDC_SECURITYCTRL);
	if(!created)
	{
		// The ocx must not be installed.
		wcscpy(clsid, L"{9C3497D6-ED98-11D0-9647-00C04FD9B15B}");
		cache.NeedComponent(clsid, cabPath);

		// try again.
		created = m_securityCtl->Create(_T("security thingy"),
										WS_CHILD,
										rect, this,
										IDC_SECURITYCTRL);
	}

	if(created)
	{
		// set the middle words in the title for the login dlg.
		CString titlePart;
		titlePart.LoadString(IDS_EVENTREG_TITLE);
		m_securityCtl->SetLoginComponent((LPCTSTR)titlePart);
	}

	// now the other one.
	created = FALSE;
	placeHolder = GetDlgItem(IDC_PLACEHOLDER);
	placeHolder->GetWindowRect(&rect);
	ScreenToClient(&rect);
	placeHolder->DestroyWindow();

	m_EventRegCtl = new CEventRegEdit;
	created = m_EventRegCtl->Create(_T("the eventreg"),
									WS_CHILD|WS_VISIBLE,
									rect, this,
									IDC_EVENTREGEDITCTRL);
	if(!created)
	{
		// The ocx must not be installed.
		wcscpy(clsid, L"{0DA25B05-2962-11D1-9651-00C04FD9B15B}");
		cache.NeedComponent(clsid, cabPath);

		// try again.
		created = m_EventRegCtl->Create(_T("the eventreg"),
										WS_CHILD|WS_VISIBLE,
										rect, this,
										IDC_EVENTLISTCTRL);
	}

	if(created)
	{
        // TODO: remember the last namespace.
		//m_EventRegCtl->SetNameSpace(_T(""));
		//-----------------------------------------
		// save the original position for later resizing.
		CRect rcBounds;

		// get the bounds again.
		GetClientRect(&rcBounds);

		// NOTE: rcBounds is the dlg; rect is the list.

		// margin on each side of list.
		m_listSide = rect.left - rcBounds.left;

		// top of dlg to top of list.
		m_listTop = rect.top - rcBounds.top;

		// bottom of dlg to bottom of list.
		m_listBottom = rcBounds.Height() - rect.Height() - m_listTop;


		// get the close button.
		m_closeBtn.GetWindowRect(&rect);
		ScreenToClient(&rect);

		// close btn right edge to dlg right edge.
		m_closeLeft = rcBounds.Width() - rect.left;

		// btn top to dlg bottom.
		m_btnTop = rcBounds.Height() - rect.top;

		//-------------------------------------------
		// deal with help button
		m_helpBtn.GetWindowRect(&rect);
		ScreenToClient(&rect);

		// help btn right edge to dlg right edge.
		m_helpLeft = rcBounds.Width() - rect.left;

		m_btnW = rect.Width();
		m_btnH = rect.Height();
		m_initiallyDrawn = true;
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
//----------------------------------------------------------
void EventReg::OnGetIWbemServices(LPCTSTR lpctstrNamespace,
								  VARIANT FAR* pvarUpdatePointer,
								  VARIANT FAR* pvarServices,
								  VARIANT FAR* pvarSC,
								  VARIANT FAR* pvarUserCancel)
{
	m_securityCtl->GetIWbemServices(lpctstrNamespace,
									pvarUpdatePointer,
									pvarServices,
									pvarSC,
									pvarUserCancel);
}

//------------------------------------------------------------------------
void EventReg::OnHelp()
{
	CString csPath;
	WbemRegString(SDK_HELP, csPath);

	CString csData = idh_eventreg;
	HWND hWnd = NULL;

	try
	{
		HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD_PTR) (LPCTSTR) csData);
		if(!hWnd)
		{
			AfxMessageBox(IDS_NOHTMLHELP, MB_OK|MB_ICONSTOP);
		}
	}

	catch( ... )
	{
		// Handle any exceptions here.
		AfxMessageBox(IDS_NOHTMLHELP, MB_OK|MB_ICONSTOP);
	}
}

//--------------------------
void EventReg::ReallyGoAway()
{
	__try
	{
		if(m_securityCtl)
		{
			m_securityCtl->PageUnloading();
			delete m_securityCtl;
			m_securityCtl = NULL;
		}
	}
	__except(1)
	{}

	__try
	{
		delete m_EventRegCtl;
		m_EventRegCtl = NULL;
	}
	__except(1)
	{}

	CDialog::OnOK();
}
//--------------------------
void EventReg::PostNcDestroy()
{
	CDialog::PostNcDestroy();
	delete this;
}

//--------------------------
void EventReg::OnGoaway()
{
	// use my own 'IDOK' so the <cr>s go to the component.
    // User closed me but just hide. Parent kills me when
    // it exits.
   	CWnd *pParent = GetParentOwner();

	ShowWindow(SW_HIDE);

	if (pParent)
	{
		pParent->SetWindowPos
						(&wndTop,
						0,
						0,
						0,
						0,
						SWP_NOSIZE | SWP_NOMOVE | SWP_NOOWNERZORDER);
	}
}

//---------------------------------------------------
void EventReg::OnCancel()
{
	OnGoaway();
}
//---------------------------------------------------
void EventReg::OnOK()
{
    // really a <CR> which the controls want.
	TCHAR szClass[10];
	CWnd* pWndFocus;

	if (((pWndFocus = GetFocus()) != NULL) &&
		IsChild(pWndFocus) &&
		GetClassName(pWndFocus->m_hWnd, szClass, 10) &&
		(_tcsicmp(szClass, _T("EDIT")) == 0))
	{
		pWndFocus->SendMessage(WM_CHAR,VK_RETURN,0);
		return;
	}
	OnGoaway();
}

//---------------------------------------------------
void EventReg::OnSize(UINT nType, int cx, int cy)
{
	CDialog::OnSize(nType, cx, cy);

	if(m_initiallyDrawn)
	{
		m_EventRegCtl->MoveWindow(m_listSide, m_listTop,
								cx - (2 * m_listSide), cy - m_listBottom - m_listTop);

		m_closeBtn.MoveWindow(cx - m_closeLeft, cy - m_btnTop,
								m_btnW, m_btnH);

		m_helpBtn.MoveWindow(cx - m_helpLeft, cy - m_btnTop,
								m_btnW, m_btnH);

		m_closeBtn.Invalidate();
		m_helpBtn.Invalidate();
		Invalidate();
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\eventlist.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_EVENTLIST_H__0B19A152_E910_11D1_ADD9_00AA00B8E05A__INCLUDED_)
#define AFX_EVENTLIST_H__0B19A152_E910_11D1_ADD9_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CEventList wrapper class

class CEventList : public CWnd
{
protected:
	DECLARE_DYNCREATE(CEventList)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xac146530, 0x87a5, 0x11d1, { 0xad, 0xbd, 0x0, 0xaa, 0x0, 0xb8, 0xe0, 0x5a } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	long GetMaxItems();
	void SetMaxItems(long);
	long GetItemCount();
	void SetItemCount(long);

// Operations
public:
	void DoDetails();
	long Clear(long item);
	long AddWbemEvent(LPUNKNOWN logicalConsumer, LPUNKNOWN Event);
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EVENTLIST_H__0B19A152_E910_11D1_ADD9_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\eventreg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{AFX_INCLUDES()
#include "eventregedit.h"
#include "security.h"
//}}AFX_INCLUDES
#if !defined(AFX_EVENTREG_H__682CE283_8EC9_11D1_ADBF_00AA00B8E05A__INCLUDED_)
#define AFX_EVENTREG_H__682CE283_8EC9_11D1_ADBF_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// EventReg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// EventReg dialog

class EventReg : public CDialog
{
// Construction
public:
	EventReg(CWnd* pParent = NULL);   // standard constructor
	virtual ~EventReg();

    void ReallyGoAway();

// Dialog Data
	//{{AFX_DATA(EventReg)
	enum { IDD = IDD_EVENT_REG };
	CButton	m_helpBtn;
	CButton	m_closeBtn;
	//}}AFX_DATA

	CEventRegEdit	*m_EventRegCtl;
	CSecurity	*m_securityCtl;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(EventReg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void PostNcDestroy();
	//}}AFX_VIRTUAL
	DECLARE_EVENTSINK_MAP()

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(EventReg)
	virtual BOOL OnInitDialog();
	afx_msg void OnHelp();
	afx_msg void OnGoaway();
	afx_msg void OnOK();
    afx_msg void OnCancel();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	void OnGetIWbemServices(LPCTSTR lpctstrNamespace, 
							  VARIANT FAR* pvarUpdatePointer, 
							  VARIANT FAR* pvarServices, 
							  VARIANT FAR* pvarSC, 
							  VARIANT FAR* pvarUserCancel);

	// resizing vars;
	UINT m_listSide;		// margin on each side of list.
	UINT m_listTop;			// top of dlg to top of list.
	UINT m_listBottom;		// bottom of dlg to bottom of list.
	UINT m_closeLeft;		// close btn left edge to dlg right edge.
	UINT m_helpLeft;		// close btn left edge to dlg right edge.
	UINT m_btnTop;			// btn top to dlg bottom.
	UINT m_btnW;			// btn width
	UINT m_btnH;			// btn height
	bool m_initiallyDrawn;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EVENTREG_H__682CE283_8EC9_11D1_ADBF_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\factory.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __PROVIDERFACTORY__
#define __PROVIDERFACTORY__
#pragma once

#include "wbemcli.h"

class CProviderFactory : public IClassFactory
{
public:

	CProviderFactory();
	virtual ~CProviderFactory();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHOD_(SCODE, CreateInstance)(IUnknown * pUnkOuter, 
									REFIID riid, 
									void ** ppvObject);

    STDMETHOD_(SCODE, LockServer)(BOOL fLock);

private:
	LONG m_cRef;
};
#endif __PROVIDERFACTORY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\eventregedit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "eventregedit.h"

/////////////////////////////////////////////////////////////////////////////
// CEventRegEdit

IMPLEMENT_DYNCREATE(CEventRegEdit, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CEventRegEdit properties

CString CEventRegEdit::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CEventRegEdit::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

CString CEventRegEdit::GetFontName()
{
	CString result;
	GetProperty(0x2, VT_BSTR, (void*)&result);
	return result;
}

void CEventRegEdit::SetFontName(LPCTSTR propVal)
{
	SetProperty(0x2, VT_BSTR, propVal);
}

short CEventRegEdit::GetFontSize()
{
	short result;
	GetProperty(0x3, VT_I2, (void*)&result);
	return result;
}

void CEventRegEdit::SetFontSize(short propVal)
{
	SetProperty(0x3, VT_I2, propVal);
}

short CEventRegEdit::GetFontWeight()
{
	short result;
	GetProperty(0x4, VT_I2, (void*)&result);
	return result;
}

void CEventRegEdit::SetFontWeight(short propVal)
{
	SetProperty(0x4, VT_I2, propVal);
}

CString CEventRegEdit::GetRootFilterClass()
{
	CString result;
	GetProperty(0x5, VT_BSTR, (void*)&result);
	return result;
}

void CEventRegEdit::SetRootFilterClass(LPCTSTR propVal)
{
	SetProperty(0x5, VT_BSTR, propVal);
}

CString CEventRegEdit::GetRootConsumerClass()
{
	CString result;
	GetProperty(0x6, VT_BSTR, (void*)&result);
	return result;
}

void CEventRegEdit::SetRootConsumerClass(LPCTSTR propVal)
{
	SetProperty(0x6, VT_BSTR, propVal);
}

CString CEventRegEdit::GetViewMode()
{
	CString result;
	GetProperty(0x7, VT_BSTR, (void*)&result);
	return result;
}

void CEventRegEdit::SetViewMode(LPCTSTR propVal)
{
	SetProperty(0x7, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CEventRegEdit operations

void CEventRegEdit::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\eventregedit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_EVENTREGEDIT_H__F51C8970_9CDE_11D1_ADC7_00AA00B8E05A__INCLUDED_)
#define AFX_EVENTREGEDIT_H__F51C8970_9CDE_11D1_ADC7_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CEventRegEdit wrapper class

class CEventRegEdit : public CWnd
{
protected:
	DECLARE_DYNCREATE(CEventRegEdit)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xda25b05, 0x2962, 0x11d1, { 0x96, 0x51, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	CString GetFontName();
	void SetFontName(LPCTSTR);
	short GetFontSize();
	void SetFontSize(short);
	short GetFontWeight();
	void SetFontWeight(short);
	CString GetRootFilterClass();
	void SetRootFilterClass(LPCTSTR);
	CString GetRootConsumerClass();
	void SetRootConsumerClass(LPCTSTR);
	CString GetViewMode();
	void SetViewMode(LPCTSTR);

// Operations
public:
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EVENTREGEDIT_H__F51C8970_9CDE_11D1_ADC7_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\factory.cpp ===
//***************************************************************************

//

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved 
//
//  File:  factory.cpp
//
//	Description :
//				"Wbem Provider" class factory
//
//	Part of :	Wbem Tutorial.
//
//  History:
//
//***************************************************************************

#include "precomp.h"
#include "factory.h"
#include "Provider.h"
#include "Container.h"

extern CContainerApp theApp;

CProviderFactory::CProviderFactory()
{
	m_cRef = 0L;
}

CProviderFactory::~CProviderFactory()
{
}

//IUnknown methods

STDMETHODIMP CProviderFactory::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IClassFactory)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CProviderFactory::AddRef(void)
{
    TRACE(_T("add factory %d\n"), m_cRef);
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CProviderFactory::Release(void)
{
    int lNewRef = InterlockedDecrement(&m_cRef);

    TRACE(_T("factory %d\n"), m_cRef);

    if(lNewRef == 0)
    {
		theApp.m_pFactory = NULL;
		theApp.EvalQuitApp();
        delete this;
    }

    return lNewRef;
}

//+---------------------------------------------------------------------------
//
//  Function:   CProviderFactory::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProviderFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, LPVOID *ppv)
{
	HRESULT hr;

    if (pUnkOuter)
        return E_FAIL;

	if(theApp.m_pProvider == NULL)
	{
        TRACE(_T("Creating provider\n"));
		theApp.m_pProvider = new CProvider();

        // CIMOM might have launched me and InitInstance() might
        // want ME to create the main UI. Cimom is very impatient
        // with InitInstance(). It wants that IFactory.

        theApp.CreateMainUI();  //maybe :)
	}

    if(theApp.m_pProvider == NULL)
	{
        *ppv = NULL;
		return E_FAIL;
	}
	else
	{
        hr = theApp.m_pProvider->QueryInterface(riid, ppv);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CProviderFactory::LockServer
//
//  Synopsis:
//
//  Arguments:  [fLock]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProviderFactory::LockServer(BOOL fLock)
{

    if (fLock)
        m_cRef++;
    else
        m_cRef--;

    TRACE(_T("lock factory %d\n"), m_cRef);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\provider.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __PROVIDER__
#define __PROVIDER__
#include "wbemcli.h"
#include "wbemprov.h"
#pragma once

class CProvider : public IWbemEventConsumerProvider
{
public:
	CProvider();
	~CProvider();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

     STDMETHOD(FindConsumer)(
				IWbemClassObject* pLogicalConsumer,
				IWbemUnboundObjectSink** ppConsumer);

private:
	DWORD m_cRef;
};
#endif __PROVIDER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\provider.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "Provider.h"
#include "Consumer.h"
#include <objbase.h>
#include "container.h"

extern CContainerApp theApp;

CProvider::CProvider()
{
	m_cRef = 0L;
}

CProvider::~CProvider()
{
}

STDMETHODIMP CProvider::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if(riid == IID_IUnknown || riid == IID_IWbemEventConsumerProvider)
        *ppv=this;

    if(*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvider::AddRef(void)
{
    TRACE(_T("add provider %d\n"), m_cRef);
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvider::Release(void)
{
    if(--m_cRef != 0L)
        return m_cRef;

    TRACE(_T("provider %d\n"), m_cRef);

	theApp.m_pProvider = NULL;
	theApp.EvalQuitApp();
    delete this;
    return 0L;
}

//-----------------------------------------------------------
STDMETHODIMP CProvider::FindConsumer(
						IWbemClassObject* pLogicalConsumer,
						IWbemUnboundObjectSink** ppConsumer)
{
	if(theApp.m_pConsumer == NULL)
	{
        TRACE(_T("Creating consumer\n"));
		theApp.m_pConsumer = new CConsumer();
	}

	return theApp.m_pConsumer->QueryInterface(IID_IWbemUnboundObjectSink,
												    (void**)ppConsumer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__AC14650A_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_)
#define AFX_STDAFX_H__AC14650A_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__AC14650A_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\hmmverr.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
// (c) 1996, 1997 by Microsoft Corporation
//
// error.h
//
// This file contains the interface to the error handling dialog, error log, and so on.
//
//  a-larryf    08-April-97   Created.
//
//***************************************************************************

#ifndef _hmmv_error_h
#pragma once


extern void HmmvErrorMsg(
		LPCTSTR szUserMsg,
		SCODE sc, 
		BOOL bUseErrorObject, 
		LPCTSTR szLogMsg,
		LPCTSTR szFile, 
		int nLine,
		BOOL bLog = FALSE);

extern void HmmvErrorMsg(
		UINT idsUserMsg,
		SCODE sc, 
		BOOL bUseErrorObject, 
		LPCTSTR szLogMsg,
		LPCTSTR szFile, 
		int nLine,
		BOOL bLog = FALSE);

#endif //_hmmv_error_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Container.rc
//
#define IDC_REGISTER                    2
#define IDC_PROPERTIES                  3
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_CONTAINER_DIALOG            102
#define IDR_MAINFRAME                   128
#define IDD_EVENT_REG                   131
#define IDB_TOOLBAR                     140
#define IDC_EVENTLISTCTRL               1001
#define IDC_CLOSE                       1002
#define IDC_EVENTREGEDITCTRL            1004
#define IDC_SECURITYCTRL                1005
#define IDC_ANIMATE1                    1008
#define IDC_ANIMATE                     1008
#define IDC_INSTALL                     1011
#define IDC_PLACEHOLDER                 1012
#define IDC_PLACEHOLDER2                1013
#define IDC_HELPME                      1015
#define IDC_GOAWAY                      1016
#define IDC_CAB_ERROR_MSG               1018
#define IDC_MSG                         1019
#define IDC_MYVERSION                   1020
#define IDC_WBEMVERSION                 1021
#define IDC_ITEMCOUNT                   1021
#define IDS_ERR_VIEW_INSTALL_ACCESS_DENIED 5075
#define IDS_ERR_VIEW_INSTALL_DISK_FULL  5076
#define IDS_ERR_CUSTOM_VIEW_MISSING     5077
#define IDS_TT_REGISTER                 5078
#define IDS_TT_PROPERTIES               5079
#define IDS_TT_CLEARALL                 5080
#define IDS_NO_HHCTRL                   5081
#define IDS_NOHTMLHELP                  5081
#define IDS_NO_HTMLHELP                 5082
#define IDS_UNAVAILABLE                 5083
#define IDS_ITEMCOUNT_FMT               5084
#define IDS_FULLLIST_MSG                5085
#define IDS_TITLE                       5086
#define IDS_WANT_TO_EXIT                5087
#define IDS_EVENTREG_TITLE              5088
#define IDS_NO_HTML_PAGE                5089
#define IDD_DOWNLOAD                    5211
#define IDC_PROGRESS                    5513
#define IDR_AVIDOWNLOAD                 6000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        149
#define _APS_NEXT_COMMAND_VALUE         32777
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\hmmverr.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
// (c) 1996, 1997 by Microsoft Corporation
//
// error.cpp
//
// This file contains the interface to the error handling dialog, error log, and so on.
//
//  a-larryf    08-April-97   Created.
//
//***************************************************************************


#include "precomp.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "hmmverr.h"
#include <MsgDlgExterns.h>

//*********************************************************************
// HmmvReleaseErrorObject
//
// Releases an error object if it hasn't already been released.
//
// Parameters:
//		[in/out] IHmmCallResult *&  pcoError
//			A reference to the error object pointer.
//
//	Returns:
//		Nothing.
//
//********************************************************************
void HmmvReleaseErrorObject(IWbemCallResult *&  pcoError)
{
	if (pcoError)
	{
		pcoError->Release();
		pcoError = NULL;
	}
}


//********************************************************************************
// LogMsg
//
// Write an entry in the error log.
//
// Parameters:
//		[in] LPCTSTR szMessage
//			The error message string.
//
//		[in] LPCTSTR szFile
//			The file where the error occurred.
//
//		[in] int nLine
//			The line number where the error occurred.
//
// Returns:
//		Nothing.
//
//************************************************************************************
static void LogMsg(LPCTSTR szMessage, LPCTSTR szFile, int nLine)
{

}


//*******************************************************************************
// ErrorMsg
//
// Display an error dialog and write an entry in the error log.
//
// Parameters:
//		[in] LPCTSTR szUserMsg
//			The user message to display in the dialog box.
//
//		[in] BOOL bUseErrorobject
//			TRUE if the message dialog should get and use the HMOM error object.
//
//		[in] SCODE sc
//			The HMOM status code.
//
//		[in] LPCTSTR szLogMsg
//			The message to write to the log.  This parameter needs to be valid only
//			if bLog is TRUE.
//
//		[in] LPCTSTR szFile
//			The file where the error occurred.  This parameter needs to be valid only
//			if bLog is TRUE.
//
//		[in] int nLine
//			The line where the error occurred.  This parameter needs to be valid only
//			if bLog is TRUE.
//
//		[in] BOOL bLog
//			TRUE to write a message to the log file.
//
// Returns:
//			Nothing.
//
//*************************************************************************************************
void HmmvErrorMsg(
		LPCTSTR szUserMsg,
		SCODE sc,
		BOOL bUseErrorObject,
		LPCTSTR szLogMsg,
		LPCTSTR szFile,
		int nLine,
		BOOL bLog
)
{

	CString sUserMsg(szUserMsg);
	BSTR bstrUserMsg = sUserMsg.AllocSysString();

	DisplayUserMessage(L"WMI Object Viewer", bstrUserMsg, sc, bUseErrorObject);

	::SysFreeString(bstrUserMsg);

	if (bLog)
	{
		LogMsg(szLogMsg,  szFile, nLine);
	}
}


//*******************************************************************************
// ErrorMsg
//
// This function is the same as the previous ErrorMsg except that it
// takes a string resource ID as its first parameter rather than a
// string pointer.
//
// Parameters:
//		Same as ErrorMsg above except for idsUserMsg which is
//		the resource id of the error message string.
//
// Returns:
//		Nothing.
//
//*********************************************************************************
extern void HmmvErrorMsg(
		UINT idsUserMsg,
		SCODE sc,
		BOOL bUseErrorObject,
		LPCTSTR szLogMsg,
		LPCTSTR szFile,
		int nLine,
		BOOL bLog)
{
	CString sUserMsg;
	sUserMsg.LoadString(idsUserMsg);
	HmmvErrorMsg((LPCTSTR) sUserMsg, sc, bUseErrorObject, szLogMsg, szFile, nLine, bLog);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\dlgdownload.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// DlgDownload.cpp : implementation file
//

#include "precomp.h"
#include <afxcmn.h>
#include "resource.h"
#include "DlgDownload.h"
#include "winerror.h"
#include "urlmon.h"
#include "download.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgDownload dialog


CDlgDownload::CDlgDownload(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgDownload::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgDownload)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT


	m_pParams = NULL;
	m_pDownload = NULL;
}


CDlgDownload::~CDlgDownload()
{
	delete m_pParams;
	delete m_pDownload;
}

void CDlgDownload::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgDownload)
	DDX_Control(pDX, IDC_ANIMATE, m_progress);
	DDX_Control(pDX, IDC_MSG, m_msg);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgDownload, CDialog)
	//{{AFX_MSG_MAP(CDlgDownload)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgDownload message handlers

void CDlgDownload::OnCancel()
{
	// TODO: Add extra cleanup here
	if (m_pDownload) {
		m_pDownload->UserCancelled();
	}
	else {
		CDialog::OnCancel();
	}

}

BOOL CDlgDownload::OnInitDialog()
{
	CDialog::OnInitDialog();

	BOOL x = m_progress.Open(IDR_AVIDOWNLOAD);

	m_pDownload = new CDownload();

	SCODE sc;
	sc = m_pDownload->DoDownload(m_pParams);
	if (sc != S_ASYNCHRONOUS) {
		EndDialog(IDOK);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



//**************************************************************
// CDlgDownload::DoDownload
//
// This method initiates the downloading of a custom view.  It
// stores all the parameters describing the component to download
// as member data, then calls DoDialog.  OnInitDialog completes
// the downloading process.
//
// Parameters:
//		[out] LPUNKNOWN& punk
//			The instance pointer for the custom view is returned here.
//
//		[in] REFCLSID clsid
//			The class id of the custom view.
//
//		[in] LPCWSTR szCodebase
//			The codebase describing the location of the custom view OCX file.
//
//		[in] DWORD dwFileVersionMS
//			The most significant word of the version number.
//
//		[in] DWORD dwFileVersionLS
//			The least significant word of the version number.
//
//
// Returns:
//		Nothing.
//
//**************************************************************
SCODE CDlgDownload::DoDownload(LPUNKNOWN& punk, REFCLSID clsid, LPCWSTR szCodebase, DWORD dwFileVersionMS, DWORD dwFileVersionLS)
{
	if (!m_pParams) {
		m_pParams = new CDownloadParams;
	}
	m_pParams->m_sc = S_OK;
	m_pParams->m_pdlg = this;
	m_pParams->m_clsid = clsid;
	m_pParams->m_szCodebase = szCodebase;
	m_pParams->m_dwFileVersionMS = dwFileVersionMS;
	m_pParams->m_dwFileVersionLS = dwFileVersionLS;

	DoModal();


	punk = m_pParams->m_punk;
	return m_pParams->m_sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\dlgdownload.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_DLGDOWNLOAD_H__C9552DA1_009D_11D1_848D_00C04FD7BB08__INCLUDED_)
#define AFX_DLGDOWNLOAD_H__C9552DA1_009D_11D1_848D_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgDownload.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgDownload dialog
class CDownloadParams;
class CDownload;

class CDlgDownload : public CDialog
{
// Construction
public:
	CDlgDownload(CWnd* pParent = NULL);   // standard constructor
	~CDlgDownload();
	HRESULT DoDownload(LPUNKNOWN& punk, REFCLSID clsid, LPCWSTR szCodebase, DWORD dwFileVersionMS, DWORD dwFileVersionLS);

// Dialog Data
	//{{AFX_DATA(CDlgDownload)
	enum { IDD = IDD_DOWNLOAD };
	CAnimateCtrl	m_progress;
	CStatic			m_msg;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgDownload)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgDownload)
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CDownloadParams* m_pParams;
	CDownload* m_pDownload;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGDOWNLOAD_H__C9552DA1_009D_11D1_848D_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\download.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  (c) 1997 by Microsoft Corporation
//
//  download.h
//
//  Header file for the custom view downloading implementation.
//
//
//  a-larryf    05-Feb-97   Created.
//
//***************************************************************************


#ifndef _download_h
#define _download_h

#pragma once


class CDlgDownload;
class CDownloadBindStatusCallback;

class CDownloadParams
{
public:	
	// [out]
	SCODE m_sc;
	ULONG m_ulCodeInstallStatus;		// The code install status
	LPUNKNOWN m_punk;

	// [in]
	CDlgDownload* m_pdlg;
	CLSID m_clsid;
	LPCWSTR m_szCodebase;
	DWORD m_dwFileVersionMS;
	DWORD m_dwFileVersionLS;
};


class CDownload {
  public:
    CDownload();
	~CDownload();

	SCODE DoDownload(CDownloadParams* pParams);
	VOID UserCancelled();

	IBindCtx*	GetBindCtx(CDownloadBindStatusCallback *pbsc) const {
		if (pbsc == m_pbsc)
			return m_pbc;
		else
			return NULL;
	}
	CDownloadParams* m_pParams;

  private:
    IMoniker*            m_pmk;
    IBindCtx*            m_pbc;
    CDownloadBindStatusCallback* m_pbsc;
};

#endif //_download_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\security.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "security.h"

/////////////////////////////////////////////////////////////////////////////
// CSecurity

IMPLEMENT_DYNCREATE(CSecurity, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CSecurity properties

CString CSecurity::GetLoginComponent()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CSecurity::SetLoginComponent(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CSecurity operations

void CSecurity::GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT* pvarUpdateNamespace, VARIANT* pvarServices, VARIANT* pvarSC, VARIANT* pvarUserCancel)
{
	static BYTE parms[] =
		VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace, pvarUpdateNamespace, pvarServices, pvarSC, pvarUserCancel);
}

void CSecurity::PageUnloading()
{
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSecurity::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\cvcache.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _cvcache_h
#define _cvcache_h
#pragma once

#define NEWEST_VERSION 0xFFFFFFFF

class CCustomViewCache
{
public:
	CCustomViewCache();
	~CCustomViewCache();

	SCODE NeedComponent(LPWSTR szClsid, LPCWSTR szCodeBase,
					  int major = NEWEST_VERSION, 
					  int minor = NEWEST_VERSION);

private:
	CString m_sTemp;
};


#endif // cvcache_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\security.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SECURITY_H__682CE285_8EC9_11D1_ADBF_00AA00B8E05A__INCLUDED_)
#define AFX_SECURITY_H__682CE285_8EC9_11D1_ADBF_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CSecurity wrapper class

class CSecurity : public CWnd
{
protected:
	DECLARE_DYNCREATE(CSecurity)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x9c3497d6, 0xed98, 0x11d0, { 0x96, 0x47, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetLoginComponent();
	void SetLoginComponent(LPCTSTR);

// Operations
public:
	void GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT* pvarUpdateNamespace, VARIANT* pvarServices, VARIANT* pvarSC, VARIANT* pvarUserCancel);
	void PageUnloading();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SECURITY_H__682CE285_8EC9_11D1_ADBF_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\container\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//	Container.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\download.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  (c) 1996 by Microsoft Corporation
//
//  download.cpp
//
//  This file, in conjunction with CDlgDownload.cpp, implements custom view
//  downloading.  Downloading is initiated though the CDlgDownload class.
//
//
//  a-larryf    05-Feb-97   Created.
//
//***************************************************************************

#include "precomp.h"
#include "winerror.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "urlmon.h"
#include "download.h"
#include "resource.h"
#include <afxcmn.h>
#include "DlgDownload.h"


//**************************************************************
// GetInetStatusText
//
// This method converts an inet status code into a human readable
// string.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
void GetInetStatusText(CString& sText, SCODE sc)
{
	switch(sc) {
	case S_ASYNCHRONOUS:
		sText = "S_ASYNCHRONOUS";
		break;
	case E_PENDING:
		sText = "E_PENDING";
		break;
	case INET_E_INVALID_URL:
		sText = "INET_E_INVALID_URL";
		break;
	case INET_E_NO_SESSION:
		sText = "INET_E_NO_SESSION";
		break;
	case INET_E_CANNOT_CONNECT:
		sText = "INET_E_CANNOT_CONNECT";
		break;
	case INET_E_RESOURCE_NOT_FOUND:
		sText = "INET_E_RESOURCE_NOT_FOUND";
		break;
	case INET_E_OBJECT_NOT_FOUND:
		sText = "INET_E_OBJECT_NOT_FOUND";
		break;
	case INET_E_DATA_NOT_AVAILABLE:
		sText = "INET_E_DATA_NOT_AVAILABLE";
		break;
	case INET_E_DOWNLOAD_FAILURE:
		sText = "INET_E_DOWNLOAD_FAILURE";
		break;
	case INET_E_AUTHENTICATION_REQUIRED:
		sText = "INET_E_AUTHENTICATION_REQUIRED";
		break;
	case INET_E_NO_VALID_MEDIA:
		sText = "INET_E_NO_VALID_MEDIA";
		break;
	case INET_E_CONNECTION_TIMEOUT:
		sText = "INET_E_CONNECTION_TIMEOUT";
		break;
	case INET_E_INVALID_REQUEST:
		sText = "INET_E_INVALID_REQUEST";
		break;
	case INET_E_UNKNOWN_PROTOCOL:
		sText = "INET_E_UNKNOWN_PROTOCOL";
		break;
	case INET_E_SECURITY_PROBLEM:
		sText = "INET_E_SECURITY_PROBLEM";
		break;
	case INET_E_CANNOT_LOAD_DATA:
		sText = "INET_E_CANNOT_LOAD_DATA";
		break;
	case INET_E_CANNOT_INSTANTIATE_OBJECT:
		sText = "INET_E_CANNOT_INSTANTIATE_OBJECT";
		break;

	}
}




//===================================================================
// Class: CDownloadBindStatusCallback
//
// This class is derived from CBindStatusCallback.  Defining this
// class allows us to override various virtual methods in the base
// class to monitor the progress of downloading a custom view.
//
//====================================================================

// for m_flags
#define USER_CANCELLED	0x1

class CDownloadBindStatusCallback : public IBindStatusCallback, public ICodeInstall {
  public:
    // IUnknown methods
    STDMETHODIMP    QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef()    { return m_cRef++; }
    STDMETHODIMP_(ULONG)    Release()   { if (--m_cRef == 0) { delete this; return 0; } return m_cRef; }

    // IBindStatusCallback methods
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pFmtetc, STGMEDIUM  __RPC_FAR *pstgmed);
	STDMETHODIMP	OnObjectAvailable( REFIID riid, IUnknown* punk);

    STDMETHODIMP    OnStartBinding(DWORD grfBSCOPTION,IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                        LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);

	// ICodeInstall method(s)
    // Old method STDMETHODIMP    GetWindow(HWND *phwnd);
	STDMETHODIMP GetWindow(REFGUID rguidReason, HWND *pHwnd);
	STDMETHODIMP 	OnCodeInstallProblem(
		/* [in] */ ULONG ulStatusCode,
		/* [in] */ LPCWSTR szDestination,
		/* [in] */ LPCWSTR szSource,
		/* [in] */ DWORD dwReserved);


    // constructors/destructors
    CDownloadBindStatusCallback(CDlgDownload* pdlg, CDownload *pdl);
	~CDownloadBindStatusCallback();

 	IBinding * GetBinding() {return m_pbinding;}
    void SetWndText(LPCWSTR szText);

	BOOL HasUserCancelled() const {return (m_flags & USER_CANCELLED);}
	VOID SetUserCancelled() {m_flags |= USER_CANCELLED;}

    // data members
    DWORD           m_cRef;
    IBinding*       m_pbinding;
	CDlgDownload*	m_pdlg;
	CDownload*		m_pdl;
	DWORD			m_flags;
};


//**************************************************************
// CDownloadBindStatusCallback::CDownloadBindStatusCallback
//
// Constructor.
//
// Parameters:
//		[in] CDlgDownload* pdlg
//			Pointer to the download dialog.
//
//
//		[in] CDownload *pdl
//			Pointer to the download object.
//
// Returns:
//		Nothing.
//
//**************************************************************
CDownloadBindStatusCallback::CDownloadBindStatusCallback(
										CDlgDownload* pdlg,
										CDownload *pdl)
{
	m_pdlg = pdlg;
	m_pdl = pdl;
    m_pbinding = NULL;
    m_cRef = 1;
	m_pdl = pdl;
	m_flags = 0;

}  // CDownloadBindStatusCallback

//**************************************************************
// CDownloadBindStatusCallback::!CDownloadBindStatusCallback
//
// Destructor.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
CDownloadBindStatusCallback::~CDownloadBindStatusCallback()
{
    if (m_pbinding)
        m_pbinding->Release();
}  // ~CDownloadBindStatusCallback

//**************************************************************
// CDownloadBindStatusCallback::SetWndText
//
// I don't know why this function is here.  I need to documentation for
// CBindStatusCallback!
//
// Parameters:
//		LPCWSTR szText.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CDownloadBindStatusCallback::SetWndText(LPCWSTR szText)
{
#if 0
	CString sText;
	sText = szText;


	if (m_pdlg->m_hWnd) {
		m_pdlg->SetWindowText(sText);
	}
#endif //0
}



//**************************************************************
// CDownloadBindStatusCallback::QueryInterface
//
// Implementation for query interface.
//
// Parameters:
//		REFIID riid
//			The interface id.
//
//		void** ppv
//			Pointer to the place to return the interface pointer.
//
// Returns:
//		Nothing.
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IBindStatusCallback) {
        *ppv = (IBindStatusCallback *)this;
	}

	if (riid==IID_ICodeInstall)
		*ppv = (ICodeInstall *)this;

	if (*ppv == NULL)
    	return E_NOINTERFACE;

	((IUnknown *)*ppv)->AddRef();

	return S_OK;

}  // CDownloadBindStatusCallback::QueryInterface



//**************************************************************
// CDownloadBindStatusCallback::GetBindInfo
//
// Override the GetBindInfo method from the base class.
//
// Parameters:
//		DWORD* pgrfBINDF
//
//		BINDINFO* pbindInfo
//
// Returns:
//		SCODE
//			S_OK if successful (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    *pgrfBINDF = BINDF_ASYNCHRONOUS;
    pbindInfo->cbSize = sizeof(BINDINFO);
    pbindInfo->szExtraInfo = NULL;
    memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
    return S_OK;
}  // CDownloadBindStatusCallback::GetBindInfo



//**************************************************************
// CDownloadBindStatusCallback::OnStartBinding
//
// The base class calls this method to notify derived classes that
// binding has started. Here we just save the binding pointer.
//
// Parameters:
//		[in] DWORD grfBSCOPTION
//
//		[in] IBinding* pbinding
//			The binding pointer.
//
// Returns:
//		SCODE
//			S_OK if successful (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnStartBinding(DWORD grfBSCOPTION,IBinding* pbinding)
{
    if (pbinding != NULL) {
        pbinding->AddRef();
	}

	m_pbinding = pbinding;
    return S_OK;
}  // CDownloadBindStatusCallback::OnStartBinding



//**************************************************************
// CDownloadBindStatusCallback::GetPriority
//
// I don't know what this method does.  Check the documentation for
// urlmon to find out and update the comments when you do.
//
// Parameters:
//		[in] LONG* pnPriority
//
//
// Returns:
//		SCODE
//			E_NOTIMPL (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::GetPriority(LONG* pnPriority)
{
	return E_NOTIMPL;
}  // CDownloadBindStatusCallback::GetPriority


//**************************************************************
// CDownloadBindStatusCallback::OnProgress
//
// The base class calls this method to notify this derived class
// of the progress of the download.
//
// We update the progress bar in the download dialog each time this
// method is called.
//
// Parameters:
//		[in] ULONG ulProgress
//			The new position of the progress indicator.
//
//		[in] ULONG ulProgressMax
//			The maximum position of the progress indicator.
//
//		[in] ULONG ulStatusCode
//			The status of the download.  We need to check the documentation
//			for urlmon to see what this is.
//
//		[in] LPCWSTR szStatusText
//			A messatge that can be displayed to provide the user with
//			more information about the status of the download.
//
//
// Returns:
//		SCODE
//			NOERROR) (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnProgress(ULONG ulProgress,
													 ULONG ulProgressMax,
													 ULONG ulStatusCode,
													 LPCWSTR szStatusText)
{
	static TCHAR action[50];

	// cleanup the msg buffer.
	memset(action, 0, 200);

	// grab back ptrs to the dlg.
	CStatic& msg = m_pdl->m_pParams->m_pdlg->m_msg;

	// what happened.
	switch(ulStatusCode)
	{
    case BINDSTATUS_FINDINGRESOURCE:
		_tcscpy(action, _T("Finding"));
		break;
	case BINDSTATUS_CONNECTING:
		_tcscpy(action, _T("Connecting"));
		break;
	case BINDSTATUS_REDIRECTING:
		_tcscpy(action, _T("Redirecting"));
		break;
	case BINDSTATUS_BEGINDOWNLOADDATA:
		_tcscpy(action, _T("Begin data"));
		_stprintf(action, _T("Looking for\n %S"), szStatusText);
		msg.SetWindowText(action);
		break;
	case BINDSTATUS_DOWNLOADINGDATA:
		_tcscpy(action, _T("Downloading"));
		break;
	case BINDSTATUS_ENDDOWNLOADDATA:
		_tcscpy(action, _T("End data"));
		break;
	case BINDSTATUS_BEGINDOWNLOADCOMPONENTS:
		_tcscpy(action, _T("Begin download"));
		break;
	case BINDSTATUS_INSTALLINGCOMPONENTS:

		// only this one moves the progress bar.
		_stprintf(action, _T("Installing\n %S"), szStatusText);
		msg.SetWindowText(action);
		// I'm see 2 calls per component.
		break;
	case BINDSTATUS_ENDDOWNLOADCOMPONENTS:
		_tcscpy(action, _T("End download"));
		break;
	case BINDSTATUS_USINGCACHEDCOPY:
		_tcscpy(action, _T("using cached copy"));
		break;
	case BINDSTATUS_SENDINGREQUEST:
		_tcscpy(action, _T("Requesting"));
		break;
	case BINDSTATUS_CLASSIDAVAILABLE:
		_tcscpy(action, _T("CLSID available"));
		break;
	case BINDSTATUS_MIMETYPEAVAILABLE:
		_tcscpy(action, _T("mime available"));
		break;
	case BINDSTATUS_CACHEFILENAMEAVAILABLE:
		_tcscpy(action, _T("cache available"));
		break;
	default: break;
	} //endswitch

    return(NOERROR);
}  // CDownloadBindStatusCallback



//**************************************************************
// CDownloadBindStatusCallback::OnDataAvailable
//
// I don't know what this method does.  Check the documentation for
// urlmon to find out and update the comments when you do.
//
// Parameters:
//		DWORD grfBSC
//
//		DWORD dwSize
//
//		FORMATETC *pFmtetc
//
//		STGMEDIUM  __RPC_FAR *pstgmed
//
// Returns:
//		SCODE
//			E_NOTIMPL (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnDataAvailable(DWORD grfBSC, DWORD dwSize, FORMATETC *pFmtetc, STGMEDIUM  __RPC_FAR *pstgmed)
{
	ASSERT(TRUE); // assert that never called
    return S_OK;
}  // CDownloadBindStatusCallback::OnDataAvailable




//**************************************************************
// CDownloadBindStatusCallback::OnObjectAvailable
//
// The base class calls this method when the downloaded object is
// available.  We store a pointer to the object at this time, but
// it is premature to take down the dialog at this point as there
// will be done by a different callback that occurs later.
//
// Parameters:
//		[in] REFIID riid
//			The interface's GUID.
//
//		[in] IUnknown* punk
//			A pointer to the object instance.
//
// Returns:
//		SCODE
//			S_OK (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnObjectAvailable( REFIID riid, IUnknown* punk)
{
	m_pdl->m_pParams->m_sc = S_OK;		// Download complete
	m_pdl->m_pParams->m_punk = punk;	// This must be released somewhere.

    return S_OK;;
}  // CDownloadBindStatusCallback::OnObjectAvailable




//**************************************************************
// CDownloadBindStatusCallback::OnLowResource
//
// The base class calls this method to notify this derived class that
// resources are running low.  We ignore this warning.
//
// Parameters:
//		[in] DWORD dwReserved
//
// Returns:
//		SCODE
//			E_NOTIMPL (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    return E_NOTIMPL;
}  // CDownloadBindStatusCallback::OnLoadResource





//**************************************************************
// CDownloadBindStatusCallback::OnStopBinding
//
// The base class calls this method to notify this derived class that
// the binding is terminating.  We end the download dialog at this point.
//
// Parameters:
//		[in] HRESULT hrResult
//			S_OK if the binding was completed successfully, otherwise an
//			error code.
//
//		[in] LPCWSTR szError
//			An error message that can be displayed for the user.
//
// Returns:
//		SCODE
//			S_OK (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnStopBinding(HRESULT hrResult, LPCWSTR szError)
{
	if (FAILED(hrResult)) {
		m_pdl->m_pParams->m_sc = GetScode(hrResult);
	} else {
		m_pdl->m_pParams->m_sc = S_OK;
	}

    if (m_pbinding) {
        m_pbinding->Release();
		m_pbinding = NULL;
	}

	RevokeBindStatusCallback(m_pdl->GetBindCtx(this), this);

	m_pdl->m_pParams->m_pdlg->EndDialog(0);

    return S_OK;
}  // CDownloadBindStatusCallback::OnStopBinding




//**************************************************************
// CDownloadBindStatusCallback::OnCodeInstallProblem
//
// The base class calls this method to notify this derived class that
// there is a code installation problem.  This method returns a status
// code to indicate whether or not the installation should be aborted.
//
// Parameters:
//		[in]  ULONG ulStatusCode
//			A status code indicating what the problem was.
//
//		[in]  LPCWSTR szDestination
//			The place where the the file was being installed.
//
//		[in]  LPCWSTR szSource
//			The place where the file came from.
//
//		[in]  DWORD dwReserved
//
// Returns:
//		SCODE
//			E_ABORT if the code installation is to be aborted,
//			S_OK if the code installation should proceed if possible.
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnCodeInstallProblem(
	/* [in] */ ULONG ulStatusCode,
	/* [in] */ LPCWSTR szDestination,
	/* [in] */ LPCWSTR szSource,
	/* [in] */ DWORD dwReserved)

{
	m_pdl->m_pParams->m_ulCodeInstallStatus = ulStatusCode;

	switch (ulStatusCode) {
		case CIP_ACCESS_DENIED:
			AfxMessageBox(IDS_ERR_VIEW_INSTALL_ACCESS_DENIED, MB_OK|MB_ICONSTOP);
			return E_ABORT;

		case CIP_DISK_FULL:
			AfxMessageBox(IDS_ERR_VIEW_INSTALL_DISK_FULL, MB_OK|MB_ICONSTOP);
			return E_ABORT;

		case CIP_OLDER_VERSION_EXISTS:
			return S_OK;

		case CIP_NEWER_VERSION_EXISTS:
			return S_OK; // always update

		case CIP_TRUST_VERIFICATION_COMPONENT_MISSING:
			return S_OK; // ignore trusting, install anyway.
		case CIP_NEED_REBOOT:
			return S_OK;
		case CIP_NAME_CONFLICT:
		case CIP_EXE_SELF_REGISTERATION_TIMEOUT:
		default:
			return E_ABORT;
	}

	return S_OK;

}

//**************************************************************
// CDownloadBindStatusCallback::GetWindow
//
// I don't know what this method does.  Check the documentation for
// urlmon to find out and update the comments when you do.
//
// Parameters:
//		[in] REFGUID rguidReason
//
//		[out] HWND *phwnd
//
// Returns:
//		SCODE
//			S_OK (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::GetWindow(REFGUID rguidReason, HWND *phwnd)
{

	*phwnd = m_pdlg->m_hWnd;
    return S_OK;
}  // CDownloadBindStatusCallback::GetWindow


//**************************************************************
// CDownload::CDownload
//
// Constructor for the CDownload class.  This class doesn't do
// much other than initiate the download through the
// CDownloadBindStatusCallback class.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
CDownload::CDownload()
{
    m_pmk = 0;
    m_pbc = 0;
    m_pbsc = 0;
}  // CDownload



//**************************************************************
// CDownload::~CDownload
//
// Destructor.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
CDownload::~CDownload()
{
    if (m_pmk)
        m_pmk->Release();
    if (m_pbc)
        m_pbc->Release();
    if (m_pbsc)
        m_pbsc->Release();
}  // ~CDownload



//**************************************************************
// CDownload::UserCancelled
//
// This method is called when the user clicks the "Cancel" button
// in the download dialog.  It aborts the binding if a binding is
// in progress.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
VOID CDownload::UserCancelled()
{
	IBinding *pBinding = NULL;
	CDownloadBindStatusCallback *pbsc;

	if (!(m_pbsc->HasUserCancelled()) ) {
		pbsc = m_pbsc;
		pbsc->SetUserCancelled();
	} else {
		m_pParams->m_sc = E_ABORT; // Download cancelled
		m_pParams->m_pdlg->EndDialog(0);
		return;
	}

	if (pbsc) {
		pBinding = pbsc->GetBinding();
	}

	if (pBinding == NULL) {
		// no binding in progress, user cancelled before or after
		//download, no abort reqd.
		m_pParams->m_sc = E_ABORT; // Download cancelled
		m_pParams->m_pdlg->EndDialog(0);
 		return;
	}

	HRESULT hr = pBinding->Abort();
	SCODE sc = GetScode(hr);
	ASSERT(SUCCEEDED(sc));
}




//**************************************************************
// CDownload::DoDownload
//
// This method is called from CDlgDownload::OnInitDialog to
// download a custom view.
//
// Parameters:
//		[in, out] CDownloadParams* pParams
//			The parameters describing the component to download
//			are passed though this structure, the stautus code
//			and object instance pointer are also returned via
//			this structure.
//
// Returns:
//		SCODE
//			An ordinary status code.
//
//**************************************************************
SCODE CDownload::DoDownload(CDownloadParams* pParams)
{
	pParams->m_sc = S_OK;
	pParams->m_ulCodeInstallStatus = 0;
	pParams->m_punk = NULL;
	m_pParams = pParams;

    HRESULT hr =  NOERROR;
	CDownloadBindStatusCallback *pbsc;
	IBindCtx *pbc;


	pbsc = new CDownloadBindStatusCallback(pParams->m_pdlg, this);

	if (pbsc != NULL)
		pbsc->AddRef();
	else
		hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        hr = CreateBindCtx(0, &pbc);

    if (SUCCEEDED(hr))
            hr = RegisterBindStatusCallback(pbc, pbsc, NULL, 0);

    if (SUCCEEDED(hr)) {
        hr = CoGetClassObjectFromURL(
					pParams->m_clsid,
					pParams->m_szCodebase,
					pParams->m_dwFileVersionMS,
					pParams->m_dwFileVersionLS,
					NULL,
					pbc,
					CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
					0,
					IID_IClassFactory,
					(VOID**) &pParams->m_punk);
	}


	ASSERT(m_pbsc == NULL);

	if (!m_pbsc) {
		m_pbsc = pbsc;
		m_pbc = pbc;
	}

	SCODE sc = GetScode(hr);
    return sc;
}  // CDownload::DoDownload
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\cvcache.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include <afxcmn.h>
#include "resource.h"
#include "DlgDownload.h"
#include "cvcache.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h




class CViewInfo
{
public:
	CViewInfo();
	~CViewInfo();
	void InstallComponent();

	BOOL CustomViewIsRegistered(CLSID& clsid, DWORD dwFileVersionMS, DWORD dwFileVersionLS);

	CString m_sClass;		// The target class of this viewer
    CLSID m_clsid;			// The GUID of the class viewer ActiveX control.
	DWORD m_dwFileVersionMS;  // The most significant part of the version number.
	DWORD m_dwFileVersionLS;  // The least significant part of the version number.
	COleVariant m_varCodebase; // The location of the class viewer ActiveX control.
	CString m_sTitle;		// The title that goes into the view selection combo box

private:
	SCODE DownloadCustomView(LPUNKNOWN& punk);
};


CViewInfo::CViewInfo()
{
}

CViewInfo::~CViewInfo()
{
}



//***********************************************************************
// CViewInfo::DownloadCustomView
//
// Download the custom view.
//
// Parameters:
//		[out] LPUNKNOWN& punk
//			The interface pointer to the custom view is returned here.
//
//
// Returns:
//		SCODE
//			S_OK if the custom view was downloaded and installed successfully,
//			a failure code otherwise.
//
//***********************************************************************
SCODE CViewInfo::DownloadCustomView(LPUNKNOWN& punk)
{
	SCODE sc;

	CDlgDownload dlg;
	sc = dlg.DoDownload(
			punk,
			m_clsid,
			m_varCodebase.bstrVal,
			m_dwFileVersionMS,
			m_dwFileVersionLS
			);

	return sc;
}



//************************************************************
// CViewInfo::CustomViewIsRegistered
//
// Parameters:
//		[in] CLSID& clsid
//			The class id for the custom view.
//
//		[in] DWORD dwFileVersionMS
//			The most significant part of the desired version number.
//			A value of 0xffffffff means any version.
//
//		[in] DWORD dwFileVersionLS
//			The least significant part of the desired version number.
//			A value of 0xffffffff means any version.
//
//
// Returns:
//		BOOL
//			TRUE if an OCX corresponding to the specified class id is
//			registered and the version number of the registered control
//			is the same or greater than the requested version.
//
//**************************************************************
BOOL CViewInfo::CustomViewIsRegistered(CLSID& clsid, DWORD dwFileVersionMS, DWORD dwFileVersionLS)
{
	// Read the version string from HKEY_CLASSES_ROOT\CLSID\<CLSID>\Version
	//
	// If this key exists, then we know that some version of the custom view is
	// registered, so if the file version is wildcarded, the custom view is installed.
	//
	// If a wildcard is not specified for the file version, then the installed
	// version must be the same or higher than the requested version.
	//
	HKEY hkeyClassesRoot = NULL;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_CLASSES_ROOT, &hkeyClassesRoot);
	if (lResult != ERROR_SUCCESS) {
		return FALSE;
	}




	// Construct a key path to the version key.
	LPOLESTR pwszClsid = NULL;

	SCODE sc;
	sc = StringFromCLSID(clsid, &pwszClsid);
	if(sc != S_OK)
	{
		return FALSE;
	}

	CString sVersionKey;
	sVersionKey = _T("CLSID\\{");
	sVersionKey += pwszClsid;
	sVersionKey += _T("}");
	sVersionKey += _T("\\Version");


	// Open the version key
	HKEY hkeyVersion = NULL;
	lResult = RegOpenKeyEx(
				hkeyClassesRoot,
				(LPCTSTR) sVersionKey,
				0,
				KEY_READ,
				&hkeyVersion);

	if (lResult != ERROR_SUCCESS) {
		RegCloseKey(hkeyClassesRoot);
		return FALSE;
	}


	// Read the version string
	unsigned long lcbValue = 256;
	CString sVersion;
	LPTSTR pszVersion = sVersion.GetBuffer(lcbValue);

	unsigned long lType;
	lResult = RegQueryValueEx(
				hkeyVersion,
				(LPCTSTR) _T(""),
				NULL,
				&lType,
				(unsigned char*) (void*) pszVersion,
				&lcbValue);


	sVersion.ReleaseBuffer();
	RegCloseKey(hkeyVersion);
	RegCloseKey(hkeyClassesRoot);

	if (lResult != ERROR_SUCCESS) {
		return FALSE;
	}

	// If the requested file version is ANY, then the control is registered
	if (dwFileVersionMS == ~0) {
		return TRUE;
	}




	DWORD dwFileVersionMSRegistered;
	DWORD dwFileVersionLSRegistered;
	int nFieldsConverted = 0;
	nFieldsConverted =  _stscanf(pszVersion, _T("%ld.%ld"), &dwFileVersionMSRegistered, &dwFileVersionLSRegistered);

	if (nFieldsConverted != 2) {
		return FALSE;
	}


	if (dwFileVersionMS != ~0) {
		if (dwFileVersionMSRegistered < dwFileVersionMS) {
			return FALSE;
		}

		if (dwFileVersionLS != ~0) {
			if (dwFileVersionLSRegistered < dwFileVersionLS) {
				return FALSE;
			}
		}
	}

	return TRUE;
}

//*******************************************************************************
void CViewInfo::InstallComponent()
{
	BOOL bViewIsRegistered;
	bViewIsRegistered = CustomViewIsRegistered(m_clsid, m_dwFileVersionMS, m_dwFileVersionLS);

	// its not there...
	if(!bViewIsRegistered)
	{

		// go get it.
		LPUNKNOWN punkDownload = NULL;
		SCODE sc;
		sc = DownloadCustomView(punkDownload);
		if(FAILED(sc))
		{
			if(sc != E_ABORT)
			{
				// If the download was cancelled, then the user is already aware of the
				// fact that the view is not available. If some other error occurred,
				// give the user a warning.
				AfxMessageBox(IDS_ERR_CUSTOM_VIEW_MISSING, MB_OK|MB_ICONSTOP);
			}
			return;
		}

		// throw it away. We're only installing, not using.
		if(punkDownload)
		{
			//punkDownload->Release();
			punkDownload = NULL;
		}
	}
}


//===========================================================================
CCustomViewCache::CCustomViewCache()
{
}


CCustomViewCache::~CCustomViewCache()
{
}

//------------------------------------------------------------------------------
SCODE CCustomViewCache::NeedComponent(LPWSTR szClsid, LPCWSTR szCodeBase,
									  int major, int minor)
{
	SCODE sc = 0;
	CViewInfo* pViewInfo = new CViewInfo;

	sc = CLSIDFromString((OLECHAR*) szClsid, &pViewInfo->m_clsid);
	if(sc != S_OK)
	{
		// The class ID format is not valid, so ignore this view since we
		// can't display it anyway.
		delete pViewInfo;
		return sc;
	}

	pViewInfo->m_varCodebase = szCodeBase;
	pViewInfo->m_dwFileVersionMS = major;
	pViewInfo->m_dwFileVersionLS = minor;

	//not using these two.
	pViewInfo->m_sTitle.Empty();
	pViewInfo->m_sClass.Empty();


	// Add this view info to the cache.
	pViewInfo->InstallComponent();

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\eventlist.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_EVENTLIST_H__AC146536_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_)
#define AFX_EVENTLIST_H__AC146536_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// EventList.h : main header file for EVENTLIST.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CEventListApp : See EventList.cpp for implementation.

class CEventListApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EVENTLIST_H__AC146536_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\eventlist.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// EventList.cpp : Implementation of CEventListApp and DLL registration.

#include "precomp.h"
#include "EventList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CEventListApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xac14652d, 0x87a5, 0x11d1, { 0xad, 0xbd, 0, 0xaa, 0, 0xb8, 0xe0, 0x5a } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CEventListApp::InitInstance - DLL initialization

BOOL CEventListApp::InitInstance()
{
	// CG: This line was added by the ActiveX Control Containment component
	AfxEnableControlContainer();

	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CEventListApp::ExitInstance - DLL termination

int CEventListApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\eventdata.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __EVENTDATASTUFF
#define __EVENTDATASTUFF

#define RELEASE(x)  if(x) {x->Release(); x = NULL;}

#include "PropThread.h"
#include <Afxmt.h>

// stored in the listctrl.
class EVENT_DATA;

class EVENT_DATA
{
public:
	BYTE m_severity;
	COleDateTime m_time;
	bstr_t m_EClass;
	bstr_t m_server;
	bstr_t m_desc;
	IWbemClassObject *m_eventPtr;
    PropertyThread *m_prop;
    bool m_dlgActive;
    EVENT_DATA *m_prev, *m_next;

    static BYTE GetByte(IWbemClassObject *obj, bstr_t prop)
    {
	    variant_t val;
	    BYTE retval = 0;
	    HRESULT hRes = 0;
	    if((hRes = obj->Get(prop, 0L, 
						    &val, NULL, NULL)) == S_OK) 
	    {
		    retval = val;
	    }
	    return retval;
    }

    static bstr_t GetString(IWbemClassObject *obj, bstr_t prop)
    {
	    variant_t val;
	    HRESULT hRes = 0;
	    if((hRes = obj->Get(prop, 0L, 
						    &val, NULL, NULL)) == S_OK) 
	    {
		    if(val.vt == VT_NULL)
		    {
			    return "";
		    }
	    }
	    return val;
    }

	// for testing.
	EVENT_DATA()
	{
		m_eventPtr = NULL;
        m_prop = NULL;
        m_dlgActive = false;
        m_prev = NULL;
        m_next = NULL;
	}

	// for real.
	EVENT_DATA(IWbemClassObject *lc, IWbemClassObject *ev)
	{
		m_severity = GetByte(lc, _T("Severity"));
		m_time = COleDateTime::GetCurrentTime();
		if(ev)
		{
			m_EClass = GetString(ev, _T("__CLASS"));
			m_server = GetString(ev, _T("__SERVER"));
		}
		else
		{
			m_EClass = _T("******");
			m_server = _T("******");
		}
		m_desc = GetString(lc, _T("Description"));
		m_eventPtr = ev;
        m_prop = NULL;
        m_dlgActive = false;
        m_prev = NULL;
        m_next = NULL;
	}

	~EVENT_DATA()
	{
		try{
			RELEASE(m_eventPtr);
		}
		catch(...) {}

		CCriticalSection cs;
		cs.Lock();
        if(m_dlgActive)
		{
		   if(m_prop && 
				m_prop->m_dlg && 
				m_prop->m_dlg->GetSafeHwnd())
		   {
					m_prop->m_dlg->SendMessage(WM_CLOSE);
		   }
		}
		
        m_prop = NULL;
		cs.Unlock();
        m_dlgActive = false;
   	}

    void ShowProperties(void)
    {
        // already active.
        if(m_dlgActive)
        {
            // re-show it.
            m_prop->OnTop();
        }
        else
        {
            // resync ptr to flag.
            m_prop = NULL;

            // create and display it in its own thread
            // so that the consumer isn't blocked.
            m_prop = new PropertyThread(m_eventPtr,
                                        &m_dlgActive);
            m_prop->CreateThread();

            // the dlg will set m_dlgActive = false when it
            // destroys itself. This dtor can also destroy 
            // dangling dialogs.
        }
    }
};

#endif __EVENTDATASTUFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\eventlistctl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// EventListCtl.cpp : Implementation of the CEventListCtrl ActiveX Control class.

#include "precomp.h"
#include "EventList.h"
#include "EventListCtl.h"
#include "EventListPpg.h"
#include "PropThread.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CEventListCtrl, COleControl)

extern CEventListApp NEAR theApp;

/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CEventListCtrl, COleControl)
	//{{AFX_MSG_MAP(CEventListCtrl)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CEventListCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CEventListCtrl)
	DISP_PROPERTY_EX(CEventListCtrl, "maxItems", GetMaxItems, SetMaxItems, VT_I4)
	DISP_PROPERTY_EX(CEventListCtrl, "ItemCount", GetItemCount, SetItemCount, VT_I4)
	DISP_FUNCTION(CEventListCtrl, "DoDetails", DoDetails, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CEventListCtrl, "Clear", Clear, VT_I4, VTS_I4)
	DISP_FUNCTION(CEventListCtrl, "AddWbemEvent", AddWbemEvent, VT_I4, VTS_UNKNOWN VTS_UNKNOWN)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CEventListCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CEventListCtrl, COleControl)
	//{{AFX_EVENT_MAP(CEventListCtrl)
	EVENT_CUSTOM("OnSelChanged", FireOnSelChanged, VTS_I4)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CEventListCtrl, 1)
	PROPPAGEID(CEventListPropPage::guid)
END_PROPPAGEIDS(CEventListCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CEventListCtrl, "WBEM.EventListCtrl.1",
	0xac146530, 0x87a5, 0x11d1, 0xad, 0xbd, 0, 0xaa, 0, 0xb8, 0xe0, 0x5a)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CEventListCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DEventList =
		{ 0xac14652e, 0x87a5, 0x11d1, { 0xad, 0xbd, 0, 0xaa, 0, 0xb8, 0xe0, 0x5a } };
const IID BASED_CODE IID_DEventListEvents =
		{ 0xac14652f, 0x87a5, 0x11d1, { 0xad, 0xbd, 0, 0xaa, 0, 0xb8, 0xe0, 0x5a } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwEventListOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CEventListCtrl, IDS_EVENTLIST, _dwEventListOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CEventListCtrl::CEventListCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CEventListCtrl

BOOL CEventListCtrl::CEventListCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to afxRegInsertable.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_EVENTLIST,
			IDB_EVENTLIST,
			afxRegInsertable | afxRegApartmentThreading,
			_dwEventListOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

/////////////////////////////////////////////////////////////////////////////
// CEventListCtrl::CEventListCtrl - Constructor

CEventListCtrl::CEventListCtrl()
{
	InitializeIIDs(&IID_DEventList, &IID_DEventListEvents);

	m_bChildrenCreated = false;
	m_iLastColumnClick = COL_TIME;
	m_sortAscending = false;
	m_initiallyDrawn = false;
    m_maxItems = 1000;   // default limit.
    m_oldestItem = NULL;
    m_newestItem = NULL;
	AfxEnableControlContainer();

}

/////////////////////////////////////////////////////////////////////////////
// CEventListCtrl::~CEventListCtrl - Destructor

CEventListCtrl::~CEventListCtrl()
{
	// TODO: Cleanup your control's instance data here.
}

// ***************************************************************************
DWORD CEventListCtrl::GetControlFlags()
{
	DWORD dwFlags = COleControl::GetControlFlags();

	// The control will not be redrawn when making the transition
	// between the active and inactivate state.
	dwFlags |= noFlickerActivate;
	return dwFlags;
}

/////////////////////////////////////////////////////////////////////////////
// CEventListCtrl::OnDraw - Drawing function

typedef struct
{
	LPTSTR text;
	int percent;
} COLUMNS;

COLUMNS cols[] =
{
	{_T("Sev"), 5},
	{_T("Time Received"), 22},
	{_T("Event Class"), 15},
	{_T("Server"), 15},
	{_T("Description"), 43}
};

#define NUM_COLS 5
//---------------------------------------------------
int CEventListCtrl::AddEvent(EVENT_DATA *data)
{
	TCHAR buf[30];
	int newItemNbr = m_list.GetItemCount() + 1;

    // if first item...
    if(m_oldestItem == NULL)
    {
        m_oldestItem = data;
    }
    else // append to LL...
    {
        // previous 'newest' pts to this guy...
        m_newestItem->m_next = data;

        // new guy pts back to previous new guy.
        data->m_prev = m_newestItem;
    }

    // this guy is the newest now.
    m_newestItem = data;

	memset(buf, 0, 30 * sizeof(TCHAR));

	// NOTE: severity maps to an imagelist index therefore it's
	// zero-based.
	int idx = m_list.InsertItem(LVIF_PARAM |LVIF_IMAGE,
								newItemNbr,
								NULL, //_itot(data->m_severity, buf, 10),
								0,
								0,
								min(data->m_severity, 2),
								(LPARAM)data);

	m_list.SetItemText(idx, COL_TIME, data->m_time.Format());
	m_list.SetItemText(idx, COL_CLASS, data->m_EClass);
	m_list.SetItemText(idx, COL_SERVER, data->m_server);
	m_list.SetItemText(idx, COL_DESC, data->m_desc);

	return idx;
}

//---------------------------------------------------------------
void CEventListCtrl::Resort(void)
{
	// sort using the current settings. This puts new events in
	// the right place.
	SORT_CMD cmd;
	cmd.column = m_iLastColumnClick;
	cmd.ascending = m_sortAscending;

	m_list.SetRedraw(FALSE);
	m_list.SortItems(CompareFunc, (LPARAM)&cmd);
	m_list.SetRedraw(TRUE);
}

//---------------------------------------------------------------
void CEventListCtrl::SillyLittleTest()
{
	int itemCount = 0;
	EVENT_DATA *data;

	data = new EVENT_DATA;

	data->m_severity = 3;
	data->m_time = COleDateTime(1998, 1, 14, 12, 15, 0);
	data->m_EClass = _T("Device off");
	data->m_server = _T("Coffee machine");
	data->m_desc = _T("Somebody forgot to turn on the coffee machine");

	m_list.InsertItem(LVIF_IMAGE|LVIF_PARAM, itemCount, _T("3"),
						0, 0, 2, (LPARAM)data);
	m_list.SetItemText(itemCount, 1, data->m_time.Format());
	m_list.SetItemText(itemCount, 2, data->m_EClass);
	m_list.SetItemText(itemCount, 3, data->m_server);
	m_list.SetItemText(itemCount++, 4, data->m_desc);

	data = new EVENT_DATA;

	data->m_severity = 2;
	data->m_time = COleDateTime(1998, 1, 14, 12, 25, 0);
	data->m_EClass = _T("Low Caffiene");
	data->m_server = _T("Human Chicken");
	data->m_desc = _T("Can't operate coffee machine before drinking coffee");

	m_list.InsertItem(LVIF_IMAGE|LVIF_PARAM, itemCount, _T("2"),
						0, 0, 1, (LPARAM)data);
	m_list.SetItemText(itemCount, 1, data->m_time.Format());
	m_list.SetItemText(itemCount, 2, data->m_EClass);
	m_list.SetItemText(itemCount, 3, data->m_server);
	m_list.SetItemText(itemCount++, 4, data->m_desc);

	data = new EVENT_DATA;

	data->m_severity = 1;
	data->m_time = COleDateTime(1998, 1, 14, 12, 30, 0);
	data->m_EClass = _T("End of World");
	data->m_server = _T("Reality");
	data->m_desc = _T("The big guy is mad about everything");

	m_list.InsertItem(LVIF_IMAGE|LVIF_PARAM, itemCount, _T("1"),
						0, 0, 0, (LPARAM)data);
	m_list.SetItemText(itemCount, 1, data->m_time.Format());
	m_list.SetItemText(itemCount, 2, data->m_EClass);
	m_list.SetItemText(itemCount, 3, data->m_server);
	m_list.SetItemText(itemCount++, 4, data->m_desc);

	SORT_CMD cmd;
	cmd.column = COL_TIME;
	cmd.ascending = m_sortAscending;
	m_list.SortItems(CompareFunc, (LPARAM)&cmd);
}

//----------------------------------------------------------
int CALLBACK CEventListCtrl::CompareFunc(LPARAM lParam1,
										LPARAM lParam2,
										LPARAM lParamSort)
{
	EVENT_DATA *data1 = (EVENT_DATA *)lParam1;
	EVENT_DATA *data2 = (EVENT_DATA *)lParam2;
	SORT_CMD *cmd = (SORT_CMD *)lParamSort;
	int retval = 0;

	// column to sort by.
	switch(cmd->column)
	{
	case COL_PRIORITY:
		if(data1->m_severity == data2->m_severity)
			retval = 0;
		else if(data1->m_severity < data2->m_severity)
			retval = -1;
		else
			retval = 1;
		break;

	case COL_TIME:
		if(data1->m_time == data2->m_time)
			retval = 0;
		else if(data1->m_time < data2->m_time)
			retval = -1;
		else
			retval = 1;
		break;

	case COL_CLASS:
		retval = strcmp(data1->m_EClass, data2->m_EClass);
		break;

	case COL_SERVER:
		retval = strcmp(data1->m_server, data2->m_server);
		break;

	case COL_DESC:
		retval = strcmp(data1->m_desc, data2->m_desc);
		break;

	default:
		return 0;
		break;
	} //endswitch by column.

	// if descending sort and they're not the same anyway....
	if(!cmd->ascending && (retval != 0))
	{
		// flip the answer.
		retval = -retval;
	}

	return retval;
}

//---------------------------------------------------------
void CEventListCtrl::LoadImageList()
{
	BOOL retval;

	if(m_iList.Create(16, 16, ILC_COLOR |ILC_MASK, 3, 3))
	{
		retval = m_iList.Add(theApp.LoadStandardIcon(IDI_HAND));
		retval = m_iList.Add(theApp.LoadStandardIcon(IDI_EXCLAMATION));
		retval = m_iList.Add(theApp.LoadStandardIcon(IDI_ASTERISK));

		m_list.SetImageList(&m_iList, LVSIL_SMALL);
	}
}

//---------------------------------------------------------
void CEventListCtrl::OnDraw(CDC* pdc,
							const CRect& rcBounds,
							const CRect& rcInvalid)
{
	BOOL retval = FALSE;

	if(GetSafeHwnd() == NULL)
	{
		return;
	}

	if(!m_bChildrenCreated)
	{
		if(m_list.Create(LVS_REPORT  | LVS_SINGLESEL |
						 WS_VISIBLE| WS_CHILD |
						 WS_BORDER | WS_TABSTOP|
						 LVS_SHOWSELALWAYS |LVS_SINGLESEL,
							rcBounds,
							this,
							IDC_LISTCTRL))
		{
			m_initiallyDrawn = true;
			// Set extended LV style for whole line selection.
			m_list.SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT|LVS_EX_HEADERDRAGDROP);

			m_bChildrenCreated = true;
			LoadImageList();

			// non-variants.
			LV_COLUMN col;
			col.mask = LVCF_TEXT|LVCF_WIDTH|LVCF_FMT|LVCF_SUBITEM;
			col.fmt =  LVCFMT_LEFT;
			int ctrlWidth = rcBounds.Width();

			for(int c = 0; c < NUM_COLS; c++)
			{
				col.cx = (cols[c].percent * ctrlWidth) / 100;
				col.pszText = cols[c].text;
				col.iSubItem = c;
				m_list.InsertColumn(c, &col);
			} //endfor 'adding the columns.
#ifdef _DEBUG
			SillyLittleTest();
#endif
		}
		else
		{
			// draw the default ellipse as an error indication.
			pdc->FillRect(rcBounds, CBrush::FromHandle((HBRUSH)GetStockObject(LTGRAY_BRUSH)));
			pdc->Ellipse(rcBounds);
		}
	}

	m_list.Invalidate();
}

/////////////////////////////////////////////////////////////////////////////
// CEventListCtrl::DoPropExchange - Persistence support

void CEventListCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}

/////////////////////////////////////////////////////////////////////////////
// CEventListCtrl::OnResetState - Reset control to default state

void CEventListCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}

/////////////////////////////////////////////////////////////////////////////
// CEventListCtrl::AboutBox - Display an "About" box to the user

void CEventListCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_EVENTLIST);
	dlgAbout.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CEventListCtrl message handlers

BOOL CEventListCtrl::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	// I've only got one control but.....
	if(wParam == IDC_LISTCTRL)
	{
		NMLISTVIEW *pnmlv = (NMLISTVIEW *)lParam;
		SORT_CMD cmd;

		// never admit to an error. :)
		*pResult = 0;

		switch(pnmlv->hdr.code)
		{
        case LVN_COLUMNCLICK:
			// change the sort.

			// if second consecutive click on same column...
            if (m_iLastColumnClick == pnmlv->iSubItem)
			{
				// toggle the sort direction.
                m_sortAscending = (m_sortAscending ? false : true);
			}
            else
			{
				// new column--start by sorting descending.
                m_sortAscending = false;

				// remember the column that was clicked.
		        m_iLastColumnClick = pnmlv->iSubItem;
			}

			// make it so.
			cmd.column = m_iLastColumnClick;
			cmd.ascending = m_sortAscending;
            m_list.SortItems(CompareFunc, (LPARAM)&cmd);
    		return TRUE;
	        break;

        case NM_CLICK:
			{
				// selection changed... tell the container.
				FireOnSelChanged(pnmlv->iItem);
			}
			return 0;  // docs require this.
			break;
        case NM_DBLCLK:
			// show the properties.
			DoDetails();
			return TRUE;
			break;

		case LVN_DELETEITEM:
			// clean up the internal data.
			{//BEGIN
				LV_ITEM lvi;

				lvi.mask     = LVIF_PARAM;
				lvi.iItem    = pnmlv->iItem;
				lvi.iSubItem = 0;
				lvi.lParam   = NULL;

				m_list.GetItem(&lvi);
				if(lvi.lParam)
				{
                    // hook up the neighbors...
                    EVENT_DATA *data = (EVENT_DATA *)lvi.lParam;
                    if(data->m_prev)
                        data->m_prev->m_next = data->m_next;
                    if(data->m_next)
                        data->m_next->m_prev = data->m_prev;

                    // kill self.
					delete data;
				}

			}//END
			return FALSE; // we want more LVN_DELETEITEMs.
			break;
		default:
			return TRUE;
			break;
		} //endswitch (code)
	}
	else
	{
		// it's not mine.
		return COleControl::OnNotify(wParam, lParam, pResult);
	}
}

//-------------------------------------------------------------------------
void CEventListCtrl::DoDetails()
{
    int iSelected = m_list.GetNextItem(-1, LVNI_SELECTED);

	if(iSelected == -1) return;

    LV_ITEM lvi;
    lvi.mask     = LVIF_PARAM;
    lvi.iItem    = iSelected;
    lvi.iSubItem = 0;
    lvi.lParam   = NULL;

    m_list.GetItem(&lvi);
	if(lvi.lParam)
	{
		EVENT_DATA *data = (EVENT_DATA *)lvi.lParam;
		IWbemClassObject *ev = (IWbemClassObject *)data->m_eventPtr;
		if(ev)
		{
            data->ShowProperties();
		}
		else  // no event object.
		{
			AfxMessageBox(IDS_NO_EVENT_DATA, MB_OK|MB_ICONSTOP);
		}
	}
	else // no data on item
	{
		AfxMessageBox(IDS_PROG_ERROR_DATA, MB_OK|MB_ICONSTOP);
	}
}

//-------------------------------------------------------------------------
long CEventListCtrl::AddWbemEvent(LPUNKNOWN logicalConsumer,
                                  LPUNKNOWN Event)
{
	SCODE sc = S_OK;
	IWbemClassObject *lc = NULL, *ev = NULL;

    TRACE(_T("Got another event\n"));

	// make sure we got a IWbemClassObject here.
	if(logicalConsumer != NULL)
	{
		HRESULT hr = logicalConsumer->QueryInterface(IID_IWbemClassObject,
									 				 (void**) &lc);
		if(FAILED(hr))
		{
			sc = GetScode(hr);
			return (long)sc;
		}
	}

	// make sure we got a IWbemClassObject here.
	if(Event != NULL)
	{
		HRESULT hr = Event->QueryInterface(IID_IWbemClassObject,
							 				 (void**) &ev);
		if(FAILED(hr))
		{
			sc = GetScode(hr);
			return (long)sc;
		}
	}

	//now add it to the list.
	EVENT_DATA *data = new EVENT_DATA(lc, ev);
	RELEASE(lc);
	AddEvent(data);
    CheckMaxItems();

    // honor the current sort settings.
	Resort();

	return (long)S_OK;
}

//---------------------------------------------------------
void CEventListCtrl::OnSize(UINT nType, int cx, int cy)
{
	COleControl::OnSize(nType, cx, cy);
	if(m_initiallyDrawn)
	{
		m_list.MoveWindow(0, 0, cx, cy);
		InvalidateControl();
	}
}

//---------------------------------------------------------
void CEventListCtrl::CheckMaxItems(void)
{
    if((m_oldestItem != NULL) &
       (m_list.GetItemCount() > m_maxItems))
    {
        int idx = -1;
        LV_FINDINFO findme;
        findme.flags = LVFI_PARAM;
        findme.psz = NULL;
        findme.lParam = (LPARAM)m_oldestItem;
        if((idx = m_list.FindItem(&findme, -1)) != -1)
        {
            // ptr to the next oldest item...
            EVENT_DATA *oldest = NULL;
            oldest = (EVENT_DATA *)m_list.GetItemData(idx);
            if(oldest)
            {
                m_oldestItem = oldest->m_next;
                m_oldestItem->m_prev = NULL;

                // delete the old geezer.
                m_list.DeleteItem(idx);
                //InvalidateControl();
            }
        }
    }
}

//---------------------------------------------------------
long CEventListCtrl::Clear(long item)
{
    if(!m_list.GetSafeHwnd())
        return 0;

    if(item == -1)
    {
	    m_list.DeleteAllItems();
        m_oldestItem = NULL;
        m_newestItem = NULL;
	    FireOnSelChanged(-1);
    }
    else if((item >= 0) &&
            (item <= m_list.GetItemCount()))
    {
        m_list.DeleteItem(item);
	    FireOnSelChanged(-1);
        // TODO smart reselect.
    }
    return m_list.GetItemCount();
}

//---------------------------------------------------------
long CEventListCtrl::GetMaxItems()
{
	return m_maxItems;
}

//---------------------------------------------------------
void CEventListCtrl::SetMaxItems(long nNewValue)
{
    m_maxItems = nNewValue;
	SetModifiedFlag();
}

//---------------------------------------------------------
long CEventListCtrl::GetItemCount()
{
    if(m_list.GetSafeHwnd())
        return m_list.GetItemCount();
    else
        return 0;
}

//---------------------------------------------------------
void CEventListCtrl::SetItemCount(long nNewValue)
{
    if(m_list.GetSafeHwnd())
    {
        m_list.SetItemCount(nNewValue);
	    SetModifiedFlag();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\eventlistctl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_EVENTLISTCTL_H__AC14653E_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_)
#define AFX_EVENTLISTCTL_H__AC14653E_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// EventListCtl.h : Declaration of the CEventListCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CEventListCtrl : See EventListCtl.cpp for implementation.

#include <afxcmn.h>
#include <comdef.h>
#include "wbemcli.h"
#include "EventData.h"

const UINT IDC_LISTCTRL = 1;

class CEventListCtrl : public COleControl
{
private:
	DECLARE_DYNCREATE(CEventListCtrl)

	CListCtrl m_list;
	CImageList m_iList;

	bool m_bChildrenCreated;
	void SillyLittleTest();
	void LoadImageList();
    void CheckMaxItems(void);
	bool m_initiallyDrawn;
    long m_maxItems;
    EVENT_DATA *m_oldestItem, *m_newestItem;

private:
	//- - - - - - - - - - - - - - - - - - - - - - - - -
	#define COL_PRIORITY 0
	#define COL_TIME 1
	#define COL_CLASS 2
	#define COL_SERVER 3
	#define COL_DESC 4
	int m_iLastColumnClick; 
	bool m_sortAscending;

	typedef struct
	{
		int column;
		bool ascending;
	} SORT_CMD;

	static int CALLBACK CompareFunc(LPARAM lParam1, 
									LPARAM lParam2, 
									LPARAM lParamSort);
	// - - - - - - - - - - - - - - - - - - - - - - 
	void Resort(void);
	int AddEvent(EVENT_DATA *data);

// Constructor
public:
	CEventListCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEventListCtrl)
	public:
	virtual DWORD GetControlFlags();
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	protected:
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CEventListCtrl();

	DECLARE_OLECREATE_EX(CEventListCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CEventListCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CEventListCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CEventListCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CEventListCtrl)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CEventListCtrl)
	afx_msg long GetMaxItems();
	afx_msg void SetMaxItems(long nNewValue);
	afx_msg long GetItemCount();
	afx_msg void SetItemCount(long nNewValue);
	afx_msg void DoDetails();
	afx_msg long Clear(long item);
	afx_msg long AddWbemEvent(LPUNKNOWN logicalConsumer, LPUNKNOWN Event);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CEventListCtrl)
	void FireOnSelChanged(long selected)
		{FireEvent(eventidOnSelChanged,EVENT_PARAM(VTS_I4), selected);}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CEventListCtrl)
	dispidMaxItems = 1L,
	dispidItemCount = 2L,
	dispidDoDetails = 3L,
	dispidClear = 4L,
	dispidAddWbemEvent = 5L,
	eventidOnSelChanged = 1L,
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EVENTLISTCTL_H__AC14653E_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\eventlistppg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// EventListPpg.cpp : Implementation of the CEventListPropPage property page class.

#include "precomp.h"
#include "EventList.h"
#include "EventListPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CEventListPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CEventListPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CEventListPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CEventListPropPage, "WBEM.EventListPropPage.1",
	0xac146531, 0x87a5, 0x11d1, 0xad, 0xbd, 0, 0xaa, 0, 0xb8, 0xe0, 0x5a)


/////////////////////////////////////////////////////////////////////////////
// CEventListPropPage::CEventListPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CEventListPropPage

BOOL CEventListPropPage::CEventListPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_EVENTLIST_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CEventListPropPage::CEventListPropPage - Constructor

CEventListPropPage::CEventListPropPage() :
	COlePropertyPage(IDD, IDS_EVENTLIST_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CEventListPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CEventListPropPage::DoDataExchange - Moves data between page and properties

void CEventListPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CEventListPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CEventListPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\eventlistppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_EVENTLISTPPG_H__AC146540_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_)
#define AFX_EVENTLISTPPG_H__AC146540_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// EventListPpg.h : Declaration of the CEventListPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CEventListPropPage : See EventListPpg.cpp.cpp for implementation.

class CEventListPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CEventListPropPage)
	DECLARE_OLECREATE_EX(CEventListPropPage)

// Constructor
public:
	CEventListPropPage();

// Dialog Data
	//{{AFX_DATA(CEventListPropPage)
	enum { IDD = IDD_PROPPAGE_EVENTLIST };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CEventListPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EVENTLISTPPG_H__AC146540_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\propthread.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __PROPERTYTHREAD__
#define __PROPERTYTHREAD__

#include "wbemcli.h"
#include "singleView.h"

class PropertyThread : public CWinThread
{
	DECLARE_DYNCREATE(PropertyThread)
protected:
	PropertyThread();           // protected constructor used by dynamic creation
public:
	PropertyThread(IWbemClassObject *ev, 
                    bool *active);
	void operator delete(void* p);

    void OnTop(void);

// Attributes
public:
    SingleView *m_dlg;

protected:
    IWbemClassObject *m_ev;
    LPSTREAM m_evStream;
    bool *m_active;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(PropertyThread)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation
	virtual ~PropertyThread();

	// Generated message map functions
	//{{AFX_MSG(PropertyThread)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

#endif __PROPERTYTHREAD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\singleview.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// SingleView.cpp : implementation file
//

#include "precomp.h"
#include "EventList.h"
#include "SingleView.h"
#include "EventListCtl.h"  // need the Get*() helpers.
#include "htmlhelp.h"
#include "cvCache.h"
#include "WbemRegistry.h"
#include "HTMTopics.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// SingleView dialog
SingleView::SingleView(IWbemClassObject *ev,
                       //bool *active,
                       CWnd* pParent /*=NULL*/)
	: CDialog(SingleView::IDD, pParent)
{
	EnableAutomation();
	m_ev = ev;
//    m_pImActive = active;

	m_initiallyDrawn = false;

	//{{AFX_DATA_INIT(SingleView)
	//}}AFX_DATA_INIT
}

//---------------------------------------------------------
SingleView::~SingleView()
{
}

//----------------------------------------
void SingleView::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CDialog::OnFinalRelease();
}

void SingleView::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(SingleView)
	DDX_Control(pDX, IDOK, m_closeBtn);
	DDX_Control(pDX, IDC_HELPME, m_helpBtn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(SingleView, CDialog)
	//{{AFX_MSG_MAP(SingleView)
	ON_BN_CLICKED(IDC_HELPME, OnHelp)
	ON_WM_SIZE()
	ON_BN_CLICKED(IDOK, OnOk)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(SingleView, CDialog)
	//{{AFX_DISPATCH_MAP(SingleView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_ISingleView to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the
//  dispinterface in the .ODL file.

// {823038C2-8931-11D1-ADBD-00AA00B8E05A}
static const IID IID_ISingleView =
{ 0x823038c2, 0x8931, 0x11d1, { 0xad, 0xbd, 0x0, 0xaa, 0x0, 0xb8, 0xe0, 0x5a } };

BEGIN_INTERFACE_MAP(SingleView, CDialog)
	INTERFACE_PART(SingleView, IID_ISingleView, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// SingleView message handlers

//-------------------------------------------------------------
BOOL SingleView::OnInitDialog()
{
	CDialog::OnInitDialog();

	CRect rect, rcBounds;
	CString cabPath;
	WCHAR clsid[50];
	CCustomViewCache cache;

	// find the cab.
	WbemRegString(APP_DIR, cabPath);
	cabPath += _T("\\wbemtool.cab");

	// convert to unicode.
#ifndef _UNICODE
	WCHAR cabFile[MAX_PATH];
	memset(cabFile, 0, MAX_PATH);
	MultiByteToWideChar(CP_ACP, 0,
						(LPCTSTR)cabPath, -1,
						cabFile, MAX_PATH);
#endif

	// now the other one.
	CWnd *placeHolder = GetDlgItem(IDC_PLACEHOLDER);
	placeHolder->GetWindowRect(&rect);
	ScreenToClient(&rect);
	placeHolder->DestroyWindow();

	BOOL created = m_singleViewCtl.Create(_T("singleviewer"),
									WS_CHILD|WS_VISIBLE,
									rect, this,
									IDC_SINGLEVIEWCTRL);
	if(!created)
	{
		// The ocx must not be installed.
		wcscpy(clsid, L"{2745E5F5-D234-11D0-847A-00C04FD7BB08}");
#ifdef _UNICODE
		cache.NeedComponent(clsid, cabPath);
#else
		cache.NeedComponent(clsid, cabFile);
#endif

		// try again.
		created = m_singleViewCtl.Create(_T("singleviewer"),
										WS_CHILD|WS_VISIBLE,
										rect, this,
										IDC_SINGLEVIEWCTRL);
	}

	if(created)
	{
		//-----------------------------------------
		// save the original position for later resizing.
		CRect rcBounds;

		// get the bounds again.
		GetClientRect(&rcBounds);

		// NOTE: rcBounds is the dlg; rect is the list.

		// margin on each side of list.
		m_listSide = rect.left - rcBounds.left;

		// top of dlg to top of list.
		m_listTop = rect.top - rcBounds.top;

		// bottom of dlg to bottom of list.
		m_listBottom = rcBounds.Height() - rect.Height() - m_listTop;


		// get the close button.
		m_closeBtn.GetWindowRect(&rect);
		ScreenToClient(&rect);

		// close btn right edge to dlg right edge.
		m_closeLeft = rcBounds.Width() - rect.left;

		// btn top to dlg bottom.
		m_btnTop = rcBounds.Height() - rect.top;

		//-------------------------------------------
		// deal with help button
		m_helpBtn.GetWindowRect(&rect);
		ScreenToClient(&rect);

		// help btn right edge to dlg right edge.
		m_helpLeft = rcBounds.Width() - rect.left;

		m_btnW = rect.Width();
		m_btnH = rect.Height();
		m_initiallyDrawn = true;
	}

	// configure the control.
    m_singleViewCtl.SetNameSpace(EVENT_DATA::GetString(m_ev, _T("__NAMESPACE")));
	m_singleViewCtl.SelectObjectByPointer(NULL, m_ev, FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//----------------------------------------------------------
void SingleView::OnHelp()
{
	CString csPath;
	WbemRegString(SDK_HELP, csPath);

	CString csData = idh_objviewer;
	HWND hWnd = NULL;

	try
	{
		HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD_PTR) (LPCTSTR) csData);
		if(!hWnd)
		{
			AfxMessageBox(IDS_NOHTMLHELP, MB_OK|MB_ICONSTOP);
		}
	}

	catch( ... )
	{
		// Handle any exceptions here.
		AfxMessageBox(IDS_NOHTMLHELP, MB_OK|MB_ICONSTOP);
	}
}

void SingleView::OnSize(UINT nType, int cx, int cy)
{
	CDialog::OnSize(nType, cx, cy);

	if(m_initiallyDrawn)
	{
		m_singleViewCtl.MoveWindow(m_listSide, m_listTop,
								cx - (2 * m_listSide), cy - m_listBottom - m_listTop);

		m_closeBtn.MoveWindow(cx - m_closeLeft, cy - m_btnTop,
								m_btnW, m_btnH);

		m_helpBtn.MoveWindow(cx - m_helpLeft, cy - m_btnTop,
								m_btnW, m_btnH);

		m_closeBtn.Invalidate();
		m_helpBtn.Invalidate();
		Invalidate();
	}

}

void SingleView::OnOk()
{
    // mark myself as dieing.
    // and die.
    CDialog::OnOK();
}

void SingleView::OnCancel()
{
	// TODO: Add extra cleanup here

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_STDAFX_H__AC146534_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_)
#define AFX_STDAFX_H__AC146534_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#include <afxdisp.h> // CG: added by ActiveX Control Containment component

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__AC146534_87A5_11D1_ADBD_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\propthread.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "PropThread.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// PropertyThread

IMPLEMENT_DYNCREATE(PropertyThread, CWinThread)

PropertyThread::PropertyThread()
{
    ASSERT(0);
}

//------------------------------------------------------
PropertyThread::PropertyThread(IWbemClassObject *ev,
                               bool *active) :
						m_ev(NULL), m_evStream(NULL)
{
    HRESULT hr = CoMarshalInterThreadInterfaceInStream(
                                            IID_IWbemClassObject,
                                            ev, &m_evStream);
    ASSERT(SUCCEEDED(hr));
	m_active = active;
    m_dlg = NULL;
}

//------------------------------------------------------
PropertyThread::~PropertyThread()
{
}

//------------------------------------------------------
void PropertyThread::operator delete(void* p)
{
	// The exiting main application thread waits for this event before completely
	// terminating in order to avoid a false memory leak detection.  See also
	// CBounceWnd::OnNcDestroy in bounce.cpp.

//	SetEvent(m_hEventBounceThreadKilled);

	CWinThread::operator delete(p);
}

//------------------------------------------------------
int PropertyThread::InitInstance()
{
    if(CoInitialize(NULL) == S_OK)
    {
        HRESULT hr = E_FAIL;

        //m_evStream->AddRef();

		if(m_evStream)
	        hr = CoGetInterfaceAndReleaseStream(m_evStream,
		                                        IID_IWbemClassObject,
			                                    (void**)&m_ev);

		if(SUCCEEDED(hr))
		{
			*m_active = true;
			m_dlg = new SingleView(m_ev);
			m_dlg->DoModal();
			m_dlg = NULL;
		}
		else
		{
			AfxMessageBox(IDS_NO_EVENT_DATA, MB_OK|MB_ICONSTOP, 0);
		}
    }

	return FALSE;
}

//------------------------------------------------------
void PropertyThread::OnTop(void)
{
    if(m_dlg)
        m_dlg->BringWindowToTop();
}

//------------------------------------------------------
int PropertyThread::ExitInstance()
{
    // suicide.
    *m_active = false;

    if(m_dlg)
      m_dlg->SendMessage(WM_CLOSE);

    CoUninitialize();
	return CWinThread::ExitInstance();
}

//------------------------------------------------------
BEGIN_MESSAGE_MAP(PropertyThread, CWinThread)
	//{{AFX_MSG_MAP(PropertyThread)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\singleviewctl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "singleviewctl.h"

/////////////////////////////////////////////////////////////////////////////
// CSingleViewCtl

IMPLEMENT_DYNCREATE(CSingleViewCtl, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CSingleViewCtl properties

CString CSingleViewCtl::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CSingleViewCtl::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

long CSingleViewCtl::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

long CSingleViewCtl::GetPropertyFilter()
{
	long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CSingleViewCtl::SetPropertyFilter(long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CSingleViewCtl operations

long CSingleViewCtl::GetEditMode()
{
	long result;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewCtl::SetEditMode(long lEditMode)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lEditMode);
}

long CSingleViewCtl::RefreshView()
{
	long result;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewCtl::NotifyWillShow()
{
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CSingleViewCtl::DeleteInstance()
{
	long result;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewCtl::ExternInstanceCreated(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

void CSingleViewCtl::ExternInstanceDeleted(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x9, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

long CSingleViewCtl::QueryCanCreateInstance()
{
	long result;
	InvokeHelper(0xa, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewCtl::QueryCanDeleteInstance()
{
	long result;
	InvokeHelper(0xb, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewCtl::QueryNeedsSave()
{
	long result;
	InvokeHelper(0xc, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewCtl::QueryObjectSelected()
{
	long result;
	InvokeHelper(0xd, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString CSingleViewCtl::GetObjectPath(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xe, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewCtl::StartViewEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xf, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

long CSingleViewCtl::GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp)
{
	long result;
	static BYTE parms[] =
		VTS_PBSTR VTS_PDISPATCH;
	InvokeHelper(0x10, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		pszTitle, lpPictureDisp);
	return result;
}

CString CSingleViewCtl::GetViewTitle(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x11, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewCtl::NextViewTitle(long lPositon, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x12, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPositon, pbstrTitle);
	return result;
}

long CSingleViewCtl::PrevViewTitle(long lPosition, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x13, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition, pbstrTitle);
	return result;
}

long CSingleViewCtl::SelectView(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x14, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewCtl::StartObjectEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x15, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

CString CSingleViewCtl::GetObjectTitle(long lPos)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x16, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPos);
	return result;
}

long CSingleViewCtl::SaveData()
{
	long result;
	InvokeHelper(0x17, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewCtl::AddContextRef(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x18, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleViewCtl::ReleaseContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x19, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleViewCtl::RestoreContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1a, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleViewCtl::GetContext(long* plCtxthandle)
{
	long result;
	static BYTE parms[] =
		VTS_PI4;
	InvokeHelper(0x1b, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		plCtxthandle);
	return result;
}

long CSingleViewCtl::NextObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1c, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewCtl::PrevObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1d, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewCtl::SelectObjectByPath(LPCTSTR szObjectPath)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x1e, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szObjectPath);
	return result;
}

long CSingleViewCtl::SelectObjectByPosition(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1f, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewCtl::SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase)
{
	long result;
	static BYTE parms[] =
		VTS_UNKNOWN VTS_UNKNOWN VTS_I4;
	InvokeHelper(0x20, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lpunkWbemServices, lpunkClassObject, bExistsInDatabase);
	return result;
}

long CSingleViewCtl::CreateInstance(LPCTSTR szClassName)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x21, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szClassName);
	return result;
}

long CSingleViewCtl::CreateInstanceOfCurrentClass()
{
	long result;
	InvokeHelper(0x22, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewCtl::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by EventList.rc
//
#define IDS_EVENTLIST                   1
#define IDD_ABOUTBOX_EVENTLIST          1
#define IDB_EVENTLIST                   1
#define IDI_ABOUTDLL                    1
#define IDS_EVENTLIST_PPG               2
#define IDS_EVENTLIST_PPG_CAPTION       200
#define IDD_PROPPAGE_EVENTLIST          200
#define IDI_SEV1                        201
#define IDS_NO_EVENT_DATA               201
#define IDI_SEV2                        202
#define IDS_PROG_ERROR_DATA             202
#define IDI_SEV3                        203
#define IDS_NO_HHCTRL                   203
#define IDD_SINGLEVIEW                  204
#define IDC_SINGLEVIEWCTRL              204
#define IDS_NO_HTMLHELP                 204
#define IDC_HELPME                      206
#define IDD_REGISTER_EVENT              209
#define IDC_PLACEHOLDER                 213
#define IDC_ANIMATE                     1008
#define IDC_MSG                         1019
#define IDS_ERR_VIEW_INSTALL_ACCESS_DENIED 5075
#define IDS_ERR_VIEW_INSTALL_DISK_FULL  5076
#define IDS_ERR_CUSTOM_VIEW_MISSING     5077
#define IDS_NO_HTML_PAGE                5078
#define IDS_NOHTMLHELP                  5078
#define IDD_DOWNLOAD                    5211
#define IDC_PROGRESS                    5513
#define IDR_AVIDOWNLOAD                 6000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        215
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         215
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\singleviewctl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SINGLEVIEWCTL_H__0E705392_0307_11D2_8832_00104B2AFB46__INCLUDED_)
#define AFX_SINGLEVIEWCTL_H__0E705392_0307_11D2_8832_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CSingleViewCtl wrapper class

class CSingleViewCtl : public CWnd
{
protected:
	DECLARE_DYNCREATE(CSingleViewCtl)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x2745e5f5, 0xd234, 0x11d0, { 0x84, 0x7a, 0x0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetReadyState();
	long GetPropertyFilter();
	void SetPropertyFilter(long);

// Operations
public:
	long GetEditMode();
	void SetEditMode(long lEditMode);
	long RefreshView();
	void NotifyWillShow();
	long DeleteInstance();
	void ExternInstanceCreated(LPCTSTR szObjectPath);
	void ExternInstanceDeleted(LPCTSTR szObjectPath);
	long QueryCanCreateInstance();
	long QueryCanDeleteInstance();
	long QueryNeedsSave();
	long QueryObjectSelected();
	CString GetObjectPath(long lPosition);
	long StartViewEnumeration(long lWhere);
	long GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp);
	CString GetViewTitle(long lPosition);
	long NextViewTitle(long lPositon, BSTR* pbstrTitle);
	long PrevViewTitle(long lPosition, BSTR* pbstrTitle);
	long SelectView(long lPosition);
	long StartObjectEnumeration(long lWhere);
	CString GetObjectTitle(long lPos);
	long SaveData();
	long AddContextRef(long lCtxtHandle);
	long ReleaseContext(long lCtxtHandle);
	long RestoreContext(long lCtxtHandle);
	long GetContext(long* plCtxthandle);
	long NextObject(long lPosition);
	long PrevObject(long lPosition);
	long SelectObjectByPath(LPCTSTR szObjectPath);
	long SelectObjectByPosition(long lPosition);
	long SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase);
	long CreateInstance(LPCTSTR szClassName);
	long CreateInstanceOfCurrentClass();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SINGLEVIEWCTL_H__0E705392_0307_11D2_8832_00104B2AFB46__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\eventviewer\eventlist\singleview.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{AFX_INCLUDES()
#include "singleviewctl.h"
//}}AFX_INCLUDES
#if !defined(AFX_SINGLEVIEW_H__823038C3_8931_11D1_ADBD_00AA00B8E05A__INCLUDED_)
#define AFX_SINGLEVIEW_H__823038C3_8931_11D1_ADBD_00AA00B8E05A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SingleView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// SingleView dialog
#include <wbemcli.h>
#include "resource.h"

class SingleView : public CDialog
{
// Construction
public:
    SingleView(IWbemClassObject *ev,
                //bool *active,
                CWnd* pParent = NULL);   // standard constructor

	virtual ~SingleView();

// Dialog Data
	//{{AFX_DATA(SingleView)
	enum { IDD = IDD_SINGLEVIEW };
	CButton	m_closeBtn;
	CButton	m_helpBtn;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(SingleView)
	public:
	virtual void OnFinalRelease();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

private:

	IWbemClassObject *m_ev;
	HINSTANCE m_htmlHelpInst;
	CSingleViewCtl m_singleViewCtl;

	// resizing vars;
	UINT m_listSide;		// margin on each side of list.
	UINT m_listTop;			// top of dlg to top of list.
	UINT m_listBottom;		// bottom of dlg to bottom of list.
	UINT m_closeLeft;		// close btn left edge to dlg right edge.
	UINT m_helpLeft;		// close btn left edge to dlg right edge.
	UINT m_btnTop;			// btn top to dlg bottom.
	UINT m_btnW;			// btn width
	UINT m_btnH;			// btn height
	bool m_initiallyDrawn;

protected:

	// Generated message map functions
	//{{AFX_MSG(SingleView)
	virtual BOOL OnInitDialog();
	afx_msg void OnHelp();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnOk();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(SingleView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SINGLEVIEW_H__823038C3_8931_11D1_ADBD_00AA00B8E05A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\availclasses.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_AVAILCLASSES_H__008C8F41_D06B_11D0_9640_00C04FD9B15B__INCLUDED_)
#define AFX_AVAILCLASSES_H__008C8F41_D06B_11D0_9640_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AvailClasses.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAvailClasses window

class CAvailClasses : public CListBox
{
// Construction
public:
	CAvailClasses();

// Attributes
public:

// Operations
public:
	// Make this look like it supports extended selection
	int GetSelCount();
	int SetSel( int nIndex, BOOL bSelect = TRUE );
	int GetSelItems( int nMaxItems, LPINT rgIndex );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAvailClasses)
	public:
	//virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CAvailClasses();

	// Generated message map functions
protected:
	CFont m_cfBold;
	BOOL m_bInit;
	//{{AFX_MSG(CAvailClasses)
	afx_msg void OnSelchange();
	afx_msg void OnDblclk();
	afx_msg int VKeyToItem(UINT nKey, UINT nIndex);
	afx_msg void OnKillfocus();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AVAILCLASSES_H__008C8F41_D06B_11D0_9640_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\availclasses.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// AvailClasses.cpp : implementation file
//

#include "precomp.h"
#include "wbemidl.h"
#include "navigator.h"
#include "AvailClasses.h"
#include "AvailClassEdit.h"
#include "SelectedClasses.h"
#include "SimpleSortedCStringArray.h"
#include "BrowseforInstances.h"
#include "OLEMSClient.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAvailClasses

CAvailClasses::CAvailClasses()
{
	m_bInit = FALSE;
}

CAvailClasses::~CAvailClasses()
{
}


BEGIN_MESSAGE_MAP(CAvailClasses, CListBox)
	//{{AFX_MSG_MAP(CAvailClasses)
	ON_CONTROL_REFLECT(LBN_SELCHANGE, OnSelchange)
	ON_CONTROL_REFLECT(LBN_DBLCLK, OnDblclk)
	ON_WM_VKEYTOITEM_REFLECT()
	ON_CONTROL_REFLECT(LBN_KILLFOCUS, OnKillfocus)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAvailClasses message handlers

/*int CAvailClasses::CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct)
{
	// TODO: Add your code to determine the sorting order of the specified items
	// return -1 = item 1 sorts before item 2
	// return 0 = item 1 and item 2 sort the same
	// return 1 = item 1 sorts after item 2

	return 0;
}*/

void CAvailClasses::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{

	CFont* pOldFont;


	CDC* pDC = CDC::FromHandle(lpDIS->hDC);


	if (!m_bInit)
	{
		m_bInit = TRUE;
		CFont *pcfCurrent = pDC->GetCurrentFont();
		LOGFONT lfCurrent;
		int nReturn = pcfCurrent->GetLogFont(&lfCurrent);
		lfCurrent.lfWeight = 700;
		m_cfBold.CreateFontIndirect(&lfCurrent);
	}

	CBrowseforInstances *pParent =
		reinterpret_cast<CBrowseforInstances *>
			(GetParent());

	//pParent->ClearSelectedSelection();

	if (lpDIS->itemID == -1)
	{
		return;
	}

	int nItem = lpDIS->itemID + 1;

	if (GetItemData(lpDIS->itemID) == 1)
	{
		pOldFont = pDC -> SelectObject( &m_cfBold );
	}

	COLORREF cr = (COLORREF)RGB(255, 255, 255);

	RECT rectFill = lpDIS->rcItem;
	rectFill.bottom += 0;

	int nListItem = lpDIS->itemID;
	BOOL bDrawEntireAction = lpDIS->itemAction & ODA_DRAWENTIRE;
	BOOL bSelectAction = lpDIS->itemAction & ODA_SELECT;
	BOOL bFocusAction = lpDIS->itemAction & ODA_FOCUS;
	BOOL bSelectItem = lpDIS->itemState & ODS_SELECTED;
	BOOL bFocusItem = lpDIS->itemState & ODS_FOCUS;

	if (bSelectAction)
	{
		pParent->ClearSelectedSelection();
	}

	if (bDrawEntireAction)
	{
		CString csOut =
			pParent->GetCurrentAvailClasses().GetStringAt(nItem);
		pDC->TextOut(lpDIS->rcItem.left + 3,
			lpDIS->rcItem.top + 1,csOut);

	}

	if ((bSelectAction | bDrawEntireAction) && bSelectItem)
	{
		// Item was selected
		COLORREF crHilite = GetSysColor(COLOR_ACTIVECAPTION);
		CBrush br(crHilite);
		pDC->FillRect(&rectFill, &br);
		pDC->SetBkMode( TRANSPARENT );
		CString csOut =
			pParent->GetCurrentAvailClasses().GetStringAt(nItem);
		COLORREF crSave = pDC->GetTextColor( );
		pDC->SetTextColor(RGB(255,255,255));
		pDC->TextOut(lpDIS->rcItem.left + 3,
			lpDIS->rcItem.top + 1,csOut);
		pDC->SetTextColor(crSave);
		pDC->SetBkMode( OPAQUE );
	}

	if ((bSelectAction | bDrawEntireAction) && !bSelectItem)

	{
		// Item has been de-selected
		CBrush br(cr);
		pDC->FillRect(&rectFill, &br);
		CString csOut =
			pParent->GetCurrentAvailClasses().GetStringAt(nItem);
		pDC->TextOut(lpDIS->rcItem.left + 3,
			lpDIS->rcItem.top + 1,csOut);

	}

	if (bFocusAction)
	{
		pDC->DrawFocusRect(&lpDIS->rcItem);
	}


	if (GetItemData(lpDIS->itemID) == 1)
	{
		pDC -> SelectObject( pOldFont );

	}

}

void CAvailClasses::MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
{
	CBrowseforInstances *pParent =
		reinterpret_cast<CBrowseforInstances *>
			(GetParent());
	TEXTMETRIC *ptmFont = &pParent->m_tmFont;

	lpMeasureItemStruct->itemHeight =
		ptmFont->tmHeight +
		ptmFont->tmDescent ;
}


void CAvailClasses::OnSelchange()
{
	// TODO: Add your control notification handler code here

}

void CAvailClasses::OnDblclk()
{
	// TODO: Add your control notification handler code here
	CBrowseforInstances *pParent =
		reinterpret_cast<CBrowseforInstances *>
			(GetParent());
	pParent->OnButtonadd();
}

int CAvailClasses::VKeyToItem(UINT nKey, UINT nIndex)
{
	// TODO: Replace the next line with your message handler code
	return -1;
}

void CAvailClasses::OnKillfocus()
{
	// TODO: Add your control notification handler code here

}

// Make this look like it supports extended selection
int CAvailClasses::GetSelCount()
{
	if (GetCurSel() != LB_ERR)
	{
		return 1;
	}
	else
	{
		return 0;
	}

}

int CAvailClasses::SetSel( int nIndex, BOOL bSelect)
{
	if (bSelect == TRUE)
	{
		return SetCurSel(nIndex);
	}
	else
	{
		return SetCurSel(-1);

	}

}

int CAvailClasses::GetSelItems( int nMaxItems, LPINT rgIndex )
{
	if (nMaxItems > 0)
	{
		int nSelection = GetCurSel();
		if (nSelection != LB_ERR)
		{
			rgIndex[0] = nSelection;
			return 1;
		}
		else
		{
			return LB_ERR;
		}

	}
	return LB_ERR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\banner.cpp ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: banner.cpp
//
// Description:
//	This file implements the CBanner class which is a part of the Class Explorer
//	OCX.  CBanner is a subclass of the Microsoft CWnd class and performs
//	the following functions:
//		a.  Contains static label, combo box and toolbar child contols
//			which allow the user to select a namespace and invoke filter
//			view dialog.
//		b.  Handles the creation of, geometry and destruction of the child
//			contols.
//
// Part of:
//	Navigator.ocx
//
// Used by:
//	CNavigatorCtrl class
//
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

#include "precomp.h"
#include "afxpriv.h"
#include "wbemidl.h"
#include "resource.h"
#include "AFXCONV.H"
#include "CInstanceTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "InstanceSearch.h"
#include "navigatorctl.h"
#include "OLEMSCLient.h"
#include "nsentry.h"
#include "InstNavNSEntry.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// ***************************************************************************
//
// CBanner::CBanner
//
// Description:
//	  Class constructor.
//
// Parameters:
//	  CNavigatorCtrl* pParent		Parent
//
// Returns:
//	  NONE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CBanner::CBanner(CNavigatorCtrl* pParent /*=NULL*/)
	:	m_pParent (pParent),
		m_bFontCreated (FALSE),
		m_nOffset (2),
		m_pnseNameSpace (NULL)
{
	m_csBanner = _T("Objects in:");
}

// ***************************************************************************
//
// CBanner::~CBanner
//
// Description:
//	  Class destructor.
//
// Parameters:
//	  void
//
// Returns:
//	  NONE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CBanner::~CBanner()
{
	delete m_pnseNameSpace;
}



BEGIN_MESSAGE_MAP(CBanner, CWnd)
	//{{AFX_MSG_MAP(CBanner)
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_WM_CREATE()
	ON_COMMAND(ID_BUTTONFILTER, OnButtonfilter)
	ON_COMMAND(ID_BROWSEFORINST, OnBrowseforinst)
	ON_UPDATE_COMMAND_UI(ID_BROWSEFORINST, OnUpdateBrowseforinst)
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


// ***************************************************************************
//
//	CBannerCWnd::SetChildControlGeometry
//
//	Description:
//		Set the geometry of the children controls based upon font size for the
//		edit and button controls.  Remainder goes to the tree control.
//
//	Parameters:
//		int cx			Width
//		int cy			Height
//
//	Returns:
//		void
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CBanner::SetChildControlGeometry(int cx, int cy)
{

	if (cx == 0 && cy == 0)
	{
		return;
	}

	int nTextLength = GetTextLength(&m_csBanner);
	CSize csToolBar = m_cctbToolBar.GetToolBarSize();

	CRect rBannerRect = CRect(	0 + nSideMargin ,
							0 + nTopMargin ,
							cx - nSideMargin ,
							cy - nTopMargin);

	rBannerRect.NormalizeRect();

	int nNameSpaceX = rBannerRect.TopLeft().x + nTextLength + 8;

	int nToolBarX = max(nNameSpaceX + 2,
						rBannerRect.TopLeft().x +
							rBannerRect.Width() - (csToolBar.cx + 6));

	int nNameSPaceXMax = nToolBarX - 2;

	#pragma warning( disable :4244 )
	int nToolBarY = rBannerRect.TopLeft().y +
					((rBannerRect.Height() - csToolBar.cy) * .5);
	#pragma warning( default : 4244 )




	m_rNameSpace = CRect(	nNameSpaceX,
							rBannerRect.TopLeft().y - 3,
							nNameSPaceXMax,
							rBannerRect.BottomRight().y);


	m_rToolBar = CRect(nToolBarX,
				nToolBarY - nTopMargin,
				rBannerRect.BottomRight().x  - 0,
				nToolBarY + csToolBar.cy + nTopMargin );

}


// ***************************************************************************
//
//  CBanner::PreCreateWindow
//
//	Description:
//		This VIRTUAL member function returns Initializes create struct values
//		for the custom tree control.
//
//	Parameters:
//		CREATESTRUCT& cs	A reference to a CREATESTRUCT with default control
//							creation values.
//
//	Returns:
// 		BOOL				Nonzero if the window creation should continue;
//							0 to indicate creation failure.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
BOOL CBanner::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Add your specialized code here and/or call the base class

	cs.style = WS_CHILD | WS_VISIBLE | ES_WANTRETURN;
	cs.style &= ~WS_BORDER;

	if (!CWnd::PreCreateWindow(cs))
	{
		return FALSE;
	}

	return TRUE;

}

// ***************************************************************************
//
//  CClassTree::OnPaint
//
//	Description:
//		Paint the client area of the widow.
//
//	Parameters:
//		NONE
//
//	Returns:
// 		VOID
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************

void CBanner::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	COLORREF dwBackColor = GetSysColor(COLOR_3DFACE);
	COLORREF crWhite = RGB(255,255,255);
	COLORREF crGray = GetSysColor(COLOR_3DHILIGHT);
	COLORREF crDkGray = GetSysColor(COLOR_3DSHADOW);
	COLORREF crBlack = GetSysColor(COLOR_WINDOWTEXT);

	CBrush br3DFACE(dwBackColor);
	dc.FillRect(&dc.m_ps.rcPaint, &br3DFACE);

	// Must do update to be able to over draw the border area.
	m_cctbToolBar.UpdateWindow();
	m_pnseNameSpace->RedrawWindow();  // calls on paint very important

	dc.SelectObject( &(m_pParent->m_cfFont) );


	dc.SetBkMode( TRANSPARENT );


	CRect rcClipInitial;
	int nReturn = dc.GetClipBox( &rcClipInitial);
	CRect rcClip;
	CRect rcClient;
	GetClientRect(rcClient);


	// Draw the banner text that is clipped so that we don't overwrite the other stuff.
	rcClient.DeflateRect(0, 0, 11, 0);
	rcClip.IntersectRect(rcClipInitial, rcClient);
	CRgn rgnClip;
	rgnClip.CreateRectRgnIndirect( &rcClip );
	dc.SelectClipRgn( &rgnClip );
	dc.TextOut( m_nOffset + nSideMargin + 2, 9,
		(LPCTSTR) m_csBanner, m_csBanner.GetLength() );
	rgnClip.DeleteObject();

	// Draw the frame using the original clip box.
	dc.SetBkMode( OPAQUE );
	rgnClip.CreateRectRgnIndirect( &rcClipInitial );
	dc.SelectClipRgn( &rgnClip);
	DrawFrame(&dc);
	rgnClip.DeleteObject( );


	// Do not call CWnd::OnPaint() for painting messages
}

// ***************************************************************************
//
// CBanner::OnSize
//
// Description:
//	  Called by the framework after the window is being resized.
//
// Parameters:
//	  UINT nType			Specifies the type of resizing requested.
//	  int cx				Specifies the new width of the client area.
//	  int cy				Specifies the new height of the client area.
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CBanner::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);
	SetChildControlGeometry(cx, cy);
	m_cctbToolBar.MoveWindow( m_rToolBar);
	m_pnseNameSpace->MoveWindow( m_rNameSpace);
}

// ***************************************************************************
//
//	CBannerCWnd::GetTextLength
//
//	Description:
//		Get the length of a string using the control's font.
//
//	Parameters:
//		CString *		Text
//
//	Returns:
//		int				Length of string
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
int CBanner::GetTextLength(CString *pcsText)
{

	CSize csLength;
	int nReturn;

	CDC *pdc = CWnd::GetDC( );

	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont* pOldFont = pdc -> SelectObject( &(m_pParent -> m_cfFont) );
	csLength = pdc-> GetTextExtent( *pcsText );
	nReturn = csLength.cx;
	pdc -> SelectObject(pOldFont);

	ReleaseDC(pdc);
	return nReturn;


}

// ***************************************************************************
//
// CBanner::OnCreate
//
// Description:
//	  Called by the framework after the window is being created but before
//	  the window is shown.
//
// Parameters:
//	  LPCREATESTRUCT lpCreateStruct	Pointer to the structure which contains
//									default parameters.
//
// Returns:
//	  BOOL				0 if continue; -1 if the window should be destroyed.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
int CBanner::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	CRect crRect;
	GetClientRect( &crRect);

	if(m_cctbToolBar.Create
		(this, WS_CHILD | WS_VISIBLE  | CBRS_SIZE_FIXED) == -1)
	{
		return FALSE;
	}

	m_cctbToolBar.LoadToolBar( MAKEINTRESOURCE(IDR_TOOLBARFILTER) );

	CToolBarCtrl* ptbcToolBarCtrl = &m_cctbToolBar.GetToolBarCtrl();

	EnableSearchButton(FALSE);

	SetChildControlGeometry(crRect.Width(), crRect.Height());

	m_pnseNameSpace = new CInstNavNSEntry;

	m_pnseNameSpace->SetLocalParent(m_pParent);

	if (m_pnseNameSpace->Create(NULL, NULL, WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN
		, m_rNameSpace,
		this, IDC_NSENTRY, NULL) == 0)
	{
		return FALSE;
	}

	// This is where we want to associate a string with
	// the tool for each button.
	CSize csToolBar = m_cctbToolBar.GetToolBarSize();

	#pragma warning( disable :4244 )
	CRect crToolBar((int) csToolBar.cx * 0,0,(int) csToolBar.cx * 1,csToolBar.cy);
	#pragma warning( default : 4244 )

	m_cctbToolBar.GetToolTip().AddTool
		(ptbcToolBarCtrl,_T("Browse for Instance"),&crToolBar,1);


	return 0;
}

// ***************************************************************************
//
// CClassTree::DrawFrame
//
// Description:
//	  Draws the frame around the banner window.
//
// Parameters:
//	  CDC* pdc			Device context for drawing.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CBanner::DrawFrame(CDC* pdc)
{
	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));


	CRect rcFrame;
	GetClientRect(rcFrame);
	rcFrame.DeflateRect(nSideMargin,nTopMargin - 1);

	CRect rc;


	// Horizontal line at top
	rc.left = rcFrame.left;
	rc.right = rcFrame.right - 1;
	rc.top = rcFrame.top - 1;
	rc.bottom = rcFrame.top ;
	pdc->FillRect(rc, &br3DSHADOW);

	// Horizontal line at bottom
	rc.top = rcFrame.bottom - 1;
	rc.bottom = rcFrame.bottom ;
	pdc->FillRect(rc, &br3DHILIGHT);

	// Vertical line at left
	rc.left = rcFrame.left;
	rc.right = rcFrame.left + 1;
	rc.top = rcFrame.top;
	rc.bottom = rcFrame.bottom;
	pdc->FillRect(rc, &br3DSHADOW);

	// Vertical line at right
	rc.left = rcFrame.right - 2;
	rc.right = rcFrame.right - 1;
	pdc->FillRect(rc, &br3DHILIGHT);

}

// ***************************************************************************
//
// CClassTree::OnButtonFilter
//
// Description:
//	  Filter view handler.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CBanner::OnButtonfilter()
{

}

CString CBanner::GetNameSpace()
{
	return m_pnseNameSpace->GetNameSpace();

}

void CBanner::SetNameSpace(CString *pcsNamespace)
{
	m_pnseNameSpace->SetNameSpace(*pcsNamespace);

}

SCODE CBanner::OpenNamespace(CString *pcsNamespace, BOOL boolNoFireEvent)
{
	BOOL bReturn =  m_pnseNameSpace->OpenNamespace(*pcsNamespace,boolNoFireEvent);
	//m_pParent->PostMessage(INVALIDATE_CONTROL,0,0);
	return bReturn;
}

void CBanner::NSEntryRedrawn()
{
	Invalidate();
	m_pParent->InvalidateControl();
	//m_pParent->PostMessage(INVALIDATE_CONTROL,0,0);

}

void CBanner::OnBrowseforinst()
{
	// TODO: Add your command handler code here
	m_pParent->OnPopupBrowse();
}

void CBanner::OnUpdateBrowseforinst(CCmdUI* pCmdUI)
{

}

void CBanner::OnSetFocus(CWnd* pOldWnd)
{
	m_pnseNameSpace->SetFocusToEdit();
}


/*	EOF:  banner.cpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\availclassedit.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_AVAILCLASSEDIT_H__090CA7C1_D15B_11D0_9642_00C04FD9B15B__INCLUDED_)
#define AFX_AVAILCLASSEDIT_H__090CA7C1_D15B_11D0_9642_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AvailClassEdit.h : header file
//

#define AvailClassEditTimer 1000
#define UPDATESELECTEDCLASS WM_USER  + 88

/////////////////////////////////////////////////////////////////////////////
// CAvailClassEdit window

class CAvailClassEdit : public CEdit
{
// Construction
public:
	CAvailClassEdit();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAvailClassEdit)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CAvailClassEdit();

	// Generated message map functions
protected:
	UINT m_uiTimer;
	//{{AFX_MSG(CAvailClassEdit)
	afx_msg void OnCaptureChanged(CWnd *pWnd);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	afx_msg LRESULT UpdateAvailClass(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AVAILCLASSEDIT_H__090CA7C1_D15B_11D0_9642_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\availclassedit.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// AvailClassEdit.cpp : implementation file
//

#include "precomp.h"
#include "wbemidl.h"
#include "navigator.h"
#include "AvailClasses.h"
#include "AvailClassEdit.h"
#include "SelectedClasses.h"
#include "SimpleSortedCStringArray.h"
#include "BrowseforInstances.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


void CALLBACK EXPORT  SelectClassAfterDelay
		(HWND hWnd,UINT nMsg,WPARAM nIDEvent, ULONG dwTime)
{
	::PostMessage(hWnd,UPDATESELECTEDCLASS,0,0);

}

/////////////////////////////////////////////////////////////////////////////
// CAvailClassEdit

CAvailClassEdit::CAvailClassEdit()
{
	m_uiTimer = 0;
}

CAvailClassEdit::~CAvailClassEdit()
{


}


BEGIN_MESSAGE_MAP(CAvailClassEdit, CEdit)
	//{{AFX_MSG_MAP(CAvailClassEdit)
	ON_WM_CAPTURECHANGED()
	ON_WM_TIMER()
	ON_WM_CHAR()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	ON_MESSAGE( UPDATESELECTEDCLASS,UpdateAvailClass)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAvailClassEdit message handlers

void CAvailClassEdit::OnCaptureChanged(CWnd *pWnd)
{
	// TODO: Add your message handler code here
	if (!m_uiTimer == 0)
	{
		KillTimer( m_uiTimer );
		m_uiTimer = 0;
	}

	CEdit::OnCaptureChanged(pWnd);
}

void CAvailClassEdit::OnTimer(UINT nIDEvent)
{
	// TODO: Add your message handler code here and/or call default
	/*if (nIDEvent == AvailClassEditTimer)
	{
		MessageBox(_T("Timer"));
		KillTimer( m_uiTimer );
		m_uiTimer = 0;
		return;
	}*/

	CEdit::OnTimer(nIDEvent);
}

void CAvailClassEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// TODO: Add your message handler code here and/or call default
	if (m_uiTimer < 0 || m_uiTimer > 0)
	{
		KillTimer( m_uiTimer );
		m_uiTimer = 0;
	}

	if (nChar == 13)
	{
		CBrowseforInstances *pParent =
			reinterpret_cast<CBrowseforInstances *>
			(GetParent());
		pParent->SendMessage(UPDATESELECTEDCLASS,0,0);
		pParent->OnButtonadd();
		// return;

	}
	else
	{
		m_uiTimer = (UINT) SetTimer(AvailClassEditTimer, AvailClassEditTimer, SelectClassAfterDelay);
	}

	CEdit::OnChar(nChar, nRepCnt, nFlags);
}

void CAvailClassEdit::OnDestroy()
{
	if (!m_uiTimer == 0)
	{
		KillTimer( m_uiTimer );
		m_uiTimer = 0;
	}

	CEdit::OnDestroy();

	// TODO: Add your message handler code here

}

BOOL CAvailClassEdit::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
	case WM_KEYUP:
      if (pMsg->wParam == VK_ESCAPE)
      {
		CBrowseforInstances *pParent =
			reinterpret_cast<CBrowseforInstances *>
			(GetParent());
		pParent->m_bEscSeen = TRUE;
      }
	}

	return CEdit::PreTranslateMessage(pMsg);
}

LRESULT CAvailClassEdit::UpdateAvailClass(WPARAM, LPARAM)
{
	if (!m_uiTimer == 0)
	{
		KillTimer( m_uiTimer );
		m_uiTimer = 0;
		CBrowseforInstances *pParent =
			reinterpret_cast<CBrowseforInstances *>
			(GetParent());
		pParent->PostMessage(UPDATESELECTEDCLASS,0,0);
	}

	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\cathelp.cpp ===
//=--------------------------------------------------------------------------=

// CatHelp.Cpp

//=--------------------------------------------------------------------------=

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "precomp.h"

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\browseforinstances.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_BROWSEFORINSTANCES_H__9F7CEA71_CAF9_11D0_963D_00C04FD9B15B__INCLUDED_)
#define AFX_BROWSEFORINSTANCES_H__9F7CEA71_CAF9_11D0_963D_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// BrowseforInstances.h : header file
//
class CAvailClasses;
class CResults;
class CNavigatorCtrl;

#define ID_SETTREEROOT WM_USER + 24

/////////////////////////////////////////////////////////////////////////////
// CBrowseforInstances dialog

class CBrowseforInstances : public CDialog
{
// Construction
public:
	CBrowseforInstances(CWnd* pParent = NULL);   // standard constructor
	void SetServices(IWbemServices *pServices)
		{m_pServices = pServices;}
	CSortedCStringArray &GetCurrentAvailClasses();
	CByteArray &GetCurrentNonInstClasses();
	BOOL HasNonInstClasses();
	void SetTMFont(TEXTMETRIC *ptmFont)
		{m_tmFont = *ptmFont;}
	void SetParent(CNavigatorCtrl *pParent)
	{m_pParent = pParent;}
	enum {TreeRoot, InitialObject};
	void SetMode(int nMode) {m_nMode = nMode;}
// Dialog Data
	//{{AFX_DATA(CBrowseforInstances)
	enum { IDD = IDD_DIALOGBROWSEFORINSTANCES };
	CStatic	m_cstaticBrowse;
	CButton	m_cbAssoc;
	CButton	m_cbRemove;
	CButton	m_cbAdd;
	CButton	m_cbOK;
	//}}AFX_DATA


	CAvailClassEdit		m_ceditClass;
	CAvailClasses		m_clbAllClasses;
	CSelectedClasses	m_clbSelClasses;

	void SetNewRoot(IWbemClassObject *pObject);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBrowseforInstances)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	IWbemServices *m_pServices;
	CNavigatorCtrl *m_pParent;
	void GetClassArray
		(CSortedCStringArray &rcsaOut, CString *pcsParent = NULL, BOOL bDeep = TRUE,
		BOOL bOnlyCanHaveInstances = TRUE, BOOL bSystemClasses = FALSE,
		BOOL bAssoc = FALSE);
	void OnOKReally();
	void OnCancelReally();
	void UpdateUI();
	BOOL m_bEscSeen;
	BOOL IsClassAvailable(CString &rcsClass);
	CSortedCStringArray m_csaAllClasses;
	CSortedCStringArray m_csaInstClasses;
	CSortedCStringArray m_csaAllPlusAssocClasses;
	CSortedCStringArray m_csaInstPlusAssocClasses;
	CStringArray m_csaSelectedClasses;
	CByteArray m_cbaAllClasses;
	CByteArray m_cbaAllPlusAssocClasses;
	BOOL m_bShowAll;
	BOOL m_bShowAssoc;
	TEXTMETRIC m_tmFont;
	CPictureHolder *m_pcphImage;
	int m_nBitmapH;
	int m_nBitmapW;

	int m_nMode;

	CString m_csSelectedInstancePath;
	void ClearSelectedSelection();
	void ClearAvailSelection();

	// Generated message map functions
	//{{AFX_MSG(CBrowseforInstances)
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioallclasses();
	afx_msg void OnRadioclassescanhaveinst();
	afx_msg void OnCheckassoc();
	afx_msg void OnChangeEDITClass();
	afx_msg void OnButtonadd();
	afx_msg void OnButtonremove();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	virtual void OnCancel();
	virtual void OnOK();
	afx_msg void OnPaint();
	afx_msg void OnDestroy();
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	afx_msg LRESULT UpdateAvailClass(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
	friend class CAvailClasses;
	friend class CAvailClassEdit;
	friend class CSelectedClasses;
	friend class CResults;
	friend class CNavigatorCtrl;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_BROWSEFORINSTANCES_H__9F7CEA71_CAF9_11D0_963D_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\banner.h ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: banner.h
//
// Description:
//	This file declares the CBanner class which is a part of the Class Explorer 
//	OCX.  CBanner is a subclass of the Microsoft CWnd class and performs 
//	the following functions:
//		a.  Contains static label, combo box and toolbar child contols
//			which allow the user to select a namespace and add and
//			delete classes
//		b.  Handles the creation of, geometry and destruction of the child
//			contols.
//
// Part of: 
//	ClassNav.ocx 
//
// Used by: 
//	CClassNavCtrl class	 
//
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

//****************************************************************************
//
// CLASS:  CBanner
//
// Description:
//	This class is a subclass of the Microsoft CWnd class. It is a window
//	container class for three child windows, two of which provide a 
//	significant part of the Class Explore's user interface.  It contains a
//	static label, a combo box which allows the user to select a namespace
//	and a toolbar for adding and deleting classes.
//
// Public members:
//	
//	CBanner 
//
//============================================================================
//	CBanner		Public constructor.
//
//============================================================================
//
//  CBanner::CBanner
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  CNavigatorCtrl* pParent		Parent.
//
// Returns:
// 	  NONE
//

//****************************************************************************

#ifndef _CBANNER_H_
#define _CBANNER_H_

class CNavigatorCtrl;
class CInstNavNSEntry;

class CBanner : public CWnd
{
// Construction
public:
	CBanner(CNavigatorCtrl* pParent = NULL);   // standard constructor
	~CBanner();
	CString GetNameSpace();
	void SetNameSpace(CString *pcsNamespace);
	SCODE OpenNamespace(CString *pcsNamespace, BOOL boolNoFireEvent);
	void EnableSearchButton(BOOL bEnable)
	{	m_cctbToolBar.EnableSearchButton(bEnable); }
protected:
	void SetParent(CNavigatorCtrl* pParent) 
		{	m_pParent = pParent;
		}

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBanner)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

	CNavigatorCtrl* m_pParent;
	BOOL m_bFontCreated;

	CInstNavNSEntry *m_pnseNameSpace;
	CContainedToolBar m_cctbToolBar;

	CString m_csBanner;
	int m_nOffset;
	int m_nFontHeight;

	CRect m_rFilter;
	CRect m_rNameSpace;
	CRect m_rNameSpaceRect;
	CRect m_rToolBar;
	int GetTextLength(CString *pcsText);
	void SetChildControlGeometry(int cx, int cy);
	void DrawFrame(CDC* pdc);

	void NSEntryRedrawn();

	friend class CNavigatorCtrl;
	friend class CInstNavNSEntry;

	//{{AFX_MSG(CBanner)
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnButtonfilter();
	afx_msg void OnBrowseforinst();
	afx_msg void OnUpdateBrowseforinst(CCmdUI* pCmdUI);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\browseforinstances.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// BrowseforInstances.cpp : implementation file
//

#include "precomp.h"
#include <OBJIDL.H>
#include "resource.h"
#include "wbemidl.h"
#include "navigator.h"
#include "CInstanceTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "InstanceSearch.h"
#include "AvailClasses.h"
#include "AvailClassEdit.h"
#include "SelectedClasses.h"
#include "SimpleSortedCStringArray.h"
#include "BrowseforInstances.h"
#include "NavigatorCtl.h"
#include "AvailClasses.h"
#include "AvailClassEdit.h"
#include "SelectedClasses.h"
#include "ResultsList.h"
#include "Results.h"
#include "OLEMSClient.h"
#include "logindlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBrowseforInstances dialog


CBrowseforInstances::CBrowseforInstances(CWnd* pParent /*=NULL*/)
	: CDialog(CBrowseforInstances::IDD, pParent)
{
	//{{AFX_DATA_INIT(CBrowseforInstances)
	//}}AFX_DATA_INIT
	m_bShowAll = TRUE;
	m_bShowAssoc = TRUE;

	CString csInit = _T(" UNINIT");
	m_csaAllClasses.AddString(csInit,FALSE);
	m_csaAllPlusAssocClasses.AddString(csInit,FALSE);
	m_csaInstClasses.AddString(csInit,FALSE);
	m_csaInstPlusAssocClasses.AddString(csInit,FALSE);

	m_cbaAllClasses.Add(0);
	m_cbaAllPlusAssocClasses.Add(0);

	m_pcphImage = NULL;
	m_bEscSeen = NULL;
}


void CBrowseforInstances::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBrowseforInstances)
	DDX_Control(pDX, IDC_STATICBROWSE, m_cstaticBrowse);
	DDX_Control(pDX, IDC_CHECKASSOC, m_cbAssoc);
	DDX_Control(pDX, IDC_BUTTONREMOVE, m_cbRemove);
	DDX_Control(pDX, IDC_BUTTONADD, m_cbAdd);
	DDX_Control(pDX, IDOK, m_cbOK);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBrowseforInstances, CDialog)
	//{{AFX_MSG_MAP(CBrowseforInstances)
	ON_BN_CLICKED(IDC_RADIOALLCLASSES, OnRadioallclasses)
	ON_BN_CLICKED(IDC_RADIOCLASSESCANHAVEINST, OnRadioclassescanhaveinst)
	ON_BN_CLICKED(IDC_CHECKASSOC, OnCheckassoc)
	ON_EN_CHANGE(IDC_EDITClass, OnChangeEDITClass)
	ON_BN_CLICKED(IDC_BUTTONADD, OnButtonadd)
	ON_BN_CLICKED(IDC_BUTTONREMOVE, OnButtonremove)
	ON_WM_CREATE()
	ON_WM_PAINT()
	ON_WM_DESTROY()
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
	ON_MESSAGE( UPDATESELECTEDCLASS,UpdateAvailClass)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBrowseforInstances message handlers

BOOL CBrowseforInstances::OnInitDialog()
{
	CDialog::OnInitDialog();

	CString csText;

	if (m_nMode == TreeRoot)
	{
		csText = _T("Browse for Instance");
		SetWindowText(csText);
	}
	else
	{
		csText = _T("Set Initial Tree Root");
		SetWindowText(csText);
	}

	m_clbAllClasses.SubclassDlgItem(IDC_LISTALLCLASSES, this);
	m_clbSelClasses.SubclassDlgItem(IDC_LISTSELCLASSES, this);
	m_ceditClass.SubclassDlgItem(IDC_EDITClass, this);

	CWaitCursor wait;
	// TODO: Add extra initialization here

	m_cbAssoc.SetCheck(0);

	CButton *pcbAllClasses =
		reinterpret_cast<CButton *>
		(GetDlgItem(IDC_RADIOALLCLASSES));
	pcbAllClasses->SetCheck(0);

	CButton *pcbCanHaveInst =
		reinterpret_cast<CButton *>
		(GetDlgItem(IDC_RADIOCLASSESCANHAVEINST));
	pcbCanHaveInst->SetCheck(1);

	m_bShowAll = FALSE;
	m_bShowAssoc = FALSE;

	UpdateUI();



	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CBrowseforInstances::UpdateUI()
{
	CSortedCStringArray &rcsaClasses = GetCurrentAvailClasses();

	GetClassArray
		(rcsaClasses,
		NULL,
		TRUE,
		m_bShowAll ? FALSE : TRUE,
		TRUE,
		m_bShowAssoc);

	int nItems = rcsaClasses.GetSize();

	m_clbAllClasses.ResetContent();
	m_clbAllClasses.InitStorage(nItems,30);

	for (int i = 1; i < nItems; i++)
	{
		int nPos = m_clbAllClasses.AddString(rcsaClasses.GetStringAt(i));

		BOOL bReturn = HasNonInstClasses();
		CByteArray &cbaNonInstClasses =
			GetCurrentNonInstClasses();



		BYTE byteFlag = FALSE;

		if (i < cbaNonInstClasses.GetSize())
		{
			byteFlag = cbaNonInstClasses.GetAt(i);
		}

		if (bReturn && byteFlag== 0)
		{
			m_clbAllClasses.SetItemData(nPos,1);

		}
		else
		{
			m_clbAllClasses.SetItemData(nPos,0);
		}

	}
	m_clbSelClasses.CheckClasses();

	// KMH 39060
	if(m_clbSelClasses.GetCount() == 0)
	{
		m_cbOK.EnableWindow(FALSE);
	}
	else
	{
		m_cbOK.EnableWindow(TRUE);
	}

}


void CBrowseforInstances::GetClassArray
(CSortedCStringArray &rcsaOut, CString *pcsParent,BOOL bDeep,
 BOOL bOnlyCanHaveInstances, BOOL bSystemClasses, BOOL bAssoc)
{
	SCODE sc;
	IEnumWbemClassObject *pIEnumWbemClassObject = NULL;
	IWbemClassObject *pIWbemClassObject = NULL;
	IWbemClassObject *pErrorObject = NULL;

	if (rcsaOut.GetStringAt(0).CompareNoCase(_T(" UNINIT")) == 0)
	{
		rcsaOut.SetAt(0,_T(" INIT"));
	}
	else
	{
		return;
	}

	long lFlag = bDeep ? WBEM_FLAG_DEEP | WBEM_FLAG_FORWARD_ONLY : WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY;

	if (pcsParent == NULL)
	{
		sc = m_pServices->CreateClassEnum
				(NULL, lFlag, NULL, &pIEnumWbemClassObject);
	}
	else
	{
		BSTR bstrTemp = pcsParent -> AllocSysString();
		sc = m_pServices->CreateClassEnum
				(bstrTemp, lFlag, NULL,
				&pIEnumWbemClassObject);
		::SysFreeString(bstrTemp);
	}

	if(sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get class enumeration ");
		csUserMsg += _T(" for class ");
		csUserMsg +=  pcsParent ? *pcsParent: L"";

		ErrorMsg
				(&csUserMsg, sc,pErrorObject, TRUE, &csUserMsg, __FILE__,
				__LINE__);

		ReleaseErrorObject(pErrorObject);

		return;
	}

	SetEnumInterfaceSecurity(m_pParent->m_csNameSpace,pIEnumWbemClassObject, m_pServices);

	sc = pIEnumWbemClassObject->Reset();

	ULONG uReturned;

    while (S_OK == pIEnumWbemClassObject->Next(INFINITE, 1, &pIWbemClassObject, &uReturned) )
		{
			CString csClass = GetIWbemClass (m_pServices,pIWbemClassObject);
			BOOL bTmp =
				!bOnlyCanHaveInstances ? ClassCanHaveInstances(pIWbemClassObject) : FALSE;
			if ((!bOnlyCanHaveInstances ||
				bOnlyCanHaveInstances  ==
				(bTmp = ClassCanHaveInstances(pIWbemClassObject))) &&
				(bSystemClasses ||
				bSystemClasses == IsSystemClass(pIWbemClassObject))  &&
				(bAssoc || bAssoc == IsAssoc(pIWbemClassObject)))
			{
				rcsaOut.AddString( csClass,FALSE);
				if (!bOnlyCanHaveInstances && !bAssoc)
				{
					if (bTmp)
					{
						m_cbaAllClasses.Add(1);
					}
					else
					{
						m_cbaAllClasses.Add(0);
					}
				}
				else if (!bOnlyCanHaveInstances && bAssoc)
				{
					if (bTmp)
					{
						m_cbaAllPlusAssocClasses.Add(1);
					}
					else
					{
						m_cbaAllPlusAssocClasses.Add(0);
					}
				}


			}

			pIWbemClassObject->Release();
			pIWbemClassObject = NULL;

		}

	pIEnumWbemClassObject -> Release();

	return;

}



void CBrowseforInstances::OnRadioallclasses()
{
	CWaitCursor wait;

	m_bShowAll = TRUE;

	UpdateUI();

}

void CBrowseforInstances::OnRadioclassescanhaveinst()
{
	CWaitCursor wait;

	m_bShowAll = FALSE;

	UpdateUI();

}

void CBrowseforInstances::OnCheckassoc()
{
	CWaitCursor wait;

	m_bShowAssoc = m_cbAssoc.GetCheck() ? TRUE: FALSE;

	UpdateUI();

}

void CBrowseforInstances::OnChangeEDITClass()
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CDialog::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.

	// TODO: Add your control notification handler code here

}

BOOL CBrowseforInstances::PreTranslateMessage(MSG* pMsg)
{
	// TODO: Add your specialized code here and/or call the base class

	switch (pMsg->message)
	{
	case WM_KEYUP:
      if (pMsg->wParam == VK_RETURN ||
		  pMsg->wParam == VK_ESCAPE)
      {
			TCHAR szClass[11];
			CWnd* pWndFocus = GetFocus();
			if (
				((pWndFocus = GetFocus()) != NULL) &&
				IsChild(pWndFocus) &&
				(pWndFocus->GetStyle() & ES_WANTRETURN) &&
				GetClassName(pWndFocus->m_hWnd, szClass, 10) &&
				(_tcsicmp(szClass, _T("EDIT")) == 0))
			{
				if (pMsg->wParam == VK_RETURN)
				{
					pWndFocus->SendMessage(WM_CHAR, pMsg->wParam, pMsg->lParam);
				}
				return TRUE;
			}
      }
	  if (pMsg->wParam == VK_MENU )
	  {
		//char c = (pMsg->lParam & 0x00FF0000) >> 16;
		//if (c == 'O' || c == 'o')
		//{
		//	return TRUE;
		//}
	  }
      break;
	}

	return CDialog::PreTranslateMessage(pMsg);
}

void CBrowseforInstances::OnButtonadd()
{
	CStringArray csaClasses;
	CByteArray cbaAbstractClasses;

	int nSel = m_clbAllClasses.GetSelCount();

	if (nSel == 0)
	{
		return;
	}
	else
	{
		int *piSel;
		piSel = new int[nSel];
		m_clbAllClasses.GetSelItems(nSel,piSel);
		CString csItem;
		for (int i =0; i < nSel; i++)
		{
			m_clbAllClasses.GetText(piSel[i],csItem);
			csaClasses.Add(csItem);
			// NOTE: The item data in the list box should only contain '0' or '1'
			BYTE nData = (BYTE) m_clbAllClasses.GetItemData(piSel[i]);
			cbaAbstractClasses.Add(nData);
		}
		delete [] piSel;
	}

	m_clbSelClasses.AddClasses
		(csaClasses,cbaAbstractClasses);

	// KMH 39060
	m_cbOK.EnableWindow(TRUE);

}

void CBrowseforInstances::OnButtonremove()
{
	// TODO: Add your control notification handler code here

	int nSel = m_clbSelClasses.GetSelCount();

	int *piSel;

	if (nSel == 0)
	{
		return;
	}
	else
	{
		piSel = new int[nSel];
		m_clbSelClasses.GetSelItems(nSel,piSel);
	}


	for (int i = nSel - 1; i >= 0; i--)
	{
		m_clbSelClasses.DeleteString(piSel[i]);
	}

	delete [] piSel;

	// KMH 39060
	if(m_clbSelClasses.GetCount() == 0)
	{
		m_cbOK.EnableWindow(FALSE);
	}
}

int CBrowseforInstances::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CDialog::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO: Add your specialized creation code here

	return 0;
}

void CBrowseforInstances::OnCancel()
{
	// TODO: Add extra cleanup here
	TCHAR szClass[10];
	CWnd* pWndFocus = GetFocus();
	if (((pWndFocus = GetFocus()) != NULL) &&
		IsChild(pWndFocus) &&
		GetClassName(pWndFocus->m_hWnd, szClass, 10) &&
		(_tcsicmp(szClass, _T("EDIT")) == 0))
	{
		//m_cmeiMachine.SendMessage(WM_CHAR,VK_RETURN,0);
		//return;
	}
	OnCancelReally();
}


void CBrowseforInstances::OnCancelReally()
{
	m_csaAllClasses.RemoveAll();
	m_csaAllPlusAssocClasses.RemoveAll();
	m_csaInstClasses.RemoveAll();
	m_csaInstPlusAssocClasses.RemoveAll();
	m_csaSelectedClasses.RemoveAll();

	m_cbaAllClasses.RemoveAll();
	m_cbaAllPlusAssocClasses.RemoveAll();

	m_cbaAllClasses.Add(0);
	m_cbaAllPlusAssocClasses.Add(0);

	CString csInit = _T(" UNINIT");

	m_csaAllClasses.AddString(csInit,FALSE);
	m_csaAllPlusAssocClasses.AddString(csInit,FALSE);
	m_csaInstClasses.AddString(csInit,FALSE);
	m_csaInstPlusAssocClasses.AddString(csInit,FALSE);

	delete m_pcphImage;
	m_pcphImage = NULL;

	CDialog::OnCancel();
}


void CBrowseforInstances::OnOK()
{
	// TODO: Add extra validation here
	TCHAR szClass[10];

	CWnd* pWndFocus = GetFocus();
	int nReturn = GetClassName(pWndFocus->m_hWnd, szClass, 10);
	if (((pWndFocus = GetFocus()) != NULL) &&
		IsChild(pWndFocus) &&
		(pWndFocus->GetStyle() & ES_WANTRETURN) &&
		nReturn &&
		(_tcsicmp(szClass, _T("EDIT")) == 0))
	{
		return;
	}
	else
		if (((pWndFocus = GetFocus()) != NULL) &&
				IsChild(pWndFocus) &&
				nReturn &&
				(_tcsicmp(szClass, _T("ListBox")) == 0))

	{
		if (pWndFocus->GetSafeHwnd() == m_clbAllClasses.GetSafeHwnd())
		{
			OnButtonadd();
		}
		return;

	}
	OnOKReally();

}

void CBrowseforInstances::OnOKReally()
{
	CWaitCursor wait;

	int nSel = m_clbSelClasses.GetCount();

	if (nSel == 0)
	{
		CString csUserMsg;
		csUserMsg =  _T("There are no classes selected to browse from. ");
		ErrorMsg
				(&csUserMsg, S_OK,NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__);
		return;
	}


	CResults crResults;


	crResults.SetMode(m_nMode);

	int i;

	for (i = 0; i < nSel; i++)
	{
		CString csItem;
		m_clbSelClasses.GetText(i,csItem);
		int nData = (int) m_clbSelClasses.GetItemData(i);
		if (nData == 1)
		{
			crResults.AddAbstractClass(csItem);
		}
		else
		{
			crResults.AddNonAbstractClass(csItem);
		}
	}

	crResults.SetServices(m_pServices);
	crResults.SetParent(this);
	int nRes = (int) crResults.DoModal();

	if (nRes == IDOK && m_nMode == TreeRoot)
	{
		CWaitCursor wait;
		CString csRootPath = m_csSelectedInstancePath;
		IWbemClassObject *pimcoRoot = NULL;

		pimcoRoot = GetIWbemObject
			(m_pParent,m_pServices,
			m_pParent->GetCurrentNamespace(),
			m_pParent->GetAuxNamespace(),
			m_pParent->GetAuxServices(),
			 csRootPath,TRUE);

		if (pimcoRoot)
		{
			CString csPath = GetIWbemFullPath(m_pServices,pimcoRoot);
			SetNewRoot(pimcoRoot);

		}

	}
	else if (nRes == IDOK && m_nMode != TreeRoot)
	{



	}
	else
	{
		m_csSelectedInstancePath.Empty();
	}
}


CSortedCStringArray &CBrowseforInstances::GetCurrentAvailClasses()
{
	return
		(m_bShowAll ? (m_bShowAssoc ? m_csaAllPlusAssocClasses : m_csaAllClasses) :
					(m_bShowAssoc ? m_csaInstPlusAssocClasses : m_csaInstClasses));


}

CByteArray &CBrowseforInstances::GetCurrentNonInstClasses()
{
	if (m_bShowAll && !m_bShowAssoc)
	{
		return m_cbaAllClasses;
	}
	else
	{
		return m_cbaAllPlusAssocClasses;
	}


}

BOOL CBrowseforInstances::HasNonInstClasses()
{
	return m_bShowAll ? TRUE : FALSE;

}

BOOL CBrowseforInstances::IsClassAvailable(CString &rcsClass)
{

	if (m_clbAllClasses.FindStringExact(-1, rcsClass) == LB_ERR)
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}

}

LRESULT CBrowseforInstances::UpdateAvailClass(WPARAM, LPARAM)
{
	CWaitCursor wait;

	CString csClass;
	m_ceditClass.GetWindowText(csClass);


	int nSel = m_clbAllClasses.GetSelCount();
	if (nSel > 0)
	{
		int *piSel;
		piSel = new int[nSel];
		m_clbAllClasses.GetSelItems(nSel,piSel);
		for (int i = 0; i < nSel;i++)
		{
			m_clbAllClasses.SetSel(piSel[i],FALSE);

		}
		delete [] piSel;
	}


	if (csClass.GetLength() > 0)
	{
		int nFound = m_clbAllClasses.FindString(-1,csClass);
		if (nFound != LB_ERR)
		{
			m_clbAllClasses.SetSel(nFound);

		}
	}
	else
	{
		m_clbAllClasses.SetSel(0);
	}

	return 0;
}

void CBrowseforInstances::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	if (!m_pcphImage)
	{
		HBITMAP hBitmap;
		HPALETTE hPalette;
		BITMAP bm;

		CString csRes;
		csRes.Format(_T("#%d"),IDB_BITMAPBANNER);
//		hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
//		(TCHAR *) csRes.GetBuffer(csRes.GetLength()),&hPalette);

		hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		(LPCTSTR)csRes ,&hPalette);


		GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
		m_nBitmapW = bm.bmWidth;
		m_nBitmapH  = bm.bmHeight;

		m_pcphImage = new CPictureHolder();
		m_pcphImage->CreateFromBitmap(hBitmap, hPalette );

	}

	CRect rcBannerExt;
	m_cstaticBrowse.GetWindowRect(&rcBannerExt);
	ScreenToClient(rcBannerExt);

	if(m_pcphImage->GetType() != PICTYPE_NONE &&
	   m_pcphImage->GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(m_pcphImage->m_pPict
		   && SUCCEEDED(m_pcphImage->m_pPict->get_hPal((unsigned int *)&hpal)))

		{

			HPALETTE hpSave = SelectPalette(dc.m_hDC,(HPALETTE)hpal,TRUE);

			dc.RealizePalette();

			dc.FillRect(&rcBannerExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			m_pcphImage->Render(&dc, rcBannerExt, rcBannerExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));


	CRect rcFrame(	rcBannerExt.TopLeft().x,
					rcBannerExt.TopLeft().y,
					rcBannerExt.BottomRight().x,
					rcBannerExt.BottomRight().y);
	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));


	CString csFont = _T("MS Shell Dlg");

	CString csOut;
	CRect crOut;

	if (m_nMode == TreeRoot)
	{
		csOut = _T("Browse Criteria");

		crOut = OutputTextString
			(&dc, this, &csOut, 15, 15, &csFont, 8, FW_BOLD);

		csOut = _T("You can browse among the objects in a number of classes to find one object.  ");

		csOut += _T("Select the classes whose objects you would like to browse, then click OK.");
	}
	else
	{
		csOut = _T("Browse Criteria");

		crOut = OutputTextString
			(&dc, this, &csOut, 15, 15, &csFont, 8, FW_BOLD);

		csOut = _T("You can browse among the objects in a number of classes to find one object.  ");

		csOut += _T("Select the classes whose objects you would like to browse, then click OK.");
	}

	CPoint cpRect(crOut.TopLeft().x + 15, crOut.BottomRight().y + 1);

	crOut.TopLeft().x = 0;
	crOut.TopLeft().y = 0;
	crOut.BottomRight().x = rcBannerExt.BottomRight().x - cpRect.x;
	crOut.BottomRight().y = rcBannerExt.BottomRight().y - cpRect.y;

	OutputTextString
		(&dc, this, &csOut, cpRect.x, cpRect.y, crOut, &csFont, 8, FW_NORMAL);

	// Do not call CDialog::OnPaint() for painting messages
}

void CBrowseforInstances::OnDestroy()
{


	CDialog::OnDestroy();



}


void CBrowseforInstances::SetNewRoot(IWbemClassObject *pObject)
{
	m_pParent->PostMessage(ID_SETTREEROOT,0,(LPARAM)pObject);
}

void CBrowseforInstances::ClearSelectedSelection()
{
	int nSel = m_clbSelClasses.GetSelCount();

	int *piSel;

	if (nSel == 0)
	{
		return;
	}
	else
	{
		piSel = new int[nSel];
		m_clbSelClasses.GetSelItems(nSel,piSel);
	}

	for (int i = nSel - 1; i >= 0; i--)
	{
		m_clbSelClasses.SetSel(piSel[i], FALSE);
	}

	delete [] piSel;

	// KMH 39060
//	m_cbOK.EnableWindow(FALSE);
}

void CBrowseforInstances::ClearAvailSelection()
{
	int nSel = m_clbAllClasses.GetSelCount();

	int *piSel;

	if (nSel == 0)
	{
		return;
	}
	else
	{
		piSel = new int[nSel];
		m_clbAllClasses.GetSelItems(nSel,piSel);
	}


	for (int i = nSel - 1; i >= 0; i--)
	{
		m_clbAllClasses.SetSel(piSel[i], FALSE);
	}

	delete [] piSel;

}

void CBrowseforInstances::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// TODO: Add your message handler code here and/or call default

	CDialog::OnChar(nChar, nRepCnt, nFlags);
}

BOOL CBrowseforInstances::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
	// TODO: Add your specialized code here and/or call the base class

	return CDialog::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\ccontainedbitmapbutton.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

class 	CNavigatorCtrl;

class CContainedBitmapButton : public CBitmapButton
{
public:
	CContainedBitmapButton(CNavigatorCtrl *pParent = NULL) 
		{m_pParent = pParent;}
	void SetParent(CNavigatorCtrl *pParent) {m_pParent = pParent;}
	
protected:
	void OnButtonClickedFilter();
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	CNavigatorCtrl *m_pParent;

    //{{AFX_MSG(CContainedBitmapButton)
	afx_msg void OnClicked();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

//	
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\ccontainedbitmapbutton.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// aButton.cpp

#include "precomp.h"
#include "afxpriv.h"
#include "AFXCONV.H"
#include "resource.h"
#include "hmmsvc.h"
#include "olemsclient.h"
#include "CContainedBitmapButton.h"
#include "ViewSelectDlg.h"
#include "CInstanceTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "InstanceSearch.h"
#include "NavigatorCtl.h"
#include "NavigatorCtl.h"

BEGIN_MESSAGE_MAP(CContainedBitmapButton,CBitmapButton)
	//{{AFX_MSG_MAP(CContainedBitmapButton)
	ON_CONTROL_REFLECT(BN_CLICKED, OnClicked)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CContainedBitmapButton::OnClicked - Handler for click event.

void CContainedBitmapButton::OnClicked()
{
	CString csLabel;
	GetWindowText(csLabel);
	if (csLabel == _T("Filter"))
	{
		OnButtonClickedFilter();
	}


}

/////////////////////////////////////////////////////////////////////////////
// CContainedBitmapButton::OnButtonClickedFilter - Handler for filter button click event.
// Displays filter dialog

void CContainedBitmapButton::OnButtonClickedFilter()
{





}

// Draw the appropriate bitmap
// Based on MFC implementation with changes from PSS ID
// Number Q134421
// In order for this to be invoked the resource id's of the
// bitmaps must be STRINGS!!!!!!!!!!!!!!!!!!!!!!
void CContainedBitmapButton::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{

	// use the main bitmap for up, the selected bitmap for down
	CBitmap* pBitmap = &m_bitmap;
	UINT state = lpDIS->itemState;
	if ((state & ODS_SELECTED) && m_bitmapSel.m_hObject != NULL)
		pBitmap = &m_bitmapSel;
#ifndef _MAC
	else if ((state & ODS_FOCUS) && m_bitmapFocus.m_hObject != NULL)
#else
	else if ((state & ODS_FOCUS) && m_bitmapFocus.m_hObject != NULL &&
			(GetParent()->GetStyle() & DS_WINDOWSUI))
#endif
		pBitmap = &m_bitmapFocus;   // third image for focused
	else if ((state & ODS_DISABLED) && m_bitmapDisabled.m_hObject != NULL)
		pBitmap = &m_bitmapDisabled;   // last image for disabled

	// draw the whole button
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	CDC memDC;
	memDC.CreateCompatibleDC(pDC);
	CBitmap* pOld = memDC.SelectObject(pBitmap);
	if (pOld == NULL)
		return;     // destructors will clean up

	CRect rect;
	rect.CopyRect(&lpDIS->rcItem);

	BITMAP bits;
    pBitmap->GetObject(sizeof(BITMAP),&bits);
    pDC->StretchBlt(rect.left,rect.top,rect.Width(),rect.Height(),
            &memDC,0,0,bits.bmWidth, bits.bmHeight, SRCCOPY);

	memDC.SelectObject(pOld);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\ccontainedtoolbar.h ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: CContainedToolBar.h
//
// Description:
//	This file declares the CContainedToolBar class which is a part of the Class 
//	Navigator OCX, it is a subclass of the Microsoft CToolBar 
//  control and performs the following functions:
//		a.  Provides a member function to calculate its size
//		b.  Provides a tooltip.
//
// Part of: 
//	Navigator.ocx 
//
// Used by: 
//	 CBanner
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

//****************************************************************************
//
// CLASS:  CContainedToolBar
//
// Description:
//	  This class is a subclass of the Microsoft CToolBar control.  It
//	  provides a member function to calculate its size and provides a tooltip.
//
// Public members:
//	
//	  CContainedToolBar	Public constructor.
//	  GetToolTip		Returns the tooltip control.
//	  SetParent			Sets the classes logicl parent.
//	  GetToolBarSize	Returns the size of the tool bar. 
//
//============================================================================
//
// CContainedToolBar::CContainedToolBar
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  NONE
//
//============================================================================
//
// CContainedToolBar::GetToolTip
//
// Description:
//	  This member function returns a reference to the tooltip control.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  CToolTipCtrl &	Reference to the tooltip control.
//
//============================================================================
//
// CContainedToolBar::SetParent
//
// Description:
//	  This member function sets the logical parent.
//
// Parameters:
//	  CNavigatorCtrl *pParent	Logical parent.
//
// Returns:
// 	  VOID
//
//============================================================================
//
// CContainedToolBar::GetToolBarSize
//
// Description:
//	  This member function returns the toolbar's size..
//
// Parameters:
//	  VOID
//
// Returns:
// 	  CSize						Toolbar size.
//
//****************************************************************************	 

#ifndef _CContainedToolBar_H_
#define _CContainedToolBar_H_
class 	CNavigatorCtrl;

class CContainedToolBar : public CToolBar
{
public:
	CContainedToolBar() {m_pParent = NULL;}
	void SetParent(CNavigatorCtrl *pParent) {m_pParent = pParent;}
	CSize GetToolBarSize();
	CToolTipCtrl &GetToolTip() {return m_ttip;}
	void EnableSearchButton(BOOL bEnable);
protected:
	CNavigatorCtrl *m_pParent;
	CToolTipCtrl m_ttip;
    //{{AFX_MSG(CContainedToolBar)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

	
}; 


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\cinstancetree.cpp ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: CInstanceTree.cpp
//
// Description:
//	This file implements the CInstanceTree class.
//	The CInstanceTree class is a part of the Instance Navigator OCX, it
//  is a subclass of the Mocrosoft CTreeCtrl common control and performs
//	the following functions:
//		a.
//		b.
//		c.
//
// Part of:
//	Navigator.ocx
//
// Used by:
//
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
// ***************************************************************************

// ===========================================================================
//
//	Includes
//
// ===========================================================================

#include "precomp.h"
#include <OBJIDL.H>
#include "afxpriv.h"
#include "wbemidl.h"
#include "resource.h"
#include "AFXCONV.H"
#include "SimpleSortedCStringArray.h"
#include "CInstanceTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "InstanceSearch.h"
#include "NavigatorCtl.h"
#include "ProgDlg.h"
#include "OLEMSCLient.h"
#include "resource.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#define KBSelectionTimer 1000
#define ExpansionOrSelectionTimer 1001
#define UPDATESELECTEDITEM WM_USER + 450

//#define SHOW_EMPTY_ASSOCS
//#define REFRESH_ON_EACH_EXPAND

void CALLBACK EXPORT  SelectItemAfterDelay
		(HWND hWnd,UINT nMsg,UINT_PTR nIDEvent, DWORD dwTime)
{
	::PostMessage(hWnd,UPDATESELECTEDITEM,0,0);

}

// Only has a valid value for the interval between a double click.
CInstanceTree *gpTreeTmp;

void CALLBACK EXPORT  ExpansionOrSelection
		(HWND hWnd,UINT nMsg,WPARAM nIDEvent, ULONG dwTime)
{

	CInstanceTree *pTree = gpTreeTmp;

	if (!pTree)
	{
		return;
	}

	if (pTree->m_uiSelectionTimer)
	{
		pTree->KillTimer(pTree->m_uiSelectionTimer );
		pTree-> m_uiSelectionTimer= 0;
	}

	if (InterlockedDecrement(&pTree->m_lSelection) == 0)
	{
		CPoint point(0,0);
		pTree->ContinueProcessSelection(TRUE,point );
		gpTreeTmp = NULL;
	}
}

BOOL FindInArrayNoCase(CStringArray *prgsz, CString *sz)
{
	for(int i=0;i<prgsz->GetSize();i++)
	{
		if(0 == sz->CompareNoCase((*prgsz)[i]))
			return i;
	}
	return -1;
}

void ClassDerivation (CStringArray *prgsz, IWbemClassObject *pObject)
{
	if(!prgsz)
	{
		ASSERT(FALSE);
		return;
	}
	SCODE sc;

    VARIANTARG var;
	VariantInit(&var);
	long lType;
	long lFlavor;

	CString csProp = _T("__derivation");

	BSTR bstrTemp = csProp.AllocSysString ( );
    sc = pObject->Get(bstrTemp ,0,&var,&lType,&lFlavor);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
		return;
	long ix[2] = {0,0};
	long lLower, lUpper;

	int iDim = SafeArrayGetDim(var.parray);
	sc = SafeArrayGetLBound(var.parray,1,&lLower);
	sc = SafeArrayGetUBound(var.parray,1,&lUpper);
	BSTR bstrClass;
	for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
	{
		sc = SafeArrayGetElement(var.parray,ix,&bstrClass);
		CString csTmp = bstrClass;
		prgsz->Add(csTmp);
		SysFreeString(bstrClass);

	}

	VariantClear(&var);
}


// ===========================================================================
//
//	Message Map
//
// ===========================================================================

BEGIN_MESSAGE_MAP(CInstanceTree,CTreeCtrl)
	ON_WM_CONTEXTMENU()
	//{{AFX_MSG_MAP(CInstanceTree)
	ON_WM_RBUTTONDOWN()
	ON_WM_CREATE()
	ON_WM_MOUSEMOVE()
	ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelchanged)
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	ON_WM_SIZE()
	ON_WM_DESTROY()
	ON_NOTIFY_REFLECT(TVN_SELCHANGING, OnSelchanging)
	ON_MESSAGE(INVALIDATE_CONTROL, SetUpInvalidate)
	ON_NOTIFY_REFLECT(TVN_KEYDOWN, OnKeydown)
	ON_WM_CONTEXTMENU()
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING,OnItemExpanding)
	ON_NOTIFY_REFLECT(TVN_ITEMEXPANDED,OnItemExpanded)
	ON_WM_LBUTTONUP()
	//}}AFX_MSG_MAP
	ON_MESSAGE( UPDATESELECTEDITEM,SelectTreeItem)
END_MESSAGE_MAP()

CTreeItemData::CTreeItemData
(	int nType,
	CString *pcsPath,
	CString *pcsMyRole
)
:	m_nType (nType)
{
	if (pcsMyRole)
	{
		m_csMyRole = *pcsMyRole;
	}

	if (pcsPath)
	{
		m_csaStrings.Add(*pcsPath);
	}
}

CString CTreeItemData::GetAt(int nItem)
{
	return m_csaStrings.GetAt(nItem);
}


CInstanceTree::CInstanceTree()
{

	gpTreeTmp;
	m_uiTimer = 0;
	m_bMouseDown = FALSE;
	m_bKeyDown = FALSE;
	m_pParent = NULL;
	m_bUseItem = FALSE;
	m_hItemToUse = NULL;
}
// ***************************************************************************
//
// CInstanceTree::PreCreateWindow
//
//	Description:
//		This VIRTUAL member function returns Initializes create struct values
//		for the custom tree control.
//
//	Parameters:
//		CREATESTRUCT& cs	A reference to a CREATESTRUCT with default control
//							creation values.
//
//	Returns:
// 		BOOL				Nonzero if the window creation should continue;
//							0 to indicate creation failure.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
BOOL CInstanceTree::PreCreateWindow(CREATESTRUCT& cs)
{
	if (!CTreeCtrl::PreCreateWindow(cs))
		return FALSE;

	cs.style =	WS_CHILD | WS_VISIBLE | CS_DBLCLKS | TVS_LINESATROOT |
				TVS_HASLINES | TVS_HASBUTTONS | TVS_SHOWSELALWAYS ;

	cs.style &= ~TVS_EDITLABELS;
	cs.style &= ~WS_BORDER;

	return TRUE;
}

//============================================================================
//
//  CInstanceTree::InitTreeState
//
//	Description:
//		This function initializes processing state for the custom tree control.
//
//	Parameters:
//		CNavigatorCtrl *pParent	A CNavigatorCtrl pointer to the tree controls
//								parent window.
//
//	Returns:
//		VOID				.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//============================================================================
void CInstanceTree::InitTreeState
(CNavigatorCtrl *pParent)
{
	m_pParent = pParent;
	m_bReCacheTools = TRUE;

	if (m_uiTimer)
	{
		KillTimer( m_uiTimer );
		m_uiTimer = 0;
	}

	if (m_uiSelectionTimer)
	{
		KillTimer(m_uiSelectionTimer );
		m_uiSelectionTimer = 0;
	}

	m_bMouseDown = FALSE;
	m_bKeyDown = FALSE;
	m_bUseItem = FALSE;
	m_hItemToUse = NULL;

}

//============================================================================
//
//  CInstanceTree::AddInitialObjectInstToTree
//
//	Description:
//		This function initializes processing state for the custom tree control.
//
//	Parameters:
//		IWbemClassObject *pimcoObjectInst	Root Wbem object
//
//	Returns:
//		HTREEITEM							Tree item handle.				.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//============================================================================
HTREEITEM CInstanceTree::AddInitialObjectInstToTree
(CString &csPath, BOOL bSendEvent)
{

	CString csLabel =
		GetDisplayLabel
		(csPath,&m_pParent->m_csNameSpace);
	TCHAR * pszLabel =
			const_cast <TCHAR *> ((LPCTSTR) csLabel);

	CTreeItemData *pctidNew =
		new CTreeItemData(CTreeItemData::ObjectInst ,&csPath);

	BOOL bChildren = TRUE;

	HTREEITEM hNew = InsertTreeItem
		(NULL,
		(LPARAM) pctidNew,
		m_pParent -> IconInstance(),
		m_pParent -> IconInstance() ,
		pszLabel ,
		bChildren,
		FALSE);

	SelectItem(hNew);

	if (bSendEvent  && 	m_pParent -> m_bReadySignal)
	{
		m_pParent -> FireViewObject((LPCTSTR)csPath);
	}

	return hNew;
}

//============================================================================
//
//  CInstanceTree::AddObjectInstToTree
//
//	Description:
//		This function adds a Wbem non-association object instance to the tree.
//
//	Parameters:
//	  HTREEITEM hParent					Handle to parent or NULL.
//	  CString &rcsObjectInst			Wbem object path of object to add.
//
//	Returns:
//		HTREEITEM						New tree item handle.				.
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
//============================================================================
HTREEITEM CInstanceTree::AddObjectInstToTree
(HTREEITEM hParent, CString &rcsObjectInst)
{
	HTREEITEM hAbove = IsIWbemObjectInTreeAbove
						(hParent ,
						rcsObjectInst,
						CTreeItemData::ObjectInst);

	// If this object is in the tree branch it is being inserted in it
	// cannot be expanded any farther.
	// ===============================================================
	if (hAbove)
	{
		CString csLabel =
		GetDisplayLabel
		(rcsObjectInst,&m_pParent->m_csNameSpace);
		TCHAR * pszLabel = const_cast <TCHAR *> ((LPCTSTR) csLabel);

		CTreeItemData *pctidNew = new CTreeItemData
			(CTreeItemData::ObjectInst ,&rcsObjectInst);

		int nImageIndex = m_pParent -> IconNEInstance();
		if (IsClass(rcsObjectInst))
		{
			nImageIndex = m_pParent -> IconClass();
		}


		HTREEITEM hNew = InsertTreeItem
							(hParent, (LPARAM) pctidNew,
							nImageIndex,
							nImageIndex ,
							pszLabel ,
							FALSE,
							FALSE);
		return hNew;
	}

	// Create tree item label and insert into the tree.
	// ================================================
	CString csLabel = GetDisplayLabel
		(rcsObjectInst,&m_pParent->m_csNameSpace);
	TCHAR * pszLabel = const_cast <TCHAR *> ((LPCTSTR) csLabel);

	CTreeItemData *pctidNew = new CTreeItemData
								(CTreeItemData::ObjectInst ,&rcsObjectInst);

	BOOL bChildren = TRUE;

	int nImageIndex = m_pParent -> IconInstance();

	if (IsClass(rcsObjectInst))
	{
		nImageIndex = m_pParent -> IconClass();
	}

	HTREEITEM hNew = InsertTreeItem
						(hParent,
						(LPARAM) pctidNew,
						nImageIndex,
						nImageIndex,
						pszLabel ,
						bChildren,
						FALSE);

	return hNew;
}

HTREEITEM CInstanceTree::AddAssocRoleToTree
(HTREEITEM hParent, CString &rcsAssocRole, CString &rcsRole ,
 CString &rcsMyRole, CStringArray *pcsaAssocRoles, int nWeak)
{
	ASSERT(nWeak >= 0);

	// For now, limit nWeak to 0,1,2
	if(nWeak>2)
		nWeak = 2;
#ifndef SHOW_EMPTY_ASSOCS
	// For now, show all assocs as the same
	nWeak = 0;
#endif

	CString szWeak;
	szWeak.Format(_T("%04i"), nWeak);

	CString csLabel = szWeak + GetIWbemClass(rcsAssocRole);
	csLabel += _T(".");
	csLabel += rcsRole;


	TCHAR * pszLabel = const_cast <TCHAR *> ((LPCTSTR) csLabel);



	CTreeItemData *pctidNew = new CTreeItemData
								(	CTreeItemData::AssocRole,
									&rcsAssocRole,
									&rcsMyRole);


	for(int i = 0; i < pcsaAssocRoles->GetSize();i++)
	{
		pctidNew->Add(pcsaAssocRoles->GetAt(i));
	}

	CTreeItemData *pctidObject =
		reinterpret_cast<CTreeItemData *>(GetItemData(hParent));

	BOOL bChildren = TRUE;

	int nIcon = m_pParent->IconAssocRole();
	switch(nWeak)
	{
	case 0: nIcon = m_pParent->IconAssocRole();break;
	case 1: nIcon = m_pParent->IconAssocRoleWeak();break;
	case 2: nIcon = m_pParent->IconAssocRoleWeak2();break;
	default: nIcon = m_pParent->IconAssocRoleWeak2();break;
	}
	return InsertTreeItem
		(	hParent,
			reinterpret_cast<LPARAM> (pctidNew),
			nIcon,
			bChildren ? m_pParent -> IconEAssocRole():
							m_pParent -> IconAssocRole(),
			pszLabel,
			bChildren,
			FALSE);
}

HTREEITEM CInstanceTree::AddObjectGroupToTree
(HTREEITEM hParent, CString &csObjectGroup, CStringArray &csaInstances)
{
	if (ObjectGroupIsInTree(hParent, csObjectGroup))
	{
		return NULL;
	}

	TCHAR * pszLabel = const_cast <TCHAR *> ((LPCTSTR) csObjectGroup);

	CTreeItemData *pctidNew = new CTreeItemData
								(	CTreeItemData::ObjectGroup,
									&csObjectGroup);

	for (int i = 0; i < csaInstances.GetSize(); i++)
	{
		pctidNew->Add(csaInstances.GetAt(i));
	}

	return InsertTreeItem
		(	hParent,
			reinterpret_cast<LPARAM> (pctidNew),
			m_pParent -> IconGroup(),
			m_pParent -> IconEGroup(),
			pszLabel,
			TRUE,
			FALSE);
}

BOOL CInstanceTree::ObjectGroupIsInTree
(HTREEITEM hParent, CString &csObjectGroup)
{
	HTREEITEM hChild = GetChildItem(hParent);

	while(hChild)
	{
		CTreeItemData *pctidChild =
			reinterpret_cast<CTreeItemData *>
			(GetItemData(hChild));
		if (pctidChild->m_nType == CTreeItemData::ObjectGroup
			&&
			pctidChild->GetAt(0).CompareNoCase(csObjectGroup) == 0)
		{
			return TRUE;
		}
		hChild = GetNextSiblingItem(hChild);

	}
	return FALSE;
}

void CInstanceTree::AddObjectGroupInstancesToTree
(HTREEITEM hParent, CString &csObjectGroup, CStringArray &csaInstances)
{
	HTREEITEM hChild = GetChildItem(hParent);
	BOOL bFound = FALSE;

	while(!bFound && hChild)
	{
		CTreeItemData *pctidChild =
			reinterpret_cast<CTreeItemData *>
			(GetItemData(hChild));
		if (pctidChild->m_nType == CTreeItemData::ObjectGroup
			&&
			pctidChild->GetAt(0).CompareNoCase(csObjectGroup) == 0)
		{
			bFound = TRUE;
			for (int i = 0; i < csaInstances.GetSize(); i++)
			{
				pctidChild->Add(csaInstances.GetAt(i));
			}
		}
		hChild = GetNextSiblingItem(hChild);

	}

}


//***************************************************************************
//
// CInstanceTree::OnItemExpanding
//
// Purpose:
//
//***************************************************************************
void CInstanceTree::OnItemExpanding
(NMHDR *pNMHDR, LRESULT *pResult)
{
//	InterlockedDecrement(&m_lSelection);
#ifdef _DEBUG
	afxDump << "CInstanceTree::OnItemExpanding\n";
#endif
	NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pNMHDR;
	CTreeItemData *pctidData = reinterpret_cast<CTreeItemData *>(pnmtv->itemNew.lParam);

	if((CTreeItemData::ObjectInst != pctidData->m_nType) && (pnmtv -> itemNew.state & TVIS_EXPANDEDONCE))
	{
		*pResult = 0;
		return;
	}

	if ((pnmtv ->action == TVE_COLLAPSE) /*||
		(pnmtv -> itemNew.state & TVIS_EXPANDEDONCE)*/)
	{
		*pResult = 0;
		return;
	}

#ifndef REFRESH_ON_EACH_EXPAND
	if(pnmtv -> itemNew.state & TVIS_EXPANDEDONCE)
	{
		*pResult = 0;
		return;
	}
#endif

	CWaitCursor wait;

	HTREEITEM hItem = pnmtv->itemNew.hItem;

	if(pnmtv -> itemNew.state & TVIS_EXPANDEDONCE)
	{
		HTREEITEM hFirst = GetChildItem(hItem);
		while(hFirst)
		{
			HTREEITEM hOld = hFirst;
			hFirst = GetNextSiblingItem(hFirst);
			DeleteItem(hOld);
		}
	}


#ifdef SHOW_EMPTY_ASSOCS
	BOOL bStars = FALSE;
	CStringArray rgsz;
#endif
	switch (pctidData -> m_nType)
	{
	case CTreeItemData::ObjectInst:
		{
#ifdef SHOW_EMPTY_ASSOCS
			if(GetParentItem(hItem) != NULL/*(GetKeyState(VK_CAPITAL) & 0x0001)*/)
			{
				bStars = TRUE;
				OnObjectInstExpanding(hItem, pctidData);
				HTREEITEM hFirst = GetChildItem(hItem);
				while(hFirst)
				{
					CString sz = GetItemText(hFirst);
					rgsz.Add(sz.Right(sz.GetLength() - 4));
					HTREEITEM hOld = hFirst;
					hFirst = GetNextSiblingItem(hFirst);
					DeleteItem(hOld);
				}
				OnObjectInstExpanding2(hItem, pctidData);

				break;
			}

#endif
			BOOL bReturn;
			if(GetParentItem(hItem) != NULL)
				bReturn = OnObjectInstExpanding(hItem, pctidData);
			else
				bReturn = OnObjectInstExpanding2(hItem, pctidData);
			if(!bReturn)
			{
				*pResult = 1;
				return;
			}
		}
		break;
	case CTreeItemData::ObjectGroup:
		OnObjectGroupExpanding(hItem, pctidData);
		break;
	case CTreeItemData::AssocRole:
		OnAssocRoleExpanding(hItem, pctidData);
		break;
	default:
		break;
	}

	SortChildren(hItem);
	if(CTreeItemData::ObjectInst == pctidData->m_nType)
	{
		HTREEITEM hFirst = GetChildItem(hItem);
		while(hFirst)
		{
			CString sz = GetItemText(hFirst);
			SetItemText(hFirst, sz.Right(sz.GetLength()-4));
			hFirst = GetNextSiblingItem(hFirst);
		}
#ifdef SHOW_EMPTY_ASSOCS
		if(bStars)
		{
			hFirst = GetChildItem(hItem);
			CStringArray rgsz2;
			while(hFirst)
			{
				CString sz = GetItemText(hFirst);
				rgsz2.Add(sz);
				if(FindInArrayNoCase(&rgsz, &sz) >= 0)
					SetItemState(hFirst, TVIS_BOLD, TVIS_BOLD);
				hFirst = GetNextSiblingItem(hFirst);
			}
			for(int xxx=0;xxx<rgsz.GetSize();xxx++)
			{
				if(FindInArrayNoCase(&rgsz2, &rgsz[xxx]) < 0)
				{
					CString sz = rgsz[xxx];
					// YIKES - This string was returned the OLD way, but not the NEW way
					ASSERT(FALSE);
				}
			}
		}
#endif

	}
	*pResult = 0;

	m_pParent-> PostMessage(SETFOCUS,0,0);SetFocus();

}

BOOL CInstanceTree::OnObjectInstExpanding
(HTREEITEM hItem, CTreeItemData *pctidData)
{
	IEnumWbemClassObject *pEnum =
		GetAssocClassesEnum
		(m_pParent -> GetServices(),
		pctidData -> GetAt(0),
		m_pParent->m_csNameSpace,
		m_pParent->m_csAuxNameSpace,
		m_pParent->m_pAuxServices,
		m_pParent);

	if (!pEnum)
	{
		return FALSE;
	}


	BOOL bCancel = FALSE;

	CString csPath = pctidData -> GetAt(0);
	CString csMessage =
		GetIWbemRelPath(&csPath);

	m_pParent->SetProgressDlgMessage(csMessage);

	CString csLabel = _T("Expanding object instance:");
	m_pParent->SetProgressDlgLabel(csLabel);

	if (!m_pParent->m_pProgressDlg->GetSafeHwnd())
	{
		m_pParent->CreateProgressDlgWindow();

	}

	CString  csParentAssoc;
	HTREEITEM hParent;

	csParentAssoc  = GetParentAssocFromTree(hItem,hParent);
	CTreeItemData *pctidAssoc =
		hParent?
		reinterpret_cast<CTreeItemData *>(GetItemData(hParent)) : NULL;

	CString csAssocRoleToFilter;
	CString csAssocToFilter;

	if (hParent)
	{
		csAssocToFilter = GetItemText(hParent);
		int nRoleBegin = csAssocToFilter.Find('.');
		csAssocToFilter = csAssocToFilter.Left(nRoleBegin);
		csAssocRoleToFilter = pctidAssoc->m_csMyRole;
	}


	HTREEITEM hObjectToFilter = hParent? GetParentItem(hParent) : NULL;

	CTreeItemData *pctidObjectToFilter =
		hObjectToFilter ?
		(reinterpret_cast<CTreeItemData *>
			(GetItemData(hObjectToFilter))) :
		NULL;
	CString csObjectToFilter
		= pctidObjectToFilter ? pctidObjectToFilter->GetAt(0) : _T("");


	bCancel = m_pParent->CheckCancelButtonProgressDlgWindow();


	if (bCancel)
	{
		pEnum->Release();
		m_pParent->DestroyProgressDlgWindow();
		return FALSE;
	}

	pEnum->Reset();

	CPtrArray csaAssocRoles;

	HRESULT hResult = S_OK;

	int nRes = 10;

	CStringArray *pcsaAssocClasses =
		GetAssocClasses
		(m_pParent -> GetServices(),
		pEnum,
		&csaAssocRoles, hResult, nRes);



	while (	pcsaAssocClasses &&
			!bCancel &&
			(hResult == S_OK ||
			hResult == WBEM_S_TIMEDOUT ||
			pcsaAssocClasses->GetSize() > 0))

	{
		/*if (!m_pParent->m_pProgressDlg->GetSafeHwnd())
		{
			m_pParent->CreateProgressDlgWindow();

		}*/
		bCancel = m_pParent->CheckCancelButtonProgressDlgWindow();

		if (bCancel)
		{
			CWaitCursor wait;
			UnCacheTools();
			m_bReCacheTools = TRUE;

			Expand(hItem,TVE_COLLAPSE);

			if (ItemHasChildren (hItem))
			{
				HTREEITEM hChild = GetChildItem(hItem);
				while (hChild)
				{
					DeleteTreeItemData(hChild);
					HTREEITEM hChildNext = GetNextSiblingItem(hChild);
					DeleteItem( hChild);
					hChild = hChildNext;
				}

			}

			TV_INSERTSTRUCT tvstruct;

			tvstruct.item.hItem = hItem;
			tvstruct.item.mask = TVIF_CHILDREN;
			tvstruct.item.cChildren = 1;
			SetItem(&tvstruct.item);

			UINT nStateMask = TVIS_EXPANDEDONCE;
			UINT uState =
				GetItemState( hItem, nStateMask );

			uState = 0;

			SetItemState(hItem, uState, TVIS_EXPANDEDONCE);

			m_pParent->InvalidateControl();

			m_pParent->DestroyProgressDlgWindow();

			pEnum->Release();
			delete pcsaAssocClasses;
			pcsaAssocClasses = NULL;
			return TRUE;

		}

		m_pParent->PumpMessagesProgressDlgWindow();

		int nSize = (int) pcsaAssocClasses -> GetSize();
		CStringArray *pcsaObjectClasses = NULL;
		CString csAssoc;

		for (int i = 0; i < nSize; i++)
		{
#ifdef _DEBUG
//	afxDump << _T("************* OnObjectInstExpanding *****************\n*********");
//	afxDump << _T("GetAssocClassesEnum nSize = " ) << nSize << _T("\n");
#endif
			csAssoc = pcsaAssocClasses -> GetAt(i);
			CString csAssocClass = GetIWbemClass(csAssoc);
			CStringArray *pcsaRoles =
							reinterpret_cast<CStringArray *>
							(csaAssocRoles.GetAt(i));

			for (int n = 0; n < pcsaRoles->GetSize(); n+=2)
			{
				m_pParent->PumpMessagesProgressDlgWindow();
				CString csMyRole = pcsaRoles -> GetAt(n);
				CString csNotMyRole = pcsaRoles->GetAt(n + 1);
				BOOL bBackassoc = FALSE;
				if (hParent) {
					if (csNotMyRole.CompareNoCase(csAssocRoleToFilter) == 0) {
						CString sPathTemp = pctidData->GetAt(0);
						bBackassoc = IsBackwardAssoc(
							csObjectToFilter,
							csAssocToFilter,
							csAssocRoleToFilter,
							csAssoc,
							sPathTemp,
							csMyRole);
					}
				}
				if (!bBackassoc)
				{
					AddAssocRoleToTree
							(hItem,csAssoc,csNotMyRole,csMyRole,pcsaRoles, 0);
				}

			}

			delete pcsaRoles;

		}

		m_pParent->PumpMessagesProgressDlgWindow();
		csaAssocRoles.RemoveAll();
		delete pcsaAssocClasses;
		pcsaAssocClasses = NULL;

		IWbemClassObject *pimcoAdd = NULL;

		pcsaAssocClasses =
		GetAssocClasses
		(m_pParent -> GetServices(),
		pEnum,
		&csaAssocRoles, hResult, nRes);

	}

	m_pParent->DestroyProgressDlgWindow();

	pEnum->Release();
	delete pcsaAssocClasses;

	if (ItemHasChildren (hItem))
	{
		if (!GetChildItem(hItem))
		{

			TV_INSERTSTRUCT		tvstruct;
			tvstruct.item.hItem = hItem;
			tvstruct.item.mask = TVIF_CHILDREN;
			tvstruct.item.cChildren = 0;
			SetItem(&tvstruct.item);
		}
	}

	return TRUE;
}

BOOL CInstanceTree::OnObjectInstExpanding2
(HTREEITEM hItem, CTreeItemData *pctidData)
{

	CString szClassBase = GetIWbemClass(pctidData->GetAt(0));
	CStringArray rgszDerivation;
	CStringArray rgszExistingAssocs;
	rgszDerivation.Add(szClassBase);
	GetDerivation(&rgszDerivation, m_pParent->GetServices(), pctidData->GetAt(0), szClassBase, m_pParent->m_csNameSpace, m_pParent->m_csAuxNameSpace, m_pParent->m_pAuxServices, m_pParent);
	for(int xxx=0;xxx<rgszDerivation.GetSize();xxx++)
	{
		CString szClass = rgszDerivation[xxx];

		IEnumWbemClassObject *pEnum =
			GetAssocClassesEnum2
			(m_pParent -> GetServices(),
			pctidData -> GetAt(0),
			szClass,
			m_pParent->m_csNameSpace,
			m_pParent->m_csAuxNameSpace,
			m_pParent->m_pAuxServices,
			m_pParent);

		if (!pEnum)
		{
			return FALSE;
		}


		BOOL bCancel = FALSE;

		CString csPath = pctidData -> GetAt(0);
		CString csMessage =
			GetIWbemRelPath(&csPath);

		m_pParent->SetProgressDlgMessage(csMessage);

		CString csLabel = _T("Expanding object instance:");
		m_pParent->SetProgressDlgLabel(csLabel);

		if (!m_pParent->m_pProgressDlg->GetSafeHwnd())
		{
//			m_pParent->CreateProgressDlgWindow();

		}

		CString  csParentAssoc;
		HTREEITEM hParent;

		csParentAssoc  = GetParentAssocFromTree(hItem,hParent);
		CTreeItemData *pctidAssoc =
			hParent?
			reinterpret_cast<CTreeItemData *>(GetItemData(hParent)) : NULL;

		CString csAssocRoleToFilter;
		CString csAssocToFilter;

		if (hParent)
		{
			csAssocToFilter = GetItemText(hParent);
			int nRoleBegin = csAssocToFilter.Find('.');
			csAssocToFilter = csAssocToFilter.Left(nRoleBegin);
			csAssocRoleToFilter = pctidAssoc->m_csMyRole;
		}


		HTREEITEM hObjectToFilter = hParent? GetParentItem(hParent) : NULL;

		CTreeItemData *pctidObjectToFilter =
			hObjectToFilter ?
			(reinterpret_cast<CTreeItemData *>
				(GetItemData(hObjectToFilter))) :
			NULL;
		CString csObjectToFilter
			= pctidObjectToFilter ? pctidObjectToFilter->GetAt(0) : _T("");


		bCancel = m_pParent->CheckCancelButtonProgressDlgWindow();


		if (bCancel)
		{
			pEnum->Release();
//			m_pParent->DestroyProgressDlgWindow();
			return FALSE;
		}

		pEnum->Reset();

		CPtrArray csaAssocRoles;

		HRESULT hResult = S_OK;

		int nRes = 10;

		CStringArray *pcsaAssocClasses =
			GetAssocClasses2
			(m_pParent -> GetServices(),
			pEnum,
			&csaAssocRoles, hResult, nRes, &rgszDerivation);



		while (	pcsaAssocClasses &&
				!bCancel &&
				(hResult == S_OK ||
				hResult == WBEM_S_TIMEDOUT ||
				pcsaAssocClasses->GetSize() > 0))

		{
			/*if (!m_pParent->m_pProgressDlg->GetSafeHwnd())
			{
				m_pParent->CreateProgressDlgWindow();

			}*/
//			bCancel = m_pParent->CheckCancelButtonProgressDlgWindow();

			if (bCancel)
			{
				CWaitCursor wait;
				UnCacheTools();
				m_bReCacheTools = TRUE;

				Expand(hItem,TVE_COLLAPSE);

				if (ItemHasChildren (hItem))
				{
					HTREEITEM hChild = GetChildItem(hItem);
					while (hChild)
					{
						DeleteTreeItemData(hChild);
						HTREEITEM hChildNext = GetNextSiblingItem(hChild);
						DeleteItem( hChild);
						hChild = hChildNext;
					}

				}

				TV_INSERTSTRUCT tvstruct;

				tvstruct.item.hItem = hItem;
				tvstruct.item.mask = TVIF_CHILDREN;
				tvstruct.item.cChildren = 1;
				SetItem(&tvstruct.item);

				UINT nStateMask = TVIS_EXPANDEDONCE;
				UINT uState =
					GetItemState( hItem, nStateMask );

				uState = 0;

				SetItemState(hItem, uState, TVIS_EXPANDEDONCE);

				m_pParent->InvalidateControl();

//				m_pParent->DestroyProgressDlgWindow();

				pEnum->Release();
				delete pcsaAssocClasses;
				pcsaAssocClasses = NULL;
				return TRUE;

			}

//			m_pParent->PumpMessagesProgressDlgWindow();

			int nSize = (int) pcsaAssocClasses -> GetSize();
			CStringArray *pcsaObjectClasses = NULL;
			CString csAssoc;

			for (int i = 0; i < nSize; i++)
			{
				csAssoc = pcsaAssocClasses -> GetAt(i);

				CString csAssocClass = GetIWbemClass(csAssoc);
				CStringArray *pcsaRoles =
								reinterpret_cast<CStringArray *>
								(csaAssocRoles.GetAt(i));

				if(FindInArrayNoCase(&rgszExistingAssocs, &csAssoc) >= 0)
				{
					delete pcsaRoles;
					continue;
				}
				rgszExistingAssocs.Add(csAssoc);

				for (int n = 0; n < pcsaRoles->GetSize(); n+=3)
				{
//					m_pParent->PumpMessagesProgressDlgWindow();
					CString csMyRole = pcsaRoles -> GetAt(n);
					CString csNotMyRole = pcsaRoles->GetAt(n + 1);
					CString szDepth = pcsaRoles->GetAt(n + 2);
					int nDepth = _ttoi(szDepth);
					BOOL bBackassoc = FALSE;
					if (hParent) {
						if (csNotMyRole.CompareNoCase(csAssocRoleToFilter) == 0) {
							CString sPathTemp = pctidData->GetAt(0);
							bBackassoc = IsBackwardAssoc(
								csObjectToFilter,
								csAssocToFilter,
								csAssocRoleToFilter,
								csAssoc,
								sPathTemp,
								csMyRole);
						}
					}
					if (!bBackassoc)
					{
						AddAssocRoleToTree
								(hItem,csAssoc,csNotMyRole,csMyRole,pcsaRoles, nDepth);
					}

				}

				delete pcsaRoles;

			}

			m_pParent->PumpMessagesProgressDlgWindow();
			csaAssocRoles.RemoveAll();
			delete pcsaAssocClasses;
			pcsaAssocClasses = NULL;

			IWbemClassObject *pimcoAdd = NULL;

			pcsaAssocClasses =
			GetAssocClasses2
			(m_pParent -> GetServices(),
			pEnum,
			&csaAssocRoles, hResult, nRes, &rgszDerivation);

		}

//		m_pParent->DestroyProgressDlgWindow();

		pEnum->Release();
		delete pcsaAssocClasses;
	}

	if (ItemHasChildren (hItem))
	{
		if (!GetChildItem(hItem))
		{

			TV_INSERTSTRUCT		tvstruct;
			tvstruct.item.hItem = hItem;
			tvstruct.item.mask = TVIF_CHILDREN;
			tvstruct.item.cChildren = 0;
			SetItem(&tvstruct.item);
		}
	}

	return TRUE;
}

IEnumWbemClassObject *CInstanceTree::GetAssocClassesEnum
(IWbemServices * pProv, CString &rcsInst,
 CString csCurrentNameSpace, CString &rcsAuxNameSpace, IWbemServices *&rpAuxServices,
 CNavigatorCtrl *pControl)
{
	CString csReqAttrib = _T("Association");
	CString csQuery =
		BuildOBJDBGetRefQuery
			(pProv, &rcsInst, NULL, NULL, &csReqAttrib, TRUE);

	BOOL bDiffNS = ObjectInDifferentNamespace(&csCurrentNameSpace,&rcsInst);

	if (bDiffNS && ObjectInDifferentNamespace(&rcsAuxNameSpace,&rcsInst))
	{
		CString csNamespace = GetObjectNamespace(&rcsInst);
		if (csNamespace.GetLength() > 0)
		{
			IWbemServices * pServices =
				pControl->InitServices(&csNamespace);
			if (pServices)
			{
				rcsAuxNameSpace = csNamespace;
				if (rpAuxServices)
				{
					rpAuxServices->Release();
				}
				rpAuxServices = pServices;
			}
			else
			{
				return NULL;
			}
		}
		else
		{
			return NULL;
		}
	}



	IEnumWbemClassObject *pemcoAssocs =
		ExecOBJDBQuery(bDiffNS == FALSE? pProv : rpAuxServices, csQuery, m_pParent->m_csNameSpace);

	return pemcoAssocs;


}

IEnumWbemClassObject *CInstanceTree::GetAssocClassesEnum2(IWbemServices * pProv, CString &rcsInst, CString &rcsClass,
 CString csCurrentNameSpace, CString &rcsAuxNameSpace, IWbemServices *&rpAuxServices,
 CNavigatorCtrl *pControl)
{
	CString csReqAttrib = _T("Association");
	CString csQuery;
	csQuery.Format(_T("references of {%s} where schemaonly"), (LPCTSTR)rcsClass);

	BOOL bDiffNS = ObjectInDifferentNamespace(&csCurrentNameSpace,&rcsInst);

	if (bDiffNS && ObjectInDifferentNamespace(&rcsAuxNameSpace,&rcsInst))
	{
		CString csNamespace = GetObjectNamespace(&rcsInst);
		if (csNamespace.GetLength() > 0)
		{
			IWbemServices * pServices =
				pControl->InitServices(&csNamespace);
			if (pServices)
			{
				rcsAuxNameSpace = csNamespace;
				if (rpAuxServices)
				{
					rpAuxServices->Release();
				}
				rpAuxServices = pServices;
			}
			else
			{
				return NULL;
			}
		}
		else
		{
			return NULL;
		}
	}



	IEnumWbemClassObject *pemcoAssocs =
		ExecOBJDBQuery(bDiffNS == FALSE? pProv : rpAuxServices, csQuery, m_pParent->m_csNameSpace);

	return pemcoAssocs;


}

void CInstanceTree::GetDerivation(CStringArray *prgsz, IWbemServices * pProv, CString &rcsInst, CString &rcsClass,
 CString csCurrentNameSpace, CString &rcsAuxNameSpace, IWbemServices *&rpAuxServices,
 CNavigatorCtrl *pControl)
{
	BOOL bDiffNS = ObjectInDifferentNamespace(&csCurrentNameSpace,&rcsInst);

	if (bDiffNS && ObjectInDifferentNamespace(&rcsAuxNameSpace,&rcsInst))
	{
		CString csNamespace = GetObjectNamespace(&rcsInst);
		if (csNamespace.GetLength() > 0)
		{
			IWbemServices * pServices =
				pControl->InitServices(&csNamespace);
			if (pServices)
			{
				rcsAuxNameSpace = csNamespace;
				if (rpAuxServices)
				{
					rpAuxServices->Release();
				}
				rpAuxServices = pServices;
			}
			else
				return;
		}
		else
			return;
	}


	if(bDiffNS && rpAuxServices)
		pProv = rpAuxServices;

	IWbemClassObject *pObject = NULL;

	HRESULT hr = E_FAIL;
	if(pProv)
	{
		BSTR bstrTemp = rcsClass.AllocSysString();
		hr = pProv->GetObject(bstrTemp,0, NULL, &pObject,NULL);
		SysFreeString(bstrTemp);
	}
	if(SUCCEEDED(hr) && pObject)
		ClassDerivation(prgsz, pObject);
}

//***************************************************************************
//
// GetAssocClasses
//
// Purpose: Get all the associations classes that an object instance
//			participates in.
//
//***************************************************************************
CStringArray *CInstanceTree::GetAssocClasses
(IWbemServices * pProv, IEnumWbemClassObject *pemcoAssocs ,
 CPtrArray *pcsaAssocPropsAndRoles, HRESULT &hResult, int nRes)
{
	if (!pemcoAssocs)
	{
		return NULL;
	}

	CStringArray *pcsaAssoc = new CStringArray;

	IWbemClassObject *pAssoc = NULL;
	BOOL bCancel = FALSE;
	CPtrArray *cpaClasses =
		m_pParent->SemiSyncEnum
		(pemcoAssocs, bCancel, hResult, nRes);

#ifdef _DEBUG
//	afxDump << _T("************* GetAssocClasses *****************\n*********");
//	afxDump << _T("SemiSyncEnum number returned  " ) << cpaClasses->GetSize() << _T("\n");
	CString csAsHex;
	csAsHex.Format(_T("0x%x"),hResult);
//	afxDump << _T("SemiSyncEnum hResult = " ) << csAsHex << _T("\n");
#endif


	int i;

	for (i = 0; i < cpaClasses->GetSize(); i++)
	{
		pAssoc = reinterpret_cast<IWbemClassObject *>
			(cpaClasses->GetAt(i));
		AddIWbemClassObjectToArray
				(pProv, pAssoc, pcsaAssoc, FALSE, FALSE);
		if (pcsaAssocPropsAndRoles)
		{
			pcsaAssocPropsAndRoles->Add(GetAssocRoles
									(	pProv,
										pAssoc,
										NULL));
		}
		pAssoc->Release();
		pAssoc = NULL;
	}

	delete cpaClasses;
	return pcsaAssoc;

}

CStringArray *CInstanceTree::GetAssocClasses2
(IWbemServices * pProv, IEnumWbemClassObject *pemcoAssocs ,
 CPtrArray *pcsaAssocPropsAndRoles, HRESULT &hResult, int nRes, CStringArray *prgszDerivation)
{
	if (!pemcoAssocs)
	{
		return NULL;
	}

	CStringArray *pcsaAssoc = new CStringArray;

	IWbemClassObject *pAssoc = NULL;
	BOOL bCancel = FALSE;
	CPtrArray *cpaClasses =
		m_pParent->SemiSyncEnum
		(pemcoAssocs, bCancel, hResult, nRes);


	int i;

	CString csAbstract(_T("Abstract"));
	for (i = 0; i < cpaClasses->GetSize(); i++)
	{
		pAssoc = reinterpret_cast<IWbemClassObject *>
			(cpaClasses->GetAt(i));

		BOOL bAbstract;
		if(S_OK == GetAttribBool(pAssoc, NULL, &csAbstract, bAbstract) && bAbstract)
		{
			pAssoc->Release();
			pAssoc = NULL;
			continue;
		}

		AddIWbemClassObjectToArray
				(pProv, pAssoc, pcsaAssoc, FALSE, FALSE);
		if (pcsaAssocPropsAndRoles)
		{
#if 0
			pcsaAssocPropsAndRoles->Add(GetAssocRoles
									(	pProv,
										pAssoc,
										NULL));
#endif
			CStringArray *prgsz = new CStringArray;
			pcsaAssocPropsAndRoles->Add(prgsz);
			CString *pcsRolesAndPaths = NULL;
			int nRoles = GetAssocRolesAndPaths(pAssoc, pcsRolesAndPaths);
			for(int j=0;j<nRoles;j++)
			{
				int nStrength = FindInArrayNoCase(prgszDerivation, &pcsRolesAndPaths[j*2+1]);
				CString szStrength;
				szStrength.Format(_T("%i"), nStrength);
				if(nStrength >= 0)
				{
					for(int k=0;k<nRoles;k++)
					{
						if(j!=k)
						{
							prgsz->Add(pcsRolesAndPaths[j*2]);
							prgsz->Add(pcsRolesAndPaths[k*2]);
							prgsz->Add(szStrength);
						}
					}
				}
			}
			delete [] pcsRolesAndPaths;
		}
		pAssoc->Release();
		pAssoc = NULL;
	}

	delete cpaClasses;
	return pcsaAssoc;

}

void CInstanceTree::OnAssocRoleExpanding
(HTREEITEM hItem, CTreeItemData *pctidData)
{
	// For a CTreeItemData instance of ItemDataType AssocRole:
	//	m_pimcoItem		is the association class
	//  m_csMyRole		is the role of the parent object

	// Get the tree item parent of the AssocRole which must be an
	// object instance.
	HTREEITEM hParent = GetParentItem (hItem);
	CTreeItemData *pctidParent = reinterpret_cast<CTreeItemData *>
									(GetItemData(hParent));

	// Get list of object classes associated thru AssocRole to pimcoParent.
	CString csText = GetItemText(hItem);
	int nRoleBegin = csText.Find('.');
	CString csRole = csText.Right(csText.GetLength() - (nRoleBegin + 1));
	CString csAssocClass =
		GetIWbemClass(pctidData ->GetAt(0));
	CStringArray *pcsaObjectInstances =
		GetObjectInstancesForAssocRole	// sign change and this wants to be
										// object instances, not classes
			(	hItem,
				m_pParent -> GetServices(),
				pctidParent -> GetAt(0),
				csAssocClass,
				pctidData -> m_csMyRole,
				csRole,
				m_pParent->m_csNameSpace,
				m_pParent->m_csAuxNameSpace,
				m_pParent->m_pAuxServices,
				m_pParent);


	if (pcsaObjectInstances == NULL)
	{
		return;
	}

	CStringArray csaObjectGroups;
	CStringArray csaObjectInstances;

	PartitionObjectInstances
		(	*pcsaObjectInstances,
			csaObjectGroups, // sorted but groups are co-mingled
			csaObjectInstances);

	int i;



	delete pcsaObjectInstances;

	CStringArray csaGroup;
	CString csClass;
	CString csInstance;

	i = 0;

	while (i < csaObjectGroups.GetSize())
	{
		csInstance = csaObjectGroups.GetAt(i);
		csClass = GetIWbemClass(csInstance);
		int n = i + 1;
		CString csTestClass;
		while (n < csaObjectGroups.GetSize())
		{
			 csTestClass = GetIWbemClass(csaObjectGroups.GetAt(n));
			 if (!csTestClass.CompareNoCase(csClass) == 0)
			 {
				break;
			 }
			 n++;
		}
		csaGroup.RemoveAll();
		int o;
		for (o = i; o < n; o++)
		{
			csaGroup.Add(csaObjectGroups.GetAt(o));
		}
		AddObjectGroupInstancesToTree(hItem, csClass, csaGroup);
		//Swap after incremental tree building.
		//AddObjectGroupToTree(hItem, csClass, csaGroup);
		i = n;

	}

	for (i = 0; i < csaObjectInstances.GetSize(); i++)
	{

		AddObjectInstToTree(hItem,csaObjectInstances.GetAt(i));
	}


		// here test to see if we do have a '+' and no children
		// if yes then remove the '+'.
		if (ItemHasChildren (hItem))
		{
			if (!GetChildItem(hItem))
			{

				TV_INSERTSTRUCT		tvstruct;
				tvstruct.item.hItem = hItem;
				tvstruct.item.mask = TVIF_CHILDREN;
				tvstruct.item.cChildren = 0;
				SetItem(&tvstruct.item);
			}


		}

}

//***************************************************************************
//
// GetObjectInstancesForAssocRole
//
// Purpose: Get the object Instances associated with an object instance
//			through an association class which plays a specified role in the
//			association instances of association class.
//
//***************************************************************************
CStringArray *CInstanceTree::GetObjectInstancesForAssocRole
(HTREEITEM hParent, IWbemServices * pProv,CString &rcsObjectInst,
CString &rcsAssocClass, CString &rcsRole,  CString &rcsResultRole, CString csCurrentNameSpace,
CString &rcsAuxNameSpace, IWbemServices *&rpAuxServices, CNavigatorCtrl *pControl)
{


	CString csQuery = BuildOBJDBGetAssocsQuery
		(pProv, &rcsObjectInst, &rcsAssocClass, NULL, &rcsRole,NULL,NULL,&rcsResultRole,FALSE,/*TRUE*/FALSE);

//	csQuery.Format(_T("references of {%s} where ResultClass=%s Role=%s"), (LPCTSTR)rcsObjectInst, (LPCTSTR)rcsAssocClass, (LPCTSTR)rcsRole);
	csQuery.Format(_T("references of {%s} where ResultClass=%s"), (LPCTSTR)rcsObjectInst, (LPCTSTR)rcsAssocClass);

	BOOL bDiffNS = ObjectInDifferentNamespace(&csCurrentNameSpace,&rcsObjectInst);

	if (bDiffNS && ObjectInDifferentNamespace(&rcsAuxNameSpace,&rcsObjectInst))
	{
		CString csNamespace = GetObjectNamespace(&rcsObjectInst);
		if (csNamespace.GetLength() > 0)
		{
			rcsAuxNameSpace = csNamespace;
			IWbemServices * pServices =
				pControl->InitServices(&csNamespace);
			if (pServices)
			{
				if (rpAuxServices)
				{
					rpAuxServices->Release();
				}
				rpAuxServices = pServices;
			}
			else
			{
				return NULL;
			}
		}
		else
		{
			return NULL;
		}
	}

	IEnumWbemClassObject *pemcoObjects =
		ExecOBJDBQuery (bDiffNS == FALSE ? pProv : rpAuxServices, csQuery, m_pParent->m_csNameSpace);

	if (!pemcoObjects)
		return NULL;

	pemcoObjects -> Reset();


	CString csMessage =
		rcsAssocClass + _T(".") + rcsResultRole;

	m_pParent->SetProgressDlgMessage(csMessage);

	CString csLabel = _T("Expanding association instance:");
	m_pParent->SetProgressDlgLabel(csLabel);

	if (!m_pParent->m_pProgressDlg->GetSafeHwnd())
	{
		m_pParent->CreateProgressDlgWindow();

	}

	CStringArray *pcsaObjects = new CStringArray;
	CMapStringToPtr mapT;
	CMapStringToPtr mapGroupFolders;

	IWbemClassObject *pObject = NULL;
	BOOL bCancel = FALSE;
	int nRes = 2;
	HRESULT hResult;
	CPtrArray *pcpaInstances =
		m_pParent->SemiSyncEnum
		(pemcoObjects, bCancel, hResult, nRes);

	CStringArray *pcsaClasses = new CStringArray[1];

	while (	pcpaInstances &&
			(hResult == S_OK ||
			hResult == WBEM_S_TIMEDOUT ||
			pcpaInstances->GetSize() > 0))
	{
		if (!bCancel)
		{
			bCancel = m_pParent->CheckCancelButtonProgressDlgWindow();
		}

		if (bCancel)
		{
			CWaitCursor wait;
			UnCacheTools();
			m_bReCacheTools = TRUE;

			Expand(hParent,TVE_COLLAPSE);

			if (ItemHasChildren (hParent))
			{
				HTREEITEM hChild = GetChildItem(hParent);
				while (hChild)
				{
					DeleteTreeItemData(hChild);
					HTREEITEM hChildNext = GetNextSiblingItem(hChild);
					DeleteItem( hChild);
					hChild = hChildNext;
				}

			}

			TV_INSERTSTRUCT tvstruct;

			tvstruct.item.hItem = hParent;
			tvstruct.item.mask = TVIF_CHILDREN;
			tvstruct.item.cChildren = 1;
			SetItem(&tvstruct.item);

			UINT nStateMask = TVIS_EXPANDEDONCE;
			UINT uState =
				GetItemState( hParent, nStateMask );

			uState = 0;

			SetItemState(hParent, uState, TVIS_EXPANDEDONCE);

			m_pParent->InvalidateControl();

			m_pParent->DestroyProgressDlgWindow();

			pemcoObjects -> Release();

			for (int i = 0; i < pcpaInstances->GetSize(); i++)
			{
				pObject = reinterpret_cast<IWbemClassObject *>
					(pcpaInstances->GetAt(i));
				pObject->Release();
			}

			delete pcpaInstances;
			pcpaInstances = NULL;

			delete [] pcsaClasses;
			pcsaClasses = NULL;

			return NULL;

		}
		int i;
		for (i = 0; i < pcpaInstances->GetSize(); i++)
		{
			pObject = reinterpret_cast<IWbemClassObject *>
				(pcpaInstances->GetAt(i));
#if 0
			CString csPath = GetIWbemFullPath(pProv,pObject);
			CString csClass = GetIWbemClass(pProv,pObject);
#endif
#if 1
			CString csPath = GetBSTRProperty(pObject, &rcsResultRole);
			CString csClass = GetIWbemClass(csPath);

			// bug#57776 - Make sure that the path retrieved from the
			// association reference is fully quallified (in other words,
			// it must start with \\<machine>\namespace:)  Otherwise,
			// prepend the namespace from the __PATH property of the
			// association object itself to the relative path returned
			// by the reference
			if(csPath.GetLength() > 2 && _T("\\\\") != csPath.Left(2))
			{
				CString csPathPropName(_T("__PATH"));
				CString csPathT = GetBSTRProperty(pObject, &csPathPropName);
				int nLen = csPathT.Find(_T(":"));
				if(nLen > 0)
				{
					csPath = csPathT.Left(nLen+1) + csPath;
				}
			}
#endif

			if (!WbemObjectIdentity(rcsObjectInst,csPath))
			{
#if 0
				AddIWbemClassObjectToArray(pProv,pObject,pcsaObjects,FALSE,  TRUE);
#endif
#if 1
				LPVOID pT;
				CString csPathT(csPath);
				csPathT.MakeLower();
				BOOL bDuplicatePath = FALSE;
				if(!(bDuplicatePath = mapT.Lookup(csPathT, pT)))
				{
					mapT[csPathT] = 0;
//					AddIWbemClassObjectToArray(&csPath, pcsaObjects);
					pcsaObjects[0].Add(csPath);
				}

#endif
				pObject->Release();
				pObject = NULL;

				// Don't do any more processing for duplicate paths
				if(bDuplicatePath)
					continue;

				BOOL bInArray =	StringInArray(pcsaClasses,&csClass,0);
				if (!bInArray)
				{
					pcsaClasses[0].Add(csClass);
				}
				else
				{
					// If we don't already have a 'group' folder for this class, add one
					if(!mapGroupFolders.Lookup(csClass, pT))
					{
						mapGroupFolders[csClass] = 0;
						CStringArray csaEmpty;
						AddObjectGroupToTree(hParent, csClass, csaEmpty);
					}

				}
			}
			else
			{
				pObject -> Release();
				pObject = NULL;
			}
		}

		delete pcpaInstances;
		pcpaInstances = NULL;
		pcpaInstances =
		m_pParent->SemiSyncEnum
			(pemcoObjects, bCancel, hResult, nRes);
	}

	m_pParent->DestroyProgressDlgWindow();

	delete [] pcsaClasses;
	pcsaClasses = NULL;

	pemcoObjects -> Release();

	return pcsaObjects;
}


void CInstanceTree::OnObjectGroupExpanding
(HTREEITEM hItem, CTreeItemData *pctidData)
{

	for (int i = 1; i < pctidData -> GetSize(); i++)
	{
		AddObjectInstToTree(hItem,pctidData->GetAt(i));

	}

}




CString CInstanceTree::GetAssocRoleInstancesQuery
(HTREEITEM hItem, CTreeItemData *pctidData)
{
	// Can use GetObjectClassForRole to get the role's class.
	HTREEITEM hParent = GetParentItem (hItem);
	CTreeItemData *pctidParent = reinterpret_cast<CTreeItemData *>
									(GetItemData(hParent));
	CString csParent = pctidParent -> GetAt(0);

	CString csText = GetItemText(hItem);
	int nRoleBegin = csText.Find('.');
	CString csRole = csText.Right(csText.GetLength() - (nRoleBegin + 1));

	CString csAssoc = GetIWbemClass(pctidData -> GetAt(0));
	CString csAttrib = _T("Association");
	CString csQuery = BuildOBJDBGetAssocsQuery
		(m_pParent -> GetServices(), &csParent,
		&csAssoc, NULL, &pctidData -> m_csMyRole,NULL,NULL,&csRole,FALSE,FALSE);


	return csQuery;
}


CString CInstanceTree::GetObjectGroupInstancesQuery
(HTREEITEM hItem, CTreeItemData *pctidData)
{
	// For a CTreeItemData instance of ItemDataType ObjectGroup:
	//	m_pimcoItem		is the grouping class
	CString csItemClass =
		pctidData -> GetAt(0);

	// Get the tree item parent of the Object Group
	HTREEITEM hParent = GetParentItem (hItem);
	CTreeItemData *pctidParent =
		reinterpret_cast<CTreeItemData *> (GetItemData(hParent));

	// Case statement on the parent of the Object Group
	switch (pctidParent -> m_nType)
	{
	case CTreeItemData::AssocRole:
		return GetObjectGroupInstancesQueryParentAssocRole
			(hItem, pctidData, pctidParent,hParent);
		break;
	case CTreeItemData::ObjectGroup:
		// Should never happen!
		break;
	default:
		break;
	}
	return "";

}



CString CInstanceTree::GetObjectGroupInstancesQueryParentAssocRole
(HTREEITEM hItem, CTreeItemData *pctidData, CTreeItemData *pctidAssocRole,
 HTREEITEM hParent)
{
	// For a CTreeItemData instance of ItemDataType ObjectGroup:
	//	m_pimcoItem		is the grouping class

	HTREEITEM hAssociatedObject =
			hParent;
	CTreeItemData *pctidAssociatedObject =
		reinterpret_cast<CTreeItemData *> (GetItemData(hAssociatedObject));

	CString csAssocClass = GetIWbemClass(pctidAssocRole -> GetAt(0));

	HTREEITEM hParentObject = GetParentItem(hAssociatedObject);
	CTreeItemData *pctidParentObject =
		reinterpret_cast<CTreeItemData *> (GetItemData(hParentObject));

	CString csText = GetItemText(hAssociatedObject);
	int nRoleBegin = csText.Find('.');
	CString csRole = csText.Right(csText.GetLength() - (nRoleBegin + 1));

	CString csQuery =
		BuildOBJDBGetAssocsQuery
		(	m_pParent -> GetServices(),
			&pctidParentObject -> GetAt(0),
			&csAssocClass,
			// The grouping class.  Must filter the results to make sure
			// that the GroupingClass of the results is this class.
			&pctidData -> GetAt(0),
			&pctidAssocRole -> m_csMyRole,NULL,NULL,
			&csRole, FALSE, FALSE
			);

	return csQuery;
}


// If we find object with role in association then return TRUE
BOOL CInstanceTree::IsBackwardAssoc(
					CString &rcsObjectToFilter,
					CString &rcsAssocToFilter,
					CString &rcsAssocRoleToFilter,
					CString &rcsAssoc,
					CString &rcsTargetObject,
					CString &rcsTargetRole)
{
	BOOL bReturn = FALSE;

	if (!GetIWbemClass(rcsAssoc).CompareNoCase(rcsAssocToFilter) == 0)
	{
		return bReturn;
	}

	CStringArray *pcsaInstances = GetAssocInstances
				(m_pParent->GetServices(),
				&rcsTargetObject,
				&rcsAssocToFilter,
				&rcsTargetRole,
				m_pParent->m_csNameSpace,
				m_pParent->m_csAuxNameSpace,
				m_pParent->m_pAuxServices,
				m_pParent);

	int nRefs = (int) pcsaInstances->GetSize();

	delete pcsaInstances;

	bReturn = nRefs > 1? FALSE : TRUE;

	return bReturn;

}

//***************************************************************************
//
//
//***************************************************************************
void CInstanceTree::PartitionObjectInstances
(CStringArray &rcsaAllObjectInstances, CStringArray &rcsaObjectGroups,
 CStringArray &rcsaObjectInstances)
{
	int nObjectInstances = (int) rcsaAllObjectInstances.GetSize();
	int i;

	CSortedCStringArray cscsaSortedInstances;

	for (i = 0; i < nObjectInstances; i++)
	{
		cscsaSortedInstances.AddString(rcsaAllObjectInstances.GetAt(i), FALSE);
	}

	int nSortedObjectInstances =
		cscsaSortedInstances.GetSize();

	ASSERT(nObjectInstances == nSortedObjectInstances);

	for (i = 0; i < nSortedObjectInstances; i++)
	{
		if (i > 0 && i + 1 < nSortedObjectInstances)
		{
			CString csInstIMinus1 = GetIWbemClass(cscsaSortedInstances.GetStringAt(i - 1));
			CString csInstI = GetIWbemClass(cscsaSortedInstances.GetStringAt(i));
			CString csInstIPlus1 = GetIWbemClass(cscsaSortedInstances.GetStringAt(i + 1));
			if (csInstI.CompareNoCase(csInstIPlus1) == 0 ||
				csInstI.CompareNoCase(csInstIMinus1) == 0)
			{
				rcsaObjectGroups.Add(cscsaSortedInstances.GetStringAt(i));
			}
			else
			{
				rcsaObjectInstances.Add(cscsaSortedInstances.GetStringAt(i));
			}
		}
		else if (i == 0 && i + 1 < nSortedObjectInstances)
		{
			CString csInstI = GetIWbemClass(cscsaSortedInstances.GetStringAt(i));
			CString csInstIPlus1 = GetIWbemClass(cscsaSortedInstances.GetStringAt(i + 1));
			if (csInstI.CompareNoCase(csInstIPlus1) == 0)
			{
				rcsaObjectGroups.Add(cscsaSortedInstances.GetStringAt(i));
			}
			else
			{
				rcsaObjectInstances.Add(cscsaSortedInstances.GetStringAt(i));
			}
		}
		else if (i > 0 && i + 1 == nSortedObjectInstances)
			{
			CString csInstIMinus1 = GetIWbemClass(cscsaSortedInstances.GetStringAt(i - 1));
			CString csInstI = GetIWbemClass(cscsaSortedInstances.GetStringAt(i));
			if (csInstI.CompareNoCase(csInstIMinus1) == 0)
			{
				rcsaObjectGroups.Add(cscsaSortedInstances.GetStringAt(i));
			}
			else
			{
				rcsaObjectInstances.Add(cscsaSortedInstances.GetStringAt(i));
			}
		}
		else
		{
				rcsaObjectInstances.Add(cscsaSortedInstances.GetStringAt(i));
		}

	}

}



CString CInstanceTree::GetParentAssocFromTree
(HTREEITEM hItem,HTREEITEM &hReturn)
{
	// Look up the tree until we see an AssocRole.
	HTREEITEM hParent = GetParentItem (hItem);

	hReturn = NULL;
	CTreeItemData *pctidParent = NULL;
	if (hParent)
	{
		pctidParent =
			reinterpret_cast<CTreeItemData *> (GetItemData(hParent));
		while (hParent &&
				!(pctidParent -> m_nType == CTreeItemData::AssocRole))
		{
			hParent = GetParentItem (hParent);
			if (hParent)
				pctidParent =
				reinterpret_cast<CTreeItemData *>
				(GetItemData(hParent));
		}


	}


	if (pctidParent)
	{
		hReturn = hParent;
		return pctidParent ->GetAt(0);
	}

	return "";

}


HTREEITEM CInstanceTree::IsIWbemObjectInTreeAbove
(HTREEITEM hItem , CString &rcsObject, int nType)
{
	CTreeItemData *pctidParent;
	HTREEITEM hParent = hItem;

	while (hParent )
		{
			pctidParent =
					reinterpret_cast<CTreeItemData *>
					(GetItemData(hParent));

			if (pctidParent -> m_nType == nType &&
					WbemObjectIdentity(rcsObject ,
					pctidParent -> GetAt(0) ))
					return hParent;

			hParent = GetParentItem (hParent);
		}

	return NULL;
}



HTREEITEM CInstanceTree::InsertTreeItem
(HTREEITEM hParent, LPARAM lparam, int iBitmap, int iSelectedBitmap,
 TCHAR *pText , BOOL bHasChildren, BOOL bBold)
{
#ifdef _DEBUG
//	afxDump << _T("************ InsertTreeItem *****************\n********");
//	afxDump << pText << _T("\n");
#endif

	TV_INSERTSTRUCT tvinsert;
	HTREEITEM h1;

	tvinsert.hParent = hParent;
	tvinsert.hInsertAfter = TVI_LAST;
	tvinsert.item.mask = TVIF_TEXT | TVIF_SELECTEDIMAGE |
							TVIF_PARAM | TVIF_IMAGE |
							TVIF_STATE | TVIF_CHILDREN;
	tvinsert.item.hItem = NULL;
	if (bBold)
	{
		tvinsert.item.state = TVIS_BOLD;
		tvinsert.item.stateMask = TVIS_BOLD;
	}
	else
	{
		tvinsert.item.state = 0;
		tvinsert.item.stateMask = 0;
	}
	tvinsert.item.cchTextMax = _tcslen(pText) + 1;
	tvinsert.item.cChildren = bHasChildren? 1 : 0;
	tvinsert.item.lParam = lparam;
	tvinsert.item.iImage = iBitmap;
	tvinsert.item.iSelectedImage = iSelectedBitmap;
	tvinsert.item.pszText = pText;
	h1 =  InsertItem(&tvinsert);

	m_bReCacheTools = TRUE;
	return h1;
}


void CInstanceTree::OnRButtonDown(UINT nFlags, CPoint point)
{
	UINT hitFlags ;
    HTREEITEM hItem ;

    hItem = HitTest( point, &hitFlags ) ;
    if (hitFlags & (TVHT_ONITEM | TVHT_ONITEMBUTTON))
	{
		CTreeItemData *pctidItem =
			reinterpret_cast<CTreeItemData *>
			(GetItemData(hItem));
		if (pctidItem)
		{
			m_pParent -> m_pctidHit = pctidItem;
			m_pParent -> m_hHit = hItem;
		}
	}
	else
	{
		m_pParent -> m_pctidHit = NULL;
		m_pParent -> m_hHit = NULL;
	}


}

void CInstanceTree::OnContextMenu(CWnd* pWnd, CPoint point)
{
	// CG: This function was added by the Pop-up Menu component
	// PSS ID Number: Q141199

	UINT hitFlags ;
    HTREEITEM hItem ;

	CPoint cpClient;

	if (point.x == -1 && point.y == -1)
	{
		CRect crClient;
		GetClientRect(&crClient);
		hItem = GetSelectedItem();
		if (hItem)
		{
			RECT rect;
			BOOL bRect = GetItemRect(hItem,&rect, TRUE );
			POINT p;
			p.x = rect.left + 2;
			p.y = rect.top + 2;
			if (bRect && crClient.PtInRect(p))
			{
				cpClient.x = rect.left + 2;
				cpClient.y = rect.top + 2;
			}
			else
			{
				cpClient.x = 0;
				cpClient.y = 0;
			}
			CTreeItemData *pctidItem =
				reinterpret_cast<CTreeItemData *>
				(GetItemData(hItem));
			if (pctidItem)
			{
				m_pParent -> m_pctidHit = pctidItem;
				m_pParent -> m_hHit = hItem;
			}
			else
			{
				m_pParent -> m_pctidHit = NULL;
				m_pParent -> m_hHit = NULL;
			}
		}
		point = cpClient;
		ClientToScreen(&point);
	}
	else
	{
		cpClient = point;
		ScreenToClient(&cpClient);
		hItem = HitTest( cpClient, &hitFlags ) ;
		if (hitFlags & (TVHT_ONITEM | TVHT_ONITEMBUTTON))
		{
			CTreeItemData *pctidItem =
				reinterpret_cast<CTreeItemData *>
				(GetItemData(hItem));
			if (pctidItem)
			{
				m_pParent -> m_pctidHit = pctidItem;
				m_pParent -> m_hHit = hItem;
			}
			else
			{
				m_pParent -> m_pctidHit = NULL;
				m_pParent -> m_hHit = NULL;
			}
		}
		else
		{
			m_pParent -> m_pctidHit = NULL;
			m_pParent -> m_hHit = NULL;
		}
	}

	VERIFY(m_cmContext.LoadMenu(CG_IDR_POPUP_A_TREE_CTRL));

	CMenu* pPopup = m_cmContext.GetSubMenu(0);

	CWnd* pWndPopupOwner = m_pParent;

	pPopup->TrackPopupMenu
		(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y,
		pWndPopupOwner);

	m_cmContext.DestroyMenu();
}

void CInstanceTree::OnItemExpanded
(NMHDR *pNMHDR, LRESULT *pResult)
{

#ifdef _DEBUG
	afxDump << "CInstanceTree::OnItemExpanded\n";
#endif

	NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pNMHDR;

	if (pnmtv -> itemNew.state & TVIS_EXPANDEDONCE)
	{
		m_bReCacheTools = TRUE;
		*pResult = 0;
		return;
	}
	m_bReCacheTools = TRUE;
	*pResult = 0;

	m_pParent-> PostMessage(SETFOCUS,0,0);
}


int CInstanceTree::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CTreeCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;
	CRect rTool(0,0,30,20);
	if (!m_ttip.Create(this))
		TRACE0("Unable to create tip window.");
	else
		m_ttip.Activate(TRUE);


	return 0;
}

void CInstanceTree::ContinueProcessSelection(UINT nFlags, CPoint point)
{

#ifdef _DEBUG
	afxDump << "Entering CInstanceTree::ContinueProcessSelection\n";
#endif

	UINT uFlags = 0;
	HTREEITEM hItem;

	if (m_bUseItem)
	{

		hItem = m_hItemToUse;
	}
	else
	{
		hItem= HitTest( point, &uFlags );
	}

	// Make sure item exists
	TVITEM item;
	item.hItem = hItem;
	item.mask = TVIF_PARAM;
	if(!::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item))
		hItem = NULL;


	if (!hItem || m_bKeyDown)
	{
		m_bUseItem = FALSE;
		m_hItemToUse = NULL;
		m_pParent-> PostMessage(SETFOCUS,0,0);
		return;
	}

	CTreeItemData *pctidItem = NULL;

	if (m_bUseItem)
	{
		m_bUseItem = FALSE;
		m_hItemToUse = NULL;
		pctidItem = reinterpret_cast <CTreeItemData *> (GetItemData(hItem));
	}
	else if (uFlags & TVHT_ONITEM)
	{
		pctidItem = reinterpret_cast <CTreeItemData *> (GetItemData(hItem));
	}

	if (!pctidItem)
	{
		m_pParent-> PostMessage(SETFOCUS,0,0);
		return;
	}

	CString csData = pctidItem -> GetAt(0);

	if (pctidItem && !csData.IsEmpty())
	{
		if (pctidItem -> m_nType == CTreeItemData::ObjectInst)
		{
			m_pParent -> m_csSingleSelection = csData;
			if (m_pParent -> m_bReadySignal)
			{
				m_pParent -> FireViewObject((LPCTSTR)csData);
			}
#ifdef _DEBUG
	afxDump << "CInstanceTree::ContinueProcessSelection m_pParent -> FireViewObject(" << csData << ");\n";
#endif
			m_pParent -> m_pctidHit = NULL;
			m_pParent -> m_hHit = NULL;
		}
		else if (pctidItem -> m_nType == CTreeItemData::ObjectGroup ||
				 pctidItem -> m_nType == CTreeItemData::AssocRole)
		{
			m_pParent -> m_pctidHit = pctidItem;
			m_pParent -> m_hHit = hItem;
#ifdef _DEBUG
	afxDump << "CInstanceTree::ContinueProcessSelection m_pParent->PostMessage(ID_MULTIINSTANCEVIEW,0,0)\n";
#endif
			m_pParent->PostMessage(ID_MULTIINSTANCEVIEW,0,0);
		}
		else
		{
			m_pParent -> m_pctidHit = NULL;
			m_pParent -> m_hHit = NULL;

		}


	}

	m_pParent -> InvalidateControl();
	m_pParent-> PostMessage(SETFOCUS,0,0);

}


void CInstanceTree::OnMouseMove(UINT nFlags, CPoint point)
{

	if (m_bReCacheTools)
	{
		m_bReCacheTools = FALSE;
		ReCacheTools();
	}

      RelayEvent(WM_MOUSEMOVE, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));
      CTreeCtrl::OnMouseMove(nFlags, point);
}

void CInstanceTree::RelayEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
      if (NULL != m_ttip.m_hWnd)
	  {
         MSG msg;

         msg.hwnd= m_hWnd;
         msg.message= message;
         msg.wParam= wParam;
         msg.lParam= lParam;
         msg.time= 0;
         msg.pt.x= LOWORD (lParam);
         msg.pt.y= HIWORD (lParam);

         m_ttip.RelayEvent(&msg);
     }
}

void CInstanceTree::ReCacheTools()
{

	HTREEITEM hItem = GetRootItem( );

	if (hItem == NULL)
		return;

	ReCacheTools(hItem);


}

void CInstanceTree::ReCacheTools(HTREEITEM hItem)
{
	HTREEITEM hChild;

	if (hItem == NULL)
		return;

    hChild = GetChildItem(  hItem );
	while (hChild)
	{
		ReCacheTools(hChild);
		hChild = GetNextSiblingItem(hChild);
	}

	BOOL bVisible;
	BOOL bToolInfo;
	CRect cr;
	CToolInfo ctiInfo;

	if (bToolInfo = m_ttip.GetToolInfo(ctiInfo , this, (UINT_PTR) hItem))
	{
		m_ttip.DelTool(this, (UINT_PTR) hItem);
	}


	if (bVisible = GetItemRect( hItem, &cr, TRUE))
	{
		CTreeItemData *pctidItem =
			reinterpret_cast<CTreeItemData *> (GetItemData(hItem));
		CString csData = pctidItem -> GetAt(0);
		if (!csData.IsEmpty())
		{
			m_csToolTipString =  csData.Left(255);
			m_ttip.AddTool (this,m_csToolTipString,&cr,(UINT_PTR) hItem);

		}
	}
}

void CInstanceTree::UnCacheTools()
{

	HTREEITEM hItem = GetRootItem( );

	if (hItem == NULL)
		return;

	UnCacheTools(hItem);


}

void CInstanceTree::UnCacheTools(HTREEITEM hItem)
{
	HTREEITEM hChild;

	if (hItem == NULL)
		return;

    hChild = GetChildItem(  hItem );
	while (hChild)
	{
		UnCacheTools(hChild);
		hChild = GetNextSiblingItem(hChild);
	}

	BOOL bToolInfo;
	CRect cr;
	CToolInfo ctiInfo;
	if (NULL != m_ttip.m_hWnd &&
		(bToolInfo = m_ttip.GetToolInfo(ctiInfo , this, (UINT_PTR) hItem)))
	{
		m_ttip.DelTool(this, (UINT_PTR) hItem);
	}


}

void CInstanceTree::OnSelchanging(NMHDR* pNMHDR, LRESULT* pResult)
{

	*pResult = 0;
	UINT uInterval = GetDoubleClickTime();
	if (uInterval > 0)
	{
		if (m_uiSelectionTimer)
		{
			KillTimer( m_uiSelectionTimer );
			m_uiSelectionTimer = 0;
		}
		gpTreeTmp = this;
		m_lSelection = 1;
		m_uiSelectionTimer = ::SetTimer
			(this->m_hWnd,
			ExpansionOrSelectionTimer,
			uInterval + 50,
			ExpansionOrSelection);

		NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pNMHDR;
		HTREEITEM hItem = pnmtv->itemNew.hItem;

		m_bUseItem = TRUE;
		m_hItemToUse = hItem;

	}

}

void CInstanceTree::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult)
{
#if 0


	NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pNMHDR;
	HTREEITEM hItem = pnmtv->itemNew.hItem;

	*pResult = 0;

	m_bUseItem = TRUE;
	m_hItemToUse = hItem;
	CPoint point(0,0);
	ContinueProcessSelection(TRUE,point );
#endif
	m_pParent-> PostMessage(SETFOCUS,0,0);
}

void CInstanceTree::OnHScroll
(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	CTreeCtrl::OnHScroll(nSBCode, nPos, pScrollBar);
	m_bReCacheTools = TRUE;
}

void CInstanceTree::OnVScroll
(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	CTreeCtrl::OnVScroll(nSBCode, nPos, pScrollBar);
	m_bReCacheTools = TRUE;
}

void CInstanceTree::OnSize(UINT nType, int cx, int cy)
{
	CTreeCtrl::OnSize(nType, cx, cy);
	m_bReCacheTools = TRUE;
}

void CInstanceTree::ResetTree()
{
	// Here we need to delete the CTreeItemData objects
	// before we DeleteAllItems().
	DeleteTreeItemData();
	DeleteAllItems();
	m_pParent->m_bTreeEmpty = TRUE;
	Invalidate();
	m_pParent->InvalidateControl();
}



void CInstanceTree::DeleteTreeItemData()
{

	HTREEITEM hRoot = GetRootItem( );

	if (!hRoot)
	{
		return;
	}

	if (ItemHasChildren (hRoot))
	{
		DeleteTreeItemData(hRoot);
	}
}

void CInstanceTree::DeleteTreeItemData(HTREEITEM hItem)
{

	CTreeItemData * pctidData =
			reinterpret_cast <CTreeItemData *> (GetItemData(hItem));
	delete pctidData;

	SetItemData(hItem,NULL);

	HTREEITEM hChild = GetChildItem(hItem);
	while (hChild)
	{
		DeleteTreeItemData(hChild);
		hChild = GetNextSiblingItem(hChild);
	}


}

void CInstanceTree::OnDestroy()
{
	if (m_uiTimer)
	{
		KillTimer( m_uiTimer );
		m_uiTimer = 0;
	}

	if (m_uiSelectionTimer)
	{
		KillTimer( m_uiSelectionTimer );
		m_uiSelectionTimer = 0;
	}

	m_bMouseDown = FALSE;
	m_bKeyDown = FALSE;
	m_bUseItem = FALSE;
	m_hItemToUse = NULL;

	CTreeCtrl::OnDestroy();


}

int CInstanceTree::GetNumChildren(HTREEITEM hItem)
{

	if (!ItemHasChildren (hItem))
	{
		return 0;
	}

	int c = 0;

	HTREEITEM hChild = GetChildItem(hItem);
	while (hChild)
	{
		c++;
		hChild = GetNextSiblingItem(hChild);
	}

	return c;

}

CString CInstanceTree::GetHMOMObject(HTREEITEM hItem)
{
	if (!hItem)
	{
		return _T("");
	}

	CTreeItemData *pctidItem =
		reinterpret_cast <CTreeItemData *> (GetItemData(hItem));
	if (pctidItem)
	{
		return pctidItem -> GetAt(0);
	}
	else
	{
		return _T("");
	}


}


void CInstanceTree::SetUpInvalidate(UINT , LONG)
{
	//ShowWindow(SW_SHOW);
	//RedrawWindow();

}

LRESULT CInstanceTree::SelectTreeItem(WPARAM, LPARAM)
{
	m_bMouseDown = FALSE;;
	m_bKeyDown = FALSE;
	m_bUseItem = FALSE;
	m_hItemToUse = NULL;

	if (m_uiTimer)
	{
		KillTimer( m_uiTimer );
		m_uiTimer = 0;
	}

	HTREEITEM hItem = GetSelectedItem();

	if (!hItem)
	{
		return 0;
	}

	m_bUseItem = TRUE;
	m_hItemToUse = hItem;
	CPoint point(0,0);

	ContinueProcessSelection(0, point);

	return 0;
}

void CInstanceTree::OnKeydown(NMHDR* pNMHDR, LRESULT* pResult)
{
		TV_KEYDOWN* pTVKeyDown = (TV_KEYDOWN*)pNMHDR;

	switch (pTVKeyDown->wVKey)
	{
	case VK_LEFT:
	case VK_RIGHT:
	case VK_UP:
	case VK_DOWN:
	case VK_NEXT:
	case VK_PRIOR:
	case VK_HOME:
	case VK_END:
		if (m_uiTimer)
		{
			KillTimer( m_uiTimer );
			m_uiTimer = 0;
		}
		m_uiTimer = SetTimer
			(KBSelectionTimer,
			KBSelectionTimer,
			SelectItemAfterDelay);
		m_bKeyDown = TRUE;
		m_bMouseDown = FALSE;
		break;
	default:
		m_bKeyDown = FALSE;
		m_bMouseDown = TRUE;
		break;

	};

	*pResult = 0;
}

BOOL CInstanceTree::IsTreeItemExpandable
(HTREEITEM hItem)
{

	TV_ITEM tvItem;

	tvItem.mask = TVIF_IMAGE;
	tvItem.hItem = hItem;

	BOOL bReturn = GetItem(&tvItem);

	bReturn = bReturn && tvItem.iImage != m_pParent -> IconNEInstance();

	return bReturn;
}



void CInstanceTree::OnKillFocus(CWnd* pNewWnd)
{
	m_pParent->m_bRestoreFocusToTree = TRUE;
	CTreeCtrl::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here

}

void CInstanceTree::OnSetFocus(CWnd* pOldWnd)
{
	m_pParent->m_bRestoreFocusToTree = TRUE;
	CTreeCtrl::OnSetFocus(pOldWnd);

	// TODO: Add your message handler code here

}



void CInstanceTree::OnLButtonUp(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	CTreeCtrl::OnLButtonUp(nFlags, point);

	m_pParent -> OnActivateInPlace(TRUE,NULL);
}

/*	EOF:  CInstanceTree.cpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\ccontainedtoolbar.cpp ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: CContainedToolBar.h
//
// Description:
//	This file implements the CContainedToolBar class which is a part of the Class
//	Navigator OCX, it is a subclass of the Microsoft CToolBar
//  control and performs the following functions:
//		a.  Provides a member function to calculate its size
//		b.  Provides a tooltip.
//
// Part of:
//	Navigator.ocx
//
// Used by:
//	 CBanner
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************
#include "precomp.h"
#include "afxpriv.h"
#include "wbemidl.h"
#include "resource.h"
#include "AFXCONV.H"
#include "CInstanceTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "InstanceSearch.h"
#include "NavigatorCtl.h"
#include "OLEMSCLient.h"

BEGIN_MESSAGE_MAP(CContainedToolBar,CToolBar)
	//{{AFX_MSG_MAP(CContainedToolBar)
	ON_WM_SIZE()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void CContainedToolBar::OnSize(UINT nType, int cx, int cy)
{
	CToolBar::OnSize(nType, cx, cy);
	if (m_pParent)
	{
		//m_pParent -> m_bBannerOnly = TRUE;
		m_pParent -> InvalidateControl();
	}

}

// ***************************************************************************
//
// CContainedToolBar::GetToolBarSize
//
// Description:
//	  This member function returns the toolbar's size..
//
// Parameters:
//	  VOID
//
// Returns:
// 	  CSize						Toolbar size.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CSize CContainedToolBar::GetToolBarSize()
{
	CRect rcButtons;
	CToolBarCtrl &rToolBarCtrl = GetToolBarCtrl();
	int nButtons = rToolBarCtrl.GetButtonCount();
	if (nButtons > 0) {
		CRect rcLastButton;
		rToolBarCtrl.GetItemRect(0, &rcButtons);
		rToolBarCtrl.GetItemRect(nButtons-1, &rcLastButton);
		rcButtons.UnionRect(&rcButtons, &rcLastButton);
	}
	else {
		rcButtons.SetRectEmpty();
	}

	CSize size;
	size.cx = rcButtons.Width();
	size.cy = rcButtons.Height();
	return size;
}


// ***************************************************************************
//
// CContainedToolBar::OnCreate
//
// Description:
//	  Called by the framework after the window is being created but before
//	  the window is shown.
//
// Parameters:
//	  LPCREATESTRUCT lpCreateStruct	Pointer to the structure which contains
//									default parameters.
//
// Returns:
//	  BOOL				0 if continue; -1 if the window should be destroyed.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
int CContainedToolBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CToolBar::OnCreate(lpCreateStruct) == -1)
		return -1;

	CToolBarCtrl &rToolBarCtrl = GetToolBarCtrl();

	if (m_ttip.Create(this,TTS_ALWAYSTIP))
	{
		m_ttip.Activate(TRUE);
		rToolBarCtrl.SetToolTips(&m_ttip );
	}

	EnableSearchButton(FALSE);
	return 0;
}

void CContainedToolBar::EnableSearchButton(BOOL bEnable)
{
	CToolBarCtrl &rToolBarCtrl = GetToolBarCtrl();
	rToolBarCtrl.EnableButton(ID_BROWSEFORINST, bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\initnamespacedialog.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// InitNamespaceDialog.cpp : implementation file
//

#include "precomp.h"
#include "resource.h"
#include "wbemidl.h"
#include "CInstanceTree.h"
#include "Navigator.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "InstanceSearch.h"
#include "AvailClasses.h"
#include "AvailClassEdit.h"
#include "SelectedClasses.h"
#include "SimpleSortedCStringArray.h"
#include "BrowseforInstances.h"
#include "NavigatorCtl.h"
#include "nsentry.h"
#include "InitNamespaceNSEntry.h"
#include "InitNamespaceDialog.h"
#include "OLEMSClient.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void CenterWindowInOwner(CWnd *pWnd,CRect &rectMove)
{
	if (!pWnd)
	{
		return;
	}

	CWnd *pOwner = pWnd->GetOwner();

	if (!pOwner)
	{
		return;
	}

	CRect rectOwner;
	pOwner->GetWindowRect(&rectOwner);

	CRect rect;
	pWnd->GetWindowRect(&rect);

	if (rectOwner.Width() < rect.Width())
	{
		long delta = (long) ((rectOwner.Width() - rect.Width()) * .5);
		rectMove.left = rectOwner.left + delta;
		rectMove.right = rectOwner.right - delta;
	}
	else
	{
		long delta = (long) ((rect.Width() - rectOwner.Width()) * .5);
		rectMove.left = rectOwner.left - delta;
		rectMove.right = rectOwner.right + delta;
	}

	if (rectOwner.Height() < rect.Height())
	{
		long delta = (long) ((rectOwner.Height() - rect.Height()) * .5);
		rectMove.top = rectOwner.top + delta;
		rectMove.bottom = rectOwner.bottom - delta;
	}
	else
	{
		long delta = (long) ((rect.Height() - rectOwner.Height()) * .5);
		rectMove.top = rectOwner.top - delta;
		rectMove.bottom = rectOwner.bottom + delta;

	}

}

/////////////////////////////////////////////////////////////////////////////
// CInitNamespaceDialog dialog

#define INITIALIZE_INIT_NAMESPACE WM_USER + 400

CInitNamespaceDialog::CInitNamespaceDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CInitNamespaceDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CInitNamespaceDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInit = FALSE;

}


void CInitNamespaceDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInitNamespaceDialog)
	DDX_Control(pDX, IDC_NSENTRYCTRLINITNAMESPACE, m_cnseInitNamespace);
	//}}AFX_DATA_MAP

	if (!m_bInit)
	{
		m_bInit = TRUE;
		PostMessage(INITIALIZE_INIT_NAMESPACE,0,0);
	}
}

LRESULT CInitNamespaceDialog::InitNamespace(WPARAM, LPARAM)
{
	if (!m_cnseInitNamespace.GetSafeHwnd())
	{
		PostMessage(INITIALIZE_INIT_NAMESPACE,0,0);
		return 0;
	}
	else
	{
		m_cnseInitNamespace.SetNamespaceText(_T("root\\CIMV2"));
		m_cnseInitNamespace.SetFocusToEdit();
		return 0;
	}

}

BEGIN_MESSAGE_MAP(CInitNamespaceDialog, CDialog)
	//{{AFX_MSG_MAP(CInitNamespaceDialog)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	ON_MESSAGE(INITIALIZE_INIT_NAMESPACE, InitNamespace )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInitNamespaceDialog message handlers

BEGIN_EVENTSINK_MAP(CInitNamespaceDialog, CDialog)
    //{{AFX_EVENTSINK_MAP(CInitNamespaceDialog)
	ON_EVENT(CInitNamespaceDialog, IDC_NSENTRYCTRLINITNAMESPACE, 3 /* GetIWbemServices */, OnGetIWbemServicesNsentryctrlinitnamespace, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

BOOL CInitNamespaceDialog::OnInitDialog()
{
	CDialog::OnInitDialog();
	m_cnseInitNamespace.SetLocalParent(m_pParent);
	m_cnseInitNamespace.ClearOnLoseFocus(0);

	CRect rectMove;
	CenterWindowInOwner(this,rectMove);

	SetWindowPos(&wndTop,
				rectMove.left,
				rectMove.top,
				rectMove.Width(),
				rectMove.Height(),
				SWP_NOSIZE | SWP_NOMOVE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CInitNamespaceDialog::OnOK()
{
		// TODO: Add extra validation here
		CWnd* pWndFocus = GetFocus();
	TCHAR szClass[140];
	int n = GetClassName(pWndFocus->m_hWnd, szClass, 139);

	CString csText = m_cnseInitNamespace.GetNamespaceText();
	csText.TrimLeft();
	csText.TrimRight();

	BSTR bstrNamespace = csText.AllocSysString();
	EnableWindow(FALSE);
	m_cnseInitNamespace.OpenNamespace(bstrNamespace, FALSE);
	EnableWindow(TRUE);
	SetFocus();
	SysFreeString(bstrNamespace);
}

void CInitNamespaceDialog::OnCancel()
{
	// TODO: Add extra cleanup here

	CDialog::OnCancel();

	m_pParent->PostMessage(SETFOCUSNSE,0,0);
}

void CInitNamespaceDialog::OnGetIWbemServicesNsentryctrlinitnamespace
(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
	// TODO: Add your control notification handler code here
	m_pParent->PassThroughGetIWbemServices
		(lpctstrNamespace,
		pvarUpdatePointer,
		pvarServices,
		pvarSC,
		pvarUserCancel);
}

void CInitNamespaceDialog::OnDestroy()
{
	m_bValid = m_cnseInitNamespace.IsTextValid();
	m_csNamespace = m_cnseInitNamespace.GetNamespaceText();


	CDialog::OnDestroy();

	// TODO: Add your message handler code here

}

BOOL CInitNamespaceDialog::PreTranslateMessage(MSG* lpMsg)
{
	// TODO: Add your specialized code here and/or call the base class
	switch (lpMsg->message)
	{
	case WM_KEYDOWN:
	case WM_KEYUP:
		if (lpMsg->wParam == VK_RETURN)
		{
			CWnd* pWndFocus = GetFocus();
			TCHAR szClass[140];
			int n = GetClassName(pWndFocus->m_hWnd, szClass, 139);

			if (pWndFocus &&
				IsChild(pWndFocus) &&
				n > 0 &&
				_tcsicmp(szClass, _T("EDIT")) == 0)
			{
				pWndFocus->SendMessage(lpMsg->message, lpMsg->wParam, lpMsg->lParam);
				return TRUE;
			}
		}
		if (lpMsg->wParam == VK_ESCAPE)
		{
			if (lpMsg->message == WM_KEYUP)
			{
				return TRUE;
			}
			PostMessage(WM_CLOSE, 0, 0);
			return TRUE;

		}

		break;
	}


	return CDialog::PreTranslateMessage(lpMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\editinput.cpp ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: EditInput.cpp
//
// Description:
//	This file implements the CEditInput class which is a subclass
//	of the MFC CEdit class.  It is a part of the Instance Explorer OCX,
//	and it performs the following functions:
//		a.  Is used to dynamically subclass the edit control in
//			the CNameSpace combo box class.  It only exists because
//			a carriage return is not seen by the edit control using
//			the normal mechanisms in the Internet Explorer.
//
// Part of:
//	Navigator.ocx
//
// Used by:
//	CNameSpace
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************
#include "precomp.h"
#include "Navigator.h"
#include "EditInput.h"
#include "NameSpace.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


BEGIN_MESSAGE_MAP(CEditInput, CEdit)
	//{{AFX_MSG_MAP(CEditInput)
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


// ***************************************************************************
//
// CEditInput::OnChar
//
// Description:
//	  Called by the framework to handle character input.  We use it to
//	  send a CNS_EDITDONE message to the CNameSpace combo box.
//
// Parameters:
//	  nChar		Contains the character code value of the key.
//	  nRepCnt   Contains the repeat count.
//	  nFlags	Contains the scan code, key-transition code, previous key
//				state, and context code.
//
// Returns:
// 	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CEditInput::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// TODO: Add your message handler code here and/or call default

	if (m_pParent && (nChar == 13))
	{
		m_pParent->SendMessage(CNS_EDITDONE,0,0);
	}

	CEdit::OnChar(nChar, nRepCnt, nFlags);
}

/*	EOF:  EditInput.cpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\editinput.h ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: EditInput.h
//
// Description:
//	This file declares the CEditInput class which is a subclass
//	of the MFC CEdit class.  It is a part of the Instance Explorer OCX, 
//	and it performs the following functions:
//		a.  Is used to dynamically subclass the edit control in
//			the CNameSpace combo box class.  It only exists because 
//			a carriage return is not seen by the edit control using
//			the normal mechanisms in the Internet Explorer. 
//
// Part of: 
//	Navigator.ocx 
//
// Used by:
//	CNameSpace 
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

//****************************************************************************
//
// CLASS:  CEditInput
//
// Description:
//	  This class which is a subclass of the MFC CEdit class.  It allows a 
//	  carriage return to bee seen by the edit control in the CNameSpace
//	  combo box.  When a carriage return is seen a CNS_EDITDONE message
//	  is sent to the combo box.
//
// Public members:
//	
//	  CEditInput		Public constructor.
//	  SetLocalParent	Initialize the member var that holds the CNameSpace
//						object. 
//
//============================================================================
//
// CEditInput::CEditInput
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  NONEnt
//
// Returns:
// 	  NONE
//
//============================================================================
//
// CEditInput::SetLocalParent
//
// Description:
//	  Initialize the member var that holds the CNameSpace  object. 
//
// Parameters:
//	  CNameSpace *pParent	 Containing CNameSpace object.		
//
// Returns:
// 	  VOID
//
//****************************************************************************

#ifndef _CEditInput_H_
#define _CEditInput_H_

class CNameSpace;


class CEditInput : public CEdit
{

public:
	CEditInput() {m_pParent = NULL;}
	void SetLocalParent(CNameSpace *pParent){m_pParent = pParent;}

protected:	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditInput)
	//}}AFX_VIRTUAL

	CNameSpace *m_pParent;
	//{{AFX_MSG(CEditInput)
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

#endif
/*	EOF:  EditInput.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\initnamespacensentry.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved


#include "precomp.h"
#include "resource.h"
#include "wbemidl.h"
#include "CInstanceTree.h"
#include "Navigator.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "InstanceSearch.h"
#include "NavigatorCtl.h"
#include "nsentry.h"
#include "InitNamespaceNSEntry.h"
#include "InitNamespaceDialog.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInitNamespaceNSEntry

IMPLEMENT_DYNCREATE(CInitNamespaceNSEntry,CNSEntry)

CInitNamespaceNSEntry::CInitNamespaceNSEntry()
{
	m_pParent = NULL;

}

BEGIN_MESSAGE_MAP(CInitNamespaceNSEntry, CNSEntry)
	//{{AFX_MSG_MAP(CInitNamespaceNSEntry)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BEGIN_EVENTSINK_MAP(CInitNamespaceNSEntry, CNSEntry)
    //{{AFX_EVENTSINK_MAP(CInitNamespaceNSEntry)
	ON_EVENT_REFLECT(CInitNamespaceNSEntry, 1 , OnNameSpaceChanged, VTS_BSTR VTS_BOOL)
	ON_EVENT_REFLECT(CInitNamespaceNSEntry, 2 , OnNameSpaceRedrawn, VTS_NONE)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

void CInitNamespaceNSEntry::OnNameSpaceRedrawn()
{
	m_pParent->InvalidateControl();
}


void CInitNamespaceNSEntry::OnNameSpaceChanged(LPCTSTR bstrNewNameSpace, BOOL boolValid)
{


	CInitNamespaceDialog *pParent =
		reinterpret_cast<CInitNamespaceDialog *>(GetParent());
	pParent->CDialog::OnOK();
	m_pParent->InvalidateControl();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\cinstancetree.h ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: CInstanceTree.h
//
// Description:
//	This file declares the CInstanceTree class and CTreeItemData.
//	The CInstanceTree class is a part of the Instance Navigator OCX, it
//  is a subclass of the Mocrosoft CTreeCtrl common control and performs
//	the following functions:
//		a.
//		b.
//		c.
//
// Part of:
//	Navigator.ocx
//
// Used by:
//
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
// **************************************************************************

#ifndef _CINSTANCETREE_H_
#define _CINSTANCETREE_H_


//****************************************************************************
//
// CLASS:  CInstanceTree
//
// Description:
//	  This class is a subclass of the Mocrosoft CTreeCtrl common control.  It
//	  specializes the common control to interact with the HMM database and
//	  display HMM instance data.
//
// Public members:
//
//	  PreCreateWindow	Called by the framework before the creation of
//						the Windows window attached to this CInstanceTree
//						object.
//	  InitTreeState		Initializes processing state for the tree control.
//	  ResetTree			Clear the domain state for the tree control.
//
//============================================================================
//
// CInstanceTree::PreCreateWindow
//
// Description:
//	  This VIRTUAL member function returns Initializes create struct values
//	  for the custom tree control.
//
// Parameters:
//	  CREATESTRUCT& cs	A reference to a CREATESTRUCT with default control
//						creation values.
//
// Returns:
// 	  BOOL				Nonzero if the window creation should continue;
//						0 to indicate creation failure.
//
//============================================================================
//
// CInstanceTree::InitTreeState
//
// Description:
//	  This function initializes processing state for the custom tree control.
//
// Parameters:
//	  CNavigatorCtrl *pParent	A CNavigatorCtrl pointer to the tree controls
//								parent window.
//
//  Returns:
//	  VOID				.
//
//============================================================================
//
// CInstanceTree::ResetTree
//
// Description:
//	  This function clears the domain state for the tree control.
//
// Parameters:
//	  VOID
//
// Returns:
//	  VOID				.
//
//****************************************************************************

//****************************************************************************
//
// CLASS:  CTreeItemData
//
// Description:
//	  This class is a subclass of the Microsoft CObject class.  It is used by
//	  the CInstanceTree class to maintain state attached to HTREEITEM tree
//	  items.  State data is:
//
//	  ItemDataType m_nType = ObjectInst:
//		  m_pimcoItem		is the object instance
//	  ItemDataType m_nType = ObjectGroup:
//		  m_pimcoItem		is the grouping class
//	  ItemDataType m_nType = AssocRole:
//		  m_pimcoItem		is the association class
//		  m_pcsMyRole		is the role of the parent object
//
// Public members:
//
//	  ItemDataType		Static enumeration of the types of nodes represented
//						by the tree item.
//	  m_nType			Int which holds the ItemTypeData.
//	  m_pimcoItem		Pointer to the IWbemClassObject represented by the
//						node.
//	  m_pcsMyRole		A CString which contains the role of the parent object
//						for an AssocRole node.  It is not used by other types.
//	  CTreeItemData		Default constructor.
//    ~CTreeItemData	Destructor.
//
//============================================================================
//
// CInstanceTree::CTreeItemData
//
// Description:
//	  This is the default constructor for the class.
//
// Parameters:
//	  int nType						The node type from ItemDataType.
//	  IWbemClassObject *pimcoItem	The IWbemClassObject represented by the node.
//	  CString *pcsMyRole			For a node of type AssocRole the role of the
//									parent object.
//
// Returns:
//	  NONE
//
//****************************************************************************

class CTreeItemData : public CObject
{
	DECLARE_DYNCREATE( CTreeItemData )
public:
	static enum ItemDataType {
			ObjectInst, ObjectGroup, AssocRole , None
		};
	int m_nType;
	CStringArray m_csaStrings;
	CString m_csMyRole;
	CString GetAt(int nItem);
	void Add(CString csAdd)
	{m_csaStrings.Add(csAdd);}
	int GetSize() {return (int) m_csaStrings.GetSize();}
	CTreeItemData	(
					int nType = CTreeItemData::None,
					CString *pcsPath = NULL,
					CString *pcsMyRole = NULL
					);

};

class CNavigatorCtrl;


class CInstanceTree : public CTreeCtrl
{
public:
	CInstanceTree();
	BOOL  PreCreateWindow(CREATESTRUCT& cs);
	void InitTreeState(CNavigatorCtrl *pParent);
	void ResetTree();
	CString GetHMOMObject(HTREEITEM hItem);
	void ContinueProcessSelection(UINT nFlags, CPoint point);
	long m_lSelection;
	UINT_PTR m_uiSelectionTimer;
protected:
	CNavigatorCtrl * m_pParent;
	CListBox *m_pclbFilter;
	int GetNumChildren(HTREEITEM hItem);

	// Used for extended selection of object instances in object groups
	//UINT m_nLBDFlags;		// Last Button Down Flags
	//CPoint m_cpLBDPoint;	// Last Button Down Point

	// Context Menu
	CMenu m_cmContext;

	// Tool Tips
	CToolTipCtrl m_ttip;
	CString m_csToolTipString;
	BOOL m_bReCacheTools;
	void RelayEvent(UINT message, WPARAM wParam, LPARAM lParam);
	// Tool Tip recaching
	void UnCacheTools();
	void UnCacheTools(HTREEITEM hItem);
	void ReCacheTools();
	void ReCacheTools(HTREEITEM hItem);

	HTREEITEM  InsertTreeItem(
			HTREEITEM hParent,
			LPARAM lparam,
			int iBitmap,
			int iSelectedBitmap,
			TCHAR *pText,
			BOOL bHasChildren,
			BOOL bBold = FALSE
		);

	HTREEITEM IsIWbemObjectInTreeAbove(
			HTREEITEM hItem,
			CString &rcsObject,
			int nType
		);

	BOOL IsTreeItemExpandable(HTREEITEM hItem);

	void OnItemExpanding(NMHDR *pNMHDR, LRESULT *pResult);
	void OnItemExpanded(NMHDR *pNMHDR, LRESULT *pResult);

	BOOL OnObjectInstExpanding(HTREEITEM hItem, CTreeItemData *pctidData);
	BOOL OnObjectInstExpanding2(HTREEITEM hItem, CTreeItemData *pctidData);

	void OnAssocRoleExpanding(HTREEITEM hItem, CTreeItemData *pctidData);
	void OnObjectGroupExpanding(HTREEITEM hItem, CTreeItemData *pctidData);


	HTREEITEM AddInitialObjectInstToTree(CString &csPath,BOOL bSendEvent = TRUE);
	HTREEITEM AddAssocRoleToTree(
				HTREEITEM hParent,
				CString &rcsAssocRole,
				CString &rcsRole ,
				CString &rcsMyRole,
				CStringArray *pcsaAssocPropsAndRoles,
				int nWeak
			);
	HTREEITEM AddObjectGroupToTree(
				HTREEITEM hParent,
				CString &csObjectGroup,
				CStringArray &csaInstances
			);
	void AddObjectGroupInstancesToTree(
				HTREEITEM hParent,
				CString &csObjectGroup,
				CStringArray &csaInstances
			);
	CStringArray *CInstanceTree::GetObjectInstancesForAssocRole(
				HTREEITEM hParent,
				IWbemServices * pProv,
				CString &rcsObjectInst,
				CString &rcsAssocClass,
				CString &rcsRole,
				CString &rcsResultRole,
				CString csCurrentNameSpace,
				CString &rcsAuxNameSpace,
				IWbemServices *&rpAuxServices,
				CNavigatorCtrl *pControl);
	BOOL ObjectGroupIsInTree(
				HTREEITEM hParent,
				CString &csObjectGroup);
	HTREEITEM AddObjectInstToTree(
				HTREEITEM hParent,
				CString &rcsObjectInst);
	void PartitionObjectInstances(
				CStringArray &rcsaAllObjectInstances,
				CStringArray &rcsaObjectGroups,
				CStringArray &rcsaObjectInstances);

	void AddGroupObjectInstancesToTree(
				HTREEITEM hParent,
				IWbemClassObject *pimcoObject,
				IWbemClassObject *pimcoAssoc,
				IWbemClassObject *pimcoGroupingObject,
				CString *pcsRole
				);

	void DeleteTreeItemData();
	void DeleteTreeItemData(HTREEITEM hItem);

	CString GetParentAssocFromTree(
				HTREEITEM hItem,
				HTREEITEM &hReturn
			);

	BOOL IsBackwardAssoc(
					CString &rcsObjectToFilter,
					CString &rcsAssocToFilter,
					CString &rcsAssocRoleToFilter,
					CString &rcsAssoc,
					CString &rcsTargetObject,
					CString &rcsTargetRole);

	CString GetObjectGroupInstancesQuery
		(HTREEITEM hItem, CTreeItemData *pctidData);

	CString GetObjectGroupInstancesQueryParentAssocRole
		(HTREEITEM hItem,
		CTreeItemData *pctidData,
		CTreeItemData *pctidAssocRole,
		HTREEITEM hParent);

	CString GetAssocRoleInstancesQuery
		(HTREEITEM hItem, CTreeItemData *pctidData);

	IEnumWbemClassObject *GetAssocClassesEnum
		(IWbemServices * pProv,
		CString &rcsInst,
		CString csCurrentNameSpace,
		CString &rcsAuxNameSpace,
		IWbemServices *&rpAuxServices,
		CNavigatorCtrl *pControl);

	IEnumWbemClassObject *GetAssocClassesEnum2
		(IWbemServices * pProv,
		CString &rcsInst,
		CString &rcsClass,
		CString csCurrentNameSpace,
		CString &rcsAuxNameSpace,
		IWbemServices *&rpAuxServices,
		CNavigatorCtrl *pControl);

	void GetDerivation
		(CStringArray *prgsz, IWbemServices * pProv,
		CString &rcsInst,
		CString &rcsClass,
		CString csCurrentNameSpace,
		CString &rcsAuxNameSpace,
		IWbemServices *&rpAuxServices,
		CNavigatorCtrl *pControl);

	CStringArray *GetAssocClasses
		(IWbemServices * pProv,
		IEnumWbemClassObject *pemcoAssocs ,
		CPtrArray *pcsaAssocPropsAndRoles,
		HRESULT &hResult,
		int nRes);

	CStringArray *GetAssocClasses2
		(IWbemServices * pProv,
		IEnumWbemClassObject *pemcoAssocs ,
		CPtrArray *pcsaAssocPropsAndRoles,
		HRESULT &hResult,
		int nRes,
		CStringArray *prgszDerivation);

	UINT_PTR m_uiTimer;
	BOOL m_bMouseDown;
	BOOL m_bKeyDown;
	BOOL m_bUseItem;
	HTREEITEM m_hItemToUse;



    //{{AFX_MSG(CInstanceTree)
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDestroy();
	afx_msg void OnSelchanging(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void SetUpInvalidate(UINT , LONG);
	afx_msg void OnKeydown(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
	afx_msg LRESULT SelectTreeItem(WPARAM, LPARAM);

    DECLARE_MESSAGE_MAP()

	friend class CNavigatorCtrl;

};

#endif	// _CINSTANCETREE_H_

/*	EOF:  CInstanceTree.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\initnamespacensentry.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __InstNavNSEntryX_H__
#define __InstNavNSEntryX_H__

class CNavigatorCtrl;

class CInitNamespaceNSEntry : public CNSEntry
{
protected:
	DECLARE_DYNCREATE(CInitNamespaceNSEntry)


	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInitNamespaceNSEntry)
	protected:
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CInitNamespaceNSEntry)
			afx_msg void OnNameSpaceChanged(LPCTSTR bstrNewNameSpace, BOOL boolValid);
			afx_msg void OnNameSpaceRedrawn();
		//	afx_msg void OnGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);
	//}}AFX_MSG
	
	DECLARE_EVENTSINK_MAP()
	DECLARE_MESSAGE_MAP()

public:
	CInitNamespaceNSEntry();
	void SetLocalParent(CNavigatorCtrl* pParent) 
		{	m_pParent = pParent;
		}
protected:
	CNavigatorCtrl* m_pParent;
};

#endif // __InstNavNSEntryX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\initnamespacedialog.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{AFX_INCLUDES()
#include "nsentry.h"
//}}AFX_INCLUDES
#if !defined(AFX_INITNAMESPACEDIALOG_H__6BB4B5F4_9356_11D1_966E_00C04FD9B15X__INCLUDED_)
#define AFX_INITNAMESPACEDIALOG_H__6BB4B5F4_9356_11D1_966E_00C04FD9B15X__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// InitNamespaceDialog.h : header file
//
class CNavigatorCtrl;
//class CInitNamespaceNSEntry;

/////////////////////////////////////////////////////////////////////////////
// CInitNamespaceDialog dialog

class CInitNamespaceDialog : public CDialog
{
// Construction
public:
	CInitNamespaceDialog(CWnd* pParent = NULL);   // standard constructor
	CString GetNamespace() {return m_csNamespace;}
// Dialog Data
	//{{AFX_DATA(CInitNamespaceDialog)
	enum { IDD = IDD_DIALOGINITNAMESPACE };
	CInitNamespaceNSEntry	m_cnseInitNamespace;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInitNamespaceDialog)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CNavigatorCtrl *m_pParent;
	CString m_csNamespace;
	BOOL m_bValid;
	BOOL m_bInit;
//	CInitNamespaceNSEntry *m_pNSEntry;
	// Generated message map functions
	//{{AFX_MSG(CInitNamespaceDialog)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnGetIWbemServicesNsentryctrlinitnamespace(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);
	afx_msg void OnDestroy();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	afx_msg LRESULT InitNamespace(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
	friend class CNavigatorCtrl;
	friend class CInitNamespaceNSEntry;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INITNAMESPACEDIALOG_H__6BB4B5F4_9356_11D1_966E_00C04FD9B15X__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\instancesearch.cpp ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: instancesearch.cpp
//
// Description:
//	This file implements the CInstanceSearch class which is a subclass
//	of the MFC CDialog class.  It is a part of the Instance Explorer OCX,
//	and it performs the following functions:
//		a.  Allows the user to enter an object path to be searched for.
//
// Part of:
//	Navigator.ocx
//
// Used by:
//	CNavigatorCtrl
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

#include "precomp.h"
#include "navigator.h"
#include "InstanceSearch.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//****************************************************************************
//
// CInstanceSearch::CInstanceSearch
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  CClassNavCtrl* pParent	Parent
//
// Returns:
// 	  NONE
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
CInstanceSearch::CInstanceSearch(CNavigatorCtrl* pParent  /*=NULL*/)
	: CDialog(CInstanceSearch::IDD, NULL)
{
	//{{AFX_DATA_INIT(CInstanceSearch)
	m_csClass = _T("");
	m_csKey = _T("");
	m_csValue = _T("");
	//}}AFX_DATA_INIT
	m_pParent = pParent;
}

// ***************************************************************************
//
// CInstanceSearch::DoDataExchange
//
// Description:
//	  Called by the framework to exchange and validate dialog data.
//
// Parameters:
//	  pDX			A pointer to a CDataExchange object.
//
// Returns:
// 	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CInstanceSearch::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInstanceSearch)
	DDX_Text(pDX, IDC_EDITClass, m_csClass);
	DDX_Text(pDX, IDC_EDITKEY, m_csKey);
	DDX_Text(pDX, IDC_EDITVALUE, m_csValue);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInstanceSearch, CDialog)
	//{{AFX_MSG_MAP(CInstanceSearch)
	ON_BN_CLICKED(IDOK, OnOK)
	ON_BN_CLICKED(IDCANCEL, OnCancel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/*	EOF:  instancesearch.cpp  */

void CInstanceSearch::OnOkreally()
{
	// TODO: Add your control notification handler code here
	CDialog::OnOK();
}

void CInstanceSearch::OnOK()
{
	TCHAR szClass[10];
	CWnd* pWndFocus = GetFocus();
	if (((pWndFocus = GetFocus()) != NULL) &&
		IsChild(pWndFocus) &&
		(pWndFocus->GetStyle() & ES_WANTRETURN) &&
		GetClassName(pWndFocus->m_hWnd, szClass, 10) &&
		(_tcsicmp(szClass, _T("EDIT")) == 0))
	{
		//m_cmeiMachine.SendMessage(WM_CHAR,VK_RETURN,0);
		return;
	}
	OnOkreally();


}

BOOL CInstanceSearch::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
	case WM_KEYUP:
      if (pMsg->wParam == VK_RETURN ||
		  pMsg->wParam == VK_ESCAPE)
      {
			TCHAR szClass[10];
			CWnd* pWndFocus = GetFocus();
			if ((pMsg->wParam == VK_RETURN) &&
				((pWndFocus = GetFocus()) != NULL) &&
				IsChild(pWndFocus) &&
				(pWndFocus->GetStyle() & ES_WANTRETURN) &&
				GetClassName(pWndFocus->m_hWnd, szClass, 10) &&
				(_tcsicmp(szClass, _T("EDIT")) == 0))
			{
				//pWndFocus->SendMessage(WM_CHAR, pMsg->wParam, pMsg->lParam);
				return TRUE;
			}
      }
      break;
	}
	return CDialog::PreTranslateMessage(pMsg);
}

void CInstanceSearch::OnCancel()
{
	// TODO: Add extra cleanup here
	TCHAR szClass[10];
	CWnd* pWndFocus = GetFocus();
	if (((pWndFocus = GetFocus()) != NULL) &&
		IsChild(pWndFocus) &&
		(pWndFocus->GetStyle() & ES_WANTRETURN) &&
		GetClassName(pWndFocus->m_hWnd, szClass, 10) &&
		(_tcsicmp(szClass, _T("EDIT")) == 0))
	{
		//m_cmeiMachine.SendMessage(WM_CHAR,VK_RETURN,0);
		return;
	}
	OnCancelReally();
}

void CInstanceSearch::OnCancelReally()
{
	CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\navigator.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Navigator.h : main header file for NAVIGATOR.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CNavigatorApp : See Navigator.cpp for implementation.

class CNavigatorApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\instnavnsentry.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __InstNavNSEntry_H__
#define __InstNavNSEntry_H__

class CNavigatorCtrl;

class CInstNavNSEntry : public CNSEntry
{
protected:
	DECLARE_DYNCREATE(CInstNavNSEntry)


	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInstNavNSEntry)
	protected:
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CInstNavNSEntry)
			afx_msg void OnNameSpaceChanged(LPCTSTR bstrNewNameSpace, long longValid);
			afx_msg void OnNameSpaceRedrawn();
			afx_msg void OnGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);
			afx_msg void OnRequestUIActive();
			afx_msg void OnChangeFocus(long lGettingFocus);
	//}}AFX_MSG
	
	DECLARE_EVENTSINK_MAP()
	DECLARE_MESSAGE_MAP()

public:
	CInstNavNSEntry();
	void SetLocalParent(CNavigatorCtrl* pParent) 
		{	m_pParent = pParent;
		}
protected:
	CNavigatorCtrl* m_pParent;
	BOOL m_bFirstTime;
};

#endif // __InstNavNSEntry_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\navigator.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Navigator.cpp : Implementation of CNavigatorApp and DLL registration.

#include "precomp.h"
#include "Navigator.h"
#include "cathelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CNavigatorApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xc7eadeb0, 0xecab, 0x11cf, { 0x8c, 0x9e, 0, 0xaa, 0, 0x6d, 0x1, 0xa } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


const GUID CDECL BASED_CODE _ctlid =   { 0xc7eadeb3, 0xecab, 0x11cf,
           { 0x8c, 0x9e, 0, 0xaa, 0, 0x6d, 0x1, 0xa} };

const CATID CATID_SafeForScripting     =
   {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing  =
   {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
////////////////////////////////////////////////////////////////////////////
// CNavigatorApp::InitInstance - DLL initialization

BOOL CNavigatorApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CNavigatorApp::ExitInstance - DLL termination

int CNavigatorApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	if (FAILED( CreateComponentCategory(CATID_SafeForScripting,
               L"Controls that are safely scriptable") ))
             return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( CreateComponentCategory(
           CATID_SafeForInitializing,
           L"Controls safely initializable from persistent data") ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForScripting) ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForInitializing) ))
         return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\instnavnsentry.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved


#include "precomp.h"
#include "resource.h"
#include "wbemidl.h"
#include "CInstanceTree.h"
#include "Navigator.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "InstanceSearch.h"
#include "NavigatorCtl.h"
#include "nsentry.h"
#include "InstNavNSEntry.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInstNavNSEntry

IMPLEMENT_DYNCREATE(CInstNavNSEntry,CNSEntry)

CInstNavNSEntry::CInstNavNSEntry()
{
	//m_bFirstTime = TRUE;
	m_bFirstTime = FALSE;

}

BEGIN_MESSAGE_MAP(CInstNavNSEntry, CNSEntry)
	//{{AFX_MSG_MAP(CInstNavNSEntry)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BEGIN_EVENTSINK_MAP(CInstNavNSEntry, CNSEntry)
    //{{AFX_EVENTSINK_MAP(CInstNavNSEntry)
	ON_EVENT_REFLECT(CInstNavNSEntry, 1 , OnNameSpaceChanged, VTS_BSTR VTS_I4)
	ON_EVENT_REFLECT(CInstNavNSEntry, 2 , OnNameSpaceRedrawn, VTS_NONE)
	ON_EVENT_REFLECT(CInstNavNSEntry, 3 , OnGetIWbemServices, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	ON_EVENT_REFLECT(CInstNavNSEntry,4,OnRequestUIActive,VTS_NONE)
	ON_EVENT_REFLECT(CInstNavNSEntry,5,OnChangeFocus,VTS_I4)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void CInstNavNSEntry::OnChangeFocus(long lGettingFocus)
{
	m_pParent->m_bRestoreFocusToTree = FALSE;
}

void CInstNavNSEntry::OnNameSpaceRedrawn()
{
	m_pParent->m_ctcTree.UpdateWindow();
	m_pParent->m_cbBannerWindow.NSEntryRedrawn();
	//m_pParent->PostMessage(INVALIDATE_CONTROL,0,0);
	//m_pParent->m_ctcTree.PostMessage(INVALIDATE_CONTROL,0,0);
}


void CInstNavNSEntry::OnNameSpaceChanged(LPCTSTR bstrNewNameSpace, long longValid)
{
	// TODO: Add your control notification handler code here
	if (!longValid)
	{
		m_pParent->InvalidateControl();
		return;
	}

	if (m_bFirstTime)
	{
		m_bFirstTime = FALSE;
		m_pParent-> PostMessage(INIT_TREE_FOR_DRAWING,0,0);
	}
	else
	{
		CString csNameSpace = bstrNewNameSpace;
		m_pParent->OpenNameSpace(&csNameSpace);
		m_pParent-> PostMessage(INIT_TREE_FOR_DRAWING,0,0);
	}

	m_pParent->InvalidateControl();
}


void CInstNavNSEntry::OnRequestUIActive()
{
	m_pParent->OnActivateInPlace(TRUE,NULL);
}

void CInstNavNSEntry::OnGetIWbemServices
(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
	m_pParent->PassThroughGetIWbemServices
		(lpctstrNamespace,
		pvarUpdatePointer,
		pvarServices,
		pvarSC,
		pvarUserCancel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\namespace.h ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: namespace.h
//
// Description:
//	This file declares the CNameSpace class which is a subclass
//	of the MFC CComboBox class.  It is a part of the Instance Explorer OCX,
//	and it performs the following functions:
//		a.  Displays a history of the namespaces either opened or
//			attempted to be opened
//		b.  Allows the user to select from the list of namespaces
//		c.  Allows the user to type in the namespace which will be added
//			to the history list.
//
// Part of:
//	Navigator.ocx
//
// Used by:
//	CBanner
//
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
// **************************************************************************

//****************************************************************************
//
// CLASS:  CNameSpace
//
// Description:
//	This class is a subclass of the MFC CComboBox class.  It displays a
//	history of the namespaces either opened or attempted to be opened, allows
//	the user to select from the list of namespaces and allows the user to type
//	in the namespace which will be added to the history list.
//
// Public members:
//
//	CNameSpace
//	SetParent
//	OnEditDone
//
//============================================================================
//	CNameSpace			Public constructor.
//	SetParent			Initialize parent.
//	OnEditDone			Handler for edit input.
//
//============================================================================
//
//  CNameSpace::CNameSpace
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  NONE
//
//============================================================================
//
//  CNameSpace::SetParent
//
// Description:
//	  Set the logical parent, which is the control.
//
// Parameters:
//	  CNavigatorCtrl *pParent		The control.
//
// Returns:
// 	  VOID
//
//============================================================================
//
//  CNameSpace::OnEditDone
//
// Description:
//	  Handler function which is invoked when editing of the edit control
//	  is done.
//
// Parameters:
//	  UINT				Not used.
//	  LONG				Not used.
//
// Returns:
// 	  long				0
//
//****************************************************************************


#ifndef _NAMESPACE_H_
#define _NAMESPACE_H_


class CNavigatorCtrl;
class CEditInput;

#define CNS_EDITDONE WM_USER + 13


class CNameSpace : public CComboBox
{
// Construction
public:
	CNameSpace(){m_bFirst = TRUE;}
	void SetParent(CNavigatorCtrl *pParent) {m_pParent = pParent;}

protected:
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNameSpace)
	//}}AFX_VIRTUAL

	CNavigatorCtrl *m_pParent;
	CString m_csNameSpace;
	CEditInput m_ceiInput;
	BOOL m_bFirst;
	CStringArray m_csaNameSpaceHistory;
	int StringInArray
		(CStringArray *prcsaArray, CString *pcsString, int nIndex);
	//{{AFX_MSG(CNameSpace)
	afx_msg void OnSelendok();
	afx_msg void OnDropdown();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	//}}AFX_MSG
public:
	afx_msg LRESULT OnEditDone(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()

private:
	friend class CNavigatorCtrl;
};

#endif
/*	EOF:  namespace.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\namespace.cpp ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: namespace.cpp
//
// Description:
//	This file implements the CNameSpace class which is a subclass
//	of the MFC CComboBox class.  It is a part of the Instance Explorer OCX,
//	and it performs the following functions:
//		a.  Displays a history of the namespaces either opened or
//			attempted to be opened
//		b.  Allows the user to select from the list of namespaces
//		c.  Allows the user to type in the namespace which will be added
//			to the history list.
//
// Part of:
//	Navigator.ocx
//
// Used by:
//	CBanner
//
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
// **************************************************************************
#include "precomp.h"
#include <stdlib.h>
#include "afxpriv.h"
#include "hmmsvc.h"
#include "resource.h"
#include "AFXCONV.H"
#include "OLEMSCLient.h"
#include "CInstanceTree.h"
#include "EditInput.h"
#include "NameSpace.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "InstanceSearch.h"
#include "NavigatorCtl.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CNameSpace, CComboBox)
	//{{AFX_MSG_MAP(CNameSpace)
	ON_CONTROL_REFLECT(CBN_SELENDOK, OnSelendok)
	ON_CONTROL_REFLECT(CBN_DROPDOWN, OnDropdown)
	ON_WM_CTLCOLOR()
	ON_MESSAGE( CNS_EDITDONE, OnEditDone )
	//}}AFX_MSG_MAP

END_MESSAGE_MAP()

// ***************************************************************************
//
// CNameSpace::OnSelendok
//
// Description:
//	  Handler for selecting an item from the combo box list.
//
// Parameters:
//	  NONE
//
// Returns:
//	  NONE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNameSpace::OnSelendok()
{

	if (m_csNameSpace.IsEmpty())
	{
		m_csNameSpace = m_pParent->GetCurrentNamespace();
		m_csaNameSpaceHistory.Add(m_csNameSpace);
	}

	CString csNameSpace;
	int nSelect = GetCurSel( );
	if (nSelect != CB_ERR )
	{
		GetLBText(nSelect,csNameSpace);
		SetWindowText(csNameSpace);
		if (m_csNameSpace.CompareNoCase(csNameSpace) != 0)
		{
			BOOL bOpened = m_pParent -> OpenNameSpace(&csNameSpace);
			if (bOpened)
			{
				m_csNameSpace = csNameSpace;
			}
			else
			{
				int nGoodNamespace =
					FindStringExact(-1,(LPCSTR) m_csNameSpace);
				SetCurSel( nGoodNamespace );
			}
		}
		int nIndex = StringInArray(&m_csaNameSpaceHistory,&csNameSpace,0);
		if (nIndex > 0)
		{
			m_csaNameSpaceHistory.RemoveAt(nIndex);
			m_csaNameSpaceHistory.InsertAt(0, csNameSpace);
		}
	}

}

// ***************************************************************************
//
//  CNameSpace::OnEditDone
//
// Description:
//	  Handler function which is invoked when editing ofthe edit control
//	  is done.
//
// Parameters:
//	  UINT				Not used.
//	  LONG				Not used.
//
// Returns:
// 	  long				0
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
LRESULT CNameSpace::OnEditDone(WPARAM, LPARAM)
{
	if (m_csNameSpace.IsEmpty())
	{
		m_csNameSpace = m_pParent->GetCurrentNamespace();
		m_csaNameSpaceHistory.Add(m_csNameSpace);
	}

	CString csNameSpace;
	GetWindowText(csNameSpace);

	if (m_csNameSpace.CompareNoCase(csNameSpace) != 0)
	{
		CWaitCursor cwcWait;
		int nFound = FindStringExact(-1, csNameSpace);
		if (nFound == CB_ERR)
		{
			int nReturn = InsertString(0,(LPCSTR) csNameSpace);
			m_csaNameSpaceHistory.Add(csNameSpace);
		}

		BOOL bOpened = m_pParent -> OpenNameSpace(&csNameSpace);
		if (bOpened)
		{

			m_csNameSpace = csNameSpace;
		}
		else
		{
			int nGoodNamespace =
					FindStringExact(-1,(LPCSTR) m_csNameSpace);
			SetCurSel( nGoodNamespace );
		}
		int nIndex = StringInArray(&m_csaNameSpaceHistory,&csNameSpace,0);
		if (nIndex > 0)
		{
			m_csaNameSpaceHistory.RemoveAt(nIndex);
			m_csaNameSpaceHistory.InsertAt(0, csNameSpace);
		}
		else if (nIndex == -1)
		{
			m_csaNameSpaceHistory.InsertAt(0, csNameSpace);
		}
		if (m_csaNameSpaceHistory.GetSize() == 21)
		{
			m_csaNameSpaceHistory.RemoveAt(20);
		}
	}

	return 0;
}

// ***************************************************************************
//
//  CNameSpace::OnDropDown
//
// Description:
//	  Handler function which is invoked when the combo box's list is
//	  dropped down.  It builds the list from the history list.
//
// Parameters:
//	  NONE
//
// Returns:
// 	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNameSpace::OnDropdown()
{
	CWaitCursor wait;

	if (m_csNameSpace.IsEmpty())
	{
		m_csNameSpace = m_pParent->GetCurrentNamespace();
		m_csaNameSpaceHistory.Add(m_csNameSpace);
	}

	int n = GetCount() - 1;

	while (n > -1)
	{
		DeleteString(n);
		n--;
	}

	int i;
	int nNameSpaces = m_csaNameSpaceHistory.GetSize();
	for (i = 0; i < nNameSpaces;i++)
	{
		AddString(m_csaNameSpaceHistory.GetAt(i));
	}


	CString csEINameSpace;
	GetWindowText(csEINameSpace);

	if (csEINameSpace.GetLength() == 0)
	{
		csEINameSpace = m_csNameSpace;
	}

	int nFound =
				FindString(-1, csEINameSpace);

	if (nFound !=  CB_ERR)
	{

		SelectString
			( -1, (LPCSTR) csEINameSpace);

	}

	CRect crParent;
	m_pParent -> m_cbBannerWindow.GetWindowRect(&crParent);
	crParent.NormalizeRect();

	CRect crMe;
	GetWindowRect(&crMe);
	crMe.NormalizeRect();

	int nWidth = crParent.Width();
	int nLeft = crMe.TopLeft().x - crParent.TopLeft().x;
	int nAbsoluteMax =  nWidth > nLeft ? nWidth - nLeft : nLeft - nWidth;

	CRect crClient;
	GetClientRect( &crClient);
	crClient.NormalizeRect();


	int nMax = crClient.Width();

	for (i = 0; i < m_csaNameSpaceHistory.GetSize(); i++)
	{
		int nWidth =
			m_pParent->m_cbBannerWindow.GetTextLength(&m_csaNameSpaceHistory.GetAt(i));
		nWidth+=10;
		if (nMax < nWidth)
		{
			nMax = nWidth;
		}

	}

	if (nMax > nAbsoluteMax)
	{
		nMax = nAbsoluteMax;
	}

	SetDroppedWidth(nMax);

	if (m_csaNameSpaceHistory.GetSize() > 5)
	{
		int nReturn = ModifyStyle( 0, WS_VSCROLL ,  0 );
	}
}

// ***************************************************************************
//
// CNameSpace::StringInArray
//
// Description:
//	  Check to see if a CString is in a CStringArray starting at a specified
//	  index.
//
// Parameters:
//	  CStringArray *pcsaArray	Array to search
//	  CString *pcsString		CString to look for (by content)
//	  int nIndex				Starting at index
//
// Returns:
// 	  int						Index if found; otherwise -1
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
int CNameSpace::StringInArray
(CStringArray *pcsaArray, CString *pcsString, int nIndex)
{
	int nSize = pcsaArray->GetSize();

	for (int i = nIndex; i < nSize; i++)
	{
		if (pcsString->CompareNoCase(pcsaArray->GetAt(i)) == 0)
		{
			return i;
		}
	}
	return -1;
}

// ***************************************************************************
//
// CNameSpace::OnCtlColor
//
// Description:
//	  Called by the framework to give a window a chance to set the brush
//	  used to paint the backgound color.  We use it to dynamically subclass
//	  the edit contol.
//
// Parameters:
//	  pDC			Not used.
//	  pWnd			Contains a pointer to the control asking for the color.
//	  nCtlColor		Specifies the control.
//
// Returns:
// 	  HBRUSH		The brush passed in.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
HBRUSH CNameSpace::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	HBRUSH hbr = CComboBox::OnCtlColor(pDC, pWnd, nCtlColor);

	// TODO: Change any attributes of the DC here
	if (m_bFirst && (nCtlColor == CTLCOLOR_EDIT))
	{
		m_ceiInput.SubclassWindow(pWnd->m_hWnd);
		m_ceiInput.SetLocalParent(this);
		m_bFirst = FALSE;
	}

	// TODO: Return a different brush if the default is not desired
	return hbr;
}


/*	EOF:  namespace.cpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\instancesearch.h ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: instancesearch.h
//
// Description:
//	This file declares the CInstanceSearch class which is a subclass
//	of the MFC CDialog class.  It is a part of the Instance Explorer OCX, 
//	and it performs the following functions:
//		a.  Allows the user to enter an object path to be searched for.
//
// Part of: 
//	Navigator.ocx 
//
// Used by:
//	CNavigatorCtrl
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

//****************************************************************************
//
// CLASS:  CInstanceSearch
//
// Description:
//	  This class which is a subclass of the MFC CDialog class.  It allows the 
//	  user to enter an object path that is used to search for the instance
//	  represented by that object path.
//
// Public members:
//	
//	  CInstanceSearch		Public constructor.
//	  m_csPath				Instance path.
//
//============================================================================
//
// CInstanceSearch::CInstanceSearch
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  CClassNavCtrl* pParent	Parent
//
// Returns:
// 	  NONE
//
//****************************************************************************

#ifndef _CInstanceSearch_H_
#define _CInstanceSearch_H_

class CNavigatorCtrl;

class CInstanceSearch : public CDialog
{
// Construction
public:
	CInstanceSearch(CNavigatorCtrl* pParent = NULL);   // standard constructor

	//{{AFX_DATA(CInstanceSearch)
	enum { IDD = IDD_DIALOGSEARCHFORINSTANCE };
	CString	m_csClass;
	CString	m_csKey;
	CString	m_csValue;
	//}}AFX_DATA

protected:

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInstanceSearch)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	CNavigatorCtrl *m_pParent;
	// Generated message map functions
	//{{AFX_MSG(CInstanceSearch)

	afx_msg void OnOK();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void OnCancelReally();
	void OnOkreally();
};

#endif

/*	EOF:  instancesearch.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\navigatorctl.cpp ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: NavigatorCtl.cpp
//
// Description:
//	This file implements the CNavigatorCtrl ActiveX control class.
//	The CNavigatorCtl class is a part of the Instance Navigator OCX, it
//  is a subclass of the Mocrosoft COleControl class and performs
//	the following functions:
//		a.
//		b.
//		c.
//
// Part of:
//	Navigator.ocx
//
// Used by:
//
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
// **************************************************************************

// ===========================================================================
//
//	Includes
//
// ===========================================================================
//   \\PEPPER\root\DEFAULT:Win32ComputerSystem.Name="PEPPER"
#include "precomp.h"
#include <OBJIDL.H>
#include "resource.h"
#include "wbemidl.h"
#include "CInstanceTree.h"
#include "Navigator.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "InstanceSearch.h"
#include "AvailClasses.h"
#include "AvailClassEdit.h"
#include "SelectedClasses.h"
#include "SimpleSortedCStringArray.h"
#include "BrowseforInstances.h"
#include "nsentry.h"
#include "InstNavNSEntry.h"
#include "InitNamespaceNSEntry.h"
#include "InitNamespaceDialog.h"
#include "NavigatorCtl.h"
#include "NavigatorPpg.h"
#include "PathDialog.h"
#include "ProgDlg.h"
#include "OLEMSCLient.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>



// ===========================================================================
//
//	Externs
//
// ===========================================================================

extern CNavigatorApp NEAR theApp;


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// ===========================================================================
//
//	Dynamic creation
//
// ===========================================================================

IMPLEMENT_DYNCREATE(CNavigatorCtrl, COleControl)
IMPLEMENT_DYNCREATE (CTreeItemData, CObject)

// ===========================================================================
//
//	Message map
//
// ===========================================================================

BEGIN_MESSAGE_MAP(CNavigatorCtrl, COleControl)
	//{{AFX_MSG_MAP(CNavigatorCtrl)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_DESTROY()
	ON_COMMAND(ID_SETROOT, OnSetroot)
	ON_UPDATE_COMMAND_UI(ID_SETROOT, OnUpdateSetroot)
	ON_COMMAND(ID_POPUP_MULTIINSTANCEVIEWER, OnPopupMultiinstanceviewer)
	ON_UPDATE_COMMAND_UI(ID_POPUP_MULTIINSTANCEVIEWER, OnUpdatePopupMultiinstanceviewer)
	ON_WM_GETDLGCODE()
	ON_COMMAND(ID_POPUP_INSTANCESEARCH, OnPopupInstancesearch)
	ON_COMMAND(ID_POPUP_PARENTASSOCIATION, OnPopupParentassociation)
	ON_UPDATE_COMMAND_UI(ID_POPUP_PARENTASSOCIATION, OnUpdatePopupParentassociation)
	ON_MESSAGE( ID_MULTIINSTANCEVIEW, SendInstancesToMultiInstanceViewer )
	ON_MESSAGE( ID_SETTREEROOT , SetNewRoot)
	ON_MESSAGE( INIT_TREE_FOR_DRAWING, InitializeTreeForDrawing)
	ON_WM_LBUTTONUP()
	ON_COMMAND(ID_POPUP_BROWSE, OnPopupBrowse)
	ON_UPDATE_COMMAND_UI(ID_POPUP_BROWSE, OnUpdatePopupBrowse)
	ON_COMMAND(ID_POPUP_GOTONAMESPACE, OnPopupGotonamespace)
	ON_UPDATE_COMMAND_UI(ID_POPUP_GOTONAMESPACE, OnUpdatePopupGotonamespace)
	ON_COMMAND(ID_POPUP_REFRESH, OnPopupRefresh)
	ON_UPDATE_COMMAND_UI(ID_POPUP_REFRESH, OnUpdatePopupRefresh)
	ON_COMMAND(ID_MENUITEMINITIALROOT, OnMenuiteminitialroot)
	ON_UPDATE_COMMAND_UI(ID_MENUITEMINITIALROOT, OnUpdateMenuiteminitialroot)
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
	ON_MESSAGE(INITIALIZE_NAMESPACE, InitializeNamespace )
	ON_MESSAGE(INVALIDATE_CONTROL, Invalidate)
	ON_MESSAGE(REDRAW_CONTROL, RedrawAll)
	ON_MESSAGE(SETFOCUS, SetFocus)
	ON_MESSAGE(SETFOCUSNSE, SetFocusNSE)
END_MESSAGE_MAP()


// ===========================================================================
//
//	Dispatch map
//
// ===========================================================================

BEGIN_DISPATCH_MAP(CNavigatorCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CNavigatorCtrl)
	DISP_PROPERTY_EX(CNavigatorCtrl, "NameSpace", GetNameSpace, SetNameSpace, VT_BSTR)
	DISP_FUNCTION(CNavigatorCtrl, "OnReadySignal", OnReadySignal, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CNavigatorCtrl, "ChangeRootOrNamespace", ChangeRootOrNamespace, VT_I4, VTS_BSTR VTS_I4 VTS_I4)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CNavigatorCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()

// ===========================================================================
//
//	Event map
//
// ===========================================================================

BEGIN_EVENT_MAP(CNavigatorCtrl, COleControl)
	//{{AFX_EVENT_MAP(CNavigatorCtrl)
	EVENT_CUSTOM("NotifyOpenNameSpace", FireNotifyOpenNameSpace, VTS_BSTR)
	EVENT_CUSTOM("ViewObject", FireViewObject, VTS_BSTR)
	EVENT_CUSTOM("ViewInstances", FireViewInstances, VTS_BSTR  VTS_VARIANT)
	EVENT_CUSTOM("QueryViewInstances", FireQueryViewInstances, VTS_BSTR  VTS_BSTR  VTS_BSTR  VTS_BSTR)
	EVENT_CUSTOM("GetIWbemServices", FireGetIWbemServices, VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()

// ===========================================================================
//
//	Property Pages
//
// ===========================================================================

BEGIN_PROPPAGEIDS(CNavigatorCtrl, 1)
	PROPPAGEID(CNavigatorPropPage::guid)
END_PROPPAGEIDS(CNavigatorCtrl)

// ===========================================================================
//
//	Class factory and guid
//
// ===========================================================================

IMPLEMENT_OLECREATE_EX(CNavigatorCtrl, "WBEM.InstNavCtrl.1",
	0xc7eadeb3, 0xecab, 0x11cf, 0x8c, 0x9e, 0, 0xaa, 0, 0x6d, 0x1, 0xa)

// ===========================================================================
//
//	Type library ID and version
//
// ===========================================================================

IMPLEMENT_OLETYPELIB(CNavigatorCtrl, _tlid, _wVerMajor, _wVerMinor)


// ===========================================================================
//
//	Interface IDs
//
// ===========================================================================

const IID BASED_CODE IID_DNavigator =
		{ 0xc7eadeb1, 0xecab, 0x11cf, { 0x8c, 0x9e, 0, 0xaa, 0, 0x6d, 0x1, 0xa } };
const IID BASED_CODE IID_DNavigatorEvents =
		{ 0xc7eadeb2, 0xecab, 0x11cf, { 0x8c, 0x9e, 0, 0xaa, 0, 0x6d, 0x1, 0xa } };

// ===========================================================================
//
//	Control type information
//
// ===========================================================================

static const DWORD BASED_CODE _dwNavigatorOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CNavigatorCtrl, IDS_NAVIGATOR, _dwNavigatorOleMisc)


// ===========================================================================
//
//	Control font height
//
// ===========================================================================

#define CY_FONT 15

// ***************************************************************************
//
// CNavigatorCtrl::CNavigatorCtrlFactory::UpdateRegistry
//
// Description:
//	  Adds or removes system registry entries for CNavigatorCtrl.
//
// Parameters:
//	  BOOL bRegister			Register if TRUE; Unregister if FALSE.
//
// Returns:
//	  BOOL					TRUE on success
//								FALSE on failure
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
BOOL CNavigatorCtrl::CNavigatorCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to afxRegInsertable.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_NAVIGATOR,
			IDB_NAVIGATOR,
			afxRegInsertable | afxRegApartmentThreading,
			_dwNavigatorOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

// ***************************************************************************
//
// CNavigatorCtrl::CNavigatorCtrlFactory::OnCreateObject
//
// Description:
//	  Called by the framework to create a new object. Override this function to
//	  create the object from something other than the CRuntimeClass passed to the
//	  constructor.  Stub generated by the OLE control wizard.
//
//
// Parameters:
//	  NONE
//
// Returns:
//	  CCmdTarget*					Pointer to object created.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CCmdTarget* CNavigatorCtrl::CNavigatorCtrlFactory::OnCreateObject()
{
	return COleObjectFactory::OnCreateObject();
}


// ***************************************************************************
//
// CNavigatorCtrl::CNavigatorCtrl
//
// Description:
//	  Class constructor.
//
// Parameters:
//	  NONE
//
// Returns:
//	  NONE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CNavigatorCtrl::CNavigatorCtrl()
{
	InitializeIIDs(&IID_DNavigator, &IID_DNavigatorEvents);

	m_bInit = FALSE;
	m_bChildrenCreated = FALSE;
	m_pcilImageList = NULL;
	m_nOffset = 2;
	m_bMetricSet = FALSE;
	m_pcbiBrowseDialog = NULL;
	m_pProgressDlg = NULL;
	m_bDrawAll = FALSE;
	m_csBanner = _T("Objects in: ");
	m_pctidHit = NULL;
	m_pServices = NULL;
	m_bFirstDraw = TRUE;
	m_pServices = NULL;
	m_pAuxServices = NULL;
	m_bInOnDraw = FALSE;
	m_bUserCancelInitialSystemObject = FALSE;
	m_bUserCancel = FALSE;
	m_bOpeningNamespace = FALSE;
	m_bTreeEmpty = TRUE;
	m_csFontName = _T("MS Shell Dlg");
	m_nFontHeight = CY_FONT;
	m_nFontWeigth = FW_NORMAL;
	m_bRefresh = FALSE;
	m_bFireEvents = TRUE;
	m_bRestoreFocusToTree = TRUE;
	m_bReadySignal = FALSE;

	AfxEnableControlContainer();

}

// ***************************************************************************
//
// CNavigatorCtrl::~CNavigatorCtrl
//
// Description:
//	  Class destructor.
//
// Parameters:
//	  NONE
//
// Returns:
//	  NONE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CNavigatorCtrl::~CNavigatorCtrl()
{
	delete m_pcbiBrowseDialog;
	delete m_pProgressDlg;

	if (m_pServices)
	{
		m_pServices -> Release();
	}

	if (m_pAuxServices)
	{
		m_pAuxServices -> Release();
	}

	m_bInit = FALSE;
	m_pcilImageList = NULL;
	m_nOffset = 2;
	m_bMetricSet = FALSE;
//	m_ppdPathDialog = NULL;
	m_pctidHit = NULL;

}

// ***************************************************************************
//
// CNavigatorCtrl::OnDraw
//
// Description:
//	  Drawing member function for screen device.
//
// Parameters:
//	  CDC *pDC			The device context in which the drawing occurs.
//	  CRect &rcBounds	The rectangular area of the control, including the
//						border.
//	CRect &rcInvalid	The rectangular area of the control that is invalid.
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNavigatorCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	if (m_bInOnDraw)
	{
		return;
	}

	if (GetSafeHwnd()) {
		CBrush br3DFACE(GetSysColor(COLOR_3DFACE));
		pdc->FillRect(rcBounds, &br3DFACE);
	}

	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	COLORREF dwBackColor = GetSysColor(COLOR_3DFACE);
	COLORREF crWhite = RGB(255,255,255);
	COLORREF crGray = GetSysColor(COLOR_3DHILIGHT);
	COLORREF crDkGray = GetSysColor(COLOR_3DSHADOW);
	COLORREF crBlack = GetSysColor(COLOR_WINDOWTEXT);

	if (m_bUserCancelInitialSystemObject || m_bUserCancel)
	{
		m_bUserCancelInitialSystemObject = FALSE;
		CRect rcOutline(rcBounds);

		rcOutline = m_rTreeRect;
		pdc -> Draw3dRect(&rcOutline, crBlack, crGray);

		return;

	}

	m_bInOnDraw = TRUE;

	if (!AmbientUserMode() || !GetSafeHwnd())
	{
		m_bInOnDraw = FALSE;
		return;
	}


	if (m_bDrawAll == FALSE)
	{
		CRect rcOutline(rcBounds);
		rcOutline = m_rBannerRect;

		rcOutline = m_rTreeRect;
		pdc -> Draw3dRect(&rcOutline, crBlack, crGray);
	}
	else
	{
		CFont* pOldFont;

		if (m_bFirstDraw)
		{
			m_bFirstDraw = FALSE;
			CWnd::SetFont ( &m_cfFont , FALSE);
			pOldFont = pdc -> SelectObject( &m_cfFont );
			InitializeChildControlSize(rcBounds.Width(), rcBounds.Height());
		}

		pOldFont = pdc -> SelectObject( &m_cfFont );


		CRect rcOutline(rcBounds);
		rcOutline = m_rBannerRect;

		rcOutline = m_rTreeRect;
		pdc -> Draw3dRect(&rcOutline, crBlack, crGray);

		pdc->SelectObject(pOldFont);

		m_ctcTree.ShowWindow(SW_SHOW);
		m_cbBannerWindow.ShowWindow(SW_SHOW);
	}


	if (m_ctcTree.GetRootItem() == NULL && !m_bTreeEmpty)
	{
		PostMessage(INIT_TREE_FOR_DRAWING,0,0);
	}
	else
	{
		InitializeTreeForDrawing(TRUE);

	}

	m_cbBannerWindow.ShowWindow(SW_SHOWNA);
	m_ctcTree.ShowWindow(SW_SHOWNA);

	if (m_bRefresh)
	{
		PostMessage(REDRAW_CONTROL,0,0);
	}

	m_bInOnDraw = FALSE;

}

void CNavigatorCtrl::CreateControlFont()
{
	if (!m_bMetricSet) // Create the font used by the control.
	{
		CDC *pdc = CWnd::GetDC( );

		pdc -> SetMapMode (MM_TEXT);
		pdc -> SetWindowOrg(0,0);

		LOGFONT lfFont;
		InitializeLogFont
			(lfFont, m_csFontName,m_nFontHeight, m_nFontWeigth);

		m_cfFont.CreateFontIndirect(&lfFont);

		CWnd::SetFont ( &m_cfFont , FALSE);
		CFont* pOldFont = pdc -> SelectObject( &m_cfFont );
		pdc->GetTextMetrics(&m_tmFont);
		pdc -> SelectObject(pOldFont);

		m_bMetricSet = TRUE;

		ReleaseDC(pdc);
	}

}

void CNavigatorCtrl::InitializeLogFont
(LOGFONT &rlfFont, CString csName, int nHeight, int nWeight)
{
	_tcscpy(rlfFont.lfFaceName, (LPCTSTR) csName);
	rlfFont.lfWeight = nWeight;
	rlfFont.lfHeight = nHeight;
	rlfFont.lfWidth = 0;
	rlfFont.lfQuality = DEFAULT_QUALITY;
	rlfFont.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
	rlfFont.lfEscapement = 0;
	rlfFont.lfOrientation = 0;
	rlfFont.lfWidth = 0;
	rlfFont.lfItalic = FALSE;
	rlfFont.lfUnderline = FALSE;
	rlfFont.lfStrikeOut = FALSE;
	rlfFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
	rlfFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
}

LRESULT CNavigatorCtrl::InitializeTreeForDrawing(WPARAM wParam, LPARAM lParam)
{
	if (!m_ctcTree.GetRootItem() && !m_bTreeEmpty)
	{
		InitializeTreeForDrawing();
	}
	else
	{
		InvalidateControl();
	}



	return 0;
}

void CNavigatorCtrl::InitializeTreeForDrawing(BOOL bNoTreeRoot)
{

	if (!m_bInit)
	{
		m_bInit = TRUE;

		int iReturn;

		HICON hIconOpen = theApp.LoadIcon(IDI_ICONOPEN);
		HICON hIconClosed = theApp.LoadIcon(IDI_ICONCLOSED);
		HICON hIconInstance = theApp.LoadIcon(IDI_ICONINSTANCE);
		HICON hIconNEInstance = theApp.LoadIcon(IDI_ICONNEINSTANCE);
		HICON hIconGroup = theApp.LoadIcon(IDI_ICONGROUP);
		HICON hIconEGroup = theApp.LoadIcon(IDI_ICONEGROUP);
		HICON hIconAssocRole = theApp.LoadIcon(IDI_ICONASSOCROLE);
		HICON hIconEAssocRole = theApp.LoadIcon(IDI_ICONEASSOCROLE);
		HICON hIconAssocInstance = theApp.LoadIcon(IDI_ICONASSOCINSTANCE);
		HICON hIconClass = theApp.LoadIcon(IDI_ICONCLASS);
		HICON hIconAssocRoleWeak = theApp.LoadIcon(IDI_ICONASSOCROLEWEAK);
		HICON hIconAssocRoleWeak2 = theApp.LoadIcon(IDI_ICONASSOCROLEWEAK2);

		m_pcilImageList = new CImageList();

		m_pcilImageList ->
			Create(16, 16, TRUE, IconClass(), IconClass());

		iReturn = m_pcilImageList -> Add(hIconInstance);
		iReturn = m_pcilImageList -> Add(hIconNEInstance);
		iReturn = m_pcilImageList -> Add(hIconGroup);
		iReturn = m_pcilImageList -> Add(hIconEGroup);
		iReturn = m_pcilImageList -> Add(hIconAssocRole);
		iReturn = m_pcilImageList -> Add(hIconEAssocRole);
		iReturn = m_pcilImageList -> Add(hIconAssocInstance);
		iReturn = m_pcilImageList -> Add(hIconOpen);
		iReturn = m_pcilImageList -> Add(hIconClosed);
		iReturn = m_pcilImageList -> Add(hIconClass);
		iReturn = m_pcilImageList -> Add(hIconAssocRoleWeak);
		iReturn = m_pcilImageList -> Add(hIconAssocRoleWeak2);

		// This image list is maintained by the ctreectrl.
		CImageList *pcilOld  = m_ctcTree.CTreeCtrl::SetImageList
			(m_pcilImageList,TVSIL_NORMAL);
		delete pcilOld;

	}

	if (!bNoTreeRoot)
	{
		InitializeTreeRoot();
	}


}

void CNavigatorCtrl::InitializeTreeRoot()
{
	// Add the root to the tree.
	CString csRoot;
	IWbemClassObject *pimcoRoot = NULL;

	if (m_bOpeningNamespace)
	{
		return;
	}

	if (m_csRootPath.GetLength() == 0)
	{
		csRoot = GetInitialSystemObject();
		if (csRoot.GetLength() == 0)
		{
			m_ctcTree.ResetTree();
			InvalidateControl();
		}
		else
		{
			m_csRootPath = csRoot;
		}
	}
	else
	{

		pimcoRoot = GetIWbemObject
		(this,m_pServices,
		GetCurrentNamespace(),
		GetAuxNamespace(),
		GetAuxServices(),
		m_csRootPath,FALSE);


		if (!pimcoRoot)
		{
			csRoot = GetInitialSystemObject();
			if (csRoot.GetLength() == 0)
			{
				m_ctcTree.ResetTree();
				InvalidateControl();
			}
			else
			{
				m_csRootPath = GetIWbemFullPath(m_pServices, pimcoRoot);
			}
		}
	}

	if (m_csRootPath.GetLength() == 0)
	{
		m_bDrawAll = TRUE;
		InvalidateControl();
		return;
	}

	if (pimcoRoot)
	{
		pimcoRoot->Release();
	}

	m_ctcTree.AddInitialObjectInstToTree
		(m_csRootPath);

	m_bDrawAll = TRUE;
	InvalidateControl();


}

CString CNavigatorCtrl::GetInitialSystemObject()
{

	if (!m_pcbiBrowseDialog)
	{
		if (m_pServices == NULL)
		{
			PostMessage(INITIALIZE_NAMESPACE,0,0);
		}
		PostMessage(INIT_TREE_FOR_DRAWING,0,0);
		InvalidateControl();
		return "";
	}
	else if (m_pcbiBrowseDialog->GetSafeHwnd())
	{
		return "";
	}
	else if (!m_pServices)
	{
		return "";
	}



	CString csRootObjectPath = _T("NamespaceConfiguration");
	CPtrArray *pInstances =
		GetInstances(m_pServices, &csRootObjectPath, m_csNameSpace, FALSE, TRUE);

	CString csSpecifiedPath;

	int i;
	for (i = 0; i < pInstances->GetSize(); i++)
	{
		IWbemClassObject *pObject =
			reinterpret_cast<IWbemClassObject *>
				(pInstances->GetAt(i));
		if (i == 0)
		{
			CString csProp = _T("BrowserRootPath");
			csSpecifiedPath =
					GetBSTRProperty
						(pObject, &csProp);
		}
		pObject ->Release();
	}

	delete pInstances;

	if (!csSpecifiedPath.IsEmpty())
	{
		m_bTreeEmpty = FALSE;
		return csSpecifiedPath;
	}

	CString csDefault = _T("CIM_ComputerSystem");
	pInstances =
		GetInstances(m_pServices, &csDefault, m_csNameSpace, TRUE, TRUE);

	for (i = 0; i < pInstances->GetSize(); i++)
	{
		IWbemClassObject *pObject =
			reinterpret_cast<IWbemClassObject *>
				(pInstances->GetAt(i));
		if (i == 0)
		{
			csSpecifiedPath =
					GetIWbemFullPath
						(m_pServices,pObject);
		}
		pObject ->Release();
	}

	delete pInstances;

	if (!csSpecifiedPath.IsEmpty())
	{
		m_bTreeEmpty = FALSE;
		SCODE sc = CreateNamespaceConfigClassAndInstance
			(m_pServices,&m_csNameSpace, &csSpecifiedPath);
		return csSpecifiedPath;
	}

	PreModalDialog();

	m_pcbiBrowseDialog->SetServices(m_pServices);
	m_pcbiBrowseDialog->SetTMFont(&m_tmFont);
	m_pcbiBrowseDialog->SetParent(this);
	m_pcbiBrowseDialog->SetMode(CBrowseforInstances::InitialObject);
	m_pcbiBrowseDialog->DoModal();
	m_ctcTree.SetFocus();

	PostModalDialog();

	if (m_pcbiBrowseDialog -> m_csSelectedInstancePath.IsEmpty())
	{
		m_bTreeEmpty = TRUE;
		m_ctcTree.UnCacheTools();
		m_ctcTree.ResetTree();
		m_bUserCancelInitialSystemObject = TRUE;
		InvalidateControl();
		return _T("");
	}
	else
	{
		csSpecifiedPath =
			m_pcbiBrowseDialog -> m_csSelectedInstancePath;
		m_bTreeEmpty = FALSE;
		SCODE sc = CreateNamespaceConfigClassAndInstance
			(m_pServices,&m_csNameSpace, &csSpecifiedPath);
		return csSpecifiedPath;
	}


}



BOOL CNavigatorCtrl::OpenNameSpace(CString *pcsNameSpace)
{

	IWbemServices *pServices = InitServices(pcsNameSpace);

	if (pServices)
	{
		if (m_pServices)
		{
			m_pServices -> Release();
		}
		m_pServices = pServices;
		m_csNameSpace = *pcsNameSpace;
		if (m_bReadySignal)
		{
			FireNotifyOpenNameSpace(*pcsNameSpace);
		}
		CString csRoot = GetInitialSystemObject();
		SetNewRoot(csRoot);
		PostMessage(INVALIDATE_CONTROL,0,0);
		return TRUE;
	}
	else
	{
		CString csPrompt = _T("Cannot open ") + *pcsNameSpace +
							_T(".  ");
		int nReturn =
			MessageBox
			(
			csPrompt,
			_T("Namespace Open Error"),
			MB_OK  | 	MB_ICONEXCLAMATION | MB_DEFBUTTON1 |
			MB_APPLMODAL);
		InvalidateControl();
		return FALSE;
	}


}

// ***************************************************************************
//
// CNavigatorCtrl::OnDrawMetafile
//
// Description:
//	  Drawing member function for Metafile device.
//
// Parameters:
//	  CDC *pDC			The device context in which the drawing occurs.
//	  CRect &rcBounds	The rectangular area of the control, including the
//						border.
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNavigatorCtrl::OnDrawMetafile(CDC* pDC, const CRect& rcBounds)
{
	CRect rcOutline(rcBounds);
	rcOutline.DeflateRect( 1, 1, 1, 1);

	pDC-> Rectangle( &rcBounds);

}

// ***************************************************************************
//
// CNavigatorCtrl::DoPropExchange
//
// Description:
//	  Control property persistence support.  Called by the framework when
//	  loading or storing a control from a persistent storage representation,
//	  such as a stream or property set.
//
// Parameters:
//	  CPropExchange* pPX	Context of the property exchange, including its
//							direction.
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNavigatorCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	PX_String(pPX, _T("RootPath"), m_csRootPath, _T(""));
	PX_String(pPX, _T("NameSpace"), m_csNameSpace, _T(""));

}

// ***************************************************************************
//
// CNavigatorCtrl::AboutBox
//
// Description:
//	  Display an "About" box to the user.
//
// Parameters:
//	  NONE
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNavigatorCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_NAVIGATOR);
	dlgAbout.DoModal();
}

LRESULT CNavigatorCtrl::Invalidate(WPARAM, LPARAM)
{
	m_cbBannerWindow.Invalidate();
	m_cbBannerWindow.PostMessage(WM_PAINT,0,0);

	return 0;
}
// ***************************************************************************
//
// CNavigatorCtrl::InitializeNamespace
//
// Description:
//	  If we are in AmbientUserMode initialize the state of the control.
//
// Parameters:
//	  NONE
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
LRESULT CNavigatorCtrl::InitializeNamespace(WPARAM, LPARAM)
{
	if (AmbientUserMode( ) && m_bOpeningNamespace == FALSE)
	{

		int cx;
		int cy;

		GetControlSize(&cx,&cy);
		InitializeChildren(cx,cy);

		m_pServices = NULL;

		m_bOpeningNamespace = TRUE;
		m_bOpeningNamespace = FALSE;
		if (m_pServices != NULL)
		{
			m_pServices->Release();
		}
		m_pServices = NULL;
		m_pServices = InitServices(&m_csNameSpace);

		if (m_bUserCancel)
		{
			InvalidateControl();
			return 0;
		}


		if (!m_pServices)
		{
			CString csUserMsg;
			if (m_sc == 0x8001010e)
			{
				csUserMsg =
							_T("You cannot open another Object Browser window.  Please close this web page.");

				//ErrorMsg
				//		(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 10);
				CString csTitle = _T("WMI Object Browser");
				MessageBox(csUserMsg,csTitle);

				return 0;

			}
			else
			{
				if (!m_csNameSpace.IsEmpty())
				{
					csUserMsg =
							_T("Cannot open namespace ");
					csUserMsg += m_csNameSpace;
					ErrorMsg
						(&csUserMsg, m_sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 10);
				}
				return 0;
			}

		}
		m_cbBannerWindow.OpenNamespace(&m_csNameSpace,TRUE);

		if (m_bReadySignal)
		{
			FireNotifyOpenNameSpace(m_csNameSpace);
		}

		m_ctcTree.InitTreeState(this);
		InvalidateControl();
		SetModifiedFlag();

	}


	return 0;

}

// ***************************************************************************
//
// CNavigatorCtrl::InitializeChildren
//
// Description:
//	  Initializes the child control (edit, button and tree control) sizes.
//
// Parameters:
//	  int cx			Width
//	  int cy			Height
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNavigatorCtrl::InitializeChildren(int cx, int cy)
{
	if (!m_bChildrenCreated)
	{
		m_pcbiBrowseDialog = new CBrowseforInstances(this);
		m_pProgressDlg = new CProgressDlg;
		m_pProgressDlg->SetActiveXParent(this);
		SetChildControlGeometry(cx, cy);

		m_bChildrenCreated = TRUE;


		if (m_ctcTree.Create (TVS_HASLINES| TVS_LINESATROOT,
			m_rTree, this , IDC_TREE ) == -1)
			return;

		m_cbBannerWindow.SetParent(this);
		if (m_cbBannerWindow.Create(NULL, _T("BannerCWnd"), WS_CHILD  |  WS_VISIBLE
			,m_rBannerRect, this,
				IDC_TOOLBAR) == -1)
			{
				return;
			}



	}



}

// ***************************************************************************
//
// CNavigatorCtrl::InitializeChildControlSize
//
// Description:
//	  Initializes the child control (edit, button and tree control) sizes.
//
// Parameters:
//	  int cx			Width
//	  int cy			Height
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNavigatorCtrl::InitializeChildControlSize(int cx, int cy)
{
	if (!m_bChildrenCreated)
	{
		m_bChildrenCreated = TRUE;

		m_pcbiBrowseDialog = new CBrowseforInstances(this);
		m_pProgressDlg = new CProgressDlg;
		m_pProgressDlg->SetActiveXParent(this);

		if (m_ctcTree.Create (TVS_HASLINES| TVS_LINESATROOT,
			m_rTree, this , IDC_TREE ) == -1)
			return;

		m_cbBannerWindow.SetParent(this);
		if (m_cbBannerWindow.Create(NULL, _T("BannerCWnd"), WS_CHILD  |  WS_VISIBLE
			,m_rBannerRect, this,
				IDC_TOOLBAR) == -1)
			{
				return;
			}

		m_ctcTree.InitTreeState(this);

	}

	SetChildControlGeometry(cx, cy);


	m_cbBannerWindow.MoveWindow(m_rBannerRect);
	m_ctcTree.MoveWindow(m_rTree);


}

// ***************************************************************************
//
//	CNavigatorCtrl::SetChildControlGeometry
//
//	Description:
//		Set the geometry of the children controls based upon font size for the
//		edit and button controls.  Remainder goes to the tree control.
//
//	Parameters:
//		int cx			Width
//		int cy			Height
//
//	Returns:
//		void
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CNavigatorCtrl::SetChildControlGeometry(int cx, int cy)
{

	if (cx == 0 && cy == 0)
	{
		m_rBannerRect = CRect(0, 0, 300, 300);
		m_rTreeRect = CRect (0, 0, 0, 0);
		m_rTree = CRect(0, 0, 0, 0);
		return;
	}

	CreateControlFont();
	int nBannerHeight = (m_tmFont.tmHeight) + 20;

	m_rBannerRect = CRect(	0 ,
							0 ,
							cx ,
							nBannerHeight);

	m_rTreeRect = CRect (	nSideMargin,
							nBannerHeight + m_nOffset,
							cx - (nSideMargin + 1) ,
							cy - nTopMargin);
	m_rTree = CRect(		nSideMargin + 1,
							nBannerHeight + m_nOffset + 1,
							cx - (nSideMargin + 2),
							cy  - (nTopMargin + 1));

}


void CNavigatorCtrl::SetNewRoot(CString &rcsRoot)
{
	if (rcsRoot.GetLength() > 0)
	{
		CWaitCursor wait;
		m_ctcTree.UnCacheTools();
		m_ctcTree.ResetTree();
		m_ctcTree.AddInitialObjectInstToTree (rcsRoot);
		m_csRootPath = rcsRoot;
		InvalidateControl();
		SetModifiedFlag();
	}


}

// ***************************************************************************
//
// CNavigatorCtrl::OnSetRoot
//
// Description:
//	  Handles the context menu's set root operation.
//
// Parameters:
//	  NONE
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNavigatorCtrl::OnSetroot()
{
	CWaitCursor wait;

	CString csRoot = m_pctidHit -> GetAt(0);

	m_ctcTree.UnCacheTools();
	m_ctcTree.ResetTree();

	m_ctcTree.AddInitialObjectInstToTree (csRoot);
	m_csRootPath = csRoot;

	InvalidateControl();
	SetModifiedFlag();
}

// ***************************************************************************
//
// CNavigatorCtrl::OnUpdateSetroot
//
// Description:
//	  Enables or disables the context menu's set root item.
//
// Parameters:
//	  CCmdUI* pCmdUI	Pointer to the handler for the menu item.
//
// Returns:
//	  NONE
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNavigatorCtrl::OnUpdateSetroot(CCmdUI* pCmdUI)
{
	CString csObject = m_pctidHit ? m_pctidHit->GetAt(0) : _T("");
	if (csObject.GetLength() > 0 &&
		m_pctidHit -> m_nType == CTreeItemData::ObjectInst)
	{
		pCmdUI -> Enable(  TRUE );
	}
	else
	{
		pCmdUI -> Enable(  FALSE );
	}

}


// ***************************************************************************
//
// CNavigatorCtrl::OnCreate
//
// Description:
//	  Called by the framework after the window is being created but before
//	  the window is shown.
//
// Parameters:
//	  LPCREATESTRUCT lpCreateStruct	Pointer to the structure which contains
//									default parameters.
//
// Returns:
//	  BOOL				0 if continue; -1 if the window should be destroyed.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
int CNavigatorCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	lpCreateStruct->style |= WS_CLIPCHILDREN;
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;
}

// ***************************************************************************
//
// CNavigatorCtrl::OnSize
//
// Description:
//	  Called by the framework after the window is being resized.
//
// Parameters:
//	  UINT nType			Specifies the type of resizing requested.
//	  int cx				Specifies the new width of the client area.
//	  int cy				Specifies the new height of the client area.
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNavigatorCtrl::OnSize(UINT nType, int cx, int cy)
{
	if (!GetSafeHwnd())
	{
		return;
	}

	COleControl::OnSize(nType, cx, cy);

	if (!m_bMetricSet) // Create the font used by the control.
	{
		CreateControlFont();
	}

	SetChildControlGeometry(cx, cy);


	if (!m_bChildrenCreated)
	{

		m_bChildrenCreated = TRUE;

		m_pcbiBrowseDialog = new CBrowseforInstances(this);
		m_pProgressDlg = new CProgressDlg;
		m_pProgressDlg->SetActiveXParent(this);

		if (m_ctcTree.Create (TVS_HASLINES| TVS_LINESATROOT,
			m_rTree, this , IDC_TREE ) == -1)
			return;

		m_cbBannerWindow.SetParent(this);

		if (m_cbBannerWindow.Create(NULL, _T("BannerCWnd"), WS_CHILD  |  WS_VISIBLE
			,m_rBannerRect, this,
				IDC_TOOLBAR) == -1)
			{
				return;
			}


		m_ctcTree.CWnd::SetFont ( &m_cfFont , FALSE);
		m_cbBannerWindow.CWnd::SetFont ( &m_cfFont , FALSE);

		m_ctcTree.InitTreeState(this);

	}

	m_cbBannerWindow.MoveWindow(m_rBannerRect,TRUE);
	m_ctcTree.MoveWindow(m_rTree,TRUE);
	InvalidateControl();
	m_bRefresh = TRUE;
//	PostMessage(REDRAW_CONTROL,0,0);


}


LRESULT CNavigatorCtrl::RedrawAll(WPARAM, LPARAM)
{
	m_cbBannerWindow.UpdateWindow();
	m_ctcTree.UpdateWindow();

	m_cbBannerWindow.RedrawWindow();
	m_ctcTree.RedrawWindow();

	if (m_bRefresh)
	{
		m_bRefresh = FALSE;
	}
	else
	{
		m_bRefresh = TRUE;
	}

	Refresh();

	return 0;

}

// ***************************************************************************
//
// CNavigatorCtrl::OnDestroy
//
// Description:
//	  Called by the framework after the window is removed from the screen but
//	  before it is destroyed.	 Deinitialize data that cannot be deinitialized
//	  in the destructor.
//
// Parameters:
//	  NONE
//
// Returns:
//	  void
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNavigatorCtrl::OnDestroy()
{
	m_ctcTree.ResetTree();
	delete m_pcilImageList;
	COleControl::OnDestroy();
}


LRESULT CNavigatorCtrl::SendInstancesToMultiInstanceViewer(WPARAM, LPARAM)
{
//	CWaitCursor wait;
	OnPopupMultiinstanceviewer();
	PostMessage(SETFOCUS,0,0);
	return 0;
}

LRESULT CNavigatorCtrl::SetNewRoot(WPARAM wParam, LPARAM lParam)
{

	IWbemClassObject *pObject =
		reinterpret_cast<IWbemClassObject *>(lParam);

	CString csPath = GetIWbemFullPath(GetServices(),pObject);
	SetNewRoot(csPath);
	pObject->Release();

	return 0;
}

void CNavigatorCtrl::OnPopupMultiinstanceviewer()
{
	 if(!m_hHit)
	 {
		return;
	 }

	 // 10/08/97 - For now we will send over queries.  10453.
	 //if (m_pctidHit -> m_nType == CTreeItemData::ObjectGroup &&
	 //	 m_ctcTree.GetItemState( m_hHit, TVIF_STATE  ) & TVIS_EXPANDEDONCE)
	 //{
	 //	MultiInstanceViewFromTreeChildren();
	 //}
	 //else
	 if (m_pctidHit -> m_nType == CTreeItemData::ObjectGroup )
	 {
		MultiInstanceViewFromObjectGroup();
	 }
	 else if (m_pctidHit -> m_nType == CTreeItemData::AssocRole)
	 {
		MultiInstanceViewFromAssocRole();
	 }

}

void CNavigatorCtrl::MultiInstanceViewFromTreeChildren()
{
	TV_ITEM tvItem;
	tvItem.hItem = m_hHit;
	tvItem.mask = TVIF_CHILDREN | TVIF_HANDLE;
	BOOL bReturn = m_ctcTree.GetItem( &tvItem );
	int cChildren = tvItem.mask & TVIF_CHILDREN ? tvItem.cChildren : 0;

	if (cChildren == 0)
	{
		return;
	}

	cChildren = m_ctcTree.GetNumChildren(m_hHit);
	SAFEARRAY *psa;

	MakeSafeArray(&psa,VT_BSTR, cChildren + 1);


	CString csGroup = m_ctcTree.GetItemText(m_hHit);
	PutStringInSafeArray(psa, &csGroup, 0);

	HTREEITEM hChild = m_ctcTree.GetChildItem(  m_hHit );
	CString csPath;
	int i = 1;
	while (hChild)
	{
		CTreeItemData *pctidItem =
			reinterpret_cast<CTreeItemData *>(m_ctcTree.GetItemData(hChild));
		if (pctidItem)
		{
			CString csItem =
				pctidItem -> GetAt(0);
			if (csItem.GetLength() > 0)
			{
				PutStringInSafeArray(psa, &csItem, i++);
			}
		}
		hChild = m_ctcTree.GetNextSiblingItem(hChild);
	}

	VARIANTARG var;
	VariantInit(&var);
	var.vt = VT_ARRAY | VT_BSTR;
	var.parray = psa;
	COleVariant covOut(var);
	CString csLabel = m_ctcTree.GetItemText(m_hHit);
	csLabel += _T(" Object Group");
	if (m_bReadySignal)
	{
		FireViewInstances((LPCTSTR)csLabel,covOut) ;
	}

	VariantClear(&var);
}

void CNavigatorCtrl::MultiInstanceViewFromObjectGroup()
{
	CString csQuery =
		m_ctcTree.GetObjectGroupInstancesQuery(m_hHit, m_pctidHit);

	if (csQuery.IsEmpty() || csQuery.GetLength() == 0)
	{
		return;
	}


	CString csLabel = m_ctcTree.GetItemText(m_hHit);
	//CString csClass = csLabel; 10/08/97 10453.  Do not send over class.
	CString csClass;
	csLabel += _T(" Object Group");
	CString csQueryType = _T("WQL");

	if (m_bReadySignal)
	{
		FireQueryViewInstances
			((LPCTSTR)csLabel,(LPCTSTR)csQueryType,
			(LPCTSTR)csQuery,(LPCTSTR) csClass);
	}

}

void CNavigatorCtrl::MultiInstanceViewFromAssocRole()
{
	// can use GetObjectClassForRole to get the role's class.
	CString csQuery =
		m_ctcTree.GetAssocRoleInstancesQuery(m_hHit, m_pctidHit);

	CString csAssoc = GetIWbemClass(m_pctidHit -> GetAt(0));

	CString csText = m_ctcTree.GetItemText(m_hHit);
	int nRoleBegin = csText.Find('.');
	CString csRole = csText.Right(csText.GetLength() - (nRoleBegin + 1));

	IWbemClassObject *pimcoAssoc = GetIWbemObject
		(this,m_pServices,
		GetCurrentNamespace(),
		GetAuxNamespace(),
		GetAuxServices(),
		csAssoc,FALSE);

	if (csQuery.IsEmpty() || csQuery.GetLength() == 0)
	{
		return;
	}


	CString csObjectClassForRole;
	if (pimcoAssoc)
	{
		// 10/08/97 10453.  Do not send over class.
		//csObjectClassForRole = GetObjectClassForRole(NULL,pimcoAssoc,&csRole);
		pimcoAssoc->Release();
	}



	CString csLabel = m_ctcTree.GetItemText(m_hHit);
	CString csClass = csObjectClassForRole;
	CString csQueryType = _T("WQL");

	if (m_bReadySignal)
	{
		FireQueryViewInstances
			((LPCTSTR)csLabel,(LPCTSTR)csQueryType,
			(LPCTSTR)csQuery,
			(LPCTSTR) csClass);
	}
}


void CNavigatorCtrl::OnUpdatePopupMultiinstanceviewer(CCmdUI* pCmdUI)
{
	if (m_pctidHit && m_hHit &&
		(m_pctidHit -> m_nType == CTreeItemData::ObjectGroup ||
		 m_pctidHit -> m_nType == CTreeItemData::AssocRole ))
	{
		pCmdUI -> Enable(  TRUE );
	}
	else
	{
		pCmdUI -> Enable(  FALSE );
	}
}





BSTR CNavigatorCtrl::GetNameSpace()
{
	return m_csNameSpace.AllocSysString();
}

void CNavigatorCtrl::SetNameSpace(LPCTSTR lpszNewValue)
{
	CString csNameSpace = lpszNewValue;
	if (GetSafeHwnd()  && AmbientUserMode())
	{
		SCODE sc = m_cbBannerWindow.OpenNamespace(&csNameSpace,TRUE);
		if (sc == S_OK)
		{
			if (m_pServices != NULL)
			{
				m_pServices->Release();
				m_pServices = NULL;
			}
			m_pServices = InitServices(&csNameSpace);
			if (!m_pServices)
			{
				CString csUserMsg =
							_T("Cannot open namespace ");
				csUserMsg += csNameSpace;
				ErrorMsg
						(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 10);
				return;

			}
			if (m_bFireEvents && m_bReadySignal)
			{
				FireNotifyOpenNameSpace((LPCTSTR) csNameSpace);
			}

			m_csNameSpace = csNameSpace;

			CString csRootPath = GetInitialSystemObject();

			m_csRootPath = csRootPath;

			if (m_csRootPath.GetLength() == 0)
			{
				m_ctcTree.UnCacheTools();
				m_ctcTree.ResetTree();
				m_bDrawAll = TRUE;
				PostMessage(INVALIDATE_CONTROL,0,0);
				return;
			}

			m_ctcTree.UnCacheTools();
			m_ctcTree.ResetTree();

			m_ctcTree.AddInitialObjectInstToTree
				(m_csRootPath,m_bFireEvents);
			m_bFireEvents = TRUE;

			m_bDrawAll = TRUE;
			PostMessage(INVALIDATE_CONTROL,0,0);
			SetModifiedFlag();
		}

	}
	else if (!AmbientUserMode())
	{
		m_csNameSpace = csNameSpace;
		SetModifiedFlag();
	}

}


UINT CNavigatorCtrl::OnGetDlgCode()
{
    // If you're firing KeyPress, prevent the container from
    // stealing WM_CHAR.
    return COleControl::OnGetDlgCode() | DLGC_WANTALLKEYS ;
}

void CNavigatorCtrl::OnKeyDownEvent(USHORT nChar, USHORT nShiftState)
{
	// TODO: Add your specialized code here and/or call the base class

	COleControl::OnKeyDownEvent(nChar, nShiftState);
}

BOOL CNavigatorCtrl::PreTranslateMessage(LPMSG lpMsg)
{

	BOOL bDidTranslate;

	bDidTranslate = COleControl::PreTranslateMessage(lpMsg);

	if (bDidTranslate)
	{
		return bDidTranslate;
	}

   switch (lpMsg->message)
	{
	case WM_KEYDOWN:
	case WM_KEYUP:

		if (lpMsg->wParam == VK_TAB)
		{
			return FALSE;
		}
		if (lpMsg->wParam == VK_ESCAPE)
		{
		   TCHAR szClass[40];
			CWnd* pWndFocus = GetFocus();
			if (pWndFocus != NULL &&
				IsChild(pWndFocus) &&
				GetClassName(pWndFocus->m_hWnd, szClass, 39) &&
				((_tcsicmp(szClass, _T("SysTreeView32")) == 0) ||
				(_tcsicmp(szClass, _T("edit")) == 0)))
			{
				pWndFocus->SendMessage(lpMsg->message, lpMsg->wParam, lpMsg->lParam);
				return TRUE;
			}
		 }
		if (lpMsg->wParam == VK_RETURN)
		{
		   TCHAR szClass[40];
			CWnd* pWndFocus = GetFocus();
			if (!pWndFocus)
			{
				break;
			}
			CRect crEdit;
			CRect crTree;
			CRect crIntersect;

			pWndFocus->GetWindowRect(&crEdit);
			m_ctcTree.GetWindowRect(&crTree);

			crEdit.NormalizeRect();
			crTree.NormalizeRect();
			BOOL bIntersect = crIntersect.IntersectRect(&crEdit,&crTree);

			if (bIntersect &&
				IsChild(pWndFocus) &&
				GetClassName(pWndFocus->m_hWnd, szClass, 39) &&
				((_tcsicmp(szClass, _T("SysTreeView32")) == 0) ||
				(_tcsicmp(szClass, _T("edit")) == 0)))
			{
				pWndFocus->SendMessage(lpMsg->message, lpMsg->wParam, lpMsg->lParam);
				return TRUE;
			}
		 }
		break;
	}


   return FALSE; // We already did COleControl::PreTranslateMessage
}

void CNavigatorCtrl::OnPopupInstancesearch()
{

}

void CNavigatorCtrl::OnPopupParentassociation()
{
//	CWaitCursor wait;
	CString csPath = ParentAssociation(m_hHit);

	if (csPath.GetLength() > 0 && m_bReadySignal)
	{

		FireViewObject((LPCTSTR)csPath);


	}

}

void CNavigatorCtrl::OnUpdatePopupParentassociation(CCmdUI* pCmdUI)
{
	if (m_pctidHit && m_hHit && (m_ctcTree.GetRootItem() != m_hHit) &&

		(m_pctidHit -> m_nType == CTreeItemData::ObjectInst ))
	{
		pCmdUI -> Enable(  TRUE );
	}
	else
	{
		pCmdUI -> Enable(  FALSE );
	}

}

CString CNavigatorCtrl::ParentAssociation
(HTREEITEM hItem)
{

	CTreeItemData *pctidItem =
		reinterpret_cast<CTreeItemData *> (m_ctcTree.GetItemData(hItem));

	if (!pctidItem)
	{
		return _T("");
	}

	CString csItem = pctidItem -> GetAt(0);
	HTREEITEM hParent;

	CString csAssoc  = m_ctcTree.GetParentAssocFromTree(hItem,hParent);
	CTreeItemData *pctidAssoc =
		hParent?
		reinterpret_cast<CTreeItemData *>(m_ctcTree.GetItemData(hParent)) : NULL;


	if (!pctidAssoc)
	{
		return _T("");
	}

	CString csAssociatedObjectRole = pctidAssoc-> m_csMyRole;

	HTREEITEM hAssociatedObject =
		m_ctcTree.GetParentItem(hParent);
	CTreeItemData *pctidAssociatedObject =
		hAssociatedObject?
		reinterpret_cast<CTreeItemData *>
		(m_ctcTree.GetItemData(hAssociatedObject)) : NULL;
	CString csAssociatedObject =
		pctidAssociatedObject -> GetAt(0);


	CString csAssocRole = m_ctcTree.GetItemText(hParent);
	int nRoleBegin = csAssocRole.Find('.');
	csAssoc = csAssocRole.Left(nRoleBegin);
	CString csRole = csAssocRole.Right((csAssocRole.GetLength() - nRoleBegin) - 1);

	CStringArray *pcsaAssocInstances = GetAssocInstances
		(m_pServices, &csItem, &csAssoc, &csRole,  m_csNameSpace,
		m_csAuxNameSpace,  m_pAuxServices, this);

	CString csAssocInstReturn;

	for (int i = 0; i < pcsaAssocInstances->GetSize(); i++)
	{
		CString csAssocInst = pcsaAssocInstances->GetAt(i);
		CStringArray *pcsaAssocRolesAndPaths =
			AssocPathRoleKey(&csAssocInst);
		for (int n = 0; n < pcsaAssocRolesAndPaths->GetSize() ; n += 2)
		{
			CString csTestRole = pcsaAssocRolesAndPaths->GetAt(n);
			CString csTestPath = pcsaAssocRolesAndPaths->GetAt(n + 1);
			if (csTestRole.CompareNoCase(csAssociatedObjectRole) == 0 &&
				csTestPath.CompareNoCase(csAssociatedObject) == 0)
			{
				csAssocInstReturn = csAssocInst;
				break;
			}
		}
		delete pcsaAssocRolesAndPaths;
	}


	delete pcsaAssocInstances;

	return csAssocInstReturn;


}



void CNavigatorCtrl::OnReadySignal()
{
	m_bReadySignal = TRUE;

	if (m_pServices)
	{
		SetNameSpace(m_csNameSpace);
		return;
	}


	InitializeNamespace(0,0);
	InitializeTreeRoot();

	HTREEITEM hItem = m_ctcTree.GetRootItem();
	if (hItem)
	{
		CTreeItemData *pctidItem =
		reinterpret_cast <CTreeItemData *> (m_ctcTree.GetItemData(hItem));
		CString csPath = pctidItem->GetAt(0);
		if (pctidItem && csPath.GetLength() > 0)
		{
			if (pctidItem -> m_nType == CTreeItemData::ObjectInst && m_bReadySignal)
			{
				FireViewObject((LPCTSTR)csPath);
			}
		}
	}
}


//***********************************************************
// CComparePaths::CompareNoCase
//
//
// Do a case insensitive comparison of two wide strings.  This
// compare works even when one or both of the string pointers are
// NULL.  A NULL pointer is taken to be less than any real string,
// even an empty one.
//
// Parameters:
//		[in] LPWSTR pws1
//			Pointer to the first string.  This pointer can be NULL.
//
//		[in] LPWSTR pws2
//			Pointer to the second string.  This pointer can be NULL.
//
// Returns:
//		int
//			Greater than zero if string1 is greater than string2.
//			Zero if the two strings are equal.
//			Less than zero if string 1 is less than string2.
//
//**************************************************************
int CComparePaths::CompareNoCase(LPWSTR pws1, LPWSTR pws2)
{
	// Handle the case where one, or both of the string pointers are NULL
	if (pws1 == NULL) {
		if (pws2 == NULL) {
			return 0;	// Two null strings are equal
		}
		else {
			return -1; // A null string is less than any real string.
		}
	}

	if (pws2 == NULL) {
		if (pws1 != NULL) {
			return 1;  // Any string is greater than a null string.
		}
	}


	ASSERT(pws1 != NULL);
	ASSERT(pws2 != NULL);

	int iResult;
	iResult = _wcsicmp( pws1, pws2);

	return iResult;
}


//***************************************************************
// CComparePath::NormalizeKeyArray
//
// The key array is normalized by sorting the KeyRef's by key name.
// After two key arrays are sorted, they can be compared without
// by iterating through the list of keys and comparing corresponding
// array entries rather than trying searching the arrays for corresponding
// key names and then comparing the key values.
//
// Parameters:
//		[in, out] ParsedObjectPath& path
//			The parsed object path containing the key array to sort.
//
// Returns:
//		Nothing. (The key array is sorted as a side effect).
//
//*****************************************************************
void CComparePaths::NormalizeKeyArray(ParsedObjectPath& path)
{
	// Do a simple bubble sort where the "KeyRefs" with the smallest
	// names are bubbled towards the top and the  the KeyRefs with the
	// largest names are bubbled toward the bottom.
	for (DWORD dwKey1 = 0; dwKey1 < path.m_dwNumKeys; ++dwKey1) {
		for (DWORD dwKey2 = dwKey1 + 1; dwKey2 < path.m_dwNumKeys; ++dwKey2) {
			ASSERT(path.m_paKeys[dwKey1] != NULL);
			KeyRef* pkr1 = path.m_paKeys[dwKey1];
			ASSERT(pkr1 != NULL);

			ASSERT(path.m_paKeys[dwKey2] != NULL);
			KeyRef* pkr2 = path.m_paKeys[dwKey2];
			ASSERT(pkr2 != NULL);

			int iResult = CompareNoCase(pkr1->m_pName, pkr2->m_pName);
			if (iResult > 0) {
				// Swap the two keys;
				path.m_paKeys[dwKey1] = pkr2;
				path.m_paKeys[dwKey2] = pkr2;
			}
		}
	}
}



//***********************************************************************
// CComparePaths::KeyValuesAreEqual
//
// Compare two key values to determine whether or not they are equal.
// To be equal, they must both be of the same type and their values
// must also be equal.
//
// Parameters:
//		[in] VARAINT& variant1
//			The first key value.
//
//		[in] VARIANT& variant2
//			The second key value.
//
// Returns:
//		TRUE if the two values are the same, FALSE otherwise.
//
//**********************************************************************
BOOL CComparePaths::KeyValuesAreEqual(VARIANT& v1, VARIANT& v2)
{
	ASSERT(v1.vt == v2.vt);
	ASSERT(v1.vt==VT_BSTR || v1.vt == VT_I4);
	ASSERT(v2.vt==VT_BSTR || v2.vt == VT_I4);


	// Key values should always be VT_BSTR or VT_I4.  We special case these
	// two types to be efficient and punt on all the other types.
	BOOL bIsEqual;
	switch(v1.vt) {
	case VT_BSTR:
		if (v2.vt == VT_BSTR) {
			bIsEqual = IsEqual(v1.bstrVal, v2.bstrVal);
			return bIsEqual;
		}
		else {
			return FALSE;
		}
		break;
	case VT_I4:
		if (v2.vt == VT_I4) {
			bIsEqual = (v1.lVal == v2.lVal);
			return bIsEqual;
		}
		else {
			return FALSE;
		}
		break;
	}


	ASSERT(FALSE);
	COleVariant var1;
	COleVariant var2;

	var1 = v1;
	var2 = v2;

	bIsEqual = (var1 == var2);
	return bIsEqual;
}


//*******************************************************************
// CComparePaths::PathsRefSameObject
//
// Compare two parsed object paths to determine whether or not they
// they reference the same object.  Note that the sever name and namespaces
// are not compared if they are missing from one of the paths.
//
// Parameters:
//		[in] ParsedObjectPath* ppath1
//			The first parsed path.
//
//		[in] ParsedObjectPath* ppath2
//			The second parsed path.
//
// Returns:
//		BOOL
//			TRUE if the two paths reference the same object, FALSE otherwise.
//
//*******************************************************************
BOOL CComparePaths::PathsRefSameObject(
	/* in */ ParsedObjectPath* ppath1,
	/* in */ ParsedObjectPath* ppath2)
{
	if (ppath1 == ppath2) {
		return TRUE;
	}
	if (ppath1==NULL || ppath2==NULL) {
		return FALSE;
	}


#if 0
	// Check to see if a server name is specified for either path
	// if so, the server name count is 1, otherwise zero.
	UINT iNamespace1 = 0;
	if (ppath1->m_pServer!=NULL) {
		if (!IsEqual(ppath1->m_pServer, L".")) {
			iNamespace1 = 1;
		}
	}

	UINT iNamespace2 = 0;
	if (ppath1->m_pServer!=NULL) {
		if (!IsEqual(ppath2->m_pServer, L".")) {
			iNamespace2 = 1;
		}
	}


	// Relative paths don't specify a server, so we assume that the server
	// for a relative path and any other path match and no further comparison is
	// necessary.
	if (iNamespace1!=0 && iNamespace2!=0) {
		if (!IsEqual(ppath1->m_pServer, ppath2->m_pServer)) {
			return FALSE;
		}
	}

	// Relative paths don't specify name spaces, so we assume that the name spaces
	// for a relative path and any other path match and no further comparison is
	// necessary.  Of course, this assumes that the namespace for a relative path
	// is indeed the same as the other path.
	if (ppath1->m_dwNumNamespaces!=0 && ppath2->m_dwNumNamespaces!=0) {
		// Check to see if one of the namespaces are different.
		if ((ppath1->m_dwNumNamespaces - iNamespace1) != (ppath2->m_dwNumNamespaces - iNamespace2)) {
			return FALSE;
		}

		while((iNamespace1 < ppath1->m_dwNumNamespaces) && (iNamespace2 < ppath2->m_dwNumNamespaces)) {

			if (!IsEqual(ppath1->m_paNamespaces[iNamespace1], ppath2->m_paNamespaces[iNamespace2])) {
				return FALSE;
			}
			++iNamespace1;
			++iNamespace2;
		}
	}


#endif //0


	// Check to see if the classes are different.
	if (!IsEqual(ppath1->m_pClass, ppath2->m_pClass)) {
		return FALSE;
	}


	// Check to see if any of the keys are different.
	if (ppath1->m_dwNumKeys  != ppath2->m_dwNumKeys) {
		return FALSE;
	}

	KeyRef* pkr1;
	KeyRef* pkr2;

	// Handle single keys as a special case since "Class="KeyValue"" should
	// be identical to "Class.keyName="KeyValue""
	if ((ppath1->m_dwNumKeys==1) && (ppath2->m_dwNumKeys==1)) {
		pkr1 = ppath1->m_paKeys[0];
		pkr2 = ppath2->m_paKeys[0];

		if (!IsEqual(pkr1->m_pName, pkr2->m_pName)) {
			if (pkr1->m_pName!=NULL && pkr2->m_pName!=NULL) {
				return FALSE;
			}
		}

		if (KeyValuesAreEqual(pkr1->m_vValue, pkr2->m_vValue)) {
			return TRUE;
		}
		else {
			return FALSE;
		}
	}


	NormalizeKeyArray(*ppath1);
	NormalizeKeyArray(*ppath2);

	for (DWORD dwKeyIndex = 0; dwKeyIndex < ppath1->m_dwNumKeys; ++dwKeyIndex) {
		ASSERT(ppath1->m_paKeys[dwKeyIndex] != NULL);
		ASSERT(ppath2->m_paKeys[dwKeyIndex] != NULL);

		pkr1 = ppath1->m_paKeys[dwKeyIndex];
		pkr2 = ppath2->m_paKeys[dwKeyIndex];


		if (!IsEqual(pkr1->m_pName, pkr2->m_pName)) {
			return FALSE;
		}

		if (!KeyValuesAreEqual(pkr1->m_vValue, pkr2->m_vValue)) {
			return FALSE;
		}

	}
	return TRUE;
}



//**************************************************************
// CComparePaths::PathsRefSameObject
//
// Check to see if two object paths point to the same object.
//
// Parameters:
//		BSTR bstrPath1
//			The first object path.
//
//		BSTR bstrPath2
//			The second object path.
//
// Returns:
//		BOOL
//			TRUE if the two paths reference the same object in
//			the database, FALSE otherwise.
//
//**************************************************************
BOOL CComparePaths::PathsRefSameObject(BSTR bstrPath1, BSTR bstrPath2)
{
	CObjectPathParser parser;

    ParsedObjectPath* pParsedPath1 = NULL;
    ParsedObjectPath* pParsedPath2 = NULL;
	int nStatus1;
	int nStatus2;

    nStatus1 = parser.Parse(bstrPath1,  &pParsedPath1);
	nStatus2 = parser.Parse(bstrPath2, &pParsedPath2);

	BOOL bRefSameObject = FALSE;
	if (nStatus1==0 && nStatus2==0) {
		bRefSameObject = PathsRefSameObject(pParsedPath1, pParsedPath2);
	}

	if (pParsedPath1) {
		parser.Free(pParsedPath1);
	}

	if (pParsedPath2) {
		parser.Free(pParsedPath2);
	}

	return bRefSameObject;
}




void CNavigatorCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	COleControl::OnLButtonUp(nFlags, point);
}

void CNavigatorCtrl::OnPopupBrowse()
{
	// TODO: Add your command handler code here
	m_pcbiBrowseDialog->SetServices(m_pServices);
	m_pcbiBrowseDialog->SetTMFont(&m_tmFont);
	m_pcbiBrowseDialog->SetParent(this);
	m_pcbiBrowseDialog->SetMode(CBrowseforInstances::TreeRoot);
	m_pcbiBrowseDialog->DoModal();
	if (m_bRestoreFocusToTree)
   {
		m_ctcTree.SetFocus();
   }
   else
   {
		m_cbBannerWindow.SetFocus();
   }
}

void CNavigatorCtrl::OnUpdatePopupBrowse(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here

}

long CNavigatorCtrl::ChangeRootOrNamespace
(LPCTSTR lpctstrRootOrNamespace, long lMakeNamespaceCurrent, long lFireEvents)
{
	if (!lpctstrRootOrNamespace)
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	CString csRootOrNamespace = lpctstrRootOrNamespace;
	CString csClass = GetIWbemClass(csRootOrNamespace);
	CString csNamespace = GetObjectNamespace(&csRootOrNamespace);
	BOOL bPathHasKeys = PathHasKeys(&csRootOrNamespace);

	if (lMakeNamespaceCurrent)
	{
		m_bFireEvents = lFireEvents;
		SetNameSpace((LPCTSTR) csNamespace);
		return S_OK;
	}
	else
	{
		CString csRootPath = csRootOrNamespace;

		if (csRootPath.GetLength() == 0)
		{
			InvalidateControl(); // jpow
			return WBEM_E_FAILED;
		}

		m_csRootPath = csRootPath;
		m_ctcTree.UnCacheTools();
		m_ctcTree.ResetTree();

		m_ctcTree.AddInitialObjectInstToTree
			(m_csRootPath, lFireEvents);

		m_bDrawAll = TRUE;
		InvalidateControl();
		return S_OK;

	}
}


void CNavigatorCtrl::OnPopupGotonamespace()
{
	CString csObject = m_pctidHit ? m_pctidHit->GetAt(0) : _T("");
	if (csObject.GetLength() > 0 &&
		m_pctidHit -> m_nType == CTreeItemData::ObjectInst)
	{
		ChangeRootOrNamespace((LPCTSTR) csObject ,TRUE, TRUE) ;
	}

}

void CNavigatorCtrl::OnUpdatePopupGotonamespace(CCmdUI* pCmdUI)
{
	CString csObject = m_pctidHit ? m_pctidHit->GetAt(0) : _T("");
	if (csObject.GetLength() > 0 &&
		m_pctidHit -> m_nType == CTreeItemData::ObjectInst &&
		ObjectInDifferentNamespace (&m_csNameSpace,&csObject))

	{
		pCmdUI -> Enable(  TRUE );
	}
	else
	{
		pCmdUI -> Enable(  FALSE );
	}


}

void CNavigatorCtrl::OnPopupRefresh()
{
	// TODO: Add your command handler code here

	CWaitCursor wait;

	m_ctcTree.UnCacheTools();
	m_ctcTree.m_bReCacheTools = TRUE;

	m_ctcTree.Expand(m_hHit,TVE_COLLAPSE);

	if (m_ctcTree.ItemHasChildren (m_hHit))
	{
		HTREEITEM hChild = m_ctcTree.GetChildItem(m_hHit);
		while (hChild)
		{
			m_ctcTree.DeleteTreeItemData(hChild);
			HTREEITEM hChildNext = m_ctcTree.GetNextSiblingItem(hChild);
			m_ctcTree.DeleteItem( hChild);
			hChild = hChildNext;
		}

	}



	TV_INSERTSTRUCT tvstruct;

	tvstruct.item.hItem = m_hHit;
	tvstruct.item.mask = TVIF_CHILDREN;
	tvstruct.item.cChildren = 1;
	m_ctcTree.SetItem(&tvstruct.item);

	UINT nStateMask = TVIS_EXPANDEDONCE;
	UINT uState =
		m_ctcTree.GetItemState( m_hHit, nStateMask );

	uState = 0;

    m_ctcTree.SetItemState(m_hHit, uState, TVIS_EXPANDEDONCE);

	InvalidateControl();
	SetModifiedFlag();
}

void CNavigatorCtrl::OnUpdatePopupRefresh(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here

	CString csObject = m_pctidHit ? m_pctidHit->GetAt(0) : _T("");
	if (csObject.GetLength() > 0 &&
		m_pctidHit -> m_nType == CTreeItemData::ObjectInst)
	{
		if (m_ctcTree.IsTreeItemExpandable(m_hHit))
		{
			pCmdUI -> Enable(  TRUE );
		}
		else
		{
			pCmdUI -> Enable(  FALSE );
		}
	}
	else
	{
		pCmdUI -> Enable(  FALSE );
	}
}

void CNavigatorCtrl::PassThroughGetIWbemServices
(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
	FireGetIWbemServices
		(lpctstrNamespace,
		pvarUpdatePointer,
		pvarServices,
		pvarSC,
		pvarUserCancel);
}

IWbemServices *CNavigatorCtrl::InitServices
(CString *pcsNameSpace)
{
	CString csObjectPath;

	if (pcsNameSpace == NULL || pcsNameSpace->IsEmpty())
	{
		PreModalDialog();
		CInitNamespaceDialog cindInitNamespace;

		cindInitNamespace.m_pParent = this;
		INT_PTR nReturn = cindInitNamespace.DoModal();

		PostModalDialog();

		if (nReturn == IDOK)
		{
			csObjectPath = cindInitNamespace.GetNamespace();
			*pcsNameSpace = csObjectPath;
		}
		else
		{
			return NULL;
		}
	}
	else
	{
		 csObjectPath = *pcsNameSpace;
	}


    IWbemServices *pSession = 0;
    IWbemServices *pChild = 0;

    CString csUser = _T("");

    pSession = GetIWbemServices(csObjectPath);

    return pSession;
}

IWbemServices *CNavigatorCtrl::GetIWbemServices
(CString &rcsNamespace)
{
	IUnknown *pServices = NULL;

	BOOL bUpdatePointer= FALSE;

	m_sc = S_OK;
	m_bUserCancel = FALSE;

	VARIANT varUpdatePointer;
	VariantInit(&varUpdatePointer);
	varUpdatePointer.vt = VT_I4;
	if (bUpdatePointer == TRUE)
	{
		varUpdatePointer.lVal = 1;
	}
	else
	{
		varUpdatePointer.lVal = 0;
	}

	VARIANT varService;
	VariantInit(&varService);

	VARIANT varSC;
	VariantInit(&varSC);

	VARIANT varUserCancel;
	VariantInit(&varUserCancel);

	FireGetIWbemServices
		((LPCTSTR)rcsNamespace,  &varUpdatePointer,  &varService, &varSC,
		&varUserCancel);

	if (varService.vt & VT_UNKNOWN)
	{
		pServices = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}

	varService.punkVal = NULL;

	VariantClear(&varService);

	if (varSC.vt == VT_I4)
	{
		m_sc = varSC.lVal;
	}
	else
	{
		m_sc = WBEM_E_FAILED;
	}

	VariantClear(&varSC);

	if (varUserCancel.vt == VT_BOOL)
	{
		m_bUserCancel = varUserCancel.boolVal;
	}

	VariantClear(&varUserCancel);

	VariantClear(&varUpdatePointer);

	IWbemServices *pRealServices = NULL;
	if (m_sc == S_OK && !m_bUserCancel)
	{
		pRealServices = reinterpret_cast<IWbemServices *>(pServices);
		m_cbBannerWindow.EnableSearchButton(TRUE);
	}

	return pRealServices;
}

void CNavigatorCtrl::OnResetState()
{
	// TODO: Add your specialized code here and/or call the base class

	COleControl::OnResetState();
}

void CNavigatorCtrl::OnMenuiteminitialroot()
{
	// TODO: Add your command handler code here

	CString csObject = m_pctidHit ? m_pctidHit->GetAt(0) : _T("");
	BOOL bReturn;
	if (csObject.GetLength() > 0)
	{
		bReturn = UpdateNamespaceConfigInstance
			(GetServices(), &csObject, m_csNameSpace);
		OnSetroot();
	}

}

void CNavigatorCtrl::OnUpdateMenuiteminitialroot(CCmdUI* pCmdUI)
{
	CString csObject = m_pctidHit ? m_pctidHit->GetAt(0) : _T("");

	if (csObject.GetLength() > 0 &&
		m_pctidHit -> m_nType == CTreeItemData::ObjectInst)
	{
		pCmdUI -> Enable(  TRUE );
	}
	else
	{
		pCmdUI -> Enable(  FALSE );
	}


}

void CNavigatorCtrl::SetProgressDlgMessage(CString &csMessage)
{
	m_pProgressDlg->SetMessage(csMessage);
}

void CNavigatorCtrl::SetProgressDlgLabel(CString &csLabel)
{
	m_pProgressDlg->SetLabel(csLabel);
}

void CNavigatorCtrl::CreateProgressDlgWindow()
{
	PreModalDialog();
	m_pProgressDlg->Create(this);
}

BOOL CNavigatorCtrl::CheckCancelButtonProgressDlgWindow()
{
	if (m_pProgressDlg->GetSafeHwnd())
	{
		return m_pProgressDlg->CheckCancelButton();
	}

	return FALSE;
}

void CNavigatorCtrl::UpdateProgressDlgWindowStrings()
{
	if (m_pProgressDlg->GetSafeHwnd())
	{
		m_pProgressDlg->UpdateWindowStrings();
	}

}

void CNavigatorCtrl::DestroyProgressDlgWindow(BOOL bSetFocus, BOOL bRedrawControl)
{
	if (m_pProgressDlg->GetSafeHwnd())
	{
		m_pProgressDlg->DestroyWindow();
		PostModalDialog();
	}

	if (bSetFocus)
	{
		PostMessage(SETFOCUS,0,0);
	}

	if (bRedrawControl)
	{
		InvalidateControl();
	}
}

void CNavigatorCtrl::PumpMessagesProgressDlgWindow()
{
	if (m_pProgressDlg->GetSafeHwnd())
	{
		m_pProgressDlg->PumpMessages();
	}
}

HWND CNavigatorCtrl::GetProgressDlgSafeHwnd()
{
	return m_pProgressDlg->GetSafeHwnd();
}

LRESULT CNavigatorCtrl::SetFocus(WPARAM, LPARAM)
{
	COleControl::SetFocus();
	return 0;
}

CPtrArray *CNavigatorCtrl::SemiSyncEnum
(IEnumWbemClassObject *pEnum, BOOL &bCancel,
 HRESULT &hResult, int nRes)
{

	if (!pEnum)
		return NULL;

	CPtrArray *pcpaObjects = new CPtrArray;

	IWbemClassObject *pObject = NULL;
	ULONG uReturned = 0;
	hResult = S_OK;

	IWbemClassObject     **pimcoInstances = new IWbemClassObject *[nRes];

	int i;

	for (i = 0; i < nRes; i++)
	{
		pimcoInstances[i] = NULL;
	}


	hResult =
			pEnum->Next(100,nRes, pimcoInstances, &uReturned);


#ifdef _DEBUG
//	afxDump << _T("************* SemiSyncEnum *****************\n*********");
//	afxDump << _T("Next uReturned = " ) << uReturned << _T("\n");
	CString csAsHex;
	csAsHex.Format(_T("0x%x"),hResult);
//	afxDump << _T("Next hResult = " ) << csAsHex << _T("\n");
#endif


	int cInst = 0;

	BOOL bDone = FALSE;
	bCancel = FALSE;
	while(!bDone && !bCancel &&
			(hResult == S_OK || hResult == WBEM_S_TIMEDOUT ||  uReturned > 0))
	{

#pragma warning( disable :4018 )
		for (int i = 0; i < uReturned; i++)
#pragma warning( default : 4018 )
		{
			IWbemClassObject *pTemp = pimcoInstances[i];
			if (pTemp)
			{
				pcpaObjects->Add(reinterpret_cast<void *>(pTemp));
				pimcoInstances[i] = NULL;
			}
#ifdef _DEBUG
			else
			{
//				afxDump << _T("************* SemiSyncEnum *****************\n*********");
//				afxDump << _T("Null pointer returned.\n");
			}
#endif

		}
		bCancel = CheckCancelButtonProgressDlgWindow();
		cInst += uReturned;
		uReturned = 0;
		if (cInst < nRes && ! bCancel)
		{
			hResult = pEnum->Next
				(100,nRes - cInst, pimcoInstances, &uReturned);
#ifdef _DEBUG
//	afxDump << _T("************* SemiSyncEnum *****************\n*********");
//	afxDump << _T("Next uReturned = " ) << uReturned << _T("\n");
	CString csAsHex;
	csAsHex.Format(_T("0x%x"),hResult);
//	afxDump << _T("Next hResult = " ) << csAsHex << _T("\n");
#endif
		}
		else
		{
			if (!bCancel)
			{
				bDone = TRUE;
			}
		}

	}

	delete[]pimcoInstances;
	if (bCancel)
	{
		for (int i = 0; i < pcpaObjects->GetSize(); i++)
		{
			IWbemClassObject *pObject =
				reinterpret_cast<IWbemClassObject *>
			(pcpaObjects->GetAt(i));
			pObject->Release();

		}
		pcpaObjects->RemoveAll();

	}

	return pcpaObjects;

}

void CNavigatorCtrl::OnKillFocus(CWnd* pNewWnd)
{
	COleControl::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	Refresh();

}

void CNavigatorCtrl::OnSetFocus(CWnd* pOldWnd)
{
	COleControl::OnSetFocus(pOldWnd);

	OnActivateInPlace(TRUE,NULL);

	if (m_bRestoreFocusToTree)
	{
		m_ctcTree.SetFocus();
	}
	else
	{
		m_cbBannerWindow.SetFocus();
	}
}

LRESULT CNavigatorCtrl::SetFocusNSE(WPARAM, LPARAM)
{
	m_cbBannerWindow.m_pnseNameSpace->SetFocus();
	return 0;
}

/*	EOF:  NavigatorCtl.cpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\navigatorctl.h ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: NavigatorCtl.h
//
// Description:
//	This file declares the CNavigatorCtrl ActiveX control class.
//	The CNavigatorCtl class is a part of the Instance Navigator OCX, it
//  is a subclass of the Mocrosoft COleControl class and performs
//	the following functions:
//		a.
//		b.
//		c.
//
// Part of:
//	Navigator.ocx
//
// Used by:
//
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
// **************************************************************************

#ifndef _NAVIGATORCTL_H_
#define _NAVIGATORCTL_H_


//****************************************************************************
//
// CLASS:  CNavigatorCtrl
//
// Description:
//	This class is a subclass of the Microsoft COleControl class.  It
//	specializes the class to bea able to interact with the HMM database and
//	display HMM instance data.
//
// Public members:
//
//	IconIndex
//	ClosedIcon
//	OpenedIcon
//	PlaceHolderIcon
//	GetServices
//
//============================================================================
//	IconIndex			Enumeration of indexes into the control's image list.
//	ClosedIcon			Returns the index of the closed folder icon contained
//						in the m_pcilImageList image list which is used by the
//						CInstanceTree instance.
//	OpenedIcon			Returns the index of the opened folder icon contained
//						in the m_pcilImageList image list which is used by the
//						CInstanceTree instance.
//	PlaceHolderIcon		Returns the index of the default non-association icon
//						contained in the m_pcilImageList image list which is
//						used by the CInstanceTree instance.
//	GetServices			Returns a pointer to the the IWbemServices COM object
//						instance
//
//============================================================================
//
//  CNavigatorCtrl::ClosedIcon
//
// Description:
//	  This member function returns the index of the closed folder icon
//	  in the CNavigatorCtrl's m_pcilImageList image list which is used by the
//	  CInstanceTree instance.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  int				Index into the image list used by the tree control.
//
//============================================================================
//
//  CNavigatorCtrl::OpenedIcon
//
// Description:
//	  This member function returns the index of the opened folder icon
//	  in the CNavigatorCtrl's m_pcilImageList image list which is used by the
//	  CInstanceTree instance.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  int				Index into the image list used by the tree control.
//
//============================================================================
//
//  CNavigatorCtrl::PlaceHolderIcon
//
// Description:
//	  This member function returns the index of the non-association icon
//	  contained in the CNavigatorCtrl's m_pcilImageList image list which is used
//	  by the CInstanceTree instance.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  int				Index into the image list used by the tree control.
//
//============================================================================
//
//  CNavigatorCtrl::GetServices
//
// Description:
//	  This member function returns a pointer to the the IWbemServices COM object
//	  instance
//
// Parameters:
//	  VOID
//
// Returns:
// 	  IWbemServices *		Pointer to the Wbem Services COM object.
//
//****************************************************************************


#define ID_MULTIINSTANCEVIEW WM_USER + 23
#define ID_SETTREEROOT WM_USER + 24
#define INVALIDATE_CONTROL WM_USER + 25
#define INITIALIZE_NAMESPACE WM_USER + 300
#define INIT_TREE_FOR_DRAWING WM_USER + 301
#define REDRAW_CONTROL WM_USER + 590
#define SETFOCUS WM_USER + 591
#define SETFOCUSNSE WM_USER + 592

typedef enum
{
	ALL_INSTANCES = 1,
	ASSOC_GROUPING,
	OBJECT_GROUPING_WITH_INSTANCES,
	OBJECT_GROUPING_NO_INSTANCES,
	NO_APPEAR,
	ALL_IGNORE
} NAVIGATOR_APPEARANCE;

const int IDC_OBJID = 1;
const int IDC_FILTER = 2;
const int IDC_TREE = 3;
const int IDC_NSENTRY = 4;
const int IDC_NAMESPACEBUTTON = 5;
const int IDC_TOOLBAR = 6;

const int nSideMargin = 10;
const int nTopMargin = 6;

struct IWbemServices;
struct IWbemClassObject;
class CPathDialog;
class CInstanceSearch;
class CInstNavNSEntry;
class CBrowseforInstances;
class CProgressDlg;
class CInitNamespaceDialog;
class CInitNamespaceNSEntry;
class CResults;

struct ParsedObjectPath;

class CComparePaths
{
public:
	BOOL PathsRefSameObject(BSTR bstrPath1, BSTR bstrPath2);

private:
	int CompareNoCase(LPWSTR pws1, LPWSTR pws2);
	BOOL IsEqual(LPWSTR pws1, LPWSTR pws2) {return CompareNoCase(pws1, pws2) == 0; }
	BOOL PathsRefSameObject(ParsedObjectPath* ppath1, ParsedObjectPath* ppath2);
	void NormalizeKeyArray(ParsedObjectPath& path);
	BOOL IsSameObject(BSTR bstrPath1, BSTR bstrPath2);
	BOOL KeyValuesAreEqual(VARIANT& variant1, VARIANT& variant2);
};



class CNavigatorCtrl : public COleControl
{

	DECLARE_DYNCREATE(CNavigatorCtrl)
public:
	enum IconIndex {
			ICONINSTANCE = 0,
			ICONNEINSTANCE,
			ICONGROUP,
			ICONEGROUP,
			ICONASSOCROLE,
			ICONEASSOCROLE,
			ICONASSOCINSTANCE,
			ICONOPEN,
			ICONCLOSED,
			ICONCLASS,
			ICONASSOCROLEWEAK,
			ICONASSOCROLEWEAK2
	};


	enum View {
			StandardView = 0,
			ShowAll
	};

	CNavigatorCtrl();
	int ClosedIcon() {return ICONCLOSED;}
	int OpenedIcon() {return ICONOPEN;}
	int IconInstance() {return ICONINSTANCE;}
	int IconNEInstance() {return ICONNEINSTANCE;}
	int IconGroup() {return ICONGROUP;}
	int IconEGroup() {return ICONEGROUP;}
	int IconAssocRole() {return ICONASSOCROLE;}
	int IconEAssocRole() {return ICONEASSOCROLE;}
	int IconAssocInstance() {return ICONASSOCINSTANCE;}
	int IconClass() {return ICONCLASS;}
	int IconAssocRoleWeak() {return ICONASSOCROLEWEAK;}
	int IconAssocRoleWeak2() {return ICONASSOCROLEWEAK2;}

	IWbemServices *GetServices() {return m_pServices;}
	IWbemServices *InitServices(CString *pcsNameSpace);
	BOOL OpenNameSpace(CString *pcsNameSpace);
	CString GetCurrentNamespace(){return m_csNameSpace;}
	IWbemServices *&GetAuxServices() {return m_pAuxServices;}
	CString GetAuxNamespace(){return m_csAuxNameSpace;}

	CPtrArray *SemiSyncEnum
		(IEnumWbemClassObject *pEnum, BOOL &bCancel, HRESULT &hResult, int nRes);

	void SetProgressDlgMessage(CString &csMessage);
	void SetProgressDlgLabel(CString &csLabel);
	void CreateProgressDlgWindow();
	BOOL CheckCancelButtonProgressDlgWindow();
	void DestroyProgressDlgWindow(BOOL bSetFocus = TRUE, BOOL bRedrawControl = FALSE);
	void PumpMessagesProgressDlgWindow();
	HWND GetProgressDlgSafeHwnd();
	void UpdateProgressDlgWindowStrings();

	BOOL m_bRestoreFocusToTree;

	BOOL m_bReadySignal;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNavigatorCtrl)
	public:
	virtual void OnKeyDownEvent(USHORT nChar, USHORT nShiftState);
	virtual void OnResetState();
	protected:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnDrawMetafile(CDC* pDC, const CRect& rcBounds);
	//}}AFX_VIRTUAL

	virtual BOOL PreTranslateMessage(LPMSG lpMsg);

// Implementation
	BOOL m_bOpeningNamespace;
	CString m_csRootPath;
	CString m_csNameSpace;
	CString m_csSingleSelection;
	CString m_csSelectedObjects;
	int m_nSelectedObjects;
	CImageList *m_pcilImageList;
	IWbemServices *m_pServices;
	BOOL m_bNamespaceInit;
	BOOL m_bTreeEmpty;

	BOOL m_bInOnDraw;
	BOOL m_bUserCancelInitialSystemObject;

	~CNavigatorCtrl();
	void InitializeTreeForDrawing(BOOL bNoTreeRoot = FALSE);
	void InitializeTreeRoot();

	CString GetInitialSystemObject();


	BEGIN_OLEFACTORY(CNavigatorCtrl)        // Class factory and guid
    virtual CCmdTarget* OnCreateObject();
	END_OLEFACTORY(CNavigatorCtrl)

	//DECLARE_OLECREATE_EX(CNavigatorCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CNavigatorCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CNavigatorCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CNavigatorCtrl)		// Type name and misc status

	// Contained controls (in the Navigator control).
	CInstanceTree m_ctcTree;
	CBanner m_cbBannerWindow;

	BOOL m_bDrawAll;
	CString m_csBanner;

	CRect m_rBannerRect;
	CRect m_rTreeRect;
	CRect m_rTree;
	int m_nOffset;

	CBrowseforInstances *m_pcbiBrowseDialog;
	CProgressDlg *m_pProgressDlg;

	BOOL m_bInit;
	BOOL m_bFirstDraw;
	BOOL m_bChildrenCreated;

	BOOL m_bMetricSet;
	TEXTMETRIC m_tmFont;
	CFont m_cfFont;
	short m_nFontHeight;
	short m_nFontWeigth;
	CString m_csFontName;
	void CreateControlFont();
	void InitializeLogFont
		(LOGFONT &rlfFont, CString csName, int nHeight, int nWeight);

	CTreeItemData *m_pctidHit;
	HTREEITEM m_hHit;

	void InitializeChildren(int cx, int cy);

	void InitializeChildControlSize(int cx, int cy);
	void SetChildControlGeometry(int cx, int cy);

	void MultiInstanceViewFromTreeChildren();
	void MultiInstanceViewFromObjectGroup();
	void MultiInstanceViewFromAssocRole();


	void SetNewRoot(CString &rcsRoot);

	CString ParentAssociation(HTREEITEM hItem);

	CString m_csAuxNameSpace;
	IWbemServices *m_pAuxServices;

	SCODE m_sc;
	BOOL m_bUserCancel;

	IWbemServices *GetIWbemServices(CString &rcsNamespace);
	void PassThroughGetIWbemServices
		(	LPCTSTR lpctstrNamespace,
			VARIANT FAR* pvarUpdatePointer,
			VARIANT FAR* pvarServices,
			VARIANT FAR* pvarSC,
			VARIANT FAR* pvarUserCancel);


	BOOL m_bRefresh;
	BOOL m_bFireEvents;



// Message maps
	//{{AFX_MSG(CNavigatorCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDestroy();
	afx_msg void OnSetroot();
	afx_msg void OnUpdateSetroot(CCmdUI* pCmdUI);
	afx_msg void OnPopupMultiinstanceviewer();
	afx_msg void OnUpdatePopupMultiinstanceviewer(CCmdUI* pCmdUI);
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnPopupInstancesearch();
	afx_msg void OnPopupParentassociation();
	afx_msg void OnUpdatePopupParentassociation(CCmdUI* pCmdUI);
	afx_msg LRESULT SendInstancesToMultiInstanceViewer(WPARAM, LPARAM);
	afx_msg LRESULT SetNewRoot(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT InitializeTreeForDrawing(WPARAM wParam, LPARAM lParam);
	afx_msg void OnPopupBrowse();
	afx_msg void OnUpdatePopupBrowse(CCmdUI* pCmdUI);
	afx_msg void OnPopupGotonamespace();
	afx_msg void OnUpdatePopupGotonamespace(CCmdUI* pCmdUI);
	afx_msg void OnPopupRefresh();
	afx_msg void OnUpdatePopupRefresh(CCmdUI* pCmdUI);
	afx_msg void OnMenuiteminitialroot();
	afx_msg void OnUpdateMenuiteminitialroot(CCmdUI* pCmdUI);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	afx_msg LRESULT InitializeNamespace(WPARAM, LPARAM);
	afx_msg LRESULT Invalidate(WPARAM, LPARAM);
	afx_msg LRESULT RedrawAll(WPARAM, LPARAM);
	afx_msg LRESULT SetFocus(WPARAM, LPARAM);
	afx_msg LRESULT SetFocusNSE(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CNavigatorCtrl)
	afx_msg BSTR GetNameSpace();
	afx_msg void SetNameSpace(LPCTSTR lpszNewValue);
	afx_msg void OnReadySignal();
	afx_msg long ChangeRootOrNamespace(LPCTSTR lpctstrRootOrNamespace, long lMakeNamespaceCurrent, long lFireEvents);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CNavigatorCtrl)
	void FireNotifyOpenNameSpace(LPCTSTR lpcstrNameSpace)
		{FireEvent(eventidNotifyOpenNameSpace,EVENT_PARAM(VTS_BSTR), lpcstrNameSpace);}
	void FireViewObject(LPCTSTR lpctstrPath)
		{FireEvent(eventidViewObject,EVENT_PARAM(VTS_BSTR), lpctstrPath);}
	void FireViewInstances(LPCTSTR bstrLabel, const VARIANT FAR& vsapaths)
		{FireEvent(eventidViewInstances,EVENT_PARAM(VTS_BSTR  VTS_VARIANT), bstrLabel, &vsapaths);}
	void FireQueryViewInstances(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass)
		{FireEvent(eventidQueryViewInstances,EVENT_PARAM(VTS_BSTR  VTS_BSTR  VTS_BSTR  VTS_BSTR), pLabel, pQueryType, pQuery, pClass);}
	void FireGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
		{FireEvent(eventidGetIWbemServices,EVENT_PARAM(VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT), lpctstrNamespace, pvarUpdatePointer, pvarServices, pvarSC, pvarUserCancel);}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
	enum {
	//{{AFX_DISP_ID(CNavigatorCtrl)
	dispidNameSpace = 1L,
	dispidOnReadySignal = 2L,
	dispidChangeRootOrNamespace = 3L,
	eventidNotifyOpenNameSpace = 1L,
	eventidViewObject = 2L,
	eventidViewInstances = 3L,
	eventidQueryViewInstances = 4L,
	eventidGetIWbemServices = 5L,
	//}}AFX_DISP_ID
	};


private:
	friend class CInstanceTree;
	friend class CBanner;
	friend class CViewSelectDlg;
	friend class CNameSpace;
	friend class CInstNavNSEntry;
	friend class CInitNamespaceDialog;
	friend class CInitNamespaceNSEntry;
	friend class CBrowseforInstances;
	friend class CResults;
};

#endif	// _NAVIGATORCTL_H_

// C:\Program Files\Microsoft Visual Studio\VB98\Vb6.exe
// D:\Wbem11\ActiveXSuite\Test\Controls\VB\Ryan40385\Project1.vbp
/*	EOF:  NavigatorCtl.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\navigatorppg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// NavigatorPpg.cpp : Implementation of the CNavigatorPropPage property page class.

#include "precomp.h"
#include "Navigator.h"
#include "NavigatorPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CNavigatorPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CNavigatorPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CNavigatorPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CNavigatorPropPage, "WBEM.InstNavPropPage.1",
	0xc7eadeb4, 0xecab, 0x11cf, 0x8c, 0x9e, 0, 0xaa, 0, 0x6d, 0x1, 0xa)


/////////////////////////////////////////////////////////////////////////////
// CNavigatorPropPage::CNavigatorPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CNavigatorPropPage

BOOL CNavigatorPropPage::CNavigatorPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_NAVIGATOR_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CNavigatorPropPage::CNavigatorPropPage - Constructor

CNavigatorPropPage::CNavigatorPropPage() :
	COlePropertyPage(IDD, IDS_NAVIGATOR_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CNavigatorPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CNavigatorPropPage::DoDataExchange - Moves data between page and properties

void CNavigatorPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CNavigatorPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CNavigatorPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\nsentry.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "nsentry.h"

/////////////////////////////////////////////////////////////////////////////
// CNSEntry

IMPLEMENT_DYNCREATE(CNSEntry, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CNSEntry properties

CString CNSEntry::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CNSEntry::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CNSEntry operations

long CNSEntry::OpenNamespace(LPCTSTR bstrNamespace, long longNoFireEvent)
{
	SCODE result;
	static BYTE parms[] =
		VTS_BSTR VTS_I4;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		bstrNamespace, longNoFireEvent);
	return result;
}

void CNSEntry::SetNamespaceText(LPCTSTR lpctstrNamespace)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace);
}

CString CNSEntry::GetNamespaceText()
{
	CString result;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_BSTR, (void*)&result, NULL);
	return result;
}

long CNSEntry::IsTextValid()
{
	long result;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CNSEntry::ClearOnLoseFocus(long lClearOnLoseFocus)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lClearOnLoseFocus);
}

void CNSEntry::SetFocusToEdit()
{
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CNSEntry::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\nsentry.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_NSENTRY_H__314E86A1_9697_11D1_966E_00C04FD9B15B__INCLUDED_)
#define AFX_NSENTRY_H__314E86A1_9697_11D1_966E_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CNSEntry wrapper class

class CNSEntry : public CWnd
{
protected:
	DECLARE_DYNCREATE(CNSEntry)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xc3db0bd3, 0x7ec7, 0x11d0, { 0x96, 0xb, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);

// Operations
public:
	long OpenNamespace(LPCTSTR bstrNamespace, long longNoFireEvent);
	void SetNamespaceText(LPCTSTR lpctstrNamespace);
	CString GetNamespaceText();
	long IsTextValid();
	void ClearOnLoseFocus(long lClearOnLoseFocus);
	void SetFocusToEdit();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NSENTRY_H__314E86A1_9697_11D1_966E_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\pathdialog.cpp ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: pathdialog.cpp
//
// Description:
//	This file implements the CPathDialog class which is a subclass
//	of the MFC CDialog class.  It is a part of the Instance Explorer OCX,
//	and it performs the following functions:
//		a.  Allows the user to enter an object path for the tree root..
//
// Part of:
//	Navigator.ocx
//
// Used by:
//	CNavigatorCtrl
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

#include "precomp.h"
#include "afxpriv.h"
#include "wbemidl.h"
#include "resource.h"
#include "AFXCONV.H"
#include "CInstanceTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "InstanceSearch.h"
#include "NavigatorCtl.h"
#include "OLEMSCLient.h"
#include "PathDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//****************************************************************************
//
// CPathDialog::CPathDialog
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  CClassNavCtrl* pParent	Parent
//
// Returns:
// 	  NONE
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
CPathDialog::CPathDialog(CNavigatorCtrl* pParent /*=NULL*/)
	: CDialog(CPathDialog::IDD, NULL)
{
	//{{AFX_DATA_INIT(CPathDialog)
	m_csPath = _T("");
	//}}AFX_DATA_INIT
	m_pParent = pParent;
}

// ***************************************************************************
//
// CPathDialog::DoDataExchange
//
// Description:
//	  Called by the framework to exchange and validate dialog data.
//
// Parameters:
//	  pDX			A pointer to a CDataExchange object.
//
// Returns:
// 	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CPathDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPathDialog)
	DDX_Text(pDX, IDC_EDIT1, m_csPath);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPathDialog, CDialog)
	//{{AFX_MSG_MAP(CPathDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/*	EOF:  pathdialog.cpp  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\olemsclient.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved


SCODE MakeSafeArray(SAFEARRAY FAR ** pRet, VARTYPE vt, int iLen);

SCODE PutStringInSafeArray(SAFEARRAY FAR * psa,CString *pcs, int iIndex);

BOOL GetErrorObjectText
(IWbemClassObject *pErrorObject, CString &rcsDescription);

BOOL NamespaceEqual
	(CString *pcsNamespace1, CString *pcsNamespace2);

BOOL WbemObjectIdentity(CString &rcsWbem1, CString &rcsWbem2);

BOOL COMObjectIdentity(IWbemClassObject *piWbem1, IWbemClassObject *piWbem2);

CString GetBSTRProperty
(IWbemClassObject * pInst, CString *pcsProperty);

long GetAttribBool
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName, 
 BOOL &bReturn);

COleVariant GetProperty
(IWbemServices * pProv, IWbemClassObject * pInst, 
 CString *pcsProperty);

int GetAssocRolesAndPaths
	(IWbemClassObject *pAssoc , CString *&pcsRolesAndPaths);

CString GetPropertyNameByAttrib
(IWbemClassObject *pObject , CString *pcsAttrib);

COleVariant GetPropertyValueByAttrib
(IWbemClassObject *pObject , CString *pcsAttrib);

CStringArray *GetAllKeys(CString &rcsFullPath);

BOOL HasAttribBool
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName);

int GetPropNames
(IWbemClassObject * pClass, CString *&pcsReturn);

CString GetBSTRAttrib
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName);

CString BuildOBJDBGetRefQuery
(IWbemServices *pProv, CString *pcsTarget, 
 CString *pcsResultClass, CString *pcsRoleFilter,
 CString *pcsReqAttrib = NULL, BOOL bClassOnly = FALSE);

CString BuildOBJDBGetAssocsQuery
(IWbemServices *pProv, CString *pcsTargetPath, 
 CString *pcsAssocClass, CString *pcsResultClass, 
 CString *pcsMyRoleFilter, CString *pcsReqAttrib, 
 CString *pcsReqAssocAttrib, CString *pcsResultRole, BOOL bClassOnly, BOOL bKeysOnly);

IEnumWbemClassObject *ExecOBJDBQuery
(IWbemServices * pProv, CString &csQuery, CString & rcsNamespace);

CStringArray *GetAssocInstances
(IWbemServices * pProv, CString *pcsInst, CString *pcsAssocClass,
 CString *pcsRole,  CString csCurrentNamespace, CString &rcsAuxNamespace,
 IWbemServices *&rpAuxServices, CNavigatorCtrl *pControl);

CStringArray *GetAssocRoles 
(IWbemServices * pProv,IWbemClassObject *pimcoAssoc, 
 IWbemClassObject *pimcoExclude); 

CString GetIWbemGroupingClass
	(IWbemServices *pProv,IWbemClassObject *pClass, BOOL bPath = FALSE);

CStringArray *AssocPathRoleKey(CString *pcsPath);

CString GetDisplayLabel
(CString &rcsClass,CString *pcsNamespace);

CString GetDisplayLabel
(IWbemServices *pProv,IWbemClassObject *pimcoClass,CString *pcsNamespace);

CString GetIWbemClass(CString &rcsFullPath);

CString GetIWbemClass(IWbemServices *pProv, IWbemClassObject *pClass);

CString GetIWbemRelPath(IWbemServices *pProv, IWbemClassObject *pClass);

CString GetIWbemRelPath(CString *pcsFullPath);

CString GetIWbemFullPath(IWbemServices *pProv, IWbemClassObject *pClass);

BOOL ObjectInDifferentNamespace
			(CString *pcsNamespace, CString *pcsObjectPath);

CString GetPCMachineName();

long GetAttribLong
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName, 
 long &lReturn);

CStringArray * CrossProduct(CStringArray *pcsaFirst, CStringArray *pcsaSecond);

void AddIWbemClassObjectToArray
(IWbemServices *pProv,IWbemClassObject *pObject,CStringArray *pcsaObjectInstances,
BOOL bAllowDups = FALSE, BOOL bTestOnPath = TRUE);

void AddIWbemClassObjectToArray(CString *pcsPath, CStringArray *pcsaObjectInstances);


CPtrArray *GetInstances(IWbemServices *pServices, CString *pcsClass, CString &rcsNamespace,
						BOOL bDeep = FALSE, BOOL bQuietly = FALSE);

BOOL IsClass(CString &rcsObject);

BOOL ClassCanHaveInstances(IWbemClassObject* pObject);

BOOL IsSystemClass(IWbemClassObject* pObject);

BOOL IsAssoc(IWbemClassObject* pObject);

CStringArray *GetNamespaces(IWbemLocator *pLocator,
							CString *pcsNamespace, BOOL bDeep = FALSE);

BOOL PathHasKeys(CString *pcsPath);

CString GetObjectNamespace(CString *pcsPath);

extern IWbemClassObject *GetIWbemObject
(CNavigatorCtrl *pControl,IWbemServices *pServices, CString csCurrentNameSpace, 
 CString& csAuxNameSpace, IWbemServices *&pAuxServices, 
 CString &rcsObject,BOOL bErrorMsg);

void ReleaseErrorObject(IWbemClassObject *&rpErrorObject);

void ErrorMsg
(CString *pcsUserMsg, SCODE sc, 
 IWbemClassObject *pErrorObject, BOOL bLog, 
 CString *pcsLogMsg, char *szFile, int nLine,
 UINT uType = MB_ICONEXCLAMATION);

void LogMsg
(CString *pcsLogMsg, char *szFile, int nLine);

CString ObjectsRoleInAssocInstance
	(IWbemServices *pProv, IWbemClassObject *pAssoc, IWbemClassObject *pObject);

CString GetObjectClassForRole
	(IWbemServices *pProv,IWbemClassObject *pAssocRole,CString *pcsRole);

int GetCBitmapWidth(const CBitmap & cbm);

int GetCBitmapHeight(const CBitmap & cbm);

HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPCTSTR lpString,
                           HPALETTE FAR* lphPalette);

HPALETTE CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors);

CPalette *GetResourcePalette(HINSTANCE hInstance, LPCTSTR lpString,
                           HPALETTE FAR* lphPalette);

CPalette *CreateCPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors);

BOOL StringInArray
(CStringArray *&rpcsaArrays, CString *pcsString, int nIndex);

void InitializeLogFont
(LOGFONT &rlfFont, CString csName, int nHeight, int nWeight);


CRect OutputTextString
(CPaintDC *pdc, CWnd *pcwnd, CString *pcsTextString, int x, int y,
 CString *pcsFontName, int nFontHeight, int nFontWeigth);

void OutputTextString
(CPaintDC *pdc, CWnd *pcwnd, CString *pcsTextString, int x, int y,
 CRect &crExt, CString *pcsFontName, int nFontHeight, 
 int nFontWeigth);

HRESULT ConfigureSecurity(IWbemServices *pServices);

HRESULT ConfigureSecurity(IEnumWbemClassObject *pEnum);

HRESULT ConfigureSecurity(IUnknown *pUnknown);

SCODE CreateNamespaceConfigClassAndInstance
	(IWbemServices *pProv, CString *pcsNamespace, CString *pcsRootPath);

BOOL SetProperty
(IWbemServices * pProv, IWbemClassObject * pInst, 
 CString *pcsProperty, CString *pcsPropertyValue,
 BOOL bQuietly);

BOOL UpdateNamespaceConfigInstance
(IWbemServices *pProv, CString *pcsRootPath, CString &rcsNamespace);

void MoveWindowToLowerLeftOfOwner(CWnd *pWnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\olemsclient.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  OLEMSClient.cpp
//
//  Module: Navigator.OCX
//
//
//***************************************************************************
#include "precomp.h"
#include <OBJIDL.H>
#include "resource.h"
#include <nddeapi.h>
#include <initguid.h>
#include "wbemidl.h"
#include "CInstanceTree.h"
#include "Navigator.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "InstanceSearch.h"
#include "NavigatorCtl.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include "MsgDlgExterns.h"
#include "logindlg.h"

#include "OLEMSClient.h"

#define BUFF_SIZE 256


// VT_BSTR for strings
SCODE MakeSafeArray(SAFEARRAY FAR ** pRet, VARTYPE vt, int iLen)
{
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iLen ;
    *pRet = SafeArrayCreate(vt,1, rgsabound);
    return (*pRet == NULL) ? 0x80000001 : S_OK;
}

SCODE PutStringInSafeArray
(SAFEARRAY FAR * psa,CString *pcs, int iIndex)
{
    long ix[2];
    ix[1] = 0;
    ix[0] = iIndex;
	long l = iIndex;
	BSTR bstrOut = pcs -> AllocSysString();
    HRESULT hResult = SafeArrayPutElement(psa,&l,bstrOut);

	//SysFreeString(bstrOut);

	return GetScode(hResult);
}

BOOL GetErrorObjectText
(IWbemClassObject *pErrorObject, CString &rcsDescription)
{
	if (!pErrorObject)
	{
		rcsDescription.Empty();
		return FALSE;
	}

	CString csProp = _T("Description");
	CString csDescription = GetBSTRProperty(pErrorObject,&csProp);
	if (csDescription.IsEmpty() || csDescription.GetLength() == 0)
	{
		rcsDescription.Empty();
		return FALSE;
	}
	else
	{
		rcsDescription = csDescription;
		return TRUE;
	}


}



//***************************************************************************
//
// GetBSTRAttrib
//
// Purpose: Get the value of a class or property BSTR Qualifier
//
//***************************************************************************
CString GetBSTRAttrib
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName)
{
    SCODE sc;
	CString csReturn;

    IWbemQualifierSet * pAttribSet = NULL;
    if(pcsPropName != NULL)   // Property Qualifier
	{
		BSTR bstrTemp = pcsPropName -> AllocSysString();
        sc = pClassInt->GetPropertyQualifierSet(bstrTemp,
					&pAttribSet);
		::SysFreeString(bstrTemp);
	}
    else	// A class Qualifier
        sc = pClassInt->GetQualifierSet(&pAttribSet);
    if (sc != S_OK)
	{
		return csReturn;
	}

	VARIANTARG var;
	VariantInit(&var);

	long lReturn;
	BSTR bstrTemp = pcsAttribName -> AllocSysString();
    sc = pAttribSet->Get(bstrTemp, 0,
		&var, &lReturn);
	::SysFreeString(bstrTemp);

	if (sc == S_OK)
		csReturn = var.bstrVal;
	else
	{
		pAttribSet->Release();
		return csReturn;
	}

    pAttribSet->Release();
    VariantClear(&var);
    return csReturn;
}

long GetAttribBool
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName,
 BOOL &bReturn)
{
    SCODE sc;
    IWbemQualifierSet *pAttribSet = NULL;
    if(pcsPropName != NULL)   // Property Qualifier
	{
		BSTR bstrTemp = pcsPropName -> AllocSysString();
        sc = pClassInt->GetPropertyQualifierSet(bstrTemp,
					&pAttribSet);
		::SysFreeString(bstrTemp);
	}
    else	// A class Qualifier
        sc = pClassInt->GetQualifierSet(&pAttribSet);

	if (sc != S_OK)
	{
		bReturn = FALSE;
		return S_OK;
	}

	VARIANTARG var;
	VariantInit(&var);

	BSTR bstrTemp = pcsAttribName -> AllocSysString();
    sc = pAttribSet->Get(bstrTemp, 0, &var, NULL);
	::SysFreeString(bstrTemp);

	if (sc == S_OK)
		bReturn = V_BOOL(&var);
	else
		bReturn = FALSE;


    pAttribSet->Release();
    VariantClear(&var);
    return sc;
}

//***************************************************************************
//
// PutAttLong
//
// Purpose: writes an long Qualifier.
//
//***************************************************************************
SCODE PutAttribLong
(IWbemClassObject * pClassInt,CString *pcsPropName,CString *pcsAttribName,
           long lType, long lValue)
{
    SCODE sc;
    IWbemQualifierSet * pAttribSet = NULL;
    if(pcsPropName != NULL)   // Property Qualifier
	{
		BSTR bstrTemp = pcsPropName -> AllocSysString();
        sc = pClassInt->GetPropertyQualifierSet(bstrTemp,
					&pAttribSet);
		::SysFreeString(bstrTemp);
	}
    else	// A class Qualifier
        sc = pClassInt->GetQualifierSet(&pAttribSet);
    if (sc != S_OK)
	{
		return sc;
	}



	VARIANTARG var;
	VariantInit(&var);
	var.vt = VT_I4;
	var.lVal = lValue;

	BSTR bstrTemp = pcsAttribName -> AllocSysString();
    sc = pAttribSet->Put(bstrTemp,&var,lType);
	::SysFreeString(bstrTemp);
    pAttribSet->Release();
    VariantClear(&var);
    return sc;
}

//***************************************************************************
//
// GetAttLong
//
// Purpose: gets an long Qualifier.
//
//***************************************************************************
long GetAttribLong
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName,
 long &lReturn)
{
    SCODE sc;
    IWbemQualifierSet * pAttribSet = NULL;
    if(pcsPropName != NULL)   // Property Qualifier
	{
		BSTR bstrTemp = pcsPropName -> AllocSysString();
        sc = pClassInt->GetPropertyQualifierSet(bstrTemp,
					&pAttribSet);
		::SysFreeString(bstrTemp);
	}
    else	// A class Qualifier
        sc = pClassInt->GetQualifierSet(&pAttribSet);
    if (sc != S_OK)
	{
		return sc;
	}

	VARIANTARG var;
	VariantInit(&var);
	var.vt = VT_I4;

	BSTR bstrTemp = pcsAttribName -> AllocSysString();
    sc = pAttribSet->Get(bstrTemp, 0, &var, NULL);
	::SysFreeString(bstrTemp);


	if (sc == S_OK)
		lReturn = var.lVal;
	else
		lReturn = -111;


    pAttribSet->Release();
    VariantClear(&var);
    return sc;
}


//***************************************************************************
//
// HasAttribBool
//
// Purpose: Predicate to determine if a objecthas a Boolean Qualifier.
//
//***************************************************************************
BOOL HasAttribBool
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName)
{
    SCODE sc;
	BOOL bReturn;
    IWbemQualifierSet * pAttribSet = NULL;
    if(pcsPropName != NULL)   // Property Qualifier
	{
		BSTR bstrTemp = pcsPropName -> AllocSysString();
        sc = pClassInt->GetPropertyQualifierSet(bstrTemp,
					&pAttribSet);
		::SysFreeString(bstrTemp);
	}
    else	// A class Qualifier
        sc = pClassInt->GetQualifierSet(&pAttribSet);
    if (sc != S_OK)
	{
		return FALSE;
	}

	VARIANTARG var;
	VariantInit(&var);
	var.vt =  VT_BOOL;

	BSTR bstrTemp = pcsAttribName -> AllocSysString();
    sc = pAttribSet->Get(bstrTemp, 0, &var, NULL);
	::SysFreeString(bstrTemp);

	if (sc == S_OK)
		bReturn = TRUE;
	else
		bReturn = FALSE;


    pAttribSet->Release();
    VariantClear(&var);
    return bReturn;
}


//***************************************************************************
//
// GetAssocRolesAndPaths
//
// Purpose: For an Assoc instance return its roles and object paths.
//
//***************************************************************************

int GetAssocRolesAndPaths(IWbemClassObject *pAssoc , CString *&pcsRolesAndPaths)
{
	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;
	int nProps;
	CString *pcsProps;

	nProps = GetPropNames(pAssoc, pcsProps);
	int i,k;
	IWbemQualifierSet * pAttrib = NULL;
	CString csRef = _T("cimtype");
	int cRefs = 0;
	pcsRolesAndPaths = new CString[nProps * 2];
	CString csTmp = _T("syntax");
	k = 0;  // index into pcsRolesAndPaths
	for (i = 0; i < nProps; i++)
	{
		BSTR bstrTemp = pcsProps[i].AllocSysString();
		sc = pAssoc -> GetPropertyQualifierSet(bstrTemp,
						&pAttrib);
		::SysFreeString(bstrTemp);
		if (sc == S_OK)
		{
			VARIANTARG var;
			VariantInit(&var);
			sc = pAttrib->GetNames(0,&psa);
			 if(sc == S_OK)
			{
				int iDim = SafeArrayGetDim(psa);
				sc = SafeArrayGetLBound(psa,1,&lLower);
				sc = SafeArrayGetUBound(psa,1,&lUpper);
				BSTR AttrName;
				for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
				{
					sc = SafeArrayGetElement(psa,ix,&AttrName);
					csTmp = AttrName;

					//Get the attrib value
					long lReturn;
					BSTR bstrTemp = csTmp.AllocSysString();
					sc = pAttrib -> Get(bstrTemp, 0,
										&var,&lReturn);
					::SysFreeString(bstrTemp);
					if (sc != S_OK)
					{
						CString csUserMsg;
						csUserMsg =  _T("Cannot get qualifier value ");
						csUserMsg += pcsProps[i] + _T(" for object ");
						csUserMsg += GetIWbemFullPath (NULL, pAssoc);
						csUserMsg += _T(" quialifier ") + csTmp;
						ErrorMsg
								(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
								__LINE__ - 11);
					}
					else
					{
						CString csValue;
						CString csValue2;
						if (var.vt == VT_BSTR)
						{
							csValue = var.bstrVal;
							csValue2 = csValue.Right(max((csValue.GetLength() - 4), 0));
							csValue = csValue.Left(4);
						}
						if (csRef.CompareNoCase(csTmp)  == 0 &&
							(csValue.CompareNoCase(_T("ref:")) == 0 ||
							 csValue.CompareNoCase(_T("ref")) == 0))
						{
							cRefs++;
							pcsRolesAndPaths[k++] = pcsProps[i];
							pcsRolesAndPaths[k++] = csValue2;
						}
						SysFreeString(AttrName);
					}
				}
			 }
			 pAttrib -> Release();
		}
	}
	SafeArrayDestroy(psa);
	delete [] pcsProps;
	return cRefs;
}


//***************************************************************************
//
// GetPropertyNameByAttrib
//
// Purpose: For an object get a property name by Qualifier.
//
//***************************************************************************
CString GetPropertyNameByAttrib(IWbemClassObject *pObject , CString *pcsAttrib)
{
	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;
	int nProps;
	CString *pcsProps;
	nProps = GetPropNames(pObject, pcsProps);
	int i;
	IWbemQualifierSet * pAttrib = NULL;
	CString csTmp;
	CString csReturn;
	BOOL bBreak = FALSE;

	for (i = 0; i < nProps; i++)
	{
		BSTR bstrTemp = pcsProps[i].AllocSysString();
		sc = pObject -> GetPropertyQualifierSet(bstrTemp,
						&pAttrib);
		::SysFreeString(bstrTemp);
		if (sc == S_OK)
		{
			sc = pAttrib->GetNames(0,&psa);
			 if(sc == S_OK)
			{
				int iDim = SafeArrayGetDim(psa);
				sc = SafeArrayGetLBound(psa,1,&lLower);
				sc = SafeArrayGetUBound(psa,1,&lUpper);
				BSTR AttrName;
				for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
				{
					sc = SafeArrayGetElement(psa,ix,&AttrName);
					csTmp = AttrName;

					if (pcsAttrib -> CompareNoCase(csTmp)  == 0)
					{
						csReturn = pcsProps[i];
						bBreak = TRUE;
					}
					SysFreeString(AttrName);

				}
			 }
			 pAttrib -> Release();
			 if (bBreak)
				 break;
		}
	}

	if (psa)
	{
		SafeArrayDestroy(psa);
	}

	if (pcsProps)
	{
		delete [] pcsProps;
	}

	return csReturn;
}

//***************************************************************************
//
// GetPropertyValueByAttrib
//
// Purpose: For an object get a property BSTR value by Qualifier.
//
//***************************************************************************
COleVariant GetPropertyValueByAttrib(IWbemClassObject *pObject , CString *pcsAttrib)
{
	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;
	int nProps;
	CString *pcsProps;
	nProps = GetPropNames(pObject, pcsProps);
	int i;
	IWbemQualifierSet * pAttrib = NULL;
	CString csTmp;
	COleVariant covReturn;
	BOOL bBreak = FALSE;

	for (i = 0; i < nProps; i++)
	{
		BSTR bstrTemp = pcsProps[i].AllocSysString();
		sc = pObject -> GetPropertyQualifierSet(bstrTemp,
						&pAttrib);
		::SysFreeString(bstrTemp);
		if (sc == S_OK && pAttrib)
		{
			sc = pAttrib->GetNames(0,&psa);
			if(sc == S_OK)
			{
				int iDim = SafeArrayGetDim(psa);
				sc = SafeArrayGetLBound(psa,1,&lLower);
				sc = SafeArrayGetUBound(psa,1,&lUpper);
				BSTR AttrName;
				for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
				{
					sc = SafeArrayGetElement(psa,ix,&AttrName);
					csTmp = AttrName;

					if (pcsAttrib -> CompareNoCase(csTmp)  == 0)
					{
						covReturn = GetProperty (NULL, pObject, &pcsProps[i]);
						bBreak = TRUE;
					}
					SysFreeString(AttrName);

				}
			 }
			 pAttrib -> Release();
			 pAttrib = NULL;
			 if (bBreak)
				 break;
		}
	}
	SafeArrayDestroy(psa);
	delete [] pcsProps;
	return covReturn;
}

//***************************************************************************
//
// GetAllKeys
//
// Purpose:
//
//***************************************************************************
CStringArray *GetAllKeys(CString &rcsFullPath)
{

	CStringArray *pcsaReturn = new CStringArray;

	CObjectPathParser parser;
	ParsedObjectPath* pParsedPath = NULL;

	BSTR bstrTemp = rcsFullPath.AllocSysString();
	int nStatus  = parser.Parse(bstrTemp,  &pParsedPath);
	::SysFreeString(bstrTemp);

	if (nStatus == 0)
	{
		if (pParsedPath->m_dwNumKeys > 0)
		{
#pragma warning( disable :4018 )
			for (int i = 0; i < pParsedPath->m_dwNumKeys; i++)
#pragma warning( default : 4018 )
			{
				CString csProp =
					pParsedPath->m_paKeys[i]->m_pName;
				pcsaReturn->Add(csProp);
				VARIANT varChanged;
				VariantInit(&varChanged);
				SCODE hr = VariantChangeType(&varChanged,
					&pParsedPath->m_paKeys[i]->m_vValue, 0, VT_BSTR);
				CString csPath = varChanged.bstrVal;
				pcsaReturn->Add(csPath);
				VariantClear(&varChanged);
			}
		}

	}

	if (pParsedPath)
	{
		parser.Free(pParsedPath);
	}

	return pcsaReturn;
}



//***************************************************************************
//
// GetPropNames
//
// Purpose: Gets the Prop names for an object.
//
//***************************************************************************

int GetPropNames(IWbemClassObject * pClass, CString *&pcsReturn)
{
	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;

	VARIANTARG var;
	VariantInit(&var);
	CString csNull;


    sc = pClass->GetNames(NULL,0,NULL,&psa);

    if(sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get property names ");
		csUserMsg += _T(" for object ");
		csUserMsg += GetIWbemFullPath (NULL, pClass);
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 10);
	}
	else
	{
       int iDim = SafeArrayGetDim(psa);
	   int i;
       sc = SafeArrayGetLBound(psa,1,&lLower);
       sc = SafeArrayGetUBound(psa,1,&lUpper);
	   pcsReturn = new CString [(lUpper - lLower) + 1];
       for(ix[0] = lLower, i = 0; ix[0] <= lUpper; ix[0]++, i++)
	   {
           BOOL bClsidSetForProp = FALSE;
           BSTR PropName;
           sc = SafeArrayGetElement(psa,ix,&PropName);
           pcsReturn[i] = PropName;
           SysFreeString(PropName);
	   }
	}

	SafeArrayDestroy(psa);

	return (lUpper - lLower) + 1;
}

COleVariant GetProperty
(IWbemServices * pProv, IWbemClassObject * pInst,
 CString *pcsProperty)

{
	SCODE sc;
	COleVariant covOut;

    VARIANTARG var;
	VariantInit(&var);
    long lType;
	long lFlavor;

	BSTR bstrTemp = pcsProperty -> AllocSysString ( );
    sc = pInst->Get(bstrTemp,0,&var,&lType,&lFlavor);
	::SysFreeString(bstrTemp);
	if(sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get property value ");
		csUserMsg += _T(" for object ");
		csUserMsg += GetIWbemFullPath (NULL, pInst);
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 9);
		return covOut;
	}


	covOut  = var;

	VariantClear(&var);
	return covOut;
}

CString GetBSTRProperty
(IWbemClassObject * pInst, CString *pcsProperty)
{
	SCODE sc;
	CString csOut;

    VARIANTARG var;
	VariantInit(&var);
	long lType;
	long lFlavor;

	BSTR bstrTemp = pcsProperty -> AllocSysString ( );
    sc = pInst->Get(bstrTemp,0,&var,&lType,&lFlavor);
	::SysFreeString(bstrTemp);
	if (sc != S_OK)
	{
	   return csOut;
	}

	if (var.vt == VT_BSTR)
		csOut = var.bstrVal;

	VariantClear(&var);
	return csOut;
}


//***************************************************************************
//
// GetAssocInstances
//
// Purpose: Get all the association instances of type that an object instance
//			participates in.
//
//***************************************************************************
CStringArray *GetAssocInstances
(IWbemServices * pProv, CString *pcsInst, CString *pcsAssocClass,
 CString *pcsRole,  CString csCurrentNameSpace, CString &rcsAuxNameSpace,
 IWbemServices *&rpAuxServices, CNavigatorCtrl *pControl)
{
	CStringArray *pcsaAssoc = new CStringArray;
	CString csReqAttrib = _T("Association");

	CString csQuery
		=  BuildOBJDBGetRefQuery
			(pProv, pcsInst, pcsAssocClass, pcsRole, &csReqAttrib, FALSE);

	BOOL bDiffNS = ObjectInDifferentNamespace(&csCurrentNameSpace,pcsInst);

	if (bDiffNS && ObjectInDifferentNamespace(&rcsAuxNameSpace,pcsInst))
	{
		CString csNamespace = GetObjectNamespace(pcsInst);
		if (csNamespace.GetLength() > 0)
		{
			rcsAuxNameSpace = csNamespace;
			IWbemServices * pServices =
				pControl->InitServices(&csNamespace);
			if (pServices)
			{
				if (rpAuxServices)
				{
					rpAuxServices->Release();
				}
				rpAuxServices = pServices;
			}
			else
			{
				return pcsaAssoc;
			}
		}
		else
		{
			return pcsaAssoc;
		}
	}




	IEnumWbemClassObject *pemcoAssocs =
		ExecOBJDBQuery(bDiffNS == FALSE ? pProv : rpAuxServices, csQuery, csCurrentNameSpace);

	if (!pemcoAssocs)
		return FALSE;

	pemcoAssocs -> Reset();
	IWbemClassObject *pAssoc = NULL;
	ULONG uReturned;
	HRESULT hResult =
		pemcoAssocs -> Next(INFINITE,1,reinterpret_cast<IWbemClassObject **> (&pAssoc),
				&uReturned);

	while(hResult == S_OK)
	{
		AddIWbemClassObjectToArray
				(pProv, pAssoc, pcsaAssoc, FALSE, TRUE);
		pAssoc->Release();
		pAssoc = NULL;
		hResult =
				pemcoAssocs -> Next(INFINITE,1,reinterpret_cast<IWbemClassObject **> (&pAssoc),
			&uReturned);
	}

	pemcoAssocs -> Release();

	return pcsaAssoc;

}

void AddIWbemClassObjectToArray
		(IWbemServices *pProv,IWbemClassObject *pObject,
		CStringArray *pcsaObjectInstances,
		BOOL bAllowDups, BOOL bTestOnPath)
{
	CString csPath = GetIWbemFullPath(pProv,pObject);
	if (bAllowDups)
	{
		pcsaObjectInstances -> Add(csPath);
		return;
	}

	CString csTmp;

	for (int i = 0; i < pcsaObjectInstances -> GetSize(); i++)
	{
		csTmp =
			pcsaObjectInstances -> GetAt(i);
		if (bTestOnPath && WbemObjectIdentity(csTmp, csPath))
		{
			return;
		}
		else if (! bTestOnPath &&
					GetIWbemClass(csTmp).CompareNoCase(GetIWbemClass(csPath)) == 0)
		{
			return;
		}

	}

	pcsaObjectInstances -> Add(csPath);

}

void AddIWbemClassObjectToArray(CString *pcsPath, CStringArray *pcsaObjectInstances)
{
	CString csTmp;

	for (int i = 0; i < pcsaObjectInstances -> GetSize(); i++)
	{
		csTmp = pcsaObjectInstances -> GetAt(i);
		if (WbemObjectIdentity(csTmp, *pcsPath))
		{
			return;
		}
	}

	pcsaObjectInstances -> Add(*pcsPath);

}
//***************************************************************************
//
// GetAssocRoles
//
// Purpose: Get all the roles for an association class in the form
//			{myRole, notmyRole , myRole, notmyRole}
//			Assumes an instance onlt plays one role in an association
//
//***************************************************************************
CStringArray *GetAssocRoles
(IWbemServices * pProv,IWbemClassObject *pAssoc,
 IWbemClassObject * )
{
	CStringArray csaIn;
	CStringArray csaOut;
	CString *pcsProps = NULL;
	int nProps = GetPropNames(pAssoc, pcsProps);
	CString csOut = _T("Out");
	CString csIn = _T("In");
	for (int i = 0; i < nProps; i++)
	{
		SCODE sc;
		IWbemQualifierSet * pAttribSet;
		BSTR bstrTemp = pcsProps[i].AllocSysString();
		sc = pAssoc->GetPropertyQualifierSet(bstrTemp,
				&pAttribSet);
		::SysFreeString(bstrTemp);
		if (sc == S_OK)
		{
			VARIANTARG var;
			VariantInit(&var);
			long lReturn;

			BSTR bstrTemp = csOut.AllocSysString();
			sc = pAttribSet -> Get(bstrTemp,0,&var,&lReturn);
			::SysFreeString(bstrTemp);

			if (sc == S_OK)
			{
				csaOut.Add(pcsProps[i]);

			}

			bstrTemp = csIn.AllocSysString();
			sc = pAttribSet -> Get(bstrTemp,0,&var,&lReturn);
			::SysFreeString(bstrTemp);

			if (sc == S_OK)
			{
				csaIn.Add(pcsProps[i]);
			}

			pAttribSet->Release();
			pAttribSet = NULL;
			VariantClear(&var);
		}
	}

	delete [] pcsProps;

	CStringArray *pcsaRoles = CrossProduct(&csaIn,&csaOut);
	CStringArray *pcsaOut = new CStringArray;
	for (i = 0; i < pcsaRoles -> GetSize(); i+=2)
	{
		CString csMyRole = pcsaRoles -> GetAt(i);
		CString csNotMyRole = pcsaRoles -> GetAt(i + 1);
		if (csMyRole.CompareNoCase(csNotMyRole) != 0)
		{
			pcsaOut->Add(csMyRole);
			pcsaOut->Add(csNotMyRole);
		}

	}
	delete pcsaRoles;

	return pcsaOut;
}


CStringArray * CrossProduct(CStringArray *pcsaFirst, CStringArray *pcsaSecond)
{
	CStringArray *pcsaCross = new CStringArray;
	int i, k;
	for (i = 0; i < pcsaFirst -> GetSize(); i++)
	{
		for (k = 0; k < pcsaSecond -> GetSize(); k++)
		{
			 pcsaCross -> Add(pcsaFirst -> GetAt(i));
			 pcsaCross -> Add(pcsaSecond -> GetAt(k));
		}

	}

	return pcsaCross;
}

//***************************************************************************
//
// ExecOBJDBQuery
//
// Purpose: Execute an OBJDB query and return class enumeration.  The caller
//			must release the enumeration when done with it.
//
//***************************************************************************
IEnumWbemClassObject *ExecOBJDBQuery
(IWbemServices * pProv, CString &csQuery, CString & rcsNamespace)
{
	IEnumWbemClassObject *pemcoResult = NULL;
	IWbemClassObject *pErrorObject = NULL;

	CString csQueryType = _T("WQL");

#ifdef _DEBUG
//	afxDump << _T("################QueryType = ") << csQueryType << _T("\n");
//	afxDump << _T("################Query = \n") << csQuery << _T("\n");
#endif

	BSTR bstrTemp1 = csQueryType.AllocSysString();
	BSTR bstrTemp2 = csQuery.AllocSysString();
	SCODE sc = pProv -> ExecQuery(bstrTemp1,bstrTemp2,WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY ,NULL,&pemcoResult);

	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);

	if (sc == S_OK)
	{
		ReleaseErrorObject(pErrorObject);
		SetEnumInterfaceSecurity(rcsNamespace,pemcoResult, pProv);
		return pemcoResult;
	}
	else
	{
		CString csUserMsg;
		CString csErrorAsHex;
		csErrorAsHex.Format(_T("0x%x"),sc);
		csUserMsg =  _T("ExecQuery failure: ");
		csUserMsg += csErrorAsHex;
		csUserMsg +=  _T(" for query: ");
		csUserMsg += csQuery;

		ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 28);
		ReleaseErrorObject(pErrorObject);
		return NULL;

	}

}

//***************************************************************************
//
// WbemObjectIdentity
//
// Purpose: Predicate to tell if two IWbemClassObject instances are the
//			same backend object.
//
//***************************************************************************
BOOL WbemObjectIdentity(CString &rcsWbem1, CString &rcsWbem2)
{
	if (rcsWbem1.CompareNoCase(rcsWbem2) == 0)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}

}

//***************************************************************************
//
// COMObjectIdentity
//
// Purpose: Predicate to tell if two COM objects are the
//			same com object.
//
//***************************************************************************
BOOL COMObjectIdentity(IWbemClassObject *piWbem1, IWbemClassObject *piWbem2)
{

	LPUNKNOWN lp1;
	LPUNKNOWN lp2;
	HRESULT hResult;
	BOOL bReturn = FALSE;

	if (piWbem1 == NULL || piWbem2 == NULL)
		return FALSE;

	hResult = piWbem1 ->
		QueryInterface(IID_IUnknown, reinterpret_cast<void **> (&lp1));

	if (hResult != S_OK)
	{
		return FALSE;
	}

	hResult = piWbem2 ->
		QueryInterface(IID_IUnknown, reinterpret_cast<void **> (&lp2));

	if (hResult != S_OK)
	{
		lp1->Release();
		return FALSE;
	}

	bReturn = lp1 == lp2;

	lp1->Release();
	lp2->Release();

	int n1 = piWbem1->AddRef();
	if (n1 == 1)
	{
		int foo = n1;
	}
	else
	{
		piWbem1->Release();
	}
	int n2 = piWbem2->AddRef();
	if (n2 == 1)
	{
		int foo2 = n2;
	}
	else
	{
		piWbem2->Release();
	}


	return bReturn;


}

//***************************************************************************
//
// GetGroupingClass
//
// Purpose: Returns grouping class Qualifier.
//
//***************************************************************************
CString GetIWbemGroupingClass
	(IWbemServices *pProv,IWbemClassObject *pClass, BOOL bPath)
{

	CString csGroupingClass;

	CString csProp = _T("__Class");
	csGroupingClass = GetBSTRProperty (pClass,&csProp);


	if (bPath)
	{
		CString csTmp = csGroupingClass;
		csGroupingClass.Empty();
		CString csPath = GetIWbemFullPath(pProv,pClass);
		CObjectPathParser parser;
		ParsedObjectPath* pParsedPath = NULL;

		BSTR bstrTemp = csPath.AllocSysString();
		int nStatus  = parser.Parse(bstrTemp,  &pParsedPath);
		::SysFreeString(bstrTemp);

		if (nStatus == 0)
		{
			if (pParsedPath->m_dwNumNamespaces > 0)
			{
				if(pParsedPath->m_pServer)
				{
					csGroupingClass = _T("\\\\");
					csGroupingClass += pParsedPath->m_pServer;
					csGroupingClass += _T("\\");
				}
				for (unsigned int i = 0; i < pParsedPath->m_dwNumNamespaces; i++)
				{
					csGroupingClass += pParsedPath->m_paNamespaces[i];
					if (i < pParsedPath->m_dwNumNamespaces - 1)
					{
						csGroupingClass += _T("\\");
					}
				}
				csGroupingClass += _T(":");
				csGroupingClass += csTmp;
			}

		}
		else
		{
			csGroupingClass = csTmp;
		}


		if (pParsedPath)
		{
			parser.Free(pParsedPath);
		}

	}

	return csGroupingClass;
}


//***************************************************************************
//
// GetIWbemClass
//
// Purpose: Returns the class of the object.
//
//***************************************************************************
CString GetIWbemClass(IWbemServices *pProv, IWbemClassObject *pClass)
{

	CString csProp = _T("__Class");
	return GetBSTRProperty(pClass,&csProp);


}

CString GetIWbemClass(CString &rcsFullPath)
{
	CObjectPathParser parser;
	ParsedObjectPath* pParsedPath = NULL;

	BSTR bstrTemp = rcsFullPath.AllocSysString();
	int nStatus  = parser.Parse(bstrTemp,  &pParsedPath);
	::SysFreeString(bstrTemp);

	CString csReturn;

	if (pParsedPath)
	{
		if (pParsedPath->m_pClass)
		{
			csReturn = pParsedPath->m_pClass;
		}
		else
		{
			csReturn = _T("");
		}
		parser.Free(pParsedPath);
	}

	return csReturn;
}


//***************************************************************************
//
// GetIWbemRelPath
//
// Purpose: Returns the relative path of the object.
//
//***************************************************************************
CString GetIWbemRelPath(IWbemServices *pProv, IWbemClassObject *pClass)
{

	CString csProp = _T("__RelPath");
	return GetBSTRProperty(pClass,&csProp);

}

CString GetIWbemRelPath(CString *pcsFullPath)
{

	int nDelimiter = pcsFullPath->Find(':');

	if (nDelimiter == -1)
	{
		return *pcsFullPath;
	}

	CString csRelPath =
		pcsFullPath->Right(pcsFullPath->GetLength() - (nDelimiter + 1));

	return csRelPath;

}

//***************************************************************************
//
// GetIWbemFullPath
//
// Purpose: Returns the complete path of the object.
//
//***************************************************************************
CString GetIWbemFullPath(IWbemServices *pProv, IWbemClassObject *pClass)
{

	CString csProp = _T("__Path");
	return GetBSTRProperty(pClass,&csProp);


}


//***************************************************************************
//
// GetDisplayLabel
//
// Purpose: Returns the label of the object.
//
//***************************************************************************
CString GetDisplayLabel
(IWbemServices *pProv,IWbemClassObject *pimcoClass)
{

	return GetIWbemClass(pProv, pimcoClass);

}

CString GetDisplayLabel
(CString &rcsClass,CString *pcsNamespace)
{

	if (ObjectInDifferentNamespace(pcsNamespace,&rcsClass))
	{
		return rcsClass;
	}
	else
	{
		return GetIWbemRelPath(&rcsClass);
	}


}

//***************************************************************************
//
// BuildOBJDBGetRefQuery
//
// Purpose: Build an OBJDB "GetRef" query string suitable to pass to
//			ExecQuery.
//
//***************************************************************************
CString BuildOBJDBGetRefQuery
(IWbemServices *pProv, CString *pcsTarget,
 CString *pcsResultClass, CString *pcsRoleFilter,
 CString *pcsReqAttrib, BOOL bClassOnly)
{

	CString csReturn = _T("references of {");
	csReturn += *pcsTarget;
	csReturn += _T("}");

	if (
		(pcsResultClass && !pcsResultClass->IsEmpty())  ||
		(pcsRoleFilter && !pcsRoleFilter -> IsEmpty()) ||
		(pcsReqAttrib && !pcsReqAttrib -> IsEmpty()) ||
		bClassOnly
		)
		csReturn += _T(" where");

	if (pcsResultClass && !pcsResultClass->IsEmpty())
	{
		csReturn += _T(" ResultClass=");
		csReturn += *pcsResultClass;
	}

	if (pcsRoleFilter && !pcsRoleFilter -> IsEmpty())
	{
		csReturn += _T(" Role=");
		csReturn += *pcsRoleFilter;
	}


	if (pcsReqAttrib && !pcsReqAttrib -> IsEmpty())
	{
		csReturn += _T(" RequiredQualifier=");
		csReturn += *pcsReqAttrib;
	}

	if (bClassOnly)
	{
		csReturn += _T(" ClassDefsOnly");
	}


	return csReturn;
}


//***************************************************************************
//
// BuildOBJDBGetAssocsQuery
//
// Purpose: Build an OBJDB "GetAssoc" query string suitable to pass to
//			ExecQuery.
//
//***************************************************************************
CString BuildOBJDBGetAssocsQuery
(IWbemServices *pProv, CString *pcsTargetPath,
 CString *pcsAssocClass, CString *pcsResultClass,
 CString *pcsMyRoleFilter, CString *pcsReqAttrib,
 CString *pcsReqAssocAttrib, CString *pcsResultRole, BOOL bClassOnly, BOOL bKeysOnly)
{

	pcsTargetPath;
	pcsAssocClass;
	pcsResultClass;


	CString csReturn = _T("associators of {");
	csReturn += *pcsTargetPath;
	csReturn += _T("}");

	if ((pcsResultClass && !pcsResultClass->IsEmpty()) ||
		(pcsMyRoleFilter && !pcsMyRoleFilter -> IsEmpty()) ||
		!pcsAssocClass->IsEmpty() ||
		(pcsReqAttrib && !pcsReqAttrib -> IsEmpty()) ||
		(pcsReqAssocAttrib && !pcsReqAssocAttrib -> IsEmpty()) ||
		bClassOnly ||
		bKeysOnly)
		csReturn += " where";

	if (pcsAssocClass && !pcsAssocClass->IsEmpty())
	{
		csReturn += _T(" AssocClass=");
		csReturn += *pcsAssocClass;
	}

	if (pcsResultClass && !pcsResultClass->IsEmpty())
	{
		csReturn += _T(" ResultClass=");
		csReturn += *pcsResultClass;
	}

	if (pcsMyRoleFilter && !pcsMyRoleFilter -> IsEmpty())
	{
		csReturn += _T(" Role=");
		csReturn += *pcsMyRoleFilter;
	}


	if (pcsResultRole && !pcsResultRole -> IsEmpty())
	{
		csReturn += _T(" ResultRole=");
		csReturn += *pcsResultRole;
	}

	if (pcsReqAttrib && !pcsReqAttrib -> IsEmpty())
	{
		csReturn += _T(" RequiredQualifier=");
		csReturn += *pcsReqAttrib;
	}

	if (pcsReqAssocAttrib && !pcsReqAssocAttrib -> IsEmpty())
	{
		csReturn += _T(" RequiredAssocAttrib=");
		csReturn += *pcsReqAssocAttrib;
	}

	if (bClassOnly)
	{
		csReturn += _T(" ClassDefsOnly");
	}

	if (bKeysOnly)
	{
		csReturn += _T(" KeysOnly");
	}

	return csReturn;
}


//***************************************************************************
// Function:	GetInstances
// Purpose:		Gets class instances in the database.
//***************************************************************************
CPtrArray *GetInstances
(IWbemServices *pServices, CString *pcsClass, CString &rcsNamespace, BOOL bDeep, BOOL bQuietly)
{
	SCODE sc;
	IEnumWbemClassObject *pIEnumWbemInstObject = NULL;
	IWbemClassObject *pIWbemInstObject = NULL;
	IWbemClassObject *pErrorObject = NULL;
 	CPtrArray *pcpaInstances = new CPtrArray;

	long lFlag = bDeep? WBEM_FLAG_DEEP: WBEM_FLAG_SHALLOW;

	BSTR bstrTemp = pcsClass -> AllocSysString();
	sc = pServices->CreateInstanceEnum
		(bstrTemp,
		lFlag | WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pIEnumWbemInstObject);
	::SysFreeString(bstrTemp);

	if(sc != S_OK)
	{
		if (!bQuietly)
		{
			CString csUserMsg=  _T("Cannot get instance enumeration ");
			csUserMsg += _T(" for class ");
			csUserMsg += *pcsClass;
			ErrorMsg
					(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__,
					__LINE__ - 11);
		}
		ReleaseErrorObject(pErrorObject);
		return pcpaInstances;
	}

	ReleaseErrorObject(pErrorObject);

	SetEnumInterfaceSecurity(rcsNamespace,pIEnumWbemInstObject, pServices);

	sc = pIEnumWbemInstObject->Reset();

	ULONG uReturned;

	sc = pIEnumWbemInstObject->Next(100, 1, &pIWbemInstObject, &uReturned);

    while (sc == S_OK || sc == WBEM_S_TIMEDOUT || uReturned > 0 )
		{
			if (uReturned == 1)
			{
				pcpaInstances->Add(pIWbemInstObject);
				pIWbemInstObject = NULL;
			}
			sc = pIEnumWbemInstObject->Next(100, 1, &pIWbemInstObject, &uReturned);
		}

	pIEnumWbemInstObject -> Release();
	return pcpaInstances;

}


BOOL IsClass(CString &rcsObject)
{
	int nFound = rcsObject.ReverseFind('=');

	if (nFound == -1)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}

}

BOOL IsAssoc(IWbemClassObject* pObject)
{
	CString csQualifier = _T("Association");
	BOOL bReturn;
	long sc = GetAttribBool
		(pObject,NULL, &csQualifier, bReturn);
	if (sc == S_OK)
	{
		return bReturn;
	}
	else
	{
		return FALSE;
	}
}

BOOL IsSystemClass(IWbemClassObject* pObject)
{
	CString csProp = _T("__Dynasty");
	CString csReturn = GetBSTRProperty
		(pObject,&csProp);
	return csReturn.CompareNoCase(_T("__SystemClass")) == 0;
}

BOOL ClassCanHaveInstances(IWbemClassObject* pObject)
{
	CString csQualifier = _T("singleton");
	BOOL bReturn;
	long sc = GetAttribBool
		(pObject,NULL, &csQualifier, bReturn);
	if (sc == S_OK)
	{
		if (bReturn == VARIANT_TRUE)
		{
			return TRUE;
		}
	}

	csQualifier = _T("abstract");
	sc = GetAttribBool
		(pObject,NULL, &csQualifier, bReturn);
	if (sc == S_OK)
	{
		if (bReturn == TRUE)
		{
			return FALSE;
		}
	}

	csQualifier = _T("key");
	CString csProp = GetPropertyNameByAttrib(pObject , &csQualifier);
	return csProp.GetLength() > 0;

}


CStringArray *GetNamespaces(CNavigatorCtrl *pControl,
							CString *pcsNamespace, BOOL bDeep)
{
	CStringArray *pcsaNamespaces = new CStringArray;
	pcsaNamespaces->Add(*pcsNamespace);
	IWbemServices *pRoot = pControl->InitServices(pcsNamespace);

	if (pRoot == NULL)
	{
		return pcsaNamespaces;
	}

	CString csTmp = _T("__namespace");
	CPtrArray *pcpaInstances =
		GetInstances(pRoot, &csTmp, *pcsNamespace);


	for (int i = 0; i < pcpaInstances->GetSize(); i++)
	{
		CString csProp = _T("name");
		IWbemClassObject *pInstance =
			reinterpret_cast<IWbemClassObject *>
				(pcpaInstances->GetAt(i));
		CString csTmp = GetBSTRProperty(pInstance,&csProp);
		CString csName = *pcsNamespace + _T("\\") + csTmp;

		pInstance->Release();

		if (bDeep)
		{
			CStringArray *pcsaChildren =
				GetNamespaces(pControl, &csName, bDeep);
			pcsaNamespaces->Append(*pcsaChildren);
			delete pcsaChildren;

		}

	}
	pRoot->Release();
	delete pcpaInstances;
	return pcsaNamespaces;
}

void ReleaseErrorObject(IWbemClassObject *&rpErrorObject)
{
	if (rpErrorObject)
	{
		rpErrorObject->Release();
		rpErrorObject = NULL;
	}


}

void ErrorMsg
(CString *pcsUserMsg, SCODE sc, IWbemClassObject *pErrorObject, BOOL bLog,
 CString *pcsLogMsg, char *szFile, int nLine, UINT uType)
{
	CString csCaption = _T("Instance Explorer Message");
	BOOL bErrorObject = sc != S_OK;

	BSTR bstrTemp1 = csCaption.AllocSysString();
	BSTR bstrTemp2 = pcsUserMsg->AllocSysString();
	DisplayUserMessage
		(bstrTemp1,bstrTemp2,
		sc,bErrorObject,uType);
	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);

	if (bLog)
	{
		LogMsg(pcsLogMsg,  szFile, nLine);

	}

}


void LogMsg
(CString *pcsLogMsg, char *szFile, int nLine)
{


}

CString ObjectsRoleInAssocInstance
	(IWbemServices *pProv, IWbemClassObject *pAssoc, IWbemClassObject *pObject)
{
	CComparePaths ccpParser;
	CString *pcsRolesAndPaths;
	int nRolesAndPaths =
		GetAssocRolesAndPaths(pAssoc ,pcsRolesAndPaths);
	CString csObjectPath = GetIWbemFullPath(pProv,pObject);
	CString csReturn;
	int i;
	for (i = 0; i < nRolesAndPaths * 2; i = i+2)
	{
		CString csRole = pcsRolesAndPaths[i];
		CString csPath = pcsRolesAndPaths[i + 1];
		BSTR bstrTemp1 = csObjectPath.AllocSysString();
		BSTR bstrTemp2 = csPath.AllocSysString();
		if (ccpParser.PathsRefSameObject(bstrTemp1,bstrTemp2))
		{
			csReturn = csRole;
			::SysFreeString(bstrTemp1);
			::SysFreeString(bstrTemp2);
			break;
		}
		else
		{
			::SysFreeString(bstrTemp1);
			::SysFreeString(bstrTemp2);
		}
	}

	delete [] pcsRolesAndPaths;

	return csReturn;
}


CString GetObjectClassForRole
	(IWbemServices *,IWbemClassObject *pAssocRole,CString *pcsRole)
{

	CString csSyntax = _T("CIMTYPE");
	CString csValue = GetBSTRAttrib
		(pAssocRole, pcsRole, &csSyntax);

	return csValue.Mid(4);

}

BOOL ObjectInDifferentNamespace
			(CString *pcsNamespace, CString *pcsPath)
{

	if (!pcsPath)
	{
		return TRUE;

	}

	if (pcsNamespace->GetLength() == 0)
	{
		return pcsNamespace->CompareNoCase(*pcsPath) != 0;

	}

	BOOL bHasServer = FALSE;
	TCHAR c1 = (*pcsNamespace)[0];
	TCHAR c2 = (*pcsNamespace)[1];

	if (c1 == '\\' && c2 == '\\')
	{
		bHasServer = TRUE;
	}

	CString csNamespace;

	CObjectPathParser parser;
	ParsedObjectPath* pParsedPath = NULL;

	BSTR bstrTemp = pcsPath->AllocSysString();
	int nStatus  = parser.Parse(bstrTemp,  &pParsedPath);
	::SysFreeString(bstrTemp);

	if (nStatus == 0)
	{
		if (pParsedPath->m_dwNumNamespaces > 0)
		{
			if(pParsedPath->m_pServer && bHasServer)
			{
				csNamespace = _T("\\\\");
				csNamespace += pParsedPath->m_pServer;
				csNamespace += _T("\\");
			}
			for (unsigned int i = 0; i < pParsedPath->m_dwNumNamespaces; i++)
			{
				csNamespace += pParsedPath->m_paNamespaces[i];
				if (i < pParsedPath->m_dwNumNamespaces - 1)
				{
					csNamespace += _T("\\");
				}
			}
		}
	}

	if (pParsedPath)
	{
		parser.Free(pParsedPath);
	}

	BOOL bReturn;

	if (csNamespace.GetLength() == 0)
	{
		bReturn = FALSE;
	}
	else
	{
		bReturn = csNamespace.CompareNoCase(*pcsNamespace) != 0;
	}

	return bReturn;


}

CString GetObjectNamespace(CString *pcsPath)
{

	BOOL bHasServer = FALSE;
	TCHAR c1 = (*pcsPath)[0];
	TCHAR c2 = (*pcsPath)[1];

	if (c1 == '/')
	{
		return "";
	}

	if (c1 == '\\' && c2 != '\\')
	{
		return "";
	}

	if (c1 == '\\' && c2 == '\\')
	{
		bHasServer = TRUE;
	}

	CString csNamespace;

	CObjectPathParser parser;
	ParsedObjectPath* pParsedPath = NULL;

	BSTR bstrTemp = pcsPath->AllocSysString();
	int nStatus  = parser.Parse(bstrTemp,  &pParsedPath);
	::SysFreeString(bstrTemp);

	if (nStatus == 0)
	{
		if (pParsedPath->m_dwNumNamespaces > 0)
		{
			if(pParsedPath->m_pServer && bHasServer)
			{
				csNamespace = _T("\\\\");
				csNamespace += pParsedPath->m_pServer;
				csNamespace += _T("\\");
			}
			else
			{
				csNamespace = _T("\\\\");
				csNamespace += GetPCMachineName();
				csNamespace += _T("\\");

			}
			for (unsigned int i = 0; i < pParsedPath->m_dwNumNamespaces; i++)
			{
				csNamespace += pParsedPath->m_paNamespaces[i];
				if (i < pParsedPath->m_dwNumNamespaces - 1)
				{
					csNamespace += _T("\\");
				}
			}
		}
	}

	if (pParsedPath)
	{
		parser.Free(pParsedPath);
	}

	return csNamespace;


}

BOOL PathHasKeys(CString *pcsPath)
{
	CObjectPathParser parser;
	ParsedObjectPath* pParsedPath = NULL;
	BOOL bReturn = FALSE;

	BSTR bstrTemp = pcsPath->AllocSysString();
	int nStatus  = parser.Parse(bstrTemp,  &pParsedPath);
	::SysFreeString(bstrTemp);
	if (nStatus == 0)
	{
		if (pParsedPath->m_dwNumKeys > 0)
		{
			bReturn = TRUE;
		}

	}

	if (pParsedPath)
	{
		parser.Free(pParsedPath);
	}

	return bReturn;
}

CStringArray *AssocPathRoleKey(CString *pcsPath)
{
	CStringArray *pcsaReturn = new CStringArray;
	CObjectPathParser parser;
	ParsedObjectPath* pParsedPath = NULL;

	BSTR bstrTemp = pcsPath->AllocSysString();
	int nStatus  = parser.Parse(pcsPath->AllocSysString(),  &pParsedPath);
	::SysFreeString(bstrTemp);

	if (nStatus == 0)
	{
		if (pParsedPath->m_dwNumKeys > 0)
		{
#pragma warning( disable :4018 )
			for (int i = 0; i < pParsedPath->m_dwNumKeys; i++)
#pragma warning( default : 4018 )
			{
				CString csRole =
					pParsedPath->m_paKeys[i]->m_pName;
				pcsaReturn->Add(csRole);
				VARIANT varChanged;
				VariantInit(&varChanged);
				SCODE hr = VariantChangeType(&varChanged,
					&pParsedPath->m_paKeys[i]->m_vValue, 0, VT_BSTR);
				CString csPath = varChanged.bstrVal;
				pcsaReturn->Add(csPath);
				VariantClear(&varChanged);
			}
		}
	}

	if (pParsedPath)
	{
		parser.Free(pParsedPath);
	}

	return pcsaReturn;
}



CString GetPCMachineName()
{
    static wchar_t ThisMachine[MAX_COMPUTERNAME_LENGTH+1];
    char ThisMachineA[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwSize = sizeof(ThisMachineA);
    GetComputerNameA(ThisMachineA, &dwSize);
    MultiByteToWideChar(CP_ACP, 0, ThisMachineA, -1,
			ThisMachine, dwSize);

    return ThisMachine;
}

BOOL NamespaceEqual
	(CString *pcsNamespace1, CString *pcsNamespace2)
{

	BOOL bHasServer1 = FALSE;
	TCHAR c1 = (*pcsNamespace1)[0];
	TCHAR c2 = (*pcsNamespace1)[1];

	if (c1 == '\\' && c2 == '\\')
	{
		bHasServer1 = TRUE;
	}

	BOOL bHasServer2 = FALSE;
	c1 = (*pcsNamespace2)[0];
	c2 = (*pcsNamespace2)[1];

	if (c1 == '\\' && c2 == '\\')
	{
		bHasServer2 = TRUE;
	}

	CString csMachine;
	if (!bHasServer1 || !bHasServer2)
	{
		csMachine = GetPCMachineName();
	}


	CString csNamespace1;
	CString csNamespace2;

	if (!bHasServer1)
	{
		csNamespace1 = _T("\\\\");
		csNamespace1 += csMachine;
		csNamespace1 += _T("\\");
		csNamespace1 += *pcsNamespace1;
	}

	if (!bHasServer2)
	{
		csNamespace2 = _T("\\\\");
		csNamespace2 += csMachine;
		csNamespace2 += _T("\\");
		csNamespace2 += *pcsNamespace2;
	}

	return csNamespace1.CompareNoCase(csNamespace2) == 0;

}





int GetCBitmapWidth(const CBitmap & cbm)
{

	BITMAP bm;
	cbm.GetObject(sizeof(BITMAP),&bm);
	return bm.bmWidth;
}

int GetCBitmapHeight(const CBitmap & cbm)
{
	BITMAP bm;
	cbm.GetObject(sizeof(BITMAP),&bm);
	return bm.bmHeight;
}


HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPCTSTR lpString,
                           HPALETTE FAR* lphPalette)
{
    HRSRC  hRsrc;
    HGLOBAL hGlobal;
    HBITMAP hBitmapFinal = NULL;
    LPBITMAPINFOHEADER  lpbi;
    HDC hdc;
    int iNumColors;

    if (hRsrc = FindResource(hInstance, lpString, RT_BITMAP))
       {
       hGlobal = LoadResource(hInstance, hRsrc);
       lpbi = (LPBITMAPINFOHEADER)LockResource(hGlobal);

       hdc = GetDC(NULL);
       *lphPalette =  CreateDIBPalette ((LPBITMAPINFO)lpbi, &iNumColors);
       if (*lphPalette)
          {
			SelectPalette(hdc,*lphPalette,FALSE);
			RealizePalette(hdc);
          }

       hBitmapFinal = CreateDIBitmap(hdc,
                   (LPBITMAPINFOHEADER)lpbi,
                   (LONG)CBM_INIT,
                   (LPSTR)lpbi + lpbi->biSize + iNumColors *
sizeof(RGBQUAD),

                   (LPBITMAPINFO)lpbi,
                   DIB_RGB_COLORS );

       ReleaseDC(NULL,hdc);
       UnlockResource(hGlobal);
       FreeResource(hGlobal);
       }
    return (hBitmapFinal);
}

HPALETTE CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors)
{
   LPBITMAPINFOHEADER  lpbi;
   LPLOGPALETTE     lpPal;
   HANDLE           hLogPal;
   HPALETTE         hPal = NULL;
   int              i;

   lpbi = (LPBITMAPINFOHEADER)lpbmi;
   if (lpbi->biBitCount <= 8)
       *lpiNumColors = (1 << lpbi->biBitCount);
   else
       *lpiNumColors = 0;  // No palette needed for 24 BPP DIB

   if (*lpiNumColors)
      {
      hLogPal = GlobalAlloc (GHND, sizeof (LOGPALETTE) +
                             sizeof (PALETTEENTRY) * (*lpiNumColors));
      lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
      lpPal->palVersion    = 0x300;
      lpPal->palNumEntries = (WORD)*lpiNumColors; // NOTE: lpiNumColors should NEVER be greater than 256 (1<<8 from above)

      for (i = 0;  i < *lpiNumColors;  i++)
         {
         lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
         lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
         lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
         lpPal->palPalEntry[i].peFlags = 0;
         }
      hPal = CreatePalette (lpPal);
      GlobalUnlock (hLogPal);
      GlobalFree   (hLogPal);
   }
   return hPal;
}


CPalette *GetResourcePalette(HINSTANCE hInstance, LPCTSTR lpString,
                           HPALETTE FAR* lphPalette)
{
    HRSRC  hRsrc;
    HGLOBAL hGlobal;
    HBITMAP hBitmapFinal = NULL;
    LPBITMAPINFOHEADER  lpbi;
    HDC hdc;
    int iNumColors;
	CPalette *pcpReturn = NULL;

    if (hRsrc = FindResource(hInstance, lpString, RT_BITMAP))
       {
       hGlobal = LoadResource(hInstance, hRsrc);
       lpbi = (LPBITMAPINFOHEADER)LockResource(hGlobal);

       hdc = GetDC(NULL);
       pcpReturn = CreateCPalette ((LPBITMAPINFO)lpbi, &iNumColors);
	   }
	return pcpReturn;
}


CPalette *CreateCPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors)
{
   LPBITMAPINFOHEADER  lpbi;
   LPLOGPALETTE     lpPal;
   HANDLE           hLogPal;
   HPALETTE         hPal = NULL;
   int              i;
   CPalette *pcpReturn;

   lpbi = (LPBITMAPINFOHEADER)lpbmi;
   if (lpbi->biBitCount <= 8)
       *lpiNumColors = (1 << lpbi->biBitCount);
   else
       *lpiNumColors = 0;  // No palette needed for 24 BPP DIB

   if (*lpiNumColors)
      {
      hLogPal = GlobalAlloc (GHND, sizeof (LOGPALETTE) +
                             sizeof (PALETTEENTRY) * (*lpiNumColors));
      lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
      lpPal->palVersion    = 0x300;
      lpPal->palNumEntries = (WORD)*lpiNumColors; // NOTE: lpiNumColors should NEVER be greater than 256 (1<<8 from above)

      for (i = 0;  i < *lpiNumColors;  i++)
         {
         lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
         lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
         lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
         lpPal->palPalEntry[i].peFlags = 0;
         }
	  pcpReturn = new CPalette;
      pcpReturn ->CreatePalette(lpPal);
      GlobalUnlock (hLogPal);
      GlobalFree   (hLogPal);
   }

   return pcpReturn;
}


BOOL StringInArray
(CStringArray *&rpcsaArrays, CString *pcsString, int nIndex)
{
	for (int i = 0; i < rpcsaArrays[nIndex].GetSize(); i++)
	{
		if (pcsString->CompareNoCase(rpcsaArrays[nIndex].GetAt(i)) == 0)
		{
			return TRUE;
		}

	}

	return FALSE;

}

void InitializeLogFont
(LOGFONT &rlfFont, CString csName, int nHeight, int nWeight)
{
	_tcscpy(rlfFont.lfFaceName, (LPCTSTR) csName);
	rlfFont.lfWeight = nWeight;
	rlfFont.lfHeight = nHeight;
	rlfFont.lfEscapement = 0;
	rlfFont.lfOrientation = 0;
	rlfFont.lfWidth = 0;
	rlfFont.lfItalic = FALSE;
	rlfFont.lfUnderline = FALSE;
	rlfFont.lfStrikeOut = FALSE;
	rlfFont.lfCharSet = ANSI_CHARSET;
	rlfFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
	rlfFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	rlfFont.lfQuality = DEFAULT_QUALITY;
	rlfFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
}


CRect OutputTextString
(CPaintDC *pdc, CWnd *pcwnd, CString *pcsTextString, int x, int y,
 CString *pcsFontName = NULL, int nFontHeight = 0, int nFontWeigth = 0)
{
	CRect crReturn;
	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont cfFont;
	CFont* pOldFont = NULL;
	TEXTMETRIC tmFont;

	if (pcsFontName)
	{
		LOGFONT lfFont;
		InitializeLogFont
			(lfFont, *pcsFontName, nFontHeight * 10, nFontWeigth);

		cfFont.CreatePointFontIndirect(&lfFont, pdc);

		pOldFont = pdc -> SelectObject( &cfFont );
	}

	pdc->GetTextMetrics(&tmFont);

	pdc->SetBkMode( TRANSPARENT );

	pdc->TextOut( x, y, *pcsTextString, pcsTextString->GetLength());

	CSize csText = pdc->GetTextExtent( *pcsTextString);

	crReturn.TopLeft().x = x;
	crReturn.TopLeft().y = y;
	crReturn.BottomRight().x = x + csText.cx;
	crReturn.BottomRight().y = y + csText.cy;

	pdc->SetBkMode( OPAQUE );

	if (pcsFontName)
	{
		pdc -> SelectObject(pOldFont);
	}

	 return crReturn;
}

void OutputTextString
(CPaintDC *pdc, CWnd *pcwnd, CString *pcsTextString, int x, int y,
 CRect &crExt, CString *pcsFontName = NULL, int nFontHeight = 0,
 int nFontWeigth = 0)
{

	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont cfFont;
	CFont* pOldFont = NULL;

	if (pcsFontName)
	{
		LOGFONT lfFont;
		InitializeLogFont
			(lfFont, *pcsFontName, nFontHeight * 10, nFontWeigth);

		cfFont.CreatePointFontIndirect(&lfFont, pdc);

		pOldFont = pdc -> SelectObject( &cfFont );
	}

	pdc->SetBkMode( TRANSPARENT );

	CRect crBounds(x,y,x + crExt.Width(), y + crExt.Height());
	pdc->DrawText(*pcsTextString, crBounds,DT_WORDBREAK);

	pdc->SetBkMode( OPAQUE );

	if (pcsFontName)
	{
		pdc -> SelectObject(pOldFont);
	}

	 return;
}

IWbemClassObject *GetIWbemObject
(CNavigatorCtrl *pControl,
 IWbemServices *pServices, CString csCurrentNameSpace,
 CString &rcsAuxNameSpace, IWbemServices *&rpAuxServices,
 CString &rcsObject,BOOL bErrorMsg)
{
	IWbemClassObject *pObject = NULL;
	IWbemClassObject *pErrorObject = NULL;
	BOOL bDiffNS = ObjectInDifferentNamespace(&csCurrentNameSpace,&rcsObject);

	if (bDiffNS && ObjectInDifferentNamespace(&rcsAuxNameSpace,&rcsObject))
	{
		CString csNamespace = GetObjectNamespace(&rcsObject);
		if (csNamespace.GetLength() > 0)
		{
			rcsAuxNameSpace = csNamespace;
			IWbemServices * pServices =
				pControl->InitServices(&csNamespace);
			if (pServices)
			{
				if (rpAuxServices)
				{
					rpAuxServices->Release();
				}
				rpAuxServices = pServices;
			}
			else
			{
				return NULL;
			}
		}
		else
		{
			return NULL;
		}
	}


	SCODE sc;

	BSTR bstrTemp = rcsObject.AllocSysString();
	if (bDiffNS)
	{
		sc =
			rpAuxServices ->
				GetObject(bstrTemp,0,NULL, &pObject, NULL);
	}
	else
	{
		sc =
			pServices ->
				GetObject(bstrTemp,0,NULL, &pObject, NULL);
	}
	::SysFreeString(bstrTemp);

	if (sc == S_OK)
	{
		ReleaseErrorObject(pErrorObject);
		return pObject;
	}
	else
	{
		if (bErrorMsg)
		{
			CString csUserMsg =
							_T("Cannot get object ");
			csUserMsg += rcsObject;
			ErrorMsg
			(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 7);
		}
		ReleaseErrorObject(pErrorObject);
		return NULL;
	}
}


HRESULT ConfigureSecurity(IWbemServices *pServices)
{
	// This is no longer required for NTLM.  Leaving stub because
	// Lev says you never know what may be required in the future.
	/*IUnknown *pUnknown = dynamic_cast<IUnknown *>(pServices);
	return ConfigureSecurity(pUnknown);*/
	return S_OK;
}

HRESULT ConfigureSecurity(IEnumWbemClassObject *pEnum)
{
	// This is no longer required for NTLM.  Leaving stub because
	// Lev says you never know what may be required in the future.
	/*IUnknown *pUnknown = dynamic_cast<IUnknown *>(pEnum);
	return ConfigureSecurity(pUnknown);*/
	return S_OK;
}

HRESULT ConfigureSecurity(IUnknown *pUnknown)
{
	// This is no longer required for NTLM.  Leaving stub because
	// Lev says you never know what may be required in the future.

    /*IClientSecurity* pCliSec;
    if(FAILED(pUnknown->QueryInterface(IID_IClientSecurity, (void**)&pCliSec)))
    {
        // no security --- probably not a proxy
        return S_OK;
    }

    HRESULT hRes =
        pCliSec->SetBlanket(pUnknown, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
        NULL, RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE,
        NULL, EOAC_NONE);

    pCliSec->Release();

	return hRes;*/
	return S_OK;

}

SCODE CreateNamespaceConfigClassAndInstance
(IWbemServices *pProv, CString *pcsNamespace, CString *pcsRootPath)
{
	IWbemClassObject *pClass = NULL;

   	SCODE sc;

	CString csClass = _T("NamespaceConfiguration");

	BSTR bstrTemp = csClass.AllocSysString();
	sc = pProv -> GetObject
		(bstrTemp,0,NULL, &pClass,NULL);
	::SysFreeString(bstrTemp);

	VARIANT v;

	if (sc != S_OK)

	{
		pClass = NULL;
		sc = pProv -> GetObject
		(NULL,0,NULL, &pClass,NULL);

		if (sc != S_OK)
		{
			CString csUserMsg;
			csUserMsg =  _T("Cannot GetObject of NULL to create NamespaceConfiguration class.");
			ErrorMsg
						(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
						__LINE__ );
			return sc;
		}

		pClass->AddRef();

		VariantInit(&v);

		CString csNewClass = _T("NamespaceConfiguration");

		// Init class __Class Property
		V_VT(&v) = VT_BSTR;

		V_BSTR(&v) = csNewClass.AllocSysString();
		BSTR ClassProp = SysAllocString(L"__Class");
		sc = pClass->Put(ClassProp, 0, &v,0);
		VariantClear(&v);
		SysFreeString(ClassProp);

		if (sc != S_OK)
		{
			CString csUserMsg;
			csUserMsg =  _T("Cannot Put __Class property on NamespaceConfiguration class.");
			ErrorMsg
						(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
						__LINE__ );
			return sc;
		}

		sc = pProv->PutClass(pClass,0,NULL,NULL);

		if (sc != S_OK)
		{
			CString csUserMsg;
			csUserMsg =  _T("Cannot PutClass for NamespaceConfiguration class.");
			ErrorMsg
						(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
						__LINE__ );
			return sc;
		}
		else
		{
			pClass->Release();
			pClass = NULL;
			BSTR bstrTemp = csNewClass.AllocSysString();
			sc = pProv -> GetObject
			(bstrTemp ,0,NULL,&pClass,NULL);
			::SysFreeString(bstrTemp);

			if (sc != S_OK)
			{
				CString csUserMsg;
				csUserMsg =  _T("Cannot GetObject for NamespaceConfiguration class just created.");
				ErrorMsg
						(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
						__LINE__ );
				return sc;
			}

		}

		// Create the key property
		// =======================

		V_VT(&v) = VT_BSTR;

		V_BSTR(&v) = SysAllocString(L"<default>");
		BSTR KeyProp = SysAllocString(L"NamespaceName");
		sc = pClass->Put(KeyProp, 0, &v,0);
		VariantClear(&v);
		SysFreeString(KeyProp);

		if (sc != S_OK)
		{
			CString csUserMsg;
			csUserMsg =  _T("Cannot Put NamespaceName property for NamespaceConfiguration Class.");
			ErrorMsg
						(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
						__LINE__ );
			pClass->Release();
			return sc;
		}

		// Mark the "Namespace" property as the 'key'.
		// =======================================

		IWbemQualifierSet *pQual = 0;
		pClass->GetPropertyQualifierSet(KeyProp, &pQual);
		V_VT(&v) = VT_BOOL;
		V_BOOL(&v) = VARIANT_TRUE;
		BSTR Key = SysAllocString(L"Key");
		sc = pQual->Put(Key, &v, 0);   // Qualifier flavors not required for KEY
		SysFreeString(Key);
		pQual->Release();   // No longer need the qualifier set for "Index"
		VariantClear(&v);

		if (sc != S_OK)
		{
			CString csUserMsg;
			csUserMsg =  _T("Cannot Put Key qualifier on Namespace property for NamespaceConfiguration class.");
			ErrorMsg
						(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
						__LINE__ );
			pClass->Release();
			return sc;
		}


		V_VT(&v) = VT_BSTR;
		V_BSTR(&v) = SysAllocString(L"<default>");
		BSTR OtherProp = SysAllocString(L"BrowserRootPath");
		sc = pClass->Put(OtherProp, 0, &v, NULL);
		SysFreeString(OtherProp);
		VariantClear(&v);

		if (sc != S_OK)
		{
			CString csUserMsg;
			csUserMsg =  _T("Cannot Put BrowserRootPath property for NamespaceConfiguration class.");
			ErrorMsg
						(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
						__LINE__ );
			pClass->Release();
			return sc;
		}

		// Register the class with CIMOM
		// ============================

		sc = pProv->PutClass(pClass, 0, 0, 0);

		if (sc != S_OK)
		{
			CString csUserMsg;
			csUserMsg =  _T("Cannot Put class for NamespaceConfiguration class.");
			ErrorMsg
						(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
						__LINE__ );
			pClass->Release();
			return sc;
		}
		pClass->Release();
		pClass = NULL;
		BSTR bstrTemp = csClass.AllocSysString();
		sc = pProv -> GetObject
				(bstrTemp,0,NULL, &pClass,NULL);
		::SysFreeString(bstrTemp);

		if (sc != S_OK)
		{
			CString csUserMsg;
			csUserMsg =  _T("Cannot get NamespaceConfiguration class just created.");
			ErrorMsg
						(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
						__LINE__ );

			return sc;
		}
	}

	IWbemClassObject *pNewInstance = 0;

	sc = pClass->SpawnInstance(0, &pNewInstance);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot SpawnInstance for NamespaceConfiguration class.");
		ErrorMsg
						(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
						__LINE__ );
		pClass->Release();
		return sc;
	}

	pClass->Release();

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v) = pcsNamespace->AllocSysString();
	BSTR InstKeyProp = SysAllocString(L"NamespaceName");
	sc = pNewInstance->Put(InstKeyProp, 0, &v, NULL);
	SysFreeString(InstKeyProp);
	VariantClear(&v);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot Put NamespaceName property for NamespaceConfiguration instance.");
		ErrorMsg
						(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
						__LINE__ );
		return sc;
	}

	V_VT(&v) = VT_BSTR;
	V_BSTR(&v) = pcsRootPath->AllocSysString();
	BSTR PathProp = SysAllocString(L"BrowserRootPath");
	sc = pNewInstance->Put(PathProp, 0, &v, NULL);
	SysFreeString(PathProp);
	VariantClear(&v);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot Put BrowserRootPath property for NamespaceConfiguration instance.");
		ErrorMsg
						(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
						__LINE__ );
		return sc;
	}


	sc = pProv->PutInstance(pNewInstance,WBEM_FLAG_CREATE_OR_UPDATE, 0, 0);

	if (sc == S_OK)
	{
		pNewInstance->Release();
	}
	else
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot PutInstance for NamespaceConfiguration instance.");
		ErrorMsg
						(&csUserMsg, sc, NULL,TRUE, &csUserMsg, __FILE__,
						__LINE__ );

	}



	return sc;
}

BOOL UpdateNamespaceConfigInstance
(IWbemServices *pProv, CString *pcsRootPath, CString &rcsNamespace)
{
	CString csRootObjectPath = _T("NamespaceConfiguration");
	CPtrArray *pInstances =
		GetInstances(pProv, &csRootObjectPath, rcsNamespace, FALSE, TRUE);

	BOOL bReturn = FALSE;

	for (int i = 0; i < pInstances->GetSize(); i++)
	{
		IWbemClassObject *pObject =
			reinterpret_cast<IWbemClassObject *>
				(pInstances->GetAt(i));
		if (i == 0)
		{
			CString csProp = _T("BrowserRootPath");
			bReturn =
				SetProperty
				(pProv, pObject,
				&csProp, pcsRootPath, TRUE);
			pProv->PutInstance(pObject, 0, 0, 0);

		}
		pObject ->Release();
	}


	return bReturn;
}

BOOL SetProperty
(IWbemServices * pProv, IWbemClassObject * pInst,
 CString *pcsProperty, CString *pcsPropertyValue, BOOL bQuietly)
{
	SCODE sc;

    VARIANTARG var;
	VariantInit(&var);
    var.vt = VT_BSTR;
    var.bstrVal = pcsPropertyValue -> AllocSysString ( );
    if(var.bstrVal == NULL)
	{
        return WBEM_E_FAILED;
	}

	BSTR bstrTemp = pcsProperty -> AllocSysString ( );
    sc = pInst->Put( bstrTemp ,0,&var,NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
		{
			if (!bQuietly)
			{
				CString csUserMsg =
								_T("Cannot Put " + *pcsProperty);
				ErrorMsg
					(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
			}
		}


	VariantClear(&var);
	return TRUE;
}

void MoveWindowToLowerLeftOfOwner(CWnd *pWnd)
{
	CWnd *pOwner = pWnd->GetOwner();
	RECT rectOwner;
	pOwner->GetClientRect(&rectOwner);

	pOwner->ClientToScreen(&rectOwner);

	RECT rect;
	pWnd->GetClientRect(&rect);

	pWnd->ClientToScreen(&rect);

	RECT rectMove;
	rectMove.left = rectOwner.left;
	rectMove.bottom = rectOwner.bottom;
	rectMove.right = rectOwner.left + (rect.right - rect.left);
	rectMove.top = rectOwner.top + (rectOwner.bottom - rect.bottom);
	pWnd->MoveWindow(&rectMove,TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\navigatorppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// NavigatorPpg.h : Declaration of the CNavigatorPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CNavigatorPropPage : See NavigatorPpg.cpp.cpp for implementation.

class CNavigatorPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CNavigatorPropPage)
	DECLARE_OLECREATE_EX(CNavigatorPropPage)

// Constructor
public:
	CNavigatorPropPage();

// Dialog Data
	//{{AFX_DATA(CNavigatorPropPage)
	enum { IDD = IDD_PROPPAGE_NAVIGATOR };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CNavigatorPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\pathdialog.h ===
// ***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File: pathdialog.h
//
// Description:
//	This file declares the CPathDialog class which is a subclass
//	of the MFC CDialog class.  It is a part of the Instance Explorer OCX, 
//	and it performs the following functions:
//		a.  Allows the user to enter an object path for the tree root.
//
// Part of: 
//	Navigator.ocx 
//
// Used by:
//	CNavigatorCtrl
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

//****************************************************************************
//
// CLASS:  CPathDialog
//
// Description:
//	  This class which is a subclass of the MFC CDialog class.  It allows the 
//	  user to enter an object path that is used to search for the instance
//	  represented by that object path to be used as the initial tree root.
//
// Public members:
//	
//	  CPathDialog		Public constructor.
//
//============================================================================
//
// CPathDialog::CPathDialog
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  CClassNavCtrl* pParent	Parent
//
// Returns:
// 	  NONE
//
//****************************************************************************

#ifndef _CPathDialog_H_
#define _CPathDialog_H_

class CNavigatorCtrl;

class CPathDialog : public CDialog
{
// Construction
public:
	CPathDialog(CNavigatorCtrl* pParent = NULL);   // standard constructor

protected:
	//{{AFX_DATA(CPathDialog)
	enum { IDD = IDD_DIALOGTREEROOT };
	CString	m_csPath;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPathDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	CNavigatorCtrl* m_pParent;
	// Generated message map functions
	//{{AFX_MSG(CPathDialog)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CNavigatorCtrl;
};

#endif

/*	EOF:  pathdialog.h  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
#define _AFX_ENABLE_INLINES
#include <afxctl.h>         // MFC support for OLE Controls
#include <AFXCMN.H>
// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#endif //_UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\progdlg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//  ProgDlg.cpp : implementation file
// CG: This file was added by the Progress Dialog component

#include "precomp.h"
#include "resource.h"
#include "ProgDlg.h"
#include <OBJIDL.H>
#include "resource.h"
#include "wbemidl.h"
#include "OLEMSCLient.h"
#include "CInstanceTree.h"
#include "Navigator.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "InstanceSearch.h"
#include "AvailClasses.h"
#include "AvailClassEdit.h"
#include "SelectedClasses.h"
#include "SimpleSortedCStringArray.h"
#include "BrowseforInstances.h"
#include "NavigatorCtl.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CNavigatorApp NEAR theApp;

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog

CProgressDlg::CProgressDlg(UINT nCaptionID)
{

    m_bCancel=FALSE;

    //{{AFX_DATA_INIT(CProgressDlg)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_bParentDisabled = FALSE;
}

CProgressDlg::~CProgressDlg()
{
	if (m_pActiveXParent->GetSafeHwnd())
	{
		m_pActiveXParent->PostMessage(SETFOCUS,0,0);
	}

    if(m_hWnd!=NULL)
      DestroyWindow();
}

BOOL CProgressDlg::DestroyWindow()
{
    ReEnableParent();
	m_bCancel = FALSE;

	if (m_pActiveXParent->GetSafeHwnd())
	{
		m_pActiveXParent->PostMessage(SETFOCUS,0,0);
	}
    return CDialog::DestroyWindow();
}

void CProgressDlg::ReEnableParent()
{
	CWnd *pParentOwner = CWnd::GetSafeOwner(m_pParentWnd);

    if(m_bParentDisabled && (pParentOwner!=NULL))
      pParentOwner->EnableWindow(TRUE);
    m_bParentDisabled=FALSE;
}

BOOL CProgressDlg::Create(CWnd *pParent)
{
	m_pParentWnd = pParent;

    // m_bParentDisabled is used to re-enable the parent window
    // when the dialog is destroyed. So we don't want to set
    // it to TRUE unless the parent was already enabled.

	// Get the true parent of the dialog
	CWnd *pParentOwner = CWnd::GetSafeOwner(m_pParentWnd);
    if((pParentOwner!=NULL) && pParentOwner->IsWindowEnabled())
    {
      pParentOwner->EnableWindow(FALSE);
      m_bParentDisabled = TRUE;
    }

    if(!CDialog::Create(CProgressDlg::IDD,pParentOwner))
    {
      ReEnableParent();
      return FALSE;
    }

	m_bCancel = FALSE;
    return TRUE;
}

void CProgressDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CProgressDlg)
	DDX_Control(pDX, CG_IDC_PROGDLG_STATUS, m_cstaticMessage);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CProgressDlg, CDialog)
    //{{AFX_MSG_MAP(CProgressDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CProgressDlg::SetStatus(LPCTSTR lpszMessage)
{
    ASSERT(m_hWnd); // Don't call this _before_ the dialog has
                    // been created. Can be called from OnInitDialog
    CWnd *pWndStatus = GetDlgItem(CG_IDC_PROGDLG_STATUS);

    // Verify that the static text control exists
    ASSERT(pWndStatus!=NULL);
    pWndStatus->SetWindowText(lpszMessage);
	m_bCancel = FALSE;
}

void CProgressDlg::OnCancel()
{
    m_bCancel=TRUE;
	CButton *pcbCancel = (CButton *) GetDlgItem(IDCANCEL);
	pcbCancel->EnableWindow(FALSE);
}

void CProgressDlg::PumpMessages()
{
    // Must call Create() before using the dialog
    ASSERT(m_hWnd!=NULL);

    MSG msg;
    // Handle dialog messages
    while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
      if(!IsDialogMessage(&msg))
      {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
      }
    }
}

BOOL CProgressDlg::CheckCancelButton()
{
    // Process all pending messages
    PumpMessages();
    BOOL bResult = m_bCancel;


    return bResult;
}

void CProgressDlg::UpdateWindowStrings()
{
	if (GetSafeHwnd())
	{
		m_cstaticMessage.SetWindowText(m_csMessage);
		SetWindowText(m_csLabel);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg message handlers

BOOL CProgressDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

	theApp.DoWaitCursor(-1);
	m_cstaticMessage.SetWindowText(m_csMessage);
	SetWindowText(m_csLabel);
	m_bCancel = FALSE;
	MoveWindowToLowerLeftOfOwner(this);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\progdlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ProgDlg.h : header file
// CG: This file was added by the Progress Dialog component

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog

#ifndef __PROGDLG_H__
#define __PROGDLG_H__

class CNavigatorCtrl;


class CProgressDlg : public CDialog
{
// Construction / Destruction
public:
    CProgressDlg(UINT nCaptionID = 0);   // standard constructor
    ~CProgressDlg();

    BOOL Create(CWnd *pParent=NULL);
	void SetMessage(CString &csMessage) 
	{m_csMessage = csMessage;}
	void SetLabel(CString &csLabel) 
	{m_csLabel = csLabel;}
	void PumpMessages();

    // Checking for Cancel button
    BOOL CheckCancelButton();
    // Progress Dialog manipulation
    void SetStatus(LPCTSTR lpszMessage);

	void SetActiveXParent(CNavigatorCtrl *pParent)
	{ m_pActiveXParent = pParent;}

	void UpdateWindowStrings();
    
// Dialog Data
    //{{AFX_DATA(CProgressDlg)
	enum { IDD = CG_IDD_PROGRESS };
	CStatic	m_cstaticMessage;
	//}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CProgressDlg)
    public:
    virtual BOOL DestroyWindow();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
	
	CString m_csMessage;
	CString m_csLabel;

    BOOL m_bCancel;
    BOOL m_bParentDisabled;

    void ReEnableParent();

	CNavigatorCtrl *m_pActiveXParent;

    // Generated message map functions
    //{{AFX_MSG(CProgressDlg)
    virtual BOOL OnInitDialog();
	virtual void OnCancel();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
	friend class CNavigatorCtrl;
};

#endif // __PROGDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\resultslist.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ResultsList.cpp : implementation file
//

#include "precomp.h"
#include "resource.h"
#include "wbemidl.h"
#include "navigator.h"
#include "AvailClasses.h"
#include "AvailClassEdit.h"
#include "SelectedClasses.h"
#include "SimpleSortedCStringArray.h"
#include "BrowseforInstances.h"
#include "OLEMSClient.h"
#include "ResultsList.h"
#include "Results.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CResultsList

CResultsList::CResultsList()
{
}

CResultsList::~CResultsList()
{
}


BEGIN_MESSAGE_MAP(CResultsList, CListCtrl)
	//{{AFX_MSG_MAP(CResultsList)
	ON_WM_CREATE()
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
	ON_NOTIFY_REFLECT(NM_CLICK, OnClk)
	ON_WM_LBUTTONDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CResultsList message handlers

int CResultsList::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CListCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO: Add your specialized creation code here

	return 0;
}

void CResultsList::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);

	COLORREF cr = (COLORREF)RGB(255, 255, 255);

	RECT rectFill = lpDIS->rcItem;
	rectFill.bottom += 0;


	if (lpDIS->itemID == -1)
	{
		return;
	}

	if (lpDIS->itemAction & ODA_DRAWENTIRE)
	{
		DrawRowItems
			(lpDIS->itemID, rectFill,pDC);

	}

	if ((lpDIS->itemState & ODS_SELECTED) &&
		(lpDIS->itemAction & (ODA_SELECT | ODA_DRAWENTIRE)))
	{
		// item has been selected - hilite frame
		COLORREF crHilite = GetSysColor(COLOR_ACTIVECAPTION);
		CBrush br(crHilite);
		pDC->FillRect(&rectFill, &br);
		pDC->SetBkMode( TRANSPARENT );
		COLORREF crSave = pDC->GetTextColor( );
		pDC->SetTextColor(RGB(255,255,255));
		DrawRowItems
			(lpDIS->itemID, rectFill,pDC);
		pDC->SetTextColor(crSave);
		pDC->SetBkMode( OPAQUE );


	}

	if ((!(lpDIS->itemState & ODS_SELECTED)) &&
		(lpDIS->itemAction & (ODA_SELECT | ODA_DRAWENTIRE)))
	{
		// Item has been de-selected -- remove frame
		CBrush br(cr);
		pDC->FillRect(&rectFill, &br);
		DrawRowItems
			(lpDIS->itemID, rectFill,pDC);
	}
}

void CResultsList::DrawRowItems
(int nItem, RECT rectFill, CDC* pDC)
{

	RECT rectSubItem;
	rectSubItem.left = rectFill.left;
	rectSubItem.right = rectFill.right;
	rectSubItem.top = rectFill.top;
	rectSubItem.bottom = rectFill.bottom;

	int i;
	TCHAR szBuffer[201];
	CString csBuffer;
	int colLeft = rectFill.left;
	for (i = 0; i < m_nCols; i++)
	{

		LV_ITEM lvItem;
		lvItem.mask = LVIF_TEXT ;
		lvItem.iItem = nItem;
		lvItem.iSubItem = i;
		lvItem.cchTextMax = 200;
		lvItem.pszText = szBuffer;

		GetItem (&lvItem);
		csBuffer = szBuffer;
		if (csBuffer.GetLength() == 0)
		{
			break;
		}
		CSize csText = pDC->GetTextExtent(csBuffer);
		int nColWidth = GetColumnWidth(i);
		int nColWidthDraw = nColWidth - 6;

		double dCharSize = csText.cx / csBuffer.GetLength();
	#pragma warning( disable :4244 )
		int nMaxChars = (nColWidthDraw / dCharSize) - 5;
	#pragma warning( default : 4244 )

		if (csBuffer.GetLength() > nMaxChars &&
			csText.cx >= (nColWidthDraw - (.5 * dCharSize)))
		{
			CString csBufferTest = csBuffer.Left(nMaxChars - 0);
			CSize csTextTest = pDC->GetTextExtent(csBufferTest);
			if (csTextTest.cx < (nColWidthDraw - (3.0 * dCharSize)))
			{
				csBuffer = csBuffer.Left(nMaxChars + 1);
			}
			else if (csTextTest.cx > (nColWidthDraw - (2.0 * dCharSize)))
			{
				csBuffer = csBuffer.Left(nMaxChars - 1);
			}
			else
			{
				csBuffer = csBuffer.Left(nMaxChars);
			}
			csBuffer += _T("...");

		}

		rectSubItem.left = colLeft;
		rectSubItem.right = colLeft + nColWidth - 3;
		pDC->ExtTextOut
			(colLeft + 3,
			rectFill.top,
			ETO_CLIPPED,
			&rectSubItem,
			csBuffer,NULL);
		colLeft = colLeft + nColWidth;

	}

}

BOOL CResultsList::PreTranslateMessage(MSG* pMsg)
{
	return CListCtrl::PreTranslateMessage(pMsg);
}

void CResultsList::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult)
{
	// TODO: Add your control notification handler code here
	CResults *pParent =
		reinterpret_cast<CResults *>
			(GetParent());

	pParent->OnOK();
	*pResult = 0;
}

void CResultsList::OnClk(NMHDR* pNMHDR, LRESULT* pResult)
{
	// TODO: Add your control notification handler code here
	CResults *pParent =
		reinterpret_cast<CResults *>
			(GetParent());

	::EnableWindow(::GetDlgItem(pParent->GetSafeHwnd(), IDOK),
							(GetSelectedCount() == 1));
	*pResult = 0;
}

void CResultsList::OnLButtonDown(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	CListCtrl::OnLButtonDown(nFlags, point);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\results.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_RESULTS_H__BE99BE31_D2ED_11D0_9642_00C04FD9B15B__INCLUDED_)
#define AFX_RESULTS_H__BE99BE31_D2ED_11D0_9642_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Results.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CResults dialog
class 	CResultsList;
class	CBrowseforInstances;
class	CSimpleSortedCStringArray;

class CResults : public CDialog
{
// Construction
public:
	CResults(CWnd* pParent = NULL);   // standard constructor
	~CResults();
	void SetServices(IWbemServices *pServices)
		{m_pServices = pServices;}
	void AddNonAbstractClass(CString &rcsClass) {m_csaNonAbstractClasses.Add(rcsClass);}
	void AddAbstractClass(CString &rcsClass) {m_csaAbstractClasses.Add(rcsClass);}
	void ResetClasses()
		{m_csaAbstractClasses.RemoveAll();
			m_csaNonAbstractClasses.RemoveAll();}
	void SetParent(CBrowseforInstances *pParent)
		{m_pParent=pParent;}
	enum {TreeRoot, InitialObject};
	void SetMode(int nMode) {m_nMode = nMode;}
// Dialog Data
	//{{AFX_DATA(CResults)
	enum { IDD = IDD_DIALOGRESULTS };
	CButton	m_cbOK;
	CButton	m_cbCancel;
	CStatic	m_cstaticBanner;
	//}}AFX_DATA
	CResultsList	m_clcResults;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CResults)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	IWbemServices *m_pServices;

	CPictureHolder *m_pcphImage;
	int m_nBitmapH;
	int m_nBitmapW;

	CBrowseforInstances *m_pParent;

	CStringArray m_csaNonAbstractClasses;
	CStringArray m_csaAbstractClasses;

	int m_nNumInstances;
//	CPtrArray m_cpaAllInstances;

	void AddCols(int nMaxKeys, int nKeys);
	void CreateCols(int nNumCols);
	void InsertRowData
		(int nRow, CString &rcsPath, CStringArray *pcsaKeys);
	CPtrArray *GetInstances(IWbemServices *pServices, CString *pcsClass,
						BOOL bDeep = FALSE, BOOL bQuietly = FALSE);

	int m_nMode;

	BOOL m_bCancel;
	int m_nSpinAwhile;

	int m_nMaxKeys;
	int m_nCols;

	int GetKeys (CString &rcsPath,  CStringArray *&pcsaKeys);
	void InsertRows(CPtrArray *pcpaInstances);

	UINT_PTR m_nObjectsDebug;
	int m_nObjectsReleasedDebug;

	// Generated message map functions
	//{{AFX_MSG(CResults)
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	//}}AFX_MSG
	afx_msg LRESULT ContinueInit(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
	CSortedCStringArray *m_pcscsaInstances;
	friend class CResultsList;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RESULTS_H__BE99BE31_D2ED_11D0_9642_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Navigator.rc
//
#define IDS_COMPOSITE                   1
#define IDD_ABOUTBOX_COMPOSITE          1
#define IDB_COMPOSITE                   1
#define IDI_ABOUTDLL                    1
#define IDS_NAVIGATOR                   1
#define IDD_ABOUTBOX_NAVIGATOR          1
#define IDB_NAVIGATOR                   1
#define IDS_COMPOSITE_PPG               2
#define IDS_NAVIGATOR_PPG               2
#define IDS_COMPOSITE_PPG_CAPTION       100
#define IDD_PROPPAGE_COMPOSITE          100
#define IDS_NAVIGATOR_PPG_CAPTION       100
#define IDD_PROPPAGE_NAVIGATOR          100
#define CG_IDR_POPUP_A_TREE_CTRL        102
#define CG_IDD_PROGRESS                 103
#define IDB_BITMAPNOEXPAND              201
#define IDC_EDITClass                   201
#define IDB_BITMAPPC                    202
#define IDB_BITMAPCLOSED                202
#define IDC_BUTTONADVANCED              202
#define IDB_BITMAPPCPU                  203
#define IDB_BITMAPYELLOW                203
#define IDC_BUTTONHELP                  203
#define IDB_BITMAPCPU                   204
#define IDB_BITMAPBLACK                 204
#define IDC_BUTTONADD                   204
#define IDB_BITMAPPC3                   205
#define IDB_BITMAPDARKGRAY              205
#define IDC_BUTTONDELETE                205
#define IDB_BITMAPPC4                   206
#define IDB_BITMAPLIGHTGRAY             206
#define IDC_LIST1                       206
#define IDB_BITMAPPC5                   207
#define IDB_BITMAPLIME                  207
#define IDC_EDIT1                       207
#define IDB_BITMAPPC6                   208
#define IDB_BITMAPPURPLE                208
#define IDD_DIALOGSEARCHFORINSTANCE     208
#define IDC_EDITVALUE                   208
#define IDC_LISTSELCLASSES              208
#define IDB_BITMAPPC7                   209
#define IDB_BITMAPRED                   209
#define IDC_EDITKEY                     209
#define IDB_BITMAPPC8                   210
#define IDB_BITMAPROYAL                 210
#define IDB_BITMAPAQUA                  211
#define IDB_BITMAPDEPEND                212
#define IDC_BUTTONREMOVE                212
#define IDB_BITMAPCONTAIN               213
#define IDC_LISTALLCLASSES              213
#define IDB_BITMAPBINDING               214
#define IDC_RADIOALLCLASSES             214
#define IDB_BITMAPUGLYGREEN             215
#define IDC_RADIOCLASSESCANHAVEINST     215
#define IDB_BITMAPCONTAIN7              216
#define IDC_CHECKASSOC                  216
#define IDB_BITMAPBINDING1              217
#define IDB_BITMAPBINDING2              218
#define IDC_STATICBROWSE                218
#define IDB_BITMAPBINDING3              219
#define IDC_STATIC33                    219
#define IDB_BITMAPBINDING4              220
#define IDC_STATICRESULTBANNER          220
#define IDB_BITMAPCONTAIN0              221
#define IDC_LISTRESULTS                 221
#define IDB_BITMAPCONTAIN1              222
#define IDB_BITMAPCONTAIN2              223
#define IDB_BITMAPCONTAIN3              224
#define IDB_BITMAPCONTAIN4              225
#define IDB_BITMAPCONTAIN5              226
#define IDB_BITMAPCONTAIN6              227
#define IDB_BITMAPBINDING0              228
#define IDB_BITMAPLEAF                  229
#define IDB_BITMAPOPEN                  230
#define IDB_BITMAPCHKCLEAR              231
#define IDB_BITMAPCHECKBOX              235
#define IDB_BITMAPCLEAR                 236
#define IDB_BITMAPCHECK                 237
#define IDB_BITMAPLEAFCHECKED           238
#define IDB_BITMAPNOEXPANDCHECKED       239
#define IDD_DIALOGSELECTVIEW            243
#define IDI_ICONOPEN                    246
#define IDI_ICONCLOSED                  247
#define IDB_BITMAPPLACEHOLDER           248
#define IDI_ICONPLACEHOLDER             248
#define IDI_ICONINSTANCE                248
#define IDI_ICONDDD                     249
#define IDI_ICONCLOSED1                 250
#define IDI_ICONNEINSTANCE              250
#define IDI_ICONGROUP                   251
#define IDI_ICONEGROUP                  252
#define IDB_BITMAPNEWSEL                253
#define IDI_ICONASSOCROLE               253
#define IDB_BITMAP1                     254
#define IDI_ICONEASSOCROLE              254
#define IDI_ICONASSOCINSTANCE           255
#define IDB_BITMAPSAVEANDFILTER         257
#define IDR_TOOLBARFILTER               258
#define IDD_DIALOGTREEROOT              260
#define IDR_TOOLBAR1                    261
#define IDI_ICONCLASS                   264
#define IDB_BITMAPFINDGLASS             265
#define IDD_DIALOGBROWSEFORINSTANCES    266
#define IDB_BITMAP2                     268
#define IDB_BITMAPBROWSE                269
#define IDB_BITMAPBANNER                270
#define IDD_DIALOGRESULTS               271
#define IDD_DIALOG3                     272
#define IDC_NSENTRYCTRLINITNAMESPACE    273
#define CG_IDC_PROGDLG_STATUS           274
#define IDD_DIALOGINITNAMESPACE         275
#define IDI_ICONASSOCROLEWEAK           276
#define IDI_ICONASSOCROLEWEAK2          277
#define ID_VIEWOBJECT                   32768
#define ID_VIEWASSOC                    32769
#define ID_SETROOT                      32770
#define ID_SELECTROOT                   32771
#define ID_POPUP_SELECTROOT_SYSTEM      32772
#define ID_POPUP_SELECTROOT_NETWORKCARD 32774
#define ID_POPUP_SELECTROOT_KEYBOARD    32775
#define ID_POPUP_SELECTROOT_MONITOR     32776
#define ID_BUTTONFILTER                 32777
#define ID_BUTTONADD                    32778
#define ID_BUTTONDELETE                 32779
#define ID_POPUP_MULTIINSTANCEVIEWER    32780
#define ID_BUTTON32781                  32781
#define ID_POPUP_INSTANCESEARCH         32783
#define ID_BUTTONGO                     32784
#define ID_POPUP_PARENTASSOCIATION      32785
#define ID_POPUP_BROWSE                 32786
#define ID_BROWSEFORINST                32787
#define ID_POPUP_GOTONAMESPACE          32788
#define ID_POPUP_REFRESH                32789
#define ID_MENUITEMINITIALROOT          32790

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        278
#define _APS_NEXT_COMMAND_VALUE         32791
#define _APS_NEXT_CONTROL_VALUE         275
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\results.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Results.cpp : implementation file
//

#include "precomp.h"
#include "resource.h"
#include "wbemidl.h"
#include "navigator.h"
#include "CInstanceTree.h"
#include "CContainedToolBar.h"
#include "Banner.h"
#include "InstanceSearch.h"
#include "AvailClasses.h"
#include "AvailClassEdit.h"
#include "SelectedClasses.h"
#include "SimpleSortedCStringArray.h"
#include "BrowseforInstances.h"
#include "NavigatorCtl.h"
#include "OLEMSClient.h"
#include "ResultsList.h"
#include "Results.h"
#include "logindlg.h"




#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CResults dialog

#define CONTINUEINIT WM_USER  + 600


CResults::CResults(CWnd* pParent /*=NULL*/)
	: CDialog(CResults::IDD, pParent)
{
	//{{AFX_DATA_INIT(CResults)
	//}}AFX_DATA_INIT

	m_pcphImage = NULL;
	m_pcscsaInstances = NULL;
}

CResults::~CResults()
{
	if (m_pcscsaInstances)
	{
		delete m_pcscsaInstances;
		m_pcscsaInstances = NULL;
	}
}

void CResults::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CResults)
	DDX_Control(pDX, IDOK, m_cbOK);
	DDX_Control(pDX, IDCANCEL, m_cbCancel);
	DDX_Control(pDX, IDC_STATICRESULTBANNER, m_cstaticBanner);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CResults, CDialog)
	//{{AFX_MSG_MAP(CResults)
	ON_WM_DESTROY()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
	ON_MESSAGE(CONTINUEINIT,ContinueInit)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CResults message handlers

void CResults::OnDestroy()
{
	CDialog::OnDestroy();


	// TODO: Add your message handler code here

}

void CResults::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	if (!m_pcphImage)
	{
		HBITMAP hBitmap;
		HPALETTE hPalette;
		BITMAP bm;

		CString csRes;
		csRes.Format(_T("#%d"),IDB_BITMAPBANNER);
		hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		csRes.GetBuffer(csRes.GetLength()),&hPalette);

		GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
		m_nBitmapW = bm.bmWidth;
		m_nBitmapH  = bm.bmHeight;

		m_pcphImage = new CPictureHolder();
		m_pcphImage->CreateFromBitmap(hBitmap, hPalette );

	}

	CRect rcBannerExt;
	m_cstaticBanner.GetWindowRect(&rcBannerExt);
	ScreenToClient(rcBannerExt);

	if(m_pcphImage->GetType() != PICTYPE_NONE &&
	   m_pcphImage->GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(m_pcphImage->m_pPict
		   && SUCCEEDED(m_pcphImage->m_pPict->get_hPal((unsigned int *)&hpal)))

		{

			HPALETTE hpSave = SelectPalette(dc.m_hDC,(HPALETTE)hpal,TRUE);

			dc.RealizePalette();

			dc.FillRect(&rcBannerExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			m_pcphImage->Render(&dc, rcBannerExt, rcBannerExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));


	CRect rcFrame(	rcBannerExt.TopLeft().x,
					rcBannerExt.TopLeft().y,
					rcBannerExt.BottomRight().x,
					rcBannerExt.BottomRight().y);
	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));


	CString csFont = _T("MS Shell Dlg");

	CString csOut;
	CRect crOut;

	csOut = _T("Results");

	crOut = OutputTextString
		(&dc, this, &csOut, 15, 15, &csFont, 8, FW_BOLD);

	CPoint cpPoint;

	if (m_nMode == TreeRoot)
	{
		csOut = _T("This dialog shows the objects in the classes you selected.  Select one object, then ");

		csOut += _T("click OK to re-root the Object Explorer tree at the object you want to find.");

		cpPoint = CPoint(crOut.TopLeft().x + 15, crOut.BottomRight().y + 1);
	}
	else
	{
		csOut = _T("This dialog shows the objects in the classes you selected.  Select one object, then ");

		csOut += _T("click OK to make the selected object the initial tree root and to store the path of the object in the database.");

		cpPoint = CPoint (crOut.TopLeft().x + 15, crOut.BottomRight().y + 1);
	}

	crOut.TopLeft().x = 0;
	crOut.TopLeft().y = 0;
	crOut.BottomRight().x = rcBannerExt.BottomRight().x - cpPoint.x;
	crOut.BottomRight().y = rcBannerExt.BottomRight().y - cpPoint.y;

	OutputTextString
		(&dc, this, &csOut, cpPoint.x, cpPoint.y, crOut, &csFont, 8, FW_NORMAL);


	// Do not call CDialog::OnPaint() for painting messages
}

BOOL CResults::OnInitDialog()
{
	CDialog::OnInitDialog();

	m_nObjectsDebug = 0;
	m_nObjectsReleasedDebug = 0;

	CString csText;
	if (m_nMode == TreeRoot)
	{
		csText = _T("Browse for Instance");
		SetWindowText(csText);
	}
	else
	{
		csText = _T("Set Initial Tree Root");
		SetWindowText(csText);
	}

	m_clcResults.SubclassDlgItem(IDC_LISTRESULTS, this);

	m_nSpinAwhile = 0;
	PostMessage(CONTINUEINIT,0,0);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CResults::ContinueInit(WPARAM, LPARAM)
{
	// So that the window actually gets shown before we add data.

	m_cbOK.EnableWindow(FALSE);
	m_cbCancel.EnableWindow(FALSE);

	if (m_nSpinAwhile < 4)
	{
		ShowWindow(SW_SHOW);
		PostMessage(CONTINUEINIT,0,0);
		m_nSpinAwhile = m_nSpinAwhile + 1;
		return 0;
	}

	int i;

	if (m_pcscsaInstances)
	{
		delete m_pcscsaInstances;
		m_pcscsaInstances = NULL;
	}

	m_pcscsaInstances = new CSortedCStringArray();
	CPtrArray *pcpaInstances;

	m_nMaxKeys = 1;
	m_nCols = 1;
	m_nNumInstances = 0;

	CreateCols(m_nCols);

	// Only instances of this class

	INT_PTR nSize = m_csaNonAbstractClasses.GetSize();
	m_bCancel = FALSE;

	for (i = 0; i < nSize; i++)
	{
		CString csClass = m_csaNonAbstractClasses.GetAt(i);

		m_pParent->m_pParent->SetProgressDlgMessage(csClass);

		CString csLabel = _T("Retrieving instances for non-abstract class:");
		m_pParent->m_pParent->SetProgressDlgLabel(csLabel);

		if (!m_pParent->m_pParent->GetProgressDlgSafeHwnd())
		{
			m_pParent->m_pParent->CreateProgressDlgWindow();

		}

		m_pParent->m_pParent->UpdateProgressDlgWindowStrings();

		pcpaInstances = GetInstances(m_pServices,&csClass,FALSE);

		delete pcpaInstances;
		pcpaInstances = NULL;

		if (m_bCancel)
		{
			break;

		}
	}



	// Instances of all classes which inherit from this class.
	if (!m_bCancel)
	{
		for (i = 0; i < m_csaAbstractClasses.GetSize(); i++)
		{
			CString csClass = m_csaAbstractClasses.GetAt(i);

			m_pParent->m_pParent->SetProgressDlgMessage(csClass);

			CString csLabel = _T("Retrieving instances for abstract class:");
			m_pParent->m_pParent->SetProgressDlgLabel(csLabel);

			if (!m_pParent->m_pParent->GetProgressDlgSafeHwnd())
			{
				m_pParent->m_pParent->CreateProgressDlgWindow();

			}

			m_pParent->m_pParent->UpdateProgressDlgWindowStrings();

			pcpaInstances = GetInstances(m_pServices,&csClass,TRUE);

			delete pcpaInstances;
			pcpaInstances = NULL;

			if (m_bCancel)
			{
				break;

			}
		}
	}

	m_pParent->m_pParent->DestroyProgressDlgWindow(FALSE,TRUE);

	nSize = m_pcscsaInstances->GetSize();

	if (nSize == 0)
	{
		m_nNumInstances = 0;
		CString csUserMsg;
		if (m_bCancel)
		{
			csUserMsg =  _T("Operation canceled.");
		}
		else
		{
			csUserMsg =  _T("The selected classes do not have instances.");
		}
		m_pParent->m_pParent->PreModalDialog();
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ );
		m_pParent->m_pParent->PostModalDialog();
		m_bCancel = FALSE;
		OnCancel();
		return TRUE;
	}

	if (m_bCancel)
	{
		CString csUserMsg;
		csUserMsg =  _T("Operation was canceled, you will see partial results.");
		m_pParent->m_pParent->PreModalDialog();
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ );
		m_pParent->m_pParent->PostModalDialog();
		m_bCancel = FALSE;
	}

	if (m_nNumInstances > 0)
	{
		m_cbOK.EnableWindow(TRUE);

		UINT uState = m_clcResults.GetItemState(0, LVIS_SELECTED );

		uState = uState | LVIS_SELECTED | LVIS_FOCUSED ;

		BOOL b = m_clcResults.SetItemState( 0 , uState, LVIS_FOCUSED | LVIS_SELECTED );

		m_clcResults.SetFocus();

	}

	m_cbCancel.EnableWindow(TRUE);

	return TRUE;

}

void CResults::AddCols(int nMaxKeys, int nKeys)
{

	int nNextCol = nMaxKeys + 1;

	LV_COLUMN lvCol;
	lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvCol.fmt = LVCFMT_LEFT;   // left-align column
	lvCol.cx = 220;             // width of column in pixels

	CString csColTitle;

	for (int i = nNextCol; i < nKeys + 1; i++)
	{
		lvCol.iSubItem = i;
		csColTitle.Format(_T("Key (%d)"),i);
		lvCol.pszText =  const_cast <TCHAR *> ((LPCTSTR) csColTitle);

		int nReturn = m_clcResults.InsertColumn( i ,&lvCol);
	}

	m_clcResults.SetNumberCols(nKeys + 1);
}

void CResults::CreateCols(int nNumCols)
{

	LV_COLUMN lvCol;
	lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvCol.fmt = LVCFMT_LEFT;   // left-align column
	lvCol.cx = 175;             // width of column in pixels
	lvCol.iSubItem = 0;
	lvCol.pszText = _T("Class");

	int nReturn =
		m_clcResults.InsertColumn( 0, &lvCol);

	CString csColTitle;
	int i;

	lvCol.fmt = LVCFMT_LEFT;   // left-align column
	lvCol.cx = 220;             // width of column in pixels

	for (i = 0; i < nNumCols; i++)
	{
		lvCol.iSubItem = i + 1;
		csColTitle.Format(_T("Key (%d)"),i + 1);
		lvCol.pszText =  const_cast <TCHAR *> ((LPCTSTR) csColTitle);

		nReturn =
			m_clcResults.InsertColumn( i + 1,&lvCol);
	}

	m_clcResults.SetNumberCols(nNumCols + 1);
}


void CResults::InsertRowData
(int nRow, CString &rcsPath, CStringArray *pcsaKeys)
{
	CString csClass =  GetIWbemClass(rcsPath);

	LV_ITEM lvItem;

	lvItem.mask = LVIF_TEXT | LVIF_PARAM ;
	lvItem.pszText = const_cast <TCHAR *> ((LPCTSTR) csClass);
	lvItem.iItem = nRow;
	lvItem.iSubItem = 0;
	lvItem.lParam = reinterpret_cast<LPARAM> (new CString(rcsPath));
	int nItem;
	nItem = m_clcResults.InsertItem (&lvItem);

	INT_PTR nKeys = pcsaKeys->GetSize() / 2;
	int i;

	for (i = 0; i < nKeys; i++)
	{
		CString csKey;
		csKey.Format(_T("%s=\"%s\""),pcsaKeys->GetAt(i * 2) , pcsaKeys->GetAt((i * 2) + 1)) ;
		lvItem.mask = LVIF_TEXT ;
		lvItem.pszText =  const_cast<TCHAR *>((LPCTSTR) csKey);
		lvItem.iItem = nItem;
		lvItem.iSubItem = i + 1;

		int nReturn = m_clcResults.SetItem (&lvItem);
	}

	m_nNumInstances+=1;

}


void CResults::OnOK()
{
#ifdef _DEBUG
//	afxDump << "m_nObjectsDebug = " << m_nObjectsDebug << "\n";
//	afxDump << "m_nObjectsReleasedDebug = " << m_nObjectsReleasedDebug << "\n";
#endif
	m_nObjectsDebug = 0;
	m_nObjectsReleasedDebug = 0;

	int nSel = m_clcResults.GetNextItem(-1,LVNI_ALL | LVNI_SELECTED);

	if (nSel == -1)
	{
		CString csUserMsg;
		csUserMsg =  _T("You must select an instance to make the root of the tree or click on Cancel ");
		csUserMsg += _T("to return to the Browse Criteria Dialog without re-rooting the tree. ");
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ );
		return;
	}


	LV_ITEM lvItem;

	lvItem.mask = LVIF_PARAM ;
	lvItem.iItem = nSel;
	lvItem.iSubItem = 0;

	m_clcResults.GetItem (&lvItem);

	CString *pcsPath = reinterpret_cast<CString *>(lvItem.lParam);



	IWbemClassObject *pObject =
		GetIWbemObject
			(m_pParent->m_pParent,m_pServices,
			m_pParent->m_pParent->GetCurrentNamespace(),
			m_pParent->m_pParent->GetAuxNamespace(),
			m_pParent->m_pParent->GetAuxServices(),
			 *pcsPath,TRUE);

	if (!pObject)
	{
		return;
	}

	BOOL bAssoc =
		IsAssoc(pObject);

	if (bAssoc)
	{
		pObject->Release();
		CString csUserMsg;
		csUserMsg =  _T("You must select an instance which is not an Association instance to make the root of the tree or click on Cancel ");
		csUserMsg += _T("to return to the Browse Criteria Dialog without re-rooting the tree. ");
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ );
		return;
	}

	pObject->Release();


	m_pParent->m_csSelectedInstancePath = *pcsPath;

	for (int i = 0; i < m_nNumInstances; i++)
	{
		LV_ITEM lvItem;

		lvItem.mask = LVIF_PARAM ;
		lvItem.iItem = i;
		lvItem.iSubItem = 0;

		m_clcResults.GetItem (&lvItem);

		CString *pcsPath = reinterpret_cast<CString *>(lvItem.lParam);
		delete pcsPath;
	}

	delete m_pcphImage;
	m_pcphImage = NULL;

	CDialog::OnOK();
	m_pParent->OnCancelReally();
}

void CResults::OnCancel()
{
#ifdef _DEBUG
//	afxDump << "m_nObjectsDebug = " << m_nObjectsDebug << "\n";
//	afxDump << "m_nObjectsReleasedDebug = " << m_nObjectsReleasedDebug << "\n";
#endif
	m_nObjectsDebug = 0;
	m_nObjectsReleasedDebug = 0;

	for (int i = 0; i < m_nNumInstances; i++)
	{
		LV_ITEM lvItem;

		lvItem.mask = LVIF_PARAM ;
		lvItem.iItem = i;
		lvItem.iSubItem = 0;

		m_clcResults.GetItem (&lvItem);

		CString *pcsPath = reinterpret_cast<CString *>(lvItem.lParam);
		delete pcsPath;
	}

	delete m_pcphImage;
	m_pcphImage = NULL;

	CDialog::OnCancel();
}

BOOL CResults::PreTranslateMessage(MSG* lpMsg)
{
	// TODO: Add your specialized code here and/or call the base class

	return CDialog::PreTranslateMessage(lpMsg);
}

void CResults::InsertRows(CPtrArray *pcpaInstances)
{
	for (int n = 0; n < pcpaInstances->GetSize(); n++)
	{
		IWbemClassObject *pObject =
			reinterpret_cast
			<IWbemClassObject *>(pcpaInstances->GetAt(n));
		CString csPath = GetIWbemFullPath(m_pServices,pObject);
		if (m_pcscsaInstances->IndexInArray(csPath) == -1)
		{
			int nIndex = m_pcscsaInstances->AddString(csPath,FALSE);
			CStringArray *pcsaKeys;
			int nKeys = GetKeys (csPath,pcsaKeys);
			if (nKeys > m_nMaxKeys)
			{
				if (nKeys > m_nCols)
				{
					AddCols(m_nMaxKeys,nKeys);
				}
				m_nMaxKeys = nKeys;
			}

			InsertRowData
				(nIndex,
				csPath,
				pcsaKeys);

			delete pcsaKeys;
		}

		m_nObjectsReleasedDebug += 1;
		pObject->Release();
	}
}

CPtrArray *CResults::GetInstances
(IWbemServices *pServices, CString *pcsClass, BOOL bDeep, BOOL bQuietly)
{
	SCODE sc;
	IEnumWbemClassObject *pIEnumWbemInstObject = NULL;
	IWbemClassObject *pIWbemInstObject = NULL;
	IWbemClassObject *pErrorObject = NULL;
	CPtrArray *pcpaInstances = NULL;

	long lFlag = bDeep? WBEM_FLAG_DEEP: WBEM_FLAG_SHALLOW;

	BSTR bstrTemp = pcsClass -> AllocSysString();
	sc = pServices->CreateInstanceEnum
		(bstrTemp,
		lFlag | WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pIEnumWbemInstObject);
	::SysFreeString(bstrTemp);

	if(sc != S_OK)
	{
		if (!bQuietly)
		{
			CString csUserMsg=  _T("Cannot get instance enumeration ");
			csUserMsg += _T(" for class ");
			csUserMsg += *pcsClass;
			ErrorMsg
					(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__,
					__LINE__ - 11);
		}
		ReleaseErrorObject(pErrorObject);
		return NULL;
	}

	ReleaseErrorObject(pErrorObject);

	SetEnumInterfaceSecurity(m_pParent->m_pParent->m_csNameSpace,pIEnumWbemInstObject, pServices);

	sc = pIEnumWbemInstObject->Reset();

	HRESULT hResult;
	int nRes = 10;

	pcpaInstances =
		m_pParent->m_pParent->SemiSyncEnum
		(pIEnumWbemInstObject, m_bCancel, hResult, nRes);

	m_nObjectsDebug += pcpaInstances->GetSize();


	while (	pcpaInstances &&
			!m_bCancel &&
			(hResult == S_OK ||
			hResult == WBEM_S_TIMEDOUT ||
			pcpaInstances->GetSize() > 0))
	{
		InsertRows(pcpaInstances);
		delete pcpaInstances;
		pcpaInstances = NULL;
		m_bCancel = m_pParent->m_pParent->CheckCancelButtonProgressDlgWindow();
		if (!m_bCancel)
		{
			pcpaInstances =
			m_pParent->m_pParent->SemiSyncEnum
				(pIEnumWbemInstObject, m_bCancel, hResult, nRes);
			m_nObjectsDebug += pcpaInstances->GetSize();
		}
	}

	delete pcpaInstances;
	pcpaInstances = NULL;

	return NULL;

}

int CResults::GetKeys (CString &rcsPath, CStringArray *&pcsaKeys)
{
	pcsaKeys =
		GetAllKeys(rcsPath);

	int nKeys = (int)pcsaKeys->GetSize();

	if (nKeys == 0)
	{
		return nKeys;
	}
	else
	{
		return nKeys / 2;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\resultslist.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_RESULTSLIST_H__A34E0CA1_D392_11D0_9642_00C04FD9B15B__INCLUDED_)
#define AFX_RESULTSLIST_H__A34E0CA1_D392_11D0_9642_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ResultsList.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CResultsList window

class CResultsList : public CListCtrl
{
// Construction
public:
	CResultsList();
	void SetNumberCols(int nCols)
	{m_nCols = nCols;}
// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CResultsList)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CResultsList();

	// Generated message map functions
protected:
	void DrawRowItems
		(int nItem, RECT rectFill, CDC* pDC);
	int m_nCols;
	//{{AFX_MSG(CResultsList)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnClk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG
	void DrawItem(LPDRAWITEMSTRUCT lpDIS);

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RESULTSLIST_H__A34E0CA1_D392_11D0_9642_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\selectedclasses.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// SelectedClasses.cpp : implementation file
//

#include "precomp.h"
#include "wbemidl.h"
#include "navigator.h"
#include "AvailClasses.h"
#include "AvailClassEdit.h"
#include "SelectedClasses.h"
#include "SimpleSortedCStringArray.h"
#include "BrowseforInstances.h"
#include "OLEMSClient.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSelectedClasses

CSelectedClasses::CSelectedClasses()
{
	m_bInit = FALSE;
}

CSelectedClasses::~CSelectedClasses()
{
}


BEGIN_MESSAGE_MAP(CSelectedClasses, CListBox)
	//{{AFX_MSG_MAP(CSelectedClasses)
	ON_CONTROL_REFLECT(LBN_SETFOCUS, OnSetfocus)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectedClasses message handlers

void CSelectedClasses::AddClasses
		(CStringArray &rcsaClasses, CByteArray &rcbaAbstractClasses)
{

	int i;
	for (i = 0; i < rcsaClasses.GetSize(); i++)
	{
		if (FindStringExact(-1, rcsaClasses.GetAt(i)) == LB_ERR)
		{
			int nReturn = AddString(rcsaClasses.GetAt(i));
			SetItemData(nReturn,rcbaAbstractClasses.GetAt(i));
		}

	}


}


void CSelectedClasses::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	CFont* pOldFont;


	CDC* pDC = CDC::FromHandle(lpDIS->hDC);


	if (!m_bInit)
	{
		m_bInit = TRUE;
		CFont *pcfCurrent = pDC->GetCurrentFont();
		LOGFONT lfCurrent;
		int nReturn = pcfCurrent->GetLogFont(&lfCurrent);
		lfCurrent.lfWeight = 700;
		m_cfBold.CreateFontIndirect(&lfCurrent);
	}

	CBrowseforInstances *pParent =
		reinterpret_cast<CBrowseforInstances *>
			(GetParent());

	//pParent->ClearAvailSelection();

	int nItem = lpDIS->itemID;

	if (nItem == -1)
	{
		return;
	}


	#pragma warning( disable :4244 )
	BYTE byteFlag = GetItemData(nItem);
	#pragma warning( default : 4244 )


	CString csOut;
	GetText(nItem, csOut);

	if (byteFlag == 1)
	{
		pOldFont = pDC -> SelectObject( &m_cfBold );

	}


	COLORREF cr = (COLORREF)RGB(255, 255, 255);



	RECT rectFill = lpDIS->rcItem;
	rectFill.bottom += 0;

	int nListItem = lpDIS->itemID;
	BOOL bDrawEntireAction = lpDIS->itemAction & ODA_DRAWENTIRE;
	BOOL bSelectAction = lpDIS->itemAction & ODA_SELECT;
	BOOL bFocusAction = lpDIS->itemAction & ODA_FOCUS;
	BOOL bSelectItem = lpDIS->itemState & ODS_SELECTED;
	BOOL bFocusItem = lpDIS->itemState & ODS_FOCUS;

	if (bSelectAction)
	{
		pParent->ClearAvailSelection();
	}


	if (bDrawEntireAction)
	{
		pDC->TextOut(lpDIS->rcItem.left + 3,
			lpDIS->rcItem.top + 1,csOut);
	}

	if ((bSelectAction | bDrawEntireAction) && bSelectItem)
	{
		// Item was selected
		COLORREF crHilite = GetSysColor(COLOR_ACTIVECAPTION);
		CBrush br(crHilite);
		pDC->FillRect(&rectFill, &br);
		pDC->SetBkMode( TRANSPARENT );
		COLORREF crSave = pDC->GetTextColor( );
		pDC->SetTextColor(RGB(255,255,255));
		pDC->TextOut(lpDIS->rcItem.left + 3,
			lpDIS->rcItem.top + 1,csOut);
		pDC->SetTextColor(crSave);
		pDC->SetBkMode( OPAQUE );
	}

	if ((bSelectAction | bDrawEntireAction) && !bSelectItem)

	{
		// Item has been de-selected
		CBrush br(cr);
		pDC->FillRect(&rectFill, &br);
		pDC->TextOut(lpDIS->rcItem.left + 3,
			lpDIS->rcItem.top + 1,csOut);

	}

	if (bFocusAction)
	{
		pDC->DrawFocusRect(&lpDIS->rcItem);
	}



	if (byteFlag == 1)
	{
		pDC -> SelectObject( pOldFont );

	}


}

void CSelectedClasses::MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
{
	// TODO: Add your code to determine the size of specified item
	CBrowseforInstances *pParent =
		reinterpret_cast<CBrowseforInstances *>
			(GetParent());
	TEXTMETRIC *ptmFont = &pParent->m_tmFont;

	lpMeasureItemStruct->itemHeight =
		ptmFont->tmHeight +
		ptmFont->tmDescent ;
}

void CSelectedClasses::CheckClasses()
{
	CBrowseforInstances *pParent =
		reinterpret_cast<CBrowseforInstances *>
			(GetParent());

	int nItems = GetCount();
	CDWordArray cbaIndexes;

	int i;

	for (i = 0; i < nItems; i++)
	{
		CString csItem;
		GetText(i,csItem);
		if (!pParent->IsClassAvailable(csItem))
		{
			cbaIndexes.Add(i);
		}
	}


	for (i = (int)cbaIndexes.GetSize() - 1; i >= 0; i--)
	{
		DeleteString(cbaIndexes.GetAt(i));
	}

}

void CSelectedClasses::OnSetfocus()
{
	// TODO: Add your control notification handler code here
	CBrowseforInstances *pParent =
		reinterpret_cast<CBrowseforInstances *>
			(GetParent());

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\simplesortedcstringarray.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved


#include "precomp.h"
#include "SimpleSortedCStringArray.h"

IMPLEMENT_DYNCREATE(CSortedCStringArray, CObject)

int CSortedCStringArray::GetSize()
{
	return (int)m_csaInternal.GetSize();
}

void CSortedCStringArray::RemoveAll()
{
	m_csaInternal.RemoveAll();
}

void CSortedCStringArray::SetAt(int i, LPCTSTR pcz)
{
	m_csaInternal.SetAt(i,pcz);
}

int CSortedCStringArray::AddString(CString &rcsItem,BOOL bAllowDuplicates)
{
	int nInsertAt = FindFirstGreaterString(rcsItem);

	if (bAllowDuplicates || nInsertAt == 0)
	{
		m_csaInternal.InsertAt(nInsertAt,rcsItem);
		return nInsertAt;
	}
	else
	{
		CString csCompare = m_csaInternal.GetAt(nInsertAt - 1);
		if (!csCompare.CompareNoCase(rcsItem) == 0)
		{
			if (nInsertAt == GetSize())
			{
				m_csaInternal.Add(rcsItem);
			}
			else
			{
				m_csaInternal.InsertAt(nInsertAt,rcsItem);
			}
			return nInsertAt;
		}
		else
		{
			return -1;
		}


	}

}

CString CSortedCStringArray::GetStringAt(int index)
{
	if (index >= 0 &&
		index < GetSize())
	{
		return m_csaInternal.GetAt(index);
	}
	else
	{
		return _T("");
	}

}

int CSortedCStringArray::FindFirstGreaterString(CString &rcsString)
{

	if (m_csaInternal.GetSize() == 0)
	{
		return 0;
	}

	return FindFirstGreaterString(rcsString,0, GetSize() -1);
}

int CSortedCStringArray::FindFirstGreaterString
(CString &rcsInsert,int nBegin, int nEnd)
{

	CString csMid;
	int nCompare;

	if (nEnd <= nBegin)
	{
		int index;

		if (nEnd < 0)
		{
			index = 0;
		}
		else
		{
			index = nEnd;
		}

		csMid = m_csaInternal.GetAt(index);
		nCompare = rcsInsert.CompareNoCase(csMid);
		if (nCompare < 0)
		{
			return max(0,index);
		}
		else
		{
			return index + 1;
		}

	}

	int nMid = ((nEnd - nBegin) / 2) + nBegin;
	csMid = m_csaInternal.GetAt(nMid);

	nCompare = rcsInsert.CompareNoCase(csMid);

	if (nCompare < 0)
	{
		return FindFirstGreaterString(rcsInsert,nBegin , nMid - 1);
	}
	else if (nCompare == 0)
	{
		return FindFirstGreaterString(rcsInsert,nMid + 1, nEnd);
	}
	else
	{
		return FindFirstGreaterString(rcsInsert,nMid + 1, nEnd);
	}

}

int CSortedCStringArray::IndexInArray(CString &rcsItem)
{

	if (GetSize() == 0)
	{
		return -1;
	}

	return IndexInArray(rcsItem,0, GetSize() -1);
}

int CSortedCStringArray::IndexInArray
(CString &rcsTest,int nBegin, int nEnd)
{

	CString csMid;
	int nCompare;

	if (nEnd <= nBegin)
	{
		csMid = m_csaInternal.GetAt(nBegin);
		nCompare = rcsTest.CompareNoCase(csMid);
		if (nCompare == 0)
		{
			return nBegin;
		}
		else
		{
			return -1;
		}

	}

	int nMid = ((nEnd - nBegin) / 2) + nBegin;
	csMid = m_csaInternal.GetAt(nMid);

	nCompare = rcsTest.CompareNoCase(csMid);

	if (nCompare < 0)
	{
		return IndexInArray(rcsTest,nBegin , nMid - 1);
	}
	else if (nCompare == 0)
	{
		return nMid;
	}
	else
	{
		return IndexInArray(rcsTest,nMid + 1, nEnd);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\selectedclasses.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SELECTEDCLASSES_H__14FF6881_D1FB_11D0_9642_00C04FD9B15B__INCLUDED_)
#define AFX_SELECTEDCLASSES_H__14FF6881_D1FB_11D0_9642_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SelectedClasses.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSelectedClasses window

class CSelectedClasses : public CListBox
{
// Construction
public:
	CSelectedClasses();
	void AddClasses
		(CStringArray &rcsaClasses, CByteArray &rcbaAbstractClasses);
	void CheckClasses();
// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectedClasses)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CSelectedClasses();

	// Generated message map functions
protected:
	CFont m_cfBold;
	BOOL m_bInit;
	//{{AFX_MSG(CSelectedClasses)
	afx_msg void OnSetfocus();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELECTEDCLASSES_H__14FF6881_D1FB_11D0_9642_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\instancenav\simplesortedcstringarray.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved


class CSortedCStringArray :public CObject
{
public:
	DECLARE_DYNCREATE(CSortedCStringArray)
		CSortedCStringArray::CSortedCStringArray() {}
	CSortedCStringArray::~CSortedCStringArray() {}
	int AddString(CString &rcsItem,BOOL bDuplicatesAllowed);
	CString GetStringAt(int index);
	int GetSize();
	int IndexInArray(CString &rcsItem);
	void RemoveAll();
	void SetAt(int i, LPCTSTR pcz);
private:
	CStringArray m_csaInternal;
	int FindFirstGreaterString(CString &rcsString);
	int FindFirstGreaterString
		(CString &rcsString,int nBegin, int nEnd);
	int IndexInArray(CString &rcsTest,int nBegin, int nEnd);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\logindlg\credentials.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#pragma once

class CCredentials
{
public:
	CCredentials(LPCTSTR szNamespace)
	{
		m_szNamespace = szNamespace;
		m_dwAuthLevel = RPC_C_AUTHN_LEVEL_CONNECT;
		m_dwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
	}
	CString m_szNamespace;
	CString m_szUser;
	CString m_szUser2;
	CString m_szAuthority;
	DWORD m_dwAuthLevel;
	DWORD m_dwImpLevel;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\logindlg\connectserverthread.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ConnectServerThread.cpp : implementation file
//

#include "precomp.h"
#include "wbemidl.h"
#include "logindlg.h"
#include "ConnectServerThread.h"
#include "Cominit.h"
#include "ServicesList.h"

#ifndef SMSBUILD
#include <cguid.h>
#include <objidl.h>
#endif
#ifdef SMSBUILD
#include <cguid.h>
#include <objidl.h>
#include "GlobalInterfaceTable.h"
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#if 0
// Helper macros we could use
#define MUST_NONNULL(xxx) if(NULL == (xxx)) __leave
#define MUST_SUCCEED(xxx) if(FAILED(xxx)) __leave
#define MUST_BE_TRUE(xxx) if(FALSE == (xxx)) __leave
#endif

extern CLoginDlgApp theApp;

// We need a helper function to allocate the CWinThread since we cannot use
// __try in a function that calls 'new'.  Also, we need to create the thread
// suspended so that we can get it's handle a save a copy
static HANDLE NewThread(AFX_THREADPROC pfnThreadProc, LPVOID pParam)
{
	CWinThread *pThread = new CWinThread(pfnThreadProc, pParam);
	if(!pThread)
		return NULL;

	// Start the thread suspended so we can get the thread handle before
	// it auto-deletes itself
	if(!pThread->CreateThread(CREATE_SUSPENDED))
	{
		delete pThread;
		return NULL;
	}

	HANDLE hThread;
	DuplicateHandle(GetCurrentProcess(), pThread->m_hThread, GetCurrentProcess(), &hThread, 0, FALSE, DUPLICATE_SAME_ACCESS);
	if(NULL == hThread)
	{
		// YIKES - We created the thread, but can't get its handle.  This
		// should NEVER happen.  We can't do anything but leave it around
		// in the suspended state.
		ASSERT(FALSE);
		return NULL;
	}

	// Let the thread start and return its handle
	pThread->ResumeThread();
	return hThread;
}

/////////////////////////////////////////////////////////////////////////////
// CConnectServerThread

HRESULT CConnectServerThread::ConnectServerStart()
{
	HRESULT hr = E_FAIL;
	DWORD dwWaitResult = WAIT_TIMEOUT;
	m_dwMainThread = GetCurrentThreadId();
	__try
	{
		if(NULL == (m_hEventEndThread = CreateEvent(NULL, FALSE, FALSE, NULL))) __leave;
		if(NULL == (m_hEventReadyToCallConnectServer = CreateEvent(NULL, FALSE, FALSE, NULL))) __leave;
		if(NULL == (m_hThread = NewThread(ConnectServerThreadFunctionStatic , (LPVOID)this))) __leave;

		// If we made it to this point, the newly created thread is running.
		// If the thread successfully initalized and is about to call
		// ConnectServer, it will signal m_hEventReadyToCallConnectServer.
		// If something goes wrong, the thread will terminate and store an
		// HRESULT in the exit code.
		// Therefore, we wait for one of two events - the signal that the
		// thread is initialized, or the thread handle telling us that the
		// thread exited because of an error
		HANDLE rgh[2] = {m_hEventReadyToCallConnectServer, m_hThread};
		dwWaitResult = WaitForMultipleObjects(2, rgh, FALSE, INFINITE);
	}
	__finally
	{
		// Always close m_hEventReadyToCallConnectServer - it is no longer needed
		if(m_hEventReadyToCallConnectServer)
		{
			CloseHandle(m_hEventReadyToCallConnectServer);
			m_hEventReadyToCallConnectServer = NULL;
		}

		// See if we initialized, or if there was an error
		switch(dwWaitResult)
		{
		case WAIT_OBJECT_0:
			// The thread was initialzed OK
			hr = S_OK;
			break;
		case (WAIT_OBJECT_0 + 1):
			// The thread ended prematurely - exit code is an HRESULT
			GetExitCodeThread(m_hThread, (LPDWORD)&hr);
			ASSERT(FAILED(hr)); // The thread was supposed to report an error
			// Just in case, make sure we report an error
			if(SUCCEEDED(hr))
				hr = E_FAIL;
			break;
		}

		// Close m_hCancelMutex if we failed
		if(FAILED(hr) && m_hEventEndThread)
		{
			CloseHandle(m_hEventEndThread);
			m_hEventEndThread = NULL;
		}

		// Close the thread handle if we failed
		if(FAILED(hr) && m_hThread)
		{
			CloseHandle(m_hThread);
			m_hThread = NULL;
		}
	}
	return hr;
}

HRESULT CConnectServerThread::ConnectServerEnd(DWORD *pdwCookie)
{
	// This should only be called if the main thread received a success
	// code from ConnectServerStart.  If called before the worker thread
	// has finished, this will cancel the worker thread and return an
	// error code.  If the worker is finished, this function will return
	// the cookie for the new service, or an error code if something went
	// wrong.
	HRESULT hr = E_ABORT;

	ASSERT(m_hThread);
	ASSERT(m_plCancel);
	ASSERT(m_hEventEndThread);

	// Both the worker thread and the main thread try to decrement the value
	// stored in m_plCancel (it initially starts at one).  The first one to
	// decrement it to zero is considered to have 'won the race' - If the main
	// thread wins, the call is considered cancelled, and the worker thread
	// won't register the services pointer in the GIT.  If this happens, this
	// function will return E_ABORT to the user.  If the worker thread wins
	// the race, it means that we must consider the ConnectServer attempt
	// complete, and the worker thread will register the services pointer (or
	// return an error code.
	BOOL bCancelled = (InterlockedDecrement(m_plCancel) == 0);

	// Now that we've checked m_plCancel, we can let the worker thread delete
	// it.  We don't delete it since it was allocated by the worker thread.
	m_plCancel = NULL;

	// Tell the worker thread it can free m_plCancel and terminate
	SetEvent(m_hEventEndThread);

	if(FALSE == bCancelled)
	{
		// We have determined that the worker thread completed the call to
		// ConnectServer.  Wait for it to terminate so we can find out the
		// results of the call.  This should not take very long.
		WaitForSingleObject(m_hThread, INFINITE);

		// The worker thread should return an HRESULT, and put the new cookie in
		// m_dwCookieOut if it was successful
		GetExitCodeThread(m_hThread, (LPDWORD)&hr);
		*pdwCookie = m_dwCookieOut;
	}
	CloseHandle(m_hThread);
	m_hThread = NULL;

	if(m_hEventEndThread)
		CloseHandle(m_hEventEndThread);
	m_hEventEndThread = NULL;

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CConnectServerThread message handlers
UINT CConnectServerThread::ConnectServerThreadFunction()
{
	LPLONG plCancel = NULL;

	HANDLE hEventEndThread = NULL;

	BSTR bstrTemp1 = m_szNamespace.AllocSysString();
	BSTR bstrTemp2 = m_szUser.GetLength() > 0? m_szUser.AllocSysString() : NULL;
	BSTR bstrTemp3 = m_szUser2.GetLength() > 0? m_szUser2.AllocSysString(): NULL;
	BSTR bstrTemp4 = m_szAuthority.GetLength() > 0? m_szAuthority.AllocSysString(): NULL;


	HRESULT hr = E_FAIL, hrCoInit = E_FAIL, hrLocator = E_FAIL, hrConnect = E_FAIL;
	IWbemServices *pSession = NULL;
	IWbemLocator *pLocator = NULL;

	BOOL bNotifyCaller = FALSE;
	__try
	{
		if(NULL == (m_plCancel = plCancel = (LPLONG)HeapAlloc(GetProcessHeap(), 0, sizeof(*plCancel)))) __leave;
		*plCancel = 1;
		if(NULL == DuplicateHandle(GetCurrentProcess(), m_hEventEndThread, GetCurrentProcess(), &hEventEndThread, 0, FALSE, DUPLICATE_SAME_ACCESS)) __leave;

		if(FAILED(hr = hrCoInit = CoInitializeEx(NULL,COINIT_MULTITHREADED))) __leave;
		if(FAILED(hr = hrLocator = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *)&pLocator))) __leave;

		// Tell the main thread that we are about to attempt the call to ConnectServer
		SetEvent(m_hEventReadyToCallConnectServer);
		hr = hrConnect = pLocator->ConnectServer(bstrTemp1,bstrTemp2,bstrTemp3,0,m_lFlags,bstrTemp4,0,&pSession);
		// NOTE: FROM THIS POINT ON, WE CANNOT ACCESS LOCAL VARIABLES UNTIL WE
		// VERIFY THAT WE HAVE NOT BEEN CANCELED BY CHECKING plCancel

	}
	__finally
	{
		if(SUCCEEDED(hrLocator))
		{
			pLocator->Release();
			// We got to the point where ConnectServer was called.  We now need
			// to see if the user has cancelled us
			if(InterlockedDecrement(plCancel) == 0)
			{
				// The user did not cancel us, so we can try to register the
				// services interface, and tell the user that ConnectServer
				// is finished.
				// NOTE: It is OK to access local variables since the user will
				// wait for us after discovering  that plCancel was already set
				// to zero.
				if(SUCCEEDED(hrConnect))
					hr = m_pGIT->RegisterInterfaceInGlobal(pSession, IID_IWbemServices, &m_dwCookieOut);

				// Wait for the main thread to be ready for our posted
				// completion notice
				WaitForSingleObject(m_hEventOkToNotify, INFINITE);
				PostThreadMessage(m_dwMainThread,CONNECT_SERVER_DONE,0,0);
			}
		}

		// NOTE: DON'T TOUCH LOCAL VARIABLES!

		if(SUCCEEDED(hrConnect))
			pSession->Release();
		if(SUCCEEDED(hrCoInit))
			CoUninitialize();
		if(hEventEndThread)
			WaitForSingleObject(hEventEndThread, INFINITE);
		if(plCancel)
			HeapFree(GetProcessHeap(), 0, plCancel);
	}
	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);
	::SysFreeString(bstrTemp3);
	::SysFreeString(bstrTemp4);

	return hr;
}

UINT CConnectServerThread::ConnectServerThreadFunctionStatic(LPVOID pParam)
{
	CConnectServerThread  *pThis = (CConnectServerThread  *)pParam;
	return pThis->ConnectServerThreadFunction();
}

CGITThread::CGITThread()
{
	m_pGIT = NULL;
	m_hEventGITExists = NULL;
	m_hEventEndThread = NULL;
	m_hThread = NULL;
}

CGITThread::~CGITThread()
{
	CleanUp();
}

HRESULT CGITThread::Init()
{
	HRESULT hr = E_FAIL;
	DWORD dwWaitResult = WAIT_TIMEOUT;

	__try
	{
		if(NULL == (m_hEventGITExists = CreateEvent(NULL, FALSE, FALSE, NULL))) __leave;
		if(NULL == (m_hEventEndThread = CreateEvent(NULL, FALSE, FALSE, NULL))) __leave;
		if(NULL == (m_hThread = NewThread(GITThreadFunctionStatic, (LPVOID)this))) __leave;

		// If we made it to this point, the newly created thread is running.
		// If the thread successfully initialized the GIT, it will signal
		// m_hEventGITExists, and then wait around until m_hEventEndThread
		// is singaled. If something goes wrong, the thread will terminate
		// and store an HRESULT in the exit code.
		// Therefore, we wait for one of two events - the signal that the
		// GIT is initialized, or the thread handle telling us that the
		// thread exited because of an error
		HANDLE rgh[2] = {m_hEventGITExists, m_hThread};
		dwWaitResult = WaitForMultipleObjects(2, rgh, FALSE, INFINITE);
	}
	__finally
	{
		// Always close m_hEventGITExists - it is no longer needed
		if(m_hEventGITExists)
		{
			CloseHandle(m_hEventGITExists);
			m_hEventGITExists = NULL;
		}

		// See if we initialized the GIT, or if there was an error
		switch(dwWaitResult)
		{
		case WAIT_OBJECT_0:
			// The GIT was initialzed by the thread
			hr = S_OK;
			break;
		case (WAIT_OBJECT_0 + 1):
			// The thread ended prematurely - exit code is an HRESULT
			GetExitCodeThread(m_hThread, (LPDWORD)&hr);
			ASSERT(FAILED(hr)); // The thread was supposed to report an error
			// Just in case, make sure we report an error
			if(SUCCEEDED(hr))
				hr = E_FAIL;
			break;
		}

		// Close m_hEventEndThread if we failed
		if(FAILED(hr) && m_hEventEndThread)
		{
			CloseHandle(m_hEventEndThread);
			m_hEventEndThread = NULL;
		}

		// Close the thread handle if we failed
		if(FAILED(hr) && m_hThread)
		{
			CloseHandle(m_hThread);
			m_hThread = NULL;
		}
	}
	return hr;
}

void CGITThread::CleanUp()
{
	// m_hEventGITExists should ALWAYS be NULL except while in the middle of the Init function
	ASSERT(NULL == m_hEventGITExists);

	// Let the other thread die
	if(m_hThread)
	{
		ASSERT(m_hEventEndThread);
		SetEvent(m_hEventEndThread);
		WaitForSingleObject(m_hThread, INFINITE);
		CloseHandle(m_hEventEndThread);
		m_hEventEndThread = NULL;
		CloseHandle(m_hThread);
		m_hThread = NULL;
	}
}

UINT CGITThread::GITThreadFunctionStatic(LPVOID pParam)
{
	CGITThread *pThis = (CGITThread *)pParam;
	return pThis->GITThreadFunction();
}

UINT CGITThread::GITThreadFunction()
{
	HRESULT hr = E_FAIL, hrCoInit = E_FAIL, hrCoCreate = E_FAIL;
	__try
	{
		// Set to multi-threaded apartment, and there is only one multithreaded apartment by definition.
		if(FAILED(hr = hrCoInit = CoInitializeEx(NULL,COINIT_MULTITHREADED))) __leave;
		if(FAILED(hr = hrCoCreate = CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (LPVOID *)&m_pGIT))) __leave;
		SetEvent(m_hEventGITExists);
		WaitForSingleObject(m_hEventEndThread,INFINITE);
	}
	__finally
	{
		if(SUCCEEDED(hrCoCreate))
		{
			m_pGIT->Release();
			m_pGIT = NULL;
		}
		if(SUCCEEDED(hrCoInit))
			CoUninitialize();
	}
	return hr;
}

UINT CGITThread::OpenNamespaceThreadFuncStatic(LPVOID pParam)
{
	COpenNamespaceInfo *pInfo = (COpenNamespaceInfo *)pParam;
	return pInfo->OpenNamespaceThreadFunc();
}

UINT CGITThread::COpenNamespaceInfo::OpenNamespaceThreadFunc()
{
	HRESULT hr = E_FAIL, hrCoInit = E_FAIL, hrGetService = E_FAIL, hrOpenNamespace = E_FAIL, hrRegister = E_FAIL;
	BSTR bstrNamespace = NULL;
	IWbemServices *pServices = NULL;
	IWbemServices *pNewServices = NULL;

	__try
	{
		if(NULL == (bstrNamespace = SysAllocString(m_szNamespace))) __leave;

		if(FAILED(hr = hrCoInit = CoInitializeEx(NULL,COINIT_MULTITHREADED))) __leave;

		if(FAILED(hr = theApp.m_pcslServices->GetServicesFromCache(m_szBaseNamespace, &pServices))) __leave;

		if(FAILED(hr = hrOpenNamespace = pServices->OpenNamespace(bstrNamespace, 0, 0, &pNewServices, NULL))) __leave;

		if(FAILED(hr = hrRegister = m_pParent->GetGIT()->RegisterInterfaceInGlobal(pNewServices, IID_IWbemServices, &m_dwCookieOut))) __leave;
	}
	__finally
	{
		if(SUCCEEDED(hrOpenNamespace))
			pNewServices->Release();
		if(SUCCEEDED(hrGetService))
			pServices->Release();
		if(SUCCEEDED(hrCoInit))
			CoUninitialize();
		if(bstrNamespace)
			SysFreeString(bstrNamespace);
	}
	return hr;
}

HRESULT CGITThread::OpenNamespace(LPCTSTR szBaseNamespace, LPCTSTR szNamespace, DWORD *pdwCookieOut)
{
	HRESULT hr = E_FAIL;
	*pdwCookieOut = 0;

	// Using the COpenNamespaceInfo, we provide the helper thread with a
	// relative namespace to open, and the cookie of the base namespace services
	// pointer. The thread will put the cookie of the new services pointer in
	// the info object.
	COpenNamespaceInfo info(this, szBaseNamespace, szNamespace);

	// Helper thread that puts a new services pointer in the GIT
	CWinThread thread(OpenNamespaceThreadFuncStatic, (LPVOID)&info);

	// Don't autodelete since this object is on the stack
	thread.m_bAutoDelete = FALSE;

	if(thread.CreateThread())
	{
		// The helper thread is running - Wait for it to finish
		WaitForSingleObject(thread.m_hThread, INFINITE);

		// The thread exit code is an HRESULT
		GetExitCodeThread(thread.m_hThread, (LPDWORD)&hr);

		// The cookie is stored in the 'info' object
		*pdwCookieOut = info.GetCookieOut();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\logindlg\connectserverthread.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_CONNECTSERVERTHREAD_H__40D209F2_6B56_11D1_9661_00C04FD9B15B__INCLUDED_)
#define AFX_CONNECTSERVERTHREAD_H__40D209F2_6B56_11D1_9661_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ConnectServerThread.h : header file
//
#define CONNECT_SERVER_DONE WM_USER + 146

/////////////////////////////////////////////////////////////////////////////
// CConnectServerThread thread

#include "Credentials.h"

class CConnectServerThread
{
public:
	CConnectServerThread(const CCredentials *pCreds, long lFlags, IGlobalInterfaceTable *pGIT, HANDLE hEventOkToNotify)
	{
		m_hEventOkToNotify = hEventOkToNotify;
		m_szNamespace = pCreds->m_szNamespace;
		m_szUser = pCreds->m_szUser;
		m_szUser2 = pCreds->m_szUser2;
		m_szAuthority = pCreds->m_szAuthority;
		m_lFlags = lFlags;
		m_pGIT = pGIT;

		m_dwMainThread = 0;
		m_dwCookieOut = 0;

		m_hEventReadyToCallConnectServer = NULL;
		m_hEventEndThread = NULL;
		m_hThread = NULL;
		m_plCancel = NULL;
	}
	~CConnectServerThread()
	{
		// There should be no cleanup needed if called correctly
		ASSERT(!m_hEventReadyToCallConnectServer);
		ASSERT(!m_hEventEndThread);
		ASSERT(!m_hThread);
		ASSERT(!m_plCancel);
	}

	HRESULT ConnectServerStart();
	HRESULT ConnectServerEnd(DWORD *pdwCookie);

protected:
	// These are values passed to the worker thread
	CString m_szNamespace;
	CString m_szUser;
	CString m_szUser2;
	CString m_szAuthority;
	long m_lFlags;
	IGlobalInterfaceTable *m_pGIT;
	HANDLE m_hEventOkToNotify;

protected:
	// These are values returned from the worker thread
	DWORD m_dwCookieOut;

protected:
	UINT ConnectServerThreadFunction();
	static UINT ConnectServerThreadFunctionStatic(LPVOID pParam);
	void CleanupWorker();

protected:
	DWORD m_dwMainThread;
	LPLONG m_plCancel;
	HANDLE m_hEventReadyToCallConnectServer;
	HANDLE m_hEventEndThread;
	HANDLE m_hThread;
};


class CGITThread
{
public:
	// The following five methods must all be called by the same thread
	CGITThread();
	~CGITThread();
	HRESULT Init();
	IGlobalInterfaceTable *GetGIT() {return m_pGIT;}
	void CleanUp();

	// OpenNamespace helper object that gets passed to helper thread
	class COpenNamespaceInfo
	{
	public:
		COpenNamespaceInfo(CGITThread *pParent, LPCWSTR szBaseNamespace, LPCWSTR szNamespace)
		{
			m_pParent = pParent;
			m_szNamespace = szNamespace;
			m_szBaseNamespace = szBaseNamespace;
			m_dwCookieOut = 0;
		}
		DWORD GetCookieOut()
		{
			return m_dwCookieOut;
		}
		UINT OpenNamespaceThreadFunc();

	protected:
		CGITThread *m_pParent;
		LPCWSTR m_szNamespace;
		LPCWSTR m_szBaseNamespace;

		DWORD m_dwCookieOut;
	};
	HRESULT OpenNamespace(LPCTSTR szBaseNamespace, LPCTSTR szNamespace, DWORD *pdwCookieOut);

//	HRESULT RegisterServicesPtr(IWbemServices *pServices, LPCTSTR szUser, LPCTSTR szPassword, LPCTSTR szAuthority, DWORD *pdwCookieOut);

protected:
	static UINT GITThreadFunctionStatic(LPVOID pParam);
	UINT GITThreadFunction();

	static UINT OpenNamespaceThreadFuncStatic(LPVOID pParam);

protected:
	IGlobalInterfaceTable *m_pGIT;
	HANDLE m_hEventGITExists;
	HANDLE m_hEventEndThread;
	HANDLE m_hThread;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONNECTSERVERTHREAD_H__40D209F2_6B56_11D1_9661_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\logindlg\globalinterfacetable.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __IGlobalInterfaceTable_INTERFACE_DEFINED__
#define __IGlobalInterfaceTable_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGlobalInterfaceTable
 * at Thu Sep 11 10:57:04 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [uuid][object][local] */ 

#ifndef __IGlobalInterfaceTable_FWD_DEFINED__
#define __IGlobalInterfaceTable_FWD_DEFINED__
typedef interface IGlobalInterfaceTable IGlobalInterfaceTable;
#endif 	/* __IGlobalInterfaceTable_FWD_DEFINED__ */


EXTERN_C  const CLSID CLSID_StdGlobalInterfaceTable;

//DEFINE_GUID(CLSID_StdGlobalInterfaceTable,0x00000323L,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

//	CLSID_StdGlobalInterfaceTable	{00000323-0000- 0000- C0 00-000000000046}


typedef /* [unique] */ IGlobalInterfaceTable __RPC_FAR *LPGLOBALINTERFACETABLE;


EXTERN_C const IID IID_IGlobalInterfaceTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000146-0000-0000-C000-000000000046")
    IGlobalInterfaceTable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterInterfaceInGlobal( 
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RevokeInterfaceFromGlobal( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfaceFromGlobal( 
            /* [in] */ DWORD dwCookie,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGlobalInterfaceTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGlobalInterfaceTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGlobalInterfaceTable __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGlobalInterfaceTable __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterInterfaceInGlobal )( 
            IGlobalInterfaceTable __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RevokeInterfaceFromGlobal )( 
            IGlobalInterfaceTable __RPC_FAR * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfaceFromGlobal )( 
            IGlobalInterfaceTable __RPC_FAR * This,
            /* [in] */ DWORD dwCookie,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        END_INTERFACE
    } IGlobalInterfaceTableVtbl;

    interface IGlobalInterfaceTable
    {
        CONST_VTBL struct IGlobalInterfaceTableVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGlobalInterfaceTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGlobalInterfaceTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGlobalInterfaceTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGlobalInterfaceTable_RegisterInterfaceInGlobal(This,pUnk,riid,pdwCookie)	\
    (This)->lpVtbl -> RegisterInterfaceInGlobal(This,pUnk,riid,pdwCookie)

#define IGlobalInterfaceTable_RevokeInterfaceFromGlobal(This,dwCookie)	\
    (This)->lpVtbl -> RevokeInterfaceFromGlobal(This,dwCookie)

#define IGlobalInterfaceTable_GetInterfaceFromGlobal(This,dwCookie,riid,ppv)	\
    (This)->lpVtbl -> GetInterfaceFromGlobal(This,dwCookie,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */




HRESULT STDMETHODCALLTYPE IGlobalInterfaceTable_RegisterInterfaceInGlobal_Proxy( 
    IGlobalInterfaceTable __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk,
    /* [in] */ REFIID riid,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IGlobalInterfaceTable_RegisterInterfaceInGlobal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGlobalInterfaceTable_RevokeInterfaceFromGlobal_Proxy( 
    IGlobalInterfaceTable __RPC_FAR * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IGlobalInterfaceTable_RevokeInterfaceFromGlobal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGlobalInterfaceTable_GetInterfaceFromGlobal_Proxy( 
    IGlobalInterfaceTable __RPC_FAR * This,
    /* [in] */ DWORD dwCookie,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IGlobalInterfaceTable_GetInterfaceFromGlobal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGlobalInterfaceTable_INTERFACE_DEFINED__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\logindlg\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LoginDlg.rc
//
#define IDC_ENABLEPRIVILEGES            216
#define IDC_EDITUSERNAME                9000
#define IDC_EDITPASSWORD                9001
#define IDC_EDITAUTHORITY               9002
#define IDC_EDITDOMAIN                  9004
#define CG_IDC_PROGDLG_STATUS           9005
#define IDC_RADIONTLM                   9006
#define IDC_RADIOWBEM                   9007
#define IDC_RADIOCURRENTUSER            9008
#define IDC_STATICDOMAIN                9009
#define IDC_BUTTONHELP                  9010
#define IDC_BUTTONOPTIONS               9011
#define IDC_CHECKCURRENTUSER            9015
#define IDC_COMBOIMP                    9016
#define IDC_COMBOAUTH                   9017
#define IDC_STATICIMPLEVEL              9018
#define IDC_STATICAUTLEVEL              9019
#define IDC_CHECK_ENABLE_PRIVILEDGES    9020
#define IDC_STATICAUTHORITY             9021
#define CG_IDD_PROGRESS                 9102
#define CG_IDS_PROGRESS_CAPTION         9103
#define IDD_DIALOGLOGIN                 9129

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        9130
#define _APS_NEXT_COMMAND_VALUE         30771
#define _APS_NEXT_CONTROL_VALUE         9022
#define _APS_NEXT_SYMED_VALUE           9104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\logindlg\progdlg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//  ProgDlg.cpp : implementation file
// CG: This file was added by the Progress Dialog component

#include "precomp.h"
#include "resource.h"
#include "ProgDlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

void MoveWindowToLowerLeftOfOwner(CWnd *pWnd)
{
	if (!pWnd)
		return;

	CWnd *pOwner = pWnd->GetOwner();

	if (!pOwner)
		return;

	RECT rectOwner;
	pOwner->GetClientRect(&rectOwner);
	pOwner->ClientToScreen(&rectOwner);

	RECT rect;
	pWnd->GetClientRect(&rect);
	pWnd->ClientToScreen(&rect);

	RECT rectMove;
	rectMove.left = rectOwner.left;
	rectMove.bottom = rectOwner.bottom;
	rectMove.right = rectOwner.left + (rect.right - rect.left);
	rectMove.top = rectOwner.top + (rectOwner.bottom - rect.bottom);
	pWnd->MoveWindow(&rectMove,TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog

CProgressDlg::CProgressDlg(CWnd* pParent, LPCTSTR szMachine, LPCTSTR szUser, HANDLE hEventOkToNotify)
	: CDialog(CProgressDlg::IDD, pParent)
{
	m_csMachine = szMachine;
	m_csUser = szUser;
	m_hEventOkToNotify = hEventOkToNotify;
}

CProgressDlg::~CProgressDlg()
{
}

void CProgressDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProgressDlg)
	DDX_Control(pDX, IDCANCEL, m_cbCancel);
	DDX_Control(pDX, CG_IDC_PROGDLG_STATUS, m_cstaticMessage);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CProgressDlg, CDialog)
    //{{AFX_MSG_MAP(CProgressDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg message handlers

BOOL CProgressDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	CString csMessage;
	SetWindowText(_T("Connecting to server:"));
	csMessage = _T("Attempting connection to \"");
	csMessage += m_csMachine;
	csMessage += _T("\" as ");
	if (m_csUser.GetLength() == 0)
	{
		csMessage += _T("current user.");
	}
	else
	{
		csMessage += _T("\"");
		csMessage += m_csUser;
		csMessage += _T("\".");
	}

	m_cstaticMessage.SetWindowText(csMessage);
	MoveWindowToLowerLeftOfOwner(this);

	// Let the worker thread know that the dialog has been created
	SetEvent(m_hEventOkToNotify);

	return TRUE;
}

void CProgressDlg::OnCancel()
{
	CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\logindlg\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__347E34B7_E42E_11D0_9644_00C04FD9B15B__INCLUDED_)
#define AFX_STDAFX_H__347E34B7_E42E_11D0_9644_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers


#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions


#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <process.h>
#include <afxmt.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__347E34B7_E42E_11D0_9644_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\logindlg\logindlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// LoginDlg.h : main header file for the LOGINDLG DLL
//

#if !defined(AFX_LOGINDLG_H__347E34B5_E42E_11D0_9644_00C04FD9B15B__INCLUDED_)
#define AFX_LOGINDLG_H__347E34B5_E42E_11D0_9644_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef BUILDING_LOGINDLG_DLL
#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols
#endif

#ifdef BUILDING_LOGINDLG_DLL
#define LOGINDLG_POLARITY __declspec(dllexport)
#else
#define LOGINDLG_POLARITY __declspec(dllimport)
#endif

extern LOGINDLG_POLARITY LONG PASCAL EXPORT GetServicesWithLogonUI(HWND hwndParent, BSTR bstrNamespace, BOOL bUpdatePointer, IWbemServices *&pServices, BSTR bstrLoginComponent);

extern LOGINDLG_POLARITY LONG PASCAL EXPORT OpenNamespace(LPCTSTR szBaseNamespace, LPCTSTR szRelativeChild, IWbemServices **ppServices);

extern LOGINDLG_POLARITY VOID PASCAL EXPORT ClearIWbemServices();

extern LOGINDLG_POLARITY LONG PASCAL EXPORT SetEnumInterfaceSecurity
(CString &rcsNamespace, IEnumWbemClassObject *pEnum, IWbemServices* psvcFrom);

extern LOGINDLG_POLARITY ULONG PASCAL EXPORT DllAddRef();

extern LOGINDLG_POLARITY ULONG PASCAL EXPORT DllRelease();

extern LOGINDLG_POLARITY BOOL PASCAL EXPORT LoginAllPrivileges(BOOL bEnable);

#ifdef BUILDING_LOGINDLG_DLL
/////////////////////////////////////////////////////////////////////////////
// CLoginDlgApp
// See LoginDlg.cpp for the implementation of this class
//

class CLoginDlg;
class CLoginDlgApp;
class CProgressDlg;
class CServicesList;
class CConnectServerThread;

extern void ErrorMsg(LPCTSTR szUserMsg, SCODE sc);

#include "Credentials.h"

class CLoginDlgApp : public CWinApp
{
public:
	CLoginDlgApp();
	CServicesList *m_pcslServices;
	ULONG AppDllAddRef();
	ULONG AppDllRelease();
	CCriticalSection m_CriticalSection;
	CCriticalSection m_DllRefCountCriticalSection;

	HWND m_hwndParent;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLoginDlgApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CLoginDlgApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	afx_msg void ConnectServerDone(WPARAM, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
protected:
	ULONG m_lRef;
};


/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CLoginDlg dialog

class CLoginDlg : public CDialog
{
// Construction
public:
	CLoginDlg(CWnd* pParent, CCredentials *pCreds, LPCTSTR szMachine, LPCTSTR szLoginComponent);

	BOOL m_bCurrentUser;
// Dialog Data
	//{{AFX_DATA(CLoginDlg)
	enum { IDD = IDD_DIALOGLOGIN };
	CButton	m_EnablePrivilegesCtl;
	CEdit	m_ceAuthority;
	CStatic	m_cstaticAuthority;
	CButton	m_cbOK;
	CButton	m_cbCancel;
	CButton	m_cbHelp;
	CButton	m_cbOptions;
	CStatic	m_cstaticImpLevel;
	CStatic	m_cstaticAuthLevel;
	CComboBox	m_cboxImp;
	CComboBox	m_cboxAuth;
	CButton	m_pbCurrentUser;
	CEdit	m_ceUser;
	CEdit	m_cePassword;
	BOOL	m_bEnablePrivileges;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLoginDlg)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CCredentials *m_pCreds;

	CString m_csMachine;
	CString m_szLoginComponent;
	CString GetSDKDirectory();
	void InvokeHelp();
	void SetOptionsConfiguration();
	void OptionsVisible(BOOL bVisible);
	void SetButtonPositions();
	BOOL m_bOptions;
	int m_nOKTop;
	CRect m_crectOriginalScreen;
	CRect m_crectOriginalClient;
	CRect m_crectCurrent;

	// Generated message map functions
	//{{AFX_MSG(CLoginDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	virtual void OnOK();
	afx_msg void OnButtonhelp();
	virtual void OnCancel();
	afx_msg void OnCheckcurrentuser();
	afx_msg void OnButtonoptions();
	afx_msg void OnEnableprivileges();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_LOGINDLG_H__347E34B5_E42E_11D0_9644_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\logindlg\serviceslist.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
// need -D_WIN32_WINNT=0x0400 defined in CFLAGS

#ifndef SMSBUILD
#include <cguid.h>
#include <objidl.h>
#endif
#ifdef SMSBUILD
#include <cguid.h>
#include <objidl.h>
#include "GlobalInterfaceTable.h"
#endif

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <nddeapi.h>
#include <initguid.h>
#include "resource.h"
#include "wbemidl.h"
#include "ProgDlg.h"
#include "ServicesList.h"
#include "LoginDlg.h"
#include "ConnectServerThread.h"
#include "cominit.h"



extern CLoginDlgApp theApp;

CString GetMachineName()
{
	char ThisMachineA[MAX_COMPUTERNAME_LENGTH+1];
	DWORD dwSize = sizeof(ThisMachineA);
	GetComputerNameA(ThisMachineA, &dwSize);
	CString csMachine = ThisMachineA;
	return csMachine;
}

CNamespace::CNamespace(LPCTSTR pszNamespace)
{
	SetNamespace(pszNamespace);
}

CNamespace::~CNamespace()
{
	m_csMachine.Empty();
	m_csaNamespaceConstituents.RemoveAll();
}

void CNamespace::SetNamespace(LPCTSTR sz)
{
	CString szNamespace(sz);

	m_csMachine.Empty();
	m_csaNamespaceConstituents.RemoveAll();

	int nLen = szNamespace.GetLength();
	if (nLen == 0)
		return;

	int i;
	int nBegin;
	if(szNamespace.Left(4) == "\\\\.\\")
	{
		m_csMachine = GetMachineName();
		nBegin = 4;
	}
	else if(szNamespace.Left(2) == "\\\\")
	{
		nBegin = 2;
		for (i = nBegin; i < nLen; i++)
		{
			if (szNamespace[i] == '\\')
			{
				m_csMachine = szNamespace.Mid(nBegin, i - nBegin);
				nBegin = i + 1;
				break;
			}
		}
		if (m_csMachine.GetLength() == 0)
		{
			m_csMachine = szNamespace.Mid(2,nLen - 1);
			nBegin = nLen;
		}
	}
	else
	{
 		m_csMachine = GetMachineName();
		nBegin = 0;
	}
	for (i = nBegin; i < nLen; i++)
	{
		if (szNamespace[i] == '\\' || i == nLen - 1)
		{
			m_csaNamespaceConstituents.Add(szNamespace.Mid(nBegin, i == nLen - 1 ? (i + 1) - nBegin : i - nBegin));
			nBegin = i + 1;
		}
	}
}

CString CNamespace::GetNamespace()
{
	CString csReturn = _T("\\\\");
	csReturn += m_csMachine;
	int nLen =  (int) m_csaNamespaceConstituents.GetSize();
	for (int i = 0; i < nLen; i++)
	{
		csReturn += _T("\\");
		csReturn += m_csaNamespaceConstituents.GetAt(i);
	}
	return csReturn;
}

int CNamespace::IsRoot()
{
	if (m_csaNamespaceConstituents.GetSize() == 1)
	{
		CString csNamespace =
			m_csaNamespaceConstituents.GetAt(0);
		return csNamespace.CompareNoCase(_T("root")) == 0;
	}
	else
	{
		return FALSE;
	}
}


CString CNamespace::GetRelNamespace(LPCTSTR szRelTo)
{

	CString csReturn;
	int i = 0;
	int nLen = (int) m_csaNamespaceConstituents.GetSize();

	if (nLen == 0)
		return _T("");

	CString csTmp = m_csaNamespaceConstituents.GetAt(i);
	if (csTmp.CompareNoCase(szRelTo) == 0)
	{
		i = 1;
	}

	for (; i < nLen; i++)
	{
		csReturn  += m_csaNamespaceConstituents.GetAt(i);
		if (i != nLen - 1)
		{
			csReturn += _T("\\");
		}
	}

	return csReturn;

}

CServicesNode::CServicesNode(const CString &rcsDomainAndUser, const CString &rcsNamespace, const CString &rcsPassword, DWORD dwCookie, DWORD dwAuthLevel, DWORD dwImpLevel)
{
	m_csDomainAndUser = rcsDomainAndUser;
	m_csUser2 = rcsPassword;
	m_dwAuthLevel = dwAuthLevel;
	m_dwImpLevel = dwImpLevel;
	m_dwCookie = dwCookie;

	int nDelimiter = rcsDomainAndUser.Find('\\');
	if (nDelimiter != -1)
	{
		m_csDomain = rcsDomainAndUser.Left(nDelimiter);
		int nUserLen = rcsDomainAndUser.GetLength() - (nDelimiter + 1);
		if (nUserLen > 0)
		{
			m_csUser = rcsDomainAndUser.Right(nUserLen);
		}

	}
	else
		m_csUser = rcsDomainAndUser;

	CNamespace cnNamespace(rcsNamespace);
	m_csNamespace = cnNamespace.GetNamespace();
	m_csMachine = cnNamespace.m_csMachine;
}

CServicesList::CServicesList()
{
	m_pGIT = NULL;
	m_pProgress = NULL;
}

CServicesList::~CServicesList()
{
}

void CServicesList::ClearGlobalInterfaceTable()
{
	ClearServicesList();
	m_GITMgr.CleanUp();
}

void CServicesList::ClearServicesList()
{
	int i;
	int n = (int) m_cpaServices.GetSize();
	for (i = 0; i < n; i++)
	{
		CServicesNode *pcsnService = (CServicesNode *)m_cpaServices.GetAt(i);
		if (pcsnService && pcsnService->m_dwCookie)
			m_pGIT->RevokeInterfaceFromGlobal(pcsnService->m_dwCookie);

		delete pcsnService;
	}
	m_cpaServices.RemoveAll();
}


HRESULT CServicesList::GetServices(LPCTSTR szNamespaceInput, BOOL bUpdatePointer, IWbemServices **ppNewServices)
{
	HRESULT hr = E_FAIL;

	CNamespace cnNamespace(szNamespaceInput);
	CString szNamespace = cnNamespace.GetNamespace();

	CServicesNode *pNode = GetServicesNode(szNamespace);

	// If we want to update the pointer, remove it if we have it.  Otherwise,
	// see if we already have it and just return it
	if(bUpdatePointer && pNode)
		RemoveServiceNodes(szNamespace);
	else if(pNode)
		return GetServicesFromCache(pNode, ppNewServices);

	// Loop until we succeed or abort
	do
	{
		CCredentials creds(szNamespace);
		CLoginDlg dlg(CWnd::FromHandle(theApp.m_hwndParent), &creds, cnNamespace.m_csMachine, m_szDialogTitle);
		if(IDOK == dlg.DoModal())
		{
			hr = TryToConnect(&creds, ppNewServices);
			if(FAILED(hr) && hr != E_ABORT)
			{
				CString csUserMsg = _T("Login failed to machine \"") + cnNamespace.m_csMachine + _T("\".");
				ErrorMsg(csUserMsg, hr);
			}
		}
		else
			hr = E_ABORT;
	} while(FAILED(hr) && hr != E_ABORT);
	return hr;
}

HRESULT CServicesList::TryToConnect(const CCredentials *pCreds, IWbemServices **ppServices)
{
	HRESULT hr = E_FAIL;
	DWORD dwCookie = 0;

	if(NULL == m_GITMgr.GetGIT())
	{
		hr = m_GITMgr.Init();
		ASSERT(SUCCEEDED(hr));
		if(!SUCCEEDED(hr))
			return hr;
		m_pGIT = m_GITMgr.GetGIT();
	}

	// The dialog will signal this event when it is initialized.  The worker
	// thread will not post us a complete message until the dialog has been created.
	HANDLE hEventOkToNotify = CreateEvent(NULL, FALSE, FALSE, NULL);

	CConnectServerThread thread(pCreds, 0, m_pGIT, hEventOkToNotify);

	// Try to start up the worker thread
	if(hEventOkToNotify && SUCCEEDED(hr = thread.ConnectServerStart()))
	{
		// Show a progress dialog
		m_pProgress = new CProgressDlg(CWnd::FromHandle(theApp.m_hwndParent), pCreds->m_szNamespace, pCreds->m_szUser, hEventOkToNotify);
		m_pProgress->DoModal();
		delete m_pProgress;

		// Just in case the progress dialog did not set the hEventOkToNotify
		// event, we'll set it.  Otherwise, the worker thread may never exit.
		SetEvent(hEventOkToNotify);

		m_pProgress = NULL;

		// The progress dialog was either dismissed by the user, or the worker
		// thread completed.  In either case, we call the worker thread to see
		// if it is done.  If the worker thead is not yet complete, this will
		// end up cancelling the request (and it will return E_ABORT).
		// Otherwise, we'll end up with a valid cookie, or an HRESULT indicating
		// what went wrong.
		// In other words - there are three possilbe results from GetCookie
		// 1) It returns SUCCESS  - In this case, the worker was finished, and
		//    we have a valid cookie
		// 2) It returns E_ABORT - In this case, the thread was not yet
		//    finished with its call to ConnectServer.  This will only happens
		//    if the user cancelled the progress dialog
		// 3) It returns some other error code - The worker thread was not able
		//    to get a service pointer registered into the GIT
		hr = thread.ConnectServerEnd(&dwCookie);

		// We can close hEventOkToNotify since the worker thread has either
		// finished, or we've cancelled it and it won't be checking the event
		CloseHandle(hEventOkToNotify);
		hEventOkToNotify = NULL;
	}

	if(FAILED(hr))
		return hr;

	CServicesNode *pcsnService = new CServicesNode(pCreds->m_szUser, pCreds->m_szNamespace, pCreds->m_szUser2, dwCookie, pCreds->m_dwAuthLevel, pCreds->m_dwImpLevel);
	// MAKE SURE THIS SUCCEEDES
	ASSERT(pcsnService);

	m_cpaServices.Add(pcsnService);
	return GetServicesFromCache(pcsnService, ppServices);
}


//////////////////////////////////////////////////////////////////////////////////////
// Helper functions

CServicesNode *CServicesList::GetServicesNode(LPCTSTR szNamespace)
{
	int i;
	for (i = 0; i < m_cpaServices.GetSize(); i++)
	{
		CServicesNode *pcsnService = (CServicesNode *)m_cpaServices.GetAt(i);
		if (pcsnService->m_csNamespace.CompareNoCase(szNamespace) == 0)
			return pcsnService;
	}
	return NULL;
}

HRESULT CServicesList::GetServicesFromCache(CServicesNode *pNode, IWbemServices **ppServices)
{
	HRESULT hr = m_pGIT->GetInterfaceFromGlobal(pNode->m_dwCookie, IID_IWbemServices, (LPVOID *)ppServices);
	if (SUCCEEDED(hr))
		return pNode->SetInterfaceSecurity(*ppServices);
	return hr;
}

void CServicesList::RemoveServiceNodes(LPCTSTR szNamespace)
{
	INT_PTR i;
	for (i = m_cpaServices.GetSize() - 1;i>=0; i--)
	{
		CServicesNode *pcsnService = (CServicesNode *)m_cpaServices.GetAt(i);
		if (pcsnService->m_csNamespace.CompareNoCase(szNamespace) == 0)
		{
			if (pcsnService && pcsnService->m_dwCookie)
				m_pGIT->RevokeInterfaceFromGlobal(pcsnService->m_dwCookie);
			delete pcsnService;
			m_cpaServices.RemoveAt(i);
		}
	}
}

HRESULT CServicesList::OpenNamespace(LPCTSTR szBaseNamespace, LPCTSTR szRelativeChild, IWbemServices **ppServices)
{
	HRESULT hr = E_FAIL;
	DWORD dwCookieChild;
	if(FAILED(hr = m_GITMgr.OpenNamespace(szBaseNamespace, szRelativeChild, &dwCookieChild)))
		return hr;

	hr = m_pGIT->GetInterfaceFromGlobal(dwCookieChild, IID_IWbemServices, (LPVOID *)ppServices);

	// Always revoke namespace opened with 'opennamespace' from GIT - we don't cache these
	m_pGIT->RevokeInterfaceFromGlobal(dwCookieChild);

	// If we got the interface, set it's security based on the credentials used to get
	// the original namespace
	if (SUCCEEDED(hr))
		hr = SetInterfaceSecurityFromCache(szBaseNamespace, *ppServices);

	return hr;
}

void CServicesList::OnConnectServerDone(WPARAM wParam, LPARAM lParam)
{
	if(m_pProgress)
		m_pProgress->EndDialog(IDOK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\logindlg\logindlg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// LoginDlg.cpp : Defines the initialization routines for the DLL.
//

#include "precomp.h"
#include "wbemidl.h"
#include "ServicesList.h"
#include "LoginDlg.h"
#include "ProgDlg.h"
#include "ConnectServerThread.h"
#include "htmlhelp.h"
#include "HTMTopics.h"
#ifndef SMSBUILD
#include <cguid.h>
#include <objidl.h>
#endif
#ifdef SMSBUILD
#include <cguid.h>
#include <objidl.h>
#include "GlobalInterfaceTable.h"
#endif

#include "MsgDlgExterns.h"
#include "WbemRegistry.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// The one and only CLoginDlgApp object

CLoginDlgApp theApp;

void ErrorMsg(LPCTSTR szUserMsg, SCODE sc)
{
	CString csCaption = _T("WMI Login Message");
	CString csUserMsg(szUserMsg);
	BOOL bErrorObject = sc != S_OK;
	BSTR bstrTemp1 = csCaption.AllocSysString();
	BSTR bstrTemp2 = csUserMsg.AllocSysString();
	DisplayUserMessage(bstrTemp1,bstrTemp2, sc,bErrorObject,MB_ICONEXCLAMATION, theApp.m_hwndParent);
	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);
}


//#define GROW_FACTOR 0.395			// Increase this to shrink dialog when not displaying options.
#define GROW_FACTOR 0.46			// Increase this to shrink dialog when not displaying options.
#define BUTTON_MARGIN_ADJUST 0.04	// Increase this to increase margin below buttons


//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//



////////////////////////////////////////////////////////////////////////////
// CLoginDlgApp

#ifdef SMSBUILD
const IID BASED_CODE CLSID_StdGlobalInterfaceTable =
		{ 0x00000323, 0x000, 0x0000, { 0xc0, 0x00, 0, 0x00,  0, 0x00, 0x0, 0x46 }};
extern const IID BASED_CODE IID_IGlobalInterfaceTable;/* =
		{ 0x00000146, 0x000, 0x0000, { 0xc0, 0x00, 0, 0x00,  0, 0x00, 0x0, 0x46 } };*/
#endif




BEGIN_MESSAGE_MAP(CLoginDlgApp, CWinApp)
	//{{AFX_MSG_MAP(CLoginDlgApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	ON_THREAD_MESSAGE(CONNECT_SERVER_DONE,ConnectServerDone)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CLoginDlgApp construction

CLoginDlgApp::CLoginDlgApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
	m_lRef = 0;
	m_hwndParent = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CLoginDlg dialog
extern ULONG PASCAL EXPORT DllAddRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return theApp.AppDllAddRef();
}

extern ULONG PASCAL EXPORT DllRelease()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return theApp.AppDllRelease();
}


extern LONG PASCAL EXPORT GetServicesWithLogonUI(HWND hwndParent, BSTR bstrNamespace, BOOL bUpdatePointer, IWbemServices *&pServices, BSTR bstrLoginComponent)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	theApp.m_hwndParent = hwndParent;

	CString csNamespace = bstrNamespace;
	theApp.m_pcslServices->m_szDialogTitle = bstrLoginComponent;

	theApp.m_CriticalSection.Lock();
	HRESULT hr = theApp.m_pcslServices->GetServices(csNamespace, bUpdatePointer, &pServices);
	theApp.m_CriticalSection.Unlock();

	theApp.m_hwndParent = NULL;
	return hr;
}

extern LONG PASCAL EXPORT OpenNamespace(LPCTSTR szBaseNamespace, LPCTSTR szRelativeChild, IWbemServices **ppServices)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	theApp.m_CriticalSection.Lock();
	HRESULT hr = theApp.m_pcslServices->OpenNamespace(szBaseNamespace, szRelativeChild, ppServices);

	if(FAILED(hr))
	{
		CString csErrorAsHex;
		csErrorAsHex.Format(_T("0x%x"), hr);
		CString csUserMsg;
		csUserMsg =  _T("CServicesList::OpenNamespace:  call failed with error code ");
		csUserMsg += csErrorAsHex + _T(".");
		ErrorMsg(csUserMsg, S_OK);
	}

	theApp.m_CriticalSection.Unlock();

	return hr;
}

extern VOID PASCAL EXPORT ClearIWbemServices
()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	theApp.m_CriticalSection.Lock();
	theApp.m_pcslServices->ClearServicesList();
	theApp.m_CriticalSection.Unlock();
}

// You need to call this for all IEnumWbemClassObject pointers you get yourself
// (the pointers you get from the DLL are already configured for security)
// and for all IEnumWbemClassObject pointers.
extern LONG PASCAL EXPORT SetEnumInterfaceSecurity(CString &rcsNamespace, IEnumWbemClassObject  *pEnum, IWbemServices* psvcFrom)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SCODE sc = theApp.m_pcslServices->SetInterfaceSecurityFromCache(rcsNamespace, pEnum);
	if(FAILED(sc) && rcsNamespace.Left(2) != _T("\\\\"))
	{
		CString csMachine = GetMachineName();
		CString csNamespace2 = _T("\\\\") + csMachine + _T("\\") + rcsNamespace;
		sc = theApp.m_pcslServices->SetInterfaceSecurityFromCache(csNamespace2, pEnum);
	}

	return sc;

}


extern BOOL PASCAL EXPORT LoginAllPrivileges(BOOL bEnable)
{
	BOOL bOk = FALSE;
	BOOL bAllEnabled = TRUE;
	HANDLE hToken = NULL;
    BYTE* pBuffer = NULL;
	__try
	{
		// Try the thread token and then the process token if there is no thread token
		if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | (bEnable?TOKEN_ADJUST_PRIVILEGES:0), TRUE, &hToken))
		{
			if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | (bEnable?TOKEN_ADJUST_PRIVILEGES:0), &hToken)) __leave;
		}

		// Get size of privilege information
		DWORD dwLen = 0;
		TOKEN_USER tu;
		memset(&tu,0,sizeof(TOKEN_USER));
		GetTokenInformation(hToken, TokenPrivileges, &tu, sizeof(TOKEN_USER), &dwLen);

		if(0 == dwLen) __leave;

		// Allocate buffer for provileges
		if(NULL == (pBuffer = new BYTE[dwLen])) __leave;

		// Get the info
		if(!GetTokenInformation(hToken, TokenPrivileges, pBuffer, dwLen, &dwLen)) __leave;

		// Iterate through all the privileges and enable them all
		TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
		for(DWORD i = 0; i < pPrivs->PrivilegeCount && bAllEnabled; i++)
		{
			if(bEnable)
				pPrivs->Privileges[i].Attributes |= SE_PRIVILEGE_ENABLED;
			else
			{
				if((pPrivs->Privileges[i].Attributes & SE_PRIVILEGE_ENABLED) == 0)
					bAllEnabled = FALSE;
			}
		}

		// Store the information back into the token
		if(bEnable)
			bOk = AdjustTokenPrivileges(hToken, FALSE, pPrivs, 0, NULL, NULL);
		else
			bOk = TRUE;
	}
	__finally
	{
		if(hToken)
			CloseHandle(hToken);
		if(pBuffer)
			delete [] pBuffer;
	}
	return bOk && bAllEnabled;
}


CLoginDlg::CLoginDlg(CWnd* pParent, CCredentials *pCreds, LPCTSTR szMachine, LPCTSTR szLoginComponent)
	: CDialog(CLoginDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CLoginDlg)
	m_bEnablePrivileges = FALSE;
	//}}AFX_DATA_INIT
	m_bOptions = FALSE;
	m_nOKTop = 0;

	m_pCreds = pCreds;
	m_csMachine = szMachine;
	m_szLoginComponent = szLoginComponent;
}


void CLoginDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLoginDlg)
	DDX_Control(pDX, IDC_ENABLEPRIVILEGES, m_EnablePrivilegesCtl);
	DDX_Control(pDX, IDC_EDITAUTHORITY, m_ceAuthority);
	DDX_Control(pDX, IDC_STATICAUTHORITY, m_cstaticAuthority);
	DDX_Control(pDX, IDOK, m_cbOK);
	DDX_Control(pDX, IDCANCEL, m_cbCancel);
	DDX_Control(pDX, IDC_BUTTONHELP, m_cbHelp);
	DDX_Control(pDX, IDC_BUTTONOPTIONS, m_cbOptions);
	DDX_Control(pDX, IDC_STATICIMPLEVEL, m_cstaticImpLevel);
	DDX_Control(pDX, IDC_STATICAUTLEVEL, m_cstaticAuthLevel);
	DDX_Control(pDX, IDC_COMBOIMP, m_cboxImp);
	DDX_Control(pDX, IDC_COMBOAUTH, m_cboxAuth);
	DDX_Control(pDX, IDC_CHECKCURRENTUSER, m_pbCurrentUser);
	DDX_Control(pDX, IDC_EDITUSERNAME, m_ceUser);
	DDX_Control(pDX, IDC_EDITPASSWORD, m_cePassword);
	DDX_Check(pDX, IDC_ENABLEPRIVILEGES, m_bEnablePrivileges);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLoginDlg, CDialog)
	//{{AFX_MSG_MAP(CLoginDlg)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTONHELP, OnButtonhelp)
	ON_BN_CLICKED(IDC_CHECKCURRENTUSER, OnCheckcurrentuser)
	ON_BN_CLICKED(IDC_BUTTONOPTIONS, OnButtonoptions)
	ON_BN_CLICKED(IDC_ENABLEPRIVILEGES, OnEnableprivileges)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLoginDlg message handlers

ULONG CLoginDlgApp::AppDllAddRef()
{
	m_DllRefCountCriticalSection.Lock();
	++m_lRef;
	if (m_lRef == 1 && !m_pcslServices)
	{
		m_pcslServices = new CServicesList;
	}
	m_DllRefCountCriticalSection.Unlock();
	return m_lRef;
}

ULONG CLoginDlgApp::AppDllRelease()
{
	m_DllRefCountCriticalSection.Lock();
	m_lRef--;
	if (m_lRef == 0)
	{
		m_pcslServices->ClearGlobalInterfaceTable();
		delete m_pcslServices;
		m_pcslServices = NULL;
	}
	m_DllRefCountCriticalSection.Unlock();
	return m_lRef;

}

BOOL CLoginDlgApp::InitInstance()
{
	// TODO: Add your specialized code here and/or call the base class

	m_DllRefCountCriticalSection.Lock();

	if (!m_pcslServices)
	{
		m_pcslServices = new CServicesList;
	}

	m_DllRefCountCriticalSection.Unlock();

	return CWinApp::InitInstance();
}

int CLoginDlgApp::ExitInstance()
{
	// TODO: Add your specialized code here and/or call the base class
	m_DllRefCountCriticalSection.Lock();

	if (m_pcslServices)
	{
		m_pcslServices->ClearGlobalInterfaceTable();
		delete m_pcslServices;
		m_pcslServices = NULL;

	}
	m_DllRefCountCriticalSection.Unlock();

	return CWinApp::ExitInstance();
}

void CLoginDlgApp::ConnectServerDone(WPARAM wParam, LPARAM lParam)
{
	if(m_pcslServices)
		m_pcslServices->OnConnectServerDone(wParam, lParam);
}

BOOL CLoginDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// bug#58931 - If HHCTRL.OCX is loaded before FASTPROX.DLL, we will get
	// a GPF when we exit IEXPLORE.  Before showing this dialog (which has
	// a help button), we CoCreate a WBEMContext to force FASTPROX.DLL to be
	// loaded
	IWbemContext *pContext = NULL;
	if(SUCCEEDED(CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (LPVOID *)&pContext)))
	{
		pContext->Release();
		pContext = NULL;
	}

	CString csTitle = _T("WMI ") + m_szLoginComponent;
	csTitle += _T(" Login");
	SetWindowText(csTitle);

	CString csMachine = GetMachineName();
	if (m_csMachine.CompareNoCase(csMachine) == 0)
	{
		m_pbCurrentUser.EnableWindow(FALSE);
	}
	else
	{
		m_pbCurrentUser.EnableWindow(TRUE);
	}

//m_pbCurrentUser.EnableWindow(TRUE);
	if(LoginAllPrivileges(FALSE))
	{
		// All of our privileges are already enabled.
		UpdateData();
		m_bEnablePrivileges = TRUE;
		UpdateData(FALSE);
	}



	m_ceUser.SetLimitText(127);
	m_cePassword.SetLimitText(127);
	m_ceAuthority.SetLimitText(127);

	m_ceUser.SetWindowText(m_pCreds->m_szUser);

	m_bCurrentUser = TRUE;
	m_pbCurrentUser.SetCheck(TRUE);
	m_ceUser.EnableWindow(FALSE);
	m_cePassword.EnableWindow(FALSE);
	m_ceAuthority.EnableWindow(FALSE);

	m_cboxImp.SetCurSel(2);

	m_cboxImp.SetItemData(0, RPC_C_IMP_LEVEL_DELEGATE );
	m_cboxImp.SetItemData(1, RPC_C_IMP_LEVEL_IDENTIFY );
	m_cboxImp.SetItemData(2, RPC_C_IMP_LEVEL_IMPERSONATE );

	m_cboxAuth.SetCurSel(1);

	m_cboxAuth.SetItemData(0, RPC_C_AUTHN_LEVEL_CALL);
	m_cboxAuth.SetItemData(1, RPC_C_AUTHN_LEVEL_CONNECT);
	m_cboxAuth.SetItemData(2, RPC_C_AUTHN_LEVEL_NONE);
	m_cboxAuth.SetItemData(3, RPC_C_AUTHN_LEVEL_PKT);
	m_cboxAuth.SetItemData(4, RPC_C_AUTHN_LEVEL_PKT_INTEGRITY);
	m_cboxAuth.SetItemData(5, RPC_C_AUTHN_LEVEL_PKT_PRIVACY);

	CenterWindow(this->GetParent());

	GetWindowRect(&m_crectOriginalScreen);
	GetClientRect(&m_crectOriginalClient);

	CRect crectOK;

	m_cbOK.GetWindowRect(&crectOK);
	ScreenToClient(&crectOK);
	m_nOKTop = crectOK.top;

	SetOptionsConfiguration();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CLoginDlg::OnDestroy()
{
	CDialog::OnDestroy();

}

BOOL CLoginDlg::PreTranslateMessage(MSG* pMsg)
{
	// TODO: Add your specialized code here and/or call the base class
	return CDialog::PreTranslateMessage(pMsg);
}


void CLoginDlg::OnOK()
{
	// TODO: Add extra validation here

	if (!m_bCurrentUser)
	{
		m_ceUser.GetWindowText(m_pCreds->m_szUser);
		m_cePassword.GetWindowText(m_pCreds->m_szUser2);
		m_ceAuthority.GetWindowText(m_pCreds->m_szAuthority);
	}
	else
	{
		m_pCreds->m_szUser = "";
		m_pCreds->m_szUser2 = "";
		m_pCreds->m_szAuthority = "";
	}

	m_pCreds->m_dwAuthLevel =  (DWORD) m_cboxAuth.GetItemData(m_cboxAuth.GetCurSel());
	m_pCreds->m_dwImpLevel = (DWORD) m_cboxImp.GetItemData(m_cboxImp.GetCurSel());

	CDialog::OnOK();
}

void CLoginDlg::OnButtonhelp()
{
	InvokeHelp();
}


CString CLoginDlg::GetSDKDirectory()
{
	CString csHmomWorkingDir;
	HKEY hkeyLocalMachine;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hkeyLocalMachine);
	if (lResult != ERROR_SUCCESS) {
		return "";
	}

	HKEY hkeyHmomCwd;
	lResult = RegOpenKeyEx(
				hkeyLocalMachine,
				_T("SOFTWARE\\Microsoft\\Wbem"),
				0,
				KEY_READ | KEY_QUERY_VALUE,
				&hkeyHmomCwd);

	if (lResult != ERROR_SUCCESS) {
		RegCloseKey(hkeyLocalMachine);
		return "";
	}

	unsigned long lcbValue = 1024;
	LPTSTR pszWorkingDir = csHmomWorkingDir.GetBuffer(lcbValue);

	unsigned long lType;
	lResult = RegQueryValueEx(
				hkeyHmomCwd,
				_T("SDK Directory"),
				NULL,
				&lType,
				(unsigned char*) (void*) pszWorkingDir,
				&lcbValue);


	csHmomWorkingDir.ReleaseBuffer();
	RegCloseKey(hkeyHmomCwd);
	RegCloseKey(hkeyLocalMachine);

	if (lResult != ERROR_SUCCESS)
	{
		csHmomWorkingDir.Empty();
	}

	return csHmomWorkingDir;
}


void CLoginDlg::OnCancel()
{
	CDialog::OnCancel();
}

void CLoginDlg::InvokeHelp()
{
	// TODO: Add your message handler code here and/or call default

	CString csPath;
	WbemRegString(SDK_HELP, csPath);


	CString csData = idh_wbemlogindb;


	HWND hWnd = NULL;

	try
	{
		HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD_PTR) (LPCTSTR) csData);
		if (!hWnd)
		{
			CString csUserMsg;
			csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
			ErrorMsg(csUserMsg, S_OK);
		}

	}

	catch( ... )
	{
		// Handle any exceptions here.
		CString csUserMsg;
		csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
		ErrorMsg(csUserMsg, S_OK);
	}
}

void CLoginDlg::OnCheckcurrentuser()
{
	// TODO: Add your control notification handler code here
	m_bCurrentUser = m_pbCurrentUser.GetCheck();

	if (m_bCurrentUser)
	{
		m_ceUser.EnableWindow(FALSE);
		m_cePassword.EnableWindow(FALSE);
		m_ceAuthority.EnableWindow(FALSE);

	}
	else
	{
		m_ceUser.EnableWindow(TRUE);
		m_cePassword.EnableWindow(TRUE);
		m_ceAuthority.EnableWindow(TRUE);
	}
}




void CLoginDlg::OnButtonoptions()
{
	if (m_bOptions)
		m_bOptions = FALSE;
	else
		m_bOptions = TRUE;
	SetOptionsConfiguration();
}

void CLoginDlg::SetOptionsConfiguration()
{
	CRect crNew(m_crectOriginalScreen);
	if (m_bOptions)
	{
		// Display the larger view with options by growing the dialog.
		m_cbOptions.SetWindowText(_T("&Options <<"));
		OptionsVisible(TRUE);
		SetButtonPositions();
		SetWindowPos(&wndTop, 0, 0, crNew.Width(),
			crNew.Height(), SWP_SHOWWINDOW | SWP_NOMOVE);
	}
	else
	{
		// Display the smaller view without options by shrinking the dialog
		int delta = (int)(crNew.Height() * GROW_FACTOR);
		crNew.bottom = crNew.top + (crNew.Height() - delta);
		m_cbOptions.SetWindowText(_T("&Options >>"));
		OptionsVisible(FALSE);
		SetButtonPositions();
		SetWindowPos(&wndTop, 0, 0,
			crNew.Width(), crNew.Height(), SWP_SHOWWINDOW | SWP_NOMOVE);
	}

}

void CLoginDlg::OptionsVisible(BOOL bVisible)
{
	if (bVisible)
	{
		m_cstaticImpLevel.EnableWindow(TRUE);
		m_cstaticImpLevel.ShowWindow(SW_SHOW);
		m_cstaticAuthLevel.EnableWindow(TRUE);
		m_cstaticAuthLevel.ShowWindow(SW_SHOW);
		m_cboxImp.EnableWindow(TRUE);
		m_cboxImp.ShowWindow(SW_SHOW);
		m_cboxAuth.EnableWindow(TRUE);
		m_cboxAuth.ShowWindow(SW_SHOW);
		m_cstaticAuthority.EnableWindow(TRUE);
		m_cstaticAuthority.ShowWindow(SW_SHOW);
//		m_ceAuthority.EnableWindow(TRUE);
		m_ceAuthority.ShowWindow(SW_SHOW);
	}
	else
	{
		m_cstaticImpLevel.EnableWindow(FALSE);
		m_cstaticImpLevel.ShowWindow(SW_HIDE);
		m_cstaticAuthLevel.EnableWindow(FALSE);
		m_cstaticAuthLevel.ShowWindow(SW_HIDE);
		m_cboxImp.EnableWindow(FALSE);
		m_cboxImp.ShowWindow(SW_HIDE);
		m_cboxAuth.EnableWindow(FALSE);
		m_cboxAuth.ShowWindow(SW_HIDE);
		m_cstaticAuthority.EnableWindow(FALSE);
		m_cstaticAuthority.ShowWindow(SW_HIDE);
//		m_ceAuthority.EnableWindow(FALSE);
		m_ceAuthority.ShowWindow(SW_HIDE);
	}
}

void CLoginDlg::SetButtonPositions()
{
	CRect crectOK;
	CRect crectCancel;
	CRect crectHelp;
	CRect crectOptions;

	m_cbOK.GetWindowRect(&crectOK);
	m_cbCancel.GetWindowRect(&crectCancel);
	m_cbHelp.GetWindowRect(&crectHelp);
	m_cbOptions.GetWindowRect(&crectOptions);

	ScreenToClient(&crectOK);
	ScreenToClient(&crectCancel);
	ScreenToClient(&crectHelp);
	ScreenToClient(&crectOptions);

	int nHeight = crectOK.Height();

	if (m_bOptions)
	{
		crectHelp.top = m_nOKTop;
		crectHelp.bottom = m_nOKTop + nHeight;
		m_cbHelp.SetWindowPos(&wndTop, crectHelp.left, crectHelp.top,
			crectHelp.Width(), crectHelp.Height(), SWP_SHOWWINDOW);

		crectOptions.top = m_nOKTop;
		crectOptions.bottom = m_nOKTop + nHeight;
		m_cbOptions.SetWindowPos(&wndTop, crectOptions.left, crectOptions.top,
			crectOptions.Width(), crectOptions.Height(), SWP_SHOWWINDOW);

		crectCancel.top = m_nOKTop;
		crectCancel.bottom = m_nOKTop + nHeight;
		m_cbCancel.SetWindowPos(&wndTop, crectCancel.left, crectCancel.top,
			crectCancel.Width(), crectCancel.Height(), SWP_SHOWWINDOW);

		crectOK.top = m_nOKTop;
		crectOK.bottom = m_nOKTop + nHeight;
		m_cbOK.SetWindowPos(&wndTop, crectOK.left, crectOK.top,
			crectOK.Width(), crectOK.Height(), SWP_SHOWWINDOW);
	}
	else
	{
		int delta = (int)(m_crectOriginalClient.Height() * GROW_FACTOR +
						  m_crectOriginalClient.Height() * BUTTON_MARGIN_ADJUST);

		crectHelp.top = crectHelp.top - delta;
		crectHelp.bottom = crectHelp.bottom - delta;
		m_cbHelp.SetWindowPos(&wndTop, crectHelp.left, crectHelp.top,
			crectHelp.Width(), crectHelp.Height(), SWP_SHOWWINDOW);

		crectOptions.top = crectOptions.top - delta;
		crectOptions.bottom = crectOptions.bottom - delta;
		m_cbOptions.SetWindowPos(&wndTop, crectOptions.left, crectOptions.top,
			crectOptions.Width(), crectOptions.Height(), SWP_SHOWWINDOW);

		crectCancel.top = crectCancel.top - delta;
		crectCancel.bottom = crectCancel.bottom - delta;
		m_cbCancel.SetWindowPos(&wndTop, crectCancel.left, crectCancel.top,
			crectCancel.Width(), crectCancel.Height(), SWP_SHOWWINDOW);

		crectOK.top = crectOK.top - delta;
		crectOK.bottom = crectOK.bottom - delta;
		m_cbOK.SetWindowPos(&wndTop, crectOK.left, crectOK.top,
			crectOK.Width(), crectOK.Height(), SWP_SHOWWINDOW);
	}
}


void CLoginDlg::OnEnableprivileges()
{
	UpdateData();
//	ASSERT(m_bEnablePrivileges); // We should never be able to clear this check
	if(m_bEnablePrivileges)
	{
		LoginAllPrivileges(TRUE);
	}
	else
	{
		m_bEnablePrivileges = TRUE;
		UpdateData(FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\cathelp.cpp ===
//=--------------------------------------------------------------------------=

// CatHelp.Cpp

//=--------------------------------------------------------------------------=

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "precomp.h"

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\logindlg\progdlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ProgDlg.h : header file
// CG: This file was added by the Progress Dialog component

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog

#ifndef __PROGDLG_H__
#define __PROGDLG_H__

class CProgressDlg : public CDialog
{
// Construction / Destruction
public:
    CProgressDlg(CWnd* pParent, LPCTSTR szMachine, LPCTSTR szUser, HANDLE hEventOkToNotify);
    ~CProgressDlg();

	// Dialog Data
    //{{AFX_DATA(CProgressDlg)
	enum { IDD = CG_IDD_PROGRESS };
	CButton	m_cbCancel;
	CStatic	m_cstaticMessage;
	//}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CProgressDlg)
	protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CString m_csMachine;
	CString m_csUser;
	HANDLE m_hEventOkToNotify;
   
    // Generated message map functions
    //{{AFX_MSG(CProgressDlg)
    virtual BOOL OnInitDialog();
	virtual void OnCancel();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // __PROGDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\logindlg\serviceslist.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#if !defined(SERVICESLIST__INCLUDED_)
#define SERVICESLIST__INCLUDED_


CString GetMachineName();

class CProgressDlg;

#include "ConnectServerThread.h"

#include "Credentials.h"
#include <cominit.h>

struct CNamespace
{
	CNamespace(LPCTSTR szNamespace = NULL);
	~CNamespace();
	void SetNamespace(LPCTSTR szNamespace);
	CString GetNamespace();
	CString GetMachine() {return m_csMachine;}
	CString m_csMachine;
	CStringArray m_csaNamespaceConstituents;
	int IsRoot();
	CString GetRelNamespace(LPCTSTR szRelTo);
};

struct CServicesNode
{
	CString m_csDomainAndUser;
	CString m_csUser;
	CString m_csDomain;
	CString m_csNamespace;
	CString m_csUser2;
	CString m_csAuthority;
	DWORD m_dwCookie;
	CString m_csMachine;
	DWORD m_dwAuthLevel;
	DWORD m_dwImpLevel;

	HRESULT SetInterfaceSecurity(IUnknown *pUnknown)
	{
		if(!this)
			return E_FAIL;

		BSTR bstrTemp1 = m_csAuthority.AllocSysString();
		BSTR bstrTemp2;
		if (m_csDomain.GetLength() > 0)
		{
			CString csUserandDomain = m_csDomain + "\\" + m_csUser;
			bstrTemp2 = csUserandDomain.AllocSysString();
		}
		else
		{
			bstrTemp2 = m_csUser.AllocSysString();
		}
		
		BSTR bstrTemp3 = m_csUser2.AllocSysString();

		HRESULT hr = ::SetInterfaceSecurity(pUnknown, bstrTemp1, bstrTemp2, bstrTemp3,  m_dwAuthLevel, m_dwImpLevel);

		::SysFreeString(bstrTemp1);
		::SysFreeString(bstrTemp2);
		::SysFreeString(bstrTemp3);

		return hr;
	}

	CServicesNode(const CString &rcsDomainAndUserUser, const CString &rcsNamespace, 
		const CString &rcsPassword,  DWORD dwCookie, DWORD dwAuthLevel, DWORD dwImpLevel);
};


class CServicesList
{
public:
	CServicesList();
	~CServicesList();
	HRESULT GetServices(LPCTSTR szNamespace, BOOL bUpdatePointer, IWbemServices **ppServices);
	HRESULT OpenNamespace(LPCTSTR szBaseNamespace, LPCTSTR szRelativeChild, IWbemServices **ppServices);

	void ClearServicesList();
	void ClearGlobalInterfaceTable();
	HRESULT SetInterfaceSecurityFromCache(LPCTSTR szNamespace, IUnknown *pUnknown)
	{
		return GetServicesNode(szNamespace)->SetInterfaceSecurity(pUnknown);
	}
	HRESULT GetServicesFromCache(LPCTSTR szNamespace, IWbemServices **ppServices)
	{
		return GetServicesFromCache(GetServicesNode(szNamespace), ppServices);
	}

	void OnConnectServerDone(WPARAM wParam, LPARAM lParam);
	CString m_szDialogTitle;
protected:
	CPtrArray m_cpaServices;
	CProgressDlg *m_pProgress;

	CGITThread m_GITMgr;
	IGlobalInterfaceTable *m_pGIT;

	HRESULT TryToConnect(const CCredentials *pCreds, IWbemServices **ppServices);

	CServicesNode *GetServicesNode(LPCTSTR szNamespace);

	HRESULT GetServicesFromCache(CServicesNode *pNode, IWbemServices **ppServices);
	
	void RemoveServiceNodes(LPCTSTR szNamespace);

	friend struct CServicesNode;
};

#endif // !defined(SERVICESLIST__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\logindlg\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//	LoginDlg.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\mofcomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MOFComp.h : main header file for MOFCOMP.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMOFCompApp : See MOFComp.cpp for implementation.

class CMOFCompApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\logindlg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// LoginDlg.cpp :
//

#include "precomp.h"
#include "resource.h"
#include <fstream.h>
#include "wbemidl.h"
#include <afxcmn.h>
#include "LoginDlg.h"
#include "MOFComp.h"
#include "MOFCompCtl.h"
#include "htmlhelp.h"
#include "HTMTopics.h"




#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define IDH_actx_Logging_into_WBEM 300

CLoginDlg::CLoginDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CLoginDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CLoginDlg)
	//}}AFX_DATA_INIT
}


void CLoginDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLoginDlg)
	DDX_Control(pDX, IDC_EDITUSERNAME, m_ceUser);
	DDX_Control(pDX, IDC_EDITPASSWORD, m_cePassword);
	DDX_Control(pDX, IDC_EDITAUTHORITY, m_ceAuthority);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLoginDlg, CDialog)
	//{{AFX_MSG_MAP(CLoginDlg)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTONHELP, OnButtonhelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLoginDlg message handlers

BOOL CLoginDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	m_bHelp = FALSE;

	m_ceUser.SetWindowText(m_csUser);
	m_cePassword.SetWindowText(m_csPassword);
	m_ceAuthority.SetWindowText(m_csAuthority);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CLoginDlg::SetMachine(CString &rcsMachine)
{
	m_csMachine = rcsMachine;
}

void CLoginDlg::OnDestroy()
{
	CDialog::OnDestroy();

}

BOOL CLoginDlg::PreTranslateMessage(MSG* pMsg)
{
	// TODO: Add your specialized code here and/or call the base class

	return CDialog::PreTranslateMessage(pMsg);
}

void CLoginDlg::OnOK()
{
	// TODO: Add extra validation here



	m_ceUser.GetWindowText(m_csUser);
	m_cePassword.GetWindowText(m_csPassword);
	m_ceAuthority.GetWindowText(m_csAuthority);

	CDialog::OnOK();
}

void CLoginDlg::OnButtonhelp()
{
	m_pActiveXControl->m_csHelpUrl = idh_logonmcw;// bug#55976 - idh_mofcompwiz;
	m_pActiveXControl->InvokeHelp();

}

void CLoginDlg::OnCancel()
{



	CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\logindlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// LoginDlg.h : main header file for 
//

#if !defined(AFX_LOGINDLG_H__347E34B5_E42E_11D0_9644_00C04FD9B15B__INCLUDED_)
#define AFX_LOGINDLG_H__347E34B5_E42E_11D0_9644_00C04FD9B15B__INCLUDED_

class CMOFCompCtrl;
class CMyPropertyPage3;

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CLoginDlg dialog

class CLoginDlg : public CDialog
{
// Construction
public:
	CLoginDlg(CWnd* pParent = NULL);   // standard constructor
	CString m_csUser;
	CString m_csPassword;
	CString m_csAuthority;
	void SetMachine(CString &rcsMachine);
// Dialog Data
	//{{AFX_DATA(CLoginDlg)
	enum { IDD = IDD_DIALOGLOGIN };
	CEdit	m_ceUser;
	CEdit	m_cePassword;
	CEdit	m_ceAuthority;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLoginDlg)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CString m_csMachine;
	BOOL m_bHelp;
	CMOFCompCtrl *m_pActiveXControl;
	// Generated message map functions
	//{{AFX_MSG(CLoginDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	virtual void OnOK();
	afx_msg void OnButtonhelp();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	
	friend class CMyPropertyPage3;
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOGINDLG_H__347E34B5_E42E_11D0_9644_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\mofcomp.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MOFComp.cpp : Implementation of CMOFCompApp and DLL registration.

#include "precomp.h"
#include "MOFComp.h"
#include "CatHelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CMOFCompApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xb2345980, 0x5cf9, 0x11d0, { 0x95, 0xfd, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const GUID CDECL BASED_CODE _ctlid =   { 0xb2345983, 0x5cf9, 0x11d0,
           { 0x95, 0xfd, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b} };

const CATID CATID_SafeForScripting     =
   {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing  =
   {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};

////////////////////////////////////////////////////////////////////////////
// CMOFCompApp::InitInstance - DLL initialization

BOOL CMOFCompApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();


	void AfxEnableControlContainer( );

	if (bInit)
	{

	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CMOFCompApp::ExitInstance - DLL termination

int CMOFCompApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	if (FAILED( CreateComponentCategory(CATID_SafeForScripting,
               L"Controls that are safely scriptable") ))
             return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( CreateComponentCategory(
           CATID_SafeForInitializing,
           L"Controls safely initializable from persistent data") ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForScripting) ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForInitializing) ))
         return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\mofcompctl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MOFCompCtl.h : Declaration of the CMOFCompCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CMOFCompCtrl : See MOFCompCtl.cpp for implementation.


#define MODNAMESPACE WM_USER + 200
#define DOMOFCOMPILE WM_USER + 201


struct IWbemClassObject;
class CMyPropertySheet;
class CMyPropertyPage1;
class CMyPropertyPage2;
class CMyPropertyPage3;
class CLoginDlg;

CString ExpandEnvironmentStrings(LPCTSTR pString);


void ErrorMsg
		(CString *pcsUserMsg, SCODE sc, IWbemClassObject *pErrorObject, BOOL bLog, CString *pcsLogMsg,
		char *szFile, int nLine, BOOL bNotification = FALSE, UINT uType = MB_ICONEXCLAMATION);
void LogMsg
		(CString *pcsLogMsg, char *szFile, int nLine);

CString GetSDKDirectory();

class CMOFCompCtrl : public COleControl
{
	DECLARE_DYNCREATE(CMOFCompCtrl)

// Constructor
public:
	CMOFCompCtrl();
	int MofCompilerProcess();
	int WmiMofCkProcess();

	IWbemLocator *CMOFCompCtrl::InitLocator();
	enum {MODECHECK, MODECOMPILE, MODEBINARY};

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMOFCompCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual DWORD GetControlFlags();
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void OnSetClientSite( );
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	CMyPropertySheet *m_pPropertySheet;
	~CMOFCompCtrl();

	IWbemServices *GetIWbemServices(CString &rcsNamespace);

	DECLARE_OLECREATE_EX(CMOFCompCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CMOFCompCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CMOFCompCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CMOFCompCtrl)		// Type name and misc status

	CToolTipCtrl m_ttip;

	BOOL m_bInitDraw;
	HICON m_hCPPComp;
	HICON m_hCPPCompSel;
	CImageList *m_pcilImageList;
	int m_nImage;

	void ProcessSwitches(CString &rcsArg);

	BOOL m_bClassSwitch;
	int m_nClassUpdateOnly;
	int m_nClassCreateOnly;

	void SetClassUpdateOnly(int nValue);
	void SetClassCreateOnly(int nValue);

	BOOL m_bInstanceSwitch;
	int m_nInstanceUpdateOnly;
	int m_nInstanceCreateOnly;

	void SetInstanceUpdateOnly(int nValue);
	void SetInstanceCreateOnly(int nValue);

	int m_nWizardMode;

	void SetMode(int nMode)
		{m_nWizardMode = nMode;}

	int GetMode()
		{return m_nWizardMode;}

	BOOL m_bNameSpaceSwitch;
	CString m_csNameSpace;

	void SetNameSpace(CString *pcsValue)
	{m_csNameSpace = *pcsValue, m_bNameSpaceSwitch = TRUE;}


	CString m_csUserName;
	void SetUserName(CString *pcsValue)
	{m_csUserName = *pcsValue;}

	CString m_csPassword;
	void SetPassword(CString *pcsValue)
	{m_csPassword = *pcsValue;}

	CString m_csAuthority;
	void SetAuthority(CString *pcsValue)
	{m_csAuthority = *pcsValue;}

	CString m_csMofFullPath;

	CString m_csBinaryMofFullPath;

	BOOL m_bWMI;

	SCODE m_sc;
	BOOL m_bUserCancel;

	void InvokeHelp();
	CString m_csHelpUrl;

	int m_nFireEventCounter;

// Message maps
	//{{AFX_MSG(CMOFCompCtrl)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnMove(int x, int y);
	//}}AFX_MSG
	afx_msg LRESULT NamespaceModified(WPARAM, LPARAM);
	afx_msg LRESULT DoMofCompile(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()

	void RelayEvent(UINT message, WPARAM wParam, LPARAM lParam);

	friend class CMyPropertyPage1;
	friend class CMyPropertyPage2;
	friend class CMyPropertyPage3;
	friend class CLoginDlg;

// Dispatch maps
	//{{AFX_DISPATCH(CMOFCompCtrl)
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CMOFCompCtrl)
	void FireGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
		{FireEvent(eventidGetIWbemServices,EVENT_PARAM(VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT), lpctstrNamespace, pvarUpdatePointer, pvarServices, pvarSC, pvarUserCancel);}
	void FireModifiedNamespace(LPCTSTR lpctstrNamespace)
		{FireEvent(eventidModifiedNamespace,EVENT_PARAM(VTS_BSTR), lpctstrNamespace);}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CMOFCompCtrl)
	eventidGetIWbemServices = 1L,
	eventidModifiedNamespace = 2L,
	//}}AFX_DISP_ID
	};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\mofcompctl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MOFCompCtl.cpp : Implementation of the CMOFCompCtrl OLE control class.

#include "precomp.h"
#include "wbemidl.h"
#include <afxcmn.h>
#include <stdio.h>
#include <STDLIB.H>
#include <fcntl.h>
#include "MOFComp.h"
#include "MOFCompCtl.h"
#include "MOFCompPpg.h"
#include "MsgDlgExterns.h"
#include "WbemRegistry.h"
#include "MyPropertyPage1.h"
#include "MyPropertySheet.h"
#include "htmlhelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMOFCompCtrl, COleControl)

extern CMOFCompApp NEAR theApp;

/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMOFCompCtrl, COleControl)
	//{{AFX_MSG_MAP(CMOFCompCtrl)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	ON_WM_MOVE()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
	ON_MESSAGE(MODNAMESPACE, NamespaceModified )
	ON_MESSAGE(DOMOFCOMPILE, DoMofCompile )
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CMOFCompCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CMOFCompCtrl)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CMOFCompCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CMOFCompCtrl, COleControl)
	//{{AFX_EVENT_MAP(CMOFCompCtrl)
	EVENT_CUSTOM("GetIWbemServices", FireGetIWbemServices, VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT)
	EVENT_CUSTOM("ModifiedNamespace", FireModifiedNamespace, VTS_BSTR)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CMOFCompCtrl, 1)
	PROPPAGEID(CMOFCompPropPage::guid)
END_PROPPAGEIDS(CMOFCompCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMOFCompCtrl, "WBEM.MOFCompCtrl.1",
	0xb2345983, 0x5cf9, 0x11d0, 0x95, 0xfd, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CMOFCompCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DMOFComp =
		{ 0xb2345981, 0x5cf9, 0x11d0, { 0x95, 0xfd, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const IID BASED_CODE IID_DMOFCompEvents =
		{ 0xb2345982, 0x5cf9, 0x11d0, { 0x95, 0xfd, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwMOFCompOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CMOFCompCtrl, IDS_MOFCOMP, _dwMOFCompOleMisc)

//////////////////////////////////////////////////////////////////////////////
// Global variables

long gCountWizards = 0;


void ErrorMsg
(CString *pcsUserMsg, SCODE sc, IWbemClassObject *pErrorObject,
 BOOL bLog, CString *pcsLogMsg, char *szFile, int nLine, BOOL, UINT uType)
{

	HWND hFocus = ::GetFocus();

	CString csCaption = _T("MOFComp Message");
	BOOL bErrorObject = sc != S_OK;
	BSTR bstrTemp1 = csCaption.AllocSysString();
	BSTR bstrTemp2 = pcsUserMsg->AllocSysString();
	DisplayUserMessage
		(bstrTemp1,bstrTemp2,
		sc,bErrorObject,uType);
	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);

	SetFocus(hFocus);

	if (bLog)
	{
		LogMsg(pcsLogMsg,  szFile, nLine);

	}

}

void LogMsg
(CString *pcsLogMsg, char *szFile, int nLine)
{


}

CString ExpandEnvironmentStrings(LPCTSTR pString)
{
	TCHAR *ptcExpanded = NULL;
	DWORD dwReturn =  ExpandEnvironmentStrings(pString,(LPTSTR)ptcExpanded,0);

	ptcExpanded = new TCHAR[dwReturn + 1];

	dwReturn =  ExpandEnvironmentStrings(pString,(LPTSTR)ptcExpanded,dwReturn);

	CString csOut;
	if (dwReturn == 0)
	{
		csOut = pString;
	}
	else
	{
		csOut =  (LPCTSTR) ptcExpanded;
	}

	delete [] ptcExpanded;

	return csOut;
}

CString GetSDKDirectory()
{
	CString csHmomWorkingDir;
	HKEY hkeyLocalMachine;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hkeyLocalMachine);
	if (lResult != ERROR_SUCCESS) {
		return "";
	}




	HKEY hkeyHmomCwd;

	lResult = RegOpenKeyEx(
				hkeyLocalMachine,
				_T("SOFTWARE\\Microsoft\\Wbem"),
				0,
				KEY_READ | KEY_QUERY_VALUE,
				&hkeyHmomCwd);

	if (lResult != ERROR_SUCCESS) {
		RegCloseKey(hkeyLocalMachine);
		return "";
	}





	unsigned long lcbValue = 1024;
	LPTSTR pszWorkingDir = csHmomWorkingDir.GetBuffer(lcbValue);


	unsigned long lType;
	lResult = RegQueryValueEx(
				hkeyHmomCwd,
				_T("SDK Directory"),
				NULL,
				&lType,
				(unsigned char*) (void*) pszWorkingDir,
				&lcbValue);


	csHmomWorkingDir.ReleaseBuffer();
	RegCloseKey(hkeyHmomCwd);
	RegCloseKey(hkeyLocalMachine);


	CString csOut;

	if (lResult == ERROR_SUCCESS)
	{
		csOut = ExpandEnvironmentStrings(csHmomWorkingDir);
	}

	return csOut;
}

/////////////////////////////////////////////////////////////////////////////
// CMOFCompCtrl::CMOFCompCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CMOFCompCtrl

BOOL CMOFCompCtrl::CMOFCompCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to afxRegInsertable.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_MOFCOMP,
			IDB_MOFCOMP,
			afxRegInsertable | afxRegApartmentThreading,
			_dwMOFCompOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CMOFCompCtrl::CMOFCompCtrl - Constructor

CMOFCompCtrl::CMOFCompCtrl()
{
	InitializeIIDs(&IID_DMOFComp, &IID_DMOFCompEvents);

	SetInitialSize (18, 16);
	m_bInitDraw = TRUE;
	m_pcilImageList = NULL;
	m_nImage = 0;
	m_pPropertySheet = NULL;

	m_bClassSwitch = TRUE;
	m_bInstanceSwitch = TRUE;
	SetMode(MODECOMPILE);
	m_bNameSpaceSwitch = TRUE;


	m_nClassUpdateOnly = 0;
	m_nClassCreateOnly = 0;
	m_nInstanceUpdateOnly = 0;
	m_nInstanceCreateOnly = 0;

	m_nFireEventCounter = 0;

}


/////////////////////////////////////////////////////////////////////////////
// CMOFCompCtrl::~CMOFCompCtrl - Destructor

CMOFCompCtrl::~CMOFCompCtrl()
{
	// TODO: Cleanup your control's instance data here.

}


/////////////////////////////////////////////////////////////////////////////
// CMOFCompCtrl::OnDraw - Drawing function

void CMOFCompCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{

	if (m_bInitDraw)
	{
		m_bInitDraw = FALSE;
		HICON m_hMOFComp  = theApp.LoadIcon(IDI_MOFCOMP16);
		HICON m_hMOFCompSel  = theApp.LoadIcon(IDI_MOFCOMPSEL16);

		m_pcilImageList = new CImageList();

		m_pcilImageList ->
			Create(32, 32, TRUE, 2, 2);

		int iReturn = m_pcilImageList -> Add(m_hMOFComp);

		iReturn = m_pcilImageList -> Add(m_hMOFCompSel);

		m_nImage = 0;
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	m_pcilImageList -> Draw(pdc, m_nImage, pt, ILD_TRANSPARENT);


}


/////////////////////////////////////////////////////////////////////////////
// CMOFCompCtrl::DoPropExchange - Persistence support

void CMOFCompCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);
	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CMOFCompCtrl::GetControlFlags -
// Flags to customize MFC's implementation of ActiveX controls.
//
// For information on using these flags, please see MFC technical note
// #nnn, "Optimizing an ActiveX Control".
DWORD CMOFCompCtrl::GetControlFlags()
{
	DWORD dwFlags = COleControl::GetControlFlags();

	return dwFlags;
}


/////////////////////////////////////////////////////////////////////////////
// CMOFCompCtrl::OnResetState - Reset control to default state

void CMOFCompCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CMOFCompCtrl::AboutBox - Display an "About" box to the user

void CMOFCompCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_MOFCOMP);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CMOFCompCtrl message handlers

void CMOFCompCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{

	RelayEvent(WM_LBUTTONDOWN, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));

}

void CMOFCompCtrl::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	RelayEvent(WM_LBUTTONUP, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));

	DoMofCompile(0,0);

}

int CMOFCompCtrl::MofCompilerProcess()
{
	DWORD dwProcessReturn = 4;
	BOOL bProcessReturn = 0;

	CString csMofCompiler = GetHmomWorkingDirectory();
	if (csMofCompiler.GetLength() > 0)
	{
		csMofCompiler += _T("\\mofcomp.exe");
		CString csArg = csMofCompiler;
		csArg += _T(" ");

		if (GetMode() == MODECOMPILE && m_csUserName.GetLength() > 0)
		{
			csArg += _T("-U:");
			csArg += m_csUserName;
		}
		m_csUserName.Empty();

		if (GetMode() == MODECOMPILE && m_csPassword.GetLength() > 0)
		{
			csArg += _T(" -P:");
			csArg += m_csPassword;
		}
		m_csPassword.Empty();

		if (GetMode() == MODECOMPILE && m_csAuthority.GetLength() > 0)
		{
			csArg += _T(" -A:");
			csArg += m_csAuthority;
		}
		m_csAuthority.Empty();

		ProcessSwitches(csArg);
		csArg += _T(" \"");
		csArg += m_csMofFullPath;
		csArg += _T("\"");
		PROCESS_INFORMATION pinfoMofCompiler;

		CString csFile;
		if (GetMode() == MODEBINARY)
		{
			int n = m_csBinaryMofFullPath.ReverseFind('\\');
			csFile = m_csBinaryMofFullPath.Left(n);
			csFile += _T("\\TempStdOut");
		}
		else
		{
			int n = m_csMofFullPath.ReverseFind('\\');
			csFile = m_csMofFullPath.Left(n);
			csFile += _T("\\TempStdOut");
		}

		SECURITY_ATTRIBUTES saTemp;
		saTemp.nLength = sizeof(SECURITY_ATTRIBUTES);
		saTemp.lpSecurityDescriptor = NULL;
		saTemp.bInheritHandle = TRUE;

		HANDLE hTemp = CreateFile
						((LPCTSTR) csFile,
						GENERIC_WRITE,
						FILE_SHARE_WRITE,
						&saTemp,
						CREATE_ALWAYS,
						FILE_ATTRIBUTE_NORMAL,
						NULL);

		if (hTemp == INVALID_HANDLE_VALUE)
		{
			csArg.Empty();
			DWORD dwError = GetLastError();
			CString csErrorAsHex;
			csErrorAsHex.Format(_T("0x%x"),dwError);
			CString csUserMsg;
			csUserMsg =  _T("MOF Wizard failure:  Cannot create temporary file.");
			csUserMsg += _T("  \"CreateFile\" function call error code returned: ") + csErrorAsHex;
			csUserMsg += _T(".");
			ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ );
			m_nImage = 0;
			InvalidateControl();
			SetFocus();
			return dwProcessReturn;
		}

		STARTUPINFO sinfoMofCompiler;
		sinfoMofCompiler.cb = sizeof(sinfoMofCompiler);
		sinfoMofCompiler.lpReserved = NULL;
		sinfoMofCompiler.lpDesktop = NULL;
		sinfoMofCompiler.lpTitle = NULL;
		sinfoMofCompiler.dwFlags = STARTF_USESTDHANDLES;
		sinfoMofCompiler.cbReserved2 = 0;
		sinfoMofCompiler.lpReserved2 = NULL;
		sinfoMofCompiler.hStdInput = NULL;
		sinfoMofCompiler.hStdOutput = (HANDLE) hTemp;
		sinfoMofCompiler.hStdError = NULL;



		BOOL bReturn =
			CreateProcess(
					(LPCTSTR) csMofCompiler,
					const_cast<TCHAR*>((LPCTSTR) csArg),
					NULL,
					NULL,
					TRUE,
					DETACHED_PROCESS,
					NULL,
					NULL,
					&sinfoMofCompiler,
					&pinfoMofCompiler);

		if (!bReturn)
		{
			csArg.Empty();
			CString csUserMsg;
			csUserMsg =  _T("MOF Wizard failure:  Cannot invoke the MOF compiler.  \"CreateProcess\" function call failed.");
			ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ - 17);
			CloseHandle(hTemp);
			m_nImage = 0;
			InvalidateControl();
			SetFocus();
			DeleteFile(csFile);
			return dwProcessReturn;
		}

		DWORD dwProcess =
			WaitForSingleObject(pinfoMofCompiler.hProcess,INFINITE);

		csArg.Empty();
		if (dwProcess != WAIT_OBJECT_0)
		{
			CString csErrorAsHex;
			csErrorAsHex.Format(_T("0x%x"),dwProcess);
			CString csUserMsg;
			csUserMsg =  _T("MOF Wizard failure:  \"WaitForSingleObject\" function call failed with error code ");
			csUserMsg += csErrorAsHex + _T(".");
			ErrorMsg
					(&csUserMsg, S_OK , NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ - 8);
			m_nImage = 0;
			CloseHandle(hTemp);
			InvalidateControl();
			SetFocus();
			DeleteFile(csFile);
			return dwProcessReturn;
		}


		bProcessReturn =
			GetExitCodeProcess( pinfoMofCompiler.hProcess,&dwProcessReturn );

		FlushFileBuffers(hTemp);
		CloseHandle(hTemp);
		FILE *fTmp = _tfopen ( (LPCTSTR) csFile, _T("r"));

		char szMofOutput[1000];
		CString csReturned;
		if(fTmp!= NULL)
		{
			while (fgets( szMofOutput, 999, fTmp))
			{
				csReturned += szMofOutput;
			}

			CString csTemp;

			if (csReturned.GetLength() > 5)
			{
				csTemp = csReturned.Right(6);
				csTemp = csTemp.Left(5);
			}

			if (csTemp.CompareNoCase(_T("Done!")) != 0 &&
				GetMode() == CMOFCompCtrl::MODECOMPILE)
			{

				csReturned += _T("\n\nNote:  All of the informtion in this MOF file up to the point where the error occurred has actually been \nwritten to the repository.");
			}

			csReturned += _T("\n");
			fclose(fTmp);
			DeleteFile(csFile);
			MessageBox
			(
				csReturned,
				_T("MOF compiler output"),
				MB_OK  | 	MB_ICONINFORMATION | MB_DEFBUTTON1 |
				MB_APPLMODAL);

		}
		else
		{
			if (bProcessReturn == 0)
			{
				CString csUserMsg;
				csUserMsg =  _T("MOF Wizard failure:  Can not get MOF compiler output from temporary file.");
				ErrorMsg
						(&csUserMsg, S_OK , NULL, TRUE, &csUserMsg, __FILE__,
						__LINE__);
				m_nImage = 0;
			}
			InvalidateControl();

		}
	}
	else
	{
		CString csErrorAsHex;
		CString csUserMsg;
		csUserMsg =  _T("MOF Wizard failure:  Could not get the CIMOM working directory.");
		csUserMsg += _T("  Could not run the MOF compiler.");

		ErrorMsg
				(&csUserMsg, S_OK , NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ );


	}

	InvalidateControl();

	if(dwProcessReturn == 0 && bProcessReturn)
	{
		WmiMofCkProcess();
	}

	SetFocus();
	SetModifiedFlag();

	return dwProcessReturn;
}

int CMOFCompCtrl::WmiMofCkProcess()
{
	if (GetMode() != CMOFCompCtrl::MODEBINARY || !m_bWMI)
	{
		return 0;
	}

	DWORD dwProcessReturn = 4;

	CString csWmiMofCk = GetWMIMofCkPathname();

	if (csWmiMofCk.GetLength() > 0)
	{
		CString csArg = csWmiMofCk;
		csArg += _T(" ");

		TCHAR szShortName[MAX_PATH];
		GetShortPathName(m_csBinaryMofFullPath, szShortName, MAX_PATH);

		csArg += _T(" \"");
		csArg += szShortName;
		csArg += _T("\"");
		PROCESS_INFORMATION pinfoWmiMofCk;

		CString csFile;
		if (GetMode() == MODEBINARY)
		{
			int n = m_csBinaryMofFullPath.ReverseFind('\\');
			csFile = m_csBinaryMofFullPath.Left(n);
			csFile += _T("\\TempStdOut");
		}
		else
		{
			int n = m_csMofFullPath.ReverseFind('\\');
			csFile = m_csMofFullPath.Left(n);
			csFile += _T("\\TempStdOut");
		}

		SECURITY_ATTRIBUTES saTemp;
		saTemp.nLength = sizeof(SECURITY_ATTRIBUTES);
		saTemp.lpSecurityDescriptor = NULL;
		saTemp.bInheritHandle = TRUE;

		HANDLE hTemp = CreateFile
						((LPCTSTR) csFile,
						GENERIC_WRITE,
						FILE_SHARE_WRITE,
						&saTemp,
						CREATE_ALWAYS,
						FILE_ATTRIBUTE_NORMAL,
						NULL);

		if (hTemp == INVALID_HANDLE_VALUE)
		{
			csArg.Empty();
			DWORD dwError = GetLastError();
			CString csErrorAsHex;
			csErrorAsHex.Format(_T("0x%x"),dwError);
			CString csUserMsg;
			csUserMsg =  _T("MOF Wizard failure:  Cannot create temporary file.");
			csUserMsg += _T("  \"CreateFile\" function call error code returned: ") + csErrorAsHex;
			csUserMsg += _T(".");
			ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ );
			m_nImage = 0;
			InvalidateControl();
			SetFocus();
			return dwProcessReturn;
		}

		STARTUPINFO sinfoWmiMofCk;
		sinfoWmiMofCk.cb = sizeof(sinfoWmiMofCk);
		sinfoWmiMofCk.lpReserved = NULL;
		sinfoWmiMofCk.lpDesktop = NULL;
		sinfoWmiMofCk.lpTitle = NULL;
		sinfoWmiMofCk.dwFlags = STARTF_USESTDHANDLES;
		sinfoWmiMofCk.cbReserved2 = 0;
		sinfoWmiMofCk.lpReserved2 = NULL;
		sinfoWmiMofCk.hStdInput = NULL;
		sinfoWmiMofCk.hStdOutput = (HANDLE) hTemp;
		sinfoWmiMofCk.hStdError = (HANDLE) hTemp;



		BOOL bReturn =
			CreateProcess(
					(LPCTSTR) csWmiMofCk,
					const_cast<TCHAR*>((LPCTSTR) csArg),
					NULL,
					NULL,
					TRUE,
					DETACHED_PROCESS,
					NULL,
					NULL,
					&sinfoWmiMofCk,
					&pinfoWmiMofCk);
		if (!bReturn)
		{
			csArg.Empty();
			CString csUserMsg;
			csUserMsg =  _T("MOF Wizard failure:  Cannot invoke the WmiMofCk.exe.  \"CreateProcess\" function call failed.");
			ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ - 17);
			CloseHandle(hTemp);
			m_nImage = 0;
			InvalidateControl();
			SetFocus();
			DeleteFile(csFile);
			return dwProcessReturn;
		}

		DWORD dwProcess =
			WaitForSingleObject(pinfoWmiMofCk.hProcess,INFINITE);

		csArg.Empty();
		if (dwProcess != WAIT_OBJECT_0)
		{
			CString csErrorAsHex;
			csErrorAsHex.Format(_T("0x%x"),dwProcess);
			CString csUserMsg;
			csUserMsg =  _T("MOF Wizard failure:  \"WaitForSingleObject\" function call failed with error code ");
			csUserMsg += csErrorAsHex + _T(".");
			ErrorMsg
					(&csUserMsg, S_OK , NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ - 8);
			m_nImage = 0;
			InvalidateControl();
			SetFocus();
			DeleteFile(csFile);
			return dwProcessReturn;
		}


		BOOL bProcessReturn =
			GetExitCodeProcess( pinfoWmiMofCk.hProcess,&dwProcessReturn );

		FlushFileBuffers(hTemp);
		CloseHandle(hTemp);
		FILE *fTmp = _tfopen ( (LPCTSTR) csFile, _T("r"));

		char szMofOutput[1000];
		CString csReturned;
		if(fTmp!= NULL)
		{
			while (fgets( szMofOutput, 999, fTmp))
			{
				csReturned += szMofOutput;
			}
			csReturned += _T("\n");
			fclose(fTmp);
			DeleteFile(csFile);
			MessageBox
			(
				csReturned,
				_T("Results of WMI syntax check"),
				MB_OK  | 	MB_ICONEXCLAMATION | MB_DEFBUTTON1 |
				MB_APPLMODAL);

		}
		else
		{
			if (bProcessReturn == 0)
			{
				CString csUserMsg;
				csUserMsg =  _T("MOF Wizard failure:  Can not get WmiMofCk.exe compiler output from temporary file.");
				ErrorMsg
						(&csUserMsg, S_OK , NULL, TRUE, &csUserMsg, __FILE__,
						__LINE__);
				m_nImage = 0;
			}
			InvalidateControl();

		}
	}
	else
	{
		CString csErrorAsHex;
		CString csUserMsg;
		csUserMsg =  _T("MOF Wizard failure:  Could not get the CIMOM working directory.");
		csUserMsg += _T("  Could not run WmiMofCk.exe.");

		ErrorMsg
				(&csUserMsg, S_OK , NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ );


	}

	InvalidateControl();

	SetFocus();
	SetModifiedFlag();

	return dwProcessReturn;
}


void CMOFCompCtrl::ProcessSwitches(CString &rcsArg)
{
	rcsArg += _T(" ");

	if (GetMode() == MODECHECK)
	{
		rcsArg += _T("-check ");
	}


	if (m_bClassSwitch)
	{
		if (m_nClassUpdateOnly)
		{
			rcsArg += _T("-class:createonly ");
		}

		if (m_nClassCreateOnly)
		{
			rcsArg += _T("-class:updateonly ");
		}
	}

	if (m_bInstanceSwitch)
	{
		if (m_nInstanceUpdateOnly)
		{
			rcsArg += _T("-instance:createonly ");
		}

		if (m_nInstanceCreateOnly)
		{
			rcsArg += _T("-instance:updateonly ");
		}
	}


	if (m_bNameSpaceSwitch && GetMode() == CMOFCompCtrl::MODECOMPILE)
	{
		if (m_csNameSpace.GetLength() > 0)
		{
			rcsArg += _T("-N:");
			rcsArg += m_csNameSpace;
			rcsArg += _T(" ");
		}

	}

	if (GetMode() == CMOFCompCtrl::MODEBINARY)
	{
			rcsArg += _T("-B:\"");
			rcsArg += m_csBinaryMofFullPath;
			rcsArg += _T("\" ");
	}

	rcsArg += _T(" ");


}

void CMOFCompCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	RelayEvent(WM_MOUSEMOVE, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));

	COleControl::OnMouseMove(nFlags, point);
}

int CMOFCompCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (m_ttip.Create(this))
		{
			m_ttip.Activate(TRUE);
			m_ttip.AddTool(this,_T("MOF Compiler"));
		}

	return 0;
}

void CMOFCompCtrl::RelayEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
      if (NULL != m_ttip.m_hWnd)
	  {
         MSG msg;

         msg.hwnd= m_hWnd;
         msg.message= message;
         msg.wParam= wParam;
         msg.lParam= lParam;
         msg.time= 0;
         msg.pt.x= LOWORD (lParam);
         msg.pt.y= HIWORD (lParam);

         m_ttip.RelayEvent(&msg);
     }
}

void CMOFCompCtrl::OnDestroy()
{
	COleControl::OnDestroy();

	delete m_pcilImageList;

}

void CMOFCompCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	SetFocus();
	OnActivateInPlace(TRUE,NULL);
	RelayEvent(WM_LBUTTONUP, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));

}

void CMOFCompCtrl::SetClassUpdateOnly(int nValue)
{
	m_nClassUpdateOnly = nValue;
	m_bClassSwitch = TRUE;
}

void CMOFCompCtrl::SetClassCreateOnly(int nValue)
{
	m_nClassCreateOnly = nValue;
	m_bClassSwitch = TRUE;
}

void CMOFCompCtrl::SetInstanceUpdateOnly(int nValue)
{
	m_nInstanceUpdateOnly = nValue;
	m_bInstanceSwitch = TRUE;
}

void CMOFCompCtrl::SetInstanceCreateOnly(int nValue)
{
	m_nInstanceCreateOnly = nValue;
	m_bInstanceSwitch = TRUE;
}


//***************************************************************************
//
// InitServices
//
// Purpose: Initialized Ole.
//
//***************************************************************************
IWbemLocator *CMOFCompCtrl::InitLocator()
{

	IWbemLocator *pLocator = NULL;
	SCODE sc  = CoCreateInstance(CLSID_WbemLocator,
							 0,
							 CLSCTX_INPROC_SERVER,
							 IID_IWbemLocator,
							 (LPVOID *) &pLocator);

	return pLocator;
}

IWbemServices *CMOFCompCtrl::GetIWbemServices
(CString &rcsNamespace)
{
	IUnknown *pServices = NULL;

	BOOL bUpdatePointer= FALSE;

	m_sc = S_OK;
	m_bUserCancel = FALSE;

	VARIANT varUpdatePointer;
	VariantInit(&varUpdatePointer);
	varUpdatePointer.vt = VT_I4;
	if (bUpdatePointer == TRUE)
	{
		varUpdatePointer.lVal = 1;
	}
	else
	{
		varUpdatePointer.lVal = 0;
	}

	VARIANT varService;
	VariantInit(&varService);

	VARIANT varSC;
	VariantInit(&varSC);

	VARIANT varUserCancel;
	VariantInit(&varUserCancel);

	FireGetIWbemServices
		((LPCTSTR)rcsNamespace,  &varUpdatePointer,  &varService, &varSC,
		&varUserCancel);

	if (varService.vt == VT_UNKNOWN)
	{
		pServices = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}

	varService.punkVal = NULL;

	VariantClear(&varService);

	if (varSC.vt == VT_I4)
	{
		m_sc = varSC.lVal;
	}
	else
	{
		m_sc = WBEM_E_FAILED;
	}

	VariantClear(&varSC);

	if (varUserCancel.vt == VT_BOOL)
	{
		m_bUserCancel = varUserCancel.boolVal;
	}

	VariantClear(&varUserCancel);

	VariantClear(&varUpdatePointer);

	IWbemServices *pRealServices = NULL;
	if (m_sc == S_OK && !m_bUserCancel)
	{
		pRealServices = reinterpret_cast<IWbemServices *>(pServices);
	}

	return pRealServices;
}

void CMOFCompCtrl::InvokeHelp()
{
	// TODO: Add your message handler code here and/or call default

	CString csPath;
	WbemRegString(SDK_HELP, csPath);


	CString csData = m_csHelpUrl;


	HWND hWnd = NULL;

	try
	{
		HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD_PTR) (LPCTSTR) csData);
		if (!hWnd)
		{
			CString csUserMsg;
			csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");

			ErrorMsg
					(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		}

	}

	catch( ... )
	{
		// Handle any exceptions here.
		CString csUserMsg;
		csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");

		ErrorMsg
				(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
	}


}

LRESULT CMOFCompCtrl::DoMofCompile(WPARAM, LPARAM)
{
	if (InterlockedIncrement(&gCountWizards) > 1)
	{
			CString csUserMsg =
					_T("Only one \"MOF Compiler Wizard\" can run at a time.");
			ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__);
			InterlockedDecrement(&gCountWizards);
			return FALSE;
	}

	if (m_pPropertySheet)
	{
		delete m_pPropertySheet;
		m_pPropertySheet = NULL;
	}

	m_pPropertySheet = new
						CMyPropertySheet(this);


	PreModalDialog();

	m_pPropertySheet->DoModal();


	PostModalDialog();

	SetFocus();

	delete m_pPropertySheet;
	m_pPropertySheet = NULL;

	InterlockedDecrement(&gCountWizards);

	return 0;
}

LRESULT CMOFCompCtrl::NamespaceModified(WPARAM, LPARAM)
{
	if (GetMode() == CMOFCompCtrl::MODEBINARY)
	{
		return 0;
	}

	m_nFireEventCounter = m_nFireEventCounter + 1;

	if (m_nFireEventCounter == 2)
	{
		FireModifiedNamespace(m_csNameSpace);
	}
	else if (m_nFireEventCounter < 2)
	{
		PostMessage(MODNAMESPACE,0,0);
	}

	return 0;
}



BOOL CMOFCompCtrl::PreCreateWindow(CREATESTRUCT& cs)
{
	 // Add the Transparent style to the control
	 cs.dwExStyle |= WS_EX_TRANSPARENT;

	 return COleControl::PreCreateWindow(cs);
}



BOOL CMOFCompCtrl::OnEraseBkgnd(CDC* pDC)
{
	 // This is needed for transparency and the correct drawing...
	 CWnd*  pWndParent;       // handle of our parent window
	 POINT  pt;

	 pWndParent = GetParent();
	 pt.x       = 0;
	 pt.y       = 0;

	 MapWindowPoints(pWndParent, &pt, 1);
	 OffsetWindowOrgEx(pDC->m_hDC, pt.x, pt.y, &pt);
	 ::SendMessage(pWndParent->m_hWnd, WM_ERASEBKGND,
				  (WPARAM)pDC->m_hDC, 0);
	 SetWindowOrgEx(pDC->m_hDC, pt.x, pt.y, NULL);

	 return 1;
}

void CMOFCompCtrl::OnSetClientSite()
{
	 m_bAutoClip = TRUE;

	 COleControl::OnSetClientSite();
}

void CMOFCompCtrl::OnKillFocus(CWnd* pNewWnd)
{
	COleControl::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	OnActivateInPlace(FALSE,NULL);
	m_nImage = 0;
	InvalidateControl();

}

void CMOFCompCtrl::OnSetFocus(CWnd* pOldWnd)
{
	COleControl::OnSetFocus(pOldWnd);

		// TODO: Add your message handler code here
	OnActivateInPlace(TRUE,NULL);
	m_nImage = 1;
	InvalidateControl();

}

BOOL CMOFCompCtrl::PreTranslateMessage(MSG* lpMsg)
{
	// TODO: Add your specialized code here and/or call the base class

	BOOL bDidTranslate;

	bDidTranslate = COleControl::PreTranslateMessage(lpMsg);

	if (bDidTranslate)
	{
		return bDidTranslate;
	}

	if  (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_RETURN)
	{
		PostMessage(DOMOFCOMPILE,0,0);
	}


	if ((lpMsg->message == WM_KEYUP || lpMsg->message == WM_KEYDOWN) &&
		lpMsg->wParam == VK_TAB)
	{
		return FALSE;
	}

	return PreTranslateInput (lpMsg);
}

void CMOFCompCtrl::OnMove(int x, int y)
{
	COleControl::OnMove(x, y);

	// TODO: Add your message handler code here
	InvalidateControl();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\mofcompppg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MOFCompPpg.cpp : Implementation of the CMOFCompPropPage property page class.

#include "precomp.h"
#include "MOFComp.h"
#include "MOFCompPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMOFCompPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMOFCompPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CMOFCompPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMOFCompPropPage, "WBEM.MOFCompPropPage.1",
	0xb2345984, 0x5cf9, 0x11d0, 0x95, 0xfd, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// CMOFCompPropPage::CMOFCompPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CMOFCompPropPage

BOOL CMOFCompPropPage::CMOFCompPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_MOFCOMP_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CMOFCompPropPage::CMOFCompPropPage - Constructor

CMOFCompPropPage::CMOFCompPropPage() :
	COlePropertyPage(IDD, IDS_MOFCOMP_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CMOFCompPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CMOFCompPropPage::DoDataExchange - Moves data between page and properties

void CMOFCompPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CMOFCompPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CMOFCompPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\mofcompppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MOFCompPpg.h : Declaration of the CMOFCompPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CMOFCompPropPage : See MOFCompPpg.cpp.cpp for implementation.

class CMOFCompPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CMOFCompPropPage)
	DECLARE_OLECREATE_EX(CMOFCompPropPage)

// Constructor
public:
	CMOFCompPropPage();

// Dialog Data
	//{{AFX_DATA(CMOFCompPropPage)
	enum { IDD = IDD_PROPPAGE_MOFCOMP };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CMOFCompPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls
#include <Afxdisp.h>

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#endif //_UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\nsentry.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_NSENTRY_H__ACAE7612_B1C7_11D0_9624_00C04FD9B15B__INCLUDED_)
#define AFX_NSENTRY_H__ACAE7612_B1C7_11D0_9624_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CNSEntry wrapper class

class CNSEntry : public CWnd
{
protected:
	DECLARE_DYNCREATE(CNSEntry)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xc3db0bd3, 0x7ec7, 0x11d0, { 0x96, 0xb, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	long GetMaxDroppedWidth();
	void SetMaxDroppedWidth(long);
	CString GetFontName();
	void SetFontName(LPCTSTR);
	long GetFontWidth();
	void SetFontWidth(long);
	long GetFontHeight();
	void SetFontHeight(long);
	long GetComponentStructure();
	void SetComponentStructure(long);
	OLE_COLOR GetBackColor();
	void SetBackColor(OLE_COLOR);
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);

// Operations
public:
	//SCODE OpenNamespace(LPCTSTR bstrNamespace, BOOL boolNoFireEvent);
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NSENTRY_H__ACAE7612_B1C7_11D0_9624_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\mypropertypage1.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MyPropertyPage1.cpp : implementation file
//

#include "precomp.h"
#include <nddeapi.h>
#include <initguid.h>
#include "wbemidl.h"
#include "resource.h"
#include "MyPropertyPage1.h"
#include <fstream.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <direct.h>
#include <SHLOBJ.H>
#include <afxcmn.h>
#include "MyPropertySheet.h"
#include "MOFComp.h"
#include "MOFCompCtl.h"
#include "LoginDlg.h"
#include "HTMTopics.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define IDH_actx_WBEM_Developer_Studio 200
#define IDC_NSENTRY 333

IMPLEMENT_DYNCREATE(CMyPropertyPage1, CPropertyPage)
IMPLEMENT_DYNCREATE(CMyPropertyPage2, CPropertyPage)
IMPLEMENT_DYNCREATE(CMyPropertyPage3, CPropertyPage)



CString GetHmomWorkingDirectory()
{
	CString csHmomWorkingDir;
	HKEY hkeyLocalMachine;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hkeyLocalMachine);
	if (lResult != ERROR_SUCCESS) {
		return "";
	}




	HKEY hkeyHmomCwd;

	lResult = RegOpenKeyEx(
				hkeyLocalMachine,
				_T("SOFTWARE\\Microsoft\\Wbem\\CIMOM"),
				0,
				KEY_READ | KEY_QUERY_VALUE,
				&hkeyHmomCwd);

	if (lResult != ERROR_SUCCESS) {
		RegCloseKey(hkeyLocalMachine);
		return "";
	}





	unsigned long lcbValue = 1024;
	LPTSTR pszWorkingDir = csHmomWorkingDir.GetBuffer(lcbValue);


	unsigned long lType;
	lResult = RegQueryValueEx(
				hkeyHmomCwd,
				_T("Working Directory"),
				NULL,
				&lType,
				(unsigned char*) (void*) pszWorkingDir,
				&lcbValue);


	csHmomWorkingDir.ReleaseBuffer();
	RegCloseKey(hkeyHmomCwd);
	RegCloseKey(hkeyLocalMachine);

	CString csOut;

	if (lResult == ERROR_SUCCESS)
	{
		csOut = ExpandEnvironmentStrings(csHmomWorkingDir);
	}

	return csOut;
}

BOOL VerifyWmiMofCkExists(CString &csPath)
{
	if (csPath.GetLength() <= 0)
		return FALSE;

	csPath += _T("\\WmiMofCk.exe");
	return (0xFFFFFFFF != GetFileAttributes(csPath));
}

CString GetRegStringValue(HKEY hkeyRoot, LPCTSTR szKey, LPCTSTR szValue)
{
	CString sz;
	HKEY hkey;
	LONG lResult = RegOpenKeyEx(hkeyRoot, szKey, 0, KEY_READ | KEY_QUERY_VALUE, &hkey);
	if (lResult == ERROR_SUCCESS)
	{
		// Get value from from registry
		TCHAR szTemp[MAX_PATH];
		DWORD cbTemp = sizeof(szTemp);
		DWORD dw;
		lResult = RegQueryValueEx(hkey, szValue, NULL,
			&dw, (LPBYTE)szTemp, &cbTemp);
		if(		ERROR_SUCCESS == lResult
			&&	(REG_SZ == dw || REG_EXPAND_SZ == dw) )
		{
			sz = szTemp;
		}
		RegCloseKey(hkey);
	}
	return sz;
}

CString GetWMIMofCkPathname()
{
	CString csWmiMofCk;

	// Try DDK directory 1
	csWmiMofCk = GetRegStringValue(HKEY_CURRENT_USER, _T("SOFTWARE\\Microsoft\\NTDDK\\Directories"), _T("Install Dir"));
	csWmiMofCk += _T("\\bin");
	if(VerifyWmiMofCkExists(csWmiMofCk))
		return csWmiMofCk;

	// Try DDK directory 2
	csWmiMofCk = GetRegStringValue(HKEY_CURRENT_USER, _T("SOFTWARE\\Microsoft\\NTDDK\\Directory"), _T("Install Dir"));
	csWmiMofCk += _T("\\bin");
	if(VerifyWmiMofCkExists(csWmiMofCk))
		return csWmiMofCk;

	// Try DDK directory 3
	csWmiMofCk = GetRegStringValue(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\NTDDK\\Directories"), _T("Install Dir"));
	csWmiMofCk += _T("\\bin");
	if(VerifyWmiMofCkExists(csWmiMofCk))
		return csWmiMofCk;

	// Try DDK directory 4
	csWmiMofCk = GetRegStringValue(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\NTDDK\\Directory"), _T("Install Dir"));
	csWmiMofCk += _T("\\bin");
	if(VerifyWmiMofCkExists(csWmiMofCk))
		return csWmiMofCk;

	// Try WBEM directory
	csWmiMofCk = GetHmomWorkingDirectory();
	if(VerifyWmiMofCkExists(csWmiMofCk))
		return csWmiMofCk;

	csWmiMofCk = _T("");
	return csWmiMofCk;
}

BOOL TryToFindDirectory(CString *pcsDir)
{

	if (pcsDir->GetLength() < 3 && pcsDir->GetLength() >= 2 && (*pcsDir)[1] == ':')
	{
		UINT  uDriveType = GetDriveType((LPCTSTR) *pcsDir);

		if (!(uDriveType == DRIVE_UNKNOWN  || uDriveType ==DRIVE_NO_ROOT_DIR))
		{
			return TRUE;
		}
	}

	WIN32_FIND_DATA wfdFile;
	HANDLE hFile =
		FindFirstFile(
			(LPCTSTR) *pcsDir, &wfdFile);

	int n = pcsDir->ReverseFind('\\');

	CString csFile;

	if (n == -1)
	{
		csFile = *pcsDir;
	}
	else
	{
		csFile = pcsDir->Right((pcsDir->GetLength() - 1) - n);
	}


	if (csFile.CompareNoCase(wfdFile.cFileName) != 0)
	{
		return FALSE;
	}

	if (hFile == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	BOOL bValue = wfdFile.dwFileAttributes && FILE_ATTRIBUTE_DIRECTORY;

	return wfdFile.dwFileAttributes && FILE_ATTRIBUTE_DIRECTORY;
}

BOOL TryToCreateDirectory (CString &csOutputDir, int nIndex)
{
	CString csDir;
	CString Next;

	CString csSearch = csOutputDir.Mid(nIndex);
	int n = csSearch.Find('\\');
	if (n == -1)
	{
		n = csOutputDir.GetLength();
	}

	csDir = csOutputDir.Left(n + nIndex);
	BOOL bReturn = CreateDirectory((LPCTSTR) csDir, NULL);
	if (n == csOutputDir.GetLength())
	{
		return bReturn;
	}
	else
	{
		return TryToCreateDirectory (csOutputDir, n + nIndex + 1);
	}


}

BOOL IsDriveValid(CWnd *pcwnd, CString *pcsDir, BOOL bRetry)
{
	BOOL bDriveSpecifier;
	CString csDrive;
	int iLen = pcsDir -> GetLength();

	if (iLen >= 3)
	{
		csDrive = pcsDir->Left(3);
	}
	else if (iLen == 2)
	{
		csDrive = pcsDir->Left(2) + '\\';
	}

	bDriveSpecifier = IsDriveSpecifier(csDrive);

	if (bDriveSpecifier && csDrive[2] != '\\')
	{
		csDrive.SetAt(2,'\\');
	}

	if (bDriveSpecifier)
	{
		UINT  uDriveType = GetDriveType(csDrive);

		if (!(uDriveType == DRIVE_UNKNOWN  || uDriveType == DRIVE_NO_ROOT_DIR || uDriveType == DRIVE_CDROM))
		{
			CString csFile = csDrive + _T("f45b789");
			SECURITY_ATTRIBUTES saTemp;
			saTemp.nLength = sizeof(SECURITY_ATTRIBUTES);
			saTemp.lpSecurityDescriptor = NULL;
			saTemp.bInheritHandle = TRUE;

			HANDLE hTemp = CreateFile
							((LPCTSTR) csFile,
							GENERIC_WRITE,
							FILE_SHARE_WRITE,
							&saTemp,
							CREATE_ALWAYS,
							FILE_ATTRIBUTE_NORMAL,
							NULL);

			if (hTemp == INVALID_HANDLE_VALUE)
			{
				if (!bRetry)
				{
					return FALSE;
				}

				CString csPrompt = _T("Drive ") + csDrive + _T(" may not be ready.");
				int nReturn =
				pcwnd -> MessageBox
				( csPrompt,
				_T("Retry or Cancel"),
				MB_ICONQUESTION | MB_RETRYCANCEL  |
				MB_APPLMODAL);
				if (nReturn == IDRETRY)
				{
					return IsDriveValid(pcwnd, &csDrive, bRetry);
				}
				else
				{
					return FALSE;
				}
			}

			FlushFileBuffers(hTemp);
			CloseHandle(hTemp);

			BOOL bDelete = DeleteFile(csFile);
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

	return TRUE;
}

int TryToCreateDirectory
(CWnd *pcwnd, CString &csOutputDir, CString *pcsErrorMsg)
{
	CString csPrompt;
	csPrompt = _T("Directory \"") + csOutputDir + _T("\" does not exist.  ");
	csPrompt += _T("Do you wish to create it?");
	int nReturn =
		pcwnd -> MessageBox
		( csPrompt,
		_T("Create Directory?"),
		MB_YESNO  | MB_ICONQUESTION | MB_DEFBUTTON1 |
		MB_APPLMODAL);
	if (nReturn == IDYES)
	{
		BOOL bReturn = CreateDirectory((LPCTSTR) csOutputDir, NULL);
		if (!bReturn)
		{
			BOOL bReturn = TryToCreateDirectory (csOutputDir,0);
			if (bReturn)
			{
				return IDYES;
			}
			else
			{
				if (!bReturn)
				{
					CString csUserMsg;
					csUserMsg =  _T("Could not create directory \"") + csOutputDir + _T("\".");
					csUserMsg += *pcsErrorMsg;
					ErrorMsg
						(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
						__LINE__ );

				}
				return IDNO;
			}
		}
		else
		{
			return IDYES;
		}
	}
	else
	{
		return IDNO;
	}
}

BOOL IsDriveSpecifier(CString &rcsPath)
{
	int n = rcsPath.GetLength();

	if (n != 3 && n != 2)
	{
		return FALSE;
	}
	else if ((rcsPath[0] >= 'a' && rcsPath[0] <= 'z' ||
				rcsPath[0] >= 'A' && rcsPath[0] <= 'Z') &&
				rcsPath[1] == ':')

	{
		if (n == 2)
		{
			return TRUE;
		}
		else
		{
			return rcsPath[2] == '\\';
		}
	}

	return FALSE;

}


BOOL IsRelativePath(CString &rcsPath)
{
	int n = rcsPath.GetLength();

	if (n == 0)
	{
		return FALSE;
	}

	if (n == 1)
	{
		return TRUE;

	}

	if (rcsPath[0] == '\\')
	{
		return FALSE;
	}

	CString csPath;

	if (n >= 3)
	{
		csPath = rcsPath.Left(3);
	}
	else if (n == 2)
	{
		csPath = rcsPath.Left(2);
	}

	if (IsDriveSpecifier(csPath))
	{
		return FALSE;
	}

	return TRUE;
}

int GetCBitmapWidth(const CBitmap & cbm)
{

	BITMAP bm;
	cbm.GetObject(sizeof(BITMAP),&bm);
	return bm.bmWidth;
}

int GetCBitmapHeight(const CBitmap & cbm)
{
	BITMAP bm;
	cbm.GetObject(sizeof(BITMAP),&bm);
	return bm.bmHeight;
}


HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPCTSTR lpString,
                           HPALETTE FAR* lphPalette)
{
    HRSRC  hRsrc;
    HGLOBAL hGlobal;
    HBITMAP hBitmapFinal = NULL;
    LPBITMAPINFOHEADER  lpbi;
    HDC hdc;
    int iNumColors;

    if (hRsrc = FindResource(hInstance, lpString, RT_BITMAP))
       {
       hGlobal = LoadResource(hInstance, hRsrc);
       lpbi = (LPBITMAPINFOHEADER)LockResource(hGlobal);

       hdc = GetDC(NULL);
       *lphPalette =  CreateDIBPalette ((LPBITMAPINFO)lpbi, &iNumColors);
       if (*lphPalette)
          {
          SelectPalette(hdc,*lphPalette,FALSE);
          RealizePalette(hdc);
          }

       hBitmapFinal = CreateDIBitmap(hdc,
                   (LPBITMAPINFOHEADER)lpbi,
                   (LONG)CBM_INIT,
                   (LPSTR)lpbi + lpbi->biSize + iNumColors *
sizeof(RGBQUAD),

                   (LPBITMAPINFO)lpbi,
                   DIB_RGB_COLORS );

       ReleaseDC(NULL,hdc);
       UnlockResource(hGlobal);
       FreeResource(hGlobal);
       }
    return (hBitmapFinal);
}

HPALETTE CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors)
{
   LPBITMAPINFOHEADER  lpbi;
   LPLOGPALETTE     lpPal;
   HANDLE           hLogPal;
   HPALETTE         hPal = NULL;
   int              i;

   lpbi = (LPBITMAPINFOHEADER)lpbmi;
   if (lpbi->biBitCount <= 8)
       *lpiNumColors = (1 << lpbi->biBitCount);
   else
       *lpiNumColors = 0;  // No palette needed for 24 BPP DIB

   if (*lpiNumColors)
      {
      hLogPal = GlobalAlloc (GHND, sizeof (LOGPALETTE) +
                             sizeof (PALETTEENTRY) * (*lpiNumColors));
      lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
      lpPal->palVersion    = 0x300;
      lpPal->palNumEntries = (WORD)*lpiNumColors; // NOTE: lpiNumColors should NEVER be greater than 256 (1<<8 from above)

      for (i = 0;  i < *lpiNumColors;  i++)
         {
         lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
         lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
         lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
         lpPal->palPalEntry[i].peFlags = 0;
         }
      hPal = CreatePalette (lpPal);
      GlobalUnlock (hLogPal);
      GlobalFree   (hLogPal);
   }
   return hPal;
}

BOOL StringInArray
(CStringArray *&rpcsaArrays, CString *pcsString, int nIndex)
{
	for (int i = 0; i < rpcsaArrays[nIndex].GetSize(); i++)
	{
		if (pcsString->CompareNoCase(rpcsaArrays[nIndex].GetAt(i)) == 0)
		{
			return TRUE;
		}

	}

	return FALSE;

}
void InitializeLogFont
(LOGFONT &rlfFont, CString csName, int nHeight, int nWeight)
{
	_tcscpy(rlfFont.lfFaceName, (LPCTSTR) csName);
	rlfFont.lfWeight = nWeight;
	rlfFont.lfHeight = nHeight;
	rlfFont.lfEscapement = 0;
	rlfFont.lfOrientation = 0;
	rlfFont.lfWidth = 0;
	rlfFont.lfItalic = FALSE;
	rlfFont.lfUnderline = FALSE;
	rlfFont.lfStrikeOut = FALSE;
	rlfFont.lfCharSet = ANSI_CHARSET;
	rlfFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
	rlfFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	rlfFont.lfQuality = DEFAULT_QUALITY;
	rlfFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
}


CRect OutputTextString
(CPaintDC *pdc, CWnd *pcwnd, CString *pcsTextString, int x, int y,
 CString *pcsFontName = NULL, int nFontHeight = 0, int nFontWeigth = 0)
{
	CRect crReturn;
	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont cfFont;
	CFont* pOldFont = NULL;
	TEXTMETRIC tmFont;

	if (pcsFontName)
	{
		LOGFONT lfFont;
		InitializeLogFont
			(lfFont, *pcsFontName, nFontHeight * 10, nFontWeigth);

		cfFont.CreatePointFontIndirect(&lfFont, pdc);

		pOldFont = pdc -> SelectObject( &cfFont );
	}

	pdc->GetTextMetrics(&tmFont);

	pdc->SetBkMode( TRANSPARENT );

	pdc->TextOut( x, y, *pcsTextString, pcsTextString->GetLength());

	CSize csText = pdc->GetTextExtent( *pcsTextString);

	crReturn.TopLeft().x = x;
	crReturn.TopLeft().y = y;
	crReturn.BottomRight().x = x + csText.cx;
	crReturn.BottomRight().y = y + csText.cy;

	pdc->SetBkMode( OPAQUE );

	if (pcsFontName)
	{
		pdc -> SelectObject(pOldFont);
	}

	 return crReturn;
}

void OutputTextString
(CPaintDC *pdc, CWnd *pcwnd, CString *pcsTextString, int x, int y,
 CRect &crExt, CString *pcsFontName = NULL, int nFontHeight = 0,
 int nFontWeigth = 0)
{

	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont cfFont;
	CFont* pOldFont = NULL;

	if (pcsFontName)
	{
		LOGFONT lfFont;
		InitializeLogFont
			(lfFont, *pcsFontName, nFontHeight * 10, nFontWeigth);

		cfFont.CreatePointFontIndirect(&lfFont, pdc);

		pOldFont = pdc -> SelectObject( &cfFont );
	}

	pdc->SetBkMode( TRANSPARENT );

	CRect crBounds(x,y,x + crExt.Width(), y + crExt.Height());
	pdc->DrawText(*pcsTextString, crBounds,DT_WORDBREAK);

	pdc->SetBkMode( OPAQUE );

	if (pcsFontName)
	{
		pdc -> SelectObject(pOldFont);
	}

	 return;
}


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage1 property page

CMyPropertyPage1::CMyPropertyPage1() : CPropertyPage(CMyPropertyPage1::IDD)
{
	//{{AFX_DATA_INIT(CMyPropertyPage1)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pParent = NULL;
	m_bInitDraw = TRUE;
}

CMyPropertyPage1::~CMyPropertyPage1()
{

}

void CMyPropertyPage1::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyPropertyPage1)
	DDX_Control(pDX, IDC_STATICWHATTODO, m_staticWhatDo);
	DDX_Control(pDX, IDC_STATICMAIN, m_staticMainExt);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyPropertyPage1, CPropertyPage)
	//{{AFX_MSG_MAP(CMyPropertyPage1)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	ON_BN_CLICKED(IDC_RADIO1, OnRadio1)
	ON_BN_CLICKED(IDC_RADIO2, OnRadio2)
	ON_BN_CLICKED(IDC_RADIO3, OnRadioBinary)
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage2 property page

CMyPropertyPage2::CMyPropertyPage2() : CPropertyPage(CMyPropertyPage2::IDD)
{
	//{{AFX_DATA_INIT(CMyPropertyPage2)
	m_nClassUpdateOptions = 0;
	m_nInstanceUpdateOptions = 0;
	//}}AFX_DATA_INIT

	m_pParent = NULL;
	m_bInitDraw = TRUE;
	m_bFirstActivate = TRUE;
	m_bRanCompiler = FALSE;

}

CMyPropertyPage2::~CMyPropertyPage2()
{

}

void CMyPropertyPage2::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyPropertyPage2)
	DDX_Control(pDX, IDC_STATIC3, m_staticTextExt);
	DDX_Radio(pDX, IDC_RADIOCREATEANDCHANGECLASS, m_nClassUpdateOptions);
	DDX_Radio(pDX, IDC_RADIOCREATEANDCHANGEINSTANCES, m_nInstanceUpdateOptions);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyPropertyPage2, CPropertyPage)
	//{{AFX_MSG_MAP(CMyPropertyPage2)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage2 property page

CMyPropertyPage3::CMyPropertyPage3() : CPropertyPage(CMyPropertyPage3::IDD)
{
	//{{AFX_DATA_INIT(CMyPropertyPage3)
	//}}AFX_DATA_INIT

	m_pParent = NULL;
	m_bInitDraw = TRUE;
	m_bFirstActivate = TRUE;
	m_bNTLM = TRUE;
	m_bWBEM = TRUE;
	m_pLocator = NULL;

}

CMyPropertyPage3::~CMyPropertyPage3()
{
	if (m_pLocator)
	{
		m_pLocator->Release();
	}
}

void CMyPropertyPage3::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyPropertyPage3)
	DDX_Control(pDX, IDC_BUTTON1, m_cbBrowse);
	DDX_Control(pDX, IDC_CHECKWMI, m_cbWMI);
	DDX_Control(pDX, IDC_NAMESPACE, m_csNamespace);
	DDX_Control(pDX, IDC_EDITBINARYMOFDIRECTORY, m_ceBinaryMofDirectory);
	DDX_Control(pDX, IDC_BINARYMOFDIRECTORY, m_csBinaryMofDirectory);
	DDX_Control(pDX, IDC_BUTTON2, m_cbBinaryMofDirectory);
	DDX_Control(pDX, IDC_BUTTONCREDENTIALS, m_cbCredentials);
	DDX_Control(pDX, IDC_STATIC4, m_staticTextExt);
	DDX_Control(pDX, IDC_EDIT2, m_ceNameSpace);
	DDX_Control(pDX, IDC_EDIT3, m_ceMofFilePath);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyPropertyPage3, CPropertyPage)
	//{{AFX_MSG_MAP(CMyPropertyPage3)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	ON_BN_CLICKED(IDC_BUTTON1, OnButtonBrowse)
	ON_BN_CLICKED(IDC_BUTTONCREDENTIALS, OnButtoncredentials)
	ON_BN_CLICKED(IDC_BUTTON2, OnButtonBinaryMofDirectory)
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()



int CMyPropertyPage1::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;
}

void CMyPropertyPage1::OnDestroy()
{
	CPropertyPage::OnDestroy();

	// TODO: Add your message handler code here

}

void CMyPropertyPage1::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_BITMAPMAINABR,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );


	CRect rcMainExt;
	m_staticMainExt.GetWindowRect(&rcMainExt);
	ScreenToClient(rcMainExt);

	CRect rcWhatDoExt;
	m_staticWhatDo.GetWindowRect(&rcWhatDoExt);
	ScreenToClient(rcWhatDoExt);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{
			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,FALSE);

			dc.RealizePalette();

			dc.FillRect(&rcMainExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcMainExt, rcMainExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame(	rcMainExt.TopLeft().x,
					rcMainExt.TopLeft().y,
					rcMainExt.BottomRight().x,
					rcMainExt.BottomRight().y);

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));

	CString csFont = _T("MS Shell Dlg");


	CString csOut = _T("Welcome to the");

	CRect crOut = OutputTextString
		(&dc, this, &csOut, rcWhatDoExt.TopLeft().x - 15 , 54, &csFont, 8, FW_BOLD);

	csOut = _T("MOF Compiler Wizard");

	csFont = _T("MS Shell Dlg");

	crOut =  OutputTextString
		(&dc, this, &csOut, rcWhatDoExt.TopLeft().x, crOut.BottomRight().y + 8,
		&csFont, 16, FW_BOLD);

	CRect crText;
	crText.TopLeft().x = crOut.TopLeft().x;
	crText.TopLeft().y = crOut.BottomRight().y + 15;
	crText.BottomRight().x = rcMainExt.BottomRight().x;
	crText.BottomRight().y = rcMainExt.TopLeft().y;

	csOut = _T("You can use this wizard to compile a .MOF file and load it into a namespace, to check the syntax of a .MOF file without compiling or loading it, or ");
	csOut += _T("to create a binary .MOF file which can be loaded into a repository at some future time.");

	csFont = _T("MS Shell Dlg");

	OutputTextString
		(&dc, this, &csOut, crText.TopLeft().x , crText.TopLeft().y, crText,
		&csFont, 8, FW_NORMAL);

	csOut = _T("What do you want to do?");

	crOut =  OutputTextString
		(&dc, this, &csOut, rcWhatDoExt.TopLeft().x, rcWhatDoExt.TopLeft().y,
		&csFont, 8, FW_BOLD);


}

BOOL CMyPropertyPage1::OnSetActive()
{
	// TODO: Add your specialized code here and/or call the base class
	BOOL bReturn = CPropertyPage::OnSetActive();

	m_pParent->m_Page1.SetWindowText(_T("MOF Compiler"));
	m_pParent->SetWizardButtons(PSWIZB_NEXT);
	CWnd *pBack = GetParent()->GetDlgItem(ID_WIZBACK);
	if (pBack)
	{
		pBack->ShowWindow(SW_HIDE);
	}

	CButton *pcbCompile =
		reinterpret_cast<CButton *>(GetDlgItem(IDC_RADIO1));

	CButton *pcbSyntax =
	reinterpret_cast<CButton *>(GetDlgItem(IDC_RADIO2));

	if (m_bInitDraw)
	{
		m_bInitDraw = FALSE;

		m_pParent->m_pParent->m_bInitDraw = FALSE;
		m_pParent->m_pParent->m_bClassSwitch = FALSE;
		m_pParent->m_pParent->m_bInstanceSwitch = FALSE;
		m_pParent->m_pParent->SetMode(CMOFCompCtrl::MODECOMPILE);
		m_pParent->m_pParent->m_bNameSpaceSwitch = FALSE;


		m_pParent->m_pParent->m_nClassUpdateOnly = 0;
		m_pParent->m_pParent->m_nClassCreateOnly = 0;
		m_pParent->m_pParent->m_nInstanceUpdateOnly = 0;
		m_pParent->m_pParent->m_nInstanceCreateOnly = 0;

		pcbCompile->SetCheck(TRUE);
		pcbSyntax->SetCheck(FALSE);
	}


	return bReturn;
}

int CMyPropertyPage2::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;
}

void CMyPropertyPage2::OnDestroy()
{
	CPropertyPage::OnDestroy();

	// TODO: Add your message handler code here

}

void CMyPropertyPage2::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_BITMAPPAGE,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );


	CRect rcMainExt;
	m_staticTextExt.GetWindowRect(&rcMainExt);
	ScreenToClient(rcMainExt);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{
			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,FALSE);

			dc.RealizePalette();

			CRect rcBitmap(0, 0, m_nBitmapW, m_nBitmapH);
			dc.FillRect(&rcMainExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcMainExt, rcMainExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame(	rcMainExt.TopLeft().x,
					rcMainExt.TopLeft().y,
					rcMainExt.BottomRight().x,
					rcMainExt.BottomRight().y);

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));


	CString csFont = _T("MS Shell Dlg");


	CString csOut = _T(" Specify update options");

	CRect crOut = OutputTextString
		(&dc, this, &csOut, 8, 1, &csFont, 8, FW_BOLD);

	if (m_pParent->m_pParent->GetMode() == CMOFCompCtrl::MODECOMPILE)
	{
		csOut = _T("You can choose whether the data in the .MOF file should modify the classes and instances already in");

		csOut += _T(" the namespace or choose whether new classes or instances defined in the .MOF file should be added");

		csOut += _T(" to the namespace.  Click \"Finish\" to compile the .MOF ");

		csOut += _T("and load it into the namespace.");
	}
	else
	{
		csOut = _T("You can choose whether the data in the .MOF file should modify the classes and instances already in");

		csOut += _T(" the namespace or choose whether new classes or instances defined in the .MOF file should be added");

		csOut += _T(" to the namespace when the binary .MOF is loaded into the repository.  Click \"Finish\" to create the binary .MOF.");
	}

	CPoint cpRect(crOut.TopLeft().x + 15, crOut.BottomRight().y + 1);

	crOut.TopLeft().x = 0;
	crOut.TopLeft().y = 0;
	crOut.BottomRight().x = rcMainExt.BottomRight().x - cpRect.x;
	crOut.BottomRight().y = rcMainExt.BottomRight().y - cpRect.y;

	OutputTextString
		(&dc, this, &csOut, cpRect.x, cpRect.y, crOut, &csFont, 8, FW_NORMAL);

}


BOOL CMyPropertyPage2::OnSetActive()
{
	// TODO: Add your specialized code here and/or call the base class
	BOOL bReturn = CPropertyPage::OnSetActive();

	m_pParent->m_pParent->m_nFireEventCounter = 0;

	m_pParent->m_Page2.SetWindowText(_T("MOF Compiler - Compile a .MOF File"));
	m_pParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
	CWnd *pBack = GetParent()->GetDlgItem(ID_WIZBACK);

	if (pBack)
	{
		pBack->ShowWindow(SW_SHOW);
	}

	if (m_bFirstActivate == TRUE)
	{
		m_bFirstActivate = FALSE;
		m_nClassUpdateOptions = 0;
		m_pParent->m_pParent->SetClassCreateOnly(0);
		m_pParent->m_pParent->SetClassUpdateOnly(0);
		m_nInstanceUpdateOptions = 0;
		m_pParent->m_pParent->SetInstanceCreateOnly(0);
		m_pParent->m_pParent->SetInstanceUpdateOnly(0);
		UpdateData(FALSE);
	}


	return bReturn;
}

LRESULT CMyPropertyPage1::OnWizardNext()
{
	// TODO: Add your specialized code here and/or call the base class

	return CPropertyPage::OnWizardNext();
}

int CMyPropertyPage3::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;


	return 0;
}

void CMyPropertyPage3::OnDestroy()
{
	CPropertyPage::OnDestroy();

	// TODO: Add your message handler code here

}

void CMyPropertyPage3::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_BITMAPPAGE,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );

	CRect rcMainExt;
	m_staticTextExt.GetWindowRect(&rcMainExt);
	ScreenToClient(rcMainExt);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{
			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,FALSE);

			dc.RealizePalette();

			dc.FillRect(&rcMainExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcMainExt, rcMainExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame(	rcMainExt.TopLeft().x,
					rcMainExt.TopLeft().y,
					rcMainExt.BottomRight().x,
					rcMainExt.BottomRight().y);

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));

	CString csFont = _T("MS Shell Dlg");

	CRect crOut;
	CString csOut;

	if (m_pParent->m_pParent->GetMode() == CMOFCompCtrl::MODECOMPILE)
	{
		csOut = _T("Select a .MOF file, namespace, and username");

		crOut = OutputTextString
			(&dc, this, &csOut, 8, 1, &csFont, 8, FW_BOLD);

		csOut = _T("Specify the path and file name for the .MOF file you want to compile, then specify the namespace into which");

		csOut += _T(" you want to load it.  Optionally, you can provide a username, password, and domain to pass to the MOF Compiler.");

	}
	else if (m_pParent->m_pParent->GetMode() == CMOFCompCtrl::MODECHECK)
	{
		csOut = _T("Select a .MOF file");

		crOut = OutputTextString
			(&dc, this, &csOut, 8, 10, &csFont, 8, FW_BOLD);

		csOut = _T("Specify the path and file name for the .MOF file whose syntax you want to check.  Then click on \"Finish\"");

		csOut += _T(" to start the syntax checker.");

	}
	else if (m_pParent->m_pParent->GetMode() == CMOFCompCtrl::MODEBINARY)
	{
		csOut = _T("Select a .MOF file, specify binary MOF file name and directory, and specify WMI checks");

		crOut = OutputTextString
			(&dc, this, &csOut, 8, 10, &csFont, 8, FW_BOLD);

		csOut = _T("Specify the path and file name for the .MOF file you want to compile, then specify the binary MOF file name and directory into which");

		csOut += _T(" you wish to create it.  Optionally, you can specify that WMI checks be performed.");


	}

	CPoint cpRect(crOut.TopLeft().x + 15, crOut.BottomRight().y + 1);

	crOut.TopLeft().x = 0;
	crOut.TopLeft().y = 0;
	crOut.BottomRight().x = rcMainExt.BottomRight().x - cpRect.x;
	crOut.BottomRight().y = rcMainExt.BottomRight().y - cpRect.y;

	OutputTextString
		(&dc, this, &csOut, cpRect.x, cpRect.y, crOut, &csFont, 8, FW_NORMAL);
}


BOOL CMyPropertyPage3::OnSetActive()
{
	BOOL bReturn = CPropertyPage::OnSetActive();

	if (m_bFirstActivate == TRUE)
	{
		m_bFirstActivate = FALSE;
		m_pLocator = m_pParent->m_pParent->InitLocator();
		CString csTemp;
		if (m_pParent->m_pParent->GetMode() == CMOFCompCtrl::MODECOMPILE)
		{
			csTemp = _T("root\\default");
			m_ceNameSpace.SetWindowText(csTemp);
		}
		else if (m_pParent->m_pParent->GetMode() == CMOFCompCtrl::MODEBINARY)
		{
			csTemp = _T("");
			m_ceNameSpace.SetWindowText(csTemp);
			csTemp = GetSDKDirectory();
			m_ceBinaryMofDirectory.SetWindowText(csTemp);
		}

		CString csPath = GetSDKDirectory() + _T("\\");
		m_ceMofFilePath.SetWindowText(csPath);
	}

	if (m_pParent->m_pParent->GetMode() == CMOFCompCtrl::MODECHECK)
	{
		m_pParent->m_Page3.SetWindowText(_T("MOF Compiler - Check syntax of a .MOF File"));
		m_pParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
		CWnd *pBack = GetParent()->GetDlgItem(ID_WIZBACK);

		if (pBack)
		{
			pBack->ShowWindow(SW_SHOW);
		}
		m_ceNameSpace.ShowWindow(SW_HIDE);
		m_csNamespace.ShowWindow(SW_HIDE);
		m_cbCredentials.ShowWindow(SW_HIDE);
		m_csBinaryMofDirectory.ShowWindow(SW_HIDE);
		m_ceBinaryMofDirectory.ShowWindow(SW_HIDE);
		m_cbBinaryMofDirectory.ShowWindow(SW_HIDE);
		m_cbWMI.ShowWindow(SW_HIDE);
	}
	else if (m_pParent->m_pParent->GetMode() == CMOFCompCtrl::MODECOMPILE)
	{
		m_pParent->m_Page3.SetWindowText
			(_T("MOF Compiler - Compile a .MOF File"));
		m_pParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

		CWnd *pBack = GetParent()->GetDlgItem(ID_WIZBACK);
		CWnd *pNext = GetParent()->GetDlgItem(ID_WIZNEXT);

		if (pBack)
		{
			pBack->ShowWindow(SW_SHOW);
		}

		if (pNext)
		{
			pNext->ShowWindow(SW_SHOW);
		}
		m_ceNameSpace.ShowWindow(SW_SHOW);
		m_csNamespace.SetWindowText(_T("N&amespace"));
		m_csNamespace.ShowWindow(SW_SHOW);
		m_cbCredentials.ShowWindow(SW_SHOW);
		m_csBinaryMofDirectory.ShowWindow(SW_HIDE);
		m_ceBinaryMofDirectory.ShowWindow(SW_HIDE);
		m_cbBinaryMofDirectory.ShowWindow(SW_HIDE);
		m_cbWMI.ShowWindow(SW_HIDE);
	}
	else if (m_pParent->m_pParent->GetMode() == CMOFCompCtrl::MODEBINARY)
	{
		m_pParent->m_Page3.SetWindowText
			(_T("MOF Compiler - Create a Binary MOF File"));
		m_pParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

		CWnd *pBack = GetParent()->GetDlgItem(ID_WIZBACK);
		CWnd *pNext = GetParent()->GetDlgItem(ID_WIZNEXT);

		if (pBack)
		{
			pBack->ShowWindow(SW_SHOW);
		}

		if (pNext)
		{
			pNext->ShowWindow(SW_SHOW);
		}
		m_ceNameSpace.ShowWindow(SW_SHOW);
		m_csNamespace.SetWindowText(_T("B&inary .MOF file name"));
		m_csNamespace.ShowWindow(SW_SHOW);
		m_cbCredentials.ShowWindow(SW_HIDE);
		m_csBinaryMofDirectory.ShowWindow(SW_SHOW);
		m_ceBinaryMofDirectory.ShowWindow(SW_SHOW);
		m_cbBinaryMofDirectory.ShowWindow(SW_SHOW);
		m_cbWMI.ShowWindow(SW_SHOW);
		CString csWmiMofCk = GetWMIMofCkPathname();
		if (csWmiMofCk.GetLength() <= 0)
			m_cbWMI.EnableWindow(FALSE);
	}

	return bReturn;
}

BOOL CMyPropertyPage3::GoToNextP()
{
	TCHAR szClass[11];
	CWnd* pWndFocus = GetFocus();
	if (((pWndFocus = GetFocus()) != NULL) &&
		GetClassName(pWndFocus->m_hWnd, szClass, 10) &&
		(_tcsicmp(szClass, _T("EDIT")) == 0))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

void CMyPropertyPage3::OnButtonBrowse()
{
	static TCHAR BASED_CODE szFilter[] =
		_T("MOF Files (*.mof)|*.mof|All Files (*.*)|*.*||");

	CString csFullPath;

	CString csPath;
	TCHAR buffer[_MAX_PATH];

	m_ceMofFilePath.GetWindowText(csPath);

	_tcscpy(buffer,(LPCTSTR)csPath);

	CFileDialog cfdMofFile(TRUE,NULL,NULL,OFN_HIDEREADONLY | OFN_FILEMUSTEXIST,szFilter);
	m_pParent->m_pParent->PreModalDialog();
	cfdMofFile.m_ofn.lpstrInitialDir = buffer;
	int nReturn = (int) cfdMofFile.DoModal();
	m_pParent->m_pParent->PostModalDialog();

	if (nReturn == IDOK)
	{
		m_csMofFilePath = cfdMofFile.GetPathName();
		m_ceMofFilePath.SetWindowText(m_csMofFilePath);
		m_pParent->m_pParent->m_csMofFullPath =
			m_csMofFilePath;
	}
	else
	{
		m_pParent->m_pParent->m_nImage = 0;
		m_pParent->m_pParent->InvalidateControl();
		return;
	}


}


BOOL CMyPropertyPage2::OnWizardFinish()
{
	CWaitCursor wait;

	UpdateData(TRUE);

	if (m_nClassUpdateOptions == 0)
	{
		m_pParent->m_pParent->SetClassCreateOnly(0);
		m_pParent->m_pParent->SetClassUpdateOnly(0);
	}
	else if (m_nClassUpdateOptions == 2)
	{
		m_pParent->m_pParent->SetClassCreateOnly(1);
		m_pParent->m_pParent->SetClassUpdateOnly(0);
	}
	else if (m_nClassUpdateOptions == 1)
	{
		m_pParent->m_pParent->SetClassCreateOnly(0);
		m_pParent->m_pParent->SetClassUpdateOnly(1);
	}


	if (m_nInstanceUpdateOptions == 0)
	{
		m_pParent->m_pParent->SetInstanceCreateOnly(0);
		m_pParent->m_pParent->SetInstanceUpdateOnly(0);
	}
	else if (m_nInstanceUpdateOptions == 2)
	{
		m_pParent->m_pParent->SetInstanceCreateOnly(1);
		m_pParent->m_pParent->SetInstanceUpdateOnly(0);
	}
	else if (m_nInstanceUpdateOptions == 1)
	{
		m_pParent->m_pParent->SetInstanceCreateOnly(0);
		m_pParent->m_pParent->SetInstanceUpdateOnly(1);
	}

	BOOL bPathGood = m_pParent->m_Page3.CheckMofFilePath();

	if (!bPathGood)
	{
		return FALSE;
	}

	bPathGood = m_pParent->m_Page3.CheckBinaryMofFilePath();


	if (!bPathGood)
	{
		return FALSE;
	}


	int nReturn =
		m_pParent->m_pParent->MofCompilerProcess();

	m_pParent->m_Page3.m_csUserName.Empty();
	m_pParent->m_Page3.m_csPassword.Empty();
	m_pParent->m_Page3.m_csAuthority.Empty();

	if (nReturn == 0)
	{
		m_pParent->m_pParent->PostMessage(MODNAMESPACE,0,0);
		m_bRanCompiler = FALSE;
		return CPropertyPage::OnWizardFinish();
	}
	m_bRanCompiler = TRUE;
	return FALSE;
}

BOOL CMyPropertyPage3::CheckMofFilePath()
{
	m_csMofFilePath.TrimLeft();
	m_csMofFilePath.TrimRight();

	m_ceMofFilePath.SetWindowText((LPCTSTR) m_csMofFilePath);


	if (m_csMofFilePath.GetLength() == 0)
	{
		CString csUserMsg =  _T("Please enter a path and file name for a .MOF file.");
		ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		return FALSE;
	}

	FILE *fTmp = _tfopen( (LPCTSTR) m_csMofFilePath, _T("r"));

	if (fTmp)
	{
		fclose(fTmp);
		return TRUE;
	}
	else
	{
		CString csUserMsg =  _T("MOF file \"") + m_csMofFilePath + _T("\" does not exist.");
		ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ );
	}

	return FALSE;
}

BOOL CMyPropertyPage3::ValidateNameSpace(CString *pcsNameSpace)
{
	return S_OK;


}


void CMyPropertyPage3::PropState()
{
	m_ceMofFilePath.GetWindowText(m_csMofFilePath);
	m_pParent->m_pParent->m_csMofFullPath = m_csMofFilePath;
	m_ceNameSpace.GetWindowText(m_csNameSpace);
	m_pParent->m_pParent->SetNameSpace(&m_csNameSpace);
	m_pParent->m_pParent->SetUserName(&m_csUserName);
	m_pParent->m_pParent->SetPassword(&m_csPassword);
	m_pParent->m_pParent->SetAuthority(&m_csAuthority);

	if (m_pParent->m_pParent->GetMode() == CMOFCompCtrl::MODEBINARY)
	{
		CString csDir;
		m_ceBinaryMofDirectory.GetWindowText
			(csDir);

		CString csFile;
		m_ceNameSpace.GetWindowText(csFile);

		BOOL bIsDrive = IsDriveSpecifier(csDir);

		m_pParent->m_pParent->m_csBinaryMofFullPath
			= bIsDrive && csDir.GetLength() == 3 ? csDir + csFile : csDir + _T("\\") + csFile;

		m_pParent->m_pParent->m_bWMI =
			m_cbWMI.GetCheck();
	}

}

LRESULT CMyPropertyPage3::OnWizardNext()
{

	PropState();

	BOOL bReturn = CheckMofFilePath();

	if (!bReturn)
	{
		m_ceMofFilePath.SetFocus();
		return -1;

	}

	// m_csMofFilePath is now good.
	bReturn = CheckBinaryMofFilePath();

	if (!bReturn)
	{
		m_ceBinaryMofDirectory.SetFocus();
		return -1;

	}

	PropState();

	// if we're doing a binary compile and the target & dest files are the same...
	if((m_pParent->m_pParent->GetMode() == CMOFCompCtrl::MODEBINARY) &&
		_tcsicmp(m_csMofFilePath, m_pParent->m_pParent->m_csBinaryMofFullPath) == 0)
	{
		// warn before going to the next page.
		if(AfxMessageBox(IDS_TARGET_DEST_SAME, MB_YESNO|MB_ICONQUESTION) == IDYES)
		{
			// he wants to overwrite it.
			return CPropertyPage::OnWizardNext();
		}
		else
		{
			// stay put.
			m_ceNameSpace.SetFocus();
			return -1;
		}
	}

	return CPropertyPage::OnWizardNext();
}

BOOL CMyPropertyPage3::CheckBinaryMofFilePath()
{
	if (m_pParent->m_pParent->GetMode() != CMOFCompCtrl::MODEBINARY)
	{
		return TRUE;
	}

	CString csDir;

	m_ceBinaryMofDirectory.GetWindowText(csDir);

	csDir.TrimLeft();
	csDir.TrimRight();

	m_ceBinaryMofDirectory.SetWindowText((LPCTSTR) csDir);

	if (csDir.GetLength() == 0)
	{
		CString csUserMsg =  _T("Please enter an output directory name for the binary .MOF file, or \"Cancel\" out of the MOFCompiler Wizard.");
		ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		return FALSE;
	}

	if (!IsDriveValid(reinterpret_cast<CWnd *>(this),&csDir,FALSE))
	{
		CString csUserMsg;
		csUserMsg =  _T("Drive \"")  + csDir + _T("\" is not ready or valid.");
		csUserMsg += _T("  Please enter another drive name, make the drive ready, or \"Cancel\" out of the MOFCompiler Wizard.");
		ErrorMsg(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);
		return FALSE;
	}

	BOOL bRelative = IsRelativePath(csDir);
	BOOL bDriveSpecifier = IsDriveSpecifier(csDir);

	if (bRelative)
	{
		int n = m_csMofFilePath.ReverseFind('\\');
		CString csMofPath = m_csMofFilePath.Left(n + 1);
		csDir = csMofPath + csDir;
	}
	else if (bDriveSpecifier)
	{
		if (csDir.GetLength() == 2)
		{
			csDir += '\\';
		}
	}

	m_ceBinaryMofDirectory.SetWindowText(csDir);

	// validate directory.
	if (!IsDriveValid(reinterpret_cast<CWnd *>(this),&csDir,FALSE))
	{
		CString csUserMsg;
		csUserMsg =  _T("Drive \"")  + csDir + _T("\" is not ready or valid.");
		csUserMsg += _T("  Please enter another drive name, make the drive ready, or \"Cancel\" out of the MOFCompiler Wizard.");
		ErrorMsg(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);
		return FALSE;
	}

	if (!bDriveSpecifier && !TryToFindDirectory (&csDir))
	{
		CString csMsg = _T("  The MOF compiler will fail if the directory does not exist.   ");
		int nReturn = TryToCreateDirectory
			(reinterpret_cast<CWnd *>(this),csDir, &csMsg);
		if (nReturn == IDNO)
		{
			m_ceBinaryMofDirectory.SetFocus();
			return FALSE;
		}
		else if (nReturn != IDYES)
		{
			CString csUserMsg;
			csUserMsg =  _T("Could not create a directory named \"") + csDir;
			csUserMsg += _T("\".  ");
			csUserMsg += _T("Please enter another directory name or \"Cancel\" out of the MOFCompiler Wizard.");
			ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 6);
			m_ceBinaryMofDirectory.SetFocus();
			return FALSE;

		}
	}

	CString csFile;

	// Use namespace text entry for binary mof file if binary mof selected.
	m_ceNameSpace.GetWindowText(csFile);

	csFile.TrimLeft();
	csFile.TrimRight();

	m_ceNameSpace.SetWindowText(csFile);

	if (csFile.IsEmpty())
	{
		CString csUserMsg;
		csUserMsg =  _T("You must provide a binary MOF file name.  ");
		csUserMsg += _T("Please enter a name or \"Cancel\" out of the MOFCompiler Wizard.");
		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);
		m_ceNameSpace.SetFocus();
		return FALSE;
	}

	TCHAR tempPath[_MAX_PATH];
	memset(tempPath, 0, _MAX_PATH);

	_tsplitpath((LPCTSTR)csFile, NULL, tempPath, NULL, NULL);
	if(_tcslen(tempPath) > 0)
	{
		CString csUserMsg;
		csUserMsg =  _T("Paths are not allowed. This field can contain filenames only.");
		ErrorMsg(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);
		m_ceNameSpace.SetFocus();
		return FALSE;
	}

	if (csFile.Find('.') == -1)
	{
		csFile += _T(".mof");
		m_ceNameSpace.SetWindowText(csFile);
	}

	CString csFullPath = bDriveSpecifier ? csDir + csFile : csDir + _T("\\") + csFile;

	return TRUE;
}

LRESULT CMyPropertyPage3::OnWizardBack()
{

	return CPropertyPage::OnWizardBack();
}


void CMyPropertyPage1::OnRadio1()
{
	// TODO: Add your control notification handler code here
	m_pParent->m_pParent->SetMode(CMOFCompCtrl::MODECOMPILE);
	if (m_pParent->m_Page3.m_ceNameSpace.GetSafeHwnd())
	{
		CString csTemp = _T("root\\default");
		m_pParent->m_Page3.m_ceNameSpace.SetWindowText(csTemp);
	}
}

void CMyPropertyPage1::OnRadio2()
{
	// TODO: Add your control notification handler code here
	m_pParent->m_pParent->SetMode(CMOFCompCtrl::MODECHECK);
}

void CMyPropertyPage2::OnCancel()
{
	// TODO: Add your specialized code here and/or call the base class
	m_pParent->m_pParent->m_nImage = 0;
	m_pParent->m_pParent->InvalidateControl();
	m_pParent->m_Page3.m_csUserName.Empty();
	m_pParent->m_Page3.m_csPassword.Empty();
	m_pParent->m_Page3.m_csAuthority.Empty();

	if (m_bRanCompiler)
	{
		m_pParent->m_pParent->PostMessage(MODNAMESPACE,0,0);
		m_bRanCompiler = FALSE;
	}

	CPropertyPage::OnCancel();
}

void CMyPropertyPage3::OnCancel()
{
	// TODO: Add your specialized code here and/or call the base class
	m_pParent->m_pParent->m_nImage = 0;
	m_pParent->m_pParent->InvalidateControl();
	m_csUserName.Empty();
	m_csPassword.Empty();
	m_csAuthority.Empty();

	CPropertyPage::OnCancel();
}

BOOL CMyPropertyPage3::OnWizardFinish()
{
	// TODO: Add your specialized code here and/or call the base class

	CWaitCursor wait;

	PropState();

	BOOL bPathGood = CheckMofFilePath();

	if (!bPathGood)
	{
		return FALSE;
	}

	bPathGood = CheckBinaryMofFilePath();


	if (!bPathGood)
	{
		return FALSE;
	}

	int nReturn =
		m_pParent->m_pParent->MofCompilerProcess();

	m_csUserName.Empty();
	m_csPassword.Empty();
	m_csAuthority.Empty();

	if (nReturn == 0)
	{
		return CPropertyPage::OnWizardFinish();
	}

	return FALSE;
}




void CMyPropertyPage3::OnButtoncredentials()
{
	// TODO: Add your control notification handler code here
	CLoginDlg cldCredentials;
	cldCredentials.m_pActiveXControl = m_pParent->m_pParent;
	cldCredentials.m_csUser = m_csUserName;
	cldCredentials.m_csPassword = m_csPassword;
	cldCredentials.m_csAuthority = m_csAuthority;

	int nReturn =  (int) cldCredentials.DoModal();

	if (nReturn == IDOK)
	{
		m_csUserName = cldCredentials.m_csUser;
		m_csPassword = cldCredentials.m_csPassword;
		m_csAuthority = cldCredentials.m_csAuthority;
	}

}

void CMyPropertyPage1::OnRadioBinary()
{
	// TODO: Add your control notification handler code here
	m_pParent->m_pParent->SetMode(CMOFCompCtrl::MODEBINARY);
	if (m_pParent->m_Page3.m_ceNameSpace.GetSafeHwnd())
	{
		CString csTemp = _T("");
		m_pParent->m_Page3.m_ceNameSpace.SetWindowText(csTemp);
		csTemp = GetSDKDirectory();
		m_pParent->m_Page3.m_ceBinaryMofDirectory.SetWindowText(csTemp);
	}
}

CString CMyPropertyPage3::GetFolder()
{
	CString csDir;

	IMalloc *pimMalloc;

	HRESULT hr = CoGetMalloc(MEMCTX_TASK,&pimMalloc);

	BROWSEINFO bi;
    LPTSTR lpBuffer;
    //LPITEMIDLIST pidlPrograms;  // PIDL for Programs folder
    LPITEMIDLIST pidlBrowse;    // PIDL selected by user

    // Allocate a buffer to receive browse information.
    if ((lpBuffer = (LPTSTR) pimMalloc->Alloc(MAX_PATH)) == NULL)
	{
		pimMalloc->Release();
        return csDir;
	}



    // Fill in the BROWSEINFO structure.
    bi.hwndOwner = this->GetSafeHwnd();
    bi.pidlRoot = NULL; // pidlPrograms;
    bi.pszDisplayName = lpBuffer;
    bi.lpszTitle = _T("Select a Directory");
    bi.ulFlags = BIF_RETURNONLYFSDIRS;
    bi.lpfn = NULL;
    bi.lParam = 0;

    // Browse for a folder and return its PIDL.
    pidlBrowse = SHBrowseForFolder(&bi);
    if (pidlBrowse != NULL) {

		if (SHGetPathFromIDList(pidlBrowse,lpBuffer))
		{
			csDir = lpBuffer;
		}
        // Free the PIDL returned by SHBrowseForFolder.
        pimMalloc->Free(pidlBrowse);
    }

    // Clean up.
    pimMalloc->Free(lpBuffer);
	pimMalloc->Release();
	return csDir;

}


void CMyPropertyPage3::OnButtonBinaryMofDirectory()
{
	// TODO: Add your control notification handler code here
	CString csFolder = GetFolder();
	if (!csFolder.IsEmpty())
	{
		 m_ceBinaryMofDirectory.SetWindowText((LPCTSTR) csFolder);

	}
}

void CMyPropertyPage1::OnHelp()
{
	m_pParent->m_pParent->m_csHelpUrl = idh_mofcompwiz;
	m_pParent->m_pParent->InvokeHelp();
}

void CMyPropertyPage2::OnHelp()
{
	m_pParent->m_pParent->m_csHelpUrl = idh_mofcompwiz;
	m_pParent->m_pParent->InvokeHelp();
}

void CMyPropertyPage3::OnHelp()
{
	m_pParent->m_pParent->m_csHelpUrl = idh_mofcompwiz;
	m_pParent->m_pParent->InvokeHelp();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\mypropertysheet.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MyPropertySheet.cpp : implementation file
//

#include "precomp.h"
#include "resource.h"
#include "wbemidl.h"
#include "MyPropertySheet.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMyPropertySheet

IMPLEMENT_DYNAMIC(CMyPropertySheet, CPropertySheet)

CMyPropertySheet::CMyPropertySheet(CWnd* pWndParent)
	 : CPropertySheet(IDS_PROPSHT_CAPTION, pWndParent)
{
	// Add all of the property pages here.  Note that
	// the order that they appear in here will be
	// the order they appear in on screen.  By default,
	// the first page of the set is the active one.
	// One way to make a different property page the
	// active one is to call SetActivePage().

	m_psh.dwFlags |= (PSH_HASHELP);

	m_pParent = reinterpret_cast<CMOFCompCtrl *>(pWndParent);


	AddPage(&m_Page1);
	AddPage(&m_Page3);
	AddPage(&m_Page2);

	m_Page1.m_psp.dwFlags |= (PSP_HASHELP);
	m_Page2.m_psp.dwFlags |= (PSP_HASHELP);
	m_Page3.m_psp.dwFlags |= (PSP_HASHELP);



	SetWizardMode();
}

CMyPropertySheet::~CMyPropertySheet()
{
}


BEGIN_MESSAGE_MAP(CMyPropertySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CMyPropertySheet)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMyPropertySheet message handlers

BOOL CMyPropertySheet::OnInitDialog()
{
	m_Page1.SetLocalParent(this);
	m_Page2.SetLocalParent(this);
	m_Page3.SetLocalParent(this);




	BOOL bResult = CPropertySheet::OnInitDialog();


	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\mypropertysheet.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MyPropertySheet.h : header file
//
// This class defines custom modal property sheet 
// CMyPropertySheet.
 // CMyPropertySheet has been customized to include
// a preview window.
 
#ifndef __MYPROPERTYSHEET_H__
#define __MYPROPERTYSHEET_H__

#include "MyPropertyPage1.h"
#include "PreviewWnd.h"

/////////////////////////////////////////////////////////////////////////////
// CMyPropertySheet
class CMOFCompCtrl;

class CMyPropertySheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CMyPropertySheet)

// Construction
public:
	CMyPropertySheet(CWnd* pWndParent = NULL);

// Attributes
public:
	CMyPropertyPage1 m_Page1;
	CMyPropertyPage2 m_Page2;
	CMyPropertyPage3 m_Page3;
	CPreviewWnd m_wndPreview;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertySheet)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMyPropertySheet();

// Generated message map functions
protected:
	//{{AFX_MSG(CMyPropertySheet)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	CMOFCompCtrl *m_pParent;
	friend class CMyPropertyPage1;
	friend class CMyPropertyPage2;
	friend class CMyPropertyPage3;
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __MYPROPERTYSHEET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\nsentry.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "nsentry.h"

/////////////////////////////////////////////////////////////////////////////
// CNSEntry

IMPLEMENT_DYNCREATE(CNSEntry, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CNSEntry properties

long CNSEntry::GetMaxDroppedWidth()
{
	long result;
	GetProperty(0x1, VT_I4, (void*)&result);
	return result;
}

void CNSEntry::SetMaxDroppedWidth(long propVal)
{
	SetProperty(0x1, VT_I4, propVal);
}

CString CNSEntry::GetFontName()
{
	CString result;
	GetProperty(0x2, VT_BSTR, (void*)&result);
	return result;
}

void CNSEntry::SetFontName(LPCTSTR propVal)
{
	SetProperty(0x2, VT_BSTR, propVal);
}

long CNSEntry::GetFontWidth()
{
	long result;
	GetProperty(0x3, VT_I4, (void*)&result);
	return result;
}

void CNSEntry::SetFontWidth(long propVal)
{
	SetProperty(0x3, VT_I4, propVal);
}

long CNSEntry::GetFontHeight()
{
	long result;
	GetProperty(0x4, VT_I4, (void*)&result);
	return result;
}

void CNSEntry::SetFontHeight(long propVal)
{
	SetProperty(0x4, VT_I4, propVal);
}

long CNSEntry::GetComponentStructure()
{
	long result;
	GetProperty(0x5, VT_I4, (void*)&result);
	return result;
}

void CNSEntry::SetComponentStructure(long propVal)
{
	SetProperty(0x5, VT_I4, propVal);
}

OLE_COLOR CNSEntry::GetBackColor()
{
	OLE_COLOR result;
	GetProperty(DISPID_BACKCOLOR, VT_I4, (void*)&result);
	return result;
}

void CNSEntry::SetBackColor(OLE_COLOR propVal)
{
	SetProperty(DISPID_BACKCOLOR, VT_I4, propVal);
}

CString CNSEntry::GetNameSpace()
{
	CString result;
	GetProperty(0x6, VT_BSTR, (void*)&result);
	return result;
}

void CNSEntry::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x6, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CNSEntry operations

/*SCODE CNSEntry::OpenNamespace(LPCTSTR bstrNamespace, BOOL boolNoFireEvent)
{
	SCODE result;
	static BYTE parms[] =
		VTS_BSTR VTS_BOOL;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_ERROR, (void*)&result, parms,
		bstrNamespace, boolNoFireEvent);
	return result;
}*/
void CNSEntry::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\cathelp.cpp ===
//=--------------------------------------------------------------------------=

// CatHelp.Cpp

//=--------------------------------------------------------------------------=

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "precomp.h"

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\mypropertypage1.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MyPropertyPage1.h : header file
//
//{{AFX_INCLUDES()

//}}AFX_INCLUDES

#ifndef __MYPROPERTYPAGE1_H__
#define __MYPROPERTYPAGE1_H__

/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage1 dialog

class CMyPropertySheet;
class CImageList;

CString GetHmomWorkingDirectory();
CString GetWMIMofCkPathname();

int GetCBitmapWidth(const CBitmap & cbm);
int GetCBitmapHeight(const CBitmap & cbm);
HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPCTSTR lpString,
                           HPALETTE FAR* lphPalette);
HPALETTE CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors);
BOOL StringInArray
(CStringArray *&rpcsaArrays, CString *pcsString, int nIndex);

BOOL IsRelativePath(CString &rcsPath);
BOOL IsDriveSpecifier(CString &rcsPath);

class CMyPropertyPage1 : public CPropertyPage
{
	DECLARE_DYNCREATE(CMyPropertyPage1)

// Construction
public:
	CMyPropertyPage1();
	~CMyPropertyPage1();
	void SetLocalParent(CMyPropertySheet *pParent) {m_pParent = pParent;}
	CMyPropertySheet *GetLocalParent() {return m_pParent;}

// Dialog Data
	//{{AFX_DATA(CMyPropertyPage1)
	enum { IDD = IDD_PROPPAGEMAIN };
	CStatic	m_staticWhatDo;
	CStatic	m_staticMainExt;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertyPage1)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMyPropertyPage1)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg void OnRadio1();
	afx_msg void OnRadio2();
	afx_msg void OnRadioBinary();
	//}}AFX_MSG
	afx_msg void OnHelp();
	DECLARE_MESSAGE_MAP()
	CMyPropertySheet *m_pParent;
	BOOL m_bInitDraw;
	int m_nBitmapH;
	int m_nBitmapW;
};


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage2 dialog

class CMyPropertyPage2 : public CPropertyPage
{
	DECLARE_DYNCREATE(CMyPropertyPage2)

// Construction
public:
	CMyPropertyPage2();
	~CMyPropertyPage2();
	void SetLocalParent(CMyPropertySheet *pParent) {m_pParent = pParent;}
	CMyPropertySheet *GetLocalParent() {return m_pParent;}

// Dialog Data
	//{{AFX_DATA(CMyPropertyPage2)
	enum { IDD = IDD_PROPPAGECALSSANDINST };
	CStatic	m_staticTextExt;
	int		m_nClassUpdateOptions;
	int		m_nInstanceUpdateOptions;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertyPage2)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnWizardFinish();
	virtual void OnCancel();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMyPropertyPage2)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	//}}AFX_MSG
	afx_msg void OnHelp();
	DECLARE_MESSAGE_MAP()
	BOOL m_bInitDraw;
	BOOL m_bFirstActivate;
	CMyPropertySheet *m_pParent;
	int m_nBitmapH;
	int m_nBitmapW;
	BOOL m_bRanCompiler;

};

class CMyPropertyPage3 : public CPropertyPage
{
	DECLARE_DYNCREATE(CMyPropertyPage3)

// Construction
public:
	CMyPropertyPage3();
	~CMyPropertyPage3();
	void SetLocalParent(CMyPropertySheet *pParent) {m_pParent = pParent;}
	CMyPropertySheet *GetLocalParent() {return m_pParent;}
	
// Dialog Data
	//{{AFX_DATA(CMyPropertyPage3)
	enum { IDD = IDD_PROPPAGEMOFANDNAMESPAVE };
	CButton	m_cbBrowse;
	CButton	m_cbWMI;
	CStatic	m_csNamespace;
	CEdit	m_ceBinaryMofDirectory;
	CStatic	m_csBinaryMofDirectory;
	CButton	m_cbBinaryMofDirectory;
	CButton	m_cbCredentials;
	CStatic	m_staticTextExt;
	CEdit	m_ceNameSpace;
	CEdit	m_ceMofFilePath;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertyPage3)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual void OnCancel();
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	IWbemLocator *m_pLocator;
	// Generated message map functions
	//{{AFX_MSG(CMyPropertyPage3)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg void OnButtonBrowse();
	afx_msg void OnButtoncredentials();
	afx_msg void OnButtonBinaryMofDirectory();
	//}}AFX_MSG
	afx_msg void OnHelp();
	DECLARE_MESSAGE_MAP()
	BOOL m_bInitDraw;
	BOOL m_bFirstActivate;
	CMyPropertySheet *m_pParent;
	int m_nBitmapH;
	int m_nBitmapW;
	CString m_csMofFilePath;
	CString m_csNameSpace;
	BOOL CheckMofFilePath();
	BOOL ValidateNameSpace(CString *pcsNameSpace);
	BOOL m_bNTLM;
	BOOL m_bWBEM;
	CString m_csUserName;
	CString m_csPassword;
	CString m_csAuthority;
	void PropState();
	CString GetFolder();
	BOOL CheckBinaryMofFilePath();
	BOOL GoToNextP();
	friend class CMyPropertyPage2;
};



#endif // __MYPROPERTYPAGE1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\previewwnd.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// PreviewWnd.h : header file
//
// This file contains the preview window used by the 
// CMyPropertySheet property sheet.

/////////////////////////////////////////////////////////////////////////////
// CPreviewWnd window

#ifndef __PREVIEWWND_H__
#define __PREVIEWWND_H__

class CPreviewWnd : public CWnd
{
// Construction
public:
	CPreviewWnd();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPreviewWnd)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CPreviewWnd();

	// Generated message map functions
protected:
	//{{AFX_MSG(CPreviewWnd)
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif		// __PREVIEWWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MOFComp.rc
//
#define IDS_MOFCOMP                     1
#define IDD_ABOUTBOX_MOFCOMP            1
#define IDB_MOFCOMP                     1
#define IDI_ABOUTDLL                    1
#define IDS_MOFCOMP_PPG                 2
#define IDS_MOFCOMP_PPG_CAPTION         100
#define IDD_PROPPAGE_MOFCOMP            100
#define IDS_PROPSHT_CAPTION             102
#define IDD_PROPPAGE1                   103
#define IDD_PROPPAGEMAIN                103
#define IDS_NO_HTML_PAGE                103
#define IDD_PROPPAGE2                   104
#define IDD_PROPPAGECALSSANDINST        104
#define IDS_TARGET_DEST_SAME            104
#define IDD_PROPPAGE3                   105
#define IDD_PROPPAGEMOFANDNAMESPAVE     105
#define IDD_PROPPAGEOPERATION           106
#define IDI_MOFCOMPSEL                  201
#define IDI_MOFCOMP                     202
#define IDC_RADIO1                      202
#define IDB_BITMAP1                     203
#define IDC_RADIO2                      203
#define IDB_BITMAP2                     204
#define IDC_BUTTON1                     204
#define IDC_CHECK1                      205
#define IDB_BITMAP3                     205
#define IDC_CHECKUPDATECLASSES          205
#define IDC_CHECKNTLM                   205
#define IDC_BUTTON2                     205
#define IDC_CHECK2                      206
#define IDC_CHECKCREATEINSTANCES        206
#define IDC_CHECKWBEM                   206
#define IDC_CHECKWMI                    206
#define IDC_CHECK3                      207
#define IDC_CHECKUPDATEINSTANCES        207
#define IDC_CHECK4                      208
#define IDC_CHECKCREATECLASSES          208
#define IDC_NSENTRYCTRL1                209
#define IDI_MOFCOMP16                   209
#define IDC_EDIT1                       210
#define IDI_MOFCOMPSEL16                210
#define IDB_BITMAPMAIN                  210
#define IDC_EDITBINARYMOFDIRECTORY      210
#define IDB_BITMAPPAGE                  211
#define IDC_EDIT3                       211
#define IDB_BITMAPMAINABR               212
#define IDC_STATICPP1                   213
#define IDC_EDIT2                       214
#define IDC_RADIOCOMPILE                215
#define IDC_RADIOSYNTAX                 216
#define IDC_NAMESPACE                   217
#define IDC_STATICMAIN                  218
#define IDC_STATICWHATTODO              219
#define IDC_STATIC3                     220
#define IDC_STATIC4                     221
#define IDC_EDITUSERNAME1               222
#define IDC_EDITPASSWORD1               223
#define IDC_STATICDOMAIN1               224
#define IDC_EDITDOMAIN1                 225
#define IDC_EDITUSERNAME                226
#define IDC_EDITPASSWORD                227
#define IDC_EDITDOMAIN                  228
#define IDC_RADIONTLM                   229
#define IDC_RADIOWBEM                   230
#define IDC_RADIOCURRENTUSER            231
#define IDC_STATICDOMAIN                232
#define IDC_BUTTONHELP                  233
#define IDD_DIALOGLOGIN                 237
#define IDC_BUTTONCREDENTIALS           238
#define IDC_RADIONOCREATEINSTANCE       239
#define IDC_RADIONOCHANGEINSTANCE       240
#define IDC_RADIONOCLASSCREATE          241
#define IDC_RADIONOUPDATECLASS          242
#define IDC_RADIOCREATEANDCHANGECLASS   243
#define IDC_RADIOCREATEANDCHANGEINSTANCES 244
#define IDC_RADIO3                      244
#define IDC_BINARYMOFDIRECTORY          245
#define IDC_EDITAUTHORITY               246

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        238
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         247
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofcomp\previewwnd.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// PreviewWnd.cpp : implementation file
//

#include "precomp.h"
#include "resource.h"
#include "PreviewWnd.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPreviewWnd

CPreviewWnd::CPreviewWnd()
{
}

CPreviewWnd::~CPreviewWnd()
{
}


BEGIN_MESSAGE_MAP(CPreviewWnd, CWnd)
	//{{AFX_MSG_MAP(CPreviewWnd)
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPreviewWnd message handlers

void CPreviewWnd::OnPaint()
{
	// TODO: Add your custom preview paint code.
	// For an example, we are drawing a blue ellipse.

	CPaintDC dc(this); // device context for painting
	CRect rect;
	GetClientRect(rect);

	CBrush brushNew(RGB(0,0,255));
	CBrush* pBrushOld = dc.SelectObject(&brushNew);
	dc.Ellipse(rect);
	dc.SelectObject(pBrushOld);
}

BOOL CPreviewWnd::OnEraseBkgnd(CDC* pDC)
{
	// Use the same background color as that of the dialog
	//  (property sheet).

	CWnd* pParentWnd = GetParent();
	HBRUSH hBrush = (HBRUSH)pParentWnd->SendMessage(WM_CTLCOLORDLG,
		(WPARAM)pDC->m_hDC, (LPARAM)pParentWnd->m_hWnd);
	CRect rect;
	GetClientRect(rect);
	pDC->FillRect(&rect, CBrush::FromHandle(hBrush));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\hlb.h ===
//****************************************************************************

// File:

//

//     HLB.H

//

// Purpose:

//

//     Provides the declaration for the CHorzListBox class.

//

// Development Team:

//

//     James Rhodes

//

// Written by Microsoft Product Support Services, Languages Developer Support

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//****************************************************************************

#ifndef HLB_H
#define HLB_H

#include <afxtempl.h>

typedef CArray<int,int> CIntArray;

/////////////////////////////////////////////////////////////////////////////
// CHorzListBox window

class CHorzListBox : public CListBox
{
// Construction
public:
	CHorzListBox();

// Attributes
protected:
	BOOL m_bLocked;
	CIntArray m_arrExtents;
	int m_nLongestExtent;
	int m_nTabStops;
	int* m_lpTabStops;

// Operations
public:
	void LockHExtentUpdate();
	void UnlockHExtentUpdate();
	void UpdateHExtent();

protected:
	void InsertNewExtent(int nItem, LPCTSTR lpszStr);
	void InsertNewExtent(int nItem, LPCTSTR lpszStr, CDC* pDC);
	void InitTabStops();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHorzListBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHorzListBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CHorzListBox)
	//}}AFX_MSG
	afx_msg LRESULT OnAddString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnInsertString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDeleteString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSetTabStops(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\mofgensheet.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MofGenSheet.h : header file
//
// This class defines custom modal property sheet 
// CMofGenSheet.
 
#ifndef __MofGENSHEET_H__
#define __MofGENSHEET_H__


//#include "MyPropertyPage1.h"

class CMOFWizCtrl;

/////////////////////////////////////////////////////////////////////////////
// CMofGenSheet

class CMofGenSheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CMofGenSheet)

// Construction
public:
	CMofGenSheet(CMOFWizCtrl* pParentWnd = NULL);
	CMOFWizCtrl *GetLocalParent(){return m_pParent;}
// Attributes
public:
	CMyPropertyPage1 m_Page1;
//	CMyPropertyPage2 m_Page2;
	CMyPropertyPage3 m_Page3;
	CMyPropertyPage4 m_Page4;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMofGenSheet)
	public:
	virtual BOOL OnInitDialog();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMofGenSheet();

// Generated message map functions
protected:
	//{{AFX_MSG(CMofGenSheet)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CMOFWizCtrl *m_pParent;
	friend class CMyPropertyPage4;
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __MofGENSHEET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\mofwiz.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MOFWiz.cpp : Implementation of CMOFWizApp and DLL registration.

#include "precomp.h"
#include "MOFWiz.h"
#include "CatHelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CMOFWizApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xf3b3a400, 0x3419, 0x11d0, { 0x95, 0xf8, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const GUID CDECL BASED_CODE _ctlid =   { 0xf3b3a403, 0x3419, 0x11d0,
           { 0x95, 0xf8, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b} };

const CATID CATID_SafeForScripting     =
   {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing  =
   {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};

////////////////////////////////////////////////////////////////////////////
// CMOFWizApp::InitInstance - DLL initialization

BOOL CMOFWizApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CMOFWizApp::ExitInstance - DLL termination

int CMOFWizApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	if (FAILED( CreateComponentCategory(CATID_SafeForScripting,
               L"Controls that are safely scriptable") ))
             return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( CreateComponentCategory(
           CATID_SafeForInitializing,
           L"Controls safely initializable from persistent data") ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForScripting) ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForInitializing) ))
         return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\hlb.cpp ===
//****************************************************************************

// File:

//

//     HLB.CPP

//

// Purpose:

//

//     Implementation file for class CHorzListBox.

//

// Functions:

//

//  CHorzListBox::CHorzListBox          Constructs a CHorzListBox

//  CHorzListBox::~CHorzListBox         Destructor

//  CHorzListBox::LockHExtentUpdate     Pauses automatic updating of the

//                                      horizontal scroll bar

//  CHorzListBox::UnlockHExtentUpdate   Restores automatic updating of

//                                      the horizontal scroll bar

//  CHorzListBox::UpdateHExtent         Updates the horizontal scroll bar

//                                      extent after LockHExtentUpdate has

//                                      been called

//  CHorzListBox::InsertNewExtent       Internal utility function used to

//                                      maintain the extent array

//  CHorzListBox::InitTabStops          Internal tab stop init function

//  CHorzListBox::OnAddString           Intercepts LB_ADDSTRING msg

//  CHorzListBox::OnInsertString        Intercepts LB_INSERTSTRING msg

//  CHorzListBox::OnDeleteString        Intercepts LB_DELETESTRING msg

//  CHorzListBox::OnSetTabStops         Intercepts LB_SETTABSTOPS msg

//

// Development Team:

//

//     James Rhodes

//

// Written by Microsoft Product Support Services, Languages Developer Support

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//****************************************************************************

#include "precomp.h"
#include "HLB.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHorzListBox

//***********************************************************************
// Function:
//
//     CHorzListBox::CHorzListBox()
//
// Purpose:
//
//     Constructs a CHorzListBox object
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
CHorzListBox::CHorzListBox()
{
	m_bLocked = FALSE;      // start out in auto mode
	m_nLongestExtent = 0;   // tracks longest extent, initially 0
	m_nTabStops = 0;        // no tab stops
	m_lpTabStops = NULL;    // array of tab stops
}

//***********************************************************************
// Function:
//
//     CHorzListBox::~CHorzListBox()
//
// Purpose:
//
//     Destructs a CHorzListBox object
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
CHorzListBox::~CHorzListBox()
{
	if (m_lpTabStops != NULL)
		delete m_lpTabStops;
}

//***********************************************************************
// Function:
//
//     CHorzListBox::LockHExtentUpdate()
//
// Purpose:
//
//     Stops auto updating of horizontal extent
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
void CHorzListBox::LockHExtentUpdate()
{
	m_bLocked = TRUE;
}

//***********************************************************************
// Function:
//
//     CHorzListBox::UnlockHExtentUpdate()
//
// Purpose:
//
//     Turns auto updating back on
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
void CHorzListBox::UnlockHExtentUpdate()
{
	m_bLocked = FALSE;
}

//***********************************************************************
// Function:
//
//     CHorzListBox::UpdateHExtent()
//
// Purpose:
//
//     Updates horizontal extent when auto updating has been turned off
//     for some period.
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
void CHorzListBox::UpdateHExtent()
{
	m_arrExtents.RemoveAll();
	m_nLongestExtent = 0;
	int nCount = GetCount();

	CDC* pDC = GetDC();
	HFONT hFont = (HFONT)SendMessage(WM_GETFONT);
	CFont *pFont = CFont::FromHandle(hFont);
	ASSERT(pFont);
	CFont* pPrevFont = pDC->SelectObject(pFont);
	CString str;

	for(int i=0; i<nCount; i++)
	{
		GetText(i, str);
		InsertNewExtent(i, str, pDC);
	}

	SetHorizontalExtent(m_nLongestExtent);
	pDC->SelectObject(pPrevFont);
	ReleaseDC(pDC);
}

//***********************************************************************
// Function:
//
//     CHorzListBox::InsertNewExtent() PROTECTED
//
// Purpose:
//
//     Used to update the extent array when a new item is added
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
void CHorzListBox::InsertNewExtent(int nItem, LPCTSTR lpszStr, CDC* pDC)
{
	if (NULL == m_lpTabStops)
		InitTabStops();

    CSize newExtent;
    if (GetStyle() & LBS_USETABSTOPS)
	    newExtent = pDC->GetTabbedTextExtent(lpszStr, _tcslen(lpszStr),
		    m_nTabStops, m_lpTabStops);
    else
        newExtent = pDC->GetTextExtent(lpszStr, _tcslen(lpszStr));

	newExtent.cx += 6;
	m_arrExtents.InsertAt(nItem, newExtent.cx);

	if (newExtent.cx > m_nLongestExtent)
	{
		m_nLongestExtent = newExtent.cx;
	}
}

void CHorzListBox::InsertNewExtent(int nItem, LPCTSTR lpszStr)
{
	if (m_bLocked)
		return;

	CDC* pDC = GetDC();
	HFONT hFont = (HFONT)SendMessage(WM_GETFONT);
	CFont *pFont = CFont::FromHandle(hFont);
	ASSERT(pFont);
	CFont* pPrevFont = pDC->SelectObject(pFont);
	InsertNewExtent(nItem, lpszStr, pDC);
	SetHorizontalExtent(m_nLongestExtent);
	pDC->SelectObject(pPrevFont);
	ReleaseDC(pDC);
}

//***********************************************************************
// Function:
//
//     CHorzListBox::InitTabStops() PROTECTED
//
// Purpose:
//
//     Initializes tab stops
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
void CHorzListBox::InitTabStops()
{
	int nDefault = 2;
	SetTabStops(1, &nDefault);
}

BEGIN_MESSAGE_MAP(CHorzListBox, CListBox)
	//{{AFX_MSG_MAP(CHorzListBox)
	//}}AFX_MSG_MAP
	ON_MESSAGE( LB_ADDSTRING, OnAddString )
	ON_MESSAGE( LB_INSERTSTRING, OnInsertString )
	ON_MESSAGE( LB_DELETESTRING, OnDeleteString )
	ON_MESSAGE( LB_SETTABSTOPS, OnSetTabStops )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHorzListBox message handlers

//***********************************************************************
// Function:
//
//     CHorzListBox::OnAddString()
//
// Purpose:
//
//     Intercepts the LB_ADDSTRING message to update the horizontal extent
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
LRESULT CHorzListBox::OnAddString(WPARAM, LPARAM lParam)
{
	LRESULT lResult = Default();
	if (LB_ERR == lResult || LB_ERRSPACE == lResult) // check for error first!
		return lResult;

	InsertNewExtent((long) lResult, (LPCTSTR)lParam);
	return lResult;
}

//***********************************************************************
// Function:
//
//     CHorzListBox::OnInsertString()
//
// Purpose:
//
//     Intercepts the LB_INSERTSTRING message to update the horizontal extent
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
LRESULT CHorzListBox::OnInsertString(WPARAM, LPARAM lParam)
{
	LRESULT lResult = Default();
	if (LB_ERR == lResult || LB_ERRSPACE == lResult) // check for error first!
		return lResult;

	InsertNewExtent((LONG)lResult, (LPCTSTR)lParam);
	return lResult;
}

//***********************************************************************
// Function:
//
//     CHorzListBox::OnDeleteString()
//
// Purpose:
//
//     Intercepts the LB_DELETESTRING message to update the horizontal extent
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
LRESULT CHorzListBox::OnDeleteString(WPARAM wParam, LPARAM)
{
	LRESULT lResult = Default();
	if (LB_ERR == lResult) // check for error first!
		return lResult;

	if (m_bLocked) // don't do anything if locked
		return lResult;

	int nExtent = m_arrExtents[wParam];
	m_arrExtents.RemoveAt(wParam);
	if (nExtent >= m_nLongestExtent)
	{
		m_nLongestExtent = 0;
		for(int i = 0; i<lResult; i++)
		{
			if (m_arrExtents[i] > m_nLongestExtent)
				m_nLongestExtent = m_arrExtents[i];
		}
	}
	SetHorizontalExtent(m_nLongestExtent);

	return lResult;
}

//***********************************************************************
// Function:
//
//     CHorzListBox::OnSetTabStops()
//
// Purpose:
//
//     Intercepts the LB_SETTABSTOPS message to update tab stop array
//
// History:
//
//   Date   Comment                                           Initials
// ======== ================================================= ========
//  1/31/96 Created                                             JMR
//***********************************************************************
LRESULT CHorzListBox::OnSetTabStops(WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult = Default();
	if (!lResult)
		return lResult;

	m_nTabStops = (int) wParam;

	if (NULL != m_lpTabStops)
	{
		delete [] m_lpTabStops;
		m_lpTabStops = NULL;
	}

	if (m_nTabStops > 0)
	{
		m_lpTabStops = new int[m_nTabStops];
		memcpy(m_lpTabStops, (void*)lParam, m_nTabStops * sizeof(int));

		CDC* pDC = GetDC();
		HFONT hFont = (HFONT)SendMessage(WM_GETFONT);
		CFont *pFont = CFont::FromHandle(hFont);
		ASSERT(pFont);
		CFont* pPrevFont = pDC->SelectObject(pFont);
		CSize size;

		GetTextExtentPoint32(pDC->GetSafeHdc(),
			_T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"),
			52, &size);

		pDC->SelectObject(pPrevFont);
		ReleaseDC(pDC);

		int aveCharWidth = (size.cx/26 +1)/2;

		for(int i=0; i<m_nTabStops; i++)
			m_lpTabStops[i] = (m_lpTabStops[i] * aveCharWidth + 2)/4;
	}

	if (!m_bLocked)
		UpdateHExtent(); // tabs changed, recalc everything!

	return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\mofgensheet.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MofGenSheet.Mof : implementation file
//

#include "precomp.h"
#include "resource.h"
#include <fstream.h>
#include "wbemidl.h"
#include <afxcmn.h>
#include "MOFWiz.h"
#include "MOFWizCtl.h"
#include "WrapListCtrl.h"
#include "hlb.h"
#include "MyPropertyPage1.h"
#include "MofGenSheet.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CMofGenSheet

IMPLEMENT_DYNAMIC(CMofGenSheet, CPropertySheet)

CMofGenSheet::CMofGenSheet(CMOFWizCtrl* pWndParent)
	 : CPropertySheet(IDS_PROPSHT_CAPTION, NULL)
{
	// Add all of the property pages here.  Note that
	// the order that they appear in here will be
	// the order they appear in on screen.  By default,
	// the first page of the set is the active one.
	// One way to make a different property page the
	// active one is to call SetActivePage().
	m_psh.dwFlags |= (PSH_HASHELP);
	m_pParent = pWndParent;
	AddPage(&m_Page1);
	//AddPage(&m_Page2);
	AddPage(&m_Page3);
	AddPage(&m_Page4);

	m_Page1.m_psp.dwFlags |= (PSP_HASHELP);
	m_Page3.m_psp.dwFlags |= (PSP_HASHELP);
	m_Page4.m_psp.dwFlags |= (PSP_HASHELP);

	SetWizardMode();
}

CMofGenSheet::~CMofGenSheet()
{
}


BEGIN_MESSAGE_MAP(CMofGenSheet, CPropertySheet)
	//{{AFX_MSG_MAP(CMofGenSheet)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMofGenSheet message handlers



BOOL CMofGenSheet::OnInitDialog()
{
	// TODO: Add your specialized code here and/or call the base class


	return CPropertySheet::OnInitDialog();
}


int CMofGenSheet::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	//WS_EX_CLIENTEDGE
	//WS_EX_WINDOWEDGE
	lpCreateStruct->dwExStyle = lpCreateStruct->dwExStyle &
		!WS_EX_CLIENTEDGE;

	if (CPropertySheet::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_Page1.SetLocalParent(this);
	m_Page3.SetLocalParent(this);
	m_Page4.SetLocalParent(this);

	return 0;
}

BOOL CMofGenSheet::PreTranslateMessage(MSG* lpMsg)
{
	// TODO: Add your specialized code here and/or call the base class

	return CPropertySheet::PreTranslateMessage(lpMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#endif //_UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\mofwiz.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MOFWiz.h : main header file for MOFWIZ.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMOFWizApp : See MOFWiz.cpp for implementation.

class CMOFWizApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\mofwizctl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MOFWizCtl.cpp : Implementation of the CMOFWizCtrl OLE control class.

#include "precomp.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <crtdbg.h>
#include <fstream.h>
#include <nddeapi.h>
#include <initguid.h>
#include "wbemidl.h"
//#include <utillib.h>
#include <afxcmn.h>
#include "MOFWiz.h"
#include "MOFWizCtl.h"
#include "MOFWizPpg.h"
#include "WrapListCtrl.h"
#include "hlb.h"
#include "MyPropertyPage1.h"
#include "MofGenSheet.h"
#include "MsgDlgExterns.h"
#include "WbemRegistry.h"
#include "htmlhelp.h"
#include "HTMTopics.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CMOFWizApp NEAR theApp;

class CWriteError
{
public:
	CWriteError();
	~CWriteError();
};

CWriteError::CWriteError()
{
}

CWriteError::~CWriteError()
{
}


#define FIREGENERATEMOF WM_USER + 737

IMPLEMENT_DYNCREATE(CMOFWizCtrl, COleControl)

#define UNICODE_SIGNATURE "\xff\xfe"
/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMOFWizCtrl, COleControl)
	//{{AFX_MSG_MAP(CMOFWizCtrl)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_LBUTTONUP()
	ON_WM_DESTROY()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_MOUSEMOVE()
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	ON_WM_ERASEBKGND()
	ON_WM_MOVE()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
	ON_MESSAGE(FIREGENERATEMOF, FireGenerateMOFMessage )
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CMOFWizCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CMOFWizCtrl)
	DISP_PROPERTY_EX(CMOFWizCtrl, "MOFTargets", GetMOFTargets, SetMOFTargets, VT_VARIANT)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CMOFWizCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CMOFWizCtrl, COleControl)
	//{{AFX_EVENT_MAP(CMOFWizCtrl)
	EVENT_CUSTOM("GenerateMOFs", FireGenerateMOFs, VTS_NONE)
	EVENT_CUSTOM("GetIWbemServices", FireGetIWbemServices, VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CMOFWizCtrl, 1)
	PROPPAGEID(CMOFWizPropPage::guid)
END_PROPPAGEIDS(CMOFWizCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMOFWizCtrl, "WBEM.MOFWizCtrl.1",
	0xf3b3a403, 0x3419, 0x11d0, 0x95, 0xf8, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CMOFWizCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DMOFWiz =
		{ 0xf3b3a401, 0x3419, 0x11d0, { 0x95, 0xf8, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const IID BASED_CODE IID_DMOFWizEvents =
		{ 0xf3b3a402, 0x3419, 0x11d0, { 0x95, 0xf8, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwMOFWizOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE ;


IMPLEMENT_OLECTLTYPE(CMOFWizCtrl, IDS_MOFWIZ, _dwMOFWizOleMisc)

//////////////////////////////////////////////////////////////////////////////
// Global variables

long gCountWizards = 0;




int StringCmp(const void *pc1,const void *pc2)
{
	CString *pcs1 = reinterpret_cast<CString*>(const_cast<void *>(pc1));
	CString *pcs2 = reinterpret_cast<CString*>(const_cast<void *>(pc2));

	int nReturn = pcs1->CompareNoCase(*pcs2);
	return nReturn;


}

void SortCStringArray(CStringArray &rcsaArray)
{
	int i;
	int nSize = (int) rcsaArray.GetSize();

	CString *pArray = new CString [nSize];

	for (i = 0; i < nSize; i++)
	{
		pArray[i] = rcsaArray.GetAt(i);
	}

	qsort( (void *)pArray, nSize, sizeof(CString), StringCmp );

	rcsaArray.RemoveAll();

	for (i = 0; i < nSize; i++)
	{
		 rcsaArray.Add(pArray[i]);
	}

	delete [] pArray;
}

void ErrorMsg
(CString *pcsUserMsg,  SCODE sc, IWbemClassObject *pErrorObject, BOOL bLog, CString *pcsLogMsg,
 char *szFile, int nLine, BOOL bNotification, UINT uType)
{
	HWND hFocus = ::GetFocus();

	CString csCaption = _T("MOF Wizard Message");
	BOOL bErrorObject = sc != S_OK;
	BSTR bstrTemp1 = csCaption.AllocSysString();
	BSTR bstrTemp2 = pcsUserMsg->AllocSysString();
	DisplayUserMessage
		(bstrTemp1,bstrTemp2,
		sc,bErrorObject,uType);
	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);

	::SendMessage(hFocus,WM_SETFOCUS,0,0);

	if (bLog)
	{
		LogMsg(pcsLogMsg,  szFile, nLine);

	}

}

void LogMsg
(CString *pcsLogMsg, char *szFile, int nLine)
{


}



//*********************************************************
// CreateAndInitVar
//
// Create a multibyte copy of a widechar string.
//
// Parameters:
//		[in] const CString& csIn
//			The string to copy.
//
//		[out] char*& szOut
//			A pointer to the newly allocated string is returned here.
//			The contents will be in the multi-byte character set.
//
// Returns:
//		The length of the returned string exclusive of the null
//		terminator.
//
//**********************************************************
int CreateAndInitVar(const CString& csIn, char *&szOut)
{
	int nInSize = csIn.GetLength();
	int nOutSize = nInSize * sizeof(TCHAR);
	szOut = new char[nOutSize + 1];
	if (csIn.IsEmpty()) {
		*szOut = 0;
		return 0;
	}


	BSTR bstrTmp =  csIn.AllocSysString();
	if (!bstrTmp) {
		*szOut = 0;
		return 0;
	}


	int nStrLen = WideCharToMultiByte(CP_ACP, 0,
						bstrTmp , nInSize,
						szOut, nOutSize,
						NULL, NULL);
	SysFreeString(bstrTmp);

	ASSERT(nStrLen >= 0);
	szOut[nStrLen] = 0;
	return nStrLen;
}

void DeleteVar(char *&szIn)
{
	delete [] szIn;
	szIn = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CMOFWizCtrl::CMOFWizCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CMOFWizCtrl

BOOL CMOFWizCtrl::CMOFWizCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to afxRegInsertable.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_MOFWIZ,
			IDB_MOFWIZ,
			afxRegInsertable | afxRegApartmentThreading,
			_dwMOFWizOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CMOFWizCtrl::CMOFWizCtrl - Constructor

CMOFWizCtrl::CMOFWizCtrl()
{
	InitializeIIDs(&IID_DMOFWiz, &IID_DMOFWizEvents);
	SetInitialSize (18, 16);
	m_bInitDraw = TRUE;
	m_pcilImageList = NULL;
	m_nImage = 0;
	m_pServices = NULL;
	m_pcgsPropertySheet = NULL;
	m_pcsaInstances = NULL;
	m_csEndl = _T("\n");
	m_bUnicode = FALSE;
	m_pfOut = NULL;

}


/////////////////////////////////////////////////////////////////////////////
// CMOFWizCtrl::~CMOFWizCtrl - Destructor

CMOFWizCtrl::~CMOFWizCtrl()
{

	if (m_pServices)
	{
		m_pServices -> Release();
	}

	delete m_pcgsPropertySheet;

	if (m_pcsaInstances)
	{
		delete [] m_pcsaInstances;
		m_pcsaInstances = NULL;
	}


}


/////////////////////////////////////////////////////////////////////////////
// CMOFWizCtrl::OnDraw - Drawing function

void CMOFWizCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{

	if (m_bInitDraw)
	{
		m_bInitDraw = FALSE;
		HICON m_hMOFWiz  = theApp.LoadIcon(IDI_MOFWIZ16);
		HICON m_hMOFWizSel  = theApp.LoadIcon(IDI_MOFWIZSEL16);

		m_pcilImageList = new CImageList();

		m_pcilImageList ->
			Create(32, 32, TRUE, 2, 2);

		m_pcilImageList -> Add(m_hMOFWiz);
		m_pcilImageList -> Add(m_hMOFWizSel);
	}




	POINT pt;
	pt.x=0;
	pt.y=0;

	m_pcilImageList -> Draw(pdc, m_nImage, pt, ILD_TRANSPARENT);



}


/////////////////////////////////////////////////////////////////////////////
// CMOFWizCtrl::DoPropExchange - Persistence support

void CMOFWizCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

}


/////////////////////////////////////////////////////////////////////////////
// CMOFWizCtrl::OnResetState - Reset control to default state

void CMOFWizCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CMOFWizCtrl::AboutBox - Display an "About" box to the user

void CMOFWizCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_MOFWIZ);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CMOFWizCtrl::PreCreateWindow - Modify parameters for CreateWindowEx

BOOL CMOFWizCtrl::PreCreateWindow(CREATESTRUCT& cs)
{
	// Add the Transparent style to the control
    cs.dwExStyle |= WS_EX_TRANSPARENT;

	return COleControl::PreCreateWindow(cs);
}




int CMOFWizCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (AmbientUserMode( ))
	{
//		HICON hIcon  = theApp.LoadIcon(IDI_MOFWIZ);
		m_pServices = NULL;

		if (m_ttip.Create(this))
		{
			m_ttip.Activate(TRUE);
			m_ttip.AddTool(this,_T("MOF Generator"));
		}
	}

	return 0;
}


void CMOFWizCtrl::OnSize(UINT nType, int cx, int cy)
{
	COleControl::OnSize(nType, cx, cy);


}

SCODE CMOFWizCtrl::MakeSafeArray(SAFEARRAY FAR ** pRet, VARTYPE vt, int iLen)
{
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iLen;
    *pRet = SafeArrayCreate(vt,1, rgsabound);
    return (*pRet == NULL) ? 0x80000001 : S_OK;
}

SCODE CMOFWizCtrl::PutStringInSafeArray
(SAFEARRAY FAR * psa,CString *pcs, int iIndex)
{
    long ix[2];
    ix[1] = 0;
    ix[0] = iIndex;
    HRESULT hResult = SafeArrayPutElement(psa,ix,pcs -> AllocSysString());
	return GetScode(hResult);
}

SCODE CMOFWizCtrl::GetStringFromSafeArray
(SAFEARRAY FAR * psa,CString *pcs, int iIndex)
{
	BSTR String;
    long ix[2];
    ix[1] = 0;
    ix[0] = iIndex;
    HRESULT hResult = SafeArrayGetElement(psa,ix,&String);
	*pcs = String;
	SysFreeString(String);
	return GetScode(hResult);
}


VARIANT CMOFWizCtrl::GetMOFTargets()
{
		VARIANT vaResult;
	VariantInit(&vaResult);

	int nTargets = (int) m_csaClassNames.GetSize();

	SAFEARRAY *psaTargets;
	MakeSafeArray (&psaTargets, VT_BSTR, nTargets);

	for (int i = 0; i < nTargets; i++)
	{
		PutStringInSafeArray (psaTargets, &m_csaClassNames.GetAt(i) , i);
	}

	vaResult.vt = VT_ARRAY | VT_BSTR;
	vaResult.parray = psaTargets;
	return vaResult;
}

void CMOFWizCtrl::SetMOFTargets(const VARIANT FAR& newValue)
{

	int n = (int) m_csaClassNames.GetSize();

	m_csaClassNames.RemoveAt(0,n);

	CString csPath;

	WORD test = VT_ARRAY|VT_BSTR;

	if(newValue.vt == test)
	{
		long ix[2] = {0,0};
		long lLower, lUpper;

		int iDim = SafeArrayGetDim(newValue.parray);
		SCODE sc = SafeArrayGetLBound(newValue.parray,1,&lLower);
		sc = SafeArrayGetUBound(newValue.parray,1,&lUpper);

		if (lUpper == 0)
		{
			CString csUserMsg =
					_T("There are no classes selected.  You must check the checkbox next to a class in the Class Tree in order to select it.");
			ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__);
			SetFocus();
			return;
		}

		ix[0] = lLower++;
		GetStringFromSafeArray
				(newValue.parray,&m_csNameSpace, ix[0]);


		m_pServices = InitServices(&m_csNameSpace);
		if (!m_pServices)
		{
			CString csUserMsg =
					_T("ConnectServer failure for ") + m_csNameSpace;
			ErrorMsg
					(&csUserMsg, m_sc, NULL, TRUE, &csUserMsg, __FILE__,
							__LINE__ - 8);
			SetFocus();
			return;
		}


		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
		{
			GetStringFromSafeArray
				(newValue.parray,&csPath, ix[0]);
			IWbemClassObject *phmmcoObject = NULL;
			IWbemClassObject *pErrorObject = NULL;
			BSTR bstrTemp = csPath.AllocSysString();
			SCODE sc =
			m_pServices ->
				GetObject
					(bstrTemp,0,NULL,&phmmcoObject,NULL);
			::SysFreeString(bstrTemp);
			if (sc == S_OK)
			{
				CString csClass = GetClassName(phmmcoObject);
				m_csaClassNames.Add(csClass);
				phmmcoObject -> Release();
				ReleaseErrorObject(pErrorObject);
			}
			else
			{
				CString csUserMsg;
				csUserMsg =  _T("Cannot get object ") + csPath;
				ErrorMsg
						(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__,
						__LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
			}
		}





		BOOL bReturn = FALSE;



		if (m_csaClassNames.GetSize() == 0 ||
			((bReturn = OnWizard(&m_csaClassNames) == FALSE)))
		{
			m_pServices->Release();
			m_pServices = NULL;
			SetFocus();
			return;
		}
		else
		{
			FinishMOFTargets();
			SetFocus();
		}

	}

	SetFocus();

}




//***************************************************************************
// CMOFWizCtrl::WriteMOFCommentHeader
//
// Generate the header at the beginning of the MOF file.
//
// Parameters:
//		[in] const CString& sMofFile
//			The name of the MOF file.
//
//		[in] IWbemClassObject *pco
//			The class object for getting the namespace
//
// Returns:
//		Nothing.
//
//**************************************************************************
void CMOFWizCtrl::WriteMOFCommentHeader(const CString& sMofFile, IWbemClassObject *pco)
{
	CString csProp = _T("__namespace");
	CString sNamespace = GetBSTRProperty(pco, &csProp);


	CString s;

	s = 	_T("//**************************************************************************")
		+ m_csEndl;
	WriteData(s);

	s =  _T("//* File: ") + sMofFile + m_csEndl;
	WriteData(s);

	s = 	_T("//**************************************************************************")
			+  m_csEndl + m_csEndl;
	WriteData(s);

	s = _T("//**************************************************************************")
		+ m_csEndl;
	WriteData(s);

	s = _T("//* This MOF was generated from the ");
	WriteData(s);

	s = _T("\"\\\\.\\") + sNamespace + _T("\"") + m_csEndl;
	WriteData(s);
	s = _T("//* namespace on machine \"") + GetMachineName() + "\"." + m_csEndl;
	WriteData(s);
	s = _T("//* To compile this MOF on another machine you should edit this pragma.");
	WriteData(s);

	s = m_csEndl + _T("//**************************************************************************")
		+ m_csEndl;
	WriteData(s);
	DoubleSlash(sNamespace);
	s =  _T("#pragma namespace(\"\\\\\\\\.\\\\") +
		sNamespace + _T("\")") + m_csEndl;
	WriteData(s);
}




//********************************************************************************
// CMOFWizCtrl::WriteClassDef
//
// Write a single class definition entry to the MOF file.
//
// Parameters:
//		[in] const CString& sMofFile
//			The MOF file name.
//
//		[in] IWbemClassObject *pco
//			Pointer to the class object for the class being written to the MOF file.
//
//		[in, out] BOOL& bFirst
//			This flag is initialized to TRUE prior to the first call to this method.  This
//			will cause some header information to be generated.  After the header has been
//			generated, this method sets the flag to false so that the header is not generated
//			from subsequent calls to this method.
//
// Returns:
//		Nothing.
//
//************************************************************************************
void CMOFWizCtrl::WriteClassDef(const CString& sMofFile, IWbemClassObject *pco, BOOL& bFirst)
{

	BSTR bstrOut = NULL;
	CString csMof;

	CString csSuperClass = GetSuperClassName(pco);
	CString csOutputString;

	SCODE sc = pco->GetObjectText(0,&bstrOut);
	if (sc == S_OK)
	{
		BOOL bIsSystemClass;
		CString csClass;
		try {
			m_bMOFIsEmpty = FALSE;
			if (bFirst)
			{
				// Write out the header, if this is the first entry.
				WriteMOFCommentHeader(sMofFile, pco);
				bFirst = FALSE;
			};

			csClass = GetClassName(pco);
			bIsSystemClass = csClass[0] == '_' ? TRUE : FALSE;

			if (bstrOut[0] == '\n')
			{
				csMof = bstrOut;
			}
			else
			{
				csMof = _T("\n");
				csMof += bstrOut;
			}
		}

		catch (CWriteError error) {
			m_bMOFIsEmpty = TRUE;
			SysFreeString(bstrOut);
			throw error;
		}

		SysFreeString(bstrOut);
		if (bIsSystemClass)
		{
			CommentOutDefinition(csMof);
		}

		csOutputString = m_csEndl +
			_T("//**************************************************************************")
			+ m_csEndl;
		WriteData(csOutputString);

		csOutputString = _T("//* Class: ") + csClass + m_csEndl;
		WriteData(csOutputString);

		csOutputString = _T("//* Derived from: ") + csSuperClass + m_csEndl;
		WriteData(csOutputString);

		if (bIsSystemClass)
		{
			csOutputString = _T("//* Informational only:  A system class definition will not compile.") + m_csEndl;
			WriteData(csOutputString);

		}

		csOutputString = 	_T("//**************************************************************************");
		WriteData(csOutputString);

		csOutputString = FixUpCrForUNICODE(csMof);
		WriteData(csOutputString);
	}
}



//***************************************************************************************
// CMOFWizCtrl::GenClassDef
//
// Generate the definition for a class.
//
// Parameters:
//		[in] LPCTSTR pszMofFile
//			The name of the MOF file.
//
//		[in] const CMapStringToPtr& mapClassGen
//			A string map containing the names of all the classes that will be generated.
//			All we care about is the existence of an entry in the table and not its
//			value.
//
//		[in, out] CMapStringToPtr& mapClassDef
//			A string map containing one entry for each class definition that has already
//			been generated.  All we care about is the existence of an entry in the table
//			and not its value.
//
//		[in, out] BOOL& bFirst
//			Initialized to TRUE to indicate that the header information has not been generated yet.
//			Set to FALSE after the header has been generated.
//
// Returns:
//		Nothing.
//
//******************************************************************************************
void CMOFWizCtrl::GenClassDef(LPCTSTR pszMofFile, const CMapStringToPtr& mapClassGen, CMapStringToPtr& mapClassDef, LPCTSTR pszClass, BOOL& bFirst)
{
	void* pMapValue = NULL;
	mapClassDef.SetAt(pszClass, pMapValue);

	IWbemClassObject *pco = NULL;
	IWbemClassObject *pcoError = NULL;
	CString csClass = pszClass;
	BSTR bstrTemp = csClass.AllocSysString();
	SCODE sc = m_pServices->GetObject(bstrTemp,0,NULL,&pco,NULL);
	::SysFreeString(bstrTemp);
	if (FAILED(sc))
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get object ") + csClass;
		ErrorMsg
				(&csUserMsg, sc, pcoError, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 32);
		if (pcoError) {
			ReleaseErrorObject(pcoError);
		}
		return;
	}

	// Check to see if the parent class definition has been generated yet.  If not, then
	// generate it now.
	CString csSuperClass;
	csSuperClass = GetSuperClassName(pco);
	if (!csSuperClass.IsEmpty()) {
		// If this class has a superclass, first check to see if it is one of the classes
		// that we will be generating.  If so, generate the superclass first so that it
		// is defined in the MOF before it is used.
		BOOL bGenerateSuperClass = mapClassGen.Lookup((LPCTSTR) csSuperClass, pMapValue);
		if (bGenerateSuperClass) {
			BOOL bFoundSuperClass = mapClassDef.Lookup((LPCTSTR) csSuperClass, pMapValue);
			if (!bFoundSuperClass) {
				GenClassDef(pszMofFile, mapClassGen, mapClassDef, csSuperClass, bFirst);
			}
		}
	}


	WriteClassDef(pszMofFile, pco, bFirst);
	pco -> Release();
	if (pcoError) {
		ReleaseErrorObject(pcoError);
	}
}



void CMOFWizCtrl::FinishMOFTargets()
{
	CString csFile;
	CString csMofName;

	int nDirLen = m_csMofDir.GetLength();

	if (m_csMofDir[nDirLen - 1] == '\\')
	{
		csFile = m_csMofDir + m_csMofFile;
	}
	else
	{
		csFile = m_csMofDir + "\\" + m_csMofFile;
	}
	csMofName = m_csMofFile;

	BOOL bOpen = OpenMofFile(csFile);

	if (!bOpen)
	{
		CString csUserMsg =
			_T("Cannot open file ")  + csFile + _T(" for output");
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 8);
		m_pServices->Release();
		m_pServices = NULL;
		return;
	}
	m_bMOFIsEmpty = TRUE;


	try
	{

		int nClasses = (int) m_csaClassNames.GetSize();
		int i;

		// Write all the class declarations out first in case there are
		// embedded object instances that reference one of the classes
		// that occur later in the output sequence.
		BOOL bFirst = TRUE;

		// Build a lookup table that has all of the class names that we're generating.
		// This gives us a quick way to find out whether we should generate a given
		// class.
		CMapStringToPtr mapClassGen;
		for (i=0; i<nClasses; ++i) {
			mapClassGen.SetAt(m_csaClassNames.GetAt(i), NULL);
		}

		// Define another map that is used to record which classes we have already
		// defined in the MOF.
		CMapStringToPtr mapClassDef;

		// Generate a definition for each class.
		for(i = 0; i < nClasses; i++)
		{
			// See if the user wanted this definition
			if(m_cbaIndicators[i])
			{
				CString csClass = m_csaClassNames.GetAt(i);
				GenClassDef(csMofName, mapClassGen, mapClassDef, csClass, bFirst);
			}
		}

		// Write the instances
		for(i = 0; i < nClasses; i++)
		{
			CString csClass = m_csaClassNames.GetAt(i);
			IWbemClassObject *phmmcoObject = NULL;
			IWbemClassObject *pErrorObject = NULL;
			BSTR bstrTemp = csClass.AllocSysString();
			SCODE sc =
			m_pServices ->GetObject(bstrTemp,0,NULL,&phmmcoObject,NULL);
			::SysFreeString(bstrTemp);
			if (sc == S_OK)
			{
				WriteInstances(phmmcoObject, &csMofName, i, bFirst);
				phmmcoObject -> Release();
				ReleaseErrorObject(pErrorObject);
			}
			else
			{
				CString csUserMsg;
				csUserMsg =  _T("Cannot get object ") + csClass;
				ErrorMsg
						(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__,
						__LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
			}


		}



		CString csOutputString =   m_csEndl + _T("//* EOF ") + csMofName +  m_csEndl;

		WriteData(csOutputString);

	}
	catch(CWriteError error) {
		m_bMOFIsEmpty = TRUE;
	}


	if (m_pfOut)
	{
		if (fflush(m_pfOut) != 0) {
			m_bMOFIsEmpty = TRUE;
			::MessageBox( GetSafeHwnd(),
					_T("Could not write output file"),
					_T("MOF Wizard Write Error"),
					MB_OK | MB_ICONEXCLAMATION |
					MB_APPLMODAL);

		}

	  fclose(m_pfOut);
	}

	CString csUserMsg;
	if (m_bMOFIsEmpty)
	{
		csUserMsg =  _T("No data was generated for ") + csFile;

	}
	else
	{

		csUserMsg =  _T("Generation of ") + csFile + _T(" complete");
	}

	ErrorMsg
			(&csUserMsg, S_OK, NULL, FALSE, NULL, __FILE__,
			__LINE__, TRUE, MB_ICONINFORMATION);

	m_pServices->Release();
	m_pServices = NULL;

	SetModifiedFlag();

}





void CMOFWizCtrl::MOFEntry(CString *pcsMofName, IWbemClassObject *phmmcoObject, int nIndex, BOOL &bFirst, BOOL bWriteInstances)
{
	if (!m_cbaIndicators.GetAt(nIndex))
	{
		WriteInstances(phmmcoObject, pcsMofName, nIndex, bFirst);
		return;
	}


	CString csSuperClass;
	csSuperClass = GetSuperClassName(phmmcoObject);


	BSTR bstrOut = NULL;
	CString csMof;

	SCODE sc = phmmcoObject -> GetObjectText(0,&bstrOut);

	CString csOutputString;

	if (sc == S_OK)
	{
		BOOL bIsSystemClass;
		CString csClass;
		try {
			m_bMOFIsEmpty = FALSE;
			if (bFirst)
			{
				csOutputString = 	_T("//**************************************************************************")
					+ m_csEndl;
				WriteData(csOutputString);
				csOutputString =  _T("//* File: ") + *pcsMofName + m_csEndl;
				WriteData(csOutputString);
				csOutputString = 	_T("//**************************************************************************")
						+  m_csEndl + m_csEndl;
				WriteData(csOutputString);
				CString csProp = _T("__namespace");
				CString csNamespace =
					GetBSTRProperty(phmmcoObject,&csProp);
				csOutputString = _T("//**************************************************************************")
					+ m_csEndl;
				WriteData(csOutputString);
				csOutputString = _T("//* This MOF was generated from the ");
				WriteData(csOutputString);
				csOutputString = _T("\"\\\\.\\") + csNamespace + _T("\"") + m_csEndl;
				WriteData(csOutputString);
				csOutputString = _T("//* namespace on machine \"") + GetMachineName() + "\"." + m_csEndl;
				WriteData(csOutputString);
				csOutputString = _T("//* To compile this MOF on another machine you should edit this pragma.");
				WriteData(csOutputString);
				csOutputString = m_csEndl + _T("//**************************************************************************")
					+ m_csEndl;
				WriteData(csOutputString);
				DoubleSlash(csNamespace);
				csOutputString =  _T("#pragma namespace(\"\\\\\\\\.\\\\") +
					csNamespace + _T("\")") + m_csEndl;
				WriteData(csOutputString);
				bFirst = FALSE;
			};
			csClass = GetClassName(phmmcoObject);
			csSuperClass = GetSuperClassName(phmmcoObject);
			bIsSystemClass = csClass[0] == '_' ? TRUE : FALSE;

			if (bstrOut[0] == '\n')
			{
				csMof = bstrOut;
			}
			else
			{
				csMof = _T("\n");
				csMof += bstrOut;
			}
		}

		catch (CWriteError error) {
			m_bMOFIsEmpty = TRUE;
			SysFreeString(bstrOut);
			throw error;
		}

		SysFreeString(bstrOut);
		if (bIsSystemClass)
		{
			CommentOutDefinition(csMof);
		}

		csOutputString = m_csEndl +
			_T("//**************************************************************************")
			+ m_csEndl;
		WriteData(csOutputString);

		csOutputString = _T("//* Class: ") + csClass + m_csEndl;
		WriteData(csOutputString);

		csOutputString = _T("//* Derived from: ") + csSuperClass + m_csEndl;
		WriteData(csOutputString);

		if (bIsSystemClass)
		{
			csOutputString = _T("//* Informational only:  A system class definition will not compile.") + m_csEndl;
			WriteData(csOutputString);

		}

		csOutputString = 	_T("//**************************************************************************");
		WriteData(csOutputString);
		csOutputString = FixUpCrForUNICODE(csMof);

		WriteData(csOutputString);
		if (bWriteInstances) {
			WriteInstances(phmmcoObject, pcsMofName, nIndex, bFirst);
		}
	}
}

void CMOFWizCtrl::CommentOutDefinition(CString &rcsMof)
{
	CString csTemp;

	int nLastNL = rcsMof.ReverseFind('\n');
	for (int i = 0; i < rcsMof.GetLength(); i++)
	{
		csTemp += rcsMof[i];
		if (rcsMof[i] == '\n' && nLastNL != i)
		{
			csTemp += _T("//* ");

		}
	}

	rcsMof = csTemp;

}

//***************************************************************************
//
// InitServices
//
// Purpose:
//
//***************************************************************************
IWbemServices *CMOFWizCtrl::InitServices
(CString *pcsNameSpace)
{

    IWbemServices *pSession = 0;
    IWbemServices *pChild = 0;


	CString csObjectPath;

    // hook up to default namespace
	if (pcsNameSpace == NULL)
	{
		csObjectPath = _T("root\\cimv2");
	}
	else
	{
		csObjectPath = *pcsNameSpace;
	}

    CString csUser = _T("");

    pSession = GetIWbemServices(csObjectPath);

    return pSession;
}

IWbemServices *CMOFWizCtrl::GetIWbemServices
(CString &rcsNamespace)
{
	IUnknown *pServices = NULL;

	BOOL bUpdatePointer= FALSE;

	m_sc = S_OK;
	m_bUserCancel = FALSE;

	VARIANT varUpdatePointer;
	VariantInit(&varUpdatePointer);
	varUpdatePointer.vt = VT_I4;
	if (bUpdatePointer == TRUE)
	{
		varUpdatePointer.lVal = 1;
	}
	else
	{
		varUpdatePointer.lVal = 0;
	}

	VARIANT varService;
	VariantInit(&varService);

	VARIANT varSC;
	VariantInit(&varSC);

	VARIANT varUserCancel;
	VariantInit(&varUserCancel);

	FireGetIWbemServices
		((LPCTSTR)rcsNamespace,  &varUpdatePointer,  &varService, &varSC,
		&varUserCancel);

	if (varService.vt & VT_UNKNOWN)
	{
		pServices = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}

	varService.punkVal = NULL;

	VariantClear(&varService);

	if (varSC.vt == VT_I4)
	{
		m_sc = varSC.lVal;
	}
	else
	{
		m_sc = WBEM_E_FAILED;
	}

	VariantClear(&varSC);

	if (varUserCancel.vt == VT_BOOL)
	{
		m_bUserCancel = varUserCancel.boolVal;
	}

	VariantClear(&varUserCancel);

	VariantClear(&varUpdatePointer);

	IWbemServices *pRealServices = NULL;
	if (m_sc == S_OK && !m_bUserCancel)
	{
		pRealServices = reinterpret_cast<IWbemServices *>(pServices);
	}

	return pRealServices;
}

void CMOFWizCtrl::OnDestroy()
{
	try
	{
		HWND hWnd = HtmlHelp(NULL,NULL,HH_CLOSE_ALL,0);

	}

	catch( ... )
	{
		// Handle any exceptions here.
		int n = 4;
	}

	COleControl::OnDestroy();

	delete m_pcilImageList;

}

void CMOFWizCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	RelayEvent(WM_LBUTTONDOWN, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));

	//COleControl::OnLButtonDown(nFlags, point);
}

void CMOFWizCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	SetFocus();
	OnActivateInPlace(TRUE,NULL);
	RelayEvent(WM_LBUTTONUP, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));

}

void CMOFWizCtrl::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	FireGenerateMOFs();
}

long CMOFWizCtrl::FireGenerateMOFMessage (UINT uParam, LONG lParam)
{

	FireGenerateMOFs();
	InvalidateControl();
	return 0;
}

void CMOFWizCtrl::WriteInstances(IWbemClassObject *pIWbemClassObject,
			   CString *pcsMofName, int nIndex, BOOL &bFirst)
{

	int nInstances = (int) m_pcsaInstances[nIndex].GetSize();

	if (nInstances == 0)
	{
		return;
	}

	CString csOutputString;

	if (bFirst)
	{
		csOutputString = _T("//**************************************************************************")
			+ m_csEndl;
		//ofsMof << csOutputString;
		WriteData(csOutputString);
		//	_T("//**************************************************************************")
		//	<< m_csEndl;
		csOutputString = _T("//* File: ") + *pcsMofName + m_csEndl;
		//ofsMof << csOutputString;
		WriteData(csOutputString);
		//_T("//* File: ") << *pcsMofName << m_csEndl;;
		csOutputString = _T("//**************************************************************************")
				+ m_csEndl + m_csEndl;
		//ofsMof <<  csOutputString;
		WriteData(csOutputString);
		//_T("//**************************************************************************")
		//<< m_csEndl << m_csEndl;
		csOutputString = _T("//**************************************************************************")
			+ m_csEndl;
		//ofsMof <<  csOutputString;
		WriteData(csOutputString);
		//	_T("//**************************************************************************")
		//	<< m_csEndl;
		CString csProp = _T("__namespace");
		CString csNamespace =
				GetBSTRProperty(pIWbemClassObject,&csProp);
		csOutputString = _T("//* This MOF was generated from the ");
		//ofsMof << csOutputString;
		WriteData(csOutputString);
		// _T("//* This MOF was generated from the ");
		csOutputString = _T("\"\\\\.\\") + csNamespace + _T("\"") + m_csEndl;
		//ofsMof << csOutputString;
		WriteData(csOutputString);
		// _T("\"\\\\.\\") << csNamespace << _T("\"") << m_csEndl;
		csOutputString = _T("//* namespace on machine \"") + GetMachineName() + "\"." + m_csEndl;
		//ofsMof << csOutputString;
		WriteData(csOutputString);
		// _T("//* namespace on machine \"") << GetMachineName() << "\"." << m_csEndl;
		csOutputString = _T("//* To compile this MOF on another machine you should edit this pragma.");
		//ofsMof << csOutputString;
		WriteData(csOutputString);
		// _T("//* To compile this MOF on another machine you should edit this pragma.");
		csOutputString = m_csEndl + _T("//**************************************************************************")
			+ m_csEndl;
		//ofsMof << csOutputString;
		WriteData(csOutputString);
		//	_T("\n//**************************************************************************")
		//	<< m_csEndl;
		DoubleSlash(csNamespace);
		csOutputString =  _T("#pragma namespace(\"\\\\\\\\.\\\\") +
			csNamespace + _T("\")") + m_csEndl;
		//ofsMof << csOutputString;
		WriteData(csOutputString);
		//_T("#pragma namespace(\"\\\\\\\\.\\\\") +
		//	csNamespace << _T("\")") << m_csEndl;
		bFirst = FALSE;
	};

	CString csClass = GetClassName(pIWbemClassObject);
	CString csMof;

	int i;
	BOOL bFirstInstanceBanner = TRUE;
	for (i = 0; i < nInstances; i++)
	{
		CString csPath=
			m_pcsaInstances[nIndex].GetAt(i);
		IWbemClassObject *phmmcoObject = NULL;
		IWbemClassObject *pErrorObject = NULL;
		BSTR bstrTemp = csPath.AllocSysString();
		SCODE sc =
			m_pServices ->
				GetObject
					(bstrTemp,0,NULL, &phmmcoObject,NULL);
		::SysFreeString(bstrTemp);
		if (sc != S_OK)
		{
			CString csUserMsg;
			csUserMsg =  _T("Cannot get object ") + csPath;
			ErrorMsg
					(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__,
					__LINE__ - 9);
			ReleaseErrorObject(pErrorObject);
		}
		else
		{
			BSTR bstrOut = NULL;
			sc = phmmcoObject -> GetObjectText(0,&bstrOut);
			ReleaseErrorObject(pErrorObject);
			try {
				if (sc == S_OK)
				{
					m_bMOFIsEmpty = FALSE;
					if (bFirstInstanceBanner)
					{
						bFirstInstanceBanner = FALSE;
						csOutputString =  m_csEndl +
								_T("//**************************************************************************")
								+ m_csEndl;
						//ofsMof << csOutputString;
						WriteData(csOutputString);
							//m_csEndl <<
							//	_T("//**************************************************************************")
							//	<< m_csEndl;
						csOutputString = _T("//* Instances of: ") + csClass + m_csEndl;
						//ofsMof << csOutputString;
						WriteData(csOutputString);
						//_T("//* Instances of: ") << csClass << m_csEndl;;
						csOutputString = _T("//**************************************************************************");
						//ofsMof <<  csOutputString;
						WriteData(csOutputString);
						//	_T("//**************************************************************************");
					}
					else
					{
						//ofsMof << m_csEndl;
					}

					csMof = bstrOut;
					csOutputString = FixUpCrForUNICODE(csMof);
					//ofsMof << csOutputString;
					WriteData(csOutputString);
						// csMof;
				}
			}
			catch (CWriteError error) {
				m_bMOFIsEmpty = TRUE;
				if (bstrOut) {
					SysFreeString(bstrOut);
				}
				phmmcoObject->Release();
				throw error;
			}

			if (bstrOut) {
				SysFreeString(bstrOut);
			}
			phmmcoObject -> Release();
		}
	}

	return;
}




CString CMOFWizCtrl::GetClassName(IWbemClassObject *pClass)
{

	CString csProp = _T("__Class");
	return GetBSTRProperty(pClass,&csProp);


}

CString CMOFWizCtrl::GetSuperClassName(IWbemClassObject *pClass)
{

	CString csProp = _T("__SuperClass");
	return GetBSTRProperty(pClass,&csProp);


}

CString CMOFWizCtrl::GetBSTRProperty
(IWbemClassObject * pInst, CString *pcsProperty)
{
	SCODE sc;
	CString csOut;


    VARIANTARG var;
	VariantInit(&var);

	BSTR bstrTemp = pcsProperty -> AllocSysString ( );
    sc = pInst->Get(bstrTemp  ,0,&var,NULL,NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		return csOut;
	}

	if (var.vt == VT_BSTR)
		csOut = var.bstrVal;

	VariantClear(&var);
	return csOut;
}

void CMOFWizCtrl::ReleaseErrorObject(IWbemClassObject *&rpErrorObject)
{
	if (rpErrorObject)
	{
		rpErrorObject->Release();
		rpErrorObject = NULL;
	}


}



void CMOFWizCtrl::DoubleSlash(CString &csNamespace)
{
	CString csTmp = csNamespace;
	WCHAR *wcTmp = new WCHAR[csTmp.GetLength() * 2];
	csNamespace.Empty();
	int i;
	int n;
	for (i = 0, n = 0; i < csTmp.GetLength(); i++)
	{
		if (csTmp[i] == '\\')
		{
			wcTmp[n++] = '\\';
			wcTmp[n++] = '\\';
		}
		else
		{
			wcTmp[n++] = csTmp[i];
		}

	}
	wcTmp[n] = '\0';
	csNamespace = wcTmp;
	delete [] wcTmp;


}

BOOL CMOFWizCtrl::OnWizard(CStringArray *pcsaClasses)
{

	if (InterlockedIncrement(&gCountWizards) > 1)
	{
			CString csUserMsg =
					_T("Only one \"MOF Generator Wizard\" can run at a time.");
			ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__);
			InterlockedDecrement(&gCountWizards);
			return FALSE;
	}

	m_csMofFile.Empty();
	m_csMofDir.Empty();
	m_cbaIndicators.RemoveAll();
	if (m_pcsaInstances)
	{
		delete [] m_pcsaInstances;
		m_pcsaInstances = NULL;
	}

	int nClasses = (int) pcsaClasses->GetSize();

	if (nClasses <= 0)
	{
		return FALSE;
	}

	for (int i = 0; i < nClasses; i++)
	{
		m_cbaIndicators.Add(1);
	}


	if (m_pcgsPropertySheet)
	{
		delete m_pcgsPropertySheet;
		m_pcgsPropertySheet = NULL;
	}

	m_pcgsPropertySheet = new
						CMofGenSheet(this);


	PreModalDialog();

	int nReturn;

	nReturn = (int) m_pcgsPropertySheet->DoModal();


	PostModalDialog();

	InterlockedDecrement(&gCountWizards);

	if (nReturn == ID_WIZFINISH)
	{
		return TRUE;
	}
	else
	{
		delete m_pcgsPropertySheet;
		m_pcgsPropertySheet = NULL;
		return FALSE;
	}

}

void CMOFWizCtrl::RelayEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
      if (NULL != m_ttip.m_hWnd)
	  {
         MSG msg;

         msg.hwnd= m_hWnd;
         msg.message= message;
         msg.wParam= wParam;
         msg.lParam= lParam;
         msg.time= 0;
         msg.pt.x= LOWORD (lParam);
         msg.pt.y= HIWORD (lParam);

         m_ttip.RelayEvent(&msg);
     }
}

void CMOFWizCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	RelayEvent(WM_MOUSEMOVE, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));

	COleControl::OnMouseMove(nFlags, point);
}

CString CMOFWizCtrl::GetMachineName()
{

	CString csNameSpace = m_csNameSpace;

	CString csReturn;

	if (csNameSpace.GetLength() > 1 &&
		csNameSpace[0] == '\\' &&
		csNameSpace[1] == '\\')
	{
		csReturn = csNameSpace.Mid(2);
		int iEnd = csReturn.Find('\\');
		if (iEnd > -1)
		{
			CString csTmp = csNameSpace.Left(iEnd + 2);
			return csTmp.Right(csTmp.GetLength() - 2);
		}
		else
		{
			return csNameSpace.Right(csNameSpace.GetLength() - 2);
		}


	}

	return GetPCMachineName();
}

CString CMOFWizCtrl::GetPCMachineName()
{
    static wchar_t ThisMachine[MAX_COMPUTERNAME_LENGTH+1];
    char ThisMachineA[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwSize = sizeof(ThisMachineA);
    GetComputerNameA(ThisMachineA, &dwSize);
    MultiByteToWideChar(CP_ACP, 0, ThisMachineA, -1,
			ThisMachine, dwSize);

    return ThisMachine;
}

CString CMOFWizCtrl::GetNamespaceMachineName()
{
	BSTR bStr = m_csNameSpace.AllocSysString();
	CObjectPathParser coppPath;
	ParsedObjectPath *ppopOutput;
	coppPath.Parse(bStr, &ppopOutput);
	::SysFreeString(bStr);
	CString csServer = ppopOutput -> m_pServer;
	delete ppopOutput;
	return csServer;

}





int CMOFWizCtrl::WriteData(CString &csOutputString)
{

	int nCh;
	int nWritten = -1;
	if (m_bUnicode)
	{
		nCh = csOutputString.GetLength();

#if _UNICODE
		nWritten = ::fwrite( (void*) (LPCTSTR) csOutputString, sizeof(TCHAR), csOutputString.GetLength(), m_pfOut);
#else
		BSTR bstrOutputString = csOutputString.AllocSysString();
		nWritten = ::fwrite( (void*) bstrOutputString, sizeof(WCHAR), nCh, m_pfOut);
		SysFreeString(bstrOutputString);
#endif //_UNICODE
	}
	else
	{
		char *szTmp;
		nCh = CreateAndInitVar(csOutputString,szTmp);
		nWritten = ::fwrite( (void*) szTmp, sizeof(char), nCh, m_pfOut);
		DeleteVar(szTmp);
	}

	if (nWritten < nCh) {
		::MessageBox( GetSafeHwnd(),
				_T("Could not write output file"),
				_T("File Write Error"),
				MB_OK | MB_ICONEXCLAMATION |
				MB_APPLMODAL);
		throw CWriteError();

	}

	return nWritten;
}

BOOL CMOFWizCtrl::OpenMofFile(CString &rcsPath)
{
	if (m_bUnicode)
	{
		m_csEndl = L"\r\n";
		m_pfOut = _tfopen(rcsPath, _T("wb"));
	}
	else
	{
		m_pfOut = _tfopen(rcsPath, _T("wt"));
	}

    if (m_pfOut == NULL)
	{
		return FALSE;
     }
	if (m_bUnicode)
	{
         fputs(UNICODE_SIGNATURE, m_pfOut);
	}

	return TRUE;

}

CString CMOFWizCtrl::FixUpCrForUNICODE(CString &rcsMof)
{

	if (!m_bUnicode)
	{
		return rcsMof;
	}

	CString csOut;

	for (int i = 0; i < rcsMof.GetLength(); i++)
	{
		if (rcsMof[i] == '\n')
		{
			csOut += m_csEndl;
		}
		else
		{
			csOut += rcsMof[i];
		}
	}

	return csOut;
}

void CMOFWizCtrl::InvokeHelp()
{
	// TODO: Add your message handler code here and/or call default

	CString csPath;
	WbemRegString(SDK_HELP, csPath);


	CString csData = idh_mofgenwiz;


	HWND hWnd = NULL;

	try
	{
		HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD_PTR) (LPCTSTR) csData);
		if (!hWnd)
		{
			CString csUserMsg;
			csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");

			ErrorMsg
					(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		}

	}

	catch( ... )
	{
		// Handle any exceptions here.
		CString csUserMsg;
		csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");

		ErrorMsg
				(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
	}



}

CString CMOFWizCtrl::GetSDKDirectory()
{
	CString csHmomWorkingDir;
	HKEY hkeyLocalMachine;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hkeyLocalMachine);
	if (lResult != ERROR_SUCCESS) {
		return "";
	}




	HKEY hkeyHmomCwd;

	lResult = RegOpenKeyEx(
				hkeyLocalMachine,
				_T("SOFTWARE\\Microsoft\\Wbem"),
				0,
				KEY_READ | KEY_QUERY_VALUE,
				&hkeyHmomCwd);

	if (lResult != ERROR_SUCCESS) {
		RegCloseKey(hkeyLocalMachine);
		return "";
	}





	unsigned long lcbValue = 1024;
	LPTSTR pszWorkingDir = csHmomWorkingDir.GetBuffer(lcbValue);


	unsigned long lType;
	lResult = RegQueryValueEx(
				hkeyHmomCwd,
				_T("SDK Directory"),
				NULL,
				&lType,
				(unsigned char*) (void*) pszWorkingDir,
				&lcbValue);


	csHmomWorkingDir.ReleaseBuffer();
	RegCloseKey(hkeyHmomCwd);
	RegCloseKey(hkeyLocalMachine);

	if (lResult != ERROR_SUCCESS)
	{
		csHmomWorkingDir.Empty();
	}

	return csHmomWorkingDir;
}

BOOL CMOFWizCtrl::PreTranslateMessage(MSG* lpMsg)
{
	// TODO: Add your specialized code here and/or call the base class

	BOOL bDidTranslate;

	bDidTranslate = COleControl::PreTranslateMessage(lpMsg);

	if (bDidTranslate)
	{
		return bDidTranslate;
	}

	if  (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_RETURN)
	{
		PostMessage(FIREGENERATEMOF,0,0);
	}

	if ((lpMsg->message == WM_KEYUP || lpMsg->message == WM_KEYDOWN) &&
		lpMsg->wParam == VK_TAB)
	{
		return FALSE;
	}

	return PreTranslateInput (lpMsg);
}

void CMOFWizCtrl::OnKillFocus(CWnd* pNewWnd)
{
	COleControl::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	m_nImage = 0;
	InvalidateControl();

}

void CMOFWizCtrl::OnSetFocus(CWnd* pOldWnd)
{
	COleControl::OnSetFocus(pOldWnd);

	// TODO: Add your message handler code here
	OnActivateInPlace(TRUE,NULL);
	m_nImage = 1;
	InvalidateControl();
}



BOOL CMOFWizCtrl::OnEraseBkgnd(CDC* pDC)
{
	 // This is needed for transparency and the correct drawing...
	 CWnd*  pWndParent;       // handle of our parent window
	 POINT  pt;

	 pWndParent = GetParent();
	 pt.x       = 0;
	 pt.y       = 0;

	 MapWindowPoints(pWndParent, &pt, 1);
	 OffsetWindowOrgEx(pDC->m_hDC, pt.x, pt.y, &pt);
	 ::SendMessage(pWndParent->m_hWnd, WM_ERASEBKGND,
				  (WPARAM)pDC->m_hDC, 0);
	 SetWindowOrgEx(pDC->m_hDC, pt.x, pt.y, NULL);

	 return 1;
}




void CMOFWizCtrl::OnSetClientSite()
{
	m_bAutoClip = TRUE;

	COleControl::OnSetClientSite();
}

void CMOFWizCtrl::OnMove(int x, int y)
{
	COleControl::OnMove(x, y);

	// TODO: Add your message handler code here
	InvalidateControl();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\mofwizppg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MOFWizPpg.cpp : Implementation of the CMOFWizPropPage property page class.

#include "precomp.h"
#include "MOFWiz.h"
#include "MOFWizPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMOFWizPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMOFWizPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CMOFWizPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMOFWizPropPage, "WBEM.MOFWizPropPage.1",
	0xf3b3a404, 0x3419, 0x11d0, 0x95, 0xf8, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// CMOFWizPropPage::CMOFWizPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CMOFWizPropPage

BOOL CMOFWizPropPage::CMOFWizPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_MOFWIZ_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CMOFWizPropPage::CMOFWizPropPage - Constructor

CMOFWizPropPage::CMOFWizPropPage() :
	COlePropertyPage(IDD, IDS_MOFWIZ_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CMOFWizPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CMOFWizPropPage::DoDataExchange - Moves data between page and properties

void CMOFWizPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CMOFWizPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CMOFWizPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\mypropertypage1.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MyPropertyPage1.Mof : implementation file
//
#include "precomp.h"
#include <fstream.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <direct.h>
#include "resource.h"
#include <SHLOBJ.H>
#include "wbemidl.h"
#include <afxcmn.h>
#include "MOFWiz.h"
#include "MOFWizCtl.h"
#include <afxcmn.h>
#include "WrapListCtrl.h"
#include "hlb.h"
#include "MyPropertyPage1.h"
#include "MofGenSheet.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CMyPropertyPage1, CPropertyPage)
IMPLEMENT_DYNCREATE(CMyPropertyPage2, CPropertyPage)
IMPLEMENT_DYNCREATE(CMyPropertyPage3, CPropertyPage)
IMPLEMENT_DYNCREATE(CMyPropertyPage4, CPropertyPage)

#define IDH_actx_WBEM_Developer_Studio 200

int GetCBitmapWidth(const CBitmap & cbm)
{

	BITMAP bm;
	cbm.GetObject(sizeof(BITMAP),&bm);
	return bm.bmWidth;
}

int GetCBitmapHeight(const CBitmap & cbm)
{
	BITMAP bm;
	cbm.GetObject(sizeof(BITMAP),&bm);
	return bm.bmHeight;
}


HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPCTSTR lpString,
                           HPALETTE FAR* lphPalette)
{
    HRSRC  hRsrc;
    HGLOBAL hGlobal;
    HBITMAP hBitmapFinal = NULL;
    LPBITMAPINFOHEADER  lpbi;
    HDC hdc;
    int iNumColors;

    if (hRsrc = FindResource(hInstance, lpString, RT_BITMAP))
       {
       hGlobal = LoadResource(hInstance, hRsrc);
       lpbi = (LPBITMAPINFOHEADER)LockResource(hGlobal);

       hdc = GetDC(NULL);
       *lphPalette =  CreateDIBPalette ((LPBITMAPINFO)lpbi, &iNumColors);
       if (*lphPalette)
          {
          SelectPalette(hdc,*lphPalette,FALSE);
          RealizePalette(hdc);
          }

       hBitmapFinal = CreateDIBitmap(hdc,
                   (LPBITMAPINFOHEADER)lpbi,
                   (LONG)CBM_INIT,
                   (LPSTR)lpbi + lpbi->biSize + iNumColors *
sizeof(RGBQUAD),

                   (LPBITMAPINFO)lpbi,
                   DIB_RGB_COLORS );

       ReleaseDC(NULL,hdc);
       UnlockResource(hGlobal);
       FreeResource(hGlobal);
       }
    return (hBitmapFinal);
}

HPALETTE CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors)
{
   LPBITMAPINFOHEADER  lpbi;
   LPLOGPALETTE     lpPal;
   HANDLE           hLogPal;
   HPALETTE         hPal = NULL;
   int              i;

   lpbi = (LPBITMAPINFOHEADER)lpbmi;
   if (lpbi->biBitCount <= 8)
       *lpiNumColors = (1 << lpbi->biBitCount);
   else
       *lpiNumColors = 0;  // No palette needed for 24 BPP DIB

   if (*lpiNumColors)
      {
      hLogPal = GlobalAlloc (GHND, sizeof (LOGPALETTE) +
                             sizeof (PALETTEENTRY) * (*lpiNumColors));
      lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
      lpPal->palVersion    = 0x300;
      lpPal->palNumEntries = (WORD)*lpiNumColors; // NOTE: lpiNumColors should NEVER be greater than 256 (1<<8 from above)

      for (i = 0;  i < *lpiNumColors;  i++)
         {
         lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
         lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
         lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
         lpPal->palPalEntry[i].peFlags = 0;
         }
      hPal = CreatePalette (lpPal);
      GlobalUnlock (hLogPal);
      GlobalFree   (hLogPal);
   }
   return hPal;
}

BOOL StringInArray
(CStringArray *&rpcsaArrays, CString *pcsString, int nIndex)
{
	for (int i = 0; i < rpcsaArrays[nIndex].GetSize(); i++)
	{
		if (pcsString->CompareNoCase(rpcsaArrays[nIndex].GetAt(i)) == 0)
		{
			return TRUE;
		}

	}

	return FALSE;

}

#if 0
BOOL TryToFindShare(CString *pcsDir)
{

	char szShare[MAX_PATH];

	::wcstombs(szShare,*pcsDir,pcsDir->GetLength());

	NETRESOURCE nr;
	nr.dwScope = RESOURCE_GLOBALNET;
	nr.dwType = RESOURCETYPE_ANY;
	nr.dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
	nr.dwUsage = RESOURCEUSAGE_CONNECTABLE;
	nr.lpLocalName = NULL;
	nr.lpRemoteName = const_cast<LPTSTR> ((LPCTSTR) *pcsDir); // szShare;
	nr.lpComment = NULL;
	nr.lpProvider = NULL;
	LPVOID pMem =  HeapAlloc(GetProcessHeap(),
		HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, 16384);

	if (!pMem)
	{
		return FALSE;
	}


	HANDLE hWNetEnum=NULL;
	DWORD dwStatus = WNetOpenEnum(RESOURCE_GLOBALNET, RESOURCETYPE_ANY,
									RESOURCEUSAGE_CONTAINER, &nr, &hWNetEnum);

	if (dwStatus != NO_ERROR)
	{
		return FALSE;
	}

	BOOL bReturn = FALSE;
	DWORD dwEntries;
	DWORD dwBuffSize;
	dwEntries =1;
	dwBuffSize= 16384;
	dwStatus = WNetEnumResource(hWNetEnum, &dwEntries, pMem, &dwBuffSize);
	if (dwStatus == NO_ERROR || dwStatus == ERROR_NO_MORE_ITEMS)
	{
		bReturn = TRUE;
	}

	HeapFree(GetProcessHeap(), 0, pMem);
	WNetCloseEnum(hWNetEnum);

	return bReturn;

}
#endif


BOOL TryToFindShare(CString *pcsDir)
{
	// Need to append *.* to the share because FindFirstFile will not
	// find shares but will find files in shares, even empty shares.

	CString csTemp = *pcsDir + _T("\\*.*");

	WIN32_FIND_DATA wfdFile;
	HANDLE hFile =
		FindFirstFile(
			(LPCTSTR) csTemp, &wfdFile);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}
	else
	{

		return TRUE;
	}
}


BOOL TryToFindDirectory(CString *pcsDir)
{

	if (pcsDir->GetLength() < 3 && pcsDir->GetLength() >= 2 && (*pcsDir)[1] == ':')
	{
		UINT  uDriveType = GetDriveType((LPCTSTR) *pcsDir);

		if (!(uDriveType == DRIVE_UNKNOWN  || uDriveType ==DRIVE_NO_ROOT_DIR))
		{
			return TRUE;
		}
	}

	if (pcsDir->GetLength() > 2 && (*pcsDir)[0] == '\\' && (*pcsDir)[1] == '\\')
	{
		// We have a UNC name like \\foocomputer\sharename.
		return TryToFindShare(pcsDir);

	}

	WIN32_FIND_DATA wfdFile;
	HANDLE hFile =
		FindFirstFile(
			(LPCTSTR) *pcsDir, &wfdFile);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		DWORD dw = GetLastError();
		return FALSE;
	}

	int n = pcsDir->ReverseFind('\\');

	CString csFile;

	if (n == -1)
	{
		csFile = *pcsDir;
	}
	else
	{
		csFile = pcsDir->Right((pcsDir->GetLength() - 1) - n);
	}


	if (csFile.CompareNoCase(wfdFile.cFileName) != 0)
	{
		return FALSE;
	}


	BOOL bValue = wfdFile.dwFileAttributes && FILE_ATTRIBUTE_DIRECTORY;

	return wfdFile.dwFileAttributes && FILE_ATTRIBUTE_DIRECTORY;
}

BOOL IsDriveValid(CWnd *pcwnd, CString *pcsDir, BOOL bRetry)
{
	if (pcsDir->GetLength() < 3 && pcsDir->GetLength() >= 2 && (*pcsDir)[1] == ':')
	{
		UINT  uDriveType = GetDriveType((LPCTSTR) *pcsDir);

		if (!(uDriveType == DRIVE_UNKNOWN  || uDriveType == DRIVE_NO_ROOT_DIR || uDriveType == DRIVE_CDROM))
		{
			CString csFile = *pcsDir + _T("f45b789");
			SECURITY_ATTRIBUTES saTemp;
			saTemp.nLength = sizeof(SECURITY_ATTRIBUTES);
			saTemp.lpSecurityDescriptor = NULL;
			saTemp.bInheritHandle = TRUE;

			HANDLE hTemp = CreateFile
							((LPCTSTR) csFile,
							GENERIC_WRITE,
							FILE_SHARE_WRITE,
							&saTemp,
							CREATE_ALWAYS,
							FILE_ATTRIBUTE_NORMAL,
							NULL);

			if (hTemp == INVALID_HANDLE_VALUE)
			{
				if (!bRetry)
				{
					return FALSE;
				}

				CString csPrompt = _T("Drive ") + *pcsDir + _T(" may not be ready.");
				int nReturn =
				pcwnd -> MessageBox
				( csPrompt,
				_T("Retry or Cancel"),
				MB_ICONQUESTION | MB_RETRYCANCEL  |
				MB_APPLMODAL);
				if (nReturn == IDRETRY)
				{
					return IsDriveValid(pcwnd, pcsDir, bRetry);
				}
				else
				{
					return FALSE;
				}
			}

			FlushFileBuffers(hTemp);
			CloseHandle(hTemp);

			BOOL bDelete = DeleteFile(csFile);
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL TryToCreateDirectory (CString &csOutputDir, int nIndex)
{
	CString csDir;
	CString Next;

	CString csSearch = csOutputDir.Mid(nIndex);
	int n = csSearch.Find('\\');
	if (n == -1)
	{
		n = csOutputDir.GetLength();
	}

	csDir = csOutputDir.Left(n + nIndex);
	BOOL bReturn = CreateDirectory((LPCTSTR) csDir, NULL);
	if (n == csOutputDir.GetLength())
	{
		return bReturn;
	}
	else
	{
		return TryToCreateDirectory (csOutputDir, n + nIndex + 1);
	}


}

BOOL IsValidFilename(CString &csFilename, CWnd *pParent , BOOL &bNoTemp)
{

	TCHAR szTempPath[_MAX_PATH];
	DWORD dwReturn = GetTempPath(_MAX_PATH,szTempPath);
	DWORD dwError = GetLastError();
	CString csTempDir;
	if (dwReturn > 0)
	{
		csTempDir = szTempPath;
	}
	else
	{
		bNoTemp = TRUE;
		return FALSE;
	}

	if (!csTempDir.IsEmpty())
	{
		if (csTempDir[csTempDir.GetLength() - 1] == '\\')
		{
			csTempDir = csTempDir.Left(csTempDir.GetLength() - 1);
		}
		BOOL bTemp = TryToFindDirectory(&csTempDir);


		if (!bTemp)
		{
			CString csUserMsg;
			csUserMsg =  _T("The temporary directory \"") + csTempDir;
			csUserMsg +=  _T("\" does not exist.  Do you wish to create it?");
			int nReturn =
				pParent->MessageBox
				(
				csUserMsg,
				_T("Create Directory?"),
				MB_YESNO  | MB_ICONQUESTION | MB_DEFBUTTON1 |
				MB_APPLMODAL);
			if (nReturn == IDNO)
			{
				bNoTemp = TRUE;
				return FALSE;
			}

			BOOL bCreated = TryToCreateDirectory (csTempDir, 0);

			if (!bCreated)
			{
				CString csUserMsg;
				csUserMsg =  _T("Could not create directory \"") + csTempDir;
				csUserMsg += _T("\".  ");
				csUserMsg += _T("Please try to create a temporary directory by that name outside of the Provider Wizard.");

				ErrorMsg
					(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
					__LINE__ );
				bNoTemp = TRUE;
				return FALSE;

			}
		}
	}

	CString csFile = csTempDir + _T("\\");

	csFile += csFilename;
	SECURITY_ATTRIBUTES saTemp;
	saTemp.nLength = sizeof(SECURITY_ATTRIBUTES);
	saTemp.lpSecurityDescriptor = NULL;
	saTemp.bInheritHandle = TRUE;

	HANDLE hTemp = CreateFile
					((LPCTSTR) csFile,
					GENERIC_WRITE,
					FILE_SHARE_WRITE,
					&saTemp,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	BOOL bIsValid = TRUE;

	if (hTemp == INVALID_HANDLE_VALUE)
	{
		bIsValid = FALSE;
		return bIsValid;
	}

	FlushFileBuffers(hTemp);
	CloseHandle(hTemp);

	BOOL bDelete = DeleteFile(csFile);

	return bIsValid;
}

int TryToCreateDirectory
(CWnd *pcwnd, CString &csOutputDir)
{
	CString csPrompt;
	csPrompt = _T("Directory \"") + csOutputDir + _T("\" does not exist.  ");
	csPrompt += _T("Do you wish to create it?");
	int nReturn =
		pcwnd -> MessageBox
		( csPrompt,
		_T("Create Directory?"),
		MB_YESNO  | MB_ICONQUESTION | MB_DEFBUTTON1 |
		MB_APPLMODAL);
	if (nReturn == IDYES)
	{
		BOOL bReturn = CreateDirectory((LPCTSTR) csOutputDir, NULL);
		if (!bReturn)
		{
			BOOL bReturn = TryToCreateDirectory (csOutputDir,0);
			if (bReturn)
			{
				return IDYES;
			}
			else
			{
				if (!bReturn)
				{
					CString csUserMsg;
					if (csOutputDir.GetLength() > 2 && csOutputDir[0] == '\\' && csOutputDir[1] == '\\')
					{
						// Cannot create shares
						csUserMsg =  _T("Can not create the share \"") + csOutputDir + _T("\".  ") ;
						csUserMsg += _T("Please enter an existing share or \"Cancel\" out of the MOF Wizard.");
						ErrorMsg
							(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
							__LINE__ - 6);

					}
					else {
						csUserMsg =  _T("Could not create directory \"") + csOutputDir + _T("\".");
						ErrorMsg
							(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
							__LINE__ );
					}

				}
				return IDNO;
			}
		}
		else
		{
			return IDYES;
		}
	}
	else
	{
		return IDNO;
	}
}

void InitializeLogFont
(LOGFONT &rlfFont, CString csName, int nHeight, int nWeight)
{
	_tcscpy(rlfFont.lfFaceName, (LPCTSTR) csName);
	rlfFont.lfWeight = nWeight;
	rlfFont.lfHeight = nHeight;
	rlfFont.lfEscapement = 0;
	rlfFont.lfOrientation = 0;
	rlfFont.lfWidth = 0;
	rlfFont.lfItalic = FALSE;
	rlfFont.lfUnderline = FALSE;
	rlfFont.lfStrikeOut = FALSE;
	rlfFont.lfCharSet = ANSI_CHARSET;
	rlfFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
	rlfFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	rlfFont.lfQuality = DEFAULT_QUALITY;
	rlfFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
}


CRect OutputTextString
(CPaintDC *pdc, CWnd *pcwnd, CString *pcsTextString, int x, int y,
 CString *pcsFontName = NULL, int nFontHeight = 0, int nFontWeigth = 0)
{
	CRect crReturn;
	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont cfFont;
	CFont* pOldFont = NULL;
	TEXTMETRIC tmFont;

	if (pcsFontName)
	{
		LOGFONT lfFont;
		InitializeLogFont
			(lfFont, *pcsFontName, nFontHeight * 10, nFontWeigth);

		cfFont.CreatePointFontIndirect(&lfFont, pdc);

		pOldFont = pdc -> SelectObject( &cfFont );
	}

	pdc->GetTextMetrics(&tmFont);

	pdc->SetBkMode( TRANSPARENT );

	pdc->TextOut( x, y, *pcsTextString, pcsTextString->GetLength());

	CSize csText = pdc->GetTextExtent( *pcsTextString);

	crReturn.TopLeft().x = x;
	crReturn.TopLeft().y = y;
	crReturn.BottomRight().x = x + csText.cx;
	crReturn.BottomRight().y = y + csText.cy;

	pdc->SetBkMode( OPAQUE );

	if (pcsFontName)
	{
		pdc -> SelectObject(pOldFont);
	}

	 return crReturn;
}

void OutputTextString
(CPaintDC *pdc, CWnd *pcwnd, CString *pcsTextString, int x, int y,
 CRect &crExt, CString *pcsFontName = NULL, int nFontHeight = 0,
 int nFontWeigth = 0)
{

	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont cfFont;
	CFont* pOldFont = NULL;

	if (pcsFontName)
	{
		LOGFONT lfFont;
		InitializeLogFont
			(lfFont, *pcsFontName, nFontHeight * 10, nFontWeigth);

		cfFont.CreatePointFontIndirect(&lfFont, pdc);

		pOldFont = pdc -> SelectObject( &cfFont );
	}

	pdc->SetBkMode( TRANSPARENT );

	CRect crBounds(x,y,x + crExt.Width(), y + crExt.Height());
	pdc->DrawText(*pcsTextString, crBounds,DT_WORDBREAK);

	pdc->SetBkMode( OPAQUE );

	if (pcsFontName)
	{
		pdc -> SelectObject(pOldFont);
	}

	 return;
}



/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage1 property page

CMyPropertyPage1::CMyPropertyPage1() : CPropertyPage(CMyPropertyPage1::IDD)
{
	//{{AFX_DATA_INIT(CMyPropertyPage1)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pParent = NULL;
	m_pcilImageList = NULL;
	m_bInitDraw = TRUE;

}

CMyPropertyPage1::~CMyPropertyPage1()
{
	delete m_pcilImageList;
}

void CMyPropertyPage1::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyPropertyPage1)
	DDX_Control(pDX, IDC_STATICBIG, m_staticMainExt);
	DDX_Control(pDX, IDC_STATICMAIN, m_staticTextExt);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyPropertyPage1, CPropertyPage)
	//{{AFX_MSG_MAP(CMyPropertyPage1)
	ON_WM_CREATE()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage2 property page

CMyPropertyPage2::CMyPropertyPage2() : CPropertyPage(CMyPropertyPage2::IDD)
{
	//{{AFX_DATA_INIT(CMyPropertyPage2)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pParent = NULL;

}

CMyPropertyPage2::~CMyPropertyPage2()
{
}

void CMyPropertyPage2::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyPropertyPage2)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyPropertyPage2, CPropertyPage)
	//{{AFX_MSG_MAP(CMyPropertyPage2)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage3 property page

CMyPropertyPage3::CMyPropertyPage3() : CPropertyPage(CMyPropertyPage3::IDD)
{
	//{{AFX_DATA_INIT(CMyPropertyPage3)
	//}}AFX_DATA_INIT
	m_pParent = NULL;
	m_pcilImageList = NULL;
	m_pcilStateImageList = NULL;
	m_nCurSel = -1;
	m_bFirstActivate = TRUE;
	m_nLastSel = -99;
}

CMyPropertyPage3::~CMyPropertyPage3()
{

}

void CMyPropertyPage3::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyPropertyPage3)
	DDX_Control(pDX, IDC_BUTTON2, m_cbUnselectAll);
	DDX_Control(pDX, IDC_BUTTON1, m_cbSelectAll);
	DDX_Control(pDX, IDC_STATICTEXTEXT2, m_staticTextExt);
	DDX_Control(pDX, IDC_CHECKCLASSSDEF, m_cbCheckClass);
	DDX_Control(pDX, IDC_LISTCLASSES, m_clcInstances);
	DDX_Control(pDX, IDC_LIST1, m_clClasses);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyPropertyPage3, CPropertyPage)
	//{{AFX_MSG_MAP(CMyPropertyPage3)
	ON_WM_CREATE()
	ON_WM_PAINT()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_CHECKCLASSSDEF, OnCheckclasssdef)
	ON_NOTIFY(NM_CLICK, IDC_LISTCLASSES, OnClickListclasses)
	ON_LBN_SELCHANGE(IDC_LIST1, OnSelchangeList1)
	ON_BN_CLICKED(IDC_BUTTON1, OnButtonSelectAll)
	ON_BN_CLICKED(IDC_BUTTON2, OnButtonUnselectAll)
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage4 property page

CMyPropertyPage4::CMyPropertyPage4() : CPropertyPage(CMyPropertyPage4::IDD)
{
	//{{AFX_DATA_INIT(CMyPropertyPage4)
	//}}AFX_DATA_INIT
	m_pParent = NULL;
	m_bFirstActivate = TRUE;
}

CMyPropertyPage4::~CMyPropertyPage4()
{
}

void CMyPropertyPage4::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyPropertyPage4)
	DDX_Control(pDX, IDC_CHECKUNICODE, m_cbUnicode);
	DDX_Control(pDX, IDC_STATICTEXTEXT3, m_staticTextExt);
	DDX_Control(pDX, IDC_PROVIDERNAME, m_ceMofName);
	DDX_Control(pDX, IDC_EDITMOFDIR, m_ceMofDir);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyPropertyPage4, CPropertyPage)
	//{{AFX_MSG_MAP(CMyPropertyPage4)
	ON_WM_CREATE()
	ON_WM_PAINT()
	ON_BN_CLICKED(IDC_BUTTONMOFDIR, OnButtonMofdir)
	ON_EN_CHANGE(IDC_EDITMOFDIR, OnChangeEditMofdir)
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()



int CMyPropertyPage4::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_pParent = reinterpret_cast<CMofGenSheet *>
					(GetLocalParent());

	return 0;
}

BOOL CMyPropertyPage4::OnSetActive()
{
	// TODO: Add your specialized code here and/or call the base class
	m_pParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
	CWnd *pBack = GetParent()->GetDlgItem(ID_WIZBACK);
	if (pBack)
	{
		pBack->ShowWindow(SW_SHOW);
	}

	if (m_bFirstActivate == FALSE)
	{
		return CPropertyPage::OnSetActive();
	}
	m_bFirstActivate = FALSE;

	CString csMofDir =  m_pParent->GetLocalParent()->
									GetMofDir();

	TCHAR buffer[_MAX_PATH];

	CString csWorkingDirectory = m_pParent->GetLocalParent()->GetSDKDirectory();

	if (csWorkingDirectory.GetLength() > 0)
	{
		if (csMofDir.IsEmpty())
		{
			m_ceMofDir.SetWindowText(csWorkingDirectory);
		}
		else
		{
			m_ceMofDir.SetWindowText((LPCTSTR)csMofDir);
		}
	}
   /* Get the current working directory: */
	else if(_tgetcwd ( buffer, _MAX_PATH ) != NULL )
	{
		if (csMofDir.IsEmpty())
		{
			m_ceMofDir.SetWindowText(buffer);
		}
		else
		{
			m_ceMofDir.SetWindowText((LPCTSTR)csMofDir);
		}

	}

	m_ceMofName.SetWindowText(_T("NewMOF"));

	return CPropertyPage::OnSetActive();
}


CString CMyPropertyPage4::GetFolder()
{
	CString csDir;

	IMalloc *pimMalloc;

	HRESULT hr = CoGetMalloc(MEMCTX_TASK,&pimMalloc);

	BROWSEINFO bi;
    LPTSTR lpBuffer;
    //LPITEMIDLIST pidlPrograms;  // PIDL for Programs folder
    LPITEMIDLIST pidlBrowse;    // PIDL selected by user

    // Allocate a buffer to receive browse information.
    if ((lpBuffer = (LPTSTR) pimMalloc->Alloc(MAX_PATH)) == NULL)
	{
		pimMalloc->Release();
        return csDir;
	}



    // Fill in the BROWSEINFO structure.
    bi.hwndOwner = this->GetSafeHwnd();
    bi.pidlRoot = NULL; // pidlPrograms;
    bi.pszDisplayName = lpBuffer;
    bi.lpszTitle = _T("Select a Directory");
    bi.ulFlags = BIF_RETURNONLYFSDIRS;
    bi.lpfn = NULL;
    bi.lParam = 0;

    // Browse for a folder and return its PIDL.
    pidlBrowse = SHBrowseForFolder(&bi);
    if (pidlBrowse != NULL) {

		if (SHGetPathFromIDList(pidlBrowse,lpBuffer))
		{
			csDir = lpBuffer;
		}
        // Free the PIDL returned by SHBrowseForFolder.
        pimMalloc->Free(pidlBrowse);
    }

    // Clean up.
    pimMalloc->Free(lpBuffer);
	pimMalloc->Release();
	return csDir;

}


BOOL CMyPropertyPage1::OnSetActive()
{
	// TODO: Add your specialized code here and/or call the base class
	m_pParent->SetWizardButtons(PSWIZB_NEXT);
	CWnd *pBack = GetParent()->GetDlgItem(ID_WIZBACK);
	if (pBack)
	{
		pBack->ShowWindow(SW_HIDE);
	}
	return CPropertyPage::OnSetActive();
}

int CMyPropertyPage1::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_pParent = reinterpret_cast<CMofGenSheet *>
					(GetLocalParent());

	// TODO: Add your specialized creation code here

	return 0;
}

BOOL CMyPropertyPage2::OnSetActive()
{
	// TODO: Add your specialized code here and/or call the base class
	m_pParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	return CPropertyPage::OnSetActive();
}

int CMyPropertyPage2::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_pParent = reinterpret_cast<CMofGenSheet *>
					(GetLocalParent());

	// TODO: Add your specialized creation code here

	return 0;
}

BOOL CMyPropertyPage3::OnSetActive()
{
	// TODO: Add your specialized code here and/or call the base class
	m_pParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	CWnd *pBack = GetParent()->GetDlgItem(ID_WIZBACK);
	if (pBack)
	{
		pBack->ShowWindow(SW_SHOW);
	}

	if (m_bFirstActivate == FALSE)
	{
		return CPropertyPage::OnSetActive();
	}

	m_bFirstActivate = FALSE;

	CStringArray &rcsaClasses =
		m_pParent->GetLocalParent()->GetClasses();
	int i;
	m_clClasses.ResetContent();

	for (i = 0; i < rcsaClasses.GetSize();i++)
	{
		CString csTest = rcsaClasses.GetAt(i);
		if (m_clClasses.FindStringExact( -1, (LPCTSTR)csTest)
				==  LB_ERR)
		{
			m_clClasses.AddString
				((LPCTSTR)rcsaClasses.GetAt(i));
		}
	}

	m_clClasses.SetCurSel(0);

	OnSelchangeList1();

	m_clcInstances.Initialize();

	SetButtonState();

	return CPropertyPage::OnSetActive();
}

void  CMyPropertyPage3::SetButtonState()
{
	if (m_clcInstances.GetItemCount() == 0)
	{
		m_cbSelectAll.EnableWindow(FALSE);
		m_cbUnselectAll.EnableWindow(FALSE);
	}
	else
	{
		int n = m_clcInstances.GetNumSelected();

		if (n != m_clcInstances.GetItemCount())
		{
			m_cbSelectAll.EnableWindow(TRUE);
		}
		else
		{
			m_cbSelectAll.EnableWindow(FALSE);
		}

		if (n > 0)
		{
			m_cbUnselectAll.EnableWindow(TRUE);
		}
		else
		{
			m_cbUnselectAll.EnableWindow(FALSE);
		}
	}

}

int CMyPropertyPage3::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_pParent = reinterpret_cast<CMofGenSheet *>
					(GetLocalParent());

	return 0;
}


void CMyPropertyPage1::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_BITMAPMAIN,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );

	CRect rcTextExt;
	m_staticTextExt.GetWindowRect(&rcTextExt);
	ScreenToClient(rcTextExt);

	CRect rcPageExt;
	m_staticMainExt.GetWindowRect(&rcPageExt);
	ScreenToClient(rcPageExt);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{
			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,FALSE);

			dc.RealizePalette();

			//CRect rcBitmap(0, 0, m_nBitmapW, m_nBitmapH);
			dc.FillRect(&rcPageExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcPageExt, rcPageExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame = rcPageExt;

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));

	CString csFont = _T("MS Shell Dlg");

	CString csOut = _T("Welcome to the");

	CRect crOut = OutputTextString
		(&dc, this, &csOut, 45, 54, &csFont, 8, FW_BOLD);

	csOut = _T("MOF Generator Wizard");

	csFont = _T("MS Shell Dlg");

	crOut =  OutputTextString
		(&dc, this, &csOut, crOut.TopLeft().x + 15, crOut.BottomRight().y + 8,
		&csFont, 16, FW_BOLD);

	csOut = _T("This wizard helps you generate a .MOF file for class definitions and/or instances.");

	csFont = _T("MS Shell Dlg");

	OutputTextString
		(&dc, this, &csOut, crOut.TopLeft().x, crOut.BottomRight().y + 15, rcTextExt,
		&csFont, 8, FW_NORMAL);


	// Do not call CPropertyPage::OnPaint() for painting messages
}

void CMyPropertyPage3::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_BITMAPPAGE,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );

	CRect rcTextExt;
	m_staticTextExt.GetWindowRect(&rcTextExt);
	ScreenToClient(rcTextExt);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{
			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,FALSE);

			dc.RealizePalette();

			//CRect rcBitmap(0, 0, m_nBitmapW, m_nBitmapH);
			dc.FillRect(&rcTextExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcTextExt, rcTextExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame = rcTextExt;

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));

	CString csFont = _T("MS Shell Dlg");

	CString csOut = _T("Select classes");

	CRect crOut = OutputTextString
		(&dc, this, &csOut, 8, 10, &csFont, 8, FW_BOLD);

	csOut = _T("Select the classes whose definitions or instances you want to include in the .MOF file.");


	OutputTextString
		(&dc, this, &csOut, crOut.TopLeft().x + 15, crOut.BottomRight().y + 1, rcTextExt,
		&csFont, 8, FW_NORMAL);



	// Do not call CPropertyPage::OnPaint() for painting messages
}



int CMyPropertyPage3::GetSelectedClass()
{
	int nIndex = m_nCurSel;
	if (nIndex == -1)
	{
		return 0;
	}
	return nIndex;

}



void CMyPropertyPage4::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_BITMAPPAGE,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );

	CRect rcTextExt;
	m_staticTextExt.GetWindowRect(&rcTextExt);
	ScreenToClient(rcTextExt);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{
			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,FALSE);

			dc.RealizePalette();

			//CRect rcBitmap(0, 0, m_nBitmapW, m_nBitmapH);
			dc.FillRect(&rcTextExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcTextExt, rcTextExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame = rcTextExt;

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));

	CString csFont = _T("MS Shell Dlg");

	CString csOut = _T("Save .MOF file");

	CRect crOut = OutputTextString
		(&dc, this, &csOut, 8, 10, &csFont, 8, FW_BOLD);

	csOut = _T("Specify a name for the .MOF file, then specify the directory where you want to save the .MOF file.");
	csOut += _T("  You may optionally generate a UNICODE .MOF file.");

	OutputTextString
		(&dc, this, &csOut, crOut.TopLeft().x + 15, crOut.BottomRight().y + 1, rcTextExt,
		&csFont, 8, FW_NORMAL);




	// Do not call CPropertyPage::OnPaint() for painting messages
}

void CMyPropertyPage4::OnButtonMofdir()
{
	CString csFolder = GetFolder();
	if (!csFolder.IsEmpty())
	{
		 m_ceMofDir.SetWindowText((LPCTSTR) csFolder);

	}
}


void CMyPropertyPage4::OnChangeEditMofdir()
{
	CString csText;
	m_ceMofDir.GetWindowText(csText);
	m_pParent->GetLocalParent()->GetMofDir() = csText;
}


BOOL CMyPropertyPage3::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	m_clcInstances.SetLocalParent(this);

	CStringArray *&rpcsaInstances =
		m_pParent->GetLocalParent()-> GetInstances();

	rpcsaInstances = new
		CStringArray
		[(int) m_pParent->GetLocalParent()->GetClasses().GetSize()];


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CMyPropertyPage3::OnDestroy()
{
	CPropertyPage::OnDestroy();

	delete m_pcilImageList;
	delete m_pcilStateImageList;

}

bool CMyPropertyPage4::LeavingPage()
{

	// check the directory.
	CString csMofDir;
	m_ceMofDir.GetWindowText(csMofDir);
	CString &rcsMofDir =
		m_pParent -> GetLocalParent() ->
			GetMofDir();
	rcsMofDir = csMofDir;


	//check the filename.
	CString csMofFile;
	m_ceMofName.GetWindowText(csMofFile);

	// filename only-- no paths.
	TCHAR tempPath[_MAX_PATH];
	memset(tempPath, 0, _MAX_PATH);

	_tsplitpath (csMofFile, NULL, tempPath, NULL, NULL);
	if(_tcslen(tempPath) > 0)
	{
		CString csUserMsg;
		csUserMsg =  _T("Paths are not allowed. This field can contain filenames only.");

		ErrorMsg(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);

		// got back to the bad control
		m_ceMofName.SetFocus();
		return false;
	}

	CString &rcsMofFile =
		m_pParent -> GetLocalParent() ->
			GetMofFile();

	rcsMofFile = csMofFile;

	// check for unicode.
	m_pParent -> GetLocalParent() -> m_bUnicode = m_cbUnicode.GetCheck();

	return true;

}


LRESULT CMyPropertyPage4::OnWizardBack()
{
	if(LeavingPage())
	{
		return CPropertyPage::OnWizardBack();
	}
	else
	{
		return -1;
	}
}

LRESULT CMyPropertyPage4::OnWizardNext()
{
	if(LeavingPage())
	{
		return CPropertyPage::OnWizardNext();
	}
	else
	{
		return -1;
	}
}

BOOL CMyPropertyPage4::OnWizardFinish()
{
	if(!LeavingPage())
	{
		return 0;
	}

	if (!CheckForSomethingSelected())
	{
		CString csUserMsg;
		csUserMsg =  _T("There are no classes or instances selected.  If you wish to cancel select \"Cancel\" or go back to the previous screen and select classes and/or instances");
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 13);
		return 0;
	}

	if (m_pParent->m_pParent->m_csMofFile.GetLength() == 0)
	{
		CString csUserMsg = _T("Please enter an output MOF filename or \"Cancel\" out of the MOF Wizard.");
		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);
		m_ceMofName.SetFocus();
		return 0;
	}

	BOOL bNoTemp;
	if (!IsValidFilename(m_pParent->m_pParent->m_csMofFile, this, bNoTemp))
	{
		CString csUserMsg;

		if (!bNoTemp)
		{
			csUserMsg =  _T("Invalid MOF filename: \"") + m_pParent->m_pParent->m_csMofFile;
			csUserMsg += _T("\".");
		}
		else
		{
			csUserMsg =  _T("Temporary directory does not exist.");
		}

		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);
		m_ceMofName.SetFocus();
		return 0;
	}

	CString csOutputDir;

	m_ceMofDir.GetWindowText(csOutputDir);

	csOutputDir.TrimLeft();
	csOutputDir.TrimRight();

	int i;
	int nRemove = 0;
	for (i = csOutputDir.GetLength() - 1; i >= 0; i--)
	{
		if (csOutputDir[i] == '\\')
		{
			nRemove++;
		}
		else
		{
			break;
		}

	}

	if (nRemove > 0)
	{
		csOutputDir = csOutputDir.Left((csOutputDir.GetLength()) - nRemove);
	}


	m_ceMofDir.SetWindowText(csOutputDir);

	int nLen = csOutputDir.GetLength();
	if (nLen == 0)
	{
		CString csUserMsg = _T("Please enter an output directory name or \"Cancel\" out of the MOF Wizard.");
		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);
		m_ceMofDir.SetFocus();
		return 0;
	}

	int nInputLen = m_pParent->m_pParent->m_csMofFile.GetLength();
	int nExtBegin = m_pParent->m_pParent->m_csMofFile.Find('.');
	int nExtLength = nExtBegin == -1 ? 0: (nInputLen - nExtBegin) - 1;
	int nFileLength = nExtBegin == -1? nInputLen : nInputLen - nExtLength;

	if (nFileLength > _MAX_FNAME - 1)
	{
		CString csUserMsg = _T("MOF file name is longer that the maximum allowed.");
		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);
		m_ceMofName.SetFocus();
		return 0;
	}

	if ((!(nExtLength == -1)) && nExtLength > _MAX_EXT - 1)
	{
		CString csUserMsg = _T("MOF file extension is longer that the maximum allowed.");
		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);
		m_ceMofName.SetFocus();
		return 0;
	}

	if (csOutputDir.GetLength() > _MAX_DIR - 1)
	{
		CString csUserMsg = _T("Output directory name is longer that the maximum allowed.");
		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);
		m_ceMofDir.SetFocus();
		return 0;
	}

	if (!IsDriveValid(reinterpret_cast<CWnd *>(this),&csOutputDir,FALSE))
	{
		CString csUserMsg;
		csUserMsg =  _T("Drive \"")  + csOutputDir + _T("\" is not ready, invalid or full.");
		csUserMsg += _T("  Please enter another drive name, make the drive ready, or \"Cancel\" out of the Wizard.");
		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);
		return 0;
	}

	if (!TryToFindDirectory (&csOutputDir))
	{

		int nReturn = TryToCreateDirectory
			(reinterpret_cast<CWnd *>(this),csOutputDir);
		if (nReturn == IDNO)
		{
			return 0;
		}
		else if (nReturn != IDYES)
		{
			CString csUserMsg;
			csUserMsg =  _T("Could not create a directory named \"") + csOutputDir;
			csUserMsg += _T("\".  ");
			csUserMsg += _T("Please enter another directory name or \"Cancel\" out of the MOF Wizard.");
			ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 6);
			return 0;
		}
	}


	CString csFile;


	if (nExtBegin == -1)
	{
		m_pParent->m_pParent->m_csMofFile += _T(".mof");
	}

	int nDirLen = m_pParent->m_pParent->m_csMofDir.GetLength();

	if (m_pParent->m_pParent->m_csMofDir[nDirLen - 1] == '\\')
	{
		csFile = m_pParent->m_pParent->m_csMofDir + m_pParent->m_pParent->m_csMofFile;
	}
	else
	{
		csFile = m_pParent->m_pParent->m_csMofDir + "\\" + m_pParent->m_pParent->m_csMofFile;
	}


	if (csFile.GetLength() > _MAX_PATH - 1)
	{
		CString csUserMsg = _T("Output path (directory plus MOF file name) is longer that the maximum allowed.");
		ErrorMsg
			(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
			__LINE__ - 6);
		m_ceMofName.SetFocus();
		return 0;
	}

	if( (_taccess((LPCTSTR) csFile, 0 )) != -1 )
	{

		if( (_taccess((LPCTSTR) csFile, 2 )) == -1 )
		{
			CString csUserMsg;
			csUserMsg = csFile +  _T(" is Read-only.  You must specify another file or clear the Read-only attribute.");
			ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ -7);
			return 0;
		}

		CString csMessage = _T("File ") + csFile + _T(" already exists.");
		csMessage += _T("  Do you want to replace it?");
		int nReturn =
			::MessageBox
			( m_pParent -> GetSafeHwnd(),
			csMessage,
			_T("File Replace Query"),
			MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON1 |
			MB_APPLMODAL);

		if (nReturn != IDYES)
		{
			return 0;
		}
	}



	return CPropertyPage::OnWizardFinish();
}


BOOL CMyPropertyPage4::CheckForSomethingSelected()
{

	CStringArray &rpcsaClasses =
		m_pParent->GetLocalParent()-> GetClasses();

	int nClasses = (int) rpcsaClasses.GetSize();

	for (int i = 0; i < nClasses; i++)
	{
		CStringArray *&rpcsaInstances =
			m_pParent->GetLocalParent()-> GetInstances();
		if (m_pParent->GetLocalParent()-> m_cbaIndicators.GetAt(i))
		{
			return TRUE;
		}
		int nInstances = (int) rpcsaInstances[i].GetSize();
		if (nInstances > 0)
		{
			return TRUE;
		}
	}

	return FALSE;
}

void CMyPropertyPage3::OnCheckclasssdef()
{
	BYTE bNew = 0;
	if (m_cbCheckClass.GetCheck())
	{
		bNew = 1;
	}

	CByteArray &rcbaIndicators =
		m_pParent -> GetLocalParent() ->
			GetClassIndicators();

	rcbaIndicators.SetAt(GetSelectedClass(),bNew);

}

void CMyPropertyPage3::OnClickListclasses(NMHDR* pNMHDR, LRESULT* pResult)
{
	// TODO: Add your control notification handler code here

	*pResult = 0;
}

void CMyPropertyPage3::OnSelchangeList1()
{
	int nIndex = m_clClasses.GetCurSel();

	if (nIndex == -1 && m_nCurSel == -1)
	{
		nIndex = 0;
		m_nCurSel = 0;
		m_clClasses.SetSel( 0,  TRUE );
	}
	else if (nIndex == -1)
	{
		nIndex = m_nCurSel;
		m_clClasses.SetSel( nIndex,  TRUE );
	}
	else
	{
		m_nCurSel = nIndex;
	}

	if (m_nLastSel == m_nCurSel)
	{
		return;
	}
	else
	{
		m_nLastSel = m_nCurSel;
	}

	CStringArray &rcsaClasses =
		m_pParent->GetLocalParent()->GetClasses();


	CByteArray &rcbaIndicators =
		m_pParent -> GetLocalParent() ->
			GetClassIndicators();

	m_cbCheckClass.SetCheck(rcbaIndicators.GetAt(m_nCurSel));

	m_clcInstances.SetListInstances
		(&rcsaClasses.GetAt(m_nCurSel), m_nCurSel);

	SetButtonState();

}

LRESULT CMyPropertyPage3::OnWizardNext()
{
	// TODO: Add your specialized code here and/or call the base class
	if (!m_pParent->m_Page4.CheckForSomethingSelected())
	{
		CString csUserMsg;
		csUserMsg =  _T("You will not be able to \"Finish\" the MOF generation because there are no classes or instances selected.");
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 13);
		return 0;
	}
	return CPropertyPage::OnWizardNext();
}

LRESULT CMyPropertyPage3::OnWizardBack()
{
	// TODO: Add your specialized code here and/or call the base class
	if (!m_pParent->m_Page4.CheckForSomethingSelected())
	{
		CString csUserMsg;
		csUserMsg =  _T("You will not be able to \"Finish\" the MOF generation because there are no classes or instances selected.");
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 13);
		return 0;
	}
	return CPropertyPage::OnWizardBack();
}

void CMyPropertyPage1::OnHelp()
{
	m_pParent->GetLocalParent()->InvokeHelp();

}

void CMyPropertyPage3::OnHelp()
{
	m_pParent->GetLocalParent()->InvokeHelp();
}

void CMyPropertyPage4::OnHelp()
{
	m_pParent->GetLocalParent()->InvokeHelp();
}

void CMyPropertyPage3::OnButtonSelectAll()
{
	// TODO: Add your control notification handler code here
	m_clcInstances.SelectAll();
	m_cbSelectAll.EnableWindow(FALSE);
	m_cbUnselectAll.EnableWindow(TRUE);
}

void CMyPropertyPage3::OnButtonUnselectAll()
{
	// TODO: Add your control notification handler code here
	m_clcInstances.UnselectAll();
	m_cbSelectAll.EnableWindow(TRUE);
	m_cbUnselectAll.EnableWindow(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\mypropertypage1.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MyPropertyPage1.h : header file
//

#ifndef __MYPROPERTYPAGE1_H__
#define __MYPROPERTYPAGE1_H__

class CMofGenSheet;
class CImageList;

int GetCBitmapWidth(const CBitmap & cbm);
int GetCBitmapHeight(const CBitmap & cbm);
HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPCTSTR lpString,
                           HPALETTE FAR* lphPalette);
HPALETTE CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors);
BOOL StringInArray
(CStringArray *&rpcsaArrays, CString *pcsString, int nIndex);
/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage1 dialog

class CMyPropertyPage1 : public CPropertyPage
{
	DECLARE_DYNCREATE(CMyPropertyPage1)

// Construction
public:
	CMyPropertyPage1();
	~CMyPropertyPage1();
	void SetLocalParent(CMofGenSheet *pParent) {m_pParent = pParent;}
	CMofGenSheet *GetLocalParent() {return m_pParent;}

// Dialog Data
	//{{AFX_DATA(CMyPropertyPage1)
	enum { IDD = IDD_PROPPAGE1 };
	CStatic	m_staticMainExt;
	CStatic	m_staticTextExt;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertyPage1)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMyPropertyPage1)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	//}}AFX_MSG
	afx_msg void OnHelp();
	DECLARE_MESSAGE_MAP()
	CMofGenSheet *m_pParent;
	CImageList *m_pcilImageList;
	BOOL m_bInitDraw;
	int m_nBitmapH;
	int m_nBitmapW;
	


};


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage2 dialog

class CMyPropertyPage2 : public CPropertyPage
{
	DECLARE_DYNCREATE(CMyPropertyPage2)

// Construction
public:
	CMyPropertyPage2();
	~CMyPropertyPage2();
	void SetLocalParent(CMofGenSheet *pParent) {m_pParent = pParent;}
	CMofGenSheet *GetLocalParent() {return m_pParent;}

// Dialog Data
	//{{AFX_DATA(CMyPropertyPage2)
	enum { IDD = IDD_PROPPAGE2 };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertyPage2)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMyPropertyPage2)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	CMofGenSheet *m_pParent;


};


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage3 dialog

class CMyPropertyPage3 : public CPropertyPage
{
	DECLARE_DYNCREATE(CMyPropertyPage3)

// Construction
public:
	CMyPropertyPage3();
	~CMyPropertyPage3();
	void SetLocalParent(CMofGenSheet *pParent) {m_pParent = pParent;}
	CMofGenSheet *GetLocalParent() {return m_pParent;}
	int GetSelectedClass();
	void SetButtonState();
// Dialog Data
	//{{AFX_DATA(CMyPropertyPage3)
	enum { IDD = IDD_PROPPAGE3 };
	CButton	m_cbUnselectAll;
	CButton	m_cbSelectAll;
	CStatic	m_staticTextExt;
	CButton	m_cbCheckClass;
	CWrapListCtrl	m_clcInstances;
	CHorzListBox	m_clClasses;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertyPage3)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMyPropertyPage3)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnCheckclasssdef();
	afx_msg void OnClickListclasses(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelchangeList1();
	afx_msg void OnButtonSelectAll();
	afx_msg void OnButtonUnselectAll();
	//}}AFX_MSG
	afx_msg void OnHelp();
	DECLARE_MESSAGE_MAP()
	BOOL m_bFirstActivate;
	CMofGenSheet *m_pParent;
	int m_nBitmapH;
	int m_nBitmapW;
	int m_nCurSel;
	int m_nLastSel;

	CImageList *m_pcilImageList;
	CImageList *m_pcilStateImageList;
	CPoint m_cpButtonUp;


	
};


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage4 dialog

class CMyPropertyPage4 : public CPropertyPage
{
	DECLARE_DYNCREATE(CMyPropertyPage4)

// Construction
public:
	CMyPropertyPage4();
	~CMyPropertyPage4();
	void SetLocalParent(CMofGenSheet *pParent) {m_pParent = pParent;}
	CMofGenSheet *GetLocalParent() {return m_pParent;}
	BOOL CheckForSomethingSelected();
// Dialog Data
	//{{AFX_DATA(CMyPropertyPage4)
	enum { IDD = IDD_PROPPAGE4 };
	CButton	m_cbUnicode;
	CStatic	m_staticTextExt;
	CEdit	m_ceMofName;
	CEdit	m_ceMofDir;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertyPage4)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnWizardFinish();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMyPropertyPage4)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	afx_msg void OnButtonMofdir();
	afx_msg void OnChangeEditMofdir();
	//}}AFX_MSG
	afx_msg void OnHelp();
	DECLARE_MESSAGE_MAP()
	BOOL m_bFirstActivate;
	CString GetFolder();
	CMofGenSheet *m_pParent;
	int m_nBitmapH;
	int m_nBitmapW;
	bool LeavingPage();


};



#endif // __MYPROPERTYPAGE1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\mofwizctl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MOFWizCtl.h : Declaration of the CMOFWizCtrl OLE control class.

class CMofGenSheet;
class CMyPropertyPage1;
class CMyPropertyPage3;
class CMyPropertyPage4;
class CWrapListCtrl;

void ErrorMsg
		(CString *pcsUserMsg, SCODE sc, IWbemClassObject *pErrorObject, BOOL bLog, CString *pcsLogMsg, 
		char *szFile, int nLine, BOOL bNotification = FALSE, UINT uType = MB_ICONEXCLAMATION);
	
void LogMsg
		(CString *pcsLogMsg, char *szFile, int nLine);

/////////////////////////////////////////////////////////////////////////////
// CMOFWizCtrl : See MOFWizCtl.cpp for implementation.

class CMOFWizCtrl : public COleControl
{
	DECLARE_DYNCREATE(CMOFWizCtrl)

// Constructor
public:
	CMOFWizCtrl();
	CString &GetMofDir(){return m_csMofDir;}
	CString &GetMofFile(){return m_csMofFile;}
	CStringArray &GetClasses() {return m_csaClassNames;}
	CByteArray &GetClassIndicators() {return m_cbaIndicators;}
	CStringArray *&GetInstances() {return m_pcsaInstances;}
	IWbemServices *GetServices(){return m_pServices;}
	void FinishMOFTargets();
	CString GetSDKDirectory();
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMOFWizCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void OnSetClientSite( );
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CMOFWizCtrl();
	CString m_csNameSpace;
	DECLARE_OLECREATE_EX(CMOFWizCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CMOFWizCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CMOFWizCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CMOFWizCtrl)		// Type name and misc status

	CToolTipCtrl m_ttip;

	BOOL m_bInitDraw;
	HICON m_hMOFWiz;
	HICON m_hMOFWizSel;
	CImageList *m_pcilImageList;
	int m_nImage;
	
	IWbemServices *m_pServices;
	IWbemServices *InitServices
		(CString *pcsNameSpace);
	IWbemServices *GetIWbemServices(CString &rcsNamespace);

	SCODE m_sc;
	BOOL m_bUserCancel;

	SCODE MakeSafeArray(SAFEARRAY FAR ** pRet, VARTYPE vt, int iLen);
	SCODE PutStringInSafeArray
		(SAFEARRAY FAR * psa,CString *pcs, int iIndex);
	SCODE CMOFWizCtrl::GetStringFromSafeArray
		(SAFEARRAY FAR * psa,CString *pcs, int iIndex);

	CStringArray m_csaClassNames;
	CByteArray m_cbaIndicators;
	CStringArray *m_pcsaInstances;

	void MOFEntry
		(CString *pcsMofName, 
		IWbemClassObject *pObject, int nIndex, BOOL &bFirst, BOOL bWriteInstances);
	void WriteInstances(IWbemClassObject *pIWbemClassObject,
			   CString *pcsMofName, int nIndex, BOOL &bFirst);

	CString m_csMofDir;
	CString m_csMofFile;
	CString GetClassName(IWbemClassObject *pClass);
	CString GetSuperClassName(IWbemClassObject *pClass);
	CString GetBSTRProperty 
		(IWbemClassObject * pInst, CString *pcsProperty);
	void ReleaseErrorObject(IWbemClassObject *&rpErrorObject);
	void DoubleSlash(CString &csNamespace);
	CMofGenSheet *m_pcgsPropertySheet;
	BOOL OnWizard(CStringArray *pcsaClasses);
	BOOL m_bMOFIsEmpty;

	void RelayEvent(UINT message, WPARAM wParam, LPARAM lParam);

	void InvokeHelp();

	CString GetMachineName();
	CString GetPCMachineName();
	CString GetNamespaceMachineName();

	int WriteData(CString &csOutputString);
	BOOL OpenMofFile(CString &rcsPath);
	CString FixUpCrForUNICODE(CString &rcsMof);
	CString m_csEndl;
	BOOL m_bUnicode;
	FILE *m_pfOut;  

	void CommentOutDefinition(CString &rcsMof);

// Message maps
	//{{AFX_MSG(CMOFWizCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnMove(int x, int y);
	//}}AFX_MSG
	afx_msg long FireGenerateMOFMessage (UINT uParam, LONG lParam);
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CMOFWizCtrl)
	afx_msg VARIANT GetMOFTargets();
	afx_msg void SetMOFTargets(const VARIANT FAR& newValue);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CMOFWizCtrl)
	void FireGenerateMOFs()
		{FireEvent(eventidGenerateMOFs,EVENT_PARAM(VTS_NONE));}
	void FireGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
		{FireEvent(eventidGetIWbemServices,EVENT_PARAM(VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT), lpctstrNamespace, pvarUpdatePointer, pvarServices, pvarSC, pvarUserCancel);}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()
	friend class CMyPropertyPage1;
	friend class CMyPropertyPage3;
	friend class CMyPropertyPage4;
	friend class CWrapListCtrl;
// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CMOFWizCtrl)
	dispidMOFTargets = 1L,
	eventidGenerateMOFs = 1L,
	eventidGetIWbemServices = 2L,
	//}}AFX_DISP_ID
	};

private:
	void GenClassDef(LPCTSTR pszMofFile, const CMapStringToPtr& mapClassGen, CMapStringToPtr& mapClassDef, LPCTSTR pszClass, BOOL& bFirst);
	void WriteClassDef(const CString& sMofFile, IWbemClassObject *pco, BOOL& bFirst);
	void WriteMOFCommentHeader(const CString& sMofFile, IWbemClassObject *pco);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MOFWiz.rc
//
#define IDS_MOFWIZ                      1
#define IDD_ABOUTBOX_MOFWIZ             1
#define IDB_MOFWIZ                      1
#define IDI_ABOUTDLL                    1
#define IDS_MOFWIZ_PPG                  2
#define IDI_MOFWIZ                      2
#define IDI_MOFWIZSEL                   3
#define IDS_MOFWIZ_PPG_CAPTION          100
#define IDD_PROPPAGE_MOFWIZ             100
#define IDS_PROPSHT_CAPTION             102
#define IDD_PROPPAGE1                   103
#define IDS_NO_HTML_PAGE                103
#define IDD_PROPPAGE2                   104
#define IDD_PROPPAGE3                   105
#define IDD_PROPPAGE4                   106
#define IDB_BITMAP1                     201
#define IDI_CPPWIZ                      201
#define IDC_LIST1                       201
#define IDC_STATICMAIN                  201
#define IDB_BITMAP2                     202
#define IDI_CPPWIZSEL                   202
#define IDB_PP1                         202
#define IDC_EDIT1                       202
#define IDC_STATICTEXTEXT2              202
#define IDB_WIZPG4                      203
#define IDD_DIALOG1                     203
#define IDC_EDIT2                       203
#define IDC_STATICTEXTEXT3              203
#define IDB_WIZPG1                      204
#define IDC_EDIT3                       204
#define IDC_STATICBIG                   204
#define IDC_RADIO1                      205
#define IDB_PP3                         205
#define IDB_WIZPG3                      205
#define IDC_BUTTON1                     205
#define IDC_RADIO2                      206
#define IDB_PP4                         206
#define IDC_BUTTON2                     206
#define IDC_LIST2                       207
#define IDC_LISTPROPERTIES              207
#define IDB_BITMAPCHECKS                207
#define IDC_LISTCLASSES                 207
#define IDI_MOFWIZ16                    207
#define IDC_STATIC1                     208
#define IDI_MOFWIZSEL16                 208
#define IDB_BITMAP3                     208
#define IDC_STATIC2                     209
#define IDB_BITMAPMAIN                  209
#define IDC_STATIC3                     210
#define IDC_STATIC4                     211
#define IDB_BITMAPPAGE                  211
#define IDC_STATIC5                     212
#define IDC_BUTTONMOFDIR                213
#define IDC_BUTTONTLBDIR                214
#define IDC_EDITMOFDIR                  215
#define IDC_EDITTLBDIR                  216
#define IDC_PROVIDERNAME                217
#define IDC_EDITPROVIDERDESCRIPTION     218
#define IDC_CHECKOVERRIDE               219
#define IDC_CHECKCLASSSDEF              220
#define IDC_CHECKUNICODE                221

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        222
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         207
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\declspec.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//#define TRACKING 

// If we are building a the  DLL then define the 
// class as exported otherwise its imported.
// ============================================
#ifndef COREPOL_HEADERFILE_IS_INCLUDED
#define COREPOL_HEADERFILE_IS_INCLUDED
//#pragma message( "Including DECLSPEC.H..." )

#undef WBEMUTILS_POLARITY

#ifdef SHARE_SOURCE
#define WBEMUTILS_POLARITY
#elif BUILDING_DLL
//#pragma message( "Building static library or DLL..." )
#define WBEMUTILS_POLARITY __declspec( dllexport )
#else 
//#pragma message( "Building Client..." )
#define WBEMUTILS_POLARITY __declspec( dllimport )
#endif

#endif COREPOL_HEADERFILE_IS_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\wraplistctrl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WrapListCtrl.h : header file


class CMyPropertyPage3;
/////////////////////////////////////////////////////////////////////////////
// CWrapListCtrl window

class CWrapListCtrl : public CListCtrl
{
// Construction
public:
	CWrapListCtrl();
	void SetListInstances(CString *pcsClass, int nIndex);
	void SetLocalParent(CMyPropertyPage3 *pParent)
		{m_pParent = pParent;}
	void Initialize();
	void DeleteFromEnd(int nNumber);
	int GetNumSelected();
	void SelectAll();
	void UnselectAll();
// Attributes
public:

// Operations
public:
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWrapListCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWrapListCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CWrapListCtrl)
	afx_msg void OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	CStringArray *m_pcsaProps;
	CMyPropertyPage3 *m_pParent;
	void UpdateClassInstanceList
		(int nItem, CString *pcsPath, BOOL bInsert);
	CStringArray *GetColProps(IWbemClassObject * pClass);
	CStringArray *GetPropNames(IWbemClassObject * pClass);
	CString GetProperty
		(IWbemClassObject * pInst, CString *pcsProperty);
	CString GetPath(IWbemClassObject *pClass);
	int GetInstances
		(IWbemServices * pIWbemServices, CString *pcsClass, 
		CPtrArray &cpaInstances);
	void AddInstances(CPtrArray &cpaInstances);
	void AddInstance(IWbemClassObject *pimcoInstance , BOOL bChecked);
	CImageList *m_pcilImageList;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\mofwizppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MOFWizPpg.h : Declaration of the CMOFWizPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CMOFWizPropPage : See MOFWizPpg.cpp.cpp for implementation.

class CMOFWizPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CMOFWizPropPage)
	DECLARE_OLECREATE_EX(CMOFWizPropPage)

// Constructor
public:
	CMOFWizPropPage();

// Dialog Data
	//{{AFX_DATA(CMOFWizPropPage)
	enum { IDD = IDD_PROPPAGE_MOFWIZ };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CMOFWizPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\dlgsingleview.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "wbemidl.h"
#include "singleview.h"
#include "dlgsingleview.h"



IMPLEMENT_DYNCREATE(CDlgSingleView,CSingleView)

BEGIN_MESSAGE_MAP(CDlgSingleView,CSingleView)
	//{{AFX_MSG_MAP(CBanner)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

int CDlgSingleView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	//CSingleView::SelectObjectByPointer(m_pErrorObject);
	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\mofwiz\wraplistctrl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WrapListCtrl.cpp : implementation file
//

#include "precomp.h"
#include <OBJIDL.H>
#include "resource.h"
#include <fstream.h>
#include "wbemidl.h"
#include "MOFWiz.h"
#include <afxcmn.h>
#include <afxcmn.h>
#include "MOFWizCtl.h"
#include "WrapListCtrl.h"
#include "hlb.h"
#include "MyPropertyPage1.h"
#include "MofGenSheet.h"
#include "logindlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CWrapListCtrl

CWrapListCtrl::CWrapListCtrl()
{
	m_pcilImageList = NULL;
	m_pcsaProps = NULL;
}

CWrapListCtrl::~CWrapListCtrl()
{
	delete m_pcilImageList;
	delete m_pcsaProps;



}


BEGIN_MESSAGE_MAP(CWrapListCtrl, CListCtrl)
	//{{AFX_MSG_MAP(CWrapListCtrl)
	ON_NOTIFY_REFLECT(LVN_ITEMCHANGED, OnItemchanged)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWrapListCtrl message handlers

void CWrapListCtrl::OnItemchanged(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_LISTVIEW* plv = (NM_LISTVIEW*)pNMHDR;

	CString *psz = (CString *)plv->lParam;
	UpdateClassInstanceList(plv->iItem, psz, GetCheck(plv->iItem));

	m_pParent->SetButtonState();
}

void CWrapListCtrl::UpdateClassInstanceList
(int nItem, CString *pcsPath, BOOL bInsert)
{
	CStringArray *&rpcsaInstances = m_pParent->GetLocalParent()->GetLocalParent()->GetInstances();

	int nClassIndex = m_pParent-> GetSelectedClass();

	BOOL bExists = StringInArray(rpcsaInstances, pcsPath, nClassIndex);

	if(bInsert && !bExists)
		rpcsaInstances[nClassIndex].Add(*pcsPath);

	if(!bInsert && bExists)
	{
		for (int i = 0; i < rpcsaInstances[nClassIndex].GetSize(); i++)
		{
			if (pcsPath->CompareNoCase(rpcsaInstances[nClassIndex].GetAt(i)) == 0)
			{
				rpcsaInstances[nClassIndex].RemoveAt(i,1);
				break;
			}
		}
	}
}

void CWrapListCtrl::DeleteFromEnd(int nNumber)
{
	int nItems = GetItemCount();

	if (nNumber <= nItems)
	{
		for (int i = nItems - 1; i >= nItems - nNumber; i--)
		{
			LPARAM dw = GetItemData(i);
			if (dw)
			{
				CString *pTmp = reinterpret_cast<CString*>(dw);
				delete pTmp;
			}
			DeleteItem(i);
		}
	}
	UpdateWindow();
}

void CWrapListCtrl::SetListInstances(CString *pcsClass , int nIndex)
{
	IWbemClassObject *phmmcoObject = NULL;
	IWbemClassObject *pErrorObject = NULL;

	BSTR bstrTemp = pcsClass->AllocSysString();
	SCODE sc =
			m_pParent->GetLocalParent()->GetLocalParent()->GetServices() ->
				GetObject
					(bstrTemp,0,NULL,&phmmcoObject,NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get class object ") + *pcsClass;
		ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 9);
		m_pParent->GetLocalParent()->GetLocalParent()->
			ReleaseErrorObject(pErrorObject);
		return;
	}

	m_pParent->GetLocalParent()->GetLocalParent()->
			ReleaseErrorObject(pErrorObject);

	delete m_pcsaProps;
	m_pcsaProps = NULL;
	m_pcsaProps = GetColProps(phmmcoObject);
	int nProps = (int) m_pcsaProps->GetSize();

	int nItems = GetItemCount();
	int i;
	for (i = 0; i < nItems;i++)
	{
		CString *pcsPath
			= reinterpret_cast<CString *>(GetItemData(i));
		delete pcsPath;
	}

	DeleteAllItems();


	for (i = 10; i >= 0; i--)
	{
		DeleteColumn(i);
	}

	LV_COLUMN lvCol;
	lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvCol.fmt = LVCFMT_LEFT;   // left-align column
	lvCol.cx = 48;             // width of column in pixels
	lvCol.iSubItem = 0;
	lvCol.pszText = _T("Include");

	int nReturn =
		InsertColumn( 0, &lvCol);


	if (nProps == 0) {
		// Handle the case where we're dealing with a singleton class that has no keys.
		// For a singleton, we need an extra column with no title since there is no
		// corresponding key property.  The values in this column will say <singleton>
		lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
		lvCol.fmt = LVCFMT_LEFT;   // left-align column
		lvCol.cx = 200;             // width of column in pixels
		lvCol.iSubItem = i + 1;
		lvCol.pszText = _T("");

		nReturn = InsertColumn( 1, &lvCol);

	}
	else {
		for (i = 0; i < nProps; i++)
		{
			lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
			lvCol.fmt = LVCFMT_LEFT;   // left-align column
			lvCol.cx = 200;             // width of column in pixels
			lvCol.iSubItem = i + 1;
			lvCol.pszText = const_cast<TCHAR *>
				((LPCTSTR)m_pcsaProps->GetAt(i));

			nReturn = InsertColumn( i + 1, &lvCol);
		}
	}




	CPtrArray cpaInstances;
	int nInstances = GetInstances
		(m_pParent->GetLocalParent()->GetLocalParent()->GetServices(),
		pcsClass, cpaInstances);

	AddInstances(cpaInstances);


}

CStringArray *CWrapListCtrl::GetColProps
(IWbemClassObject * pClass)
{
	CStringArray csaKeyProps;
	CString csLabelProp;
	CStringArray *pcsaReturn = NULL; // leak

	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;
	int nProps;
	CStringArray *pcsProps = GetPropNames(pClass);
	nProps =  (int) pcsProps->GetSize();
	int i;
	IWbemQualifierSet * pAttrib = NULL;
	CString csTmp;
	CString csLabelAttrib = _T("Label");
	CString csKeyAttrib = _T("Key");
	CString csClassProp = _T("__Class");


	for (i = 0; i < nProps; i++)
	{
		BSTR bstrTemp = pcsProps -> GetAt(i).AllocSysString();
		sc = pClass -> GetPropertyQualifierSet(bstrTemp,
						&pAttrib);
		::SysFreeString(bstrTemp);
		if (sc == S_OK)
		{
			sc = pAttrib->GetNames(0,&psa);

			 if(sc == S_OK)
			{
				int iDim = SafeArrayGetDim(psa);
				sc = SafeArrayGetLBound(psa,1,&lLower);
				sc = SafeArrayGetUBound(psa,1,&lUpper);
				BSTR AttrName;
				for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
				{
					sc = SafeArrayGetElement(psa,ix,&AttrName);
					csTmp = AttrName;
					if (csTmp.CompareNoCase(csLabelAttrib)  == 0)
					{
						csLabelProp = pcsProps -> GetAt(i);
					}
					else if (csTmp.CompareNoCase(csKeyAttrib)  == 0)
					{
						csaKeyProps.Add(pcsProps -> GetAt(i));
					}
					SysFreeString(AttrName);

				}
			 }
			 pAttrib -> Release();
		}
	}

	SafeArrayDestroy(psa);
	delete pcsProps;
	pcsaReturn = new CStringArray;
	if (!csLabelProp.IsEmpty())
	{
		pcsaReturn -> Add(csLabelProp);
	}
	else
	{
		pcsaReturn -> CStringArray::Append(csaKeyProps);
	}

	return pcsaReturn;
}

CStringArray *CWrapListCtrl::GetPropNames(IWbemClassObject * pClass)
{
	CStringArray *pcsaReturn = NULL;
	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;

	VARIANTARG var;
	VariantInit(&var);
	CString csNull;


    sc = pClass->GetNames(NULL,0,NULL, &psa );

    if(sc == S_OK)
	{
       int iDim = SafeArrayGetDim(psa);
	   int i;
       sc = SafeArrayGetLBound(psa,1,&lLower);
       sc = SafeArrayGetUBound(psa,1,&lUpper);
	   pcsaReturn = new CStringArray;
	   CString csTmp;
       for(ix[0] = lLower, i = 0; ix[0] <= lUpper; ix[0]++, i++)
	   {
           BSTR PropName;
           sc = SafeArrayGetElement(psa,ix,&PropName);
		   csTmp = PropName;
           pcsaReturn -> Add(csTmp);
           SysFreeString(PropName);
	   }
	}

	SafeArrayDestroy(psa);

	return (pcsaReturn);
}

void CWrapListCtrl::Initialize()
{
#if 0
	CBitmap cbmChecks;

	cbmChecks.LoadBitmap(IDB_BITMAPCHECKS);

	m_pcilImageList = new CImageList();

	m_pcilImageList -> Create (16, 16, TRUE, 3, 0);

	m_pcilImageList -> Add(&cbmChecks,RGB (255,0,0));

	cbmChecks.DeleteObject();

	SetImageList(m_pcilImageList, LVSIL_SMALL);
#endif

	DWORD dw = GetExtendedStyle();
	dw |= LVS_EX_FULLROWSELECT | LVS_EX_CHECKBOXES;
	SetExtendedStyle(dw);
}

CString CWrapListCtrl::GetProperty
(IWbemClassObject * pInst, CString *pcsProperty)

{
	SCODE sc;

    VARIANTARG var;
	VariantInit(&var);
	long lType;

	BSTR bstrTemp = pcsProperty -> AllocSysString ( );
    sc = pInst->Get( bstrTemp ,0,&var,&lType,NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK || lType == CIM_EMPTY)
	{
		return  _T("");
	}

	VARIANTARG varChanged;
	VariantInit(&varChanged);


	HRESULT hr;

	hr = VariantChangeType(&varChanged, &var, 0, VT_BSTR);

	CString csOut;

	if (hr == S_OK && varChanged.vt == VT_BSTR)
	{
		csOut = varChanged.bstrVal;
	}
	else
	{
		csOut = _T("");
	}

	VariantClear(&var);
	VariantClear(&varChanged);
	return csOut;
}

CString CWrapListCtrl::GetPath(IWbemClassObject *pClass)
{

	CString csProp = _T("__Path");
	return GetProperty(pClass,&csProp);


}

int CWrapListCtrl::GetInstances
(IWbemServices * pIWbemServices, CString *pcsClass, CPtrArray &cpaInstances)
{
	SCODE sc;
	IEnumWbemClassObject *pimecoInstanceEnum = NULL;
	IWbemClassObject     *pimcoInstance = NULL;
	IWbemClassObject     *pErrorObject = NULL;


	BSTR bstrTemp = pcsClass -> AllocSysString();
	sc = pIWbemServices->CreateInstanceEnum
		(bstrTemp, WBEM_FLAG_SHALLOW,NULL,
		&pimecoInstanceEnum);
	::SysFreeString(bstrTemp);

	if(sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get instance enumeration ");
		csUserMsg += _T(" for class ");
		csUserMsg += *pcsClass;
		ErrorMsg
				(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 11);
		m_pParent->GetLocalParent()->GetLocalParent()->
			ReleaseErrorObject(pErrorObject);
		return 0;
	}
	m_pParent->GetLocalParent()->GetLocalParent()->
			ReleaseErrorObject(pErrorObject);

	SetEnumInterfaceSecurity(m_pParent->GetLocalParent()->GetLocalParent()->m_csNameSpace,pimecoInstanceEnum, pIWbemServices);

	sc = pimecoInstanceEnum->Reset();

	ULONG uReturned;
	int i = 0;

	pimcoInstance = NULL;
    while (S_OK == pimecoInstanceEnum->Next(INFINITE,1, &pimcoInstance, &uReturned) )
		{
			cpaInstances.Add(reinterpret_cast<void *>(pimcoInstance));
			pimcoInstance = NULL;
			i++;
		}

	pimecoInstanceEnum -> Release();
	return i;

}

void CWrapListCtrl::AddInstances(CPtrArray &cpaInstances)
{
	int nIndex = m_pParent-> GetSelectedClass();

	CStringArray *&rpcsaInstances=
			m_pParent ->GetLocalParent()->GetLocalParent()->
					GetInstances();


	for (int i = 0; i < cpaInstances.GetSize(); i++)
	{
		IWbemClassObject *pimcoInstance =
			reinterpret_cast<IWbemClassObject *>(cpaInstances.GetAt(i));
		CString csPath = GetPath(pimcoInstance);
		if(StringInArray (rpcsaInstances, &csPath, nIndex))
		{
			AddInstance(pimcoInstance,TRUE);
		}
		else
		{
			AddInstance(pimcoInstance,FALSE);
		}
		pimcoInstance->Release();
	}

}

void CWrapListCtrl::AddInstance
(IWbemClassObject *pimcoInstance , BOOL bChecked)
{

	CString *pcsPath = new CString;
	*pcsPath = GetPath (pimcoInstance);

	LV_ITEM lvItem;

	lvItem.mask = LVIF_TEXT | LVIF_PARAM;
	lvItem.pszText = _T("");
	lvItem.iItem = GetItemCount();
	lvItem.iSubItem = 0;
	lvItem.iImage = 0;
	lvItem.lParam = (LPARAM)(pcsPath);

	int nItem;
	nItem = InsertItem (&lvItem);


	int nKeys = (int) m_pcsaProps->GetSize();
	if (nKeys > 0) {
		for (int iKey = 0; iKey < nKeys;iKey++)
		{
			CString csValue = GetProperty
				(pimcoInstance,&m_pcsaProps->GetAt(iKey));


			SetItemText
				(nItem, iKey + 1,
				const_cast<TCHAR *>((LPCTSTR) csValue));

		}
	}
	else {
		// An instance in a class without keys must be a singleton.

		SetItemText(nItem, 1, _T("<singleton>"));
	}

	SetCheck(nItem, bChecked);
}


void CWrapListCtrl::OnDestroy()
{

	int nItems = GetItemCount();

	for (int i = 0; i < nItems; i++)
	{
		LPARAM dw = GetItemData(i);
		if (dw)
		{
			CString *pTmp = reinterpret_cast<CString*>(dw);
			delete pTmp;
		}


	}

	CListCtrl::OnDestroy();
}

int CWrapListCtrl::GetNumSelected()
{
	int n = 0;

	for (int i = 0; i < GetItemCount(); i++)
	{
		if (GetCheck(i))
			n++;
	}

	return n;
}

void CWrapListCtrl::SelectAll()
{
	CStringArray *&rpcsaInstances = m_pParent->GetLocalParent()->GetLocalParent()->GetInstances();
	int nClassIndex = m_pParent-> GetSelectedClass();
	rpcsaInstances[nClassIndex].RemoveAll();

	int nCount = GetItemCount();
	for (int i = 0; i < nCount; i++)
	{
		SetCheck(i, TRUE);
		CString *psz = (CString *)GetItemData(i);

		// bug#57552 - The SetCheck 'may' cause the item to be inserted into the list.  Use
		// UpdateClassInstanceList to be safe (this won't insert an item twice
//		rpcsaInstances[nClassIndex].Add(*psz);
		UpdateClassInstanceList(0, psz, TRUE);
	}
}

void CWrapListCtrl::UnselectAll()
{
	int nCount = GetItemCount();
	for (int i = 0; i < nCount; i++)
		SetCheck(i, FALSE);

	CStringArray *&rpcsaInstances = m_pParent->GetLocalParent()->GetLocalParent()->GetInstances();
	int nClassIndex = m_pParent-> GetSelectedClass();
	rpcsaInstances[nClassIndex].RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\dlgsingleview.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
class CDlgSingleView  :public CSingleView 
{
protected:
	DECLARE_DYNCREATE(CDlgSingleView)
public:

//{{AFX_MSG(CDlgSingleView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
public:
	IWbemClassObject *m_pErrorObject;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\delayhlp.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#define STRICT
#include <windows.h>
#pragma hdrstop
#include "delayImp.h"
#include <tchar.h> 




extern "C"
PUnloadInfo __puiHead = 0;


struct ULI : public UnloadInfo {
    ULI(PCImgDelayDescr pidd_) {
        pidd = pidd_;
        Link();
        }

    ~ULI() {
        Unlink();
        }

    void *
    operator new(unsigned int cb) {
        return ::LocalAlloc(LPTR, cb);
        }

    void
    operator delete(void * pv) {
        ::LocalFree(pv);
        }

    void
    Unlink() {
        PUnloadInfo *   ppui = &__puiHead;

        while (*ppui && *ppui != this) {
            ppui = &((*ppui)->puiNext);
            }
        if (*ppui == this) {
            *ppui = puiNext;
            }
        }

    void
    Link() {
        puiNext = __puiHead;
        __puiHead = this;
        }
    };

static inline
PIMAGE_NT_HEADERS WINAPI
PinhFromImageBase(HMODULE);

static inline
DWORD WINAPI
TimeStampOfImage(PIMAGE_NT_HEADERS);

static inline
void WINAPI
OverlayIAT(PImgThunkData pitdDst, PCImgThunkData pitdSrc);

static inline
bool WINAPI
FLoadedAtPreferredAddress(PIMAGE_NT_HEADERS, HMODULE);

extern "C"
FARPROC WINAPI
__delayLoadHelper(
    PCImgDelayDescr pidd,
    FARPROC *       ppfnIATEntry
    ) {

    // Set up some data we use for the hook procs but also useful for
    // our own use
    //

    DelayLoadInfo   dli = {
        sizeof DelayLoadInfo,
        pidd,
        ppfnIATEntry,
		pidd->szName,
        { 0 },
        0,
        0,
        0
        };

    HMODULE hmod = *(pidd->phmod);

    // Calculate the index for the name in the import name table.
    // N.B. it is ordered the same as the IAT entries so the calculation
    // comes from the IAT side.
    //
    unsigned        iINT;
    iINT = IndexFromPImgThunkData(PCImgThunkData(ppfnIATEntry), pidd->pIAT);

    PCImgThunkData  pitd = &((pidd->pINT)[iINT]);

    if (dli.dlp.fImportByName = ((pitd->u1.Ordinal & IMAGE_ORDINAL_FLAG) == 0))
	{
        dli.dlp.szProcName = (LPCSTR)(pitd->u1.AddressOfData->Name);
    }
    else {
        dli.dlp.dwOrdinal = IMAGE_ORDINAL(pitd->u1.Ordinal);
        }

    // Call the initial hook.  If it exists and returns a function pointer,
    // abort the rest of the processing and just return it for the call.
    //
    FARPROC pfnRet = NULL;

    if (__pfnDliNotifyHook) {
        if (pfnRet = ((*__pfnDliNotifyHook)(dliStartProcessing, &dli))) {
            goto HookBypass;
            }
        }

    if (hmod == 0) {
        if (__pfnDliNotifyHook) {
            hmod = HMODULE(((*__pfnDliNotifyHook)(dliNotePreLoadLibrary, &dli)));
            }
#ifdef UNICODE
		TCHAR tcName[MAX_PATH];
		for (unsigned int i = 0; i < strlen(dli.szDll); i++)
		{
			TCHAR tc = dli.szDll[i];
			tcName[i] = tc;

		}
		tcName[i] = '\0';
		 if (hmod == 0) 
		 {
            hmod = ::LoadLibrary(tcName);
         }
#else
		  if (hmod == 0)
		  {
            hmod = ::LoadLibrary(dli.szDll);
          }
#endif
        
        if (hmod == 0) {
            dli.dwLastError = ::GetLastError();
            if (__pfnDliFailureHook) {
                // when the hook is called on LoadLibrary failure, it will
                // return 0 for failure and an hmod for the lib if it fixed
                // the problem.
                //
                hmod = HMODULE((*__pfnDliFailureHook)(dliFailLoadLib, &dli));
                }

            if (hmod == 0) {
                PDelayLoadInfo  pdli = &dli;

                RaiseException(
                    VcppException(ERROR_SEVERITY_ERROR, ERROR_MOD_NOT_FOUND),
                    0,
                    1,
                    PDWORD(&pdli)
                    );
                
                // If we get to here, we blindly assume that the handler of the exception
                // has magically fixed everything up and left the function pointer in 
                // dli.pfnCur.
                //
                return dli.pfnCur;
                }
            }

        // Store the library handle.  If it is already there, we infer
        // that another thread got there first, and we need to do a
        // FreeLibrary() to reduce the refcount
        //
        HMODULE hmodT = HMODULE(::InterlockedExchange(LPLONG(pidd->phmod), LONG(hmod)));
        if (hmodT != hmod) {
            // add lib to unload list if we have unload data
            if (pidd->pUnloadIAT) {
                ULI *   puli = new ULI(pidd);
                (void *)puli;
                }
            }
        else {
            ::FreeLibrary(hmod);
            }
        
        }

    // Go for the procedure now.
    dli.hmodCur = hmod;
    if (__pfnDliNotifyHook) {
        pfnRet = (*__pfnDliNotifyHook)(dliNotePreGetProcAddress, &dli);
        }
    if (pfnRet == 0) {
        if (pidd->pBoundIAT && pidd->dwTimeStamp) {
            // bound imports exist...check the timestamp from the target image
            PIMAGE_NT_HEADERS   pinh(PinhFromImageBase(hmod));

            if (pinh->Signature == IMAGE_NT_SIGNATURE &&
                TimeStampOfImage(pinh) == pidd->dwTimeStamp &&
                FLoadedAtPreferredAddress(pinh, hmod)) {

                OverlayIAT(pidd->pIAT, pidd->pBoundIAT);
                pfnRet = FARPROC(pidd->pIAT[iINT].u1.Function);
                goto HookBypass;
                }
            }
         pfnRet = ::GetProcAddress(hmod, dli.dlp.szProcName);
        }

    if (pfnRet == 0) {
        dli.dwLastError = ::GetLastError();
        if (__pfnDliFailureHook) {
            // when the hook is called on GetProcAddress failure, it will
            // return 0 on failure and a valid proc address on success
            //
            pfnRet = (*__pfnDliFailureHook)(dliFailGetProc, &dli);
            }
        if (pfnRet == 0) {
            PDelayLoadInfo  pdli = &dli;

            RaiseException(
                VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND),
                0,
                1,
                PDWORD(&pdli)
                );

            // If we get to here, we blindly assume that the handler of the exception
            // has magically fixed everything up and left the function pointer in 
            // dli.pfnCur.
            //
            pfnRet = dli.pfnCur;
            }
        }


    *ppfnIATEntry = pfnRet;

HookBypass:
    if (__pfnDliNotifyHook) {
        dli.dwLastError = 0;
        dli.hmodCur = hmod;
        dli.pfnCur = pfnRet;
        (*__pfnDliNotifyHook)(dliNoteEndProcessing, &dli);
        }
    return pfnRet;
    }


#pragma intrinsic(strlen,memcmp,memcpy)

extern "C"
BOOL WINAPI
__FUnloadDelayLoadedDLL(LPCSTR szDll) {
    
    BOOL        fRet = FALSE;
    PUnloadInfo pui = __puiHead;
    
    for (pui = __puiHead; pui; pui = pui->puiNext) {
        if (memcmp(szDll, pui->pidd->szName, strlen(pui->pidd->szName)) == 0) {
            break;
            }
        }

    if (pui && pui->pidd->pUnloadIAT) {
        PCImgDelayDescr pidd = pui->pidd;
        HMODULE         hmod = *pidd->phmod;

        OverlayIAT(pidd->pIAT, pidd->pUnloadIAT);
        ::FreeLibrary(hmod);
        *pidd->phmod = NULL;
        
        delete reinterpret_cast<ULI*> (pui);

        fRet = TRUE;
        }

    return fRet;
    }

static inline
PIMAGE_NT_HEADERS WINAPI
PinhFromImageBase(HMODULE hmod) {
    return PIMAGE_NT_HEADERS(PCHAR(hmod) + PIMAGE_DOS_HEADER(hmod)->e_lfanew);
    }

static inline
void WINAPI
OverlayIAT(PImgThunkData pitdDst, PCImgThunkData pitdSrc) {
    memcpy(pitdDst, pitdSrc, CountOfImports(pitdDst) * sizeof IMAGE_THUNK_DATA);
    }

static inline
DWORD WINAPI
TimeStampOfImage(PIMAGE_NT_HEADERS pinh) {
    return pinh->FileHeader.TimeDateStamp;
    }

static inline
bool WINAPI
FLoadedAtPreferredAddress(PIMAGE_NT_HEADERS pinh, HMODULE hmod) {
    return DWORD(hmod) == pinh->OptionalHeader.ImageBase;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\embededobjdlg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// EmbededObjDlg.cpp : implementation file
//

#include "precomp.h"
#include "wbemidl.h"
#include "MsgDlg.h"
#include "singleview.h"
#include "dlgsingleview.h"
#include "EmbededObjDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum {EDITMODE_BROWSER=0, EDITMODE_STUDIO=1, EDITMODE_READONLY=2};	// We should have a common define for this somewhere.

/////////////////////////////////////////////////////////////////////////////
// CEmbededObjDlg dialog


CEmbededObjDlg::CEmbededObjDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CEmbededObjDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEmbededObjDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_csvControl.m_pErrorObject = NULL;
}


void CEmbededObjDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEmbededObjDlg)
	DDX_Control(pDX, IDC_SINGLEVIEWCTRL1, m_csvControl);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEmbededObjDlg, CDialog)
	//{{AFX_MSG_MAP(CEmbededObjDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEmbededObjDlg message handlers

BOOL CEmbededObjDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO: Add extra initialization here
	m_csvControl.SetEditMode(EDITMODE_READONLY);
	m_csvControl.SelectObjectByPointer(NULL, m_csvControl.m_pErrorObject, TRUE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CEmbededObjDlg::OnOK()
{
	if(m_csvControl.QueryNeedsSave())
	{
		AfxMessageBox(IDS_NO_SAVE_ERROR_OBJ, MB_OK|MB_ICONWARNING);
	}
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\embededobjdlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{AFX_INCLUDES()
#include "singleview.h"
//}}AFX_INCLUDES
#if !defined(AFX_EMBEDEDOBJDLG_H__890221D2_18ED_11D1_9650_00C04FD9B15B__INCLUDED_)
#define AFX_EMBEDEDOBJDLG_H__890221D2_18ED_11D1_9650_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// EmbededObjDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEmbededObjDlg dialog

class CEmbededObjDlg : public CDialog
{
// Construction
public:
	CEmbededObjDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CEmbededObjDlg)
	enum { IDD = IDD_DIALOG3 };
	CDlgSingleView	m_csvControl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEmbededObjDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEmbededObjDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_EMBEDEDOBJDLG_H__890221D2_18ED_11D1_9650_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\htmtopics.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "HTMTopics.h"
#include "resource.h"
#include "wbemRegistry.h"
#include "wbemVersion.h"
#include "htmlhelp.h"

#ifdef NO_WBEMUTILS
#include "..\eventviewer\container\container.h"
extern CContainerApp theApp;
#else
#include "MsgDlg.h"
extern CMsgDlgApp theApp;
#endif NO_WBEMUTILS

typedef HWND (WINAPI *HTMLHELPPROC)(HWND hwndCaller,
								LPCSTR pszFile,
								UINT uCommand,
								DWORD_PTR dwData);

WBEMUTILS_POLARITY void WbemHelp(HWND hParent, LPCSTR page)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CString csPath;
	HTMLHELPPROC proc = 0;

	// never looked for control yet.
	if(theApp.m_htmlHelpInst == NULL)
	{
		theApp.m_htmlHelpInst = LoadLibrary(_T("Hhctrl.ocx"));
	}

	// can I find the control?
	if(theApp.m_htmlHelpInst == NULL)
	{
		// tell them where to get it.
		AfxMessageBox(IDS_NO_HHCTRL, MB_OK|MB_ICONSTOP);
	}
	else
	{
		// got the control, now get the procedure...
#ifdef UNICODE
			(FARPROC&)proc = GetProcAddress(theApp.m_htmlHelpInst, "HtmlHelpW");
#else
			(FARPROC&)proc = GetProcAddress(theApp.m_htmlHelpInst, "HtmlHelpA");
#endif

		// got the procedure??
		if(proc)
		{
			// cool, get ready to call it.
			WbemRegString(SDK_HELP, csPath);

#ifdef _UNICODE
			char szTemp[1024];
			wcstombs(szTemp, csPath, sizeof(szTemp));

			// do it.
			HWND retval = (*proc)(hParent, szTemp, HH_DISPLAY_TOPIC,
								(DWORD_PTR) ((LPCTSTR)page));
#else

			// do it.
			HWND retval = (*proc)(hParent, csPath, HH_DISPLAY_TOPIC,
								(unsigned long) ((LPCTSTR)page));
#endif


			if(retval == 0)
			{
				// tell them where to get it.
				AfxMessageBox(IDS_NO_HTML_PAGE, MB_OK|MB_ICONSTOP);
			}
		}
		else
		{
			// nope? something seriously wrong.
			AfxMessageBox(IDS_NO_HTMLHELP, MB_OK|MB_ICONSTOP);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\delayimp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// DelayImp.h
//
//  define structures and prototypes necessary for delay loading of imports
//
#pragma once
#if !defined(_delayimp_h)
#define _delayimp_h

#if defined(__cplusplus)
#define ExternC extern "C"
#else
#define ExternC
#endif

typedef IMAGE_THUNK_DATA *          PImgThunkData;
typedef const IMAGE_THUNK_DATA *    PCImgThunkData;

typedef struct ImgDelayDescr {
    DWORD           grAttrs;        // attributes
    LPCSTR          szName;		    // pointer to dll name
    HMODULE *       phmod;          // address of module handle
    PImgThunkData   pIAT;           // address of the IAT
    PCImgThunkData  pINT;           // address of the INT
    PCImgThunkData  pBoundIAT;      // address of the optional bound IAT
    PCImgThunkData  pUnloadIAT;     // address of optional copy of original IAT
    DWORD           dwTimeStamp;    // 0 if not bound,
                                    // O.W. date/time stamp of DLL bound to (Old BIND)
    } ImgDelayDescr, * PImgDelayDescr;

typedef const ImgDelayDescr *   PCImgDelayDescr;

//
// Delay load import hook notifications
//
enum {
    dliStartProcessing,             // used to bypass or note helper only
    dliNotePreLoadLibrary,          // called just before LoadLibrary, can
                                    //  override w/ new HMODULE return val
    dliNotePreGetProcAddress,       // called just before GetProcAddress, can
                                    //  override w/ new FARPROC return value
    dliFailLoadLib,                 // failed to load library, fix it by
                                    //  returning a valid HMODULE
    dliFailGetProc,                 // failed to get proc address, fix it by
                                    //  returning a valid FARPROC
    dliNoteEndProcessing,           // called after all processing is done, no
                                    //  no bypass possible at this point except
                                    //  by longjmp()/throw()/RaiseException.
    };

typedef struct DelayLoadProc {
    BOOL                fImportByName;
    union {
        LPCSTR          szProcName;
        DWORD           dwOrdinal;
        };
    } DelayLoadProc;

typedef struct DelayLoadInfo {
    DWORD               cb;         // size of structure
    PCImgDelayDescr     pidd;       // raw form of data (everything is there)
    FARPROC *           ppfn;       // points to address of function to load
    LPCSTR             szDll;      // name of dll
    DelayLoadProc       dlp;        // name or ordinal of procedure
    HMODULE             hmodCur;    // the hInstance of the library we have loaded
    FARPROC             pfnCur;     // the actual function that will be called
    DWORD               dwLastError;// error received (if an error notification)
    } DelayLoadInfo, * PDelayLoadInfo;

typedef FARPROC (WINAPI *PfnDliHook)(
    unsigned        dliNotify,
    PDelayLoadInfo  pdli
    );

// utility function for calculating the index of the current import
// for all the tables (INT, BIAT, UIAT, and IAT).
__inline unsigned
IndexFromPImgThunkData(PCImgThunkData pitdCur, PCImgThunkData pitdBase) {
    return pitdCur - pitdBase;
    }

//
// Unload support
//

// routine definition; takes a pointer to a name to unload, or NULL to
// unload all the delay load dlls in the list.
//
ExternC
BOOL WINAPI
__FUnloadDelayLoadedDLL(LPCSTR szDll);

// structure definitions for the list of unload records
typedef struct UnloadInfo * PUnloadInfo;
typedef struct UnloadInfo {
    PUnloadInfo     puiNext;
    PCImgDelayDescr pidd;
    } UnloadInfo;

// the default delay load helper places the unloadinfo records in the list
// headed by the following pointer.
ExternC
extern
PUnloadInfo __puiHead;

//
// Exception information
//
#define FACILITY_VISUALCPP  ((LONG)0x6d)
#define VcppException(sev,err)  ((sev) | (FACILITY_VISUALCPP<<16) | err)

// utility function for calculating the count of imports given the base
// of the IAT.  NB: this only works on a valid IAT!
__inline unsigned
CountOfImports(PCImgThunkData pitdBase) {
    unsigned        cRet = 0;
    PCImgThunkData  pitd = pitdBase;
    while (pitd->u1.Function) {
        pitd++;
        cRet++;
        }
    return cRet;
    }

//
// Hook pointers
//

// The "notify hook" gets called for every call to the
// delay load helper.  This allows a user to hook every call and
// skip the delay load helper entirely.
//
// dliNotify == {
//  dliStartProcessing |
//  dliPreLoadLibrary  |
//  dliPreGetProc |
//  dliNoteEndProcessing}
//  on this call.
//
ExternC
extern
PfnDliHook   __pfnDliNotifyHook;

// This is the failure hook, dliNotify = {dliFailLoadLib|dliFailGetProc}
ExternC
extern
PfnDliHook   __pfnDliFailureHook;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\htmtopics.h ===
#ifndef __WBEMHTMLHELP__
#define __WBEMHTMLHELP__
#pragma once
#include "DeclSpec.h"

#define idh_provcodegen _T("hh/wmisdk/framework_859u.htm")                   //  Provider Code Generator
#define idh_appguide _T("hh/wmisdk/toolsguide_9m5h.htm")                     //  Applications Guide
#define idh_sysreq _T("hh/wmisdk/toolsguide_0dwz.htm")                       //  System Requirements for WMI Applications
#define idh_wbemlogindb _T("hh/wmisdk/toolsguide_1t4e.htm")                  //  WMI Application Logon
#define idh_objbrowser _T("hh/wmisdk/toolsguide_9ueq.htm")                   //  WMI Object Browser
#define idh_startobjbrowser _T("hh/wmisdk/toolsguide_5qcy.htm")              //  Starting WMI Object Browser
#define idh_objbrowserui _T("hh/wmisdk/toolsguide_9a1x.htm")                 //  WMI Object Browser User Interface
#define idh_objexplorer _T("hh/wmisdk/toolsguide_2enm.htm")                  //  Object Explorer
#define idh_objviewer _T("hh/wmisdk/toolsguide_6wj6.htm")                    //  Object Viewer
#define idh_objbrowserfunc _T("hh/wmisdk/toolsguide_9o4z.htm")               //  WMI Object Browser Functions
#define idh_dispobjtree _T("hh/wmisdk/toolsguide_036t.htm")                  //  Displaying an Object Tree
#define idh_namespaceobjbox _T("hh/wmisdk/toolsguide_41bs.htm")              //  Specifying the Namespace in the Objects in Box
#define idh_namespacehistory _T("hh/wmisdk/toolsguide_5gvo.htm")             //  Selecting the Namespace from the History List
#define idh_namespacebrowse _T("hh/wmisdk/toolsguide_32ud.htm")              //  Browsing for a Namespace
#define idh_usinggotonamespace _T("hh/wmisdk/toolsguide_1h66.htm")           //  Using the Go to Namespace Function
#define idh_rerootingobjtree _T("hh/wmisdk/toolsguide_3cx1.htm")             //  Rerooting an Object Tree
#define idh_usingmkinitialtreeroot _T("hh/wmisdk/toolsguide_2eyc.htm")       //  Using Make Initial Tree Root
#define idh_usingmakerootreroot _T("hh/wmisdk/toolsguide_9qqt.htm")          //  Using Make Root to Reroot the Object Tree
#define idh_usingbrowseforinstancereroot _T("hh/wmisdk/toolsguide_9mzp.htm") //  Using Browse for Instance to Reroot the Object Tree
#define idh_displayingregobjprops _T("hh/wmisdk/toolsguide_1zw3.htm")        //  Displaying Properties of Regular Objects
#define idh_filterobjpropviews _T("hh/wmisdk/toolsguide_9m43.htm")           //  Filtering Views of Object Properties
#define idh_displayingobjdatacustview _T("hh/wmisdk/toolsguide_3kgx.htm")    //  Displaying Custom Views of Object Data
#define idh_editobjprops _T("hh/wmisdk/toolsguide_3s1f.htm")                 //  Editing Object Properties
#define idh_dispinstances _T("hh/wmisdk/toolsguide_1zjn.htm")                //  Displaying Instances
#define idh_dispobjmethods _T("hh/wmisdk/toolsguide_21df.htm")               //  Displaying Object Methods
#define idh_execobjmethods _T("hh/wmisdk/toolsguide_93sj.htm")               //  Executing Object Methods
#define idh_dispobjassoc _T("hh/wmisdk/toolsguide_70xf.htm")                 //  Displaying Object Associations
#define idh_dispassocobjprops _T("hh/wmisdk/toolsguide_6oz7.htm")            //  Displaying Properties of Association Objects
#define idh_editassocobjprops _T("hh/wmisdk/toolsguide_3f1v.htm")            //  Editing Properties of Association Objects
#define idh_dispobjqual _T("hh/wmisdk/toolsguide_3303.htm")                  //  Displaying Object Qualifiers
#define idh_disppropqual _T("hh/wmisdk/toolsguide_9cs3.htm")                 //  Displaying Property Qualifiers
#define idh_editobjpropqual _T("hh/wmisdk/toolsguide_2t83.htm")              //  Editing Object and Property Qualifiers
#define idh_wbemcimstudio _T("hh/wmisdk/toolsguide_5fan.htm")                //  WMI CIM Studio
#define idh_startwbemcimstudio _T("hh/wmisdk/toolsguide_97ov.htm")           //  Starting WMI CIM Studio
#define idh_cimstudioui _T("hh/wmisdk/toolsguide_684l.htm")                  //  WMI CIM Studio User Interface
#define idh_classexpl _T("hh/wmisdk/toolsguide_7836.htm")                    //  Class Explorer
#define idh_classview _T("hh/wmisdk/toolsguide_9diq.htm")                    //  Class Viewer
#define idh_wizards _T("hh/wmisdk/toolsguide_9w1f.htm")                      //  Wizards
#define idh_cimstudiofunc _T("hh/wmisdk/toolsguide_6gvn.htm")                //  WMI CIM Studio Functions
#define idh_dispclassinhtree _T("hh/wmisdk/toolsguide_28th.htm")             //  Displaying a Class Inheritance Tree
#define idh_specnamespacebox _T("hh/wmisdk/toolsguide_28th.htm")             //  Displaying a Class Inheritance Tree
#define idh_selnamespacehistory _T("hh/wmisdk/toolsguide_28th.htm")          //  Displaying a Class Inheritance Tree
#define idh_classsearch _T("hh/wmisdk/toolsguide_39o3.htm")                  //  Searching for a Class
#define idh_dispextclassdef _T("hh/wmisdk/toolsguide_5jqr.htm")              //  Displaying the Definition of an Existing Class
#define idh_dispclassprop _T("hh/wmisdk/toolsguide_57eb.htm")                //  Displaying Class Properties
#define idh_filtclasspropview _T("hh/wmisdk/toolsguide_33jn.htm")            //  Filtering Views of Class Properties
#define idh_dispclassmeth _T("hh/wmisdk/toolsguide_1lgz.htm")                //  Displaying Class Methods
#define idh_dispclassqual _T("hh/wmisdk/toolsguide_3trn.htm")                //  Displaying Class Qualifiers
#define idh_disppropqualclassex _T("hh/wmisdk/toolsguide_9mlu.htm")          //  Displaying Property Qualifiers in the Class Explorer
#define idh_dispmethqual _T("hh/wmisdk/toolsguide_625v.htm")                 //  Displaying Method Qualifiers
#define idh_dispclassassoc _T("hh/wmisdk/toolsguide_2c4z.htm")               //  Displaying Class Associations
#define idh_dispexclassinst _T("hh/wmisdk/toolsguide_0dyr.htm")              //  Displaying Instances of an Existing Class
#define idh_dispinsttab _T("hh/wmisdk/toolsguide_0i1x.htm")                  //  Displaying an Instance Table
#define idh_usingcustinstviews _T("hh/wmisdk/toolsguide_7vlf.htm")           //  Creating and Using Custom Views of Instances
#define idh_dispinstassoc _T("hh/wmisdk/toolsguide_9y91.htm")                //  Displaying Associations of an Instance
#define idh_addclassdefs _T("hh/wmisdk/toolsguide_5ab7.htm")                 //  Adding Class Definitions
#define idh_delclassdef _T("hh/wmisdk/toolsguide_3uyb.htm")                  //  Deleting Class Definitions
#define idh_modclassdef _T("hh/wmisdk/toolsguide_9wj7.htm")                  //  Modifying Class Definitions
#define idh_addclassrop _T("hh/wmisdk/toolsguide_0rar.htm")                  //  Adding Class Properties
#define idh_cimstudiorenclass _T("hh/wmisdk/toolsguide_2hm7.htm")            //  Renaming Classes in WMI CIM Studio
#define idh_delclassprop _T("hh/wmisdk/toolsguide_6zhv.htm")                 //  Deleting Class Properties
#define idh_editclassprop _T("hh/wmisdk/toolsguide_284z.htm")                //  Editing Class Properties
#define idh_addclassmeth _T("hh/wmisdk/toolsguide_8c1f.htm")                 //  Adding Class Methods
#define idh_delclassmeth _T("hh/wmisdk/toolsguide_46wj.htm")                 //  Deleting Class Methods
#define idh_editclassmethparm _T("hh/wmisdk/toolsguide_444z.htm")            //  Editing Class Method Parameters
#define idh_addclasspropmethqual _T("hh/wmisdk/toolsguide_2fw3.htm")         //  Adding Class, Property, or Method Qualifiers
#define idh_delclasspropmethqual _T("hh/wmisdk/toolsguide_38j7.htm")         //  Deleting Class, Property, or Method Qualifiers
#define idh_editclasspropmethqual _T("hh/wmisdk/toolsguide_0tmb.htm")        //  Editing Class, Property, or Method Qualifiers
#define idh_addclassinst _T("hh/wmisdk/toolsguide_39v7.htm")                 //  Adding Instances of a Class
#define idh_delclassinst _T("hh/wmisdk/toolsguide_5jub.htm")                 //  Deleting Instances of a Class
#define idh_methodexec _T("hh/wmisdk/toolsguide_9tin.htm")                   //  Executing Methods in CIM Studio
#define idh_wqlquerytool _T("hh/wmisdk/toolsguide_2zea.htm")                 //  Using the WQL Query Builder
#define idh_mofgenwiz _T("hh/wmisdk/toolsguide_1c2s.htm")                    //  Using the MOF Generator Wizard
#define idh_mofcompwiz _T("hh/wmisdk/toolsguide_3ois.htm")                   //  Using the MOF Compiler Wizard
#define idh_mofcomp _T("hh/wmisdk/toolsguide_5het.htm")                      //  Compiling a MOF File
#define idh_logonmcw _T("hh/wmisdk/toolsguide_26w4.htm")                     //  Logging on to the MOF Compiler Wizard
#define idh_checkmofsyn _T("hh/wmisdk/toolsguide_32zp.htm")                  //  Checking the Syntax of a MOF File
#define idh_creatbinmof _T("hh/wmisdk/toolsguide_5c6d.htm")                  //  Creating a Binary MOF File
#define idh_eventreg _T("hh/wmisdk/toolsguide_7df0.htm")                     //  WMI Event Registration Tool
#define idh_eventregui _T("hh/wmisdk/toolsguide_7rc5.htm")                   //  WMI Event Registration Tool Interface
#define idh_eventregfunc _T("hh/wmisdk/toolsguide_18mr.htm")                 //  WMI Event Registration Tool Functions
#define idh_viewclassprop _T("hh/wmisdk/toolsguide_2vub.htm")                //  Viewing Class Properties
#define idh_createventci _T("hh/wmisdk/toolsguide_8obp.htm")                 //  Creating an Event Consumer Instance
#define idh_createventfi _T("hh/wmisdk/toolsguide_58yt.htm")                 //  Creating an Event Filter Instance
#define idh_createventti _T("hh/wmisdk/toolsguide_3pr9.htm")                 //  Creating an Event Timer Instance
#define idh_regconsumerevent _T("hh/wmisdk/toolsguide_8bjo.htm")             //  Registering a Consumer for an Event
#define idh_eventviewer _T("hh/wmisdk/toolsguide_690y.htm")                  //  WMI Event Viewer
#define idh_eventvieweri _T("hh/wmisdk/toolsguide_8ecl.htm")                 //  WMI Event Viewer Interface

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\msgdlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MsgDlg.h : main header file for the MSGDLG DLL
//

#if !defined(AFX_MSGDLG_H__B25E3D35_A79A_11D0_961C_00C04FD9B15B__INCLUDED_)
#define AFX_MSGDLG_H__B25E3D35_A79A_11D0_961C_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

#define CALL_TIMEOUT 5000


/////////////////////////////////////////////////////////////////////////////
// CMsgDlgApp
// See MsgDlg.cpp for the implementation of this class
//

class CMsgDlgApp : public CWinApp
{
public:
	CMsgDlgApp();
	virtual ~CMsgDlgApp();

	HINSTANCE m_htmlHelpInst;
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMsgDlgApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CMsgDlgApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSGDLG_H__B25E3D35_A79A_11D0_961C_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\msgdlg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MsgDlg.cpp : Defines the initialization routines for the DLL.
//

#include "precomp.h"
#include "wbemidl.h"
#include "MsgDlg.h"
#include "UserMsgDlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//

/////////////////////////////////////////////////////////////////////////////
// CMsgDlgApp

BEGIN_MESSAGE_MAP(CMsgDlgApp, CWinApp)
	//{{AFX_MSG_MAP(CMsgDlgApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMsgDlgApp construction

CMsgDlgApp::CMsgDlgApp()
{
	m_htmlHelpInst = 0;
}
CMsgDlgApp::~CMsgDlgApp()
{

	if(m_htmlHelpInst)
	{
		FreeLibrary(m_htmlHelpInst);
		m_htmlHelpInst = 0;
	}
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMsgDlgApp object

CMsgDlgApp theApp;

BOOL CMsgDlgApp::InitInstance()
{
	AfxEnableControlContainer ();
	return CWinApp::InitInstance();
}

int CMsgDlgApp::ExitInstance()
{
	return CWinApp::ExitInstance();
}

//--------------------------------------------------------
//-------------EXTERNS------------------------------------
//--------------------------------------------------------
extern BOOL PASCAL EXPORT DisplayUserMessage(
							BSTR bstrDlgCaption,
							BSTR bstrClientMsg,
							HRESULT sc,
							BOOL bUseErrorObject,
							UINT uType = 0, HWND hwndParent = NULL)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// normal function body here

	if (sc == S_OK &&
		(bstrClientMsg == NULL || bstrClientMsg[0] == '\0'))
	{
		return TRUE;
	}

	IErrorInfo* perrinfo = NULL;
	IWbemClassObject* pcoError = NULL;
	if (bUseErrorObject)
	{
		HRESULT hr =  ::GetErrorInfo(0, &perrinfo);
		if (hr == S_OK)
		{
			hr = perrinfo->QueryInterface(IID_IWbemClassObject, (void**) &pcoError);
			if (FAILED(hr))
			{
				pcoError = NULL;
			}
		}
		else
		{
			perrinfo = NULL;
		}
	}


	CWnd* pParent = CWnd::FromHandle(hwndParent);
	CUserMsgDlg *pcumdDialog =
		new CUserMsgDlg(pParent, bstrDlgCaption,
						bstrClientMsg,
						sc,
						pcoError,
						uType);

	pcumdDialog->DoModal();

	BOOL bReturn = pcumdDialog->GetMsgDlgError();

	delete pcumdDialog;

	if(pcoError)
	{
		pcoError->Release();
	}
	if(perrinfo)
	{
		perrinfo->Release();
	}

	return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\msgdlgexterns.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MsgDlgExterns.h
#ifndef __MSGDLGEXTERNS__
#define __MSGDLGEXTERNS__

// pick icon based on severity code.
#define BASED_ON_HRESULT 0

extern BOOL PASCAL EXPORT DisplayUserMessage(
							BSTR bstrDlgCaption, 
							BSTR bstrClientMsg, 
							HRESULT sc, 
							BOOL bUseErrorObject,
							UINT uType = BASED_ON_HRESULT, HWND hwndParent = NULL);

#endif __MSGDLGEXTERNS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\schemainfo.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#pragma once

#include "declspec.h"

		enum SCHEMA_ICONS {
			SCHEMA_CLASS = 0,
			SCHEMA_CLASS_ABSTRACT1,
			SCHEMA_CLASS_ABSTRACT2,
			SCHEMA_CLASS_1,
			SCHEMA_4,
			SCHEMA_5,
			SCHEMA_6,
			SCHEMA_7,
			SCHEMA_ASSOC,
			SCHEMA_ASSOC_ABSTRACT1,
			SCHEMA_ASSOC_ABSTRACT2,
			SCHEMA_ASSOC_1,
			SCHEMA_ASSOC_2,
			SCHEMA_ASSOC_3,
			SCHEMA_14,
			SCHEMA_15
		};

// This class is a helper class that can be used to help access schema info
// from MFC projects.  It uses WMI interfaces to query the schema of a given
// namespace, and caches class information for easy access.
class WBEMUTILS_POLARITY CSchemaInfo
{
public:
	class CClassInfo
	{
	public:
		CClassInfo() {m_pObject = NULL;m_bAbstract = FALSE;m_bAssoc = FALSE;m_bSomeConcreteChild = FALSE;}
		IWbemClassObject *m_pObject;
		CString m_szClass;
		CString m_szSuper;
		BOOL m_bAbstract;
		BOOL m_bAssoc;
		BOOL m_bSomeConcreteChild;
		CStringArray m_rgszSubs;
		CStringArray m_rgszRealSubs;
		CStringArray m_rgszRealAssocsAssoc;
		CStringArray m_rgszRealAssocsEndpoint;

		int GetImage()
		{
			int nImage;
			if (m_bAssoc)
			{
				nImage = SCHEMA_ASSOC;
				if(m_bAbstract)
					nImage = m_bSomeConcreteChild?SCHEMA_ASSOC_ABSTRACT1:SCHEMA_ASSOC_ABSTRACT2;
			}
			else
			{
				nImage = SCHEMA_CLASS;
				if(m_bAbstract)
					nImage = m_bSomeConcreteChild?SCHEMA_CLASS_ABSTRACT1:SCHEMA_CLASS_ABSTRACT2;
			}
			return nImage;
		}

	protected:
		enum SCHEMA_ICONS {
			SCHEMA_CLASS = 0,
			SCHEMA_CLASS_ABSTRACT1,
			SCHEMA_CLASS_ABSTRACT2,
			SCHEMA_CLASS_1,
			SCHEMA_4,
			SCHEMA_5,
			SCHEMA_6,
			SCHEMA_7,
			SCHEMA_ASSOC,
			SCHEMA_ASSOC_ABSTRACT1,
			SCHEMA_ASSOC_ABSTRACT2,
			SCHEMA_ASSOC_1,
			SCHEMA_ASSOC_2,
			SCHEMA_ASSOC_3,
			SCHEMA_14,
			SCHEMA_15
		};

	};

protected:
	union _tagMapHelp
	{
		LPVOID pTemp;
		CClassInfo *pClass;
	};


public:
	CSchemaInfo()
	{
	}
	~CSchemaInfo()
	{
		CleanUp();
	}
	void CleanUp()
	{
		POSITION pos = m_mapNameToClass.GetStartPosition();
		while(pos)
		{
			_tagMapHelp u;
			CString szClass;
			m_mapNameToClass.GetNextAssoc(pos, szClass, u.pTemp);
			delete u.pClass;
		}
		m_mapNameToClass.RemoveAll();
	}
	static BOOL CreateImageList(CImageList *pImageList)
	{
#define IDB_SYMBOLS                     136
		return pImageList->Attach(ImageList_LoadBitmap(GetModuleHandle(_T("WBEMUtils.dll")),MAKEINTRESOURCE(IDB_SYMBOLS), 16, 16, RGB(0,128,128)));
//		return pImageList->Create(MAKEINTRESOURCE(IDB_SYMBOLS), 16, 16, RGB(0,0,0));
	}

	CClassInfo &operator [](LPCTSTR szClass)
	{
		_tagMapHelp u;
		if(!m_mapNameToClass.Lookup(szClass, u.pTemp))
		{
			u.pClass = new CClassInfo;
			m_mapNameToClass[szClass] = u.pClass;
		}
		return *u.pClass;
	}
	POSITION GetStartPosition()
	{
		return m_mapNameToClass.GetStartPosition();
	}
	CClassInfo &GetNextAssoc(POSITION& rNextPosition, CString& rKey)
	{
		_tagMapHelp u;
		m_mapNameToClass.GetNextAssoc(rNextPosition, rKey, u.pTemp);
		return *u.pClass;
	}
	BOOL IsSuper(LPCTSTR szSuper, LPCTSTR szClass)
	{
		CString szClassT(szClass);
		while(szClassT.GetLength())
		{
			if(szClassT == szSuper)
				return TRUE;
			szClassT = (*this)[szClassT].m_szSuper;
		}
		return FALSE;
	}


	// Initialize an instance of this class.  rgpClasses is an array of
	// IWbemClassObject pointers that represents all the classes in a
	// namespace
	void Init(const CPtrArray &rgpClasses);
	void Update(const CPtrArray &rgpClasses);
	void Delete(LPCTSTR szClass);
	CClassInfo &AddClass(IWbemClassObject *pClass);


protected:
	CMapStringToPtr m_mapNameToClass;
	void DeleteFromMap(LPCTSTR szClass);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B25E3D37_A79A_11D0_961C_00C04FD9B15B__INCLUDED_)
#define AFX_STDAFX_H__B25E3D37_A79A_11D0_961C_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <wbemcli.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B25E3D37_A79A_11D0_961C_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//	MsgDlg.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MsgDlg.rc
//
#define IDD_DIALOG1                     129
#define IDI_ICONINFORM                  130
#define IDD_DIALOG2                     130
#define IDI_ICONEPOINT                  131
#define IDI_ICONSTOP                    132
#define IDD_DIALOG3                     133
#define IDB_SYMBOLS                     136
#define IDS_UNKN_ERROR_STR_FMT          464
#define IDS_UNKN_ERROR_CODE_FMT         465
#define IDS_CANT_GET_FM_ERROR_OBJ       466
#define IDS_MSGDLG_ERROR_CAPTION        467
#define IDS_GENERIC_XPORT_ERROR         468
#define IDC_BUTTONADVANCED              1000
#define IDC_STATICCLIENTMSG             1001
#define IDC_STATICPROVIDERNAME          1002
#define IDC_STATICOPERATION             1003
#define IDC_STATICPARAMETER             1004
#define IDC_STATICFRAME                 1005
#define IDC_STATICHMOMMSG               1006
#define IDC_CODEPLUSMESSAGE             1007
#define IDC_SINGLEVIEWCTRL1             1008
#define IDC_MYICON                      1009
#define IDC_EDIT_CLIENTMSG              1010
#define IDC_PRIV_TEXT                   1011
#define IDC_PRIV_CHECK                  1012
#define IDC_MSG                         1019
#define IDS_ERR_VIEW_INSTALL_ACCESS_DENIED 5075
#define IDS_ERR_VIEW_INSTALL_DISK_FULL  5076
#define IDS_ERR_CUSTOM_VIEW_MISSING     5077
#define IDS_NO_HHCTRL                   5081
#define IDS_NO_HTMLHELP                 5082
#define IDS_NO_HTML_PAGE                5083
#define IDS_NO_SAVE_ERROR_OBJ           5084
#define IDS_ERROR_UNKN_ERROR_FMT        5085
#define IDS_ERROR_FMT                   5086
#define IDS_NO_PRIVS                    5087
#define IDS_ENABLE_THE_PRIVS            5088
#define IDS_CANT_ENABLE_PRIVS           5089
#define IDD_DOWNLOAD                    5211
#define IDC_PROGRESS                    5513

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        137
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\singleview.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "singleview.h"

/////////////////////////////////////////////////////////////////////////////
// CSingleView

IMPLEMENT_DYNCREATE(CSingleView, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CSingleView properties

CString CSingleView::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CSingleView::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

long CSingleView::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

long CSingleView::GetPropertyFilter()
{
	long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CSingleView::SetPropertyFilter(long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CSingleView operations

long CSingleView::GetEditMode()
{
	long result;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::SetEditMode(long lEditMode)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lEditMode);
}

long CSingleView::RefreshView()
{
	long result;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::NotifyWillShow()
{
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CSingleView::DeleteInstance()
{
	long result;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::ExternInstanceCreated(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

void CSingleView::ExternInstanceDeleted(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x9, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

long CSingleView::QueryCanCreateInstance()
{
	long result;
	InvokeHelper(0xa, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::QueryCanDeleteInstance()
{
	long result;
	InvokeHelper(0xb, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::QueryNeedsSave()
{
	long result;
	InvokeHelper(0xc, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::QueryObjectSelected()
{
	long result;
	InvokeHelper(0xd, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString CSingleView::GetObjectPath(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xe, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::StartViewEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xf, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

long CSingleView::GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp)
{
	long result;
	static BYTE parms[] =
		VTS_PBSTR VTS_PDISPATCH;
	InvokeHelper(0x10, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		pszTitle, lpPictureDisp);
	return result;
}

CString CSingleView::GetViewTitle(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x11, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::NextViewTitle(long lPositon, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x12, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPositon, pbstrTitle);
	return result;
}

long CSingleView::PrevViewTitle(long lPosition, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x13, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition, pbstrTitle);
	return result;
}

long CSingleView::SelectView(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x14, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::StartObjectEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x15, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

CString CSingleView::GetObjectTitle(long lPos)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x16, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPos);
	return result;
}

long CSingleView::SaveData()
{
	long result;
	InvokeHelper(0x17, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::AddContextRef(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x18, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleView::ReleaseContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x19, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleView::RestoreContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1a, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleView::GetContext(long* plCtxthandle)
{
	long result;
	static BYTE parms[] =
		VTS_PI4;
	InvokeHelper(0x1b, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		plCtxthandle);
	return result;
}

long CSingleView::NextObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1c, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::PrevObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1d, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::SelectObjectByPath(LPCTSTR szObjectPath)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x1e, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szObjectPath);
	return result;
}

long CSingleView::SelectObjectByPosition(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1f, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase)
{
	long result;
	static BYTE parms[] =
		VTS_UNKNOWN VTS_UNKNOWN VTS_I4;
	InvokeHelper(0x20, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lpunkWbemServices, lpunkClassObject, bExistsInDatabase);
	return result;
}

long CSingleView::CreateInstance(LPCTSTR szClassName)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x21, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szClassName);
	return result;
}

long CSingleView::CreateInstanceOfCurrentClass()
{
	long result;
	InvokeHelper(0x22, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\singleview.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SINGLEVIEW_H__0E705383_0307_11D2_8832_00104B2AFB46__INCLUDED_)
#define AFX_SINGLEVIEW_H__0E705383_0307_11D2_8832_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CSingleView wrapper class

class CSingleView : public CWnd
{
protected:
	DECLARE_DYNCREATE(CSingleView)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x2745e5f5, 0xd234, 0x11d0, { 0x84, 0x7a, 0x0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetReadyState();
	long GetPropertyFilter();
	void SetPropertyFilter(long);

// Operations
public:
	long GetEditMode();
	void SetEditMode(long lEditMode);
	long RefreshView();
	void NotifyWillShow();
	long DeleteInstance();
	void ExternInstanceCreated(LPCTSTR szObjectPath);
	void ExternInstanceDeleted(LPCTSTR szObjectPath);
	long QueryCanCreateInstance();
	long QueryCanDeleteInstance();
	long QueryNeedsSave();
	long QueryObjectSelected();
	CString GetObjectPath(long lPosition);
	long StartViewEnumeration(long lWhere);
	long GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp);
	CString GetViewTitle(long lPosition);
	long NextViewTitle(long lPositon, BSTR* pbstrTitle);
	long PrevViewTitle(long lPosition, BSTR* pbstrTitle);
	long SelectView(long lPosition);
	long StartObjectEnumeration(long lWhere);
	CString GetObjectTitle(long lPos);
	long SaveData();
	long AddContextRef(long lCtxtHandle);
	long ReleaseContext(long lCtxtHandle);
	long RestoreContext(long lCtxtHandle);
	long GetContext(long* plCtxthandle);
	long NextObject(long lPosition);
	long PrevObject(long lPosition);
	long SelectObjectByPath(LPCTSTR szObjectPath);
	long SelectObjectByPosition(long lPosition);
	long SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase);
	long CreateInstance(LPCTSTR szClassName);
	long CreateInstanceOfCurrentClass();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SINGLEVIEW_H__0E705383_0307_11D2_8832_00104B2AFB46__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\schemainfo.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include "SchemaInfo.h"

// Returns TRUE if the attribute exists, it is of type BOOL, and is set to TRUE
BOOL GetAttribBool(IWbemQualifierSet *pAttribSet, LPCWSTR szName)
{
	if(!pAttribSet)
		return FALSE;

	BOOL bReturn = FALSE;
	VARIANTARG var;
	VariantInit(&var);
	BSTR bstrTemp = SysAllocString(szName);

	HRESULT hr = pAttribSet->Get(bstrTemp, 0, &var, NULL);

	::SysFreeString(bstrTemp);

	if(SUCCEEDED(hr) && var.vt == VT_BOOL)
		bReturn = V_BOOL(&var);

	VariantClear(&var);
	return bReturn;
}

CString GetBSTRProperty(IWbemClassObject *pClass, LPCWSTR szProperty)
{
	CString szOut;
	VARIANTARG var;
	VariantInit(&var);
	long lType;
	long lFlavor;
	BSTR bstrTemp = SysAllocString(szProperty);

	HRESULT hr = pClass->Get(bstrTemp, 0, &var, &lType, &lFlavor);
	::SysFreeString(bstrTemp);

	if(SUCCEEDED(hr) && var.vt == VT_BSTR)
		szOut = var.bstrVal;

	VariantClear(&var);
	return szOut;
}


BOOL IsAbstract(IWbemQualifierSet *pAttribSet)
{
	return GetAttribBool(pAttribSet, L"Abstract");
}

BOOL IsAssoc(IWbemQualifierSet *pAttribSet)
{
	return GetAttribBool(pAttribSet, L"Association");
}

CString GetIWbemClass(IWbemClassObject *pClass)
{
	return GetBSTRProperty(pClass,L"__Class");
}

CString GetIWbemSuperClass(IWbemClassObject *pClass)
{
	return GetBSTRProperty(pClass,L"__SuperClass");
}


void CSchemaInfo::Init(const CPtrArray &rgpClasses)
{
	CleanUp();
	Update(rgpClasses);
}

void CSchemaInfo::Update(const CPtrArray &rgpClasses)
{
	for(int i=0;i<rgpClasses.GetSize();i++)
	{
		IWbemClassObject *pClass = (IWbemClassObject *)rgpClasses[i];
		AddClass(pClass);
	}
}

void CSchemaInfo::Delete(LPCTSTR szClass)
{
	DeleteFromMap(szClass);

	// Refresh remaining classes
	POSITION pos = GetStartPosition();
	while(pos)
	{
		CString szClass;
		CSchemaInfo::CClassInfo &info = GetNextAssoc(pos, szClass);
		info.m_rgszSubs.RemoveAll();
		info.m_bSomeConcreteChild = FALSE;
	}

	pos = GetStartPosition();
	while(pos)
	{
		CString szClass;
		CSchemaInfo::CClassInfo &info = GetNextAssoc(pos, szClass);
		(*this)[info.m_szSuper].m_rgszSubs.Add(info.m_szClass);
		if(!info.m_bAbstract)
		{
			CString szClassT(info.m_szSuper);
			while(szClassT.GetLength())
			{
				CClassInfo &infoT = (*this)[szClassT];
				if(infoT.m_bSomeConcreteChild)
					break;
				infoT.m_bSomeConcreteChild = TRUE;
				szClassT = infoT.m_szSuper;
			}
		}
	}
}

void CSchemaInfo::DeleteFromMap(LPCTSTR szClass)
{
	_tagMapHelp u;
	if(!m_mapNameToClass.Lookup(szClass, u.pTemp))
	{
		ASSERT(FALSE);
		return;
	}
	if(u.pClass->m_rgszSubs.GetSize())
	{
		for(int i=0;i<u.pClass->m_rgszSubs.GetSize();i++)
			DeleteFromMap(u.pClass->m_rgszSubs[i]);
	}
	delete u.pClass;
	m_mapNameToClass.RemoveKey(szClass);
}

CSchemaInfo::CClassInfo &CSchemaInfo::AddClass(IWbemClassObject *pClass)
{
	IWbemQualifierSet *pAttribSet = NULL;
	if(FAILED(pClass->GetQualifierSet(&pAttribSet)))
	{
		ASSERT(FALSE);
		// Nothing we can do - IsAbstract and IsAssoc will handle it
	}

	CString szClass = GetIWbemClass(pClass);
	CString szSuper = GetIWbemSuperClass(pClass);
	CClassInfo &info = (*this)[szClass];
	info.m_pObject = pClass;
	info.m_szClass = szClass;
	info.m_szSuper = szSuper;
	info.m_bAbstract = IsAbstract(pAttribSet);
	info.m_bAssoc = IsAssoc(pAttribSet);
	(*this)[szSuper].m_rgszSubs.Add(szClass);

	if(!info.m_bAbstract)
	{
		CString szClassT(szSuper);
		while(szClassT.GetLength())
		{
			CClassInfo &infoT = (*this)[szClassT];
			if(infoT.m_bSomeConcreteChild)
				break;
			infoT.m_bSomeConcreteChild = TRUE;
			szClassT = infoT.m_szSuper;
		}
	}

	if(pAttribSet)
		pAttribSet->Release();

	return info;
}




// OLD STUFF FROM ClassNavCtl.cpp
#if 0
	CStringArray rgszRealClasses;
	CStringArray rgszRealAssocs;
	CStringArray rgszRealAssocsLeft;
	CStringArray rgszRealAssocsRight;


	POSITION pos = schema.GetStartPosition();
	while(pos)
	{
		CString szClass;
		CSchemaInfo::CClassInfo &info = schema.GetNextAssoc(pos, szClass);
		if(info.m_szClass.GetLength() == 0)
			continue;
		if(!info.m_bAbstract)
		{
			if(info.m_bAssoc)
			{
				rgszRealAssocs.Add(szClass);
				CString szLeft, szRight;
				GetAssocLeftRight(info.m_pObject, szLeft, szRight);
				rgszRealAssocsLeft.Add(szLeft);
				rgszRealAssocsRight.Add(szRight);
			}
			else
			{
				rgszRealClasses.Add(szClass);
				CString szClassT(szClass);
				while(szClassT.GetLength())
				{
					schema[szClassT].m_rgszRealSubs.Add(szClass);
					szClassT = schema[szClassT].m_szSuper;
				}
			}
		}
	}



	HTREEITEM hLRA = m_ctcTree.InsertItem(_T("Classes that can participate in Associations"), SCHEMA_ASSOC, SCHEMA_ASSOC);
	HTREEITEM hALR = m_ctcTree.InsertItem(_T("Associations classes"), SCHEMA_ASSOC, SCHEMA_ASSOC);

	HTREEITEM hLegend = m_ctcTree.InsertItem(_T("Legend"), SCHEMA_15, SCHEMA_15);

	m_ctcTree.InsertItem(_T("Abstract Class with only Abstract children"), SCHEMA_CLASS_ABSTRACT2, SCHEMA_CLASS_ABSTRACT2, hLegend);
	m_ctcTree.InsertItem(_T("Abstract Class with at leat one child not Abstract"), SCHEMA_CLASS_ABSTRACT1, SCHEMA_CLASS_ABSTRACT1, hLegend);
	m_ctcTree.InsertItem(_T("Class"), SCHEMA_CLASS, SCHEMA_CLASS, hLegend);
	m_ctcTree.InsertItem(_T("Abstract Association Class with only Abstract children"), SCHEMA_ASSOC_ABSTRACT2, SCHEMA_ASSOC_ABSTRACT2, hLegend);
	m_ctcTree.InsertItem(_T("Abstract Associaton Class with at leat one Non-Abstract child"), SCHEMA_ASSOC_ABSTRACT1, SCHEMA_ASSOC_ABSTRACT1, hLegend);
	m_ctcTree.InsertItem(_T("Associaton Class"), SCHEMA_ASSOC, SCHEMA_ASSOC, hLegend);
	HTREEITEM hLegend2 = m_ctcTree.InsertItem(_T("Specialized Icons"), SCHEMA_15, SCHEMA_15, hLegend);
	HTREEITEM hLegend3 = m_ctcTree.InsertItem(_T("Debug Info"), SCHEMA_15, SCHEMA_15, hLegend);
	m_ctcTree.InsertItem(_T("Association Class with one side the same or superclass of other"), SCHEMA_ASSOC_2, SCHEMA_ASSOC_2, hLegend2);
	m_ctcTree.InsertItem(_T("Association Class whoes relationship is more than 1 to 1"), SCHEMA_ASSOC_1, SCHEMA_ASSOC_1, hLegend2);
	m_ctcTree.InsertItem(_T("Endpoint Class with multiple possible Association paths"), SCHEMA_CLASS_1, SCHEMA_CLASS_1, hLegend2);

	DWORD dw4 = GetTickCount();
	for(i=0;i<rgszRealAssocs.GetSize();i++)
	{
		CString szAssoc = rgszRealAssocs[i];
		CString szLeft = rgszRealAssocsLeft[i];
		CString szRight = rgszRealAssocsRight[i];
		HTREEITEM hAssoc = m_ctcTree.AddTreeObject2(hALR, schema[szAssoc], TRUE);

		PopulateTree(hAssoc, szLeft, schema, TRUE);
		PopulateTree(hAssoc, szRight, schema, TRUE);
//		m_ctcTree.Expand(hAssoc, TVE_EXPAND);

		CSchemaInfo::CClassInfo &infoLeft = schema[szLeft];
		CSchemaInfo::CClassInfo &infoRight = schema[szRight];

		int nNonAbstractOnLeft = infoLeft.m_rgszRealSubs.GetSize();
		int nNonAbstractOnRight = infoRight.m_rgszRealSubs.GetSize();
		BOOL bMany = (1 != nNonAbstractOnLeft || 1 != nNonAbstractOnRight);
		if(bMany)
		{
			CString sz;
			sz.Format(_T("%s  (%i <==> %i)"), (LPCTSTR)szAssoc, nNonAbstractOnLeft, nNonAbstractOnRight);
			m_ctcTree.SetItemText(hAssoc, sz);
			m_ctcTree.SetItemImage(hAssoc, SCHEMA_ASSOC_1, SCHEMA_ASSOC_1);
		}
		if(schema.IsSuper(szLeft, szRight) || schema.IsSuper(szRight, szLeft))
			m_ctcTree.SetItemImage(hAssoc, SCHEMA_ASSOC_2, SCHEMA_ASSOC_2);
//			m_ctcTree.SetItemImage(hAssoc, bMany?12:SCHEMA_ASSOC_2, bMany?12:SCHEMA_ASSOC_2);

		int j;
		for(j=0;j<infoLeft.m_rgszRealSubs.GetSize();j++)
		{
			for(int k=0;k<infoRight.m_rgszRealSubs.GetSize();k++)
			{
				schema[infoLeft.m_rgszRealSubs[j]].m_rgszRealAssocsAssoc.Add(szAssoc);
				schema[infoLeft.m_rgszRealSubs[j]].m_rgszRealAssocsEndpoint.Add(infoRight.m_rgszRealSubs[k]);
			}
		}
		for(j=0;j<infoRight.m_rgszRealSubs.GetSize();j++)
		{
			for(int k=0;k<infoLeft.m_rgszRealSubs.GetSize();k++)
			{
				schema[infoRight.m_rgszRealSubs[j]].m_rgszRealAssocsAssoc.Add(szAssoc);
				schema[infoRight.m_rgszRealSubs[j]].m_rgszRealAssocsEndpoint.Add(infoLeft.m_rgszRealSubs[k]);
			}
		}
	}
	DWORD dw5 = GetTickCount();
	for(i=0;i<rgszRealClasses.GetSize();i++)
	{
		CSchemaInfo::CClassInfo &info = schema[rgszRealClasses[i]];
		if(info.m_rgszRealAssocsAssoc.GetSize()==0)
			continue;
		HTREEITEM hClass = m_ctcTree.AddTreeObject2(hLRA, info, TRUE);
		HTREEITEM hAssocs = m_ctcTree.InsertItem(_T("Possible Association Class Instances"), SCHEMA_ASSOC, SCHEMA_ASSOC, hClass);
		HTREEITEM hEndpoints = m_ctcTree.InsertItem(_T("Possible Association Endpoint Instances"), SCHEMA_ASSOC, SCHEMA_ASSOC, hClass);
		CString szAssoc;
		CString szEndpoint;
		union
		{
			CMapStringToPtr *pMap;
			LPVOID pTemp;
		} u;
		LPVOID pTemp2;
		CMapStringToPtr mapAssocs(50);
		CMapStringToPtr mapEndpoints(50);

		for(int j=0;j<info.m_rgszRealAssocsAssoc.GetSize();j++)
		{
			szAssoc = info.m_rgszRealAssocsAssoc[j];
			szEndpoint = info.m_rgszRealAssocsEndpoint[j];

			if(!mapAssocs.Lookup(szAssoc, u.pTemp))
				mapAssocs[szAssoc] = u.pMap = new CMapStringToPtr;

			(*u.pMap)[szEndpoint] = NULL;

			if(!mapEndpoints.Lookup(szEndpoint, u.pTemp))
				mapEndpoints[szEndpoint] = u.pMap = new CMapStringToPtr;

			// What should we do about duplicated paths?
			(*u.pMap)[szAssoc] = NULL;
		}
		POSITION pos1 = mapAssocs.GetStartPosition();
		while(pos1)
		{
			mapAssocs.GetNextAssoc(pos1, szAssoc, u.pTemp);
			HTREEITEM hAssoc = m_ctcTree.AddTreeObject2(hAssocs, schema[szAssoc], TRUE);
			POSITION pos2 = u.pMap->GetStartPosition();
			while(pos2)
			{
				u.pMap->GetNextAssoc(pos2, szEndpoint, pTemp2);
				m_ctcTree.AddTreeObject2(hAssoc, schema[szEndpoint], FALSE);
			}
			delete u.pMap;
		}
		pos1 = mapEndpoints.GetStartPosition();
		while(pos1)
		{
			mapEndpoints.GetNextAssoc(pos1, szEndpoint, u.pTemp);
			HTREEITEM hEndpoint = m_ctcTree.AddTreeObject2(hEndpoints, schema[szEndpoint], TRUE);
			if(u.pMap->GetCount() > 1)
				m_ctcTree.SetItemImage(hEndpoint, SCHEMA_CLASS_1, SCHEMA_CLASS_1);

			POSITION pos2 = u.pMap->GetStartPosition();
			while(pos2)
			{
				u.pMap->GetNextAssoc(pos2, szAssoc, pTemp2);
				m_ctcTree.AddTreeObject2(hEndpoint, schema[szAssoc], FALSE);
			}
			delete u.pMap;
		}

		m_ctcTree.SortChildren(hAssocs);
		m_ctcTree.Expand(hAssocs, TVE_EXPAND);
		m_ctcTree.SortChildren(hEndpoints);
		m_ctcTree.Expand(hEndpoints, TVE_EXPAND);
	}
	DWORD dw6 = GetTickCount();
	DWORD dwTotal1 = dw2-dw1;;
	DWORD dwTotal2 = dw3-dw2;;
	DWORD dwTotal3 = dw4-dw3;;
	DWORD dwTotal4 = dw5-dw4;;
	DWORD dwTotal5 = dw6-dw5;;
	DWORD dwTotal = dw6 - dw1;
	CString sz;
	sz.Format(_T("Total = %i.%03i (%i.%03i, %i.%03i, %i.%03i, %i.%03i, %i.%03i)"), dwTotal/1000, dwTotal%1000, dwTotal1/1000, dwTotal1%1000, dwTotal2/1000, dwTotal2%1000, dwTotal3/1000, dwTotal3%1000, dwTotal4/1000, dwTotal4%1000, dwTotal5/1000, dwTotal5%1000);
	m_ctcTree.InsertItem(sz, SCHEMA_15, SCHEMA_15, hLegend3);


	m_ctcTree.SortChildren(hALR);
	m_ctcTree.SortChildren(hLRA);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\wbemerror.h ===
#ifndef __WBEMERROR__

#define __WBEMERROR__

//=============================================================================

//

//                              WbemError.h

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//	Implements string table based, error msgs for all of wbem.
//
//  History:
//
//      a-khint  5-mar-98       Created.
//
//============================================================================= 

//---------------------------------------------------------
// ErrorString: Extracts convenient information out of the
//				HRESULT. If its not a wbem error,
//				system error msgs will be checked.
// Parms:
//		hr - The error code from any facility.
//		errMsg - pointer to an allocated string buffer for
//					the error msg. Can be NULL.
//		errSize - the size of errMsg in chars.
//
//		sevIcon - ptr to receive the appropriate MB_ICON*
//					value for the hr. Can be NULL. Value
//					should be OR'ed with the MessageBox()
//					uType.
//
// Returns:
//		Nothing.
//---------------------------------------------------------
void ErrorStringEx(HRESULT hr, 
				   WCHAR *errMsg, UINT errSize,
				   UINT *sevIcon);



#endif __WBEMERROR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\wbemregistry.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "WbemRegistry.h"

typedef struct
{
	LPTSTR key;
	LPTSTR value;
} REGMAP;

REGMAP RegMap[] =
{
	{_T("SOFTWARE\\Microsoft\\WBEM"),
				_T("Application Directory")},
	{_T("SOFTWARE\\Microsoft\\WBEM\\CIMOM"),
				_T("Working Directory")},
	{_T("SOFTWARE\\Microsoft\\WBEM"),
				_T("SDK Directory")},
	{_T("SOFTWARE\\Microsoft\\WBEM"),
				_T("SDK Help")}
};

//---------------------------------------------------------
WBEMUTILS_POLARITY long WbemRegString(RegString req, CString &sStr)
{
	long lResult;
	ULONG lcbValue = 1024;
	LPTSTR pszWorkingDir = sStr.GetBuffer(lcbValue);

	if((lResult = WbemRegString(req, pszWorkingDir, &lcbValue)) != ERROR_SUCCESS)
	{
//		sStr.Empty();
		lstrcpy(pszWorkingDir, _T("wmisdk.chm"));
	}

	sStr.ReleaseBuffer();
	return lResult;
}

//---------------------------------------------------------
WBEMUTILS_POLARITY long WbemRegString(RegString req,
        					 LPTSTR sStr, ULONG *strSize)
{
	HKEY hkeyLocalMachine;
	long lResult;

	lResult = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE,
									&hkeyLocalMachine);
	if (lResult != ERROR_SUCCESS)
	{
		return lResult;
	}

	HKEY hkeyHmomCwd;

	lResult = RegOpenKeyEx(hkeyLocalMachine,
							RegMap[req].key,
							0,
							KEY_READ | KEY_QUERY_VALUE,
							&hkeyHmomCwd);

	if (lResult != ERROR_SUCCESS)
	{
		RegCloseKey(hkeyLocalMachine);
		return lResult;
	}

	unsigned long lType;

	lResult = RegQueryValueEx(hkeyHmomCwd,
								RegMap[req].value,
								NULL,
								&lType,
								(unsigned char*) (void*) sStr,
								strSize);


	RegCloseKey(hkeyHmomCwd);
	RegCloseKey(hkeyLocalMachine);

	return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\wbemerror.cpp ===
//=============================================================================

//

//                              WbemError.cpp

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//	Helper routine for core's error features.
//
//  History:
//
//      a-khint  5-mar-98       Created.
//      a-khint  14-sep-98      hooked into core's error routines.
//
//=============================================================================
#include "precomp.h"
#include "WbemError.h"
#include "resource.h"
#include <wbemcli.h>

//-------------------------------------------------
#define TEMP_BUF 512

void ErrorStringEx(HRESULT hr,
				   WCHAR *errMsg, UINT errSize,
				   UINT *sevIcon)
{
    WCHAR szError[TEMP_BUF];
	WCHAR szFacility[TEMP_BUF];
    WCHAR szFormat[100];
	IWbemStatusCodeText * pStatus = NULL;

    // initialize buffers.
	errMsg[0] = 0;
	szFacility[0] = 0;
	szError[0] = 0;

	HRESULT hr1 = CoInitialize(NULL);
	SCODE sc = CoCreateInstance(CLSID_WbemStatusCodeText,
								0, CLSCTX_INPROC_SERVER,
								IID_IWbemStatusCodeText,
								(LPVOID *) &pStatus);

	// loaded OK?
	if(sc == S_OK)
	{
		BSTR bstr = 0;
		sc = pStatus->GetErrorCodeText(hr, 0, 0, &bstr);
		if(sc == S_OK)
		{
			_tcsncpy(szError, bstr, TEMP_BUF-1);
			SysFreeString(bstr);
			bstr = 0;
		}

		sc = pStatus->GetFacilityCodeText(hr, 0, 0, &bstr);
		if(sc == S_OK)
		{
			_tcsncpy(szFacility, bstr, TEMP_BUF-1);
			SysFreeString(bstr);
			bstr = 0;
		}

		// RELEASE
		pStatus->Release();
		pStatus = NULL;


	}
	else
	{
		::MessageBox(NULL, _T("WMI error features not available. Upgrade WMI to a newer build."),
					 _T("Internal Error"), MB_ICONSTOP|MB_OK);
	}

	// if not msgs returned....
	if(wcslen(szFacility) == 0 || wcslen(szError) == 0)
	{
		// format the error nbr as a reasonable default.
		LoadString(GetModuleHandle(_T("WBEMUtils.dll")), IDS_ERROR_UNKN_ERROR_FMT, szFormat, 99);
		_stprintf(errMsg, szFormat, hr);
	}
	else
	{
		// format a readable msg.
		LoadString(GetModuleHandle(_T("WBEMUtils.dll")), IDS_ERROR_FMT, szFormat, 99);
		_stprintf(errMsg, szFormat, szFacility, szError);
	}

	// want an icon recommendation with that?
	if(sevIcon)
	{
		switch(SCODE_SEVERITY(hr))
		{
		case 0: // - Success
			*sevIcon = MB_ICONINFORMATION;
			break;
		case 1: //- Failed
			*sevIcon = MB_ICONEXCLAMATION;
			break;
		} //endswitch severity

	} //endif sevIcon

	if(hr1 == S_OK)
		CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\usermsgdlg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// UserMsgDlg.cpp : implementation file

#include "precomp.h"
#include <nddeapi.h>
#include <initguid.h>
#include "wbemidl.h"
#include "MsgDlg.h"
#include "singleview.h"
#include "dlgsingleview.h"
#include "EmbededObjDlg.h"
#include "UserMsgDlg.h"
#include "WbemError.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define CALL_TIMEOUT 5000

/////////////////////////////////////////////////////////////////////////////
// CUserMsgDlg dialog

const int nPhantomButtons = 56;
const int nPhantomWidth = 25;

//-------------------------------------------------------
CUserMsgDlg::CUserMsgDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CUserMsgDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CUserMsgDlg)
	//}}AFX_DATA_INIT
}

//-------------------------------------------------------
CUserMsgDlg::CUserMsgDlg(CWnd* pParent, BSTR bstrDlgCaption,
						BSTR bstrClientMsg,
						HRESULT sc,
						IWbemClassObject *pErrorObject,
						UINT uType /* = 0 */)
	: CDialog(CUserMsgDlg::IDD, pParent)
{
	m_csDlgCaption = bstrDlgCaption;
	m_csClientMsg = bstrClientMsg;
	m_initiallyDrawn = false;
	m_uType = uType;
	m_sc = sc;
	m_pErrorObject = pErrorObject;

	if(m_pErrorObject)
	{
		GetErrorObjectText(pErrorObject, m_csDescription, 0);
		GetErrorObjectText(pErrorObject, m_csProviderName, 1);
		GetErrorObjectText(pErrorObject, m_csOperation, 2);
		GetErrorObjectText(pErrorObject, m_csParameterInfo, 3);
	}

	m_bError = FALSE;
	m_bTall = FALSE;
	m_bInit = FALSE;
	m_pAdvanced = NULL;
}

//-------------------------------------------------------
void CUserMsgDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CUserMsgDlg)
	DDX_Control(pDX, IDC_EDIT_CLIENTMSG, m_editClientMsg);
	DDX_Control(pDX, IDC_STATICHMOMMSG, m_errorMsg);
	DDX_Control(pDX, IDC_MYICON, m_icon);
	DDX_Control(pDX, IDOK, m_ok);
	DDX_Control(pDX, IDC_BUTTONADVANCED, m_cbAdvanced);
	//}}AFX_DATA_MAP
}

//-------------------------------------------------------
BEGIN_MESSAGE_MAP(CUserMsgDlg, CDialog)
	//{{AFX_MSG_MAP(CUserMsgDlg)
	ON_BN_CLICKED(IDC_BUTTONADVANCED, OnButtonadvanced)
	ON_WM_DESTROY()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////
// CUserMsgDlg message handlers

void CUserMsgDlg::OnButtonadvanced()
{
	if (m_pAdvanced)
	{
		m_pAdvanced->m_csvControl.m_pErrorObject = m_pErrorObject;
		m_pAdvanced->DoModal();
	}
}

//-------------------------------------------------------
BOOL CUserMsgDlg::GetErrorObjectText(IWbemClassObject *pcoError,
									 CString &rcsText, int nText)
{
	if(!pcoError)
	{
		rcsText.Empty();
		return FALSE;
	}

	CString csProp;

	if(nText == 0)
	{
		csProp = _T("Description");
	}
	else if(nText == 1)
	{
		csProp = _T("ProviderName");
	}
	else if(nText == 2)
	{
		csProp = _T("Operation");
	}
	else if(nText == 3)
	{
		csProp = _T("ParameterInfo");
	}

	CString csText = GetBSTRProperty(pcoError, &csProp);

	if(csText.IsEmpty() || csText.GetLength() == 0)
	{
		rcsText.Empty();
		return FALSE;
	}
	else
	{
		rcsText = csText;
		return TRUE;
	}
}

//-------------------------------------------------------
CString CUserMsgDlg::GetIWbemFullPath(IWbemClassObject *pClass)
{
	CString csProp = _T("__Path");
	return GetBSTRProperty(pClass,&csProp);
}

//-------------------------------------------------------
CString CUserMsgDlg::GetBSTRProperty(IWbemClassObject *pInst,
									 CString *pcsProperty)
{
	SCODE sc;
	CString csOut;

    VARIANT var;
	VariantInit(&var);
	long lsType;
	long lFlavor;

	BSTR bstrTemp = pcsProperty->AllocSysString();
    sc = pInst->Get(bstrTemp, 0, &var, &lsType, &lFlavor);
	::SysFreeString(bstrTemp);

	if(sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg.Format(IDS_CANT_GET_FM_ERROR_OBJ, *pcsProperty);

		ErrorMsg(&csUserMsg, TRUE,
				 &csUserMsg, __FILE__, __LINE__ - 10);
		return csOut;
	}

	if(var.vt == VT_BSTR)
		csOut = var.bstrVal;

	VariantClear(&var);
	return csOut;
}

//-------------------------------------------------------
long CUserMsgDlg::GetLongProperty(IWbemClassObject *pInst,
								  CString *pcsProperty)
{
	SCODE sc;
	long lOut;

    VARIANT var;
	VariantInit(&var);
	long lsType;
	long lFlavor;

	BSTR bstrTemp = pcsProperty->AllocSysString();
    sc = pInst->Get(bstrTemp,
					0, &var, &lsType, &lFlavor);
	::SysFreeString(bstrTemp);

	if(sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg.Format(IDS_CANT_GET_FM_ERROR_OBJ, *pcsProperty);

        ErrorMsg(&csUserMsg, TRUE, &csUserMsg, __FILE__, __LINE__ - 10);
		return 0;
	}

	if(var.vt == VT_I4)
		lOut = var.lVal;

	VariantClear(&var);
	return lOut;
}

//-------------------------------------------------------
void CUserMsgDlg::ErrorMsg(CString *pcsUserMsg,
						   BOOL bLog,
						   CString *pcsLogMsg,
						   char *szFile,
						   int nLine)
{

    CString caption;
    caption.LoadString(IDS_MSGDLG_ERROR_CAPTION);

	MessageBox((LPCTSTR)*pcsUserMsg, caption,
				MB_OK |	MB_ICONEXCLAMATION | MB_DEFBUTTON1 |
				MB_APPLMODAL);

	if(bLog)
	{
		LogMsg(pcsLogMsg, szFile, nLine);
	}
	m_bError = TRUE;
}

//-------------------------------------------------------
void CUserMsgDlg::LogMsg(CString *pcsLogMsg,
						 char *szFile,
						 int nLine)
{
}

//-------------------------------------------------------
BOOL CUserMsgDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	m_bInit = TRUE;

	if(!m_csDlgCaption.IsEmpty() &&
		m_csDlgCaption.GetLength() > 0)
	{
		SetWindowText(m_csDlgCaption);
	}

	CString csMessage;

	if((!m_csClientMsg.IsEmpty() &&
		 m_csClientMsg.GetLength() > 0) ||
	   (m_sc == WBEM_E_TRANSPORT_FAILURE ||
		m_sc == 0x800706ba))
	{
		if(m_sc == WBEM_E_TRANSPORT_FAILURE ||
			m_sc == 0x800706ba)
		{
			csMessage.LoadString(IDS_GENERIC_XPORT_ERROR);
        	m_csClientMsg += csMessage;
		}
	}

	// see if access denied is due to privileges.
	if(m_sc == WBEM_E_PRIVILEGE_NOT_HELD)
	{
		// now way can you do this action.
		csMessage.LoadString(IDS_NO_PRIVS);
      	m_csClientMsg += csMessage;

	} //endif WBEM_E_PRIVILEGE_NOT_HELD

	if(!m_pErrorObject)
	{
		m_cbAdvanced.SetWindowText(L"");
		m_cbAdvanced.ShowWindow(SW_HIDE);
	}
	else
	{
		m_pAdvanced = new CEmbededObjDlg(this);
	}


	m_editClientMsg.SetWindowText(m_csClientMsg);

	long msgLines = (csMessage.GetLength() / 45) + 2;

	if(m_pErrorObject && !m_csDescription.IsEmpty())
	{
		m_errorMsg.SetWindowText(m_csDescription);
	}
	else
	{
		// dont put up success msgs per Judy/Larry assumption.
		if(m_sc != S_OK)
		{
			TCHAR szBuffer[512];
			memset(szBuffer, 0, 512);

			// READ: if m_uType is zero, ask ErrorStringEx() for an icon,
			//  otherwise use what the client passed in.
			ErrorStringEx(m_sc, szBuffer, 32, (m_uType == 0 ? &m_uType : NULL));

			m_errorMsg.SetWindowText(szBuffer);
		}

		// load the OEM icon.
		switch(m_uType)
		{
		case 0:
			ASSERT(FALSE); // no valid icon available.
			break;

		case MB_ICONINFORMATION:
			m_icon.SetIcon(LoadIcon(NULL, MAKEINTRESOURCE(IDI_INFORMATION)));
			break;

		case MB_ICONEXCLAMATION:
			m_icon.SetIcon(LoadIcon(NULL, MAKEINTRESOURCE(IDI_EXCLAMATION)));
			break;

		case MB_ICONSTOP:
			m_icon.SetIcon(LoadIcon(NULL, MAKEINTRESOURCE(IDI_HAND)));
			break;

		} //endswitch severity
	}

	//-----------------------------------------
	// save the original position for later resizing.

	CRect rcBounds, rect;

	// get the bounds.
	GetClientRect(&rcBounds);
	m_editClientMsg.GetWindowRect(&rect);
	ScreenToClient(&rect);

	// NOTE: rcBounds is the dlg; rect is the client msg.

	// top of dlg to top of list.
	m_listTop = rect.top - rcBounds.top;

	// bottom of dlg to bottom of list.
	m_listBottom = rcBounds.Height() - rect.Height() - m_listTop;

	// get the close button.
	m_ok.GetWindowRect(&rect);
	ScreenToClient(&rect);

	// close btn right edge to dlg right edge.
	m_okLeft = rcBounds.Width() - rect.left;

	// btn top to dlg bottom.
	m_btnTop = rcBounds.Height() - rect.top;

	//-------------------------------------------
	// deal with help button
	m_cbAdvanced.GetWindowRect(&rect);
	ScreenToClient(&rect);

	// help btn right edge to dlg right edge.
	m_advLeft = rcBounds.Width() - rect.left;

	m_btnW = rect.Width();
	m_btnH = rect.Height();

	m_initiallyDrawn = true;

	if(msgLines > 2)
	{
		ClientToScreen(&rcBounds);
		rcBounds.bottom += msgLines * 14;
		MoveWindow(rcBounds);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//-------------------------------------------------------
void CUserMsgDlg::OnDestroy()
{
	if(m_pAdvanced)
	{
		delete m_pAdvanced;
		m_pAdvanced = NULL;
	}

	CDialog::OnDestroy();
}

//-------------------------------------------------------
void CUserMsgDlg::OnSize(UINT nType, int cx, int cy)
{
	CDialog::OnSize(nType, cx, cy);

	if(m_initiallyDrawn)
	{
		m_editClientMsg.MoveWindow(7, m_listTop,
								cx - 14, cy - m_listBottom - m_listTop);

		m_ok.MoveWindow(cx - m_okLeft, cy - m_btnTop,
						m_btnW, m_btnH);

		m_cbAdvanced.MoveWindow(cx - m_advLeft, cy - m_btnTop,
								m_btnW, m_btnH);

		m_ok.Invalidate();
		m_cbAdvanced.Invalidate();
		Invalidate();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\usermsgdlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_USERMSGDLG_H__B25E3D3F_A79A_11D0_961C_00C04FD9B15B__INCLUDED_)
#define AFX_USERMSGDLG_H__B25E3D3F_A79A_11D0_961C_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// UserMsgDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CUserMsgDlg dialog


class CEmbededObjDlg;

class CUserMsgDlg : public CDialog
{
// Construction
public:
	CUserMsgDlg(CWnd* pParent = NULL);   // standard constructor
	CUserMsgDlg(CWnd* pParent, BSTR bstrDlgCaption, 
				BSTR bstrClientMsg, 
				HRESULT sc, 
				IWbemClassObject *pErrorObject,
				UINT uType = 0);

	BOOL GetMsgDlgError(){return m_bError;}

// Dialog Data
	//{{AFX_DATA(CUserMsgDlg)
	enum { IDD = IDD_DIALOG1 };
	CEdit	m_editClientMsg;
	CStatic	m_errorMsg;
	CStatic	m_icon;
	CButton	m_ok;
	CButton	m_cbAdvanced;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CUserMsgDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CEmbededObjDlg *m_pAdvanced;
	BOOL m_bInit;
	BOOL m_bError;
	BOOL m_bTall;
	CStatic *m_pcsLine;
	CRect m_crShort;
	CRect m_crTall;
	CString m_csDlgCaption;
	CString m_csClientMsg;
	UINT m_uType;

	HRESULT m_sc;
	IWbemClassObject *m_pErrorObject;
	CString m_csDescription;
	CString m_csProviderName;
	CString m_csOperation;
	CString m_csParameterInfo;

	// resizing vars;
	UINT m_listTop;			// top of dlg to top of list.
	UINT m_listBottom;		// bottom of dlg to bottom of list.
	UINT m_okLeft;			// ok btn left edge to dlg right edge.
	UINT m_advLeft;		// adv btn left edge to dlg right edge.
	UINT m_btnTop;			// btn top to dlg bottom.
	UINT m_btnW;			// btn width
	UINT m_btnH;			// btn height
	bool m_initiallyDrawn;

	BOOL GetErrorObjectText(IWbemClassObject *pErrorObject, 
							CString &rcsText, 
							int nText = 0);

	CString GetIWbemFullPath(IWbemClassObject *pClass);

	CString GetBSTRProperty(IWbemClassObject * pInst, 
							CString *pcsProperty);

	long GetLongProperty(IWbemClassObject * pInst, 
							CString *pcsProperty);

	void ErrorMsg(CString *pcsUserMsg, 
					BOOL bLog, 
					CString *pcsLogMsg, 
					char *szFile, 
					int nLine);

	void LogMsg(CString *pcsLogMsg, 
				char *szFile, 
				int nLine);

	// Generated message map functions
	//{{AFX_MSG(CUserMsgDlg)
	afx_msg void OnButtonadvanced();
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_USERMSGDLG_H__B25E3D3F_A79A_11D0_961C_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\wbemregistry.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __WBEMREGISTRY__
#define __WBEMREGISTRY__
#pragma once
#include "DeclSpec.h"

// ---------------------------------------------------
// utilities to get wbem related registry values.
// ---------------------------------------------------
enum RegString 
{
	APP_DIR = 0,
	WORK_DIR = 1,
	SDK_DIR = 2,
	SDK_HELP = 3
};

WBEMUTILS_POLARITY long WbemRegString(RegString req,
		        			 CString &sStr);

WBEMUTILS_POLARITY long WbemRegString(RegString req,
				        	 LPTSTR sStr,
					        ULONG *strSize);

#endif __WBEMREGISTRY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\wbemresource.h ===
#ifndef __WBEMRESOURCE__

#define __WBEMRESOURCE__

//=============================================================================

//

//                              WbemResource.h

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//	Accesses common resources.
//
//  History:
//
//      a-khint  21-apr-98       Created.
//
//============================================================================= 
#include "DeclSpec.h"

//---------------------------------------------------------
// GetIcon: Returns the requested HICON.
// Parms:
//		resName - The name of the icon.
// Returns:
//  NULL if failed, otherwise HICON.
//
//---------------------------------------------------------

WBEMUTILS_POLARITY HICON WBEMGetIcon(LPCTSTR resName);

#endif __WBEMRESOURCE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\wbemresource.cpp ===
//=============================================================================

//

//                              WbemResource.cpp

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//	Accesses common resources.
//
//  History:
//
//      a-khint  21-apr-98       Created.
//
//=============================================================================
#include "precomp.h"
#include "WbemResource.h"

typedef enum
{
    LOCAL_RES,
    REMOTE_RES,
    FILEBASED,
    OEM_RES,
    DONTKNOW,
} ICON_PARSER;

// Syntax of resName:
//  "<path\res.dll>:<name>"
//      'name' from 'res.dll'
//  "<path\filename>.ico>"
///     icon file specified.
//  "<classname>"
//      icon resource from this dll.
//  "IDI_*"
//      OEM icon.       - See GetIcon()
//

ICON_PARSER IconParse(LPCTSTR resName,
                        LPTSTR name1,
                        LPTSTR name2)
{
    TCHAR ext[_MAX_EXT];
    _tsplitpath(resName, NULL, NULL, NULL, ext);

    int colonPos = 0;

    //  "<path\res.dll>:<name>"
#ifdef _UNICODE
    if((colonPos = _tcscspn(resName, _T(":"))) < (int)wcslen(resName))
#else
    if((colonPos = _tcscspn(resName, _T(":"))) < (int)strlen(resName))
#endif
    {
        _tcsncpy(name1, resName, colonPos - 1);
        _tcscpy(name2, &resName[colonPos+1]);
        return REMOTE_RES;
    }
    //  "<path\filename>.ico>"  look for the '.ico' extension
    else if(_tcsicmp(ext, _T(".ico")) == 0)
    {
        return FILEBASED;
    }
    //  "IDI_*"  OEM's start with IDI_
    else if(_tcsncmp(resName, _T("IDI_"), 4) == 0)
    {
        return OEM_RES;
    }
    //  "WIN32_*"  my class icons.
    else if(_tcsnicmp(resName, _T("WIN32_"), 6) == 0)
    {
        return LOCAL_RES;
    }

    return DONTKNOW;
}

//---------------------------------------------------------
// GetIcon: Returns the requested HICON.
// Parms:
//		resName - The name of the icon.
// Returns:
//      NULL if failed, otherwise HICON.
//
//---------------------------------------------------------
WBEMUTILS_POLARITY HICON WBEMGetIcon(LPCTSTR resName)
{
    TCHAR name1[512], name2[512];
    memset(name1, 0, 512);
    memset(name2, 0, 512);
    HICON icon = NULL;

    switch(IconParse(resName, name1, name2))
    {
    case LOCAL_RES:
        icon = LoadIcon(GetModuleHandle(_T("WBEMUtils.dll")),
                        resName);
		icon = (HICON) LoadImage(GetModuleHandle(_T("WBEMUtils.dll")),
									resName, IMAGE_ICON,
									0, 0, LR_SHARED);

        break;

    case REMOTE_RES:
        {
            HINSTANCE hInst = LoadLibraryEx(name1, NULL, LOAD_LIBRARY_AS_DATAFILE);
            if(hInst != NULL)
            {
				icon = (HICON) LoadImage(hInst, name2, IMAGE_ICON,
											0, 0, LR_SHARED);
                FreeLibrary(hInst);
                hInst = NULL;
            }
        }
        break;

    case FILEBASED:
        icon = ExtractIcon(GetModuleHandle(_T("WBEMUtils.dll")),
                            resName, 0);
        break;

    case OEM_RES:
        icon = LoadIcon(NULL, resName);
        break;

    }//endswitch

    return icon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\wbemversion.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __WBEMVERSION__
#define __WBEMVERSION__
#pragma once
#include "DeclSpec.h"

extern "C" {
// version resource helpers.
WBEMUTILS_POLARITY void GetDoubleVersion(HINSTANCE inst, LPTSTR str, UINT size);
WBEMUTILS_POLARITY void GetMyVersion(HINSTANCE inst, LPTSTR str, UINT size);
WBEMUTILS_POLARITY void GetCimomVersion(LPTSTR str, UINT size);

WBEMUTILS_POLARITY void GetStringFileInfo(LPCTSTR filename, LPCTSTR key, LPTSTR str, UINT size);

WBEMUTILS_POLARITY long GetCimomFileName(LPTSTR filename, UINT size);
WBEMUTILS_POLARITY void GetMyCompany(HINSTANCE inst, LPTSTR str, UINT size);

}
#endif __WBEMVERSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\asyncenumdialog.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// AsyncEnumDialog.cpp : implementation file
//

#include "precomp.h"
#include "multiview.h"
#include "AsyncEnumDialog.h"
#include <wbemidl.h>
#include "olemsclient.h"
#include "grid.h"
#include "MultiViewCtl.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CMultiViewApp NEAR theApp;


/////////////////////////////////////////////////////////////////////////////
// CAsyncEnumDialog dialog


CAsyncEnumDialog::CAsyncEnumDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CAsyncEnumDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAsyncEnumDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pParent = NULL;

}


void CAsyncEnumDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAsyncEnumDialog)
	DDX_Control(pDX, IDC_STATICMESSAGE, m_cstaticMessage);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAsyncEnumDialog, CDialog)
	//{{AFX_MSG_MAP(CAsyncEnumDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAsyncEnumDialog message handlers

void CAsyncEnumDialog::OnCancel()
{
	theApp.DoWaitCursor(1);
	/*if (m_pParent->m_pAsyncEnumSinkThread->m_hThread != NULL)
	{
		m_pParent->m_pAsyncEnumSinkThread->PostThreadMessage(ID_ASYNCENUM_CANCEL,0,0);
	}
	m_pParent->PostMessage(ID_ASYNCENUM_CANCEL,0,0);*/


	m_pParent->PostMessage(ID_ASYNCENUM_CANCEL,0,0);

	CDialog::EndDialog(IDCANCEL);
}

BOOL CAsyncEnumDialog::PreTranslateMessage(MSG* pMsg)
{
	// TODO: Add your specialized code here and/or call the base class
	if (pMsg->message == ID_ASYNCENUM_DONE)
	{
		EndDialog(IDOK);
		return TRUE;
	}

	return CDialog::PreTranslateMessage(pMsg);
}


BOOL CAsyncEnumDialog::OnInitDialog()
{
	CDialog::OnInitDialog();

	CString csMessage =
		_T("Retrieving instances for class ") + m_csClass + _T(".");

	m_cstaticMessage.SetWindowText(csMessage);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\msgdlg\wbemversion.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "WbemVersion.h"
#include "WbemRegistry.h"

//----------------------------------------------------------------------
WBEMUTILS_POLARITY long GetCimomFileName(LPTSTR filename, UINT size)
{
	long lResult = 0;
	ULONG fileSize = size;

	// working directory...
	lResult = WbemRegString(WORK_DIR, filename, &fileSize);

	// plus filename.
	TCHAR cimomName[] = _T("\\winmgmt.exe");

	if((SUCCEEDED(lResult)) &&
	   ((fileSize + sizeof(cimomName)) <= size))
	{
		_tcscat(filename, cimomName);
	}

	return lResult;
}

//----------------------------------------------------------------------
WBEMUTILS_POLARITY void GetDoubleVersion(HINSTANCE inst, LPTSTR str, UINT size)
{
	//    <myversion/cimomVer>
	GetMyVersion(inst, str, size);

	// append cimom's version.
	_tcscat(str, _T("\\"));
	TCHAR cimVer[30];
	memset(cimVer, 0, MAX_PATH);

	GetCimomVersion(cimVer, 30);

	_tcscat(str, cimVer);
}

//----------------------------------------------------------------------
WBEMUTILS_POLARITY void GetCimomVersion(LPTSTR str, UINT size)
{
	TCHAR filename[MAX_PATH];

	memset(filename, 0, MAX_PATH);

	//if the wbem key, etc is there...
	if(GetCimomFileName(filename, sizeof(filename)) == ERROR_SUCCESS)
	{
		GetStringFileInfo(filename, _T("FileVersion"), str, size);
		return;
	}
	_tcscat(str, _T("No WinMgmt"));
}

//----------------------------------------------------------------------
WBEMUTILS_POLARITY void GetMyVersion(HINSTANCE inst, LPTSTR str, UINT size)
{
	TCHAR filename[MAX_PATH];

	memset(filename, 0, MAX_PATH);

	GetModuleFileName(inst, filename, sizeof(filename));

	GetStringFileInfo(filename, _T("FileVersion"), str, size);
}

//----------------------------------------------------------------------
WBEMUTILS_POLARITY void GetMyCompany(HINSTANCE inst, LPTSTR str, UINT size)
{
	TCHAR filename[MAX_PATH];

	memset(filename, 0, MAX_PATH);

	GetModuleFileName(inst, filename, sizeof(filename));

	GetStringFileInfo(filename, _T("CompanyName"), str, size);
}

//----------------------------------------------------------------------
WBEMUTILS_POLARITY void GetStringFileInfo(LPCTSTR filename, LPCTSTR key, LPTSTR str, UINT size)
{

	DWORD infoSize = 0;
	UINT  valSize = 0;
	LPBYTE info = NULL;
	DWORD handle = 0;
	LPVOID verStr = NULL;
	DWORD *TransBlk = NULL;
	TCHAR blockStr[100];

	memset(blockStr, 0, 100);

	infoSize = GetFileVersionInfoSize((LPTSTR)filename, &handle);

	if(infoSize)
	{
		info = new BYTE[infoSize];

		if(GetFileVersionInfo((LPTSTR)filename, handle,
								infoSize, info))
		{
			// get the translation block.
			// NOTE: This assumes that the localizers REPLACE the english with
			// the 'other' language so there will only be ONE entry in the
			// translation table. If we ever do a single binary that supports
			// multiple languages, it's a whole nother ballgame folks.
			if(VerQueryValue(info, _T("\\VarFileInfo\\Translation"),
								(void **)&TransBlk, &valSize))
			{

			   _stprintf(blockStr, _T("\\StringFileInfo\\%04hX%04hX\\%s"),
						 LOWORD(*TransBlk),
						 HIWORD(*TransBlk),
						 key);

				if(VerQueryValue(info, (LPTSTR)blockStr,
									(void **)&verStr, &valSize))
				{
					if(size >= valSize)
					{
						_tcscat(str, (LPTSTR)verStr);
					}
					else
					{
						_tcscat(str, _T("Unknown"));
					}
				} //endif VerQueryValue()
			}

		} //endif GetFileVersionInfo()

		delete[] (LPBYTE)info;

	} // endif infoSize
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\asyncenumsyncuithread.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// AsyncEnumSinkThread.cpp : implementation file
//

#include "precomp.h"
#include "multiview.h"
#include "AsyncEnumSyncUIThread.h"
#include "AsyncEnumDialog.h"
#include <hmmsvc.h>
#include "olemsclient.h"
#include "grid.h"
#include "MultiViewCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAsyncEnumSinkThread

IMPLEMENT_DYNCREATE(CAsyncEnumSinkThread, CWinThread)

CAsyncEnumSinkThread::CAsyncEnumSinkThread()
{
	m_pParent = NULL;
	m_pServices = NULL;

}

CAsyncEnumSinkThread::~CAsyncEnumSinkThread()
{

}

BOOL CAsyncEnumSinkThread::InitInstance()
{
	// TODO:  perform and per-thread initialization here


	m_pInstEnumObjectSink = new CAsyncInstEnumSink(m_pParent);


#ifdef _DEBUG
	ASSERT(m_pInstEnumObjectSink);
#endif

	if (!m_pInstEnumObjectSink)
	{
		return FALSE;

	}

	m_pInstEnumObjectSink->AddRef();


	m_pParent->m_nInstances = 0;

	SCODE sc = m_pServices->CreateInstanceEnumAsync
		(m_csClass.AllocSysString(),
		HMM_FLAG_DEEP,
		(IHmmObjectSink *) m_pInstEnumObjectSink ,
		&m_pInstEnumObjectSink->m_lAsyncRequestHandle);



#ifdef _DEBUG
	ASSERT(sc == S_OK);
#endif

	if(sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Ascyronous instance enumeration failed for class: ") + m_csClass;
		ErrorMsg
				(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__);
		m_pInstEnumObjectSink->Release();
		return FALSE;
	}


	return TRUE;
}

int CAsyncEnumSinkThread::ExitInstance()
{
	// TODO:  perform any per-thread cleanup here
	return CWinThread::ExitInstance();
}

BEGIN_MESSAGE_MAP(CAsyncEnumSinkThread, CWinThread)
	//{{AFX_MSG_MAP(CAsyncEnumSinkThread)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAsyncEnumSinkThread message handlers

BOOL CAsyncEnumSinkThread::PreTranslateMessage(MSG* pMsg)
{
	// TODO: Add your specialized code here and/or call the base class
	if (pMsg->message == ID_ASYNCENUM_DONE)
	{
		if (::IsWindow(m_pParent->m_pcaedDialog->GetSafeHwnd()))
		{
			m_pParent->m_pcaedDialog->PostMessage(ID_ASYNCENUM_DONE,0,0);
		}
		m_pInstEnumObjectSink->Release();
		m_pInstEnumObjectSink = NULL;
		AfxEndThread( 0 );
		return TRUE;
	}

	if (pMsg->message == ID_ASYNCENUM_CANCEL)
	{
		m_pInstEnumObjectSink->ShutDownSink();
		m_pInstEnumObjectSink = NULL;
		AfxEndThread( 0 );
		return TRUE;
	}

	return CWinThread::PreTranslateMessage(pMsg);
}


void CAsyncEnumSinkThread::SetLocalParent(CMultiViewCtrl *pParent)
{
	m_pParent = pParent;
}

void CAsyncEnumSinkThread::SetClass(CString *pcsClass)
{
	m_csClass = *pcsClass;
}

void CAsyncEnumSinkThread::SetServices(IHmmServices *pServices)
{
	m_pServices = pServices;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\asyncenumsyncuithread.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_AsyncEnumSinkThread_H__A02E1522_C1B0_11D0_962F_00C04FD9B15B__INCLUDED_)
#define AFX_ASYNCENUMSYNCUITHREAD_H__A02E1522_C1B0_11D0_962F_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AsyncEnumSyncUIThread.h : header file
//



/////////////////////////////////////////////////////////////////////////////
// CAsyncEnumSinkThread thread

class CMultiViewCtrl;
class CAsyncEnumDialog;
class CAsyncInstEnumSink;
struct IHmmClassObject;
struct IHmmServices;

class CAsyncEnumSinkThread : public CWinThread
{
	DECLARE_DYNCREATE(CAsyncEnumSinkThread)
protected:
	CAsyncEnumSinkThread();           // protected constructor used by dynamic creation
	CAsyncInstEnumSink *m_pInstEnumObjectSink;
// Attributes
public:
	void SetLocalParent(CMultiViewCtrl *pParent);
	void SetClass(CString *pcsClass);
	void SetServices(IHmmServices *pServices);
	CAsyncInstEnumSink *GetInstEnumObjectSink()
		{return m_pInstEnumObjectSink;}
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAsyncEnumSinkThread)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAsyncEnumSinkThread();
	CMultiViewCtrl *m_pParent;
	CString m_csClass;
	IHmmServices *m_pServices;
	// Generated message map functions
	//{{AFX_MSG(CAsyncEnumSinkThread)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AsyncEnumSinkThread_H__A02E1522_C1B0_11D0_962F_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\asyncenumdialog.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_ASYNCENUMDIALOG_H__A02E1521_C1B0_11D0_962F_00C04FD9B15B__INCLUDED_)
#define AFX_ASYNCENUMDIALOG_H__A02E1521_C1B0_11D0_962F_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AsyncEnumDialog.h : header file
//

class CMultiViewCtrl;
/////////////////////////////////////////////////////////////////////////////
// CAsyncEnumDialog dialog

class CAsyncEnumDialog : public CDialog
{
// Construction
public:
	CAsyncEnumDialog(CWnd* pParent = NULL);   // standard constructor
	void SetLocalParent(CMultiViewCtrl * pParent)
	{m_pParent = pParent;}
	void SetClass(CString *pcsClass)
	{m_csClass = *pcsClass;}
// Dialog Data
	//{{AFX_DATA(CAsyncEnumDialog)
	enum { IDD = IDD_DIALOGASYNCENUM };
	CStatic	m_cstaticMessage;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAsyncEnumDialog)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CMultiViewCtrl *m_pParent;
	CString m_csClass;

	// Generated message map functions
	//{{AFX_MSG(CAsyncEnumDialog)
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ASYNCENUMDIALOG_H__A02E1521_C1B0_11D0_962F_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\asyncquerydialog.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// AsyncQueryDialog.cpp : implementation file
//

#include "precomp.h"
#include "multiview.h"
#include "AsyncQueryDialog.h"
#include <wbemidl.h>
#include "olemsclient.h"
#include "grid.h"
#include "MultiViewCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CMultiViewApp NEAR theApp;

/////////////////////////////////////////////////////////////////////////////
// CAsyncQueryDialog dialog


CAsyncQueryDialog::CAsyncQueryDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CAsyncQueryDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAsyncQueryDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CAsyncQueryDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAsyncQueryDialog)
	DDX_Control(pDX, IDC_STATICMESSAGE1, m_staticMessage);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAsyncQueryDialog, CDialog)
	//{{AFX_MSG_MAP(CAsyncQueryDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAsyncQueryDialog message handlers

BOOL CAsyncQueryDialog::PreTranslateMessage(MSG* pMsg)
{
if (pMsg->message == ID_ASYNCQUERY_DONE)
	{
		EndDialog(IDOK);
		return TRUE;
	}

	return CDialog::PreTranslateMessage(pMsg);
}

BOOL CAsyncQueryDialog::OnInitDialog()
{
	CDialog::OnInitDialog();

	CString csMessage;

	if (m_csClass.GetLength() == 0)
	{
		csMessage = _T("Retrieving instances.");
	}
	else
	{
		csMessage =
			_T("Retrieving instances.  Because of the nature of this operation the");
		csMessage +=
			_T(" instances will not be displayed until they are all retireved.");
	}

	csMessage +=
		_T("  You may cancel the operation.");
	m_staticMessage.SetWindowText(csMessage);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAsyncQueryDialog::OnCancel()
{
	theApp.DoWaitCursor(1);
	/*if (m_pParent->m_pAsyncQuerySinkThread->m_hThread != NULL)
	{
		m_pParent->m_pAsyncQuerySinkThread->PostThreadMessage(ID_ASYNCQUERY_CANCEL,0,0);
	}
	m_pParent->PostMessage(ID_ASYNCQUERY_CANCEL,0,0);*/

	m_pParent->PostMessage(ID_ASYNCQUERY_CANCEL,0,0);

	CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\asyncquerydialog.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_ASYNCQUERYDIALOG_H__805BA5A1_C7DC_11D0_9639_00C04FD9B15B__INCLUDED_)
#define AFX_ASYNCQUERYDIALOG_H__805BA5A1_C7DC_11D0_9639_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AsyncQueryDialog.h : header file
//

class CMultiViewCtrl;

/////////////////////////////////////////////////////////////////////////////
// CAsyncQueryDialog dialog

class CAsyncQueryDialog : public CDialog
{
// Construction
public:
	CAsyncQueryDialog(CWnd* pParent = NULL);   // standard constructor
	void SetLocalParent(CMultiViewCtrl * pParent)
	{m_pParent = pParent;}
	void SetClass(CString *pcsClass)
	{m_csClass = *pcsClass;}
	void SetQueryType(CString *pcsQueryType)
	{m_csQueryType = *pcsQueryType;}
	void SetQuery(CString *pcsQuery)
	{m_csQuery = *pcsQuery;}
// Dialog Data
	//{{AFX_DATA(CAsyncQueryDialog)
	enum { IDD = IDD_DIALOGASYNCQUERY };
	CStatic	m_staticMessage;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAsyncQueryDialog)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CMultiViewCtrl *m_pParent;
	CString m_csClass;
	CString m_csQueryType;
	CString m_csQuery;
	// Generated message map functions
	//{{AFX_MSG(CAsyncQueryDialog)
	virtual BOOL OnInitDialog();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ASYNCQUERYDIALOG_H__805BA5A1_C7DC_11D0_9639_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\cathelp.cpp ===
//=--------------------------------------------------------------------------=

// CatHelp.Cpp

//=--------------------------------------------------------------------------=

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "precomp.h"

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\multiview.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MultiView.h : main header file for MULTIVIEW.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMultiViewApp : See MultiView.cpp for implementation.

class CMultiViewApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\multiview.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MultiView.cpp : Implementation of CMultiViewApp and DLL registration.

#include "precomp.h"
#include "MultiView.h"
#include "Grid.h"
#include "CatHelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CMultiViewApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xff371bf1, 0x213d, 0x11d0, { 0x95, 0xf3, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const GUID CDECL BASED_CODE _ctlid =   { 0xff371bf4, 0x213d, 0x11d0,
           { 0x95, 0xf3, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b} };

const CATID CATID_SafeForScripting     =
   {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing  =
   {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
////////////////////////////////////////////////////////////////////////////
// CMultiViewApp::InitInstance - DLL initialization

BOOL CMultiViewApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
		InitializeHmmvGrid();
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CMultiViewApp::ExitInstance - DLL termination

int CMultiViewApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	if (FAILED( CreateComponentCategory(CATID_SafeForScripting,
               L"Controls that are safely scriptable") ))
             return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( CreateComponentCategory(
           CATID_SafeForInitializing,
           L"Controls safely initializable from persistent data") ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForScripting) ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForInitializing) ))
         return ResultFromScode(SELFREG_E_CLASS);


	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\asyncquerysinkthread.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_ASYNCQUERYSINKTHREAD_H__F6336871_C7D4_11D0_9639_00C04FD9B15B__INCLUDED_)
#define AFX_ASYNCQUERYSINKTHREAD_H__F6336871_C7D4_11D0_9639_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AsyncQuerySinkThread.h : header file
//


class CAsyncQuerySink;
class CMultiViewCtrl;
struct IHmmServices;

/////////////////////////////////////////////////////////////////////////////
// CAsyncQuerySinkThread thread

class CAsyncQuerySinkThread : public CWinThread
{
	DECLARE_DYNCREATE(CAsyncQuerySinkThread)
protected:
	CAsyncQuerySinkThread();           // protected constructor used by dynamic creation
	CAsyncQuerySink *m_pAsyncQuerySink;
// Attributes
public:
	void SetLocalParent(CMultiViewCtrl *pParent);
	void SetQuery(CString *pcsQuery);
	void SetQueryType(CString *pcsQueryType);
	void SetServices(IHmmServices *pServices);
	CAsyncQuerySink *GetInstEnumObjectSink()
		{return m_pAsyncQuerySink;}
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAsyncQuerySinkThread)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAsyncQuerySinkThread();
	CMultiViewCtrl *m_pParent;
	CString m_csQuery;
	CString m_csQueryType;
	IHmmServices *m_pServices;
	// Generated message map functions
	//{{AFX_MSG(CAsyncQuerySinkThread)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ASYNCQUERYSINKTHREAD_H__F6336871_C7D4_11D0_9639_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\asyncquerysinkthread.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// AsyncQuerySinkThread.cpp : implementation file
//

#include "precomp.h"
#include "multiview.h"
#include "AsyncQuerySinkThread.h"
#include "AsyncQueryDialog.h"
#include <hmmsvc.h>
#include "olemsclient.h"
#include "grid.h"
#include "MultiViewCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAsyncQuerySinkThread

IMPLEMENT_DYNCREATE(CAsyncQuerySinkThread, CWinThread)

CAsyncQuerySinkThread::CAsyncQuerySinkThread()
{
	m_pParent = NULL;
	m_pServices = NULL;
}

CAsyncQuerySinkThread::~CAsyncQuerySinkThread()
{
}

BOOL CAsyncQuerySinkThread::InitInstance()
{

	// TODO:  perform and per-thread initialization here
	m_pAsyncQuerySink = new CAsyncQuerySink(m_pParent);


#ifdef _DEBUG
	ASSERT(m_pAsyncQuerySink);
#endif

	if (!m_pAsyncQuerySink)
	{
		return FALSE;

	}

	m_pAsyncQuerySink->AddRef();


	m_pParent->m_nInstances = 0;

	SCODE sc = m_pServices->
				ExecQueryAsync
				(	m_csQueryType.AllocSysString(),
					m_csQuery.AllocSysString(),
					0,
					(IHmmObjectSink *) m_pAsyncQuerySink ,
					&m_pAsyncQuerySink->m_lAsyncRequestHandle);

#ifdef _DEBUG
	ASSERT(sc == S_OK);
#endif

	if(sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Ascyronous query failed for query: ") + m_csQuery;
		ErrorMsg
				(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__);
		m_pAsyncQuerySink->Release();
		return FALSE;
	}


	return TRUE;
}

int CAsyncQuerySinkThread::ExitInstance()
{
	// TODO:  perform any per-thread cleanup here
	return CWinThread::ExitInstance();
}

BEGIN_MESSAGE_MAP(CAsyncQuerySinkThread, CWinThread)
	//{{AFX_MSG_MAP(CAsyncQuerySinkThread)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAsyncQuerySinkThread message handlers
void CAsyncQuerySinkThread::SetLocalParent(CMultiViewCtrl *pParent)
{
	m_pParent = pParent;
}

void CAsyncQuerySinkThread::SetQuery(CString *pcsQuery)
{
	m_csQuery = *pcsQuery;
}

void CAsyncQuerySinkThread::SetQueryType(CString *pcsQueryType)
{
	m_csQueryType = *pcsQueryType;
}

void CAsyncQuerySinkThread::SetServices(IHmmServices *pServices)
{
	m_pServices = pServices;

}
BOOL CAsyncQuerySinkThread::PreTranslateMessage(MSG* pMsg)
{
	// TODO: Add your specialized code here and/or call the base class
	if (pMsg->message == ID_ASYNCQUERY_DONE)
	{
		if (::IsWindow(m_pParent->m_pcaqdDialog->GetSafeHwnd()))
		{
			m_pParent->m_pcaqdDialog->PostMessage(ID_ASYNCQUERY_DONE,0,0);
		}
		m_pAsyncQuerySink->Release();
		m_pAsyncQuerySink = NULL;
		AfxEndThread( 0 );
		return TRUE;
	}

	if (pMsg->message == ID_ASYNCQUERY_CANCEL)
	{
		m_pAsyncQuerySink->ShutDownSink();
		m_pAsyncQuerySink = NULL;
		AfxEndThread( 0 );
		return TRUE;
	}

	return CWinThread::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\multiviewppg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MultiViewPpg.cpp : Implementation of the CMultiViewPropPage property page class.

#include "precomp.h"
#include "MultiView.h"
#include "MultiViewPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMultiViewPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMultiViewPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CMultiViewPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMultiViewPropPage, "WBEM.MultiViewPropPage.1",
	0xff371bf5, 0x213d, 0x11d0, 0x95, 0xf3, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// CMultiViewPropPage::CMultiViewPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CMultiViewPropPage

BOOL CMultiViewPropPage::CMultiViewPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_MULTIVIEW_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CMultiViewPropPage::CMultiViewPropPage - Constructor

CMultiViewPropPage::CMultiViewPropPage() :
	COlePropertyPage(IDD, IDS_MULTIVIEW_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CMultiViewPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CMultiViewPropPage::DoDataExchange - Moves data between page and properties

void CMultiViewPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CMultiViewPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CMultiViewPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\multiviewctl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MultiViewCtl.cpp : Implementation of the CMultiViewCtrl OLE control class.
//
// 03, Jan, 1997 - Larry French
//		Added code to the CMultiViewGrid class to fire the SelectionChanged event
//		when the grids selection changed.  Also added the code to check for the
//		selection change.
//
//		Please look for all the places marked with !!! Judy (to do)

#include "precomp.h"
#include <OBJIDL.H>
#include <wbemidl.h>
#include "olemsclient.h"
#include "grid.h"
#include "MultiView.h"
#include "MultiViewCtl.h"
#include "MultiViewPpg.h"
#include "SyncEnumDlg.h"
#include "AsyncEnumDialog.h"
#include "AsyncQueryDialog.h"
#include "ProgDlg.h"
#include "resource.h"
#include "logindlg.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <WbemResource.h>


#define ENUM_TIMEOUT 500		// Half second timeout

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define SZ_MODULE_NAME "MultiView.ocx"
#define CX_SMALL_ICON 16
#define CY_SMALL_ICON 16

#define N_INSTANCES 20

enum {VIEW_DEFAULT=0, VIEW_CURRENT=1, VIEW_FIRST=2, VIEW_LAST=3};
enum {OBJECT_CURRENT=0, OBJECT_FIRST=1, OBJECT_LAST=2};


extern CMultiViewApp NEAR theApp;


IMPLEMENT_DYNCREATE(CMultiViewCtrl, COleControl)

/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMultiViewCtrl, COleControl)
	ON_WM_CONTEXTMENU()
	//{{AFX_MSG_MAP(CMultiViewCtrl)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_DESTROY()
	ON_WM_SHOWWINDOW()
	ON_COMMAND(ID_MENUITEMGOTOSINGLE, OnMenuitemgotosingle)
	ON_UPDATE_COMMAND_UI(ID_MENUITEMGOTOSINGLE, OnUpdateMenuitemgotosingle)
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
	ON_MESSAGE( ID_DISPLAYNOINSTANCES, DisplayNoInstances )
	ON_MESSAGE( ID_INSTENUMDONE, InstEnumDone )
	ON_MESSAGE( ID_QUERYDONE, QueryDone )
	ON_MESSAGE( ID_GETASYNCINSTENUMSINK, GetEnumSink)
	ON_MESSAGE( ID_GETASYNCQUERYSINK, GetQuerySink)
	ON_MESSAGE( ID_ENUM_DOMODAL, EnumDoModalDialog)
	ON_MESSAGE( ID_SYNC_ENUM_DOMODAL, SyncEnumDoModalDialog)
	ON_MESSAGE( ID_SYNC_ENUM, SyncEnum)
	ON_MESSAGE( ID_QUERY_DOMODAL, QueryDoModalDialog)
	ON_MESSAGE( ID_ASYNCENUM_CANCEL , AsyncEnumCancelled)
	ON_MESSAGE( ID_ASYNCQUERY_CANCEL , AsyncQueryCancelled)
	ON_MESSAGE( ID_ASYNCQUERY_DISPLAY ,DisplayAsyncQueryInstances)
	ON_MESSAGE( INITSERVICES, InitServices)
	ON_MESSAGE(	INITIALIZE_NAMESPACE, OpenNamespace)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CMultiViewCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CMultiViewCtrl)
	DISP_PROPERTY_EX(CMultiViewCtrl, "NameSpace", GetNameSpace, SetNameSpace, VT_BSTR)
	DISP_PROPERTY_EX(CMultiViewCtrl, "PropertyFilter", GetPropertyFilter, SetPropertyFilter, VT_I4)
	DISP_FUNCTION(CMultiViewCtrl, "ViewClassInstances", ViewClassInstances, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CMultiViewCtrl, "ForceRedraw", ForceRedraw, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CMultiViewCtrl, "CreateInstance", CreateInstance, VT_I4, VTS_NONE)
	DISP_FUNCTION(CMultiViewCtrl, "DeleteInstance", DeleteInstance, VT_I4, VTS_NONE)
	DISP_FUNCTION(CMultiViewCtrl, "GetContext", GetContext, VT_I4, VTS_PI4)
	DISP_FUNCTION(CMultiViewCtrl, "RestoreContext", RestoreContext, VT_I4, VTS_I4)
	DISP_FUNCTION(CMultiViewCtrl, "AddContextRef", AddContextRef, VT_I4, VTS_I4)
	DISP_FUNCTION(CMultiViewCtrl, "ReleaseContext", ReleaseContext, VT_I4, VTS_I4)
	DISP_FUNCTION(CMultiViewCtrl, "GetEditMode", GetEditMode, VT_I4, VTS_NONE)
	DISP_FUNCTION(CMultiViewCtrl, "GetObjectPath", GetObjectPath, VT_BSTR, VTS_I4)
	DISP_FUNCTION(CMultiViewCtrl, "GetObjectTitle", GetObjectTitle, VT_BSTR, VTS_I4)
	DISP_FUNCTION(CMultiViewCtrl, "GetTitle", GetTitle, VT_I4, VTS_PBSTR VTS_PDISPATCH)
	DISP_FUNCTION(CMultiViewCtrl, "GetViewTitle", GetViewTitle, VT_BSTR, VTS_I4)
	DISP_FUNCTION(CMultiViewCtrl, "NextViewTitle", NextViewTitle, VT_I4, VTS_I4 VTS_PBSTR)
	DISP_FUNCTION(CMultiViewCtrl, "ExternInstanceCreated", ExternInstanceCreated, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CMultiViewCtrl, "ExternInstanceDeleted", ExternInstanceDeleted, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CMultiViewCtrl, "NotifyWillShow", NotifyWillShow, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CMultiViewCtrl, "PrevViewTitle", PrevViewTitle, VT_I4, VTS_I4 VTS_PBSTR)
	DISP_FUNCTION(CMultiViewCtrl, "QueryCanCreateInstance", QueryCanCreateInstance, VT_I4, VTS_NONE)
	DISP_FUNCTION(CMultiViewCtrl, "QueryCanDeleteInstance", QueryCanDeleteInstance, VT_I4, VTS_NONE)
	DISP_FUNCTION(CMultiViewCtrl, "QueryNeedsSave", QueryNeedsSave, VT_I4, VTS_NONE)
	DISP_FUNCTION(CMultiViewCtrl, "QueryObjectSelected", QueryObjectSelected, VT_I4, VTS_NONE)
	DISP_FUNCTION(CMultiViewCtrl, "RefreshView", RefreshView, VT_I4, VTS_NONE)
	DISP_FUNCTION(CMultiViewCtrl, "SaveData", SaveData, VT_I4, VTS_NONE)
	DISP_FUNCTION(CMultiViewCtrl, "SelectView", SelectView, VT_I4, VTS_I4)
	DISP_FUNCTION(CMultiViewCtrl, "SetEditMode", SetEditMode, VT_EMPTY, VTS_I4)
	DISP_FUNCTION(CMultiViewCtrl, "StartObjectEnumeration", StartObjectEnumeration, VT_I4, VTS_I4)
	DISP_FUNCTION(CMultiViewCtrl, "StartViewEnumeration", StartViewEnumeration, VT_I4, VTS_I4)
	DISP_FUNCTION(CMultiViewCtrl, "ViewInstances", ViewInstances, VT_I4, VTS_BSTR VTS_VARIANT)
	DISP_FUNCTION(CMultiViewCtrl, "QueryViewInstances", QueryViewInstances, VT_EMPTY, VTS_BSTR VTS_BSTR VTS_BSTR VTS_BSTR)
	DISP_FUNCTION(CMultiViewCtrl, "NextObject", NextObject, VT_I4, VTS_I4)
	DISP_FUNCTION(CMultiViewCtrl, "PrevObject", PrevObject, VT_I4, VTS_I4)
	DISP_FUNCTION(CMultiViewCtrl, "SelectObjectByPath", SelectObjectByPath, VT_I4, VTS_BSTR)
	DISP_FUNCTION(CMultiViewCtrl, "SelectObjectByPosition", SelectObjectByPosition, VT_I4, VTS_I4)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CMultiViewCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CMultiViewCtrl, COleControl)
	//{{AFX_EVENT_MAP(CMultiViewCtrl)
	EVENT_CUSTOM("NotifyViewModified", FireNotifyViewModified, VTS_NONE)
	EVENT_CUSTOM("NotifySelectionChanged", FireNotifySelectionChanged, VTS_NONE)
	EVENT_CUSTOM("NotifySaveRequired", FireNotifySaveRequired, VTS_NONE)
	EVENT_CUSTOM("NotifyViewObjectSelected", FireNotifyViewObjectSelected, VTS_BSTR)
	EVENT_CUSTOM("GetIWbemServices", FireGetIWbemServices, VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT)
	EVENT_CUSTOM("NotifyContextChanged", FireNotifyContextChanged, VTS_I4)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CMultiViewCtrl, 1)
	PROPPAGEID(CMultiViewPropPage::guid)
END_PROPPAGEIDS(CMultiViewCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMultiViewCtrl, "WBEM.MultiViewCtrl.1",
	0xff371bf4, 0x213d, 0x11d0, 0x95, 0xf3, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CMultiViewCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DMultiView =
		{ 0xff371bf2, 0x213d, 0x11d0, { 0x95, 0xf3, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const IID BASED_CODE IID_DMultiViewEvents =
		{ 0xff371bf3, 0x213d, 0x11d0, { 0x95, 0xf3, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwMultiViewOleMisc =\
	OLEMISC_SIMPLEFRAME |
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CMultiViewCtrl, IDS_MULTIVIEW, _dwMultiViewOleMisc)

STDMETHODIMP CMVContext::QueryInterface(REFIID riid, LPVOID* ppv)
{
    if(riid == IID_IUnknown)
    {
        *ppv = this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

ULONG CMVContext::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG CMVContext::Release()
{
    int lNewRef = InterlockedDecrement(&m_lRef);
    if(lNewRef == 0)
    {
        delete this;
    }

    return lNewRef;
}

CMVContext::CMVContext(CMVContext &rhs)
:		m_lRef(0),
		m_bContextDrawn(FALSE)
{
	GetType() = rhs.GetType();
	GetClass()= rhs.GetClass();
	GetQuery() = rhs.GetQuery();
	GetQueryType() = rhs.GetQueryType();
	GetLabel() = rhs.GetLabel();
	GetNamespace() = rhs.GetNamespace();
	for (int i = 0; i < rhs.GetInstances().GetSize(); i++)
	{
		GetInstances().Add(rhs.GetInstances().GetAt(i));
	}
}

BOOL CMVContext::IsContextEqual(CMVContext &cmvcContext)
{
	if(GetType() != cmvcContext.m_nContextType)
	{
		return FALSE;
	}

	if (GetClass().CompareNoCase(cmvcContext.m_csClass) != 0)
	{
		return FALSE;
	}


	if (GetQuery().CompareNoCase(cmvcContext.m_csQuery) != 0)
	{
		return FALSE;
	}

	if (GetQueryType().CompareNoCase(cmvcContext.m_csQueryType) != 0)
	{
		return FALSE;
	}

	if (GetLabel().CompareNoCase(cmvcContext.m_csLabel) != 0)
	{
		return FALSE;
	}

	if (GetNamespace().CompareNoCase(cmvcContext.m_csNamespace) != 0)
	{
		return FALSE;
	}

	if (GetInstances().GetSize() != cmvcContext.m_csaInstances.GetSize())
	{
		return FALSE;
	}

	for (int i = 0; i < cmvcContext.m_csaInstances.GetSize(); i++)
	{
		if (GetInstances().GetAt(i).CompareNoCase
			(cmvcContext.m_csaInstances.GetAt(i)) != 0)
		{
			return FALSE;
		}
	}


	return TRUE;
}

CMVContext &CMVContext::operator=(const CMVContext &rhs)
{
	if (this == &rhs)
	{
		return *this;
	}

	this->~CMVContext();

	m_lRef = 0;
	IsDrawn() = FALSE;
	GetType() = rhs.m_nContextType;
	GetClass()= rhs.m_csClass;
	GetQuery() = rhs.m_csQuery;
	GetQueryType() = rhs.m_csQueryType;
	GetLabel() = rhs.m_csLabel;
	GetNamespace() = rhs.m_csNamespace;
	for (int i = 0; i < rhs.m_csaInstances.GetSize(); i++)
	{
		GetInstances().Add(rhs.m_csaInstances.GetAt(i));
	}

	return *this;

}

STDMETHODIMP CAsyncQuerySink::QueryInterface(REFIID riid, LPVOID* ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemObjectSink)
    {
        *ppv = this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

ULONG CAsyncQuerySink::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG CAsyncQuerySink::Release()
{
    int lNewRef = InterlockedDecrement(&m_lRef);
    if(lNewRef == 0)
    {
        delete this;
    }

    return lNewRef;
}

STDMETHODIMP CAsyncQuerySink::Indicate
(LONG lObjectCount,IWbemClassObject FAR* FAR*ppObjArray)
{
	BOOL bDone = FALSE;
	CPtrArray cpaInstances;
	int i;
	for (i = 0; i < lObjectCount; i++)
	{
		IWbemClassObject *pInst = reinterpret_cast<IWbemClassObject*>(ppObjArray[i]);
		CString csClass = GetIWbemClass
			(m_pMultiViewCtrl->m_pServices,pInst);
		CString csNotifyBase = _T("__NotifyStatus");
		CString csDynasty = _T("__Dynasty");
		csDynasty = ::GetProperty(m_pMultiViewCtrl->m_pServices,pInst,&csDynasty);
		if (!csDynasty.CompareNoCase(csNotifyBase) == 0)
		{
			pInst->AddRef();
			cpaInstances.Add(ppObjArray[i]);
			m_pMultiViewCtrl->m_nInstances++;
		}
		else
		{
			m_lAsyncRequestHandle = 0;
			if (m_pMultiViewCtrl->m_nInstances == 0)
			{
				m_pMultiViewCtrl->PostMessage(ID_DISPLAYNOINSTANCES,0,0);

			}
			bDone = TRUE;



		}

	}

	if (lObjectCount > 0)
	{
		if (m_pMultiViewCtrl->m_csClassForAsyncSink.GetLength() > 0)
		{
			m_pMultiViewCtrl->AddToDisplay(&cpaInstances);
		}
		else
		{
			m_pMultiViewCtrl->m_cpaInstancesForQuery.Append(cpaInstances);

		}
	}

	if (bDone)
	{
		if (m_pMultiViewCtrl->m_csClassForAsyncSink.GetLength() == 0)
		{
			m_pMultiViewCtrl->PostMessage(ID_ASYNCQUERY_DISPLAY,0,0);
		}

		m_pMultiViewCtrl->PostMessage(ID_QUERYDONE,0,0);
	}


	return S_OK;
}


CAsyncQuerySink::~CAsyncQuerySink()
{
	if (m_lRef > 0)
	{


	}
}


void CAsyncQuerySink::ShutDownSink()
{
	if (!m_lAsyncRequestHandle == 0)
	{
		AddRef();
		SCODE sc =
			m_pMultiViewCtrl->m_pServices->
				CancelAsyncCall((IWbemObjectSink*) this);
        Sleep(1000);
		CoDisconnectObject(this,0);
		m_lRef = 0;
		CAsyncQuerySink::~CAsyncQuerySink();
	} else if (m_lRef == 1)
	{
		m_lRef = 0;
		CAsyncQuerySink::~CAsyncQuerySink();
	}
	else
	{
		CoDisconnectObject(this,0);
		m_lRef = 0;
		CAsyncQuerySink::~CAsyncQuerySink();
	}
}




STDMETHODIMP CAsyncInstEnumSink::QueryInterface(REFIID riid, LPVOID* ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemObjectSink)
    {
        *ppv = this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

ULONG CAsyncInstEnumSink::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG CAsyncInstEnumSink::Release()
{
    int lNewRef = InterlockedDecrement(&m_lRef);
    if(lNewRef == 0)
    {
        delete this;
    }

    return lNewRef;
}

STDMETHODIMP CAsyncInstEnumSink::Indicate
(LONG lObjectCount,IWbemClassObject FAR* FAR*ppObjArray)
{
	BOOL bDone;
#ifdef _DEBUG
//	afxDump << _T("Entering Indicate\n");;
#endif

	CPtrArray cpaInstances;
	int i;
	for (i = 0; i < lObjectCount; i++)
	{
		IWbemClassObject *pInst = reinterpret_cast<IWbemClassObject*>(ppObjArray[i]);
		CString csClass = GetIWbemClass
			(m_pMultiViewCtrl->m_pServices,pInst);
#ifdef _DEBUG
//		afxDump << _T("Async enum class = ") << csClass << "\n";
#endif
		CString csNotifyBase = _T("__NotifyStatus");
		CString csDynasty = _T("__Dynasty");
		csDynasty = ::GetProperty(m_pMultiViewCtrl->m_pServices,pInst,&csDynasty);
		if (!csDynasty.CompareNoCase(csNotifyBase) == 0)
		{
			pInst->AddRef();
			cpaInstances.Add(ppObjArray[i]);
			m_pMultiViewCtrl->m_nInstances++;
		}
		else
		{
			m_lAsyncRequestHandle = 0;
			if (m_pMultiViewCtrl->m_nInstances == 0)
			{
				m_pMultiViewCtrl->PostMessage(ID_DISPLAYNOINSTANCES,0,0);

			}

			bDone = TRUE;
		}

	}

	if (lObjectCount > 0)
	{
		m_pMultiViewCtrl->AddToDisplay(&cpaInstances);
	}

	if (bDone)
	{
		m_pMultiViewCtrl->PostMessage(ID_INSTENUMDONE,0,0);
	}

#ifdef _DEBUG
//	afxDump << _T("Leaving Indicate\n");;
#endif

	return S_OK;
}


CAsyncInstEnumSink::~CAsyncInstEnumSink()
{
	if (m_lRef > 0)
	{


	}
}


void CAsyncInstEnumSink::ShutDownSink()
{
	if (!m_lAsyncRequestHandle == 0)
	{
		AddRef();
		SCODE sc =
			m_pMultiViewCtrl->m_pServices->
				CancelAsyncCall((IWbemObjectSink*) this);
        Sleep(1000);
		CoDisconnectObject(this,0);
		m_lRef = 0;
		CAsyncInstEnumSink::~CAsyncInstEnumSink();
	} else if (m_lRef == 1)
	{
		m_lRef = 0;
		CAsyncInstEnumSink::~CAsyncInstEnumSink();
	}
	else
	{
		CoDisconnectObject(this,0);
		m_lRef = 0;
		CAsyncInstEnumSink::~CAsyncInstEnumSink();
	}
}





/////////////////////////////////////////////////////////////////////////////
// CMultiViewCtrl::CMultiViewCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CMultiViewCtrl

BOOL CMultiViewCtrl::CMultiViewCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to afxRegInsertable.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_MULTIVIEW,
			IDB_MULTIVIEW,
			afxRegInsertable | afxRegApartmentThreading,
			_dwMultiViewOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CMultiViewCtrl::CMultiViewCtrl - Constructor

CMultiViewCtrl::CMultiViewCtrl()
{
	InitializeIIDs(&IID_DMultiView, &IID_DMultiViewEvents);
	EnableSimpleFrame();
	m_pServices = NULL;
	m_cgGrid.SetParent (this);
	m_nClassOrInstances = CMultiViewCtrl::NONE;
	m_pcsedDialog = NULL;
	m_pcaedDialog = NULL;
	m_pcaqdDialog = NULL;
	m_pInstEnumObjectSink = NULL;
	m_pAsyncQuerySink = NULL;
	m_bInOnDraw = FALSE;
	m_bInitServices = TRUE;
	m_pcmvcCurrentContext = new CMVContext;
	m_pcmvcCurrentContext->AddRef();
	m_pProgressDlg = NULL;
	m_cpRightUp.x = 0;
	m_cpRightUp.y = 0;
	m_lPropFilterFlags = PROPFILTER_SYSTEM | PROPFILTER_INHERITED | PROPFILTER_LOCAL;
	m_bSelectionNotChanging = FALSE;
	m_bCanEdit = FALSE;
	m_bPropFilterFlagsChanged = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CMultiViewCtrl::~CMultiViewCtrl - Destructor

CMultiViewCtrl::~CMultiViewCtrl()
{
	m_csaProps.RemoveAll();

	if (m_pServices)
	{
		m_pServices -> Release();
	}

	// Delete stored paths
	int nRows = m_cgGrid.GetRows();
	for (int i = 0; i < nRows; i++)
	{
		CString *pcsPath =
			reinterpret_cast<CString *>
				(m_cgGrid.GetAt(i, 0).GetTagValue());
		delete pcsPath;
	}

	m_pcmvcCurrentContext->Release();

}


/////////////////////////////////////////////////////////////////////////////
// CMultiViewCtrl::OnDraw - Drawing function

void CMultiViewCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{


	if (GetSafeHwnd() && !AmbientUserMode())
	{
		COLORREF crWhite = RGB(255,255,255);
		CRect rcOutline(rcBounds);
		CBrush cbBackGround;
		cbBackGround.CreateSolidBrush(crWhite);
		CBrush *cbSave = pdc -> SelectObject(&cbBackGround);
		pdc ->FillRect(&rcOutline, &cbBackGround);
		pdc -> SelectObject(cbSave);
		return;
	}

	// TODO: Replace the following code with your own drawing code.
	if (m_bInOnDraw)
	{
		return;
	}

	m_bInOnDraw = TRUE;
	if (m_cgGrid.GetSafeHwnd())
	{
		m_cgGrid.ShowWindow(SW_SHOW);
	}

	if (m_csNamespaceToInit.GetLength() > 0)
	{
		PostMessage(INITIALIZE_NAMESPACE,0,0);
	}

	m_bInOnDraw = FALSE;
}

LRESULT CMultiViewCtrl::InitServices (WPARAM, LPARAM)
{
	if (m_bInitServices)
	{
		m_pServices = InitServices(&m_csNameSpace);
		m_bInitServices = FALSE;
	}
	return 0;

}

/////////////////////////////////////////////////////////////////////////////
// CMultiViewCtrl::DoPropExchange - Persistence support

void CMultiViewCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	PX_String(pPX, _T("NameSpace"), m_csNameSpace, _T(""));

	if (pPX->IsLoading() && m_csNameSpace.GetLength() > 0)
	{
		m_csNamespaceToInit = m_csNameSpace;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CMultiViewCtrl::OnResetState - Reset control to default state

void CMultiViewCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CMultiViewCtrl::AboutBox - Display an "About" box to the user

void CMultiViewCtrl::AboutBox()
{
	CWnd* pwndFocus = GetFocus();

	CDialog dlgAbout(IDD_ABOUTBOX_MULTIVIEW);
	dlgAbout.DoModal();

	if (pwndFocus && ::IsWindow(pwndFocus->m_hWnd)) {
		pwndFocus->SetFocus();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMultiViewCtrl message handlers

int CMultiViewCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (AmbientUserMode( ) && GetSafeHwnd())
	{
		// Create the grid window
		UINT idWindow = 500;
		BOOL bGridVisible = TRUE;
		CRect rcGrid(0, 0, 0, 0);
		m_cgGrid.Create(rcGrid, this, idWindow, bGridVisible);


		m_pcsedDialog = new CSyncEnumDlg;
		m_pcsedDialog->SetLocalParent(this);
		m_pcaedDialog = new CAsyncEnumDialog;
		m_pcaedDialog->SetLocalParent(this);
		m_pcaqdDialog = new CAsyncQueryDialog;
		m_pcaqdDialog->SetLocalParent(this);

		m_pProgressDlg = new CProgressDlg;


	}
	return 0;
}

void CMultiViewCtrl::OnSize(UINT nType, int cx, int cy)
{
	if (AmbientUserMode( ) && GetSafeHwnd())
	{
		COleControl::OnSize(nType, cx, cy);

		// Make the grid window cover the entire client area.
		if (m_cgGrid.m_hWnd) {
			m_cgGrid.MoveWindow(0, 0, cx, cy, TRUE);
		}
	}

}

void CMultiViewCtrl::ViewClassInstances(LPCTSTR lpszClassName)
{
	m_pcmvcCurrentContext->~CMVContext();

	m_pcmvcCurrentContext->AddRef();
	m_pcmvcCurrentContext->GetType() = CMVContext::Class;
	m_pcmvcCurrentContext->GetClass() = lpszClassName;
	m_pcmvcCurrentContext->GetNamespace() = m_csNameSpace;

	m_nClassOrInstances = CMultiViewCtrl::CLASS;

	if (IsWindowVisible())
	{
		NotifyWillShow();
	}

}

void CMultiViewCtrl::ViewClassInstancesSync(LPCTSTR lpszClassName)
{
	if (lpszClassName == NULL || lpszClassName[0] == '\0' || !m_pServices)
	{
		return;
	}

	m_csSyncEnumClass = lpszClassName;
	// This is just to allow the message pump to run so we see the gird
	// because the container will not actually show us until "VierInstances"
	// returns??
	// From PolyView.cpp:
	//		m_pmv->NotifyWillShow();
	//		m_pmv->ShowWindow(SW_SHOW);
	// It would be nice to do these in the reverse order because as it now stands
	// ViewClassInstances is not synchronous which is not good for programatic use.
	PostMessage(ID_SYNC_ENUM , 0,0);
	// Refresh repaints in line.
//	Refresh();
//	SyncEnum(0,0);
}

LRESULT CMultiViewCtrl::SyncEnum(WPARAM, LPARAM)
{
//	CWaitCursor wait;

	IWbemClassObject *pimcoClass = NULL;
	IWbemClassObject *pErrorObject = NULL;

	SCODE sc;

	CString csPath;

	if (m_pcmvcCurrentContext->GetType() == CMVContext::Class)
	{
		BSTR bstrTemp = m_csSyncEnumClass.AllocSysString();

		m_sc = m_pServices ->
			GetObject(bstrTemp,0, NULL, &pimcoClass,NULL);
		::SysFreeString(bstrTemp);
	}
	else
	{
		csPath = m_csSyncEnumClass;
		pimcoClass = GetClassFromAnyNamespace(csPath);
	}

	if (!pimcoClass)
	{
		InitializeDisplay(NULL,NULL,NULL);
		CString csUserMsg;
		csUserMsg =  _T("Cannot get class object ") + csPath;
		ErrorMsg
				(&csUserMsg, m_sc,FALSE, FALSE, &csUserMsg, __FILE__,
				__LINE__ - 9);
		return 0;
	}

	if (csPath.IsEmpty())
	{
		csPath = GetIWbemClass(m_pServices,pimcoClass);
	}

	CString csClass;

	BOOL bDiffNS =
		ObjectInDifferentNamespace
			(m_pServices, &m_csNameSpace, pimcoClass);

	IWbemServices *pServices;

	if (bDiffNS)
	{
		CString csNameSpace =
			GetObjectNamespace (m_pServices, pimcoClass);
		pServices = InitServices(&csNameSpace);

		if (!pServices)
		{
			InitializeDisplay(NULL,NULL,NULL);
			CString csUserMsg;
			csUserMsg =  _T("Cannot connect to namespace ") + csNameSpace;
			ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 9);
			pimcoClass->Release();
			return 0;
		}
		csClass = GetIWbemClass(pServices ,pimcoClass);
	}
	else
	{
		csClass = GetIWbemClass(m_pServices ,pimcoClass);
	}

	CPtrArray *pcpaInstances = new CPtrArray;
	IWbemClassObject *pInstanceEnumErrorObject = NULL;
	int cInst;
	BOOL bCancel = FALSE;
	m_pAsyncEnumCancelled = FALSE;
	m_pAsyncQueryCancelled = FALSE;
	sc = SemiSyncClassInstancesIncrementalAddToDisplay
		(bDiffNS? pServices: m_pServices, pimcoClass, &csClass ,
		*pcpaInstances , cInst, bCancel);

	if (cInst == 0 || bCancel)
	{
		m_nClassOrInstances = CMultiViewCtrl::ZERO_CLASS_INST;
		CString csMessage;

		if (bCancel)
		{
			csMessage = _T("Operation Canceled");
		}
		else
		{
			csMessage = _T("No Instances Available");
		}
		InitializeDisplay(NULL,NULL,NULL,&csMessage);
		pimcoClass -> Release();
		if (bDiffNS)
		{
			pServices->Release();
		}
		m_csClass = csPath;
		delete pcpaInstances;
		return 0;
	}

	pimcoClass -> Release();

	if (bDiffNS)
	{
		pServices->Release();
	}

	delete pcpaInstances;

	return 0;

}

SCODE CMultiViewCtrl::SemiSyncClassInstancesIncrementalAddToDisplay
(IWbemServices * pIWbemServices, IWbemClassObject *pimcoClass,
 CString *pcsClass,
 CPtrArray &cpaInstances,int &cInst, BOOL &bCancel)
{

	m_bSelectionNotChanging = TRUE;

	CString csMessage =
		m_csSyncEnumClass + _T(" class instances.");

	SetProgressDlgMessage(csMessage);

	cInst = 0;
	bCancel = 0;

	SCODE sc;
	IEnumWbemClassObject *pimecoInstanceEnum = NULL;

#ifdef _DEBUG
	afxDump << "CreateInstanceEnum in SemiSyncClassInstancesIncrementalAddToDisplay for class " << *pcsClass << "\n";
#endif

	BSTR bstrTemp = pcsClass -> AllocSysString();
	sc = pIWbemServices->CreateInstanceEnum
		(bstrTemp,
		WBEM_FLAG_DEEP | WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pimecoInstanceEnum);
	::SysFreeString(bstrTemp);

	if(sc != S_OK)
	{
		m_bSelectionNotChanging = FALSE;
		m_cgGrid.CheckForSelectionChange();
		return sc;
	}

	sc = SetEnumInterfaceSecurity(m_csNameSpace,pimecoInstanceEnum, pIWbemServices);

#ifdef _DEBUG
	afxDump << "SetEnumInterfaceSecurityin SemiSyncClassInstancesIncrementalAddToDisplay for class " << sc << "\n";
#endif

//	sc = pimecoInstanceEnum->Reset();

	m_csaProps.RemoveAll();
	int nProps = GetSortedPropNames (pimcoClass, m_csaProps, m_cmstpPropFlavors);

	InitializeDisplay(NULL, NULL, &m_csaProps, NULL, &m_cmstpPropFlavors);

	IWbemClassObject     *pimcoInstances[N_INSTANCES];
	IWbemClassObject     **pInstanceArray =
		reinterpret_cast<IWbemClassObject **> (&pimcoInstances);

	int i;

	for (i = 0; i < N_INSTANCES; i++)
	{
		pimcoInstances[i] = NULL;
	}


	IWbemClassObject     *pimcoInstance = NULL;
	ULONG uReturned = 0;

#ifdef _DEBUG
	afxDump << "Next in SemiSyncClassInstancesIncrementalAddToDisplay number returned = ";
#endif

	CString csPath = m_csSyncEnumClass;
	m_csClass = csPath;
	m_nClassOrInstances = CLASS;

	if (!m_pProgressDlg->GetSafeHwnd())
	{
		CreateProgressDlgWindow();
	}

	BOOL bReportRetrievalError = FALSE;
	HWND hwndFocus = ::GetFocus();
	sc = pimecoInstanceEnum->Next(ENUM_TIMEOUT,N_INSTANCES,pInstanceArray, &uReturned);
	if (FAILED(sc)) {
		bReportRetrievalError = TRUE;
	}


#ifdef _DEBUG
	afxDump << uReturned << "\n";
#endif

    while (sc == S_OK || sc == WBEM_S_TIMEDOUT || uReturned > 0)
		{
			bCancel = CheckCancelButtonProgressDlgWindow();

			if (bCancel)
			{
#pragma warning( disable :4018 )
				for (int i = 0; i < uReturned; i++)
#pragma warning( default : 4018 )
				{
					pimcoInstances[i]->Release();
					pimcoInstances[i] = NULL;
				}
				cInst = 0;
				break;
			}

#pragma warning( disable :4018 )
			for (int i = 0; i < uReturned; i++)
#pragma warning( default : 4018 )
			{
				cpaInstances.Add(reinterpret_cast<void *>(pimcoInstances[i]));
				pimcoInstances[i] = NULL;
			}
			if (uReturned > 0)
			{
				AddToDisplay(&cpaInstances);
			}
			cpaInstances.RemoveAll();
			cInst += uReturned;
			uReturned = 0;
#ifdef _DEBUG
	afxDump << "Next in SemiSyncClassInstancesIncrementalAddToDisplay number returned = ";
#endif

			sc = pimecoInstanceEnum->Next
				(1,N_INSTANCES,pInstanceArray, &uReturned);


			if (FAILED(sc)) {
				bReportRetrievalError = TRUE;
			}
#ifdef _DEBUG
	afxDump << uReturned << "\n";
#endif
		}

	pimecoInstanceEnum -> Release();

	DestroyProgressDlgWindow();


	if (bReportRetrievalError) {
		CString csUserMsg =
						_T("An error occurred while attempting to retrieve the list of objects.");

		ErrorMsg
			(&csUserMsg, sc, TRUE,
			TRUE, &csUserMsg, __FILE__, __LINE__ - 6);

		if (::IsWindow(hwndFocus) && ::IsWindowVisible(hwndFocus)) {
			::SetFocus(hwndFocus);
		}
	}
	m_bSelectionNotChanging = FALSE;
	m_cgGrid.CheckForSelectionChange();

	return sc;

}

void CMultiViewCtrl::SetProgressDlgMessage(CString &csMessage)
{
	m_pProgressDlg->SetMessage(csMessage);
}

void CMultiViewCtrl::CreateProgressDlgWindow()
{

	PreModalDialog();
	m_pProgressDlg->Create(this);
}

BOOL CMultiViewCtrl::CheckCancelButtonProgressDlgWindow()
{
	if (::IsWindow(m_pProgressDlg->m_hWnd) && m_pProgressDlg->GetSafeHwnd())
	{
		return m_pProgressDlg->CheckCancelButton();
	}

	return FALSE;
}

void CMultiViewCtrl::DestroyProgressDlgWindow()
{
	if (::IsWindow(m_pProgressDlg->m_hWnd) && m_pProgressDlg->GetSafeHwnd())
	{
		m_pProgressDlg->DestroyWindow();
		PostModalDialog();
	}
}

void CMultiViewCtrl::PumpMessagesProgressDlgWindow()
{
	if (::IsWindow(m_pProgressDlg->m_hWnd) && m_pProgressDlg->GetSafeHwnd())
	{
		m_pProgressDlg->PumpMessages();
	}
}

void CMultiViewCtrl::ViewClassInstancesAsync(LPCTSTR lpszClassName)
{
	if (lpszClassName == NULL || lpszClassName[0] == '\0' || !m_pServices)
	{
		return;
	}



	CString csPath = lpszClassName;

	IWbemClassObject *pimcoClass = NULL;

	SCODE sc;

	pimcoClass = GetClassFromAnyNamespace(csPath);
	if (!pimcoClass)
	{
		InitializeDisplay(NULL,NULL,NULL);
		CString csUserMsg;
		csUserMsg =  _T("Cannot get class object ") + csPath;
		ErrorMsg
				(&csUserMsg, m_sc, FALSE, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 9);
		return;
	}


	CString csClass;

	BOOL bDiffNS =
		ObjectInDifferentNamespace
			(m_pServices, &m_csNameSpace, pimcoClass);

	IWbemServices *pServices;

	if (bDiffNS)
	{
		CString csNameSpace =
			GetObjectNamespace (m_pServices, pimcoClass);
		pServices = InitServices(&csNameSpace);

		if (!pServices)
		{
			InitializeDisplay(NULL,NULL,NULL);
			CString csUserMsg;
			csUserMsg =  _T("Cannot connect to namespace ") + csNameSpace;
			ErrorMsg
				(&csUserMsg, m_sc, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 9);
			pimcoClass->Release();
			return;
		}
		csClass = GetIWbemClass(pServices ,pimcoClass);
	}
	else
	{
		csClass = GetIWbemClass(m_pServices ,pimcoClass);
	}

	m_csaProps.RemoveAll();

	int nProps = GetSortedPropNames (pimcoClass, m_csaProps, m_cmstpPropFlavors);
	pimcoClass -> Release();

	m_csClass = csClass;
	m_nClassOrInstances = CLASS;
	InitializeDisplay(&csClass, NULL, &m_csaProps, NULL, &m_cmstpPropFlavors);


	m_pcaedDialog->SetClass(&csClass);
	BOOL bCancel = FALSE;
	sc = GetInstancesAsync
		(bDiffNS? pServices: m_pServices, &csClass);

	if (bDiffNS)
	{
		pServices->Release();
	}
}


SCODE CMultiViewCtrl::ViewInstances(LPCTSTR szTitle, const VARIANT FAR& varPathArray)
{
	//
	// There are two things that ViewInstances needs to do to work
	// properly with the new view interface:
	//
	// 1. The container now passes the call to ViewInstances though immediately
	//    rather than waiting till the multiview is made visible.  This means
	//    that CMultiViewCtrl needs to check to see if the multiview control
	//    is currently hidden. If so, ViewInstances should a) save the parameter values
	//    somewhere and b) set itself to an "empty" state, and c) when NotifyDidShow is
	//    called, load the instances into the multiview.
	//
	// 2. The container now passes the title though to the multiview.  The multiview
	//     needs to make this available through the GetTitle method.
	//


	if (!((varPathArray.vt == (VT_ARRAY | VT_BSTR)) ||
		(varPathArray.vt == (VT_VARIANT | VT_BYREF))))
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	m_pcmvcCurrentContext->~CMVContext();

	m_pcmvcCurrentContext->AddRef();
	m_pcmvcCurrentContext->GetType() = CMVContext::Instances;
	m_pcmvcCurrentContext->GetLabel() = szTitle;
	m_pcmvcCurrentContext->GetNamespace() = m_csNameSpace;


	CStringArray csaPaths;
	CStringArray csaClasses;
	CPtrArray cpaInstances;

	SAFEARRAY *psaPaths = NULL;

	if (varPathArray.vt == (VT_VARIANT | VT_BYREF))
	{
		if (varPathArray.pvarVal->vt == (VT_ARRAY | VT_VARIANT))
		{
			psaPaths = varPathArray.pvarVal->parray;
		}
	}
	else
	{
		psaPaths = varPathArray.parray;
	}
	long ix[2] = {0,0};
	long lLower, lUpper;

	int iDim = SafeArrayGetDim(psaPaths );
	int i;
	SCODE sc = SafeArrayGetLBound(psaPaths,1,&lLower);
	sc = SafeArrayGetUBound(psaPaths,1,&lUpper);

	for(ix[0] = lLower, i = 0; ix[0] <= lUpper; ix[0]++, i++)
	{

		CString csPath;
		BSTR bstrPath;
		if (varPathArray.pvarVal->vt == (VT_ARRAY | VT_VARIANT))
		{
			VARIANT var;
			VariantInit(&var);
			sc = SafeArrayGetElement(psaPaths,ix,&var);

			if (SUCCEEDED(sc))
			{
				VARIANTARG varChanged;
				VariantInit(&varChanged);

				sc = VariantChangeType(&varChanged, &var, 0, VT_BSTR);
				VariantClear(&var);
				if (SUCCEEDED(sc))
				{
					bstrPath = varChanged.bstrVal;
					VariantClear(&varChanged);
				}
			}

		}
		else
		{
			sc = SafeArrayGetElement(psaPaths,ix,&bstrPath);
		}

		if (SUCCEEDED(sc))
		{
			csPath = bstrPath;
			m_pcmvcCurrentContext->GetInstances().Add(csPath);
			SysFreeString(bstrPath);
		}
	}



	if (IsWindowVisible())
	{
		NotifyWillShow();
	}

	return S_OK;


}

SCODE CMultiViewCtrl::ViewInstancesInternal
(LPCTSTR szTitle, CStringArray &rcsaPathArray)
{

	CString csTitle = szTitle;

//	CWaitCursor wait;

	CString csMessage =
		csTitle + _T(" instances.");

	SetProgressDlgMessage(csMessage);

	if (!m_pProgressDlg->GetSafeHwnd())
	{
		 CreateProgressDlgWindow();
	}

	CStringArray csaPaths;
	CStringArray csaClasses;
	CPtrArray cpaInstances;

	IWbemClassObject *pimcoClass = NULL;

	int i;
	for (i = 1; i < rcsaPathArray.GetSize(); i++)
	{
		PumpMessagesProgressDlgWindow();
		CString csPath = rcsaPathArray.GetAt(i);
		IWbemClassObject *pimcoObject = NULL;

		BSTR bstrTemp = csPath.AllocSysString();
#ifdef _DEBUG
//	afxDump << "GetObject in ViewInstancesInternal for " << csPath << "\n";
#endif
		SCODE sc;

		if (csPath.GetLength() == 0)
		{
			sc = E_FAIL;
		}
		else
		{
			sc =
				m_pServices -> GetObject(bstrTemp,0, NULL,
							&pimcoObject,NULL);
		}

		::SysFreeString(bstrTemp);

		CString csClass;
		if (sc == S_OK)
		{
			PumpMessagesProgressDlgWindow();
			csClass = GetIWbemClassPath(m_pServices ,pimcoObject);
			csaPaths.Add(csPath);
			cpaInstances.Add(pimcoObject);
			if (!ClassInClasses(&csaClasses,&csClass))
			{
				csaClasses.Add(csClass);
			}
		}
		else
		{
			PumpMessagesProgressDlgWindow();
		}
	}


	if (csaClasses.GetSize() > 0)
	{
		pimcoClass = CommonParent(&csaClasses);
	}
	else
	{
		pimcoClass = NULL;
	}

	if (pimcoClass == NULL)
	{
		DestroyProgressDlgWindow();
		m_nClassOrInstances = INSTANCES;
		m_csClass.Empty();
		InitializeDisplay(NULL,NULL,NULL);
		CString csUserMsg;
		csUserMsg =  _T("Cannot get a common parent ");
		PreModalDialog();
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 13);
		PostModalDialog();
		CString csMessage = _T("No Instances Available");
		m_nClassOrInstances = NONE;
		m_csClass.Empty();
		InitializeDisplay(NULL,NULL,NULL,&csMessage);
		return S_OK;
	}

	m_csaProps.RemoveAll();
	int nProps = GetSortedPropNames (pimcoClass, m_csaProps, m_cmstpPropFlavors);

	CString csClass = GetIWbemClass(m_pServices,pimcoClass);
	pimcoClass -> Release();
	m_nClassOrInstances = INSTANCES;
	m_csClass.Empty();


	DestroyProgressDlgWindow();
	InitializeDisplay(&csClass, &cpaInstances, &m_csaProps, NULL, &m_cmstpPropFlavors);

	return S_OK;

}

BOOL CMultiViewCtrl::IsColVisible(long lFilter, long lFlavor)
{

	BOOL bLocal = (lFilter & PROPFILTER_LOCAL) && (lFlavor == WBEM_FLAVOR_ORIGIN_LOCAL);

	if (bLocal)
	{
		return TRUE;
	}

	BOOL bSystem = (lFilter & PROPFILTER_SYSTEM) && (lFlavor == WBEM_FLAVOR_ORIGIN_SYSTEM);

	if (bSystem)
	{
		return TRUE;
	}

	BOOL bPropagated = (lFilter & PROPFILTER_INHERITED) && (lFlavor == WBEM_FLAVOR_ORIGIN_PROPAGATED);

	if (bPropagated)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}

}

void CMultiViewCtrl::SetAllColVisibility( CStringArray *pcsaProps, CMapStringToPtr *pcmstpPropFlavors)
{
	long *plFlavor;

	BOOL bReturn;

	for (int i = 0; i < pcsaProps->GetSize(); i++)
	{
		bReturn = m_cmstpPropFlavors.Lookup((LPCTSTR) pcsaProps->GetAt(i),(void *&) plFlavor);

		// NOTE: Win64- the m_cmstpPropFlavors was really only using the lower 32 bits to store the flavor
		long lFlavor = (DWORD)(DWORD_PTR)plFlavor;

		BOOL bVisible;
		if (bReturn)
		{
			bVisible = IsColVisible(m_lPropFilterFlags, lFlavor);
		}
		else
		{
			bVisible = TRUE;
		}
		m_cgGrid.SetColVisibility(i, bVisible);
	}
}

void CMultiViewCtrl::InitializeDisplay
(CString *pcsClass, CPtrArray *pcpaInstances, CStringArray *pcsaProps,
 CString *pcsMessage, CMapStringToPtr *pcmstpPropFlavors)
{

//	CWaitCursor cwcWait;
	int i;

	// Delete stored paths
	int nRows = m_cgGrid.GetRows();
	for (i = 0; i < nRows; i++)
	{
		CString *pcsPath =
			reinterpret_cast<CString *>
				(m_cgGrid.GetAt(i, 0).GetTagValue());
		delete pcsPath;
	}

	int n = m_cgGrid.GetCols();

	if (n > 1)
	{
		for (int i = 0; i < n; i++)
		{
			m_cgGrid.m_cwaColWidth.SetAtGrow(i,(WORD)m_cgGrid.ColWidthFromHeader(i));
		}

	}

	// Clear the grid
	m_cgGrid.Clear();

	if (pcsaProps == NULL && pcsMessage == NULL)
	{
		InvalidateControl();
		m_cgGrid.RedrawWindow();
		return;
	}

	if (pcsMessage)
	{
		InitializeDisplayMessage(pcsMessage);
		return;

	}

	int nCols = (int) pcsaProps -> GetSize();
	nRows = pcpaInstances? (int) pcpaInstances -> GetSize(): 0;



	// Row columns

	int nColSave = 	(int) m_cgGrid.m_cwaColWidth.GetSize();

	for (i = 0; i < nCols; i++)
	{
		int nColWidth = 100;
		if ( i < nColSave)
		{
			nColWidth = m_cgGrid.m_cwaColWidth.GetAt(i);

		}

		m_cgGrid.AddColumn(nColWidth, pcsaProps -> GetAt(i));
	}

	SetAllColVisibility(pcsaProps,pcmstpPropFlavors);

	for (i = 0; i < nRows; i++)
	{
		IWbemClassObject *pimcoInstance =
			reinterpret_cast<IWbemClassObject *>
				(pcpaInstances -> GetAt(i));
		m_cgGrid.AddRow();
		CString *pcsPath =
			new CString(GetIWbemFullPath(m_pServices,pimcoInstance));
		(m_cgGrid.GetAt(i, 0).SetTagValue
			(reinterpret_cast<DWORD_PTR>(pcsPath)));
		VARIANT var;
		for (int k = 0; k < nCols; k++)
		{
			CIMTYPE cimtype;
			GetPropertyAsVariant( pimcoInstance,&pcsaProps -> GetAt(k),var, cimtype);

			m_cgGrid.GetAt(i,k).SetValue(CELLTYPE_VARIANT, var, cimtype);
				m_cgGrid.GetAt(i,k).SetFlags(CELLFLAG_READONLY,CELLFLAG_READONLY);
			VariantClear(&var);
		}
		pimcoInstance -> Release();

		CString *pcsStoredPath =
			reinterpret_cast<CString *>
				(m_cgGrid.GetAt(i, 0).GetTagValue());
	}

	m_cgGrid.CheckForSelectionChange();

	SetModifiedFlag();

	// 5-2-97 removed per Cori's usggestion.
	// Sort the grid using column zero as the primary key.
	//if (m_cgGrid.GetRows() > 0) {
	//	m_cgGrid.SortGrid(0, m_cgGrid.GetRows()-1, 0);
	//}

	InvalidateControl();
	m_cgGrid.RedrawWindow();

}

LRESULT CMultiViewCtrl::DisplayAsyncQueryInstances(WPARAM, LPARAM)
{

	if (m_cpaInstancesForQuery.GetSize() == 0)
	{
		return 0;
	}

	CStringArray csaPaths;
	CStringArray csaClasses;


	int i;

	for (i = 0; i < m_cpaInstancesForQuery.GetSize(); i++)
	{
		IWbemClassObject *pObject =
			reinterpret_cast<IWbemClassObject *>
				(m_cpaInstancesForQuery.GetAt(i));

		CString csClass = GetIWbemClass(m_pServices ,pObject);

		if (!ClassInClasses(&csaClasses,&csClass))
		{
			csaClasses.Add(csClass);
		}

	}

	IWbemClassObject *pClass = CommonParent(&csaClasses);

	if (pClass == NULL)
	{
		m_nClassOrInstances = INSTANCES;
		m_csClass.Empty();
		InitializeDisplay(NULL,NULL,NULL);
		CString csUserMsg;
		csUserMsg =  _T("Cannot get a common parent ");
		ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 13);
		return 0;
	}

	m_csaProps.RemoveAll();
	int nProps = GetSortedPropNames (pClass, m_csaProps, m_cmstpPropFlavors);

	CString csClass = GetIWbemClass(m_pServices,pClass);
	pClass -> Release();
	m_nClassOrInstances = INSTANCES;
	m_csClass.Empty();
	InitializeDisplay(NULL, &m_cpaInstancesForQuery, &m_csaProps, NULL, &m_cmstpPropFlavors);
	m_cpaInstancesForQuery.RemoveAll();

	return 0;
}

void CMultiViewCtrl::AddToDisplay(CPtrArray *pcpaInstances)
{

	if (m_pAsyncEnumCancelled == TRUE || m_pAsyncQueryCancelled == TRUE)
	{
		return;
	}

	int nLastRow = m_cgGrid.GetRows();
	int nNewRows = (int) pcpaInstances->GetSize();
	int nCols = (int) m_csaProps.GetSize();
	int i;
	int n = nLastRow;

	for (i = 0; i < nNewRows; i++)
	{
		IWbemClassObject *pimcoInstance =
			reinterpret_cast<IWbemClassObject *>
				(pcpaInstances -> GetAt(i));
		if (pimcoInstance == NULL) {
			continue;
		}

		m_cgGrid.AddRow();
		int nNow = m_cgGrid.GetRows();

		CString *pcsPath = new CString(GetIWbemFullPath (m_pServices,pimcoInstance));

		m_cgGrid.GetAt(n, 0).SetTagValue (reinterpret_cast<DWORD_PTR>(pcsPath));

		VARIANT var;
		for (int k = 0; k < nCols; k++)
		{
			CIMTYPE cimtype;
			GetPropertyAsVariant( pimcoInstance,&m_csaProps.GetAt(k),var, cimtype);
			m_cgGrid.GetAt(n,k).SetValue(CELLTYPE_VARIANT, var, cimtype);
				m_cgGrid.GetAt(n,k).SetFlags(CELLFLAG_READONLY,CELLFLAG_READONLY);
			VariantClear(&var);
		}

		pimcoInstance -> Release();

		CString *pcsStoredPath =
			reinterpret_cast<CString *>
				(m_cgGrid.GetAt(n, 0).GetTagValue());
		n++;
	}
	m_cgGrid.CheckForSelectionChange();

	SetModifiedFlag();

	// 5-2-97 removed per Cori's usggestion.
	// Sort the grid using column zero as the primary key.
//	if (m_cgGrid.GetRows() > 0) {
//		m_cgGrid.SortGrid(0, m_cgGrid.GetRows()-1, 0);
//	}

	InvalidateControl();
	m_cgGrid.RedrawWindow();
}

void CMultiViewCtrl::InitializeDisplayMessage
(CString *pcsMessage)
{

	PumpMessagesProgressDlgWindow();
	CString *pcsTitle = new CString(_T("  "));
	m_cgGrid.AddColumn(500,*pcsTitle);

	m_cgGrid.AddRow();
	(m_cgGrid.GetAt(0, 0).SetTagValue
			(reinterpret_cast<DWORD_PTR>(pcsTitle)));
	VARIANT var;
	VariantInit(&var);
	var.vt = VT_BSTR;
	var.bstrVal = pcsMessage->AllocSysString();
	m_cgGrid.GetAt(0,0).SetValue(CELLTYPE_VARIANT, var, CIM_STRING);
	m_cgGrid.GetAt(0,0).SetFlags(CELLFLAG_READONLY,CELLFLAG_READONLY);
	VariantClear(&var);


	SetModifiedFlag();
	InvalidateControl();
	m_cgGrid.RedrawWindow();

}

IWbemClassObject *CMultiViewCtrl::ParentFromDerivations(CStringArray **pcsaDerivation, int nDerivation)
{
	//Search from the end of the derivations until they do not match.

	// Make sure all the derivations end in the same class
	int i;

	int *nEndIndex = new int[nDerivation];

	nEndIndex[0] = ((int) pcsaDerivation[0]->GetSize()) - 1;
	CString csTest1 = pcsaDerivation[0]->GetAt(nEndIndex[0]);

	int nMaxDerivation = (int) pcsaDerivation[0]->GetSize();
	int nLongestDerivationIndex = 0;

	for (i = 0; i < nDerivation; i++)		//zina: changed to 0
	{
		int n = (int) pcsaDerivation[i]->GetSize();
		if (n > nMaxDerivation)
		{
			nMaxDerivation = n;
			nLongestDerivationIndex = i;
		}

		nEndIndex[i] = ((int) pcsaDerivation[i]->GetSize()) - 1;
		if (csTest1.CompareNoCase(pcsaDerivation[i]->GetAt(nEndIndex[i])) != 0)
		{
			delete [] nEndIndex;
			return FALSE;
		}
	}

	// All derivations are length of one and must be the same if we are here.
	if (nEndIndex[nLongestDerivationIndex] == 1)
	{
		BSTR bstrTemp = csTest1.AllocSysString();
		IWbemClassObject *pObject = NULL;
		SCODE sc =
		m_pServices ->
			GetObject(bstrTemp,0, NULL, &pObject,NULL);

		::SysFreeString(bstrTemp);

		if (!SUCCEEDED(sc))
		{
			delete [] nEndIndex;
			return NULL;
		}
		else
		{
			delete [] nEndIndex;
			return pObject;
		}
	}

	BOOL bDone = FALSE;
	CString csSave = csTest1;

	while(!bDone)
	{
		if (nEndIndex[nLongestDerivationIndex] - 1 < 0)
		{
			bDone = TRUE;
			break;
		}

		csSave = csTest1;
		csTest1 = pcsaDerivation[nLongestDerivationIndex]->GetAt(nEndIndex[nLongestDerivationIndex] - 1);

		for (i = 0; i < nDerivation; i++)
		{
			nEndIndex[i]--;
			// Two things end the search

			// 1) No more classes in a derivation
			if (nEndIndex[i] < 0)
			{
				bDone = TRUE;
				break;
			}

			// 2) The derivations do not match
			if (csTest1.CompareNoCase(pcsaDerivation[i]->GetAt(nEndIndex[i])) != 0)
			{
				bDone = TRUE;
				break;
			}
		}
	}


	BSTR bstrTemp = csSave.AllocSysString();
	IWbemClassObject *pObject = NULL;
	SCODE sc =
	m_pServices ->
		GetObject(bstrTemp,0, NULL, &pObject,NULL);

	::SysFreeString(bstrTemp);

	if (!SUCCEEDED(sc))
	{
		delete [] nEndIndex;
		return NULL;
	}
	else
	{
		delete [] nEndIndex;
		return pObject;
	}

}

IWbemClassObject *CMultiViewCtrl::LowestCommonParent(CStringArray *pcsaPaths)
{
	int n = (int) pcsaPaths->GetSize();

	CStringArray **pcsaDerivation = new CStringArray *[n];

	//try to get derivation array for each class
	for (int i = 0, k = 0; i < n; i++)
	{
		pcsaDerivation[k] = NULL;

		CStringArray * pDeriv = ClassDerivation(m_pServices, pcsaPaths->GetAt(i));

		//if we could get derivation for this class:
		if (pDeriv != NULL && pDeriv->GetSize() > 0) {
			pcsaDerivation[k] = pDeriv;
			k++;
		}
	}



	IWbemClassObject *pParent = ParentFromDerivations(pcsaDerivation,k);


	for (i = 0; i < k; i++)
	{
		delete pcsaDerivation[i];
	}

	delete [] pcsaDerivation;

	return pParent;

}

IWbemClassObject * CMultiViewCtrl::CommonParent(CStringArray *pcsaPaths)
{
	 if (pcsaPaths -> GetSize() == 0)
	 {
		return NULL;
	 }

	 if (pcsaPaths -> GetSize() == 1)
	 {
		IWbemClassObject *pimcoClass = NULL;

		pimcoClass = GetClassFromAnyNamespace(pcsaPaths -> GetAt(0));
		if (pimcoClass)
		{
			return pimcoClass;
		}
		else
		{
			return NULL;
		}
	 }

	return LowestCommonParent(pcsaPaths);

}

BOOL CMultiViewCtrl::ClassInClasses(CStringArray *pcsaClasses, CString *pcsParent)
{
	for (int i = 0; i < pcsaClasses -> GetSize();i++)
	{
		if (pcsParent -> CompareNoCase(pcsaClasses -> GetAt(i)) == 0)
		{
			return TRUE;
		}
	}
	return FALSE;

}


void CMultiViewCtrl::ForceRedraw()
{
	InvalidateControl();

}

SCODE CMultiViewCtrl::GetInstancesAsync
(IWbemServices * pIWbemServices, CString *pcsClass)
{

	m_pServicesForAsyncSink = pIWbemServices;
	m_csClassForAsyncSink = *pcsClass;

	m_pAsyncEnumCancelled = FALSE;
	m_pAsyncQueryCancelled = FALSE;
	m_pAsyncEnumRunning = TRUE;

	PostMessage(ID_ENUM_DOMODAL , 0,0);
	PostMessage(ID_GETASYNCINSTENUMSINK,0,0);



	return WBEM_NO_ERROR;

}



void CMultiViewGrid::OnCellDoubleClicked(int iRow, int iCol)
{

	if (m_pParent -> m_nClassOrInstances == CMultiViewCtrl::NONE ||
		m_pParent -> m_nClassOrInstances == CMultiViewCtrl::ZERO_CLASS_INST)
	{
		return;
	}


	CString *pcsPath =
		reinterpret_cast<CString *>
			(GetAt(iRow, 0).GetTagValue());
	if (pcsPath)
	{
		CheckForSelectionChange();
		m_pParent ->FireNotifyViewObjectSelected((LPCTSTR) *pcsPath);
	}


}


void CMultiViewGrid::OnRequestUIActive()
{
	m_pParent->OnRequestUIActive();
}


//************************************************************
// CMultiViewGrid::CheckForSelectionChange
//
// Check to see if the grid's row selection changed.  If so,
// fire the SelectionChanged event.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//************************************************************
void CMultiViewGrid::CheckForSelectionChange()
{
	int iRow;

	if (m_pParent->m_bSelectionNotChanging)
	{
		return;
	}


	if (m_pParent -> m_nClassOrInstances == CMultiViewCtrl::NONE ||
		m_pParent -> m_nClassOrInstances == CMultiViewCtrl::ZERO_CLASS_INST)
	{
		return;
	}

	iRow = GetSelectedRow();
	m_pParent->FireNotifySelectionChanged();
	m_iSelectedRow = iRow;

}


//***********************************************************
// CMultiViewGrid::OnRowHandleDoubleClicked
//
// The CGrid base class calls this method when a row handle
// is double clicked.  When this happens, fire the "ViewObject"
// event.
//
// Parameters:
//		[in] int iRow
//
// Returns:
//		Nothing.
//
//************************************************************
void CMultiViewGrid::OnRowHandleDoubleClicked(int iRow)
{

	if (m_pParent -> m_nClassOrInstances == CMultiViewCtrl::NONE ||
		m_pParent -> m_nClassOrInstances == CMultiViewCtrl::ZERO_CLASS_INST)
	{
		return;
	}

	CString *pcsPath =
		reinterpret_cast<CString *>
			(GetAt(iRow, 0).GetTagValue());
	if (pcsPath)
	{
		CheckForSelectionChange();
		m_pParent -> FireNotifyViewObjectSelected((LPCTSTR) *pcsPath);
	}
}



void CMultiViewGrid::SetRowEditFlag(int nRow, BOOL bEdit)
{

}

void CMultiViewGrid::OnCellClicked(int iRow, int iCol)
{
	if(m_iSelectedRow != GetSelectedRow())
		CheckForSelectionChange();
}

void CMultiViewGrid::OnSetToNoSelection()
{
	m_pParent->FireNotifySelectionChanged();
	SyncSelectionIndex();
}


void CMultiViewGrid::OnRowHandleClicked(int iRow)
{
	SelectRow(iRow);
	CheckForSelectionChange();
}


//**********************************************************************
// CMultiViewGrid::OnHeaderItemClick
//
// Catch the "header item clicked" notification message by overriding
// the base class' virtual method.
//
// Parameters:
//		int iColumn
//			The index of the column that was clicked.
//
// Returns:
//		Nothing.
//
//***********************************************************************
void CMultiViewGrid::OnHeaderItemClick(int iColumn)
{

	int iLastRow = GetRows()-1;
	if (iLastRow > 0) {
		SortGrid(0, iLastRow, iColumn);
		BOOL bAscending = ColumnIsAscending(iColumn);
		SetHeaderSortIndicator(iColumn, bAscending);
		RedrawWindow();
	}
}



//*******************************************************************
// CMultiViewGrid::CompareRows
//
// This is a virtual method override that compares two rows in the grid
// using the column index as the sort criteria.
//
// Parameters:
//		int iRow1
//			The index of the first row.
//
//		int iRow2
//			The index of the second row.
//
//		int iSortColumn
//			The column index.
//
// Returns:
//		>0 if row 1 is greater than row 2
//		0  if row 1 equal zero
//		<0 if row 1 is less than zero.
//
//********************************************************************
int CMultiViewGrid::CompareRows(int iRow1, int iRow2, int iSortColumn)
{
	// First do a row comparison using the specified column as the
	// primary key.
	int iResult;
	iResult = CompareCells(iRow1, iSortColumn, iRow2, iSortColumn);
	if (iResult != 0) {
		// The primary keys were not equal, so we have the result already.
		return iResult;
	}


	// Control comes here if the primary keys were identical.  Now we must
	// compare the other columns to establish a sort order.  To do this
	// we iterate through all of the columns from left to right until
	// we encounter a column that differentiates the two rows.
	int nCols = GetCols();
	for (int iCol=0; iCol < nCols; ++iCol) {
		if (iCol == iSortColumn) {
			// We already know these two columns are equal, so there is
			// no sense in comparing them again.
			continue;
		}
		iResult = CompareCells(iRow1, iCol, iRow2, iCol);
		if (iResult != 0) {
			break;
		}
	}

	return iResult;
}

BSTR CMultiViewCtrl::GetNameSpace()
{
	return m_csNameSpace.AllocSysString();
}

void CMultiViewCtrl::SetNameSpace(LPCTSTR lpszNewValue)
{
	// TODO: Add your property handler here
	if (GetSafeHwnd() && AmbientUserMode())
	{
		m_csNamespaceToInit = lpszNewValue;
		OpenNamespace(0,0);
	}
	else if (GetSafeHwnd() && !AmbientUserMode())
	{
		m_csNameSpace = lpszNewValue;
		SetModifiedFlag();
	}

}

LRESULT CMultiViewCtrl::OpenNamespace(WPARAM, LPARAM)
{
	CString csNameSpace = m_csNamespaceToInit;
	m_csNamespaceToInit.Empty();

	IWbemServices *pServices = InitServices(&csNameSpace);

	if (pServices)
	{
		if (m_pServices)
		{
			m_pServices -> Release();
		}
		m_pServices = pServices;
		m_csNameSpace = csNameSpace;
	}



	InitializeDisplay
		(NULL, NULL, NULL);
	SetModifiedFlag();
	InvalidateControl();

	return 0;
}






int CMultiViewCtrl::ObjectInGrid(CString *pcsPathIn)
{

	int nNumRows = m_cgGrid.GetRows();
	for (int i = 0; i < nNumRows; i++)
	{
		CString *pcsPath =
			reinterpret_cast<CString *>
				(m_cgGrid.GetAt(i, 0).GetTagValue());
		if (pcsPath->CompareNoCase(*pcsPathIn) == 0)
		{
			return i;
		}
	}
	return -1;
}



long CMultiViewCtrl::SelectObjectByPath(LPCTSTR szObjectPath)
{
	CString csPathIn = szObjectPath;

	int nRow = ObjectInGrid(&csPathIn);

	if (nRow > -1)
	{
		m_cgGrid.SelectRow(nRow);
		m_cgGrid.CheckForSelectionChange();
		InvalidateControl();
		return S_OK;
	}
	else
	{
		return WBEM_E_NOT_FOUND;
	}

}

//******************************************************
// CMultiViewGrid::IsNoInstanceRow
//
// This method checks to see if the specified row is
// the "No Instances Available" row.  This special case
// occurs when the grid is logically empty, but this
// special row exists anyway so that the user sees that
// there are no instances.
//
// Parameters:
//		[in] iRow
//			The index of the row to test.
//
// Returns:
//		TRUE if the specified row is the "No Instance Available"
//		row, FALSE otherwise.
//
//*******************************************************
BOOL CMultiViewGrid::IsNoInstanceRow(int iRow)
{
	if (iRow >= 0) {
		CString *pcsPath =
		reinterpret_cast<CString *>
			(GetAt(iRow, 0).GetTagValue());
		pcsPath->TrimRight();
		if (pcsPath->IsEmpty())
		{
			return TRUE;
		}
	}
	return FALSE;
}


BOOL CMultiViewGrid::OnRowKeyDown
	(int iRow,UINT nChar,  UINT nRepCnt,  UINT nFlags)
{
	CWnd* pwndFocus = GetFocus();

	switch(nChar) {
	case VK_DELETE:
		{
			if (!m_pParent->m_bCanEdit)
			{
				MessageBeep(MB_ICONEXCLAMATION);
				if (pwndFocus && ::IsWindow(pwndFocus->m_hWnd)) {
					pwndFocus->SetFocus();
				}
				return TRUE;
			}
			int nRow = GetSelectedRow();
			CString *pcsPath =
			reinterpret_cast<CString *>
				(GetAt(nRow, 0).GetTagValue());
			pcsPath->TrimRight();
			if (pcsPath->IsEmpty())
			{
				return TRUE;
			}


			long lPos;
			CString sTitle;
			lPos = m_pParent->StartObjectEnumeration(OBJECT_CURRENT);
			if (lPos >= 0) {
				sTitle = m_pParent->GetObjectTitle(lPos);
			}
			else {
				ASSERT(FALSE);
				sTitle = *pcsPath;
			}

			CString csPrompt;
			csPrompt = _T("Do you want to delete \"") + sTitle;
			csPrompt += _T("\"?");
			int nReturn =
				m_pParent -> MessageBox
				(
				csPrompt,
				_T("Deleting an Instance"),
				MB_YESNO  | MB_ICONQUESTION | MB_DEFBUTTON1 |
				MB_APPLMODAL);
			if (pwndFocus && ::IsWindow(pwndFocus->m_hWnd)) {
				pwndFocus->SetFocus();
			}

			if (nReturn == IDYES)
			{
				SCODE sc;

				BSTR bstrTemp = pcsPath -> AllocSysString();
				sc =  m_pParent->m_pServices ->
					DeleteInstance(bstrTemp, NULL, 0, NULL);
				::SysFreeString(bstrTemp);

				if (sc != S_OK)
				{
					CString csUserMsg =
									_T("Cannot delete instance ") + *pcsPath;

					ErrorMsg
						(&csUserMsg, sc, TRUE,
						TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
					if (pwndFocus && ::IsWindow(pwndFocus->m_hWnd)) {
						pwndFocus->SetFocus();
					}
					return TRUE;
				}
				m_pParent->ExternInstanceDeleted((LPCTSTR) *pcsPath);
			}
		}
		return TRUE;
	}


	// We don't handle this event.
	return FALSE;
}

LRESULT CMultiViewCtrl::DisplayNoInstances(WPARAM, LPARAM)
{
	CString csMessage = _T("No Instances Available");
	InitializeDisplay(NULL,NULL,NULL,&csMessage);

	return 0;
}

LRESULT CMultiViewCtrl::InstEnumDone(WPARAM, LPARAM)
{
	PostMessage(ID_ASYNCENUM_DONE,0,0);

	m_pAsyncEnumRunning = FALSE;


	return 0;
}

LRESULT CMultiViewCtrl::QueryDone(WPARAM, LPARAM)
{

	PostMessage(ID_ASYNCQUERY_DONE,0,0);

	m_pAsyncQueryRunning = FALSE;

	return 0;
}

LRESULT CMultiViewCtrl::EnumDoModalDialog(WPARAM, LPARAM)
{
	CWnd* pwndFocus = GetFocus();

	m_pcaedDialog->DoModal();

	if (pwndFocus && ::IsWindow(pwndFocus->m_hWnd)) {
		pwndFocus->SetFocus();
	}
	return 0;
}

LRESULT CMultiViewCtrl::SyncEnumDoModalDialog(WPARAM, LPARAM)
{
	CWnd* pwndFocus = GetFocus();

	m_pcsedDialog->DoModal();
	if (pwndFocus && ::IsWindow(pwndFocus->m_hWnd)) {
		pwndFocus->SetFocus();
	}

	return 0;
}

LRESULT CMultiViewCtrl::QueryDoModalDialog(WPARAM, LPARAM)
{
	CWnd* pwndFocus = GetFocus();

	m_pcaqdDialog->DoModal();

	if (pwndFocus && ::IsWindow(pwndFocus->m_hWnd)) {
		pwndFocus->SetFocus();
	}

	return 0;
}

LRESULT CMultiViewCtrl::AsyncEnumCancelled(WPARAM, LPARAM)
{
	m_pAsyncEnumCancelled = TRUE;

	if (m_pAsyncEnumRunning)
	{
		m_pAsyncEnumRunning = FALSE;

	}

	CString csMessage = _T("Instance retrieval operation cancelled");
	InitializeDisplay(NULL,NULL,NULL,&csMessage);

	theApp.DoWaitCursor(-1);


	return 0;
}

LRESULT CMultiViewCtrl::AsyncQueryCancelled(WPARAM, LPARAM)
{
	m_pAsyncQueryCancelled = TRUE;

	if (m_pAsyncQueryRunning)
	{
		m_pAsyncQueryRunning = FALSE;

	}

	CString csMessage = _T("Instance retrieval operation cancelled");
	InitializeDisplay(NULL,NULL,NULL,&csMessage);

	for (int i = 0; i < m_cpaInstancesForQuery.GetSize(); i++)
	{
		IWbemClassObject *pObject =
			reinterpret_cast<IWbemClassObject *>
				(m_cpaInstancesForQuery.GetAt(i));
		pObject->Release();

	}

	m_cpaInstancesForQuery.RemoveAll();


	theApp.DoWaitCursor(-1);


	return 0;
}

LRESULT CMultiViewCtrl::GetEnumSink(WPARAM, LPARAM)
{
	CWnd* pwndFocus = GetFocus();
	m_pInstEnumObjectSink = new CAsyncInstEnumSink(this);


#ifdef _DEBUG
	ASSERT(m_pInstEnumObjectSink);
#endif

	if (!m_pInstEnumObjectSink)
	{
		return FALSE;

	}

	m_pInstEnumObjectSink->AddRef();


	m_nInstances = 0;

	BSTR bstrTemp = m_csClass.AllocSysString();
	SCODE sc = m_pServices->CreateInstanceEnumAsync
		(bstrTemp,
		WBEM_FLAG_DEEP | WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
		NULL,
		(IWbemObjectSink *) m_pInstEnumObjectSink );
	::SysFreeString(bstrTemp);



#ifdef _DEBUG
	ASSERT(sc == S_OK);
#endif

	if(sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Ascyronous instance enumeration failed for class: ") + m_csClass;
		ErrorMsg
				(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__);
		if (pwndFocus && ::IsWindow(pwndFocus->m_hWnd)) {
			pwndFocus->SetFocus();
		}

		m_pInstEnumObjectSink->Release();
		return FALSE;
	}

	return S_OK;
}

LRESULT CMultiViewCtrl::GetQuerySink(WPARAM, LPARAM)
{
	CWnd* pwndFocus = GetFocus();
	m_pAsyncQuerySink = new CAsyncQuerySink(this);


	if (!m_pAsyncQuerySink)
	{
		return FALSE;
	}

	m_pAsyncQuerySink->AddRef();


	m_nInstances = 0;


	BSTR bstrTemp1 = m_csQueryTypeForAsyncSink.AllocSysString();
	BSTR bstrTemp2 = m_csQueryForAsyncSink.AllocSysString();
	SCODE sc = m_pServices->
				ExecQueryAsync
				(	bstrTemp1,
					bstrTemp2,
					0,
					NULL,
					(IWbemObjectSink *) m_pAsyncQuerySink);
	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);


	if(sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Ascyronous query failed for query: ") + m_csQueryForAsyncSink;
		ErrorMsg
				(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__);

		m_pAsyncQuerySink->Release();
		if (pwndFocus && ::IsWindow(pwndFocus->m_hWnd)) {
			pwndFocus->SetFocus();
		}

		return FALSE;
	}

	return S_OK;
}


BOOL CMultiViewCtrl::PreTranslateMessage(MSG* pMsg)
{
	// TODO: Add your specialized code here and/or call the base class
	if (pMsg->message == ID_DISPLAYNOINSTANCES)
	{
		DisplayNoInstances(0,0);
		return TRUE;
	}

	if (pMsg->message == ID_INSTENUMDONE)
	{
		InstEnumDone(0,0);
		return TRUE;
	}

	if (pMsg->message == ID_QUERYDONE)
	{
		QueryDone(0,0);
		return TRUE;
	}


	return COleControl::PreTranslateMessage(pMsg);
}

void CMultiViewCtrl::OnDestroy()
{
	delete m_pcsedDialog;
	delete m_pcaedDialog;
	delete m_pcaqdDialog;
	delete m_pProgressDlg;

	COleControl::OnDestroy();

}

void CMultiViewCtrl::QueryViewInstances
(LPCTSTR szTitle, LPCTSTR szQueryType, LPCTSTR szQuery, LPCTSTR szClass)
{

	CString csQuery = szQuery;

	// This really, really wants to return an scode.
	//if (!szQuery || !szQueryType || !(csQuery.CompareNoCase("WQL")))
	//{
	//	return;
	//}

	m_pcmvcCurrentContext->~CMVContext();

	m_pcmvcCurrentContext->AddRef();
	m_pcmvcCurrentContext->GetType() = CMVContext::Query;
	m_pcmvcCurrentContext->GetLabel() = szTitle;
	m_pcmvcCurrentContext->GetQuery() = szQuery;
	m_pcmvcCurrentContext->GetQueryType() = szQueryType;
	m_pcmvcCurrentContext->GetClass() = szClass;
	m_pcmvcCurrentContext->GetNamespace() = m_csNameSpace;

	if (IsWindowVisible())
	{
		NotifyWillShow();
	}

	DestroyProgressDlgWindow();

}

void CMultiViewCtrl::QueryViewInstancesSync
(LPCTSTR szTitle, LPCTSTR szQueryType, LPCTSTR szQuery, LPCTSTR szClass)
{
	//
	//		There are two things that need to be done to QueryViewInstances.
	//
	//      1. The multiview control needs to implement delayed data loading if
	//         it is currently currently hidden.
	//
	//		2. The container now passes the title (label) though to the multiview
	//         control.  The multiview control needs to make this title available
	//         via the GetTitle method.
	//
	//      The delayed rendering is necessary because the container now passes
	//      calls to the multiview though immediately even if the multiview is
	//      hidden.  Now the multiview is responsible for delaying the execution
	//      of these calls until it is made visible again.
	//


//	CWaitCursor wait;

	CString csClass = szClass;

	if (csClass.GetLength() > 0)
	{
		QueryViewInstancesSyncWithClass
			(szTitle,szQueryType,szQuery,szClass);
	}
	else
	{
		QueryViewInstancesSyncWithoutClass
			(szTitle,szQueryType,szQuery);
	}

	DestroyProgressDlgWindow();

}

void CMultiViewCtrl::QueryViewInstancesSyncWithoutClass
(LPCTSTR szTitle, LPCTSTR szQueryType, LPCTSTR szQuery)
{
	//
	//		There are two things that need to be done to QueryViewInstances.
	//
	//      1. The multiview control needs to implement delayed data loading if
	//         it is currently currently hidden.
	//
	//		2. The container now passes the title (label) though to the multiview
	//         control.  The multiview control needs to make this title available
	//         via the GetTitle method.
	//
	//      The delayed rendering is necessary because the container now passes
	//      calls to the multiview though immediately even if the multiview is
	//      hidden.  Now the multiview is responsible for delaying the execution
	//      of these calls until it is made visible again.
	//


	SCODE sc;
	CString csQuery = szQuery;

	CString csMessage =
			_T("Executing query: ") + csQuery + _T(".");

	SetProgressDlgMessage(csMessage);

	if (!m_pProgressDlg->GetSafeHwnd())
	{
		CreateProgressDlgWindow();
	}

	CString csQueryType = szQueryType;


	IWbemClassObject *pCommonParent = NULL;


	m_csaProps.RemoveAll();
	m_csClass = _T("");
	m_nClassOrInstances = INSTANCES;

	InitializeDisplay(NULL, NULL, NULL);


#ifdef _DEBUG
//	afxDump << "ExecQuery in QueryViewInstancesSyncWithoutClass = " << csQuery << "\n";
#endif

	IEnumWbemClassObject *pecoInstances =
		ExecQuery(m_pServices, csQueryType, csQuery, m_csNameSpace);

	BOOL bCancel = CheckCancelButtonProgressDlgWindow();

	if (bCancel)
	{
		csMessage = _T("Operation Canceled");
		InitializeDisplay(NULL,NULL,NULL,&csMessage);
		if (pecoInstances)
		{
			pecoInstances->Release();
			pecoInstances = NULL;
		}
	}


	CPtrArray *pcpaInstances = NULL;

	if (pecoInstances)
	{
		sc = SemiSyncQueryInstancesNonincrementalAddToDisplay
			(pcpaInstances, pecoInstances, bCancel);

	}

	int nInstances = pcpaInstances? (int) pcpaInstances->GetSize() : 0;
	if (nInstances == 0)
	{
		m_nClassOrInstances = CMultiViewCtrl::NONE;
		CString csMessage;

		if (bCancel)
		{
			csMessage = _T("Operation Canceled");
		}
		else
		{
			csMessage = _T("No Instances Available");
		}
		InitializeDisplay(NULL,NULL,NULL,&csMessage);
		delete pcpaInstances;
		return;
	}

	int i;
	CStringArray csaClasses;

	CString csClass;

	if (nInstances > 0)
	{
		for (i = 0; i < nInstances; i++)
		{
			IWbemClassObject *pInstance =
				reinterpret_cast<IWbemClassObject *>
					(pcpaInstances->GetAt(i));

			ASSERT (pInstance);

			csClass = GetIWbemClassPath(m_pServices ,pInstance);
			if (csClass.IsEmpty()) {
				continue;
			}
			if (!ClassInClasses(&csaClasses,&csClass))
			{
				csaClasses.Add(csClass);
			}
		}

		//if we could retrieve class names for some instances
		if (csaClasses.GetSize() != 0) {
			pCommonParent = CommonParent(&csaClasses);
		}
		m_csaProps.RemoveAll();

		m_nClassOrInstances = INSTANCES;

		if (!pCommonParent)
		{
			//get sorted properties for each instance, then find least common denominator
			for (i = 0; i < nInstances; i++)	{
				IWbemClassObject *pInstance =
					reinterpret_cast<IWbemClassObject *>(pcpaInstances->GetAt(i));
				CStringArray csaProps;
				int nProps = GetSortedPropNames (pInstance, csaProps, m_cmstpPropFlavors);

				//initialize resulting property array
				if (i == 0) {
					m_csaProps.Copy(csaProps);
				}

				//intersect resulting array with the current one
				IntersectInPlace(m_csaProps, csaProps);
			}

			m_csClass = _T("");
			InitializeDisplay(NULL, NULL, &m_csaProps, NULL, &m_cmstpPropFlavors);

		}
		else
		{
			int nProps = GetSortedPropNames (pCommonParent, m_csaProps, m_cmstpPropFlavors);
			pCommonParent -> Release();
			m_csClass = _T("");
			InitializeDisplay(NULL, NULL, &m_csaProps, NULL, &m_cmstpPropFlavors);
		}

	}

	AddToDisplay(pcpaInstances);
	delete pcpaInstances;

}

SCODE CMultiViewCtrl::SemiSyncQueryInstancesNonincrementalAddToDisplay
(CPtrArray *& pcpaObjects,  IEnumWbemClassObject *pemcoObjects, BOOL &bCancel)
{

	ASSERT(pcpaObjects == NULL);

	if (!pemcoObjects)
		return E_FAIL;

	pcpaObjects = new CPtrArray;


	pemcoObjects -> Reset();
	IWbemClassObject *pObject = NULL;
	ULONG uReturned = 0;
	HRESULT hResult = S_OK;

	IWbemClassObject     *pimcoInstances[N_INSTANCES];
	IWbemClassObject     **pInstanceArray =
		reinterpret_cast<IWbemClassObject **> (&pimcoInstances);

	int i;

	for (i = 0; i < N_INSTANCES; i++)
	{
		pimcoInstances[i] = NULL;
	}


	IWbemClassObject     *pimcoInstance = NULL;
#ifdef _DEBUG
//	afxDump << "Next in SemiSyncQueryInstancesNonincrementalAddToDisplay\n";
#endif
	hResult =
			pemcoObjects->Next(ENUM_TIMEOUT, N_INSTANCES,pInstanceArray, &uReturned);

	int cInst = 0;

	while(hResult == S_OK || hResult == WBEM_S_TIMEDOUT || uReturned > 0)
	{
		if (!m_pProgressDlg->GetSafeHwnd())
		{
			CreateProgressDlgWindow();
		}
		else
		{
			bCancel = CheckCancelButtonProgressDlgWindow();
		}

		if (bCancel)
			{
				int i;
#pragma warning( disable :4018 )
				for (i = 0; i < uReturned; i++)
#pragma warning( default : 4018 )
				{
					pimcoInstances[i]->Release();
					pimcoInstances[i] = NULL;
				}
				cInst = 0;
				for (i = 0; i < pcpaObjects->GetSize(); i++)
				{
					IWbemClassObject *pObject =
						reinterpret_cast<IWbemClassObject *>
							(pcpaObjects->GetAt(i));
					pObject->Release();

				}
				pcpaObjects->RemoveAll();
				break;
			}


#pragma warning( disable :4018 )
		for (int i = 0; i < uReturned; i++)
#pragma warning( default : 4018 )
		{
			pcpaObjects->Add(reinterpret_cast<void *>(pimcoInstances[i]));
			pimcoInstances[i] = NULL;
		}

		cInst += uReturned;
		uReturned = 0;
#ifdef _DEBUG
//	afxDump << "Next in SemiSyncQueryInstancesNonincrementalAddToDisplay\n";
#endif
		hResult = pemcoObjects->Next
				(0,N_INSTANCES,pInstanceArray, &uReturned);
	}

	pemcoObjects -> Release();

	DestroyProgressDlgWindow();


	if (FAILED(hResult)) {
		CString csUserMsg =
						_T("An error occurred while attempting to retrieve the list of objects.");

		HWND hwndFocus = ::GetFocus();
		ErrorMsg
			(&csUserMsg, hResult, TRUE,
			TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
		if (::IsWindow(hwndFocus) && ::IsWindowVisible(hwndFocus)) {
			::SetFocus(hwndFocus);
		}

	}

	return S_OK;

}

void CMultiViewCtrl::QueryViewInstancesSyncWithClass
(LPCTSTR szTitle, LPCTSTR szQueryType, LPCTSTR szQuery, LPCTSTR szClass)
{
	//
	//		There are two things that need to be done to QueryViewInstances.
	//
	//      1. The multiview control needs to implement delayed data loading if
	//         it is currently currently hidden.
	//
	//		2. The container now passes the title (label) though to the multiview
	//         control.  The multiview control needs to make this title available
	//         via the GetTitle method.
	//
	//      The delayed rendering is necessary because the container now passes
	//      calls to the multiview though immediately even if the multiview is
	//      hidden.  Now the multiview is responsible for delaying the execution
	//      of these calls until it is made visible again.
	//

//	CWaitCursor wait;

	CString csQuery = szQuery;

	CString csMessage =
			_T("Executing query: ") + csQuery + _T(".");

	SetProgressDlgMessage(csMessage);


	CString csClass = szClass;
	CString csQueryType = szQueryType;


	IWbemClassObject *pCommonParent = NULL;

	SCODE sc;

	pCommonParent = GetClassFromAnyNamespace(csClass);


	if (!pCommonParent)
	{
		InitializeDisplay(NULL,NULL,NULL);
		CString csUserMsg;
		csUserMsg =  _T("Cannot get class object ") + csClass;
		ErrorMsg
				(&csUserMsg, m_sc, FALSE,TRUE, &csUserMsg, __FILE__,
				__LINE__ - 9);
		return;
	}


#ifdef _DEBUG
//	afxDump << "ExecQuery in QueryViewInstancesSyncWithClass = " << csQuery << "\n";
#endif

	IEnumWbemClassObject *pecoInstances =
		ExecQuery(m_pServices, csQueryType, csQuery, m_csNameSpace);

	if (pecoInstances == NULL)
	{
		InitializeDisplay(NULL,NULL,NULL);
		CString csUserMsg;
		csUserMsg =  _T("Cannot get enumeration for ") + csQuery;
		CWnd* pwndFocus = GetFocus();
		ErrorMsg
				(&csUserMsg, S_OK, FALSE,TRUE, &csUserMsg, __FILE__,
				__LINE__ );
		if (pwndFocus && ::IsWindow(pwndFocus->m_hWnd)) {
			pwndFocus->SetFocus();
		}

		return;
	}

	m_csaProps.RemoveAll();

	int nProps = GetSortedPropNames (pCommonParent, m_csaProps, m_cmstpPropFlavors);
	pCommonParent -> Release();
	m_csClass = _T("");
	m_nClassOrInstances = INSTANCES;
	InitializeDisplay(NULL, NULL, &m_csaProps, NULL, &m_cmstpPropFlavors);

	CPtrArray *pcpaInstances = new CPtrArray;
	BOOL bCancel= FALSE;
	int cInst = 0;

	sc = SemiSyncQueryInstancesIncrementalAddToDisplay
		(m_pServices, pecoInstances, *pcpaInstances, cInst,  bCancel);

	pecoInstances -> Release();

	if (cInst == 0)
	{
		m_nClassOrInstances = CMultiViewCtrl::NONE;
		CString csMessage = _T("No Instances Available");
		InitializeDisplay(NULL,NULL,NULL,&csMessage);
		delete pcpaInstances;
		return;
	}

	delete pcpaInstances;

}

SCODE CMultiViewCtrl::SemiSyncQueryInstancesIncrementalAddToDisplay
(IWbemServices * pIWbemServices, IEnumWbemClassObject *pimecoInstanceEnum,
 CPtrArray &cpaInstances,int &cInst, BOOL &bCancel)
{
	cInst = 0;
	bCancel = 0;

	SCODE sc = S_OK;

	if(pimecoInstanceEnum == NULL)
	{
		return sc;
	}

	sc = pimecoInstanceEnum->Reset();

	IWbemClassObject     *pimcoInstances[N_INSTANCES];
	IWbemClassObject     **pInstanceArray =
		reinterpret_cast<IWbemClassObject **> (&pimcoInstances);

	int i;

	for (i = 0; i < N_INSTANCES; i++)
	{
		pimcoInstances[i] = NULL;
	}


	IWbemClassObject     *pimcoInstance = NULL;
	ULONG uReturned = 0;

#ifdef _DEBUG
//	afxDump << "Next in SemiSyncQueryInstancesIncrementalAddToDisplay\n";
#endif
	sc = pimecoInstanceEnum->Next(ENUM_TIMEOUT,N_INSTANCES,pInstanceArray, &uReturned);

	CString csPath = m_csSyncEnumClass;
	m_csClass = csPath;
	m_nClassOrInstances = CLASS;

    while (sc == S_OK || sc == WBEM_S_TIMEDOUT || uReturned > 0)
		{
			if (!m_pProgressDlg->GetSafeHwnd())
			{
				CreateProgressDlgWindow();
			}
			else
			{
				PumpMessagesProgressDlgWindow();
			}
			cpaInstances.RemoveAll();

#pragma warning( disable :4018 )
			for (int i = 0; i < uReturned; i++)
#pragma warning( default : 4018 )
			{
				cpaInstances.Add(reinterpret_cast<void *>(pimcoInstances[i]));
				pimcoInstances[i] = NULL;
			}
			if (uReturned > 0)
			{
				AddToDisplay(&cpaInstances);
			}
			cInst += uReturned;
			uReturned = 0;

#ifdef _DEBUG
//	afxDump << "Next in SemiSyncQueryInstancesIncrementalAddToDisplay\n";
#endif
			sc = pimecoInstanceEnum->Next(ENUM_TIMEOUT, N_INSTANCES,pInstanceArray, &uReturned);
		}

	DestroyProgressDlgWindow();


	if (FAILED(sc)) {
		CString csUserMsg =
						_T("An error occurred while attempting to retrieve the list of objects.");

		ErrorMsg
			(&csUserMsg, sc, TRUE,
			TRUE, &csUserMsg, __FILE__, __LINE__ - 6);

	}

	return sc;

}

void CMultiViewCtrl::QueryViewInstancesAsync(LPCTSTR szTitle, LPCTSTR szQueryType, LPCTSTR szQuery, LPCTSTR szClass)
{
	//
	//		There are two things that need to be done to QueryViewInstances.
	//
	//      1. The multiview control needs to implement delayed data loading if
	//         it is currently currently hidden.
	//
	//		2. The container now passes the title (label) though to the multiview
	//         control.  The multiview control needs to make this title available
	//         via the GetTitle method.
	//
	//      The delayed rendering is necessary because the container now passes
	//      calls to the multiview though immediately even if the multiview is
	//      hidden.  Now the multiview is responsible for delaying the execution
	//      of these calls until it is made visible again.
	//



	CString csClass = szClass;
	CString csQueryType = szQueryType;
	CString csQuery = szQuery;

	IWbemClassObject *pimcoClass = NULL;

	if (csClass.GetLength() > 0)
	{
		//SCODE sc;
		pimcoClass = GetClassFromAnyNamespace(csClass);

		if (!pimcoClass)
		{
			InitializeDisplay(NULL,NULL,NULL);
			CString csUserMsg;
			csUserMsg =  _T("Cannot get class object ") + csClass;
			CWnd* pwndFocus = GetFocus();
			ErrorMsg
					(&csUserMsg, m_sc, FALSE,TRUE, &csUserMsg, __FILE__,
					__LINE__ - 9);
			if (pwndFocus && ::IsWindow(pwndFocus->m_hWnd)) {
				pwndFocus->SetFocus();
			}

			return;
		}


		m_csaProps.RemoveAll();

		int nProps = GetSortedPropNames (pimcoClass, m_csaProps, m_cmstpPropFlavors);
		pimcoClass -> Release();
		m_csClass = _T("");
		m_nClassOrInstances = INSTANCES;
		InitializeDisplay(NULL, NULL, &m_csaProps, NULL, &m_cmstpPropFlavors);

	}
	else
	{
		m_csaProps.RemoveAll();
		m_csClass = _T("");
		m_nClassOrInstances = INSTANCES;

		InitializeDisplay(NULL, NULL, NULL);
	}

	m_csClassForAsyncSink = csClass;
	m_csQueryForAsyncSink = csQuery;
	m_csQueryTypeForAsyncSink = csQueryType;

	m_pcaqdDialog->SetClass(&csClass);
	m_pcaqdDialog->SetQueryType(&csQueryType);
	m_pcaqdDialog->SetQuery(&csQuery);

	GetQueryInstancesAsync
		(m_pServices, &csQueryType, &csQuery);


}

//*************************************************************
// CMultiViewCtrl::CreateInstance
//
// Create an instance of the current class.
//
//
// Parameters:
//		None.
//
// Returns:
//		SCODE
//			S_OK if the operation was successful, E_FAIL otherwise.
//
//**************************************************************
SCODE CMultiViewCtrl::CreateInstance()
{
	//
	// Please send your comments to me regarding the design
	// of the interface for "Create" and "Delete".
	//
	// I am not yet clear on how the multiview should handle
	// CreateInstance.  This is because of goals:
	//     1. The multiview should be able to work in the absence
	//        of the single view.  In this case what does CreateInstance
	//        mean since the single view will not be available for
	//        editing the newly created instance.
	//
	//     2. The views have the greatest flexibility if they are
	//        in control of "creation" and "deletion" as it allows
	//        the view to attach their own semantics to these actions.
	//
	//     3. When using the multiview as a stand-alone control, it
	//        would make the multiview more powerful and easy to use
	//        if it could handle instance creation/deletion.
	//
	//     4. Create and delete can originate from within the multiview
	//        though keyboard events that are sent to the multiview
	//        control.
	//

	return E_NOTIMPL;
}



//*************************************************************
// CMultiViewCtrl::DeleteInstance
//
// Delete the currently selected object.
//
//
// Parameters:
//		None.
//
// Returns:
//		SCODE
//			S_OK if the operation was successful, E_FAIL otherwise.
//
//**************************************************************
SCODE CMultiViewCtrl::DeleteInstance()
{
	//
	// I am not yet satisfied with the interface for create and delete.
	// Please review the my comments in CMultiViewCtrl::CreateInstance and
	// send your comments to me regarding any improvements to this design.
	//
	// The container calls this method when the "Delete Instance" button
	// is clicked and the multiview is visible.  The multiview is now
	// responsible for deleting whatever it is that it wants to delete.
	// This will typically be an instance of the current class.
	//
	// The container will call this method only if the QueryCanDeleteInstance
	// method returns TRUE.  The container checks this when the multiview is
	// first made visible and whenever it gets a FireNotifyViewModified event.

	long lPosition = StartObjectEnumeration(OBJECT_CURRENT);
	CString csPath;

	if (lPosition > -1)
	{
		csPath = GetObjectPath(lPosition);

	}
	else
	{
		return WBEM_E_FAILED;
	}

	if (csPath.GetLength() > 0)
	{
		SCODE sc;
		IWbemClassObject *pObject = NULL;
		BSTR bstrTemp = csPath.AllocSysString();
		sc =
			m_pServices ->
				DeleteInstance(bstrTemp,0, NULL,NULL);
		::SysFreeString(bstrTemp);
		if (sc == S_OK)
		{
			CString *pcsPath =
				reinterpret_cast<CString *>
					(m_cgGrid.GetAt(lPosition, 0).GetTagValue());
			delete pcsPath;
			m_cgGrid.DeleteRowAt(lPosition);
			if (m_cgGrid.GetRows() == 0) {
				NotifyWillShow();
			}

			m_cgGrid.CheckForSelectionChange();

			InvalidateControl();
			return S_OK;
		}
		else
		{
			CString *pcsPath =
				reinterpret_cast<CString *>
					(m_cgGrid.GetAt(lPosition, 0).GetTagValue());
			CString csUserMsg;
			csUserMsg =  _T("Cannot delete object ") + *pcsPath;
			CWnd* pwndFocus = GetFocus();
			ErrorMsg
				(&csUserMsg, sc, TRUE, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 7);
			if (pwndFocus && ::IsWindow(pwndFocus->m_hWnd)) {
				pwndFocus->SetFocus();
			}

			return sc;
		}
	}
	else
	{
		return WBEM_E_FAILED;
	}
}


//*************************************************************
// CMultiViewCtrl::GetContext
//
// Get a handle to the current multiview context by allocating
// a multiview context object, storing a snapshot of the current
// state in the context object, and returning a handle to the
// newly created context object.
//
// The container may use this handle later to restore the multivew
// to a previous state.
//
// Parameters:
//		[out] long FAR* pCtxHandle
//			The place to return the context handle.
//
// Returns:
//		SCODE
//			S_OK if the operation was successful, E_FAIL otherwise.
//
//**************************************************************
SCODE CMultiViewCtrl::GetContext(long FAR* pCtxHandle)
{
	// The container calls this method to save the current state of the
	// multiview in a context object.  When this method is called, a new
	// context handle needs to be created, the current state is saved in
	// it and a handle to the context object is returned. The intial
	// reference count on the context object is assumed to be 1.
	//
	// I expect that the context handles will actually be a pointer
	// to some context object of your own design that has been cast to a
	// long.  To the container the context handles are just long integers.

	//if (m_pcmvcCurrentContext->GetType() == CMVContext::Unitialized)
	//{
		// A NULL handle means restore to the uninitialized state.
	//	*pCtxHandle = NULL;
	//	return S_OK;
	//}

	CMVContext *pNewContext;

	if (m_pcmvcCurrentContext)
	{
		pNewContext = new CMVContext(*m_pcmvcCurrentContext);
	}
	else
	{
		pNewContext = new CMVContext;
	}

	if (!pNewContext)
	{
		return WBEM_E_FAILED;
	}

	pNewContext->AddRef();
// BUGBUG: HACK: WE SHOULD NOT BE PASSING A POINTER THROUGH AN AUTOMATION INTERFACE!!!
#ifdef _WIN64
	ASSERT(FALSE);
	*pCtxHandle = NULL;
#else
	*pCtxHandle = reinterpret_cast<long>(pNewContext);
#endif
	return S_OK;
}



//*************************************************************
// CMultiViewCtrl::AddContextRef
//
// Restore the multiview's context to the state specified by the
// given view context handle.
//
// Parameters:
//		[in] long lCtxtHandle
//			The view context handle.
//
// Returns:
//		SCODE
//			S_OK if the operation was successful, E_FAIL otherwise.
//
//**************************************************************
SCODE CMultiViewCtrl::RestoreContext(long lCtxtHandle)
{

	// The container calls this method to restore the
	// multiview to a previously saved state.  The state is stored in
	// an object identified by the context handle.
	//
	// I expect that the context handles will actually be a pointer
	// to some context object of your own design that has been cast to a
	// long.  To the container the context handles are just long integers.

	CMVContext *pNewContext;

	if (lCtxtHandle == 0)
	{
		 pNewContext = new CMVContext;
	}
	else
	{
		pNewContext = reinterpret_cast<CMVContext*>(lCtxtHandle);
	}


	if (!pNewContext)
	{
		return WBEM_E_FAILED;
	}

	if (m_pcmvcCurrentContext->IsContextEqual(*pNewContext))
	{
		if (IsWindowVisible())
		{
			NotifyWillShow();
		}
		return S_OK;
	}

	*m_pcmvcCurrentContext = *pNewContext;
	m_pcmvcCurrentContext->AddRef();
	if (m_pcmvcCurrentContext->GetNamespace().GetLength() > 0 &&
		m_pcmvcCurrentContext->GetNamespace().CompareNoCase(m_csNameSpace))
	{
		SetNameSpace(m_pcmvcCurrentContext->GetNamespace());
	}

	if (IsWindowVisible())
	{
		NotifyWillShow();
	}

	return S_OK;
}

//*************************************************************
// CMultiViewCtrl::AddContextRef
//
// Increment the reference count on the specified context handle.
//
// Parameters:
//		[in] long lCtxtHandle
//			The view context handle.
//
// Returns:
//		SCODE
//			S_OK if the operation was successful, E_FAIL otherwise.
//
//**************************************************************
SCODE CMultiViewCtrl::AddContextRef(long lCtxtHandle)
{
	// The container calls this method to increment the reference count
	// of the specified context object.
	//
	// I expect that the context handles will actually be a pointer
	// to some context object of your own design that has been cast to a
	// long.  To the container the context handles are just long integers.

	CMVContext *pContext = reinterpret_cast<CMVContext*>(lCtxtHandle);

	if (!pContext)
	{
		return WBEM_E_FAILED;
	}

	pContext->AddRef();
	return S_OK;
}


//*************************************************************
// CMultiViewCtrl::ReleaseContext
//
// Decrement the reference count on the specified view context handle.
// If the reference count goes to zero, delete the corresponding
// view context.
//
// Parameters:
//		[in] long lCtxtHandle
//			The view context handle.
//
// Returns:
//		SCODE
//			S_OK if the operation was successful, E_FAIL otherwise.
//
//**************************************************************
SCODE CMultiViewCtrl::ReleaseContext(long lCtxtHandle)
{
	if (lCtxtHandle == 0) {
		// !!!Judy: A null context handle corresponds to "uninitialized:
		return S_OK;
	}

	// The container calls this method to release the specified
	// context handle.  When the context handle's reference count
	// goes to zero, the context can be deleted.
	//
	// I expect that the context handles will actually be a pointer
	// to some context object of your own design that has been cast to a
	// long.  To the container the context handles are just long integers.

	CMVContext *pContext = reinterpret_cast<CMVContext*>(lCtxtHandle);
	pContext->Release();
	return S_OK;
}


//*********************************************************
// CMultiViewCtrl::SetEditMode
//
// Set the edit mode flag.
//
// Parameters:
//		[in] BOOL bCanEdit
//			TRUE if the view can be edited (studio mode),
//			FALSE if the data can not be edited (browser mode).
//
// Returns:
//		Nothing.
//
//*********************************************************
void CMultiViewCtrl::SetEditMode(long bCanEdit)
{
	// The container passes the "studio mode" flag to you here.
	// bCanEdit will be TRUE if the container is in studio mode,
	// and FALSE if it is in browse mode.
	m_bCanEdit = bCanEdit;
}


//*************************************************************
// CMultiViewCtrl::GetEditMode
//
// Get the current edit mode.
//
// Parameters:
//		None.
//
// Returns:
//		BOOL
//			TRUE if editing is enabled (studio mode).
//			FALSE if editing is disabled (browser mode).
//
//**************************************************************
long CMultiViewCtrl::GetEditMode()
{
	return m_bCanEdit;
}




//*************************************************************
// CMultiViewCtrl::GetTitle
//
// Get the multiview's title and picture that will be displayed
// in the container's titlebar.  This title and picture should
// correspond to the currently selected object.
//
// Parameters:
//		[out] BSTR FAR* pbstrTitle
//			The place to return the title.
//
//		[out] LPDISPATCH FAR* lpPictDisp
//			The place to return the picture to be displayed as the
//			object's icon in the container's titlebar.
//
//**************************************************************
SCODE CMultiViewCtrl::GetTitle(BSTR FAR* pbstrTitle, LPDISPATCH FAR* lpPictDisp)
{	//
	// This is the method that the container calls to get the title and
	// icon that appear in the container's titlebar.  The title and icon
	// should correspond to the currently selected instance, class, and
	// so on.
	//
	// You can see how this is done in the SingleView by looking at the
	// following methods:
	//
	// CSingleViewCtrl::GetTitle		    SingleView\SingleViewCtl.cpp
	// CSelection::GetObjectDescription     SingleView\Path.cpp
	// CSelection::GetPictureDispatch		SingleView\Path.cpp
	//

	if (m_pcmvcCurrentContext->GetLabel().GetLength() > 0)
	{
		*pbstrTitle =  m_pcmvcCurrentContext->GetLabel().AllocSysString();
		CString csLabel = *pbstrTitle;
		BOOL bGroup;
		if (csLabel.Right(5).CompareNoCase(_T("Group")) == 0)
		{
			bGroup = TRUE;
		}
		else
		{
			bGroup = FALSE;
		}

		CPictureHolder *pPicture = new CPictureHolder;

		HICON hIcon;

		if (bGroup)
		{
			hIcon = theApp.LoadIcon(IDI_ICONOJBG);
		}
		else
		{
			hIcon = theApp.LoadIcon(IDI_ICONASSOCROLE);
		}

		if (hIcon)
		{
			pPicture->CreateFromIcon(hIcon,TRUE);
			*lpPictDisp = pPicture->GetPictureDispatch();
		}
		else
		{
			*lpPictDisp = NULL;
		}

		return S_OK;
	}
	else
	{
		// Get Class Icon
		*pbstrTitle =  m_pcmvcCurrentContext->GetClass().AllocSysString();
		CString csClass = *pbstrTitle;
		IWbemClassObject *pClass = NULL;

		if (!m_pServices)
		{
			*lpPictDisp = NULL;
			return S_OK;
		}

		BSTR bstrTemp = csClass.AllocSysString();
#ifdef _DEBUG
//	afxDump << "GetObject in GetTitle for " << csClass << "\n";
#endif
		SCODE sc =
		m_pServices ->
			GetObject(bstrTemp,0, NULL, &pClass, NULL);
		::SysFreeString(bstrTemp);

		if (sc != S_OK)
		{
			*lpPictDisp = NULL;
			return sc;

		}

		CString csAttribName = _T("Icon");
		CString csIconPath = GetBSTRAttrib(pClass, NULL , &csAttribName);

		if (csIconPath.GetLength() == 0)
		{
			csIconPath = csClass;
		}

		CPictureHolder *pPicture = new CPictureHolder;

		HICON hIcon = NULL;

		if (csIconPath.GetLength() > 0)
		{
  			hIcon = ::WBEMGetIcon((LPCTSTR)csIconPath);
		}

		if (hIcon)
		{
			pPicture->CreateFromIcon(hIcon,TRUE);
			*lpPictDisp = pPicture->GetPictureDispatch();
		}
		else
		{
			hIcon = theApp.LoadIcon(IDI_ICONPLACEH);
			if (hIcon)
			{
				pPicture->CreateFromIcon(hIcon,TRUE);
				*lpPictDisp = pPicture->GetPictureDispatch();
			}
			else
			{
				delete pPicture;
				*lpPictDisp = NULL;
			}
		}

		return S_OK;

	}


}


HICON  CMultiViewCtrl::LoadIcon(CString pcsFile)
{

	SIZE size;
	size.cx = CX_SMALL_ICON;
	size.cy = CY_SMALL_ICON;
	HICON hIcon = (HICON) ::LoadImage(NULL, pcsFile, IMAGE_ICON,
					size.cx, size.cy, LR_LOADFROMFILE);


	return hIcon;
}







//*****************************************************************
// CMultiViewCtrl::ExternInstanceCreated
//
// The container calls this method to notify the multiview control
// that the container deleted an object instance.  This gives the
// multiview a chance to remove the instance from its list if necessary.
//
// Parameters:
//		[in] LPCTSTR szObjectPath
//			The HMOM object path of the instance that was Created (wouldn't
//			a uniform object identifier be nice here?)
//
// Returns:
//		Nothing.
//
//********************************************************************
void CMultiViewCtrl::ExternInstanceCreated(LPCTSTR szObjectPath)
{
	if (m_nClassOrInstances != CMultiViewCtrl::CLASS &&
		m_nClassOrInstances != CMultiViewCtrl::ZERO_CLASS_INST)
	{
		return;
	}

	CString csPath = szObjectPath;

	IWbemClassObject *pimcoObject = NULL;

	BSTR bstrTemp = csPath.AllocSysString();
#ifdef _DEBUG
//	afxDump << "GetObject in ExternInstanceCreated for " << csPath << "\n";
#endif
	SCODE sc =
		m_pServices ->
		GetObject(bstrTemp,0, NULL, &pimcoObject, NULL);
	::SysFreeString(bstrTemp);

	if(sc != S_OK)
	{
		CString csUserMsg;
		csUserMsg =  _T("Cannot get object ") + csPath;

		ErrorMsg
				(&csUserMsg, sc, TRUE, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 7);
		return;
	}


	CString csClassPath =
		GetIWbemFullPath(m_pServices, pimcoObject);
	CString csClass =
		GetIWbemClass(m_pServices, pimcoObject);

	pimcoObject->Release();
	if (m_csClass.CompareNoCase(m_csClass) == 0)
	{
		 ViewClassInstances((LPCTSTR) csClass);
	}
	InvalidateControl();
	return;
}



//************************************************************
// CMultiViewCtrl::ExternInstanceDeleted
//
// The container calls this method when an instance is deleted.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CMultiViewCtrl::ExternInstanceDeleted(LPCTSTR szObjectPath)
{
	if (m_nClassOrInstances == CMultiViewCtrl::NONE ||
		m_nClassOrInstances == CMultiViewCtrl::ZERO_CLASS_INST)
	{
		return;
	}

	int nRows = m_cgGrid.GetRows();

	if (nRows == 0)
	{
		return;
	}

	CString csPath = szObjectPath;

	int nRow = ObjectInGrid(&csPath);
	if (nRow == -1)
	{
		return;
	}

	CString *pcsPath =
			reinterpret_cast<CString *>
				(m_cgGrid.GetAt(nRow, 0).GetTagValue());
	delete pcsPath;

	m_cgGrid.DeleteRowAt(nRow);

	nRows = m_cgGrid.GetRows();

	if (nRows == 0  && GetSafeHwnd() && (IsWindowVisible()))
	{
		CString csMessage = _T("No Instances Available");
		InitializeDisplay(NULL,NULL,NULL,&csMessage);
	}

	InvalidateControl();
}


//************************************************************
// CMultiViewCtrl::NotifyWillShow
//
// The container calls this method just prior to performing
// a ShowWindow(SW_SHOW) on the multiview window.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//************************************************************
void CMultiViewCtrl::NotifyWillShow()
{

	//
	// Now the container passes though calls to the multiview
	// immediately even if the multiview is currently hidden.  To avoid
	// the performance hits we experienced in the past, the multiview
	// will be responsible for implementing "delayed" loading where the
	// data is loaded at the time the multiview becomes visible.
	//
	// The container calls NotifyWillShow just prior to making the
	// multiview visible.  This is the multiview's chance to do any
	// data loading that might have been delayed.
	//
	// Of course it would be nice if multiview could do its data loading
	// asyncrhonously in the backgound even if it is currenly hidden so long
	// as the user wouldn't experience a big performance hit.

	if (m_pcmvcCurrentContext->IsDrawn() == FALSE || m_bPropFilterFlagsChanged)
	{
		if ((m_pcmvcCurrentContext->GetNamespace().IsEmpty() || m_csNameSpace.IsEmpty())
			&& m_pcmvcCurrentContext->GetType() != CMVContext::Unitialized)
		{
			CString csUserMsg;
			csUserMsg =  _T("A namespace must be opened before you can view instances.");
			ErrorMsg
					(&csUserMsg, S_OK, FALSE, TRUE, &csUserMsg, __FILE__,
					__LINE__ );
			return;
		}
		m_pcmvcCurrentContext->IsDrawn() = TRUE;
		m_bPropFilterFlagsChanged = FALSE;
		if (m_pcmvcCurrentContext->GetType() == CMVContext::Class)
		{
			ViewClassInstancesSync(m_pcmvcCurrentContext->GetClass());
		}
		else if (m_pcmvcCurrentContext->GetType() == CMVContext::Instances)
		{
			ViewInstancesInternal(m_pcmvcCurrentContext->GetLabel(),
									m_pcmvcCurrentContext->GetInstances());
		}
		else if(m_pcmvcCurrentContext->GetType() == CMVContext::Query)
		{
			QueryViewInstancesSync
				(m_pcmvcCurrentContext->GetLabel(),
				m_pcmvcCurrentContext->GetQueryType(),
				m_pcmvcCurrentContext->GetQuery(),
				m_pcmvcCurrentContext->GetClass());
		}
		else
		{
			InitializeDisplay(NULL,NULL,NULL);

		}

	}
	else
	{
		int nRows = m_cgGrid.GetRows();

		if (nRows == 0  && GetSafeHwnd())
		{
			CString csMessage = _T("No Instances Available");
			InitializeDisplay(NULL,NULL,NULL,&csMessage);
		}

		InvalidateControl();

	}
}


//************************************************************
// CMultiViewCtrl::QueryCanCreateInstance
//
// The container calls this method to determine whether or not
// a "CreateInstance" can be done.
//
// Parameters:
//		None.
//
// Returns:
//		TRUE if a "create instance" can be done, FALSE otherwise.
//
//************************************************************
long CMultiViewCtrl::QueryCanCreateInstance()
{
	// Return TRUE if  it is OK to create and instance.  Please see the
	// CSelection::UpdateCreateDeleteFlags method that I have placed
	// near the end of this file to see how I did determined whether
	// instance creation/deletion could be done in the "SingleView".
	// You can find related code in the SingleView's
	// "path.cpp, and hmomutil.cpp" files.

	return FALSE;
}



//************************************************************
// CMultiViewCtrl::QueryCanDeleteInstance
//
// The container calls this method to determine whether or not it
// is OK to delete the currently selected instance.
//
// Parameters:
//		None.
//
// Returns:
//		TRUE if it is OK to delete the currently selected instance,
//		FALSE otherwise.
//
//*************************************************************
long CMultiViewCtrl::QueryCanDeleteInstance()
{
	// Return TRUE if there is an instance selected and it is
	// OK to delete it.  Please see the CSelection::UpdateCreateDeleteFlags
	// method that I have placed near the end of this file to see how
	// I did determined whether instance creation/deletion could be
	// done in the "SingleView".  You can find related code in the SingleView's
	// "path.cpp, and hmomutil.cpp" files.

	long lPosition = StartObjectEnumeration(OBJECT_CURRENT);
	CString csPath;

	if (lPosition > -1)
	{
		csPath = GetObjectPath(lPosition);

	}
	else
	{
		return FALSE;
	}

	if (csPath.GetLength() > 0)
	{
		SCODE sc;
		IWbemClassObject *pObject = NULL;
		BSTR bstrTemp = csPath.AllocSysString();
#ifdef _DEBUG
//	afxDump << "GetObject in QueryCanDeleteInstance for " << csPath << "\n";
#endif
		sc =
			m_pServices ->
			GetObject(bstrTemp,0, NULL, &pObject, NULL);
		::SysFreeString(bstrTemp);

		if (sc == S_OK)
		{
			BOOL bObjectIsDynamic = ObjectIsDynamic(sc, pObject);
			if (sc == S_OK && !bObjectIsDynamic)
			{
				pObject->Release();
				return TRUE;
			}
			else
			{
				if (sc == S_OK)
				{
					pObject->Release();
				}
				return FALSE;

			}
		}
		else
		{
			return FALSE;

		}
	}
	else
	{
		return FALSE;
	}
}


//***********************************************************
// CMultiViewCtrl::QueryNeedsSave
//
// Query to determine whether a save needs to be done.
//
// Parameters:
//		None.
//
// Returns:
//		TRUE if a save needs to be done, FALSE otherwise.
//
//************************************************************
long CMultiViewCtrl::QueryNeedsSave()
{
	// Return TRUE if the user has edited something and a
	// save needs to be done.  Perhaps this is redundant since
	// the container could use the control's modified flag, but
	// right now the container calls QueryNeedSave anyway to
	// determine whether or not a save needs to be done.
	return FALSE;
}



//***********************************************************
// CMultiViewCtrl::QueryObjectSelected
//
// Query to determine where any object in the object list is
// currently selected. (ie. is there a current object?)
//
// Parameters:
//		None.
//
// Returns:
//		TRUE if there is an object is selected, FALSE otherwise.
//
//***********************************************************
long CMultiViewCtrl::QueryObjectSelected()
{

	int nRow = m_cgGrid.GetSelectedRow();

	if (nRow == -1)
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}



//***********************************************************
// CMultiViewCtrl::RefreshView
//
// Refresh the view data from the HMOM database.
//
// Parameters:
//		None.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//***********************************************************
SCODE CMultiViewCtrl::RefreshView()
{
	// This should work like the obsolete "RefreshData" method
	// except that now the multiview is responsible for keeping
	// track of what to refresh.  Previously the container passed
	// a list of object paths to "RefreshData"
	//
	// Note that the code for RefreshData is at the bottom of the
	// file in the obsolete code section that has been ifdefed out.

	if (m_pcmvcCurrentContext->GetType() != CMVContext::Unitialized)
	{
		m_pcmvcCurrentContext->IsDrawn() = FALSE;
		if (IsWindowVisible())
		{
			NotifyWillShow();
		}
		return S_OK;
	}
	else
	{
		return WBEM_E_FAILED;
	}
}



//**********************************************************
// CMultiViewCtrl::SaveData
//
// Execute a "Save" operation corresponding to click on the
// "Save" button in the container.
//
// Parameters:
//		None.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise E_FAIL.
//
//**********************************************************
SCODE CMultiViewCtrl::SaveData()
{
	// The container calls this method when the "Save" button
	// is clicked.
	//
	// To enable the container's "Save" button, the multiview
	// must fire the FireNotifySaveRequired() event.  This
	// will be necessary only if the user edits the data directly
	// in the multiview.

	return E_NOTIMPL;
}


//*********************************************************
// CMultiViewCtrl::StartObjectEnumeration
//
// Start enumerating the object paths.
//
// Parameters:
//		[in] long lWhere
//			enum {OBJECT_CURRENT=0, OBJECT_FIRST=1, OBJECT_LAST=2};
//
// Returns:
//		long
//			The position of the object in the object list.
//			-1 if the object list is empty, or a failure occurs.
//
//***********************************************************
long CMultiViewCtrl::StartObjectEnumeration(long lWhere)
{
	// This method needs to return an index into the instance
	// list corresponding to the "lWhere" selector as described
	// in the parameter list.

	int nNumRows = m_cgGrid.GetRows();
	if (nNumRows == 0) {
		return -1;
	}

	// Check to see if this row is the "No instances available" row.
	if (nNumRows == 1)  {
		if (m_cgGrid.IsNoInstanceRow(0)) {
			return -1;
		}
	}

	int iRow;
	switch(lWhere) {
	case OBJECT_CURRENT:
		iRow = m_cgGrid.GetSelectedRow();
		return iRow;
		break;
	case OBJECT_FIRST:
		return 0;
		break;
	case OBJECT_LAST:
		return nNumRows - 1;
		break;
	default:
		// Invalid input parameter.
		return -1;

	}

}

//*********************************************************
// CMultiViewCtrl::NextObject
//
// Get the position of the next HMOM object in the object
// list.  The container uses this method to enumerate the
// object instances in multiview's instance list.
//
// Parameters:
//		[in] long lPosition
//			The position of the reference object (the
//			position of the next object after this one is returned).
//
// Retuturns:
//		long
//			The position of the object that logically follows
//			the reference object or -1 if no "next" object
//			is available.
//
//**********************************************************
long CMultiViewCtrl::NextObject(long lPosition)
{
	// This method needs to return the index of the next
	// object instance in the instance list.

	int nNumRows = m_cgGrid.GetRows();

	if (lPosition < nNumRows - 1 && lPosition >= 0)
	{
		return lPosition + 1;
	}
	else
	{
		return -1;
	}

}



//*********************************************************
// CMultiViewCtrl::PrevObject
//
// Get the position of the previous HMOM object in the object
// list.  The container uses this method to enumerate the
// object instances in multiview's instance list.
//
// Parameters:
//		[in] long lPosition
//			The position of the reference object (the
//			position of the object preceding this one is returned).
//
// Retuturns:
//		long
//			The position of the object that logically follows
//			the reference object or -1 if no "previous" object
//			is available.
//
//**********************************************************
long CMultiViewCtrl::PrevObject(long lPosition)
{
	// This method needs to return the index of the previous
	// object instance in the instance list.

	int nNumRows = m_cgGrid.GetRows();

	if (lPosition < nNumRows - 1 && lPosition >= 1)
	{
		return lPosition - 1;
	}
	else
	{
		return -1;
	}
}




//*************************************************************
// CMultiViewCtrl::GetObjectPath
//
// Get the HMOM object path of the specified class-object.
//
// Parameters:
//		[in] long lPosition
//			The position of the object.
//
// Returns:
//		BSTR
//			The title of the specified class-object.
//
//**************************************************************
BSTR CMultiViewCtrl::GetObjectPath(long lPosition)
{
	// Return the HMOM object path for the specified object.

	CString csReturn = _T("");

	int nNumRows = m_cgGrid.GetRows();
	if (lPosition >= 0 && lPosition < nNumRows)
	{
		CString *pcsPath =
			reinterpret_cast<CString *>
				(m_cgGrid.GetAt(lPosition, 0).GetTagValue());
		if (pcsPath)
		{
			csReturn = *pcsPath;
		}

	}

	return csReturn.AllocSysString();

}


//*************************************************************
// CMultiViewCtrl::GetObjectTitle
//
// Get the title of the specified class-object.
//
// Parameters:
//		[in] long lPosition
//			The position of the object.
//
// Returns:
//		BSTR
//			The title of the specified class-object.
//
//**************************************************************
BSTR CMultiViewCtrl::GetObjectTitle(long lPosition)
{
	// The container calls this method to get the title of the
	// specified object instance.  The container uses this title
	// in message boxes and so on when it needs to display a message
	// containing a reference to an object.
	//
	// It would have been possible for the container to generate the
	// title from the object path, however this API provides a convenient
	// way for applications to get the object title when the multiview
	// control is used separately from the container.
	//
	// Note: This is the title of a specific object and not that of
	// the entire view.

	CString csReturn = _T("");

	CString csPath;

	if (lPosition > -1)
	{
		csPath = GetObjectPath(lPosition);
		if (csPath.GetLength() == 0)
		{
			return csReturn.AllocSysString();
		}
	}
	else
	{
		return csReturn.AllocSysString();
	}

	SCODE sc;
	IWbemClassObject *pObject = NULL;
	BSTR bstrTemp = csPath.AllocSysString();
#ifdef _DEBUG
//	afxDump << "GetObject in GetObjectTitle for " << csPath << "\n";
#endif
	sc =
		m_pServices ->
			GetObject(bstrTemp,0, NULL, &pObject, NULL);
	::SysFreeString(bstrTemp);

	if (sc != S_OK)
	{
		return csReturn.AllocSysString();

	}
	BOOL bDiffNS =
			ObjectInDifferentNamespace
				(m_pServices, &m_csNameSpace, pObject);
	csPath = GetIWbemFullPath(m_pServices,pObject);
	CString csRelPath = GetIWbemRelPath(m_pServices,pObject);
	pObject->Release();

	if (bDiffNS)
	{
		return csPath.AllocSysString();
	}
	else
	{
		return csRelPath.AllocSysString();
	}





}

//*********************************************************
// CMultiViewCtrl::SelectObjectByPosition
//
// Select the specified HMOM class object.
//
// Parameters:
//		[in] long lPosition
//			The position of the HMOM object to select.
//
// Returns:
//		S_OK if the specified object was selected,
//		E_FAIL if the object was not selected.
//
//***********************************************************
SCODE CMultiViewCtrl::SelectObjectByPosition(long lPosition)
{
	// Select the specified instance in the instance list.
	// lPosition is an index into the instance list.

	int nNumRows = m_cgGrid.GetRows();

	if (lPosition >= 0 && lPosition < nNumRows)
	{
		m_cgGrid.SelectRow(lPosition);
		m_cgGrid.CheckForSelectionChange();
		InvalidateControl();
		return S_OK;
	}
	else
	{
		return WBEM_E_NOT_FOUND;
	}

}





//********************************************************
// CMultiViewCtrl::StartViewEnumeration
//
// Start enumerating the alternate views (custom views) that
// the multiview supports (none currently).
//
// Parameters:
//		[in] long lWhere
//			The place to start the enumeration.
//			enum {VIEW_DEFAULT=0, VIEW_CURRENT=1, VIEW_FIRST=2, VIEW_LAST=3};
//
// Returns:
//		long
//			The position of the view in the view list,
//			or -1 if there are no alternate views.
//
//********************************************************
long CMultiViewCtrl::StartViewEnumeration(long lWhere)
{
	// Currently, there are no alternate (custom) views, so return
	// -1 to indicate that there are none.
	return -1;
}



//*********************************************************
// CMultiViewCtrl::SelectView
//
// Select an alternate view (custom view).
//
// Parameters:
//		[in] long lPosition
//			The position of the view in the alternate view list.
//
// Returns:
//		SCODE
//			S_OK if the view was successfully selected, E_FAIL
//			if it was not selected.
//
//***********************************************************
SCODE CMultiViewCtrl::SelectView(long lPosition)
{
	// Currently there are no alternate (custom) views, so it
	// doesn't make any sense to try to select one.
	return E_FAIL;
}



//************************************************************
// CMultiViewCtrl::NextViewTitle
//
// Get the title o the next alternate (custom) view.
//
// Parameters:
//		[in] long lPosition
//			The position of the view that preceeds the desired
//			view in the view list.
//
//		[out] BSTR FAR* pbstrTitle
//			A pointer to the place to return the view's title.
//
// Returns:
//		long
//			The position of the next view (the view who's title
//			is returned). -1 if the end of the view list
//			is reached.
//****************************************************************
long CMultiViewCtrl::NextViewTitle(long lPosition, BSTR FAR* pbstrTitle)
{
	// Currently there are no alternate (custom) views, so just
	// return -1.
	return -1;
}



//************************************************************
// CMultiViewCtrl::GetViewTitle
//
// Get the title o the specified alternate (custom) view.
//
// Parameters:
//		[in] long lPosition
//			The position of the view in the view list.
//
// Returns:
//		BSTR
//			The view title.
//
//****************************************************************
BSTR CMultiViewCtrl::GetViewTitle(long lPosition)
{

	// Currently there are no alternate (custom) views, so just
	// return an empty string for the view titles just in case
	// someone calls this method.

	CString strResult;
	return strResult.AllocSysString();
}


//************************************************************
// CMultiViewCtrl::PrevViewTitle
//
// Get the title o the previous alternate (custom) view.
//
// Parameters:
//		[in] long lPosition
//			The position of the view that follows the desired
//			view in the view list.
//
//		[out] BSTR FAR* pbstrTitle
//			A pointer to the place to return the view's title.
//
// Returns:
//		long
//			The position of the previous view (the view who's title
//			is returned). -1 if the beginning of the view list
//			is reached.
//****************************************************************
long CMultiViewCtrl::PrevViewTitle(long lPosition, BSTR FAR* pbstrTitle)
{
	// Currently there are no alternate (custom) views, so just
	// return -1.
	return -1;
}


IWbemServices *CMultiViewCtrl::InitServices
(CString *pcsNameSpace)
{

    IWbemServices *pSession = 0;
    IWbemServices *pChild = 0;


	CString csObjectPath;

    // hook up to default namespace
	if (pcsNameSpace == NULL)
	{
		csObjectPath = _T("root\\cimv2");
	}
	else
	{
		csObjectPath = *pcsNameSpace;
	}

    CString csUser = _T("");

    pSession = GetIWbemServices(csObjectPath);

    return pSession;
}

IWbemServices *CMultiViewCtrl::GetIWbemServices
(CString &rcsNamespace)
{
	IUnknown *pServices = NULL;

	BOOL bUpdatePointer= FALSE;

	m_sc = S_OK;
	m_bUserCancel = FALSE;

	VARIANT varUpdatePointer;
	VariantInit(&varUpdatePointer);
	varUpdatePointer.vt = VT_I4;
	if (bUpdatePointer == TRUE)
	{
		varUpdatePointer.lVal = 1;
	}
	else
	{
		varUpdatePointer.lVal = 0;
	}

	VARIANT varService;
	VariantInit(&varService);

	VARIANT varSC;
	VariantInit(&varSC);

	VARIANT varUserCancel;
	VariantInit(&varUserCancel);

	FireGetIWbemServices
		((LPCTSTR)rcsNamespace,  &varUpdatePointer,  &varService, &varSC,
		&varUserCancel);

	if (varService.vt & VT_UNKNOWN)
	{
		pServices = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}

	varService.punkVal = NULL;

	VariantClear(&varService);

	if (varSC.vt == VT_I4)
	{
		m_sc = varSC.lVal;
	}
	else
	{
		m_sc = WBEM_E_FAILED;
	}

	VariantClear(&varSC);

	if (varUserCancel.vt == VT_BOOL)
	{
		m_bUserCancel = varUserCancel.boolVal;
	}

	VariantClear(&varUserCancel);

	VariantClear(&varUpdatePointer);

	IWbemServices *pRealServices = NULL;
	if (m_sc == S_OK && !m_bUserCancel)
	{
		pRealServices = reinterpret_cast<IWbemServices *>(pServices);
	}

	return pRealServices;
}

void CMultiViewCtrl::OnShowWindow(BOOL bShow, UINT nStatus)
{
	if (GetSafeHwnd() && AmbientUserMode())
	{
		COleControl::OnShowWindow(bShow, nStatus);
		if (bShow == TRUE)
		{
			NotifyWillShow();
		}
	}

}

IWbemClassObject *CMultiViewCtrl::GetClassFromAnyNamespace(CString &csClass)
{
	IWbemClassObject *pimcoClass = NULL;
	IWbemClassObject *pErrorObject = NULL;

	CString csNameSpace = GetPathNamespace(csClass);

	BOOL bDiffNS =
		csNameSpace.CompareNoCase(m_csNameSpace) != 0;

	IWbemServices *pServices;

	if (bDiffNS)
	{
		pServices = InitServices(&csNameSpace);

		if (!pServices)
		{
			InitializeDisplay(NULL,NULL,NULL);
			CString csUserMsg;
			csUserMsg =  _T("Cannot connect to namespace ") + csNameSpace;
			ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__,
				__LINE__ - 9);
			return 0;
		}
		BSTR bstrTemp = csClass.AllocSysString();
#ifdef _DEBUG
//	afxDump << "GetObject in GetClassFromAnyNamespace for " << csClass << "\n";
#endif
		pServices ->
			GetObject(bstrTemp,0,NULL, &pimcoClass,NULL);
		::SysFreeString(bstrTemp);
		pServices->Release();
	}
	else
	{
		BSTR bstrTemp = csClass.AllocSysString();
#ifdef _DEBUG
//	afxDump << "GetObject in GetClassFromAnyNamespace for " << csClass << "\n";
#endif
		m_sc =
			m_pServices ->
				GetObject(bstrTemp,0,NULL, &pimcoClass,NULL);
		::SysFreeString(bstrTemp);
	}


	return pimcoClass;


}

//***************************************************************************
//
// GetIWbemClassPath
//
// Purpose: Returns the path of the class of the object.
//
//***************************************************************************
CString CMultiViewCtrl::GetIWbemClassPath(IWbemServices *pProv, IWbemClassObject *pimcoObject)
{
	CString csProp = _T("__Path");
	CString csPath = ::GetProperty(pProv,pimcoObject,&csProp);

	CString csClassPath = GetClassFromPath(csPath);

	return csClassPath;

}



//******************************************************
// CMultiViewCtrl::GetPropertyFilter
//
// Get the value of the property filter flags.  The flags
// indicate which type of properties should be displayed
// on the properties tab.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			A long value that is composed of bitflags to
//			indicate which type of properties to show on
//			the properties tab.
//
//			The following values are valid:
//
//				PROPFILTER_SYSTEM
//				PROPFILTER_INHERITED
//				PROPFILTER_LOCAL
//
//*******************************************************
long CMultiViewCtrl::GetPropertyFilter()
{
	return m_lPropFilterFlags;
}




//******************************************************
// CMultiViewCtrl::SetPropertyFilter
//
// Set the value of the property filter flags.  The flags
// indicate which type of properties should be displayed
// on the properties tab.
//
// Parameters:
//		[in] long lPropertyFilter
//			A long value that is composed of bitflags to
//			indicate which type of properties to show on
//			the properties tab.
//
//			The following values are valid:
//
//				PROPFILTER_SYSTEM
//				PROPFILTER_INHERITED
//				PROPFILTER_LOCAL
//
// Returns:
//		Nothing.
//
//*******************************************************
void CMultiViewCtrl::SetPropertyFilter(long lPropFilterFlags)
{
	// Make sure only the flags that we know about are set.
	long lPropFilterFlagsSave = m_lPropFilterFlags;
	m_lPropFilterFlags = lPropFilterFlags  & (PROPFILTER_SYSTEM | PROPFILTER_INHERITED | PROPFILTER_LOCAL);

	if (IsWindowVisible())
	{
		SetAllColVisibility(&m_csaProps,&m_cmstpPropFlavors);
		m_cgGrid.CheckForSelectionChange();
		SetModifiedFlag();
		InvalidateControl();
		m_cgGrid.RedrawWindow();
		m_bPropFilterFlagsChanged = FALSE;
	}
	else
	{
		if (lPropFilterFlagsSave != m_lPropFilterFlags)
		{
			m_bPropFilterFlagsChanged = TRUE;
		}
	}
#if 0
	// Make sure only the flags that we know about are set.
	m_lPropFilterFlags = lPropFilterFlags & (PROPFILTER_SYSTEM | PROPFILTER_INHERITED | PROPFILTER_LOCAL);

	// Verify that the caller did not try to set any bits that we don't understand.
	ASSERT(m_lPropFilterFlags == lPropFilterFlags);


	if (m_lPropFilterFlags != lPrevValue) {
		IWbemClassObject* pco = (IWbemClassObject*) *m_psel;
		if (pco != NULL) {
			m_bSelectingObject = TRUE;
			Refresh();
			m_bSelectingObject = FALSE;
			InvalidateControl();
		}
	}
#endif //0
}

void CMultiViewCtrl::OnUpdateMenuitemgotosingle(CCmdUI* pCmdUI)
{
	// TODO: Add your command update UI handler code here
	// m_cpRightUp;
	int iRow;
	int iCol;
	BOOL bClickedCell = m_cgGrid.PointToCell(m_cpRightUp, iRow, iCol);
	if (!bClickedCell)
	{
		iCol = NULL_INDEX;
		BOOL bClickedRowHandle = m_cgGrid.PointToRowHandle(m_cpRightUp, iRow);
		if (!bClickedRowHandle)
		{
			iRow = NULL_INDEX;
		}
	}

	m_iContextRow = iRow;

	if ((iRow == NULL_INDEX) || m_cgGrid.IsNoInstanceRow(iRow))
	{
		pCmdUI->Enable(FALSE);
	}
	else
	{
		pCmdUI->Enable(TRUE);
	}



}




void CMultiViewCtrl::OnContextMenu(CWnd*, CPoint point)
{
	m_cpRightUp = point;
	ScreenToClient(&m_cpRightUp);

	// CG: This block was added by the Pop-up Menu component
	{
		if (point.x == -1 && point.y == -1){
			//keystroke invocation
			CRect rect;
			GetClientRect(rect);
			ClientToScreen(rect);

			point = rect.TopLeft();
			point.Offset(5, 5);
		}

		CMenu menu;
		VERIFY(menu.LoadMenu(CG_IDR_POPUP_MULTI_VIEW_CTRL));

		CMenu* pPopup = menu.GetSubMenu(0);
#ifdef _DEBUG
		ASSERT(pPopup != NULL);
#endif
		CWnd* pWndPopupOwner = this;

		pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y,
			pWndPopupOwner);
	}
}

void CMultiViewCtrl::OnMenuitemgotosingle()
{
	// TODO: Add your command handler code here
	CString *pcsPath =
			reinterpret_cast<CString *>
				(m_cgGrid.GetAt(m_iContextRow, 0).GetTagValue());
	if (pcsPath)
	{
		FireNotifyViewObjectSelected((LPCTSTR) *pcsPath);
	}
}


SCODE CMultiViewCtrl::GetQueryInstancesAsync
(IWbemServices * pIWbemServices, CString *pcsQueryType, CString *pcsQuery)
{

	m_cpaInstancesForQuery.RemoveAll();

	m_pServicesForAsyncSink = pIWbemServices;
	m_csQueryTypeForAsyncSink = *pcsQueryType;
	m_csQueryForAsyncSink = *pcsQuery;

	m_pAsyncQueryCancelled = FALSE;
	m_pAsyncEnumCancelled = FALSE;
	m_pAsyncQueryRunning = TRUE;

	PostMessage(ID_QUERY_DOMODAL , 0,0);
	PostMessage(ID_GETASYNCQUERYSINK,0,0);



	return WBEM_NO_ERROR;

}

void CMultiViewCtrl::OnSetFocus(CWnd* pOldWnd)
{
	COleControl::OnSetFocus(pOldWnd);
	OnActivateInPlace(TRUE,NULL);
	m_cgGrid.SetFocus();

	// TODO: Add your message handler code here

}

void CMultiViewCtrl::OnKillFocus(CWnd* pNewWnd)
{
	COleControl::OnKillFocus(pNewWnd);


	// TODO: Add your message handler code here

}



void CMultiViewCtrl::OnRequestUIActive()
{
	OnActivateInPlace(TRUE,NULL);
	FireRequestUIActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\multiviewctl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MultiViewCtl.h : Declaration of the CMultiViewCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CMultiViewCtrl : See MultiViewCtl.cpp for implementation.

#define ID_DISPLAYNOINSTANCES WM_USER + 53
#define ID_INSTENUMDONE WM_USER + 54
#define ID_GETASYNCINSTENUMSINK WM_USER + 55
#define ID_ASYNCENUM_DONE WM_USER + 56
#define ID_ASYNCENUM_CANCEL WM_USER + 57
#define ID_ENUM_DOMODAL WM_USER + 58
#define ID_ASYNCQUERY_DONE WM_USER + 59
#define ID_ASYNCQUERY_CANCEL WM_USER + 60
#define ID_QUERYDONE WM_USER + 61
#define ID_GETASYNCQUERYSINK WM_USER + 62
#define ID_QUERY_DOMODAL WM_USER + 63
#define ID_ASYNCQUERY_DISPLAY WM_USER + 64
#define ID_SYNC_ENUM_DOMODAL WM_USER + 65
#define ID_SYNC_ENUM WM_USER + 66
#define ID_SYNC_ENUM_DONE WM_USER + 67
#define INITSERVICES WM_USER + 68
#define CREATE_DIALOG_WITH_DELAY WM_USER + 69
#define END_THE_THREAD WM_USER + 70
#define INITIALIZE_NAMESPACE WM_USER + 300

class CProgressDlg;


struct Pair
	{
		CString csInst1;
		CString csInst2;
		CString csParent;
	};


#define PROPFILTER_SYSTEM		1
#define PROPFILTER_INHERITED	2
#define PROPFILTER_LOCAL		4


class CMultiViewCtrl;
class CAsyncEnumSinkThread;
class CAsyncEnumDialog;
class CAsyncQueryDialog;
class CAsyncQuerySink;
class CAsyncInstEnumSink;
class CSyncEnumDlg;

class CMultiViewGrid : public CGrid
{
public:
	void CheckForSelectionChange();
	void SyncSelectionIndex() {m_iSelectedRow = GetSelectedRow(); }
	BOOL IsNoInstanceRow(int iRow);


protected:
	CMultiViewGrid() {SyncSelectionIndex(); }
	void SetParent (CMultiViewCtrl *pParent)
		{m_pParent = pParent;}
	void OnCellDoubleClicked(int iRow, int iCol);
	void SetRowEditFlag(int nRow, BOOL bEdit = FALSE);
	void OnCellClicked(int iRow, int iCol);
	void OnSetToNoSelection();
	void OnRowHandleClicked(int iRow);
	void OnRowHandleDoubleClicked(int iRow);
	void OnHeaderItemClick(int iColumn);
	void OnRequestUIActive();
	int CompareRows(int iRow1, int iRow2, int iSortOrder);
	BOOL CMultiViewGrid::OnRowKeyDown
		(int iRow, UINT nChar, UINT nRepCnt, UINT nFlags);
	CMultiViewCtrl *m_pParent;
	CWordArray m_cwaColWidth;
	friend class CMultiViewCtrl;

private:
	int m_iSelectedRow;
};

class CMVContext : public IUnknown
{
protected:
    long m_lRef;
	int m_nContextType;
	CString m_csClass;
	CString m_csQuery;
	CString m_csQueryType;
	CString m_csLabel;
	CStringArray m_csaInstances;
	BOOL m_bContextDrawn;
	CString m_csNamespace;
public:
	CMVContext() :	m_nContextType(Unitialized),
					m_lRef(0),
					m_bContextDrawn(FALSE){}
	CMVContext(CMVContext &rhs);
	CMVContext &operator=(const CMVContext &rhs);
	BOOL IsContextEqual(CMVContext &cmvcContext);
	~CMVContext()
	{m_lRef = 0;
	m_bContextDrawn = FALSE;
	m_nContextType = Unitialized;
	m_csClass.Empty();
	m_csQuery.Empty();
	m_csQueryType.Empty();
	m_csLabel.Empty();
	m_csaInstances.RemoveAll();
	m_csNamespace.Empty();}
	enum ContextType {Class, Query, Instances, Unitialized};
	int &GetType() {return m_nContextType;}
	CString &GetClass() {return m_csClass;}
	CString &GetQuery() {return m_csQuery;}
	CString &GetQueryType() {return m_csQueryType;}
	CString &GetLabel() {return m_csLabel;}
	CStringArray &GetInstances() {return m_csaInstances;}
	CString &GetNamespace() {return m_csNamespace;}
	BOOL &IsDrawn() {return m_bContextDrawn;}
	//
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
};


class CAsyncQuerySink : public IWbemObjectSink
{
protected:
    long m_lRef;
	CMultiViewCtrl *m_pMultiViewCtrl;
	long m_lAsyncRequestHandle;
	UINT m_uSinkTimer;
public:
    CAsyncQuerySink(CMultiViewCtrl *pMultiViewCtrl = NULL)
		:	m_lRef(0),
			m_lAsyncRequestHandle(0),
			m_uSinkTimer(0),
			m_pMultiViewCtrl(pMultiViewCtrl)
		{}
    ~CAsyncQuerySink();
	void ShutDownSink();

     HRESULT STDMETHODCALLTYPE SetStatus(
            /* [in] */ long lFlags,
            /* [in] */ long lParam,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam) {return S_OK; }

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR** rgszNames, UINT cNames,
      LCID lcid, DISPID* rgdispid)
    {return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
      DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
      UINT* puArgErr)
    {return E_NOTIMPL;}

    STDMETHOD_(SCODE, Indicate)(long lObjectCount,
        IWbemClassObject FAR* FAR* pObjArray);
	friend class CMultiViewCtrl;
	friend class CAsyncQuerySinkThread;
};


class CAsyncInstEnumSink : public IWbemObjectSink
{
protected:
    long m_lRef;
	CMultiViewCtrl *m_pMultiViewCtrl;
	long m_lAsyncRequestHandle;
	UINT m_uSinkTimer;
public:
    CAsyncInstEnumSink(CMultiViewCtrl *pMultiViewCtrl = NULL)
		:	m_lRef(0),
			m_lAsyncRequestHandle(0),
			m_uSinkTimer(0),
			m_pMultiViewCtrl(pMultiViewCtrl)
		{}
    ~CAsyncInstEnumSink();
     HRESULT STDMETHODCALLTYPE SetStatus(
            /* [in] */ long lFlags,
            /* [in] */ long lParam,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam) {return S_OK; }

	void ShutDownSink();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR** rgszNames, UINT cNames,
      LCID lcid, DISPID* rgdispid)
    {return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
      DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
      UINT* puArgErr)
    {return E_NOTIMPL;}

    STDMETHOD_(SCODE, Indicate)(long lObjectCount,
        IWbemClassObject FAR* FAR* pObjArray);
	friend class CMultiViewCtrl;
	friend class CAsyncEnumSinkThread;
};


class CMultiViewCtrl : public COleControl
{
	DECLARE_DYNCREATE(CMultiViewCtrl)

// Constructor
public:
	CMultiViewCtrl();
	enum { NONE, CLASS, INSTANCES, ZERO_CLASS_INST};
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMultiViewCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	afx_msg void OnContextMenu(CWnd*, CPoint point);
	~CMultiViewCtrl();
	CString m_csNameSpace;
	CString m_csClass;
	CStringArray m_csaProps;
	CMapStringToPtr m_cmstpPropFlavors;
	int m_nClassOrInstances; // 0 = none, 1 = class, 2 = instances;
	void InitializeDisplay
		(CString *pcsClass, CPtrArray *pcpaInstances, CStringArray *pcsaProps,
		CString *pcsMessage = NULL, CMapStringToPtr *pcmstpPropFlavors = NULL);

	BOOL IsColVisible(long lFilter, long lFlavor);
	void SetAllColVisibility( CStringArray *pcsaProps, CMapStringToPtr *pcmstpPropFlavors);
	void AddToDisplay(CPtrArray *pcpaInstances);

	void InitializeDisplayMessage(CString *pcsMessage);
	void OnRequestUIActive();

	IWbemClassObject *CommonParent(CStringArray *pcsaPaths);
	IWbemClassObject *LowestCommonParent(CStringArray *pcsaPaths);
	IWbemClassObject *ParentFromDerivations(CStringArray **pcsaDerivation, int iIndex);

	BOOL  ClassInClasses(CStringArray *pcsaClasses, CString *pcsParent);

	IWbemClassObject *GetClassFromAnyNamespace(CString &csClass);
	CString GetIWbemClassPath
		(IWbemServices *pProv, IWbemClassObject *pimcoObject);

	int ObjectInGrid(CString *pcsPathIn);

	CMultiViewGrid m_cgGrid;

	IWbemServices *m_pServices;

	SCODE m_sc;
	BOOL m_bUserCancel;

	BOOL m_bInOnDraw;
	BOOL m_bInitServices;

	CPoint m_cpRightUp;
	int m_iContextRow;

	IWbemServices *InitServices(CString *pcsNameSpace);
	IWbemServices *GetIWbemServices(CString &rcsNamespace);

	CSyncEnumDlg *m_pcsedDialog;
	CAsyncEnumDialog *m_pcaedDialog;
	CAsyncQueryDialog *m_pcaqdDialog;
	int m_nInstances;

	BOOL m_pAsyncEnumCancelled;
	BOOL m_pAsyncEnumRunning;

	BOOL m_pAsyncQueryCancelled;
	BOOL m_pAsyncQueryRunning;

	SCODE GetInstancesAsync
		(IWbemServices * pIWbemServices, CString *pcsClass);

	SCODE SemiSyncClassInstancesIncrementalAddToDisplay
		(IWbemServices * pIWbemServices, IWbemClassObject *pimcoClass,
		CString *pcsClass,
		 CPtrArray &cpaInstances, int &cInst, BOOL &bCancel);

	SCODE SemiSyncQueryInstancesIncrementalAddToDisplay
		(IWbemServices * pIWbemServices,
		IEnumWbemClassObject *pimecoInstanceEnum,
		 CPtrArray &cpaInstances,int &cInst, BOOL &bCancel);

	SCODE SemiSyncQueryInstancesNonincrementalAddToDisplay
		(CPtrArray *& pcpaInstances, IEnumWbemClassObject *pemcoObjects, BOOL &bCancel);

	SCODE GetQueryInstancesAsync
		(	IWbemServices * pIWbemServices,
			CString *pcsQueryType,
			CString *pcsQuery);


	CString m_csSyncEnumClass;

	BOOL m_bSelectionNotChanging;

	CProgressDlg *m_pProgressDlg;
	void SetProgressDlgMessage(CString &csMessage);
	void CreateProgressDlgWindow();
	BOOL CheckCancelButtonProgressDlgWindow();
	void DestroyProgressDlgWindow();
	void PumpMessagesProgressDlgWindow();

	void ViewClassInstancesSync(LPCTSTR lpszClassName);
	void ViewClassInstancesAsync(LPCTSTR lpszClassName);
	void QueryViewInstancesSync
		(LPCTSTR szTitle, LPCTSTR szQueryType, LPCTSTR szQuery, LPCTSTR szClass);
	void QueryViewInstancesAsync
		(LPCTSTR szTitle, LPCTSTR szQueryType, LPCTSTR szQuery, LPCTSTR szClass);
	void QueryViewInstancesSyncWithoutClass
		(LPCTSTR szTitle, LPCTSTR szQueryType, LPCTSTR szQuery);
	void QueryViewInstancesSyncWithClass
		(LPCTSTR szTitle, LPCTSTR szQueryType, LPCTSTR szQuery, LPCTSTR szClass);


	CMVContext *m_pcmvcCurrentContext;
	SCODE ViewInstancesInternal(LPCTSTR szTitle, CStringArray &rcsaPathArray);

	HICON LoadIcon(CString pcsFile);

	CAsyncInstEnumSink *m_pInstEnumObjectSink;
	CAsyncQuerySink *m_pAsyncQuerySink;

	IWbemServices *m_pServicesForAsyncSink;
	CString m_csClassForAsyncSink;
	CString m_csQueryTypeForAsyncSink;
	CString m_csQueryForAsyncSink;
	CPtrArray m_cpaInstancesForQuery;

	CString m_csNamespaceToInit;

	DECLARE_OLECREATE_EX(CMultiViewCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CMultiViewCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CMultiViewCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CMultiViewCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CMultiViewCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDestroy();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnMenuitemgotosingle();
	afx_msg void OnUpdateMenuitemgotosingle(CCmdUI* pCmdUI);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG

	afx_msg LRESULT DisplayNoInstances(WPARAM, LPARAM);
	afx_msg LRESULT InstEnumDone(WPARAM, LPARAM);
	afx_msg LRESULT QueryDone(WPARAM, LPARAM);
	afx_msg LRESULT GetEnumSink(WPARAM, LPARAM);
	afx_msg LRESULT GetQuerySink(WPARAM, LPARAM);
	afx_msg LRESULT EnumDoModalDialog(WPARAM, LPARAM);
	afx_msg LRESULT SyncEnumDoModalDialog(WPARAM, LPARAM);
	afx_msg LRESULT SyncEnum(WPARAM, LPARAM);
	afx_msg LRESULT QueryDoModalDialog(WPARAM, LPARAM);
	afx_msg LRESULT AsyncEnumCancelled(WPARAM, LPARAM);
	afx_msg LRESULT AsyncQueryCancelled(WPARAM, LPARAM);
	afx_msg LRESULT DisplayAsyncQueryInstances(WPARAM, LPARAM);
	afx_msg LRESULT InitServices(WPARAM, LPARAM);
	afx_msg LRESULT OpenNamespace(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CMultiViewCtrl)
	afx_msg BSTR GetNameSpace();
	afx_msg void SetNameSpace(LPCTSTR lpszNewValue);
	afx_msg long GetPropertyFilter();
	afx_msg void SetPropertyFilter(long nNewValue);
	afx_msg void ViewClassInstances(LPCTSTR lpszClassName);
	afx_msg void ForceRedraw();
	afx_msg long CreateInstance();
	afx_msg long DeleteInstance();
	afx_msg long GetContext(long FAR* pCtxHandle);
	afx_msg long RestoreContext(long lCtxtHandle);
	afx_msg long AddContextRef(long lCtxtHandle);
	afx_msg long ReleaseContext(long lCtxtHandle);
	afx_msg long GetEditMode();
	afx_msg BSTR GetObjectPath(long lPosition);
	afx_msg BSTR GetObjectTitle(long lPosition);
	afx_msg long GetTitle(BSTR FAR* pbstrTitle, LPDISPATCH FAR* lpPictDisp);
	afx_msg BSTR GetViewTitle(long lPosition);
	afx_msg long NextViewTitle(long lPosition, BSTR FAR* pbstrTitle);
	afx_msg void ExternInstanceCreated(LPCTSTR szObjectPath);
	afx_msg void ExternInstanceDeleted(LPCTSTR szObjectPath);
	afx_msg void NotifyWillShow();
	afx_msg long PrevViewTitle(long lPosition, BSTR FAR* pbstrTitle);
	afx_msg long QueryCanCreateInstance();
	afx_msg long QueryCanDeleteInstance();
	afx_msg long QueryNeedsSave();
	afx_msg long QueryObjectSelected();
	afx_msg long RefreshView();
	afx_msg long SaveData();
	afx_msg long SelectView(long lPosition);
	afx_msg void SetEditMode(long bCanEdit);
	afx_msg long StartObjectEnumeration(long lWhere);
	afx_msg long StartViewEnumeration(long lWhere);
	afx_msg long ViewInstances(LPCTSTR szTitle, const VARIANT FAR& varPathArray);
	afx_msg void QueryViewInstances(LPCTSTR szTitle, LPCTSTR szQueryType, LPCTSTR szQuery, LPCTSTR szClass);
	afx_msg long NextObject(long lPosition);
	afx_msg long PrevObject(long lPosition);
	afx_msg long SelectObjectByPath(LPCTSTR szObjectPath);
	afx_msg long SelectObjectByPosition(long lPosition);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CMultiViewCtrl)
	void FireNotifyViewModified()
		{FireEvent(eventidNotifyViewModified,EVENT_PARAM(VTS_NONE));}
	void FireNotifySelectionChanged()
		{FireEvent(eventidNotifySelectionChanged,EVENT_PARAM(VTS_NONE));}
	void FireNotifySaveRequired()
		{FireEvent(eventidNotifySaveRequired,EVENT_PARAM(VTS_NONE));}
	void FireNotifyViewObjectSelected(LPCTSTR szObjectPath)
		{FireEvent(eventidNotifyViewObjectSelected,EVENT_PARAM(VTS_BSTR), szObjectPath);}
	void FireGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
		{FireEvent(eventidGetIWbemServices,EVENT_PARAM(VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT), lpctstrNamespace, pvarUpdatePointer, pvarServices, pvarSC, pvarUserCancel);}
	void FireNotifyContextChanged(long bPushContext)
		{FireEvent(eventidNotifyContextChanged,EVENT_PARAM(VTS_I4), bPushContext);}
	void FireRequestUIActive()
		{FireEvent(eventidRequestUIActive,EVENT_PARAM(VTS_NONE));}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

	friend class CMultiViewGrid;
	friend class CAsyncInstEnumSink;
	friend class CAsyncEnumSinkThread;
	friend class CAsyncEnumDialog;
	friend class CAsyncQuerySink;
	friend class CAsyncQuerySinkThread;
	friend class CAsyncQueryDialog;
	friend class CSyncEnumDlg;

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CMultiViewCtrl)
	dispidViewClassInstances = 3L,
	dispidForceRedraw = 4L,
	dispidCreateInstance = 5L,
	dispidDeleteInstance = 6L,
	dispidGetContext = 7L,
	dispidRestoreContext = 8L,
	dispidAddContextRef = 9L,
	dispidReleaseContext = 10L,
	dispidGetEditMode = 11L,
	dispidGetObjectPath = 12L,
	dispidGetObjectTitle = 13L,
	dispidGetTitle = 14L,
	dispidGetViewTitle = 15L,
	dispidNextViewTitle = 16L,
	dispidExternInstanceCreated = 17L,
	dispidExternInstanceDeleted = 18L,
	dispidNotifyWillShow = 19L,
	dispidPrevViewTitle = 20L,
	dispidQueryCanCreateInstance = 21L,
	dispidQueryCanDeleteInstance = 22L,
	dispidQueryNeedsSave = 23L,
	dispidQueryObjectSelected = 24L,
	dispidRefreshView = 25L,
	dispidSaveData = 26L,
	dispidSelectView = 27L,
	dispidSetEditMode = 28L,
	dispidStartObjectEnumeration = 29L,
	dispidStartViewEnumeration = 30L,
	dispidViewInstances = 31L,
	dispidQueryViewInstances = 32L,
	dispidNextObject = 33L,
	dispidPrevObject = 34L,
	dispidSelectObjectByPath = 35L,
	dispidSelectObjectByPosition = 36L,
	eventidNotifyViewModified = 1L,
	eventidNotifySelectionChanged = 2L,
	eventidNotifySaveRequired = 3L,
	eventidNotifyViewObjectSelected = 4L,
	eventidGetIWbemServices = 5L,
	eventidNotifyContextChanged = 6L,
	eventidRequestUIActive = 7L,
	//}}AFX_DISP_ID
	};

private:
	BOOL m_bCanEdit;		// TRUE = Studio mode, FALSE = Browser mode
	long m_lPropFilterFlags;
	BOOL m_bPropFilterFlagsChanged;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\multiviewppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MultiViewPpg.h : Declaration of the CMultiViewPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CMultiViewPropPage : See MultiViewPpg.cpp.cpp for implementation.

class CMultiViewPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CMultiViewPropPage)
	DECLARE_OLECREATE_EX(CMultiViewPropPage)

// Constructor
public:
	CMultiViewPropPage();

// Dialog Data
	//{{AFX_DATA(CMultiViewPropPage)
	enum { IDD = IDD_PROPPAGE_MULTIVIEW };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CMultiViewPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\progdlg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//  ProgDlg.cpp : implementation file
// CG: This file was added by the Progress Dialog component

#include "precomp.h"
#include "MultiView.h"
#include "resource.h"
#include <wbemidl.h>
#include "olemsclient.h"
#include "ProgDlg.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


extern CMultiViewApp NEAR theApp;


/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog

CProgressDlg::CProgressDlg(UINT nCaptionID)
{
	m_hwndFocusPrev = NULL;
    m_bCancel=FALSE;

    //{{AFX_DATA_INIT(CProgressDlg)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_bParentDisabled = FALSE;
}

CProgressDlg::~CProgressDlg()
{
    if(m_hWnd!=NULL)
      DestroyWindow();
}

BOOL CProgressDlg::DestroyWindow()
{
    ReEnableParent();
    return CDialog::DestroyWindow();
}

void CProgressDlg::ReEnableParent()
{
	CWnd *pParentOwner = CWnd::GetSafeOwner(m_pParentWnd);

    if(m_bParentDisabled && (pParentOwner!=NULL))
      pParentOwner->EnableWindow(TRUE);
    m_bParentDisabled=FALSE;
	if ((m_hwndFocusPrev != NULL) && ::IsWindow(m_hwndFocusPrev)) {
		::SetFocus(m_hwndFocusPrev);
	}
	m_hwndFocusPrev = NULL;
}

BOOL CProgressDlg::Create(CWnd *pParent)
{
	m_hwndFocusPrev = ::GetFocus();
	m_pParentWnd = pParent;

    // m_bParentDisabled is used to re-enable the parent window
    // when the dialog is destroyed. So we don't want to set
    // it to TRUE unless the parent was already enabled.

	// Get the true parent of the dialog
	CWnd *pParentOwner = CWnd::GetSafeOwner(m_pParentWnd);
    if((pParentOwner!=NULL) && pParentOwner->IsWindowEnabled())
    {
      pParentOwner->EnableWindow(FALSE);
      m_bParentDisabled = TRUE;
    }

    if(!CDialog::Create(CProgressDlg::IDD,pParentOwner))
    {
      ReEnableParent();
      return FALSE;
    }

    return TRUE;
}

void CProgressDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CProgressDlg)
	DDX_Control(pDX, CG_IDC_PROGDLG_STATUS, m_cstaticMessage);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CProgressDlg, CDialog)
    //{{AFX_MSG_MAP(CProgressDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CProgressDlg::SetStatus(LPCTSTR lpszMessage)
{
    ASSERT(m_hWnd); // Don't call this _before_ the dialog has
                    // been created. Can be called from OnInitDialog
    CWnd *pWndStatus = GetDlgItem(CG_IDC_PROGDLG_STATUS);

    // Verify that the static text control exists
    ASSERT(pWndStatus!=NULL);
    pWndStatus->SetWindowText(lpszMessage);
}

void CProgressDlg::OnCancel()
{
    m_bCancel=TRUE;
}

void CProgressDlg::PumpMessages()
{
    // Must call Create() before using the dialog
    ASSERT(m_hWnd!=NULL);

    MSG msg;
    // Handle dialog messages
    while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
      if(!IsDialogMessage(&msg))
      {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
      }
    }
}

BOOL CProgressDlg::CheckCancelButton()
{
    // Process all pending messages
    PumpMessages();
    BOOL bResult = m_bCancel;

    return bResult;
}


/////////////////////////////////////////////////////////////////////////////
// CProgressDlg message handlers


BOOL CProgressDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

	m_bCancel = FALSE;

	CString strCaption;

	m_cstaticMessage.SetWindowText(m_csMessage);

	MoveWindowToLowerLeftOfOwner(this);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\progressdlgthread.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ProgressDlgThread.cpp : implementation file
//

#include "precomp.h"
#include <wbemsvc.h>
#include "olemsclient.h"
#include "grid.h"
#include "multiview.h"
#include "MultiViewCtl.h"
#include "ProgressDlgThread.h"
#include "ProgDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define nIDEventDelayShow 3000

CProgressDlgThread *gpProgressThread;

void CALLBACK EXPORT  ShowWindowAfterDelay
		(HWND hWnd,UINT nMsg,UINT nIDEvent, DWORD dwTime)
{
	if (gpProgressThread)
	{
		gpProgressThread->CreateDialogWithDelay(0,0);

	}
}

/////////////////////////////////////////////////////////////////////////////
// CProgressDlgThread

IMPLEMENT_DYNCREATE(CProgressDlgThread, CWinThread)

CProgressDlgThread::CProgressDlgThread()
{
	gpProgressThread = NULL;
	m_uiTimer = NULL;
	m_pcpdMessage = NULL;
}

CProgressDlgThread::~CProgressDlgThread()
{
}

BOOL CProgressDlgThread::InitInstance()
{
	// TODO:  perform and per-thread initialization here
	gpProgressThread = this;
	m_uiTimer =
		::SetTimer
		(NULL, nIDEventDelayShow, nIDEventDelayShow, ShowWindowAfterDelay);


	return TRUE;
}

int CProgressDlgThread::ExitInstance()
{
	// TODO:  perform any per-thread cleanup here
	if (m_uiTimer)
	{
		KillTimer(NULL, m_uiTimer );
		m_uiTimer = NULL;
	}

	gpProgressThread = NULL;

	if (m_pcpdMessage && m_pcpdMessage->GetSafeHwnd())
	{
		m_pcpdMessage->DestroyWindow();
		delete m_pcpdMessage;
		m_pcpdMessage = NULL;
	}
	else if (m_pcpdMessage)
	{
		delete m_pcpdMessage;
		m_pcpdMessage = NULL;
	}

	return CWinThread::ExitInstance();
}

BEGIN_MESSAGE_MAP(CProgressDlgThread, CWinThread)
	//{{AFX_MSG_MAP(CProgressDlgThread)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
	ON_THREAD_MESSAGE(CREATE_DIALOG_WITH_DELAY, CreateDialogWithDelay)
	ON_THREAD_MESSAGE(END_THE_THREAD, EndTheThread)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProgressDlgThread message handlers

LRESULT CProgressDlgThread::CreateDialogWithDelay(WPARAM, LPARAM)
{
	if (m_uiTimer)
	{
		KillTimer(NULL, m_uiTimer );
		m_uiTimer = NULL;
	}

	m_pcpdMessage = new CProgressDlg;
	m_pcpdMessage->SetMessage(m_csMessage);

	m_pcpdMessage->Create();

	return 0;
}

LRESULT CProgressDlgThread::EndTheThread(WPARAM, LPARAM)
{
	if (m_uiTimer)
	{
		KillTimer(NULL, m_uiTimer );
		m_uiTimer = NULL;
	}

	gpProgressThread = NULL;

	if (m_pcpdMessage && m_pcpdMessage->GetSafeHwnd())
	{
		m_pcpdMessage->DestroyWindow();
		delete m_pcpdMessage;
		m_pcpdMessage = NULL;
	}
	else if (m_pcpdMessage)
	{
		delete m_pcpdMessage;
		m_pcpdMessage = NULL;
	}

	AfxEndThread( 0 );
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\progdlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ProgDlg.h : header file
// CG: This file was added by the Progress Dialog component

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog

#ifndef __PROGDLG_H__
#define __PROGDLG_H__

class CProgressDlg : public CDialog
{
// Construction / Destruction
public:
    CProgressDlg(UINT nCaptionID = 0);   // standard constructor
    ~CProgressDlg();

    BOOL Create(CWnd *pParent=NULL);
	void SetMessage(CString &csMessage) 
	{m_csMessage = csMessage;}
	void PumpMessages();

    // Checking for Cancel button
    BOOL CheckCancelButton();
    // Progress Dialog manipulation
    void SetStatus(LPCTSTR lpszMessage);
    
// Dialog Data
    //{{AFX_DATA(CProgressDlg)
	enum { IDD = CG_IDD_PROGRESS };
	CStatic	m_cstaticMessage;
	//}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CProgressDlg)
    public:
    virtual BOOL DestroyWindow();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
	
	CString m_csMessage;

    BOOL m_bCancel;
    BOOL m_bParentDisabled;

    void ReEnableParent();

    // Generated message map functions
    //{{AFX_MSG(CProgressDlg)
    virtual BOOL OnInitDialog();
	virtual void OnCancel();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
	HWND m_hwndFocusPrev;
};

#endif // __PROGDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\progressdlgthread.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_PROGRESSDLGTHREAD_H__C7E495F1_044D_11D1_964A_00C04FD9B15B__INCLUDED_)
#define AFX_PROGRESSDLGTHREAD_H__C7E495F1_044D_11D1_964A_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ProgressDlgThread.h : header file
//

class CProgressDlg;

/////////////////////////////////////////////////////////////////////////////
// CProgressDlgThread thread

class CProgressDlgThread : public CWinThread
{
	DECLARE_DYNCREATE(CProgressDlgThread)
protected:
	CProgressDlgThread();           // protected constructor used by dynamic creation
	CString m_csMessage;
	UINT m_uiTimer;
// Attributes
public:
	void SetMessage(CString &csMessage)
	{m_csMessage = csMessage;}

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProgressDlgThread)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CProgressDlgThread();

	// Generated message map functions
	//{{AFX_MSG(CProgressDlgThread)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
public:
	afx_msg LRESULT CreateDialogWithDelay(WPARAM, LPARAM);
protected:
	CProgressDlg *m_pcpdMessage;
	afx_msg LRESULT EndTheThread(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROGRESSDLGTHREAD_H__C7E495F1_044D_11D1_964A_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls
#include <afxcmn.h>
// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#endif //_UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\olemsclient.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved



typedef enum
{
	ALL_INSTANCES = 1,
	ASSOC_GROUPING,
	OBJECT_GROUPING_WITH_INSTANCES,
	OBJECT_GROUPING_NO_INSTANCES,
	NO_APPEAR,
	ALL_IGNORE
} NAVIGATOR_APPEARANCE;



SCODE MakeSafeArray(SAFEARRAY FAR ** pRet, VARTYPE vt, int iLen);

SCODE PutStringInSafeArray
(SAFEARRAY FAR * psa,CString *pcs, int iIndex);


BOOL SetProperty
(IWbemServices * pProv, IWbemClassObject * pInst, 
 CString *pcsProperty, CString *pcsPropertyValue);

BOOL GetPropertyAsVariant
(IWbemClassObject * pInst, 
 CString *pcsProperty,VARIANT &varOut, CIMTYPE& cimtypeOut );

CString GetProperty
(IWbemServices * pProv, IWbemClassObject * pInst, 
 CString *pcsProperty);

int GetSortedPropNames
(IWbemClassObject * pClass, CStringArray &rcsaReturn, CMapStringToPtr &rcmstpPropFlavors);

CPtrArray *GetObjectInstances
(IWbemServices * pProv, IWbemClassObject *pAssoc, 
 IWbemClassObject *pimcoExclude = NULL);

int GetPropNames
(IWbemClassObject * pClass, CStringArray *&pcsaReturn);

CString GetBSTRAttrib
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName);

CString BuildOBJDBGetRefQuery
(IWbemServices *pProv, IWbemClassObject *pimcoTarget, 
 IWbemClassObject *pimcoResultClass, CString *pcsRoleFilter,
 CString *pcsReqAttrib = NULL, BOOL bClassOnly = FALSE);

CString BuildOBJDBGetAssocsQuery
(IWbemServices *pProv, IWbemClassObject *pimcoTarget, 
 IWbemClassObject *pimcoAssocClass, IWbemClassObject *pimcoResultClass, 
 CString *pcsMyRoleFilter, CString *pcsReqAttrib = NULL, 
 CString *pcsReqAssocAttrib = NULL, BOOL bClassOnly = FALSE);

IEnumWbemClassObject *ExecOBJDBQuery
(IWbemServices * pProv, CString &csQuery);

CString GetIWbemClass(IWbemServices *pProv, IWbemClassObject *pClass);

CString GetIWbemClass(IWbemServices *pProv, CString *pcsPath);

CString GetIWbemClassPath(IWbemServices *pProv, CString *pcsPath);


CString GetIWbemSuperClass(IWbemServices *pProv, IWbemClassObject *pClass);

CString GetIWbemSuperClass(IWbemServices *pProv, CString *pcsClass, BOOL bClass);

CString GetIWbemRelPath(IWbemServices *pProv, IWbemClassObject *pClass);

CString GetIWbemFullPath(IWbemServices *pProv, IWbemClassObject *pClass);

IWbemClassObject *GetClassObject 
(IWbemServices *pProv,IWbemClassObject *pimcoInstance);

BOOL ObjectInDifferentNamespace
(IWbemServices *pProv, CString *pcsNamespace, IWbemClassObject *pObject);

CString GetObjectNamespace
(IWbemServices *pProv, IWbemClassObject *pObject);

IEnumWbemClassObject *ExecQuery
(IWbemServices * pProv, CString &csQueryType, CString &rcsQuery, CString &rcsNamespace);

CPtrArray *GetObjectInstancesFromEnum 
(IEnumWbemClassObject *pemcoObjects, BOOL &bCancel);

BOOL ObjectIsDynamic(SCODE& sc, IWbemClassObject* pco) ;

CString GetSDKDirectory();

CStringArray *ClassDerivation (IWbemServices *pServices, CString &rcsPath);

CStringArray *ClassDerivation (IWbemClassObject *pObject);

void ErrorMsg
(CString *pcsUserMsg, SCODE sc, BOOL bUseErrorObject,
 BOOL bLog, CString *pcsLogMsg, char *szFile, int nLine,
 UINT uType = MB_ICONEXCLAMATION);

void LogMsg
(CString *pcsLogMsg, char *szFile, int nLine);

CString GetPathNamespace (CString &csPath);

CString GetClassFromPath(CString &csPath);
CString GetClassNameFromPath(CString &csPath);

void MoveWindowToLowerLeftOfOwner(CWnd *pWnd);

void IntersectInPlace (CStringArray& dest, CStringArray& ar);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\provider.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: MosProvider_v1 */

#ifndef _MosProvider_v1_H_
#define _MosProvider_v1_H_

DEFINE_GUID(LIBID_MosProvider_v1,0x027947F3L,0xD731,0x11CE,0xA3,0x57,0x00,0x00,0x00,0x00,0x00,0x01);

typedef enum {
    OLEMS_FLAG_KEYS_ONLY = 1,
    OLEMS_FLAG_ALWAYS,
    OLEMS_FLAG_ONLY_IF_TRUE,
    OLEMS_FLAG_ONLY_IF_FALSE,
    OLEMS_FLAG_ONLY_IF_IDENTICAL,
    OLEMS_FLAG_INCLUDE_ATTR,
    OLEMS_FLAG_CLASS_ATTRIB,
    OLEMS_FLAG_PRIVATE_ATTRIB,
    OLEMS_FLAG_TEMP_ATTRIB,
    OLEMS_FLAG_NAMESPACE_ATTRIB,
    OLEMS_FLAG_SHALLOW,
    OLEMS_FLAG_DEEP,
    OLEMS_FLAG_NO_EXPANSION,
    OLEMS_FLAG_PREFER_THIS,
    OLEMS_FLAG_PREFER_SOURCE
} OLEMS_FLAG_TYPE;

typedef enum {
    OLEMS_NO_ERROR = 0,
    OLEMS_S_NO_MORE_DATA = 262145,
    OLEMS_E_FAILED = -2147217407,
    OLEMS_E_NOT_FOUND,
    OLEMS_E_ACCESS_DENIED,
    OLEMS_E_PERMISSION_DENIED,
    OLEMS_E_PROVIDER_FAILURE,
    OLEMS_E_TYPE_MISMATCH,
    OLEMS_E_INVALID_ENV_VAR,
    OLEMS_E_OUT_OF_MEMORY,
    OLEMS_E_UNSUPPORTED_VARIANT,
    OLEMS_E_NETWORK_ERROR,
    OLEMS_E_INVALID_CONTEXT,
    OLEMS_E_INVALID_PARAMETER,
    OLEMS_E_NOT_AVAILABLE,
    OLEMS_E_CRITICAL_ERROR,
    OLEMS_E_INVALID_STREAM,
    OLEMS_E_NOT_SUPPORTED,
    OLEMS_E_INVALID_SUPERCLASS,
    OLEMS_E_INVALID_NAMESPACE,
    OLEMS_E_INVALID_OBJECT,
    OLEMS_E_INVALID_CLASS,
    OLEMS_E_PROVIDER_NOT_FOUND,
    OLEMS_E_INVALID_PROVIDER_REGISTRATION,
    OLEMS_E_PROVIDER_LOAD_FAILURE
} OLEMS_STATUS;

DEFINE_GUID(IID_IMosAttributeSet,0xDC12A680L,0x737F,0x11CF,0x88,0x4D,0x00,0xAA,0x00,0x4B,0x2E,0x24);

/* Definition of interface: IMosAttributeSet */
#undef INTERFACE
#define INTERFACE IMosAttributeSet

DECLARE_INTERFACE_(IMosAttributeSet, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IMosAttributeSet methods */
    STDMETHOD_(SCODE, Get)(THIS_ BSTR Name, long lFlags, long FAR* plType, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, Put)(THIS_ BSTR Name, long lType, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, Delete)(THIS_ BSTR Name) PURE;
    STDMETHOD_(SCODE, GetNames)(THIS_ SAFEARRAY FAR* FAR* pNames) PURE;
    STDMETHOD_(SCODE, Reset)(THIS) PURE;
    STDMETHOD_(SCODE, Next)(THIS_ long lFlags, BSTR FAR* pName, long FAR* plType, VARIANT FAR* pVal) PURE;
};

DEFINE_GUID(IID_IMosClassObject,0xDC12A681L,0x737F,0x11CF,0x88,0x4D,0x00,0xAA,0x00,0x4B,0x2E,0x24);

/* Definition of interface: IMosClassObject */
#undef INTERFACE
#define INTERFACE IMosClassObject

DECLARE_INTERFACE_(IMosClassObject, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IMosClassObject methods */
    STDMETHOD_(SCODE, GetAttributeSet)(THIS_ IMosAttributeSet FAR* FAR* pAttribSet) PURE;
    STDMETHOD_(SCODE, Get)(THIS_ BSTR Name, long lFlags, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, Put)(THIS_ BSTR Name, long lFlags, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, Delete)(THIS_ BSTR Name) PURE;
    STDMETHOD_(SCODE, GetNames)(THIS_ SAFEARRAY FAR* FAR* pNames, BSTR AttrName, long lFlags, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, GetType)(THIS_ BSTR Name, long FAR* plType) PURE;
    STDMETHOD_(SCODE, Reset)(THIS) PURE;
    STDMETHOD_(SCODE, Next)(THIS_ long lFlags, BSTR FAR* pName, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, GetPropAttributeSet)(THIS_ BSTR pProperty, IMosAttributeSet FAR* FAR* pAttribSet) PURE;
    STDMETHOD_(SCODE, Clone)(THIS_ IMosClassObject FAR* FAR* pCopy) PURE;
    STDMETHOD_(SCODE, CopyHere)(THIS_ IMosClassObject FAR* pSrc) PURE;
    STDMETHOD_(SCODE, Merge)(THIS_ long lFlags, IMosClassObject FAR* pSrc) PURE;
    STDMETHOD_(SCODE, PutAttribForAllProps)(THIS_ BSTR Name, long lType, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, DeleteAttribForAllProps)(THIS_ BSTR Name, long lFlags, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, DeleteProps)(THIS_ BSTR Attrib, long lFlags, VARIANT FAR* pVal) PURE;
    STDMETHOD_(SCODE, GetObjectText)(THIS_ BSTR FAR* pMofSyntax) PURE;
};

DEFINE_GUID(IID_IMosNotify,0x7C857801L,0x7381,0x11CF,0x88,0x4D,0x00,0xAA,0x00,0x4B,0x2E,0x24);

/* Definition of interface: IMosNotify */
#undef INTERFACE
#define INTERFACE IMosNotify

DECLARE_INTERFACE_(IMosNotify, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IMosNotify methods */
    STDMETHOD_(SCODE, Notify)(THIS_ long lObjectCount, IMosClassObject FAR* FAR* pObjArray) PURE;
};

DEFINE_GUID(IID_IEnumMosClassObject,0x027947E1L,0xD731,0x11CE,0xA3,0x57,0x00,0x00,0x00,0x00,0x00,0x01);

/* Definition of interface: IEnumMosClassObject */
#undef INTERFACE
#define INTERFACE IEnumMosClassObject

DECLARE_INTERFACE_(IEnumMosClassObject, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IEnumMosClassObject methods */
    STDMETHOD_(SCODE, Reset)(THIS) PURE;
    STDMETHOD_(SCODE, Next)(THIS_ ULONG uCount, IMosClassObject FAR* FAR* pProp, ULONG FAR* puReturned) PURE;
    STDMETHOD_(SCODE, Clone)(THIS_ IEnumMosClassObject FAR* FAR* pEnum) PURE;
    STDMETHOD_(SCODE, Skip)(THIS_ ULONG nNum) PURE;
};

DEFINE_GUID(IID_IMosProvider,0x9556DC99L,0x828C,0x11CF,0xA3,0x7E,0x00,0xAA,0x00,0x32,0x40,0xC7);

/* Definition of interface: IMosProvider */
#undef INTERFACE
#define INTERFACE IMosProvider

DECLARE_INTERFACE_(IMosProvider, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IMosProvider methods */
    STDMETHOD_(SCODE, OpenNamespace)(THIS_ BSTR ObjectPath, BSTR User, BSTR Password, IMosProvider FAR* FAR* pNewContext) PURE;
    STDMETHOD_(SCODE, QueryNotificationHandler)(THIS_ IMosNotify FAR* FAR* pHandler) PURE;
    STDMETHOD_(SCODE, CreateClass)(THIS_ long lFlags, BSTR Parent, IMosClassObject FAR* FAR* pObj) PURE;
    STDMETHOD_(SCODE, DeleteClass)(THIS_ BSTR Class, long lFlags) PURE;
    STDMETHOD_(SCODE, CreateClassEnum)(THIS_ BSTR Parent, long lFlags, IEnumMosClassObject FAR* FAR* pEnum) PURE;
    STDMETHOD_(SCODE, CreateClassEnumAsync)(THIS_ BSTR RefClass, long lFlags, IMosNotify FAR* pHandler) PURE;
    STDMETHOD_(SCODE, UpdateClass)(THIS_ long lFlags, IMosClassObject FAR* pObj) PURE;
    STDMETHOD_(SCODE, GetClass)(THIS_ BSTR Class, long lFlags, IMosClassObject FAR* FAR* pObj) PURE;
    STDMETHOD_(SCODE, GetClassAsync)(THIS_ BSTR Class, long lFlags, IMosNotify FAR* pHandler) PURE;
    STDMETHOD_(SCODE, CreateInstance)(THIS_ BSTR Class, long lFlags, IMosClassObject FAR* FAR* pInst) PURE;
    STDMETHOD_(SCODE, UpdateInstance)(THIS_ long lFlags, IMosClassObject FAR* pInst) PURE;
    STDMETHOD_(SCODE, DeleteInstance)(THIS_ BSTR ObjectPath) PURE;
    STDMETHOD_(SCODE, CreateInstanceEnum)(THIS_ long lFlags, BSTR Class, IEnumMosClassObject FAR* FAR* pEnum) PURE;
    STDMETHOD_(SCODE, CreateInstanceEnumAsync)(THIS_ BSTR Class, long lFlags, IMosNotify FAR* pHandler) PURE;
    STDMETHOD_(SCODE, LockInstance)(THIS_ long lFlags, BSTR ObjectPath) PURE;
    STDMETHOD_(SCODE, UnlockInstance)(THIS_ BSTR ObjectPath) PURE;
    STDMETHOD_(SCODE, RefreshInstance)(THIS_ long lFlags, IMosClassObject FAR* pObj) PURE;
    STDMETHOD_(SCODE, RefreshInstanceAsync)(THIS_ long lFlags, IMosClassObject FAR* pObj, IMosNotify FAR* pHandler) PURE;
    STDMETHOD_(SCODE, GetObjectByPath)(THIS_ BSTR ObjectPath, IMosClassObject FAR* FAR* pObj) PURE;
    STDMETHOD_(SCODE, GetObjectByPathAsync)(THIS_ BSTR ObjectPath, IMosNotify FAR* pHandler) PURE;
    STDMETHOD_(SCODE, ExecQuery)(THIS_ BSTR QueryFormat, BSTR Query, IEnumMosClassObject FAR* FAR* pEnum) PURE;
    STDMETHOD_(SCODE, ExecQueryAsync)(THIS_ BSTR QueryFormat, BSTR Query, IMosNotify FAR* pHandler) PURE;
    STDMETHOD_(SCODE, ExecQueryIndirect)(THIS_ BSTR QueryObjectPath, IEnumMosClassObject FAR* FAR* pEnum) PURE;
    STDMETHOD_(SCODE, ExecQueryIndirectAsync)(THIS_ BSTR QueryObjectPath, IMosNotify FAR* pHandler) PURE;
    STDMETHOD_(SCODE, ExecMethod)(THIS_ BSTR Object, BSTR MethodEncodingFormat, void FAR* InboundEncoding, void FAR* FAR* OutboundEncoding) PURE;
    STDMETHOD_(SCODE, GetErrorInformation)(THIS_ long LocaleId, BSTR FAR* pErrorInfo) PURE;
};

DEFINE_GUID(IID_IMosLocator,0xDC12A687L,0x737F,0x11CF,0x88,0x4D,0x00,0xAA,0x00,0x4B,0x2E,0x24);

/* Definition of interface: IMosLocator */
#undef INTERFACE
#define INTERFACE IMosLocator

DECLARE_INTERFACE_(IMosLocator, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IMosLocator methods */
    STDMETHOD_(SCODE, ConnectServer)(THIS_ BSTR ObjectPath, BSTR User, BSTR Password, long lFlags, IMosProvider FAR* FAR* pNamespace) PURE;
};

DEFINE_GUID(CLSID_MosLocator,0xD85ADEF1L,0xDD7F,0x11CE,0xA3,0x57,0x00,0x00,0x00,0x00,0x00,0x01);

#ifdef __cplusplus
class MosLocator;
#endif

DEFINE_GUID(CLSID_MosClassObject,0xD85ADEF2L,0xDD7F,0x11CE,0xA3,0x57,0x00,0x00,0x00,0x00,0x00,0x01);

#ifdef __cplusplus
class MosClassObject;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\olemsclient.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  OLEMSClient.cpp
//
//  Module: Navigator.OCX
//
//
//  Larry French
//		10-January-1997
//			Modified "GetSortedPropNames" to account for the fact that
//			now system properties don't have any qualifiers and HMOM
//			returns a failure code when there is an attempt to get
//			the qualifiers of a system property.
//
//		29-June-1997
//			Changed the interface of ErrorMsg to use IWbemCallResult as a
//			parameter instead of IWbemClassObject
//
//		29-June-1997
//			Upated to the new interface for version 140 of HMOM.
//
//***************************************************************************
#include "precomp.h"
#include <OBJIDL.H>
#include "resource.h"
#include <nddeapi.h>
#include <initguid.h>
#include "wbemidl.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include "MsgDlgExterns.h"
#include "logindlg.h"

#define TIMEOUT_MILLISECONDS 5000

#include "OLEMSClient.h"

#define BUFF_SIZE 256


SCODE MakeSafeArray(SAFEARRAY FAR ** pRet, VARTYPE vt, int iLen)
{
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iLen;
    *pRet = SafeArrayCreate(vt,1, rgsabound);
    return (*pRet == NULL) ? 0x80000001 : S_OK;
}

SCODE PutStringInSafeArray
(SAFEARRAY FAR * psa,CString *pcs, int iIndex)
{
    long ix[2];
    ix[1] = 0;
    ix[0] = iIndex;
    HRESULT hResult = SafeArrayPutElement(psa,ix,pcs -> AllocSysString());
	return GetScode(hResult);
}

//***************************************************************************
//
// GetBSTRAttrib
//
// Purpose: Get the value of a class or property BSTR Qualifier
//
//***************************************************************************
CString GetBSTRAttrib
(IWbemClassObject * pClassInt,CString *pcsPropName, CString *pcsAttribName)
{
    SCODE sc;
	CString csReturn;
    IWbemQualifierSet * pAttribSet = NULL;
    if(pcsPropName != NULL)   // Property Qualifier
	{
		BSTR bstrTemp = pcsPropName -> AllocSysString();
        sc = pClassInt->GetPropertyQualifierSet(bstrTemp,
					&pAttribSet);
		::SysFreeString(bstrTemp);
	}
    else	// A class Qualifier
        sc = pClassInt->GetQualifierSet(&pAttribSet);
    if (sc != S_OK)
	{
		return csReturn;

	}


	VARIANTARG var;
	VariantInit(&var);


	long lFlavor;
	BSTR bstrTemp = pcsAttribName -> AllocSysString();
    sc = pAttribSet->Get(bstrTemp, 0,
		&var, &lFlavor );
	::SysFreeString(bstrTemp);

	if (sc == S_OK)
		csReturn = var.bstrVal;
	else
		csReturn = _T("");

    pAttribSet->Release();
    VariantClear(&var);
    return csReturn;
}

//***************************************************************************
//
// GetPropNames
//
// Purpose: Gets the Prop names for an object.
//
//***************************************************************************

int GetPropNames(IWbemClassObject * pClass, CStringArray *&pcsaReturn)
{
	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;

	VARIANTARG var;
	VariantInit(&var);
	CString csNull;


    sc = pClass->GetNames(NULL,0,NULL, &psa );

    if(sc == S_OK)
	{
       int iDim = SafeArrayGetDim(psa);
	   int i;
       sc = SafeArrayGetLBound(psa,1,&lLower);
       sc = SafeArrayGetUBound(psa,1,&lUpper);
	   pcsaReturn = new CStringArray;
	   CString csTmp;
       for(ix[0] = lLower, i = 0; ix[0] <= lUpper; ix[0]++, i++)
	   {
           BSTR PropName;
           sc = SafeArrayGetElement(psa,ix,&PropName);
		   csTmp = PropName;
           pcsaReturn -> Add(csTmp);
           SysFreeString(PropName);
	   }
	}

	SafeArrayDestroy(psa);

	return (lUpper - lLower) + 1;
}

int GetSortedPropNames
(IWbemClassObject *pClass, CStringArray &rcsaReturn, CMapStringToPtr &rcmstpPropFlavors)
{
	CStringArray csaRegularProps;
	CStringArray csaKeyProps;
	CString csLabelProp;

	rcsaReturn.RemoveAll();
	rcmstpPropFlavors.RemoveAll();

	SCODE sc;
	long ix[2] = {0,0};
	long lLower, lUpper;
	SAFEARRAY * psa = NULL;
	int nProps;
	CStringArray *pcsProps;
	nProps = GetPropNames(pClass, pcsProps);
	int i;
	IWbemQualifierSet * pAttrib = NULL;
	CString csTmp;
	CString csLabelAttrib = _T("Label");
	CString csKeyAttrib = _T("Key");
	CString csClassProp = _T("__CLASS");


	for (i = 0; i < nProps; i++)
	{
		BSTR bstrTemp = pcsProps -> GetAt(i).AllocSysString();
		sc = pClass -> GetPropertyQualifierSet(bstrTemp,
						&pAttrib);

		if (FAILED(sc)) {
			// System properties don't have qualifier sets.  Lev promised that
			// the only way for GetPropertyQualifierSet to fail is if the property
			// doesn't have any qualifiers.


			if (pcsProps -> GetAt(i).CompareNoCase(csClassProp) != 0)
			{
				csaRegularProps.Add(pcsProps -> GetAt(i));

			}
		}
		else {

			sc = pAttrib->GetNames(0,&psa);
			BOOL bExclude = FALSE;
			 if(sc == S_OK)
			{
				int iDim = SafeArrayGetDim(psa);
				sc = SafeArrayGetLBound(psa,1,&lLower);
				sc = SafeArrayGetUBound(psa,1,&lUpper);
				BSTR AttrName;
				for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
				{
					sc = SafeArrayGetElement(psa,ix,&AttrName);
					csTmp = AttrName;
					if (csTmp.CompareNoCase(csLabelAttrib)  == 0)
					{
						bExclude = TRUE;
						csLabelProp = pcsProps -> GetAt(i);
					}
					else if (csTmp.CompareNoCase(csKeyAttrib)  == 0)
					{
						bExclude = TRUE;
						csaKeyProps.Add(pcsProps -> GetAt(i));
					}
					SysFreeString(AttrName);

				}
			 }
			 if (bExclude == FALSE)
			 {
				if (pcsProps -> GetAt(i).CompareNoCase(csClassProp) != 0)
				{
					csaRegularProps.Add(pcsProps -> GetAt(i));

				}
			 }

			 pAttrib -> Release();
		}
		long lFlavor = 0;
		sc = pClass -> Get(bstrTemp,0,NULL,NULL,&lFlavor);
#ifdef _DEBUG
//		ASSERT(sc == S_OK);
//		afxDump << "Adding " << pcsProps -> GetAt(i) << " with flavor = " << lFlavor << "\n";
#endif
		lFlavor &= WBEM_FLAVOR_MASK_ORIGIN;
		rcmstpPropFlavors.SetAt((LPCTSTR)pcsProps -> GetAt(i),(void *) lFlavor);

		::SysFreeString(bstrTemp);
	}


	SafeArrayDestroy(psa);
	delete pcsProps;

	rcsaReturn.RemoveAll();

	if (!csLabelProp.IsEmpty())
	{
		rcsaReturn.Add(csLabelProp);
		rcsaReturn.Add(csClassProp);
		for(i = 0; i < csaKeyProps.GetSize();i++)
		{
			if (csLabelProp.CompareNoCase(csaKeyProps.GetAt(i)) != 0)
			{
				rcsaReturn.Add(csaKeyProps.GetAt(i));
			}
		}
	}
	else
	{
		rcsaReturn.CStringArray::Append(csaKeyProps);
		rcsaReturn.Add(csClassProp);
	}

	rcsaReturn.CStringArray::Append(csaRegularProps);

#ifdef _DEBUG
	{
		int nPropsTemp = rcsaReturn.GetSize();
		int nFlavorsTemp = rcmstpPropFlavors.GetCount();
		ASSERT (nPropsTemp == nFlavorsTemp);
		int i;
		long *plFlavor;
		for (i = 0; i < nPropsTemp; i++)
		{
			BOOL bReturn = rcmstpPropFlavors.Lookup((LPCTSTR) rcsaReturn.GetAt(i),(void *&) plFlavor);
			if (bReturn)
			{
				afxDump << "Found " << rcsaReturn.GetAt(i) << " with flavor = " << (long) plFlavor << "\n";
			}
		}
	}
#endif

	return (int)rcsaReturn.GetSize();
}


CString GetProperty
(IWbemServices * , IWbemClassObject * pInst,
 CString *pcsProperty)

{
	ASSERT(pInst != NULL);
	if (pInst == NULL) {
		return _T("");
	}

	SCODE sc;

    VARIANTARG var;
	VariantInit(&var);

	BSTR bstrTemp = pcsProperty->AllocSysString();
    sc = pInst->Get( bstrTemp ,0,&var,NULL,NULL);
	::SysFreeString(bstrTemp);

	VARIANTARG varChanged;
	VariantInit(&varChanged);


	HRESULT hr;

	if (sc == S_OK && var.vt != VT_NULL)
	{
		if (var.vt == VT_BOOL)
		{
			varChanged.vt = VT_BSTR;
			CString csBool;
			if (var.boolVal)
			{
				csBool = _T("true");
			}
			else
			{
				csBool = _T("false");
			}
			varChanged.bstrVal = csBool.AllocSysString();
			hr = S_OK;
		}
		else
		{
			hr = VariantChangeType(&varChanged, &var, 0, VT_BSTR);
		}
	}
	else
	{
		if (var.vt == VT_NULL)
		{
			VariantClear(&var);
		}
		return _T("");

	}

	CString csOut;

	if (hr == S_OK && varChanged.vt == VT_BSTR)
	{
		csOut = varChanged.bstrVal;
		VariantClear(&varChanged);
	}
	else
	{
		csOut = _T("");
	}

	VariantClear(&var);

	return csOut;
}

BOOL GetPropertyAsVariant
(IWbemClassObject * pInst, CString *pcsProperty, VARIANT&  varOut, CIMTYPE& cimtypeOut )

{
	SCODE sc;

	VariantInit(&varOut);
	cimtypeOut = CIM_EMPTY;

	BSTR bstrTemp = pcsProperty -> AllocSysString ( );
    sc = pInst->Get(bstrTemp  ,0,&varOut, &cimtypeOut,NULL);
	::SysFreeString(bstrTemp);

	return TRUE;
}

//***************************************************************************
//
// GetIWbemClass
//
// Purpose: Returns the class of the object.
//
//***************************************************************************
CString GetIWbemClass(IWbemServices *pProv, IWbemClassObject *pClass)
{

	CString csProp = _T("__Class");
	return ::GetProperty(pProv,pClass,&csProp);


}

//***************************************************************************
//
// GetIWbemClass
//
// Purpose: Returns the class of the object by path.
//
//***************************************************************************
CString GetIWbemClass(IWbemServices *pProv, CString *pcsPath)
{

	IWbemClassObject *pimcoObject = NULL;

	BSTR bstrTemp = pcsPath -> AllocSysString();
#ifdef _DEBUG
//	afxDump << "GetObject in GetIWbemClass for " << *pcsPath << "\n";
#endif
	SCODE sc =
		pProv ->
		GetObject(bstrTemp,0, NULL, &pimcoObject,NULL);
	::SysFreeString(bstrTemp);
	if (sc == S_OK)
	{
		CString csProp = _T("__Class");
		CString csClass = ::GetProperty(pProv,pimcoObject,&csProp);
		pimcoObject -> Release();
		return csClass;
	}
	else
	{
		return _T("");
	}


}
//***************************************************************************
//
// GetIWbemClassPath
//
// Purpose: Returns the path of the class of the object.
//
//***************************************************************************
CString GetIWbemClassPath(IWbemServices *pProv, CString *pcsPath)
{

	IWbemClassObject *pimcoObject = NULL;
	BSTR bstrTemp = pcsPath -> AllocSysString();
#ifdef _DEBUG
//	afxDump << "GetObject in GetIWbemClassPath for " << *pcsPath << "\n";
#endif
	SCODE sc =
		pProv ->
		GetObject(bstrTemp,0, NULL, &pimcoObject,NULL);
	::SysFreeString(bstrTemp);
	if (sc == S_OK)
	{
		CString csProp = _T("__Class");
		CString csClass = ::GetProperty(pProv,pimcoObject,&csProp);
		pimcoObject -> Release();
		if (csClass.GetLength() > 0)
		{
			BSTR bstrTemp = csClass.AllocSysString();
#ifdef _DEBUG
//	afxDump << "GetObject in GetIWbemClassPath for " << csClass << "\n";
#endif
			SCODE sc =
				pProv ->
				GetObject(bstrTemp,0, NULL, &pimcoObject,NULL);
			::SysFreeString(bstrTemp);
			if (sc == S_OK)
			{
				csProp = _T("__Path");
				CString csPath = ::GetProperty(pProv,pimcoObject,&csProp);
				pimcoObject -> Release();
				return csPath;
			}


		}
		return csProp;
	}
	else
	{
		return _T("");
	}


}



//***************************************************************************
//
// GetIWbemRelPath
//
// Purpose: Returns the relative path of the object.
//
//***************************************************************************
CString GetIWbemRelPath(IWbemServices *pProv, IWbemClassObject *pClass)
{

	CString csProp = _T("__RelPath");
	return ::GetProperty(pProv,pClass,&csProp);


}

//***************************************************************************
//
// GetIWbemFullPath
//
// Purpose: Returns the complete path of the object.
//
//***************************************************************************
CString GetIWbemFullPath(IWbemServices *pProv, IWbemClassObject *pClass)
{

	CString csProp = _T("__Path");
	return ::GetProperty(pProv,pClass,&csProp);


}

//***************************************************************************
//
// GetIWbemSuperClass
//
// Purpose: Returns the Super class of the object.
//
//***************************************************************************
CString GetIWbemSuperClass(IWbemServices *pProv, IWbemClassObject *pClass)
{

	CString csProp = _T("__SuperClass");
	return ::GetProperty(pProv,pClass,&csProp);


}

//***************************************************************************
//
// GetIWbemSuperClass
//
// Purpose: Returns the Super class of the object.
//
//***************************************************************************
CString GetIWbemSuperClass
(IWbemServices *pProv, CString *pcsClassOrPath, BOOL bClass)
{
	if (pcsClassOrPath -> GetLength() == 0)
	{
		return *pcsClassOrPath;
	}

	IWbemClassObject *pimcoClass = NULL;

	SCODE sc;

	BSTR bstrTemp = pcsClassOrPath -> AllocSysString();
#ifdef _DEBUG
//	afxDump << "GetObject in GetIWbemSuperClass for " << *pcsClassOrPath << "\n";
#endif
	sc = pProv ->
			GetObject(bstrTemp,0, NULL, &pimcoClass,NULL);
	::SysFreeString(bstrTemp);

	if (sc == S_OK)
	{
			CString csProp = _T("__SuperClass");
			CString csClass = ::GetProperty(pProv,pimcoClass,&csProp);
			pimcoClass -> Release();
			return csClass;
	}
	else
	{
		return _T("");
	}


}


//***************************************************************************
//
// GetClassObject
//
// Purpose: Get the class object for an instance.
//
//***************************************************************************
IWbemClassObject *GetClassObject
(IWbemServices *pProv, IWbemClassObject *pimcoInstance)
{

	IWbemClassObject *pimcoClass = NULL;
	CString csClass = GetIWbemClass(pProv, pimcoInstance);

	BSTR bstrTemp = csClass.AllocSysString();
#ifdef _DEBUG
//	afxDump << "GetObject in GetClassObject for " << csClass << "\n";
#endif
	SCODE sc = pProv ->
		GetObject(bstrTemp,0, NULL, &pimcoClass,NULL);
	::SysFreeString(bstrTemp);

	if (sc == S_OK)
	{
		return pimcoClass;
	}
	else
	{
		return NULL;
	}


}

BOOL ObjectInDifferentNamespace
(IWbemServices *pProv, CString *pcsNamespace, IWbemClassObject *pObject)
{

	BOOL bHasServer = FALSE;
	TCHAR c1 = (*pcsNamespace)[0];
	TCHAR c2 = (*pcsNamespace)[1];

	if (c1 == '\\' && c2 == '\\')
	{
		bHasServer = TRUE;
	}

	CString csNamespace;

	CString csPath = GetIWbemFullPath(pProv,pObject);
	CObjectPathParser parser;
	ParsedObjectPath* pParsedPath = NULL;

	BSTR bstrTemp = csPath.AllocSysString();
	int nStatus  = parser.Parse(bstrTemp,  &pParsedPath);
	::SysFreeString(bstrTemp);

	if (nStatus == 0)
	{
		if (pParsedPath->m_dwNumNamespaces > 0)
		{
			if(pParsedPath->m_pServer && bHasServer)
			{
				csNamespace = _T("\\\\");
				csNamespace += pParsedPath->m_pServer;
				csNamespace += _T("\\");
			}
			for (unsigned int i = 0; i < pParsedPath->m_dwNumNamespaces; i++)
			{
				csNamespace += pParsedPath->m_paNamespaces[i];
				if (i < pParsedPath->m_dwNumNamespaces - 1)
				{
					csNamespace += _T("\\");
				}
			}
		}
	}

	if (pParsedPath)
	{
		parser.Free(pParsedPath);
	}

	return csNamespace.CompareNoCase(*pcsNamespace) != 0;


}


CString GetObjectNamespace
(IWbemServices *pProv, IWbemClassObject *pObject)
{

	CString csNamespace;

	CString csPath = GetIWbemFullPath(pProv,pObject);
	CObjectPathParser parser;
	ParsedObjectPath* pParsedPath = NULL;

	BSTR bstrTemp = csPath.AllocSysString();
	int nStatus  = parser.Parse(bstrTemp,  &pParsedPath);
	::SysFreeString(bstrTemp);

	if (nStatus == 0)
	{
		if (pParsedPath->m_dwNumNamespaces > 0)
		{
			if(pParsedPath->m_pServer)
			{
				csNamespace = _T("\\\\");
				csNamespace += pParsedPath->m_pServer;
				csNamespace += _T("\\");
			}
			for (unsigned int i = 0; i < pParsedPath->m_dwNumNamespaces; i++)
			{
				csNamespace += pParsedPath->m_paNamespaces[i];
				if (i < pParsedPath->m_dwNumNamespaces - 1)
				{
					csNamespace += _T("\\");
				}
			}
		}
	}

	if (pParsedPath)
	{
		parser.Free(pParsedPath);
	}

	return csNamespace;

}

CString GetPathNamespace(CString &csPath)
{

	CString csNamespace;

	CObjectPathParser parser;
	ParsedObjectPath* pParsedPath = NULL;

	BSTR bstrTemp = csPath.AllocSysString();
	int nStatus  = parser.Parse(bstrTemp,  &pParsedPath);
	::SysFreeString(bstrTemp);

	if (nStatus == 0)
	{
		if (pParsedPath->m_dwNumNamespaces > 0)
		{
			if(pParsedPath->m_pServer)
			{
				csNamespace = _T("\\\\");
				csNamespace += pParsedPath->m_pServer;
				csNamespace += _T("\\");
			}
			for (unsigned int i = 0; i < pParsedPath->m_dwNumNamespaces; i++)
			{
				csNamespace += pParsedPath->m_paNamespaces[i];
				if (i < pParsedPath->m_dwNumNamespaces - 1)
				{
					csNamespace += _T("\\");
				}
			}
		}
	}

	if (pParsedPath)
	{
		parser.Free(pParsedPath);
	}

	return csNamespace;

}

CString GetClassFromPath(CString &csPath)
{

	CString csNamespace;

	CObjectPathParser parser;
	ParsedObjectPath* pParsedPath = NULL;

	BSTR bstrTemp = csPath.AllocSysString();
	int nStatus  = parser.Parse(bstrTemp,  &pParsedPath);
	::SysFreeString(bstrTemp);

	CString csClassPath;

	if (nStatus == 0 && pParsedPath != NULL)
	{
		if (pParsedPath->m_dwNumNamespaces > 0)
		{
			if(pParsedPath->m_pServer)
			{
				csNamespace = _T("\\\\");
				csNamespace += pParsedPath->m_pServer;
				csNamespace += _T("\\");
			}
			for (unsigned int i = 0; i < pParsedPath->m_dwNumNamespaces; i++)
			{
				csNamespace += pParsedPath->m_paNamespaces[i];
				if (i < pParsedPath->m_dwNumNamespaces - 1)
				{
					csNamespace += _T("\\");
				}
			}
		}
		csClassPath = csNamespace + ':' + pParsedPath->m_pClass;
	}


	if (pParsedPath)
	{
		parser.Free(pParsedPath);
	}

	return csClassPath;

}

CString GetClassNameFromPath(CString &csPath)
{

	CString csNamespace;

	CObjectPathParser parser;
	ParsedObjectPath* pParsedPath = NULL;

	BSTR bstrTemp = csPath.AllocSysString();
	int nStatus  = parser.Parse(bstrTemp,  &pParsedPath);
	::SysFreeString(bstrTemp);

	CString csClass = (nStatus == 0) ? pParsedPath->m_pClass : _T("");

	if (pParsedPath)
	{
		parser.Free(pParsedPath);
	}

	return csClass;

}


IEnumWbemClassObject *ExecQuery(IWbemServices * pProv, CString &csQueryType, CString &csQuery,
								CString &rcsNamespace)
{
	IEnumWbemClassObject *pemcoResult = NULL;
	IWbemClassObject *pErrorObject = NULL;

	BSTR bstrTemp1 = csQueryType.AllocSysString();
	BSTR bstrTemp2 = csQuery.AllocSysString();
	SCODE sc = pProv -> ExecQuery(bstrTemp1,bstrTemp2,0,NULL,&pemcoResult);
	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);

	if (sc == S_OK)
	{
		SetEnumInterfaceSecurity(rcsNamespace,pemcoResult, pProv);
		return pemcoResult;
	}
	else
	{
		CString csUserMsg;
		CString csErrorAsHex;
		csErrorAsHex.Format(_T("0x%x"),sc);
		csUserMsg =  _T("ExecQuery failure: ");
		csUserMsg += csErrorAsHex;
		csUserMsg +=  _T(" for query: ");
		csUserMsg += csQuery;

		ErrorMsg
				(&csUserMsg, sc, TRUE, FALSE, &csUserMsg, __FILE__,
				__LINE__ - 28);
		return NULL;

	}

}

CStringArray *ClassDerivation (IWbemServices *pServices, CString &rcsPath)
{
	IWbemClassObject *pObject = NULL;

	BSTR bstrTemp = rcsPath.AllocSysString();

	SCODE sc =
		pServices ->
		GetObject(bstrTemp,0, NULL, &pObject,NULL);

	::SysFreeString(bstrTemp);

	if (!SUCCEEDED(sc))
	{
		return NULL;
	}

	CStringArray *pcsaDerivation = ClassDerivation(pObject);

	pObject ->Release();

	return pcsaDerivation;

}

CStringArray *ClassDerivation (IWbemClassObject *pObject)
{
	SCODE sc;

    VARIANTARG var;
	VariantInit(&var);
	long lType;
	long lFlavor;


	CString csProp = _T("__derivation");

	BSTR bstrTemp = csProp.AllocSysString ( );
    sc = pObject->Get(bstrTemp ,0,&var,&lType,&lFlavor);
	::SysFreeString(bstrTemp);

	if (sc != S_OK || var.vt == VT_NULL)
	{
	   return NULL;
	}

	long ix[2] = {0,0};
	long lLower, lUpper;

	int iDim = SafeArrayGetDim(var.parray);
	sc = SafeArrayGetLBound(var.parray,1,&lLower);
	sc = SafeArrayGetUBound(var.parray,1,&lUpper);
	BSTR bstrClass;
	CStringArray *pcsaReturn = new CStringArray;
	for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
	{
		sc = SafeArrayGetElement(var.parray,ix,&bstrClass);
		CString csTmp = bstrClass;
		pcsaReturn->Add(csTmp);
		SysFreeString(bstrClass);

	}

	VariantClear(&var);
	return pcsaReturn;

}

BOOL ObjectIsDynamic(SCODE& sc, IWbemClassObject* pco)
{
	BOOL bIsDynamic = FALSE;

	IWbemQualifierSet* pqs = NULL;
	sc = pco->GetQualifierSet(&pqs); // Get instance attribute
	if (SUCCEEDED(sc)) {
		LONG lFlavor;
		COleVariant varValue;
		sc = pqs->Get(L"dynamic", 0, &varValue, &lFlavor);
		if (SUCCEEDED(sc)) {
			ASSERT(varValue.vt == VT_BOOL);
			if (varValue.vt == VT_BOOL) {
				bIsDynamic = varValue.boolVal;
			}
		}
		sc = S_OK;
		pqs->Release();
	}
	return bIsDynamic;
}

CString GetSDKDirectory()
{
	CString csHmomWorkingDir;
	HKEY hkeyLocalMachine;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hkeyLocalMachine);
	if (lResult != ERROR_SUCCESS) {
		return "";
	}




	HKEY hkeyHmomCwd;

	lResult = RegOpenKeyEx(
				hkeyLocalMachine,
				_T("SOFTWARE\\Microsoft\\Wbem"),
				0,
				KEY_READ | KEY_QUERY_VALUE,
				&hkeyHmomCwd);

	if (lResult != ERROR_SUCCESS) {
		RegCloseKey(hkeyLocalMachine);
		return "";
	}





	unsigned long lcbValue = 1024;
	LPTSTR pszWorkingDir = csHmomWorkingDir.GetBuffer(lcbValue);


	unsigned long lType;
	lResult = RegQueryValueEx(
				hkeyHmomCwd,
				_T("SDK Directory"),
				NULL,
				&lType,
				(unsigned char*) (void*) pszWorkingDir,
				&lcbValue);


	csHmomWorkingDir.ReleaseBuffer();
	RegCloseKey(hkeyHmomCwd);
	RegCloseKey(hkeyLocalMachine);

	if (lResult != ERROR_SUCCESS)
	{
		csHmomWorkingDir.Empty();
	}

	return csHmomWorkingDir;
}



void ErrorMsg
(CString *pcsUserMsg, SCODE sc, BOOL bUseErrorObject, BOOL bLog, CString *pcsLogMsg,
 char *szFile, int nLine, UINT uType)
{
	CString csCaption = _T("Multiview Message");
	BOOL bErrorObject = sc != S_OK;
	BSTR bstrTemp1 = csCaption.AllocSysString();
	BSTR bstrTemp2 = pcsUserMsg->AllocSysString();
	DisplayUserMessage
		(bstrTemp1,bstrTemp2,
		sc, bUseErrorObject,uType);
	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);

	if (bLog)
	{
		LogMsg(pcsLogMsg,  szFile, nLine);

	}

}

void LogMsg
(CString *pcsLogMsg, char *szFile, int nLine)
{


}


void MoveWindowToLowerLeftOfOwner(CWnd *pWnd)
{
	CWnd *pOwner = pWnd->GetOwner();
	RECT rectOwner;
	pOwner->GetClientRect(&rectOwner);

	pOwner->ClientToScreen(&rectOwner);

	RECT rect;
	pWnd->GetClientRect(&rect);

	pWnd->ClientToScreen(&rect);

	RECT rectMove;
	rectMove.left = rectOwner.left;
	rectMove.bottom = rectOwner.bottom;
	rectMove.right = rectOwner.left + (rect.right - rect.left);
	rectMove.top = rectOwner.top + (rectOwner.bottom - rect.bottom);
	pWnd->MoveWindow(&rectMove,TRUE);
}

//this method intersects 2 string arrays and stores the result in the first one
void IntersectInPlace (CStringArray& dest, CStringArray& ar) {

	if (dest.GetSize() == 0 || ar.GetSize() == 0) {
		dest.RemoveAll();
		return;
	}

	CStringArray csAux;

	for (int i = 0; i < dest.GetSize(); i++) {
		for (int k = 0; k < ar.GetSize(); k++) {
			if (dest[i].CompareNoCase(ar[k]) == 0) {
				csAux.Add (dest[i]);
			}
		}
	}

	dest.RemoveAll();
	dest.Copy(csAux);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MultiView.rc
//
#define IDS_MULTIVIEW                   1
#define IDD_ABOUTBOX_MULTIVIEW          1
#define IDB_MULTIVIEW                   1
#define IDI_ABOUTDLL                    1
#define IDS_MULTIVIEW_PPG               2
#define IDS_MULTIVIEW_PPG_CAPTION       100
#define IDD_PROPPAGE_MULTIVIEW          100
#define CG_IDD_PROGRESS                 102
#define CG_IDS_PROGRESS_CAPTION         103
#define CG_IDR_POPUP_MULTI_VIEW_CTRL    104
#define IDC_BUTTON1                     201
#define IDD_DIALOGASYNCENUM             202
#define IDC_STATICMESSAGE               202
#define IDI_ICONINFORM                  203
#define IDD_DIALOGASYNCQUERY            203
#define IDC_STATICMESSAGE1              203
#define IDD_DIALOGSYNCENUM              204
#define IDI_ICONASSOCROLE               204
#define IDI_ICONOJBG                    205
#define IDI_ICONPLACEH                  206
#define CG_IDC_PROGDLG_PROGRESS         1003
#define CG_IDC_PROGDLG_STATUS           1005
#define ID_MENUITEMGOTOSINGLE           32768

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        207
#define _APS_NEXT_COMMAND_VALUE         32769
#define _APS_NEXT_CONTROL_VALUE         204
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\syncenumdlg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// SyncEnumDlg.cpp : implementation file
//

#include "precomp.h"
#include <wbemidl.h>
#include "grid.h"
#include "MultiView.h"
#include "MultiViewCtl.h"
#include "SyncEnumDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSyncEnumDlg dialog


CSyncEnumDlg::CSyncEnumDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSyncEnumDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSyncEnumDlg)
	//}}AFX_DATA_INIT
}


void CSyncEnumDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSyncEnumDlg)
	DDX_Control(pDX, IDC_STATICMESSAGE, m_cstaticMessage);
	DDX_Control(pDX, IDCANCEL, m_cbCancel);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSyncEnumDlg, CDialog)
	//{{AFX_MSG_MAP(CSyncEnumDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSyncEnumDlg message handlers

void CSyncEnumDlg::OnCancel()
{
	// TODO: Add extra cleanup here

	CDialog::OnCancel();
}

BOOL CSyncEnumDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	m_cbCancel.EnableWindow(FALSE);

	CString csMessage =
		_T("Retrieving instances for class ") + m_csClass + _T(".");

	csMessage +=
		_T("  You cannot cancel the operation.");

	m_cstaticMessage.SetWindowText(csMessage);
	// TODO: Add extra initialization here

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CSyncEnumDlg::PreTranslateMessage(MSG* pMsg)
{
	// TODO: Add your specialized code here and/or call the base class
	if (pMsg->message == ID_SYNC_ENUM_DONE)
	{
		EndDialog(IDOK);
		return TRUE;
	}



	return CDialog::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\browsetbc.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// BrowseTBC.cpp : implementation file
//

#include "precomp.h"
#include <shlobj.h>
#include <afxcmn.h>
#include "wbemidl.h"
#include "resource.h"
#include "NSEntry.h"
#include "BrowseTBC.h"
#include "ToolCWnd.h"
#include "NameSpaceTree.h"
#include "MachineEditInput.h"
#include "BrowseDialogPopup.h"
#include "NSEntryCtl.h"
#include "EditInput.h"
#include "NameSpace.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBrowseTBC

CBrowseTBC::CBrowseTBC()
{
}

CBrowseTBC::~CBrowseTBC()
{
}


BEGIN_MESSAGE_MAP(CBrowseTBC, CToolBarCtrl)
	//{{AFX_MSG_MAP(CBrowseTBC)
	ON_WM_LBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBrowseTBC message handlers


void CBrowseTBC::OnLButtonUp(UINT nFlags, CPoint point)
{
	CToolBarCtrl::OnLButtonUp(nFlags, point);

	CString csMachineName = m_pParent->GetServerName();
	m_pParent->m_cbdpBrowse.SetMachineName(&csMachineName);

	CString csNameSpace = m_pParent->GetNameSpace();
	if((csNameSpace.GetLength() > csMachineName.GetLength()) && (0 == csMachineName.CompareNoCase(csNameSpace.Left(csMachineName.GetLength()))))
		csNameSpace = csNameSpace.Right(csNameSpace.GetLength() - csMachineName.GetLength() - 1);
	else
	{
		if(!csNameSpace.GetLength())
			csNameSpace = _T("root");
	}
	m_pParent->m_cbdpBrowse.SetNameSpace(&csNameSpace);

	m_pParent->PreModalDialog();

	m_pParent->m_cbdpBrowse.DoModal();

	m_pParent->PostModalDialog();

	m_pParent->FireNameSpaceEntryRedrawn();
	m_pParent->InvalidateControl();

	m_pParent->SetFocusToEdit();

}

CSize CBrowseTBC::GetToolBarSize()
{
	CRect rcButtons;
	//CToolBarCtrl &rToolBarCtrl = *this;
	int nButtons = GetButtonCount();
	if (nButtons > 0) {
		CRect rcLastButton;
		GetItemRect(0, &rcButtons);
		GetItemRect(nButtons-1, &rcLastButton);
		rcButtons.UnionRect(&rcButtons, &rcLastButton);
	}
	else {
		rcButtons.SetRectEmpty();
	}

	CSize size;
	size.cx = rcButtons.Width();
	size.cy = rcButtons.Height();
	return size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\multiview\syncenumdlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SYNCENUMDLG_H__BDA76D81_F954_11D0_9648_00C04FD9B15B__INCLUDED_)
#define AFX_SYNCENUMDLG_H__BDA76D81_F954_11D0_9648_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SyncEnumDlg.h : header file
//

class CMultiViewCtrl;
/////////////////////////////////////////////////////////////////////////////
// CSyncEnumDlg dialog

class CSyncEnumDlg : public CDialog
{
// Construction
public:
	CSyncEnumDlg(CWnd* pParent = NULL);   // standard constructor
	void SetLocalParent(CMultiViewCtrl * pParent)
	{m_pParent = pParent;}
	void SetClass(CString *pcsClass)
	{m_csClass = *pcsClass;}
// Dialog Data
	//{{AFX_DATA(CSyncEnumDlg)
	enum { IDD = IDD_DIALOGSYNCENUM };
	CStatic	m_cstaticMessage;
	CButton	m_cbCancel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSyncEnumDlg)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CMultiViewCtrl *m_pParent;
	CString m_csClass;

	// Generated message map functions
	//{{AFX_MSG(CSyncEnumDlg)
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SYNCENUMDLG_H__BDA76D81_F954_11D0_9648_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\browsedialogpopup.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// BrowseDialogPopup.cpp : implementation file
//

#include "precomp.h"
#include <shlobj.h>
#include <afxcmn.h>
#include "wbemidl.h"
#include "resource.h"
#include "NameSpaceTree.h"
#include "MachineEditInput.h"
#include "BrowseDialogPopup.h"
#include "NSEntry.h"
#include "NSEntryCtl.h"
#include "NSEntryPpg.h"
#include "namespace.h"
#include "ToolCWnd.h"
#include "BrowseTBC.h"
#include "logindlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif




/////////////////////////////////////////////////////////////////////////////
// CBrowseDialogPopup dialog


CBrowseDialogPopup::CBrowseDialogPopup(CNSEntryCtrl* pParent /*=NULL*/)
	:	CDialog(CBrowseDialogPopup::IDD, pParent),
		m_pParent (pParent)
{
	//{{AFX_DATA_INIT(CBrowseDialogPopup)
	m_szNameSpace = _T("root");
	m_bUseExisting = TRUE;
	//}}AFX_DATA_INIT
	m_bInitialized = FALSE;
}

CBrowseDialogPopup::~CBrowseDialogPopup()
{
	m_csaNamespaceConnectionsFromDailog.RemoveAll();
}

void CBrowseDialogPopup::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBrowseDialogPopup)
	DDX_Control(pDX, IDC_BUTTON1, m_NetWork);
	DDX_Control(pDX, IDC_BUTTONCONNECT, m_cbConnect);
	DDX_Control(pDX, IDC_EDIT1, m_cmeiMachine);
	DDX_Control(pDX, IDC_TREE1, m_cnstTree);
	DDX_Text(pDX, IDC_EDIT2, m_szNameSpace);
	DDX_Check(pDX, IDC_USEEXISTING, m_bUseExisting);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBrowseDialogPopup, CDialog)
	//{{AFX_MSG_MAP(CBrowseDialogPopup)
	ON_WM_CREATE()
	ON_BN_CLICKED(IDC_BUTTON1, OnButton1)
	ON_BN_CLICKED(IDOKREALLY, OnOkreally)
	ON_WM_DESTROY()
	ON_WM_SHOWWINDOW()
	ON_BN_CLICKED(IDCANCELREALLY, OnCancelreally)
	ON_WM_CTLCOLOR()
	ON_BN_CLICKED(IDC_BUTTONCONNECT, OnButtonconnect)
	ON_EN_CHANGE(IDC_EDIT2, OnChangeEdit2)
	ON_MESSAGE( WINDOWSHOW_DONE, InitializeMachine )
	ON_MESSAGE( WINDOWMACHINE_DONE , InitializeTree )
	//}}AFX_MSG_MAP
	ON_MESSAGE(FOCUSCONNECT,FocusConnect)
	ON_MESSAGE(FOCUSTREE,FocusTree)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBrowseDialogPopup message handlers

int CBrowseDialogPopup::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CDialog::OnCreate(lpCreateStruct) == -1)
	{
		return -1;
	}

	return 0;
}

void CBrowseDialogPopup::OnButton1()
{
	CWaitCursor wait;
	CString csMachine = GetMachineName();
	wait.Restore( );

	if (csMachine.IsEmpty())
	{
		return;
	}
	if (m_csMachine.CompareNoCase(csMachine) == 0)
	{

		return;
	}


	m_cmeiMachine.SetTextClean();

	m_csMachine = _T("\\\\");
	m_csMachine += csMachine;

	m_cmeiMachine.SetWindowText(m_csMachine);

	CString csNamespace = m_csMachine + _T("\\root");
	BOOL bReturn =
		m_cnstTree.DisplayNameSpaceInTree
			(&csNamespace,reinterpret_cast<CWnd *>(this));

	EnableOK(FALSE);

	UpdateData(FALSE);
}

BOOL CBrowseDialogPopup::OnInitDialog()
{
	CDialog::OnInitDialog();

	m_pParent->OnActivateInPlace(TRUE,NULL);

	EnableOK(FALSE);
	SetFocus();

	PostMessage(FOCUSCONNECT,0,0);


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

CString CBrowseDialogPopup::GetMachineName()
{
	CWaitCursor wait;

	CString csMAchine;

	//IMalloc *pimMalloc;

	HRESULT hr = CoGetMalloc(MEMCTX_TASK,&m_pimMalloc);

	BROWSEINFO bi;
    LPTSTR lpBuffer;
    LPITEMIDLIST pidlMachines;  // PIDL for Network Hood
    LPITEMIDLIST pidlBrowse;    // PIDL selected by user

    // Allocate a buffer to receive browse information.
    if ((lpBuffer = (LPTSTR) m_pimMalloc->Alloc(MAX_PATH)) == NULL)
	{
		m_pimMalloc->Release();
        return csMAchine;
	}

		    // Get the PIDL for the Programs folder.
    if (!SUCCEEDED(SHGetSpecialFolderLocation(
            this->GetSafeHwnd(), CSIDL_NETWORK, &pidlMachines)))
	{//CSIDL_NETHOOD  CSIDL_NETWORK
        m_pimMalloc->Free(lpBuffer);
        return csMAchine;
    }


    // Fill in the BROWSEINFO structure.
    bi.hwndOwner = this->GetSafeHwnd();
    bi.pidlRoot = pidlMachines;
    bi.pszDisplayName = lpBuffer;
    bi.lpszTitle = NULL;
    bi.ulFlags = BIF_BROWSEFORCOMPUTER;
    bi.lpfn = NULL;
    bi.lParam = 0;

    // Browse for a folder and return its PIDL.
    pidlBrowse = SHBrowseForFolder(&bi);

	wait.Restore( );

    if (pidlBrowse != NULL)
	{
		STRRET strretMachine;
		strretMachine.uType = STRRET_WSTR;
		HRESULT hResult;
		IShellFolder *pisfMachine = NULL;
		hResult = SHGetDesktopFolder(&pisfMachine);
		if (hResult == S_OK)
		{
			csMAchine = GoToMachine(pisfMachine,pidlBrowse);
		}
        // Free the PIDL returned by SHBrowseForFolder.
        m_pimMalloc->Free(pidlBrowse);
    }

    // Clean up.
	m_pimMalloc->Free(pidlMachines);
    m_pimMalloc->Free(lpBuffer);
	m_pimMalloc->Release();
	return csMAchine;

}

CString CBrowseDialogPopup::GoToMachine
(IShellFolder *pisfMachine, LPITEMIDLIST pidlBrowse)
{
    //CWaitCursor wait;
	CString csMAchine;
	LPITEMIDLIST pidl;
	LPITEMIDLIST pidlSave;
	LPSHELLFOLDER pSubFolder;
    LPITEMIDLIST pidlCopy;

    // Process each item identifier in the list.
    for (pidl = pidlBrowse; pidl != NULL;
            pidl = GetNextItemID(pidl))
	{
		pidlSave = pidl;

		// Copy the item identifier to a list by itself.
        if ((pidlCopy = CopyItemID(pidl)) == NULL)
            break;

		// Bind to the subfolder.
        if (!SUCCEEDED(pisfMachine->BindToObject(
                pidlCopy, NULL,
                IID_IShellFolder, (LPVOID *) &pSubFolder)))
		{
            m_pimMalloc->Free(pidlCopy);
            break;
        }

        // Free the copy of the item identifier.
        m_pimMalloc->Free(pidlCopy);

        // Release the parent folder and point to the
        // subfolder.
        pisfMachine->Release();
        pisfMachine = pSubFolder;
	}

    STRRET sName;

    // Copy the item identifier to a list by itself.
    if ((pidlCopy = CopyItemID(pidlSave)) != NULL)
	{
		// Get the name of the subfolder.
		if (SUCCEEDED(pisfMachine->GetDisplayNameOf(
					pidlCopy, SHGDN_INFOLDER,
					&sName)))
		{
			csMAchine = GetMachineNameFromStrRet(pidlCopy, &sName);
		}

		m_pimMalloc->Free(pidlCopy);
	}

    // Release the last folder that was bound to.
    if (pisfMachine != NULL)
        pisfMachine->Release();



    return csMAchine;
}




CString CBrowseDialogPopup::WalkDownToMachine
(IShellFolder *pisfMachine, LPITEMIDLIST pidlBrowse)
{
    //CWaitCursor wait;
	CString csMAchine;
	LPITEMIDLIST pidl;

    // Process each item identifier in the list.
    for (pidl = pidlBrowse; pidl != NULL;
            pidl = GetNextItemID(pidl)) {
        STRRET sName;
        LPSHELLFOLDER pSubFolder;
        LPITEMIDLIST pidlCopy;

        // Copy the item identifier to a list by itself.
        if ((pidlCopy = CopyItemID(pidl)) == NULL)
            break;

        // Display the name of the subfolder.
        if (SUCCEEDED(pisfMachine->GetDisplayNameOf(
                pidlCopy, SHGDN_INFOLDER,
                &sName)))
		 {
            csMAchine = GetMachineNameFromStrRet(pidlCopy, &sName);
		 }

        // Bind to the subfolder.
        if (!SUCCEEDED(pisfMachine->BindToObject(
                pidlCopy, NULL,
                IID_IShellFolder, (LPVOID *) &pSubFolder))) {
            m_pimMalloc->Free(pidlCopy);
            break;
        }

        // Free the copy of the item identifier.
        m_pimMalloc->Free(pidlCopy);

        // Release the parent folder and point to the
        // subfolder.
        pisfMachine->Release();
        pisfMachine = pSubFolder;
    }

    // Release the last folder that was bound to.
    if (pisfMachine != NULL)
        pisfMachine->Release();



    return csMAchine;
}


// GetNextItemID - points to the next element in an item identifier
//     list.
// Returns a PIDL if successful or NULL if at the end of the list.
// pdil - previous element
LPITEMIDLIST CBrowseDialogPopup::GetNextItemID(LPITEMIDLIST pidl)
{
	//CWaitCursor wait;
    // Get the size of the specified item identifier.
    int cb = pidl->mkid.cb;

    // If the size is zero, it is the end of the list.
    if (cb == 0)
        return NULL;

    // Add cb to pidl (casting to increment by bytes).
    pidl = (LPITEMIDLIST) (((LPBYTE) pidl) + cb);

    // Return NULL if it is null-terminating or a pidl otherwise.
    return (pidl->mkid.cb == 0) ? NULL : pidl;
}

//Following is the CopyItemID function. Given a pointer to an
//element in an item identifier list, the function allocates a
//new list containing only the specified element followed by a
//terminating zero. The main function uses this function to create
//single-element PIDLs, which it passes to IShellFolder member
//functions.
// CopyItemID - creates an item identifier list containing the first
//     item identifier in the specified list.
// Returns a PIDL if successful or NULL if out of memory.
LPITEMIDLIST CBrowseDialogPopup::CopyItemID(LPITEMIDLIST pidl)
{
	//CWaitCursor wait;
    // Get the size of the specified item identifier.
    int cb = pidl->mkid.cb;

    // Allocate a new item identifier list.
    LPITEMIDLIST pidlNew = (LPITEMIDLIST)
        m_pimMalloc->Alloc(cb + sizeof(USHORT));
    if (pidlNew == NULL)
        return NULL;

    // Copy the specified item identifier.
    CopyMemory(pidlNew, pidl, cb);

    // Append a terminating zero.
    *((USHORT *) (((LPBYTE) pidlNew) + cb)) = 0;

    return pidlNew;
}

//The IShellFolder::GetDisplayNameOf member function returns a
//display name in a STRRET structure. The display name may be
//returned in one of three ways, which is specified by the uType
// member of the STRRET structure.
// GetMachineName - gets the contents of a STRRET structure.
// pidl - PIDL containing the display name if STRRET_OFFSET
// lpStr - address of the STRRET structure
CString CBrowseDialogPopup::GetMachineNameFromStrRet(LPITEMIDLIST pidl, LPSTRRET lpStr)
{
	//CWaitCursor wait;
	CString csMAchine;
	char *pszTmp;

    switch (lpStr->uType) {

        case STRRET_WSTR:

			csMAchine = lpStr->pOleStr;


            break;

        case STRRET_OFFSET:
			pszTmp = ((char *) pidl) + lpStr->uOffset;
			csMAchine = pszTmp;

            break;

        case STRRET_CSTR:
			csMAchine = lpStr->cStr;

            break;
    }
	return csMAchine;
}


BOOL CBrowseDialogPopup::PreTranslateMessage(MSG* lpMsg)
{
	switch (lpMsg->message)
   {
	case WM_SYSKEYDOWN:
		{
		// Need to do this here because the conect button handler is called
		// before the edit loses focus.
		UINT_PTR w = lpMsg->wParam;
		CString csText;
		m_cmeiMachine.GetWindowText(csText);
		m_csMachineBeforeLosingFocus = csText;
		break;
		}
	}

	return CDialog::PreTranslateMessage(lpMsg);
}

void CBrowseDialogPopup::OnOK()
{
	TCHAR szClass[10];
	CWnd* pWndFocus = GetFocus();
	if (((pWndFocus = GetFocus()) != NULL) &&
		IsChild(pWndFocus) &&
		(pWndFocus->GetStyle() & ES_WANTRETURN) &&
		GetClassName(pWndFocus->m_hWnd, szClass, 10) &&
		(_tcsicmp(szClass, _T("EDIT")) == 0))
	{
		m_cmeiMachine.SendMessage(WM_CHAR,VK_RETURN,0);
		return;
	}
	else if (pWndFocus && (pWndFocus->GetSafeHwnd() == m_cbConnect.GetSafeHwnd()))
	{
			OnButtonconnect();
			return;
	}
	else if (pWndFocus && (pWndFocus->GetSafeHwnd() == m_NetWork.GetSafeHwnd()))
	{
			OnButton1();
			return;
	}


	OnOkreally();


}

void CBrowseDialogPopup::OnOkreally()
{
	// TODO: Add your control notification handler code here

	m_bInitialized = FALSE;
	CString csNamespace;

	csNamespace = m_cnstTree.GetSelectedNamespace();

	if (!csNamespace.IsEmpty())
	{
		CString *pcsNew;
		pcsNew = new CString(csNamespace);
		UpdateData();
		m_pParent->PostMessage(SETNAMESPACE,!m_bUseExisting,(LPARAM) pcsNew);
	}

	m_cmeiMachine.SetTextClean();
	CDialog::OnOK();
}

void CBrowseDialogPopup::EnableOK(BOOL bOK)
{
	CButton *pcbOK =
		reinterpret_cast<CButton *>(GetDlgItem(IDOKREALLY));
	if (m_cmeiMachine.IsClean())
	{
		pcbOK->EnableWindow(bOK);
	}
	else
	{
		pcbOK->EnableWindow(FALSE);
	}

}

void CBrowseDialogPopup::OnCancel()
{
	TCHAR szClass[10];
	CWnd* pWndFocus = GetFocus();
	if (((pWndFocus = GetFocus()) != NULL) &&
		IsChild(pWndFocus) &&
		(pWndFocus->GetStyle() & ES_WANTRETURN) &&
		GetClassName(pWndFocus->m_hWnd, szClass, 10) &&
		(_tcsicmp(szClass, _T("EDIT")) == 0))
	{
		m_cmeiMachine.SendMessage(WM_CHAR,VK_ESCAPE,0);
		return;
	}

	OnCancelreally();

}

void CBrowseDialogPopup::OnDestroy()
{
	CDialog::OnDestroy();

	// TODO: Add your message handler code here

}

void CBrowseDialogPopup::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CDialog::OnShowWindow(bShow, nStatus);

	if (m_bInitialized == FALSE)
	{
		m_bInitialized = TRUE;
		if (!m_pParent->m_csNameSpace.IsEmpty())
		{
			PostMessage(WINDOWSHOW_DONE,0,0);
		}
		else
		{
			m_cnstTree.SetLocalParent(m_pParent);
			m_cnstTree.SetNewStyle
			(WS_CHILD | WS_VISIBLE | CS_DBLCLKS | TVS_LINESATROOT |
				TVS_HASLINES | TVS_HASBUTTONS | TVS_SHOWSELALWAYS, TRUE);
			m_cnstTree.SetNewStyle(TVS_EDITLABELS,FALSE);
			m_cnstTree.InitImageList();
			m_cmeiMachine.SetTextDirty();
			m_cmeiMachine.SetWindowText(m_csMachine);
			if (m_pParent->ConnectedToMachineP(m_csMachine))
			{
				m_cmeiMachine.SetTextClean();
				m_cmeiMachine.SetWindowText(m_csMachine);
				UpdateData();
				CString csNamespace = m_csMachine + _T("\\") + m_szNameSpace; //_T("\\root");
				m_cbConnect.EnableWindow(FALSE);
				BOOL bReturn =
					m_cnstTree.DisplayNameSpaceInTree
						(&csNamespace,reinterpret_cast<CWnd *>(this));
				if (bReturn)
				{
					PostMessage(FOCUSTREE,0,0);
				}
			}
			else
			{
				m_cmeiMachine.SetTextDirty();
				m_cmeiMachine.SetWindowText(m_csMachine);
				m_cbConnect.EnableWindow(TRUE);
				PostMessage(FOCUSCONNECT,0,0);
			}
		}
	}


}

LRESULT CBrowseDialogPopup::InitializeMachine(WPARAM, LPARAM)
{
	m_cmeiMachine.SetWindowText(m_csMachine);

	m_cnstTree.SetLocalParent(m_pParent);

	EnableOK(FALSE);

	UpdateWindow();

	PostMessage(WINDOWMACHINE_DONE,0,0);


	return 0;
}

LRESULT CBrowseDialogPopup::InitializeTree(WPARAM, LPARAM)
{

	m_cnstTree.SetNewStyle
		(WS_CHILD | WS_VISIBLE | CS_DBLCLKS | TVS_LINESATROOT |
			TVS_HASLINES | TVS_HASBUTTONS | TVS_SHOWSELALWAYS, TRUE);

	m_cnstTree.SetNewStyle(TVS_EDITLABELS,FALSE);

	m_cnstTree.InitImageList();

	if (m_pParent->ConnectedToMachineP(m_csMachine))
	{
		m_cmeiMachine.SetTextClean();
		m_cmeiMachine.SetWindowText(m_csMachine);
		UpdateData();
		CString csNamespace = m_csMachine + _T("\\") + m_szNameSpace; //_T("\\root");
		m_cbConnect.EnableWindow(FALSE);
		BOOL bReturn =
			m_cnstTree.DisplayNameSpaceInTree
				(&csNamespace,reinterpret_cast<CWnd *>(this));
		if (bReturn)
		{
			PostMessage(FOCUSTREE,0,0);
		}
	}
	else
	{
		m_cmeiMachine.SetTextDirty();
		m_cmeiMachine.SetWindowText(m_csMachine);
		m_cbConnect.EnableWindow(TRUE);
		PostMessage(FOCUSCONNECT,0,0);
	}

	return 0;
}

INT_PTR CBrowseDialogPopup::DoModal()
{
	// TODO: Add your specialized code here and/or call the base class
	CWaitCursor wait;

	INT_PTR nReturn = CDialog::DoModal();

	return nReturn;
}

void CBrowseDialogPopup::OnCancelreally()
{
	// TODO: Add your control notification handler code here
	m_bInitialized = FALSE;

	m_cmeiMachine.SetTextClean();
	CDialog::OnCancel();
	m_pParent->FireNameSpaceEntryRedrawn();
}

HBRUSH CBrowseDialogPopup::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);

	// TODO: Change any attributes of the DC here
	if (nCtlColor == CTLCOLOR_EDIT)
	{
		pDC->SetTextColor(m_cmeiMachine.m_clrText);
		pDC->SetBkColor( m_cmeiMachine.m_clrBkgnd );	// text bkgnd
		return m_cmeiMachine.m_brBkgnd;


	}
	// TODO: Return a different brush if the default is not desired
	return hbr;
}

void CBrowseDialogPopup::OnButtonconnect()
{
	// TODO: Add your control notification handler code here
	CString csMachine;

	if (m_csMachineBeforeLosingFocus.IsEmpty())
	{
		m_cmeiMachine.GetWindowText(csMachine);
	}
	else
	{
		m_cmeiMachine.SetWindowText(m_csMachineBeforeLosingFocus);
	}

	m_cmeiMachine.SetFocus();
	m_cmeiMachine.PostMessage(WM_CHAR, 13, 13);
	m_csMachineBeforeLosingFocus.Empty();
}

LRESULT CBrowseDialogPopup::FocusConnect(WPARAM, LPARAM)
{
	if (m_cbConnect.IsWindowEnabled())
	{
		m_cbConnect.SetFocus();
	}
	else
	{
		PostMessage(FOCUSTREE,0,0);
	}

	return 0;
}

LRESULT CBrowseDialogPopup::FocusTree(WPARAM, LPARAM)
{
	m_cnstTree.SetFocus();

	return 0;
}

void CBrowseDialogPopup::OnChangeEdit2()
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CDialog::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

	m_cbConnect.EnableWindow(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\browsenamespace.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// BrowseNameSpace.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CBrowseNameSpace window

class CBrowseNameSpace : public CButton
{
// Construction
public:
	CBrowseNameSpace();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBrowseNameSpace)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CBrowseNameSpace();

	// Generated message map functions
protected:
	//{{AFX_MSG(CBrowseNameSpace)
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\browsedialogpopup.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// BrowseDialogPopup.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CBrowseDialogPopup dialog

#define WINDOWSHOW_DONE WM_USER + 15
#define WINDOWMACHINE_DONE WM_USER + 16

class CNSEntryCtrl;
class CNameSpaceTree;
class CEditInput;

class CBrowseDialogPopup : public CDialog
{
// Construction
public:
	CBrowseDialogPopup(CNSEntryCtrl* pParent = NULL);   // standard constructor
	~CBrowseDialogPopup();
	void SetLocalParent(CNSEntryCtrl *pParent)
		{m_pParent = pParent;}
	void SetMachineName(CString *pcsMachineName)
		{m_csMachine = *pcsMachineName;}
	void SetNameSpace(CString *pcsNameSpace)
		{m_szNameSpace = *pcsNameSpace;}
	void EnableOK(BOOL bOK);

// Dialog Data
	//{{AFX_DATA(CBrowseDialogPopup)
	enum { IDD = IDD_DIALOGBROWSE };
	CButton	m_NetWork;
	CButton	m_cbConnect;
	CMachineEditInput	m_cmeiMachine;
	CNameSpaceTree	m_cnstTree;
	CString	m_szNameSpace;
	BOOL	m_bUseExisting;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBrowseDialogPopup)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual INT_PTR DoModal();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CNSEntryCtrl *m_pParent;
	BOOL m_bInitialized;
	CString GetMachineName();
	IMalloc *m_pimMalloc;
	CString	m_csMachine;
	CString GoToMachine
		(IShellFolder *pisfMachine, LPITEMIDLIST pidlBrowse);
	CString WalkDownToMachine
		(IShellFolder *pisfMachine, LPITEMIDLIST pidlBrowse);
	LPITEMIDLIST GetNextItemID(LPITEMIDLIST pidl);
	LPITEMIDLIST CopyItemID(LPITEMIDLIST pidl);
	CString GetMachineNameFromStrRet(LPITEMIDLIST pidl, LPSTRRET lpStr);

	CString m_csMachineBeforeLosingFocus;

	CStringArray m_csaNamespaceConnectionsFromDailog;

	// Generated message map functions
	//{{AFX_MSG(CBrowseDialogPopup)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnButton1();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnOkreally();
	virtual void OnCancel();
	afx_msg void OnDestroy();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnCancelreally();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnButtonconnect();
	afx_msg void OnChangeEdit2();
	//}}AFX_MSG
	afx_msg LRESULT InitializeTree(WPARAM, LPARAM);
	afx_msg LRESULT InitializeMachine(WPARAM, LPARAM);
	afx_msg LRESULT FocusConnect(WPARAM, LPARAM);
	afx_msg LRESULT FocusTree(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
	friend class CNSEntryCtrl;
	friend class CMachineEditInput;
	friend class CNameSpaceTree;
	friend class CEditInput;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\cathelp.cpp ===
//=--------------------------------------------------------------------------=

// CatHelp.Cpp

//=--------------------------------------------------------------------------=

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "precomp.h"

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\browsenamespace.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// BrowseNameSpace.cpp : implementation file
//

#include "precomp.h"
#include "NSEntry.h"
#include "BrowseNameSpace.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBrowseNameSpace

CBrowseNameSpace::CBrowseNameSpace()
{
}

CBrowseNameSpace::~CBrowseNameSpace()
{
}


BEGIN_MESSAGE_MAP(CBrowseNameSpace, CButton)
	//{{AFX_MSG_MAP(CBrowseNameSpace)
	ON_WM_LBUTTONUP()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBrowseNameSpace message handlers

void CBrowseNameSpace::OnLButtonUp(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	CButton::OnLButtonUp(nFlags, point);
}

int CBrowseNameSpace::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CButton::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO: Add your specialized creation code here

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\editinput.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// EditInput.cpp : implementation file
//

#include "precomp.h"
#include <shlobj.h>
#include <afxcmn.h>
#include "wbemidl.h"
#include "resource.h"
#include "NSEntry.h"
#include "NameSpaceTree.h"
#include "MachineEditInput.h"
#include "BrowseDialogPopup.h"
#include "NSEntryCtl.h"
#include "EditInput.h"
#include "NameSpace.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


extern CNSEntryApp NEAR theApp;
/////////////////////////////////////////////////////////////////////////////
// CEditInput

CEditInput::CEditInput()
{
	m_pParent = NULL;
	m_clrText = COLOR_CLEAN_CELL_TEXT;
	m_clrBkgnd = RGB( 255, 255, 255 );
	m_brBkgnd.CreateSolidBrush( m_clrBkgnd );
	m_bSawKeyDown = FALSE;
}

CEditInput::~CEditInput()
{
}


BEGIN_MESSAGE_MAP(CEditInput, CEdit)
	//{{AFX_MSG_MAP(CEditInput)
	ON_CONTROL_REFLECT(EN_UPDATE, OnUpdate)
	ON_WM_KEYUP()
	ON_WM_CHAR()
	ON_WM_CTLCOLOR()
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	ON_WM_LBUTTONDOWN()
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditInput message handlers

void CEditInput::OnUpdate()
{
	// TODO: Add your control notification handler code here

}

void CEditInput::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// TODO: Add your message handler code here and/or call default
	time_t ttKeyDown = CTime::GetCurrentTime().GetTime();

	CEdit::OnKeyUp(nChar, nRepCnt, nFlags);

	if ((m_bSawKeyDown && (m_ttKeyDown != ttKeyDown)) || !m_bSawKeyDown)
	{
#ifdef _DEBUG
	afxDump << _T("**** CEditInput::OnKeyUp with m_bSawKeyDown == FALSE\n");
#endif
		m_bSawKeyDown = FALSE;
		return;
	}

	m_bSawKeyDown = FALSE;

#ifdef _DEBUG
	afxDump << _T("**** CEditInput::OnKeyUp\n");
#endif

	if (m_pParent && (nChar == VK_RETURN))
	{
		CString csText;
		GetWindowText(csText);
		csText.TrimLeft();
		csText.TrimRight();
		SetWindowText((LPCTSTR) csText);
		if (csText.GetLength() + 1 > MAX_PATH)
		{
			CString csMessage = _T("Namespace is too long: ") + csText;
			m_pParent->m_pParent->ErrorMsg
				(&csMessage, WBEM_E_INVALID_NAMESPACE, NULL, TRUE,NULL, __FILE__, __LINE__);
			m_pParent->RedrawWindow();
			m_pParent->UpdateWindow();
			m_pParent->m_pParent->InvalidateControl();
			m_pParent->m_pParent->FireNameSpaceEntryRedrawn();
			m_pParent->m_pParent->PostMessage(FOCUSEDIT,0,0);
			return;
		}
		else if (csText.Compare(_T("\\")) == 0 || csText.Compare(_T("\\\\")) == 0)
		{
			CString csUserMsg = _T("Invalid namespace name: ") ;
			csUserMsg += csText;
			csUserMsg += _T(".");
			m_pParent->m_pParent->ErrorMsg
				(&csUserMsg, WBEM_E_INVALID_NAMESPACE, NULL, TRUE, &csUserMsg, __FILE__, __LINE__);
			m_pParent->RedrawWindow();
			m_pParent->UpdateWindow();
			m_pParent->m_pParent->InvalidateControl();
			m_pParent->m_pParent->FireNameSpaceEntryRedrawn();
			m_pParent->m_pParent->PostMessage(FOCUSEDIT,0,0);
			return;
		}

		if (csText.GetLength() > 0)
		{
			m_pParent->SendMessage(CNS_EDITDONE,0,0);
		}
	}
	else if (m_pParent && (nChar == VK_ESCAPE))
	{
		SetTextClean();
		SetWindowText(m_pParent->m_csNameSpace);
		SetSel
		(m_pParent->m_csNameSpace.GetLength(),
			m_pParent->m_csNameSpace.GetLength());
		m_pParent->m_pParent->FireNameSpaceEntryRedrawn();
		m_pParent->RedrawWindow();
		m_pParent->UpdateWindow();
		m_pParent->m_pParent->InvalidateControl();
	}
}

void CEditInput::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{

#ifdef _DEBUG
	afxDump << _T("**** CEditInput::OnChar\n");
	if (nChar == VK_RETURN ||  nChar == VK_ESCAPE)
	{
		afxDump << _T("Saw VK_RETURN or VK_ESCAPE in OnChar\n");
	}
#endif

	// If we are not in a tree we need to handle OnChar.
	CString csNamespace;

	CWnd *pFocus = GetFocus();


	if (pFocus != this)
	{
		SetFocus();
	}

	if (nChar != VK_RETURN && nChar != VK_ESCAPE)
	{
		CEdit::OnChar(nChar, nRepCnt, nFlags);
	}

	if (m_pParent && (nChar == VK_RETURN))
	{
		CString csText;
		GetWindowText(csText);
		csText.TrimLeft();
		csText.TrimRight();
		SetWindowText((LPCTSTR) csText);
		if (csText.GetLength() + 1 > MAX_PATH)
		{
			CString csMessage = _T("Namespace is too long: ") + csText;
			m_pParent->m_pParent->ErrorMsg
				(&csMessage, WBEM_E_INVALID_NAMESPACE, NULL, TRUE,NULL, __FILE__, __LINE__);
			m_pParent->RedrawWindow();
			m_pParent->UpdateWindow();
			m_pParent->m_pParent->InvalidateControl();
			m_pParent->m_pParent->FireNameSpaceEntryRedrawn();
			m_pParent->m_pParent->PostMessage(FOCUSEDIT,0,0);
			return;
		}
		else if (csText.Compare(_T("\\")) == 0 || csText.Compare(_T("\\\\")) == 0)
		{
			CString csUserMsg = _T("Invalid namespace name: ") ;
			csUserMsg += csText;
			csUserMsg += _T(".");
			m_pParent->m_pParent->ErrorMsg
				(&csUserMsg, WBEM_E_INVALID_NAMESPACE, NULL, TRUE, &csUserMsg, __FILE__, __LINE__);
			m_pParent->RedrawWindow();
			m_pParent->UpdateWindow();
			m_pParent->m_pParent->InvalidateControl();
			m_pParent->m_pParent->FireNameSpaceEntryRedrawn();
			m_pParent->m_pParent->PostMessage(FOCUSEDIT,0,0);
			return;
		}

		if (csText.GetLength() > 0)
		{
			m_pParent->SendMessage(CNS_EDITDONE,0,0);
		}
	}
	else if (m_pParent && (nChar == VK_ESCAPE))
	{
		SetTextClean();
		SetWindowText(m_pParent->m_csNameSpace);
		SetSel
		(m_pParent->m_csNameSpace.GetLength(),
			m_pParent->m_csNameSpace.GetLength());
	}
	else
	{
		SetTextDirty();
	}



	m_pParent->m_pParent->FireNameSpaceEntryRedrawn();
	m_pParent->RedrawWindow();
	m_pParent->UpdateWindow();
	m_pParent->m_pParent->InvalidateControl();


}

HBRUSH CEditInput::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	// TODO: Change any attributes of the DC here
	pDC->SetTextColor(m_clrText);
	pDC->SetBkColor( m_clrBkgnd );	// text bkgnd
	return m_brBkgnd;

}

void CEditInput::OnKillFocus(CWnd* pNewWnd)
{

#ifdef _DEBUG
	afxDump << _T("**** CEditInput::OnKillFocus\n");
#endif

	CString csText;
	GetWindowText(csText);
	csText.TrimLeft();
	csText.TrimRight();
	SetWindowText((LPCTSTR) csText);


	if (csText.GetLength() + 1 > MAX_PATH)
	{
		CEdit::OnKillFocus(pNewWnd);
		m_pParent->RedrawWindow();
		m_pParent->UpdateWindow();
		m_pParent->m_pParent->InvalidateControl();
		m_pParent->m_pParent->FireNameSpaceEntryRedrawn();
		m_pParent->m_pParent->PostMessage(FOCUSEDIT,0,0);
		return;
	}

	m_pParent->m_pParent->FireChangeFocus(0);

	CEdit::OnKillFocus(pNewWnd);

	GetWindowText(csText);

	m_csTextSave = csText;
	m_clrTextSave = m_clrText;

	if(m_pParent->m_bOpeningNamespace)
	{
		return;
	}

	if(!m_pParent->m_pParent->m_lClearOnLoseFocus)
	{
		return;
	}

	if (!IsClean() || csText.GetLength() == 0)
	{
		SetTextClean();
		SetWindowText(m_pParent->m_csNameSpace);
	}

	m_pParent->m_pParent->FireNameSpaceEntryRedrawn();
	m_pParent->RedrawWindow();
	m_pParent->UpdateWindow();
	m_pParent->m_pParent->InvalidateControl();

	// TODO: Add your message handler code here

}

void CEditInput::OnSetFocus(CWnd* pOldWnd)
{

#ifdef _DEBUG
	afxDump << _T("**** CEditInput::OnSetFocus\n");
#endif

	m_pParent->m_pParent->FireChangeFocus(1);

	CEdit::OnSetFocus(pOldWnd);
	m_csTextSave.Empty();

	m_pParent->m_pParent->OnActivateInPlace(TRUE,NULL);

}

void CEditInput::OnLButtonDown(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	CEdit::OnLButtonDown(nFlags, point);
}

void CEditInput::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// TODO: Add your message handler code here and/or call default
#ifdef _DEBUG
	afxDump << _T("**** CEditInput::OnKeyDown\n");
#endif
	if (nChar == VK_RETURN || nChar == VK_ESCAPE)
	{
		m_bSawKeyDown = TRUE;
	}
	else
	{
		m_bSawKeyDown = FALSE;
	}

	CEdit::OnKeyDown(nChar, nRepCnt, nFlags);

	// We care about the time we saw a return key because if we are in another control
	// as opposed to a dialog we may see a return key up without seeing a key down.
	// We do work when we see a return key down folowed by key up but do not want to
	// do work if we just see a return key up.
	// Do not put a breakpoint between here and the GetTime() in key up!
	if (nChar == VK_RETURN || nChar == VK_ESCAPE)
	{
		m_ttKeyDown = CTime::GetCurrentTime().GetTime();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\ccontainedtoolbar.h ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: CContainedToolBar.h
//
// Description:
//	This file declares the CContainedToolBar class which is a part of the Class 
//	Navigator OCX, it is a subclass of the Microsoft CToolBar 
//  control and performs the following functions:
//		a.  Provides a member function to calculate its size
//		b.  Provides a tooltip.
//
// Part of: 
//	ClassNav.ocx 
//
// Used by: 
//	 CBanner
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

//****************************************************************************
//
// CLASS:  CContainedToolBar
//
// Description:
//	  This class is a subclass of the Microsoft CToolBar control.  It
//	  provides a member function to calculate its size and provides a tooltip.
//
// Public members:
//	
//	  CContainedToolBar	Public constructor.
//	  GetToolTip		Returns the tooltip control.
//	  SetParent			Sets the classes logicl parent.
//	  GetToolBarSize	Returns the size of the tool bar. 
//
//============================================================================
//
// CContainedToolBar::CContainedToolBar
//
// Description:
//	  This member function is the public constructor.  It initializes the state
//	  of member variables.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  NONE
//
//============================================================================
//
// CContainedToolBar::GetToolTip
//
// Description:
//	  This member function returns a reference to the tooltip control.
//
// Parameters:
//	  VOID
//
// Returns:
// 	  CToolTipCtrl &	Reference to the tooltip control.
//
//============================================================================
//
// CContainedToolBar::SetParent
//
// Description:
//	  This member function sets the logical parent.
//
// Parameters:
//	  CClassNavCtrl *pParent	Logical parent.
//
// Returns:
// 	  VOID
//
//============================================================================
//
// CContainedToolBar::GetToolBarSize
//
// Description:
//	  This member function returns the toolbar's size..
//
// Parameters:
//	  VOID
//
// Returns:
// 	  CSize						Toolbar size.
//
//****************************************************************************	 

#ifndef _CContainedToolBar_H_
#define _CContainedToolBar_H_

class 	CNSEntryCtrl;

class CContainedToolBar : public CToolBar
{
public:
	CContainedToolBar() {m_pParent = NULL;}
	void SetParent(CNSEntryCtrl *pParent) {m_pParent = pParent;}
	CSize GetToolBarSize();
	CToolTipCtrl &GetToolTip() {return m_ttip;}
protected:
	CNSEntryCtrl *m_pParent;
	CToolTipCtrl m_ttip;
    //{{AFX_MSG(CContainedToolBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\editinput.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// EditInput.h : header file
//

class CNameSpace;
class CNSEntryCtrl;
/////////////////////////////////////////////////////////////////////////////
// CEditInput window

class CEditInput : public CEdit
{
// Construction
public:
	CEditInput();
	void SetTextClean() {m_clrText = COLOR_CLEAN_CELL_TEXT;}
	void SetTextDirty() {m_clrText = COLOR_DIRTY_CELL_TEXT;}
	BOOL IsClean() {return m_clrText == COLOR_CLEAN_CELL_TEXT;}
// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditInput)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEditInput();
	void SetLocalParent(CNameSpace *pParent){m_pParent = pParent;}

	// Generated message map functions
protected:
	CNameSpace *m_pParent;
	COLORREF m_clrText;
	COLORREF m_clrBkgnd;
	CBrush m_brBkgnd;
	CString m_csTextSave;
	COLORREF m_clrTextSave;
	BOOL m_bSawKeyDown;
	time_t m_ttKeyDown;
	//{{AFX_MSG(CEditInput)
	afx_msg void OnUpdate();
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	friend class CNameSpace;
	friend class CNSEntryCtrl;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\browsetbc.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// BrowseTBC.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CBrowseTBC window
class CNSEntryCtrl;

class CBrowseTBC : public CToolBarCtrl
{
// Construction
public:
	CBrowseTBC();
	void SetLocalParent(CNSEntryCtrl *pParent)
		{m_pParent = pParent;}	
	CSize GetToolBarSize();
// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBrowseTBC)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CBrowseTBC();

	// Generated message map functions
protected:
	CNSEntryCtrl *m_pParent;
	//{{AFX_MSG(CBrowseTBC)
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\machineeditinput.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MachineEditInput.h : header file
//


#define COLOR_DIRTY_CELL_TEXT  RGB(0, 0, 255) // Dirty text color = BLUE
#define COLOR_CLEAN_CELL_TEXT RGB(0, 0, 0)    // Clean text color = BLACK

/////////////////////////////////////////////////////////////////////////////
// CMachineEditInput window
class CBrowseDialogPopup;


class CMachineEditInput : public CEdit
{
// Construction
public:
	CMachineEditInput();
	void SetTextClean() {m_clrText = COLOR_CLEAN_CELL_TEXT;}
	void SetTextDirty() {m_clrText = COLOR_DIRTY_CELL_TEXT;}
	BOOL IsClean() {return m_clrText == COLOR_CLEAN_CELL_TEXT;}
// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMachineEditInput)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMachineEditInput();

	// Generated message map functions
protected:
	COLORREF m_clrText;
	COLORREF m_clrBkgnd;
	CBrush m_brBkgnd;
	//{{AFX_MSG(CMachineEditInput)
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnKillfocus();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	friend class CBrowseDialogPopup;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\ccontainedtoolbar.cpp ===
// ***************************************************************************

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
//
// File: CContainedToolBar.h
//
// Description:
//	This file implements the CContainedToolBar class which is a part of the Class
//	Navigator OCX, it is a subclass of the Microsoft CToolBar
//  control and performs the following functions:
//		a.  Provides a member function to calculate its size
//		b.  Provides a tooltip.
//
// Part of:
//	ClassNav.ocx
//
// Used by:
//	 CBanner
//
// History:
//	Judith Ann Powell	10-08-96		Created.
//
//
//**************************************************************************

#include "precomp.h"
#include <shlobj.h>
#include <afxcmn.h>
#include "afxpriv.h"
#include "AFXCONV.H"
#include "resource.h"
#include "wbemidl.h"
#include "CContainedToolBar.h"
#include "NameSpaceTree.h"
#include "MachineEditInput.h"
#include "BrowseDialogPopup.h"
#include "NSEntryCtl.h"

BEGIN_MESSAGE_MAP(CContainedToolBar,CToolBar)
	//{{AFX_MSG_MAP(CContainedToolBar)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// ***************************************************************************
//
// CContainedToolBar::GetToolBarSize
//
// Description:
//	  This member function returns the toolbar's size..
//
// Parameters:
//	  VOID
//
// Returns:
// 	  CSize						Toolbar size.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
CSize CContainedToolBar::GetToolBarSize()
{
	CRect rcButtons;
	CToolBarCtrl &rToolBarCtrl = GetToolBarCtrl();
	int nButtons = rToolBarCtrl.GetButtonCount();
	if (nButtons > 0) {
		CRect rcLastButton;
		rToolBarCtrl.GetItemRect(0, &rcButtons);
		rToolBarCtrl.GetItemRect(nButtons-1, &rcLastButton);
		rcButtons.UnionRect(&rcButtons, &rcLastButton);
	}
	else {
		rcButtons.SetRectEmpty();
	}

	CSize size;
	size.cx = rcButtons.Width();
	size.cy = rcButtons.Height();
	return size;
}

// ***************************************************************************
//
// CContainedToolBar::OnCreate
//
// Description:
//	  Called by the framework after the window is being created but before
//	  the window is shown.
//
// Parameters:
//	  LPCREATESTRUCT lpCreateStruct	Pointer to the structure which contains
//									default parameters.
//
// Returns:
//	  BOOL				0 if continue; -1 if the window should be destroyed.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
int CContainedToolBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	lpCreateStruct->style = lpCreateStruct->style |
								CBRS_TOOLTIPS | CBRS_FLYBY;
	if (CToolBar::OnCreate(lpCreateStruct) == -1)
		return -1;

	CToolBarCtrl &rToolBarCtrl = GetToolBarCtrl();

	if (!m_ttip.Create(this,TTS_ALWAYSTIP))
		TRACE0("Unable to create tip window.");
	else
	{
		m_ttip.Activate(TRUE);
		rToolBarCtrl.SetToolTips(&m_ttip );


	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\machineeditinput.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MachineEditInput.cpp : implementation file
//

#include "precomp.h"
#include "NSEntry.h"
#include <shlobj.h>
#include <afxcmn.h>
#include "wbemidl.h"
#include "resource.h"
#include "NameSpaceTree.h"
#include "MachineEditInput.h"
#include "BrowseDialogPopup.h"
#include "NSEntryCtl.h"

#define COLOR_DIRTY_CELL_TEXT  RGB(0, 0, 255) // Dirty text color = BLUE
#define COLOR_CLEAN_CELL_TEXT RGB(0, 0, 0)    // Clean text color = BLACK

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMachineEditInput

CMachineEditInput::CMachineEditInput()
{
	m_clrText = COLOR_CLEAN_CELL_TEXT;
	m_clrBkgnd = RGB( 255, 255, 255 );
	m_brBkgnd.CreateSolidBrush( m_clrBkgnd );
}

CMachineEditInput::~CMachineEditInput()
{
}


BEGIN_MESSAGE_MAP(CMachineEditInput, CEdit)
	//{{AFX_MSG_MAP(CMachineEditInput)
	ON_WM_CHAR()
	ON_WM_CTLCOLOR()
	ON_CONTROL_REFLECT(EN_KILLFOCUS, OnKillfocus)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMachineEditInput message handlers

void CMachineEditInput::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	CBrowseDialogPopup* pParent =
			reinterpret_cast<CBrowseDialogPopup *>
			(GetParent( ));

	if (nChar != VK_RETURN)
	{
		CEdit::OnChar(nChar, nRepCnt, nFlags);
	}


	if (nChar == VK_RETURN)
	{
		pParent->m_csMachineBeforeLosingFocus.Empty();
		CString csNamespace;

		GetWindowText(csNamespace);

		csNamespace.TrimLeft();
		csNamespace.TrimRight();


		if (csNamespace.GetLength() == 0)
		{
			CString csUserMsg = _T("Machine name cannot be blank.") ;
			pParent->m_pParent->ErrorMsg
				(&csUserMsg, WBEM_E_INVALID_NAMESPACE, NULL, TRUE, &csUserMsg, __FILE__, __LINE__);
			pParent->m_cbConnect.EnableWindow(TRUE);
			return;

		}
		else if (csNamespace.Compare(_T("\\")) == 0 || csNamespace.Compare(_T("\\\\")) == 0)
		{
			CString csUserMsg = _T("Invalid machine name: ") ;
			csUserMsg += csNamespace;
			csUserMsg += _T(".");

			pParent->m_pParent->ErrorMsg
				(&csUserMsg, WBEM_E_INVALID_NAMESPACE, NULL, TRUE, &csUserMsg, __FILE__, __LINE__);
			pParent->m_cbConnect.EnableWindow(TRUE);
			return;
		}

		pParent->UpdateData();
		if(pParent->m_szNameSpace.Left(4).CompareNoCase(_T("root")) != 0)
		{
			CString csUserMsg = _T("The initial namespace must start with 'root'");
			pParent->m_pParent->ErrorMsg
				(&csUserMsg, WBEM_E_INVALID_NAMESPACE, NULL, TRUE, &csUserMsg, __FILE__, __LINE__);
		}

		CString csSlashesMaybe;
		if (csNamespace[0] != '\\' ||
			csNamespace[1] != '\\')
		{
			if (csNamespace[0] != '\\')
			{
				csSlashesMaybe = _T("\\");
			}
			if (csNamespace[1] != '\\')
			{
				csSlashesMaybe += _T("\\");

			}
		}

		CString csValidate = csSlashesMaybe;
		csValidate += csNamespace;
		int nSlash = csValidate.ReverseFind('\\');

		if (nSlash > 1 || csValidate.GetLength() < 3 || csValidate.GetLength() + 1 > MAX_PATH)
		{
			CString csUserMsg = _T("Invalid machine name: ") ;
			csUserMsg += csValidate;
			csUserMsg += _T(".");

			pParent->m_pParent->ErrorMsg
				(&csUserMsg, WBEM_E_INVALID_NAMESPACE, NULL, TRUE, &csUserMsg, __FILE__, __LINE__);
			pParent->m_cbConnect.EnableWindow(TRUE);
			return;
		}

		nSlash = csValidate.ReverseFind('/');
		if (nSlash > 0)
		{
			CString csUserMsg = _T("Invalid machine name: ") ;
			csUserMsg += csValidate;
			csUserMsg += _T(".");

			pParent->m_pParent->ErrorMsg
				(&csUserMsg, WBEM_E_INVALID_NAMESPACE, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ );
			pParent->m_cbConnect.EnableWindow(TRUE);
			return;
		}

		SetTextClean();
		pParent->m_cbConnect.EnableWindow(FALSE);

		pParent->m_csMachine.Empty();

		pParent->m_csMachine = csSlashesMaybe;

		pParent->m_csMachine += csNamespace;
		SetWindowText(pParent->m_csMachine);

		pParent->m_cnstTree.ClearTree();
		pParent->m_cnstTree.UpdateWindow();

		csNamespace = pParent->m_csMachine + _T("\\") + pParent->m_szNameSpace; /*_T("\\root");*/
		BOOL bReturn =
			pParent->m_cnstTree.DisplayNameSpaceInTree
						(&csNamespace);

		if (bReturn)
		{
			pParent->m_csaNamespaceConnectionsFromDailog.Add(csNamespace);
			pParent->PostMessage(FOCUSTREE,0,0);
		}

		pParent->EnableOK(FALSE);
	 	EndWaitCursor();

	}
	else if (pParent && (nChar == VK_ESCAPE))
	{
		pParent->OnCancelreally();
	}
	else
	{
		pParent->EnableOK(FALSE);
		pParent->m_cbConnect.EnableWindow(TRUE);
		SetTextDirty();
	}

	RedrawWindow();


}

HBRUSH CMachineEditInput::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	// TODO: Change any attributes of the DC here
	pDC->SetTextColor(m_clrText);
	pDC->SetBkColor( m_clrBkgnd );	// text bkgnd
	return m_brBkgnd;
}

void CMachineEditInput::OnKillfocus()
{

	CBrowseDialogPopup* pParent =
			reinterpret_cast<CBrowseDialogPopup *>
			(GetParent( ));

	CString csText;
	GetWindowText(csText);

	pParent-> m_csMachineBeforeLosingFocus = csText;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\namespace.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// NameSpace.cpp : implementation file
//


#include "precomp.h"
#include <shlobj.h>
#include <afxcmn.h>
#include "wbemidl.h"
#include "resource.h"
#include "NameSpaceTree.h"
#include "MachineEditInput.h"
#include "BrowseDialogPopup.h"
#include "NSEntryCtl.h"
#include "EditInput.h"
#include "NameSpace.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNameSpace

CNameSpace::CNameSpace()
:	m_bFirst(TRUE),
	m_pceiInput(NULL),
	m_bOpeningNamespace(FALSE)
{

}

CNameSpace::~CNameSpace()
{
	delete m_pceiInput;
}


BEGIN_MESSAGE_MAP(CNameSpace, CComboBox)
	//{{AFX_MSG_MAP(CNameSpace)
	ON_WM_CREATE()
	ON_CONTROL_REFLECT(CBN_SELENDOK, OnSelendok)
	ON_CONTROL_REFLECT(CBN_CLOSEUP, OnCloseup)
	ON_CONTROL_REFLECT(CBN_EDITCHANGE, OnEditchange)
	ON_WM_CTLCOLOR()
	ON_WM_SIZE()
	ON_MESSAGE( RESTORE_DIRTY_TEXT, RestoreDirtyText )
	ON_MESSAGE( CNS_EDITDONE, OnEditDone )
	ON_CONTROL_REFLECT(CBN_DROPDOWN, OnDropdown)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNameSpace message handlers

int CNameSpace::OnCreate(LPCREATESTRUCT lpCreateStruct)
{

	m_pceiInput = new CEditInput;

	if (CComboBox::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;
}

void CNameSpace::OnSelendok()
{
	if (m_csNameSpace.IsEmpty())
	{
		m_csNameSpace = m_pParent->GetCurrentNamespace();
		if (m_csNameSpace.GetLength() > 0)
		{
			int nIndex = StringInArray(&m_csaNameSpaceHistory,&m_csNameSpace,0);
			if (nIndex < 0)
			{
				m_csaNameSpaceHistory.Add(m_csNameSpace);
			}
		}
	}

	CString csNameSpace;
	int nSelect = GetCurSel( );
	// Here if nothing is selected and text is clean or dirty there
	// will be not text in the combos edit box.  Test this in the clean
	// situation.
	if (nSelect != CB_ERR )
	{
		GetLBText(nSelect,csNameSpace);
		SetWindowText(csNameSpace);
		// Commented out so that namespace will be reinitialized
		// when reselected.
		if (m_csNameSpace.CompareNoCase(csNameSpace) != 0)
		{
			BOOL bOpened = m_pParent->OpenNameSpace(&csNameSpace,TRUE);
			if (bOpened)
			{
				m_csNameSpace = csNameSpace;
				m_pParent->FireNameSpaceEntryRedrawn();
				m_pParent->m_pcnsNameSpace->SetTextClean();
				m_pParent->InvalidateControl();
			}
			else
			{
				m_pParent->FireNameSpaceEntryRedrawn();
				m_pParent->m_pcnsNameSpace->SetTextDirty();
				m_pParent->InvalidateControl();
				return;
			}
		}
		else
		{
			m_pParent->FireNameSpaceEntryRedrawn();
			m_pParent->m_pcnsNameSpace->SetTextClean();
			m_pParent->InvalidateControl();
		}

		int nIndex = StringInArray(&m_csaNameSpaceHistory,&csNameSpace,0);
		if (nIndex > 0)
		{
			m_csaNameSpaceHistory.RemoveAt(nIndex);
			m_csaNameSpaceHistory.InsertAt(0, csNameSpace);
		}
	}
	else
	{
		m_pceiInput->SetWindowText(m_csNameSpace);
		m_pParent->FireNameSpaceEntryRedrawn();
		m_pParent->m_pcnsNameSpace->SetTextClean();
		m_pParent->InvalidateControl();
	}


}

LRESULT CNameSpace::OnEditDoneSafe(WPARAM, LPARAM)
{

	CWaitCursor cwcWait;

	if (m_csNameSpace.IsEmpty())
	{
		m_csNameSpace = m_pParent->GetCurrentNamespace();
		if (m_csNameSpace.GetLength() > 0)
		{
			int nIndex = StringInArray(&m_csaNameSpaceHistory,&m_csNameSpace,0);
			if (nIndex < 0)
			{
				m_csaNameSpaceHistory.Add(m_csNameSpace);
			}
		}
	}

	CString csNameSpace;
	CString csNameSpaceTemp;

	CString csText;
	GetWindowText(csText);
	csText.TrimLeft();
	csText.TrimRight();
	SetWindowText((LPCTSTR) csText);

	GetWindowText(csNameSpaceTemp);
	CString csMachine = m_pParent->GetMachineName();

	csNameSpaceTemp.TrimLeft();
	csNameSpaceTemp.TrimRight();

	int nNamespace = csNameSpaceTemp.GetLength();

	if (nNamespace > 3 &&
		csMachine.CompareNoCase(csNameSpaceTemp.Mid(2,csMachine.GetLength())) == 0 &&
		csNameSpaceTemp[csMachine.GetLength() + 2] == '\\')
	{
		csNameSpace = csNameSpaceTemp.Mid(csMachine.GetLength() + 3);
	}
	else if (nNamespace > 4 &&
			csNameSpaceTemp.Left(4).CompareNoCase(_T("\\\\.\\")) == 0)
	{
		csNameSpace = csNameSpaceTemp.Mid(4);
	}
	else
	{
		csNameSpace =  csNameSpaceTemp;
	}

	if (csNameSpace.GetLength() != csNameSpaceTemp.GetLength())
	{
		SetWindowText(csNameSpace);
	}

	if (m_csNameSpace.CompareNoCase(csNameSpace) != 0)
	{
		BOOL bOpened = TRUE;
		if (bOpened)
		{
			int nFound = FindStringExact(-1, csNameSpace);
			if (nFound == CB_ERR)
			{
				int nReturn = InsertString(0,(LPCTSTR) csNameSpace);
				m_csaNameSpaceHistory.Add(csNameSpace);
			}

			m_csNameSpace = csNameSpace;
			m_pParent->m_pcnsNameSpace->SetTextClean();
			m_pParent->InvalidateControl();
		}
		else
		{
			m_pParent->m_pcnsNameSpace->SetTextDirty();
			m_pParent->InvalidateControl();
			m_pParent->m_pcnsNameSpace->SetFocus();
			return 0;

		}
		int nIndex = StringInArray(&m_csaNameSpaceHistory,&csNameSpace,0);
		if (nIndex > 0)
		{
			m_csaNameSpaceHistory.RemoveAt(nIndex);
			m_csaNameSpaceHistory.InsertAt(0, csNameSpace);
		}
		else if (nIndex == -1)
		{
			m_csaNameSpaceHistory.InsertAt(0, csNameSpace);
		}
		if (m_csaNameSpaceHistory.GetSize() == 21)
		{
			m_csaNameSpaceHistory.RemoveAt(20);
		}
	}
	else
	{
		m_pParent->m_pcnsNameSpace->SetTextClean();
		m_pParent->InvalidateControl();
	}


	return 0;
}

LRESULT CNameSpace::OnEditDone(WPARAM wParam, LPARAM)
{

	CWaitCursor cwcWait;

	if (m_csNameSpace.IsEmpty())
	{
		m_csNameSpace = m_pParent->GetCurrentNamespace();
		if (m_csNameSpace.GetLength() > 0)
		{
			int nIndex = StringInArray(&m_csaNameSpaceHistory,&m_csNameSpace,0);
			if (nIndex < 0)
			{
				m_csaNameSpaceHistory.Add(m_csNameSpace);
			}
		}
	}

	CString csNameSpace;
	CString csNameSpaceTemp;

	CString csText;
	GetWindowText(csText);
	csText.TrimLeft();
	csText.TrimRight();
	SetWindowText((LPCTSTR) csText);

	csNameSpaceTemp = csText;

	CString csMachine = m_pParent->GetMachineName();
	int nLength = csNameSpaceTemp.GetLength();

	if (nLength >= csMachine.GetLength() + 2 &&
		csMachine.CompareNoCase(csNameSpaceTemp.Mid(2,csMachine.GetLength())) == 0  &&
		csNameSpaceTemp[csMachine.GetLength() + 2] == '\\')
	{
		csNameSpace = csNameSpaceTemp.Mid(csMachine.GetLength() + 3);
	}
	else if (nLength >= 4 && csNameSpaceTemp.Left(4).CompareNoCase(_T("\\\\.\\")) == 0)
	{
		csNameSpace = csNameSpaceTemp.Mid(4);
	}
	else
	{
		csNameSpace =  csNameSpaceTemp;
	}

	if (csNameSpace.GetLength() != csNameSpaceTemp.GetLength())
	{
		SetWindowText(csNameSpace);
	}

	m_bOpeningNamespace = TRUE;
	BOOL bOpened = m_pParent -> OpenNameSpace(&csNameSpace,TRUE, FALSE, wParam?TRUE:FALSE);
	m_bOpeningNamespace = FALSE;
	if (bOpened)
	{
		int nFound = FindStringExact(-1, csNameSpace);
		if (nFound == CB_ERR)
		{
			int nReturn = InsertString(0,(LPCTSTR) csNameSpace);
			m_csaNameSpaceHistory.Add(csNameSpace);
		}

		m_csNameSpace = csNameSpace;
		m_pParent->m_pcnsNameSpace->SetTextClean();
		m_pParent->InvalidateControl();
	}
	else
	{
		m_pParent->m_pcnsNameSpace->SetTextDirty();
		m_pParent->InvalidateControl();
		m_pParent->m_pcnsNameSpace->SetFocus();
		return 0;

	}
	int nIndex = StringInArray(&m_csaNameSpaceHistory,&csNameSpace,0);
	if (nIndex > 0)
	{
		m_csaNameSpaceHistory.RemoveAt(nIndex);
		m_csaNameSpaceHistory.InsertAt(0, csNameSpace);
	}
	else if (nIndex == -1)
	{
		m_csaNameSpaceHistory.InsertAt(0, csNameSpace);
	}
	if (m_csaNameSpaceHistory.GetSize() == 21)
	{
		m_csaNameSpaceHistory.RemoveAt(20);
	}



	return 0;
}




void CNameSpace::OnCloseup()
{
	CString csText;
	m_csNameSpace;
	m_pceiInput->GetWindowText(csText);
	if (!IsClean())
	{
		m_csDirtyText = csText;
		PostMessage(RESTORE_DIRTY_TEXT,0,0);
	}
}

LRESULT CNameSpace::RestoreDirtyText(WPARAM, LPARAM)
{
	m_pceiInput->SetWindowText(m_csDirtyText);
	m_pceiInput->SetSel
		(m_csDirtyText.GetLength(), m_csDirtyText.GetLength());
	m_csDirtyText.Empty();
	m_pParent->InvalidateControl();
	m_pParent->FireNameSpaceEntryRedrawn();
	return 0;
}

void CNameSpace::OnEditchange()
{

}

void CNameSpace::OnDropdown()
{
	CWaitCursor wait;

	if (m_csNameSpace.IsEmpty())
	{
		m_csNameSpace = m_pParent->GetCurrentNamespace();
		if (m_csNameSpace.GetLength() > 0)
		{
			m_csaNameSpaceHistory.Add(m_csNameSpace);
		}
	}

	int n = GetCount() - 1;

	while (n > -1)
	{
		DeleteString(n);
		n--;
	}

	int i;
	int nNameSpaces = (int) m_csaNameSpaceHistory.GetSize();
	for (i = 0; i < nNameSpaces;i++)
	{
		AddString(m_csaNameSpaceHistory.GetAt(i));
	}

	CString csEINameSpace;
	GetWindowText(csEINameSpace);

	if (csEINameSpace.GetLength() == 0)
	{
		SetWindowText(m_csNameSpace);
	}

	int nFound =
				FindString(-1, csEINameSpace);

	if (nFound !=  CB_ERR)
	{

		SelectString
			( -1, (LPCTSTR) csEINameSpace);

	}

	int x;
	int y;
	m_pParent -> GetControlSize(&x,&y);
	CRect crParent(0,0,x,y);

	int nMax = crParent.Width();

	for (i = 0; i < m_csaNameSpaceHistory.GetSize(); i++)
	{
		int nWidth =
			GetTextLength(&m_csaNameSpaceHistory.GetAt(i));
		nWidth+=10;
		if (nMax < nWidth)
		{
			nMax = nWidth;
		}

	}

	SetDroppedWidth(nMax);

	if (m_csaNameSpaceHistory.GetSize() > 5)
	{
		int nReturn = ModifyStyle( 0, WS_VSCROLL ,  0 );
	}

}

int CNameSpace::StringInArray
(CStringArray *pcsaArray, CString *pcsString, int nIndex)
{
	INT_PTR nSize = pcsaArray->GetSize();

	for (int i = nIndex; i < nSize; i++)
	{
		if (pcsString->CompareNoCase(pcsaArray->GetAt(i)) == 0)
		{
			return i;
		}
	}
	return -1;
}

HBRUSH CNameSpace::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	HBRUSH hbr = CComboBox::OnCtlColor(pDC, pWnd, nCtlColor);

	// TODO: Change any attributes of the DC here
	if (m_bFirst && (nCtlColor == CTLCOLOR_EDIT))
	{
		m_pceiInput->SubclassWindow(pWnd->m_hWnd);
		m_pceiInput->SetLocalParent(this);
		m_pceiInput->ModifyStyle(0,ES_WANTRETURN);
		if (m_pParent->m_bFocusEdit)
		{
			m_pceiInput->SetFocus();
			m_pceiInput->PostMessage(EM_SETSEL,0,-1);
			m_pParent->m_bFocusEdit = FALSE;
		}
		m_bFirst = FALSE;
	}

	if (nCtlColor == CTLCOLOR_EDIT)
	{
		pDC->SetTextColor(m_pceiInput->m_clrText);
		pDC->SetBkColor( m_pceiInput->m_clrBkgnd );	// text bkgnd
		return m_pceiInput->m_brBkgnd;


	}

	// TODO: Return a different brush if the default is not desired
	return hbr;
}

int CNameSpace::GetTextLength(CString *pcsText)
{

	CSize csLength;
	int nReturn;

	CDC *pdc = CWnd::GetDC( );

	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont* pOldFont = pdc -> SelectObject( &(m_pParent -> m_cfFont) );
	csLength = pdc-> GetTextExtent( *pcsText );
	nReturn = csLength.cx;
	pdc -> SelectObject(pOldFont);

	ReleaseDC(pdc);
	return nReturn;

}

void CNameSpace::SetTextClean()
{
	m_pceiInput->SetTextClean();
}

void CNameSpace::SetTextDirty()
{
	m_pceiInput->SetTextDirty();
}

BOOL CNameSpace::IsClean()
{
	return m_pceiInput->IsClean();
}

void CNameSpace::OnSize(UINT nType, int cx, int cy)
{
	CComboBox::OnSize(nType, cx, cy);

	//m_pParent->InvalidateControl();

}

void CNameSpace::OnLButtonDown(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default
	CComboBox::OnLButtonDown(nFlags, point);

}

void CNameSpace::OnLButtonUp(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default
	CComboBox::OnLButtonUp(nFlags, point);

}

BOOL CNameSpace::PreTranslateMessage(MSG* pMsg)
{
	// TODO: Add your specialized code here and/or call the base class

	return CComboBox::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\nsentry.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// NSEntry.h : main header file for NSENTRY.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CNSEntryApp : See NSEntry.cpp for implementation.

class CNSEntryApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\namespacetree.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// NameSpaceTree.cpp : implementation file
//

#include "precomp.h"
#include <OBJIDL.H>
#include <shlobj.h>
#include <afxcmn.h>
#include "wbemidl.h"
#include "resource.h"
#include "NSEntry.h"
#include "NameSpaceTree.h"
#include "BrowseTBC.h"
#include "ToolCWnd.h"
#include "MachineEditInput.h"
#include "BrowseDialogPopup.h"
#include "NSEntryCtl.h"
#include "logindlg.h"
#include "NameSpace.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CNameSpaceTree

CNameSpaceTree::CNameSpaceTree()
{
	m_pParent = NULL;
	m_pcilImageList = NULL;
}

CNameSpaceTree::~CNameSpaceTree()
{

}


BEGIN_MESSAGE_MAP(CNameSpaceTree, CTreeCtrl)
	//{{AFX_MSG_MAP(CNameSpaceTree)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, OnItemexpanding)
	ON_NOTIFY_REFLECT(TVN_SELCHANGING, OnSelchanging)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
	ON_WM_LBUTTONUP()
	ON_NOTIFY_REFLECT(NM_SETFOCUS, OnSetfocus)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNameSpaceTree message handlers



CStringArray *CNameSpaceTree::GetNamespaces(CString *pcsNamespace)
{
	//IWbemLocator *pLocator = m_pParent->GetLocator();
	CStringArray *pcsaNamespaces = new CStringArray;


	IWbemServices *pRoot = NULL;
	if(0 == pcsNamespace->CompareNoCase(m_szRootNamespace) || pcsNamespace->GetLength() <= (m_szRootNamespace.GetLength() + 1))
		pRoot = m_pParent->InitServices(pcsNamespace, FALSE);
	else
	{
		CString szChild = pcsNamespace->Right(pcsNamespace->GetLength() - m_szRootNamespace.GetLength() - 1);
		if(FAILED(OpenNamespace(m_szRootNamespace, szChild, &pRoot)))
			pRoot = NULL;
	}

	if (pRoot == NULL)
	{
		delete pcsaNamespaces;
		return NULL;
	}

	CString csTmp = _T("__namespace");
	CPtrArray *pcpaInstances =
		GetInstances(pRoot, &csTmp, *pcsNamespace);


	for (int i = 0; i < pcpaInstances->GetSize(); i++)
	{
		CString csProp = _T("name");
		IWbemClassObject *pInstance =
			reinterpret_cast<IWbemClassObject *>
				(pcpaInstances->GetAt(i));
		CString csTmp = GetBSTRProperty(pRoot,pInstance,&csProp);
		CString csName = *pcsNamespace + _T("\\") + csTmp;

		pInstance->Release();
		pcsaNamespaces->Add(csName);
	}
	pRoot->Release();
	delete pcpaInstances;
	return pcsaNamespaces;
}

//***************************************************************************
// Function:	GetInstances
// Purpose:		Gets class instances in the database.
//***************************************************************************
CPtrArray *CNameSpaceTree::GetInstances
(IWbemServices *pServices, CString *pcsClass, CString &rcsNamespace)
{
	SCODE sc;
	IEnumWbemClassObject *pIEnumWbemInstObject = NULL;
	IWbemClassObject *pIWbemInstObject = NULL;
 	CPtrArray *pcpaInstances = new CPtrArray;

	long lFlag = 0;

	BSTR bstrTemp = pcsClass -> AllocSysString();
	sc = pServices->CreateInstanceEnum
		(bstrTemp,
		WBEM_FLAG_DEEP | WBEM_FLAG_FORWARD_ONLY, NULL, &pIEnumWbemInstObject);
	::SysFreeString(bstrTemp);
	if(sc != S_OK)
	{
		return pcpaInstances;
	}

	SetEnumInterfaceSecurity(m_szRootNamespace/*rcsNamespace*/,pIEnumWbemInstObject, pServices);

	sc = pIEnumWbemInstObject->Reset();

	ULONG uReturned;

    while (S_OK == pIEnumWbemInstObject->Next(INFINITE, 1, &pIWbemInstObject, &uReturned) )
		{

			pcpaInstances->Add(pIWbemInstObject);
		}

	pIEnumWbemInstObject -> Release();
	return pcpaInstances;

}

CString CNameSpaceTree::GetBSTRProperty
(IWbemServices * pProv, IWbemClassObject * pInst,
 CString *pcsProperty)

{
	SCODE sc;

    VARIANTARG var;
	VariantInit(&var);

	BSTR bstrTemp = pcsProperty -> AllocSysString ( );
    sc = pInst->Get( bstrTemp ,0,&var,NULL,NULL);
	::SysFreeString(bstrTemp);
	if(sc != S_OK)
	{
		return "";
	}

	CString csOut;
	if (var.vt == VT_BSTR)
		csOut = var.bstrVal;

	VariantClear(&var);
	return csOut;
}


/*BOOL CNameSpaceTree::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.style =	WS_CHILD | WS_VISIBLE | CS_DBLCLKS | TVS_LINESATROOT |
				TVS_HASLINES | TVS_HASBUTTONS | TVS_SHOWSELALWAYS ;

	cs.style &= ~TVS_EDITLABELS;
	// cs.style &= ~WS_BORDER;

	return CTreeCtrl::PreCreateWindow(cs);
}*/

BOOL CNameSpaceTree::DisplayNameSpaceInTree
(CString *pcsNamespace,CWnd *pcwndParent)
{
	m_szRootNamespace = *pcsNamespace;

	CWaitCursor wait;

	ClearTree();

	BOOL bExists = m_pParent->OpenNameSpace(pcsNamespace,FALSE,TRUE);

	if (!bExists)
	{
		m_pParent->m_cbdpBrowse.m_cbConnect.EnableWindow(TRUE);
		m_pParent->m_cbdpBrowse.m_cmeiMachine.SetTextDirty();
		return FALSE;
	}

	m_pParent->m_cbdpBrowse.m_cbConnect.EnableWindow(FALSE);

	CString *pcsNamespaceParam;
	pcsNamespaceParam = new CString;
	*pcsNamespaceParam =
			*pcsNamespace;
	CString csLabel = GetNamespaceLabel(pcsNamespace);
	InsertTreeItem(NULL, (LPARAM) pcsNamespaceParam, &csLabel , NameSpaceHasChildren(pcsNamespace));
	return TRUE;
}

void CNameSpaceTree::ClearTree()
{
	HTREEITEM hItem = GetRootItem();

	if (hItem == NULL)
	{
		return;
	}

	CString *pcsNamespace
		= reinterpret_cast<CString *>(GetItemData( hItem ));

	delete pcsNamespace;

	HTREEITEM hChild = GetChildItem(  hItem );
	while (hChild)
	{
		ClearTree(hChild);
		hChild = GetNextSiblingItem(hChild);
	}

	DeleteAllItems();
}

void CNameSpaceTree::ClearTree(HTREEITEM hItem)
{

	CString *pcsNamespace
		= reinterpret_cast<CString *>(GetItemData( hItem ));

	delete pcsNamespace;

	HTREEITEM hChild = GetChildItem(  hItem );
	while (hChild)
	{
		ClearTree(hChild);
		hChild = GetNextSiblingItem(hChild);
	}

}

HTREEITEM CNameSpaceTree::InsertTreeItem
(HTREEITEM hParent, LPARAM lparam, CString *pcsText ,
 BOOL bChildren)
{

	TV_INSERTSTRUCT tvinsert;
	HTREEITEM h1;
	TCHAR *pszText =
		const_cast <TCHAR *> ((LPCTSTR) (*pcsText));

	tvinsert.hParent = hParent;
	tvinsert.hInsertAfter = TVI_LAST;
	tvinsert.item.mask =	TVIF_TEXT | TVIF_SELECTEDIMAGE |
							TVIF_CHILDREN |
							TVIF_PARAM | TVIF_IMAGE;
	tvinsert.item.hItem = NULL;


	tvinsert.item.cchTextMax = _tcslen(pszText) + 1;
	tvinsert.item.cChildren = bChildren? 1 : 0;
	tvinsert.item.lParam = lparam;
	tvinsert.item.iImage = 0;
	tvinsert.item.iSelectedImage = 0;
	tvinsert.item.pszText = pszText;
	h1 =  InsertItem(&tvinsert);


	return h1;
}

void CNameSpaceTree::InitImageList()
{
	CBitmap cbmOpen;
	CBitmap cbmClosed;

	cbmOpen.LoadBitmap(IDB_BITMAPOPEN);
	cbmClosed.LoadBitmap(IDB_BITMAPCLOSED);

	m_pcilImageList = new CImageList();

	m_pcilImageList -> Create (16, 15, TRUE, 2, 0);

	m_pcilImageList -> Add(&cbmClosed,RGB (255,0,0));
	m_pcilImageList -> Add(&cbmOpen,RGB (255,0,0));

		// This image list is maintained by the ctreectrl.
	CImageList *pcilOld  =
		SetImageList (m_pcilImageList,TVSIL_NORMAL);

	delete pcilOld;


}

int CNameSpaceTree::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	lpCreateStruct-> style =	WS_CHILD | WS_VISIBLE | CS_DBLCLKS | TVS_LINESATROOT |
				TVS_HASLINES | TVS_HASBUTTONS | TVS_SHOWSELALWAYS ;

	lpCreateStruct -> style &= ~TVS_EDITLABELS;

	if (CTreeCtrl::OnCreate(lpCreateStruct) == -1)
	{
		return -1;
	}

	InitImageList();

	return 0;
}

void CNameSpaceTree::OnDestroy()
{
	ClearTree();
	CTreeCtrl::OnDestroy();

	delete m_pcilImageList;
}

void CNameSpaceTree::OnItemexpanding(NMHDR* pNMHDR, LRESULT* pResult)
{
	CWaitCursor wait;

	NM_TREEVIEW* pnmtv = (NM_TREEVIEW*)pNMHDR;
	HTREEITEM hItem = pnmtv->itemNew.hItem;

	if (pnmtv ->action == TVE_COLLAPSE ||
		pnmtv -> itemNew.state & TVIS_EXPANDEDONCE)
	{
		*pResult = 0;
		return;
	}

	CString *pcsNamespace =
		reinterpret_cast<CString *>(pnmtv->itemNew.lParam);

	CStringArray *pcsaChildrenNamespaces = GetNamespaces(pcsNamespace);

	if(NULL == pcsaChildrenNamespaces)
	{
		*pResult = 1;
		return;
	}

	if (pcsaChildrenNamespaces->GetSize() == 0)
	{
		delete pcsaChildrenNamespaces;
		TVITEM tvi;
		ZeroMemory(&tvi, sizeof(tvi));
		tvi.mask = TVIF_HANDLE | TVIF_CHILDREN;
		tvi.hItem = hItem;
		SetItem(&tvi);
		return;
	}

	int i;
	for (i = 0; i < pcsaChildrenNamespaces->GetSize(); i++)
	{
		CString *pcsNamespace;
		pcsNamespace = new CString;
		*pcsNamespace =
			pcsaChildrenNamespaces->GetAt(i);
#if 0
		CStringArray *pcsaGrandChildNamespaces =
			GetNamespaces(pcsNamespace);
		int nChildren = (int) pcsaGrandChildNamespaces->GetSize();
		delete pcsaGrandChildNamespaces;
#endif
		CString csLabel = GetNamespaceLabel(pcsNamespace);
		InsertTreeItem
			(hItem, (LPARAM) pcsNamespace, &csLabel , 1/*nChildren > 0*/);

	}

	delete pcsaChildrenNamespaces;

	SortChildren( hItem);
	*pResult = 0;
}

CString CNameSpaceTree::GetNamespaceLabel(CString *pcsNamespace)
{
	int iLastSlash = pcsNamespace->ReverseFind('\\');

	if (iLastSlash == -1)
	{
		return *pcsNamespace;
	}
	else
	{
		return pcsNamespace->
			Right(pcsNamespace->GetLength() - (iLastSlash + 1));
	}
}

BOOL CNameSpaceTree::NameSpaceHasChildren(CString *pcsNamespace)
{
	CStringArray *pcsaChildrenNamespaces = GetNamespaces(pcsNamespace);
	if(!pcsaChildrenNamespaces)
		return FALSE;

	if (pcsaChildrenNamespaces->GetSize() == 0)
	{
		delete pcsaChildrenNamespaces;
		return FALSE;
	}
	else
	{
		delete pcsaChildrenNamespaces;
		return TRUE;
	}


}

void CNameSpaceTree::SetNewStyle(long lStyleMask, BOOL bSetBits)
{
	long		lStyleOld;

	lStyleOld = GetWindowLong(m_hWnd, GWL_STYLE);
	lStyleOld &= ~lStyleMask;

	if (bSetBits)
		lStyleOld |= lStyleMask;

	SetWindowLong(m_hWnd, GWL_STYLE, lStyleOld);
	SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);
}

CString CNameSpaceTree::GetSelectedNamespace()
{
	CString csNamespace;

	HTREEITEM hItem = GetSelectedItem();

	if (!hItem)
	{
		hItem = GetRootItem();

	}

	if (hItem)
	{
		CString *pcsNamespace =
			reinterpret_cast<CString *>(GetItemData(hItem));
		if (pcsNamespace)
		{
			csNamespace = *pcsNamespace;
		}
	}

	return csNamespace;


}

void CNameSpaceTree::OnSelchanging(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here


	CBrowseDialogPopup *pParent =
		reinterpret_cast<CBrowseDialogPopup *>(GetParent());

	pParent->EnableOK(TRUE);

	*pResult = 0;
}

void CNameSpaceTree::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult)
{
	// TODO: Add your control notification handler code here
	UINT uFlags = TVHT_ONITEMBUTTON;
	if (!HitTest( m_cpLeftUp, &uFlags))
	{
		*pResult = 0;
		return;
	}

	CBrowseDialogPopup *pParent =
		reinterpret_cast<CBrowseDialogPopup *>(GetParent());

	pParent->OnOkreally();

	*pResult = 0;
}

void CNameSpaceTree::OnLButtonUp(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	CTreeCtrl::OnLButtonUp(nFlags, point);
	m_cpLeftUp = point;
}

void CNameSpaceTree::OnSetfocus(NMHDR* pNMHDR, LRESULT* pResult)
{
	// TODO: Add your control notification handler code here

	CBrowseDialogPopup* pParent =
			reinterpret_cast<CBrowseDialogPopup *>
			(GetParent( ));

	CString csText;
	m_pParent->m_cbdpBrowse.m_cmeiMachine.GetWindowText(csText);

	pParent-> m_csMachineBeforeLosingFocus = csText;

	if (!pParent->m_cmeiMachine.IsClean())
	{
		CBrowseDialogPopup* pParent =
			reinterpret_cast<CBrowseDialogPopup *>
			(GetParent( ));

		if (GetCount() > 0)
		{
			pParent->m_cmeiMachine.SetTextClean();
			pParent->m_cmeiMachine.SetWindowText(pParent->m_csMachine);
		}
	}

	CButton *pcbOK =
		reinterpret_cast<CButton *>(pParent->GetDlgItem(IDOKREALLY));

	pcbOK->EnableWindow(TRUE);

	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\namespace.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// NameSpace.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNameSpace window

#define CNS_EDITDONE WM_USER + 13
#define RESTORE_DIRTY_TEXT WM_USER + 14

class CNSEntryCtrl;
class CEditInput;
class CBrowseTBC;



class CNameSpace : public CComboBox
{
// Construction
public:
	CNameSpace();
	void SetParent(CNSEntryCtrl *pParent) {m_pParent = pParent;}
	void SetNameSpace(CString *pcsNameSpace)
		{m_csNameSpace = *pcsNameSpace;}
	void SetTextClean();
	void SetTextDirty();
	BOOL IsClean();
	// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNameSpace)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CNameSpace();

	// Generated message map functions
protected:

	CNSEntryCtrl *m_pParent;
	CString m_csNameSpace;
	CEditInput *m_pceiInput;
	BOOL m_bFirst;
	BOOL m_bOpeningNamespace;
	CStringArray m_csaNameSpaceHistory;
	int StringInArray
		(CStringArray *pcsaArray, CString *pcsString, int nIndex);
	int GetTextLength(CString *pcsText);
	CString m_csDirtyText;

	//{{AFX_MSG(CNameSpace)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSelendok();
	afx_msg void OnCloseup();
	afx_msg void OnEditchange();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg LRESULT RestoreDirtyText(WPARAM, LPARAM);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG

	LRESULT OnEditDoneSafe(WPARAM, LPARAM);
public:
	afx_msg void OnDropdown();
	afx_msg LRESULT OnEditDone(WPARAM, LPARAM);
protected:
	DECLARE_MESSAGE_MAP()
	friend class CEditInput;
	friend class CNSEntryCtrl;
	friend class CBrowseTBC;

};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\nsentry1.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "nsentry1.h"

/////////////////////////////////////////////////////////////////////////////
// CNSEntry

IMPLEMENT_DYNCREATE(CNSEntry, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CNSEntry properties

CString CNSEntry::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CNSEntry::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

long CNSEntry::GetMaxDroppedWidth()
{
	long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CNSEntry::SetMaxDroppedWidth(long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

CString CNSEntry::GetFontName()
{
	CString result;
	GetProperty(0x3, VT_BSTR, (void*)&result);
	return result;
}

void CNSEntry::SetFontName(LPCTSTR propVal)
{
	SetProperty(0x3, VT_BSTR, propVal);
}

long CNSEntry::GetFontWidth()
{
	long result;
	GetProperty(0x4, VT_I4, (void*)&result);
	return result;
}

void CNSEntry::SetFontWidth(long propVal)
{
	SetProperty(0x4, VT_I4, propVal);
}

long CNSEntry::GetFontHeight()
{
	long result;
	GetProperty(0x5, VT_I4, (void*)&result);
	return result;
}

void CNSEntry::SetFontHeight(long propVal)
{
	SetProperty(0x5, VT_I4, propVal);
}

long CNSEntry::GetComponentStructure()
{
	long result;
	GetProperty(0x6, VT_I4, (void*)&result);
	return result;
}

void CNSEntry::SetComponentStructure(long propVal)
{
	SetProperty(0x6, VT_I4, propVal);
}

OLE_COLOR CNSEntry::GetBackColor()
{
	OLE_COLOR result;
	GetProperty(DISPID_BACKCOLOR, VT_I4, (void*)&result);
	return result;
}

void CNSEntry::SetBackColor(OLE_COLOR propVal)
{
	SetProperty(DISPID_BACKCOLOR, VT_I4, propVal);
}

CString CNSEntry::Get_NameSpace()
{
	CString result;
	GetProperty(0x0, VT_BSTR, (void*)&result);
	return result;
}

void CNSEntry::Set_NameSpace(LPCTSTR propVal)
{
	SetProperty(0x0, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CNSEntry operations

VARIANT CNSEntry::PopUpBrowseDialog(LPCTSTR bstrNameSpace)
{
	VARIANT result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_VARIANT, (void*)&result, parms,
		bstrNameSpace);
	return result;
}

void CNSEntry::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\namespacetree.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// NameSpaceTree.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CNameSpaceTree window
class CNSEntryCtrl;

class CNameSpaceTree : public CTreeCtrl
{
// Construction
public:
	CNameSpaceTree();
	void SetLocalParent(CNSEntryCtrl *pParent)
		{m_pParent = pParent;}
	BOOL DisplayNameSpaceInTree(CString *pcsNamespace, CWnd *pcwndParent= NULL);
	void SetNewStyle(long lStyleMask, BOOL bSetBits);
	void InitImageList();
	CString GetSelectedNamespace();
	void ClearTree();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNameSpaceTree)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CNameSpaceTree();

	// Generated message map functions
protected:
	CString m_szRootNamespace;
	CNSEntryCtrl *m_pParent;
	CImageList *m_pcilImageList;
	void ClearTree(HTREEITEM hItem);
	CStringArray *GetNamespaces(CString *pcsNamespace);
	CPtrArray *GetInstances
		(IWbemServices *pServices, CString *pcsClass, CString &rcsNamespace);
	CString GetBSTRProperty
		(IWbemServices * pProv, IWbemClassObject * pInst, 
		CString *pcsProperty);
	HTREEITEM InsertTreeItem 
		(HTREEITEM hParent, LPARAM lparam, 
		CString *pcsText , BOOL bChildren);
	CString GetNamespaceLabel(CString *pcsNamespace);
	BOOL NameSpaceHasChildren(CString *pcsNamespace);
	CPoint m_cpLeftUp;
	//{{AFX_MSG(CNameSpaceTree)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnItemexpanding(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelchanging(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnSetfocus(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\nsentry.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// NSEntry.cpp : Implementation of CNSEntryApp and DLL registration.

#include "precomp.h"
#include "NSEntry.h"
#include "CatHelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CNSEntryApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xc3db0bd0, 0x7ec7, 0x11d0, { 0x96, 0xb, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const GUID CDECL BASED_CODE _ctlid =   { 0xc3db0bd3, 0x7ec7, 0x11d0,
           { 0x96, 0xb, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b} };

const CATID CATID_SafeForScripting     =
   {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing  =
   {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
////////////////////////////////////////////////////////////////////////////
// CNSEntryApp::InitInstance - DLL initialization

BOOL CNSEntryApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CNSEntryApp::ExitInstance - DLL termination

int CNSEntryApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	if (FAILED( CreateComponentCategory(CATID_SafeForScripting,
               L"Controls that are safely scriptable") ))
             return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( CreateComponentCategory(
           CATID_SafeForInitializing,
           L"Controls safely initializable from persistent data") ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForScripting) ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForInitializing) ))
         return ResultFromScode(SELFREG_E_CLASS);


	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#endif //_UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\nsentryppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// NSEntryPpg.h : Declaration of the CNSEntryPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CNSEntryPropPage : See NSEntryPpg.cpp.cpp for implementation.

class CNSEntryPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CNSEntryPropPage)
	DECLARE_OLECREATE_EX(CNSEntryPropPage)

// Constructor
public:
	CNSEntryPropPage();

// Dialog Data
	//{{AFX_DATA(CNSEntryPropPage)
	enum { IDD = IDD_PROPPAGE_NSENTRY };
	int		m_nRadioGroup;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CNSEntryPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NSEntry.rc
//
#define IDS_NSENTRY                     1
#define IDD_ABOUTBOX_NSENTRY            1
#define IDB_NSENTRY                     1
#define IDI_ABOUTDLL                    1
#define IDS_NSENTRY_PPG                 2
#define IDS_NSENTRY_PPG_CAPTION         100
#define IDD_PROPPAGE_NSENTRY            100
#define IDB_BITMAPBROWSE                201
#define IDC_RADIOComboAndBrowse         201
#define IDC_RADIOBasicForm              201
#define IDR_TOOLBARNS                   202
#define IDC_RADIOComboOnly              202
#define IDC_RADIOMinimalForm            202
#define IDC_RADIOBrowseOnly             203
#define IDC_RADIOMaximalFormWOCancel    203
#define IDC_RADIOInvisible              204
#define IDC_RADIOMaximalFormWCancel     204
#define IDB_BITMAPSEL                   206
#define IDB_BITMAPBROWSENARROW          206
#define IDD_DIALOGBROWSE                207
#define IDC_TREE1                       208
#define IDC_EDIT1                       209
#define IDB_BITMAPCLOSED                209
#define IDC_BUTTON1                     210
#define IDB_BITMAPOPEN                  210
#define IDD_DIALOGOPENNAMESPACE         211
#define IDC_EDIT2                       211
#define IDOKREALLY                      212
#define IDCANCELREALLY                  213
#define IDC_BUTTONCONNECT               214
#define IDC_USEEXISTING                 215
#define IDC_ENABLEPRIVILEGES            216
#define ID_BUTTONBROWSE                 32768

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        212
#define _APS_NEXT_COMMAND_VALUE         32769
#define _APS_NEXT_CONTROL_VALUE         217
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\nsentryppg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// NSEntryPpg.cpp : Implementation of the CNSEntryPropPage property page class.

#include "precomp.h"
#include "NSEntry.h"
#include "NSEntryPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CNSEntryPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CNSEntryPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CNSEntryPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CNSEntryPropPage, "WBEM.NSPickerPropPage.1",
	0xc3db0bd4, 0x7ec7, 0x11d0, 0x96, 0xb, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// CNSEntryPropPage::CNSEntryPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CNSEntryPropPage

BOOL CNSEntryPropPage::CNSEntryPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_NSENTRY_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CNSEntryPropPage::CNSEntryPropPage - Constructor

CNSEntryPropPage::CNSEntryPropPage() :
	COlePropertyPage(IDD, IDS_NSENTRY_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CNSEntryPropPage)
	m_nRadioGroup = -1;
	//}}AFX_DATA_INIT


}


/////////////////////////////////////////////////////////////////////////////
// CNSEntryPropPage::DoDataExchange - Moves data between page and properties

void CNSEntryPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CNSEntryPropPage)
	DDP_Radio(pDX, IDC_RADIOBasicForm, m_nRadioGroup, _T("ComponentStructure") );
	DDX_Radio(pDX, IDC_RADIOBasicForm, m_nRadioGroup);
	//}}AFX_DATA_MAP

	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CNSEntryPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\nsentry1.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __NSENTRY1_H__
#define __NSENTRY1_H__

// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CNSEntry wrapper class

class CNSEntry : public CWnd
{
protected:
	DECLARE_DYNCREATE(CNSEntry)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xc3db0bd3, 0x7ec7, 0x11d0, { 0x96, 0xb, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetMaxDroppedWidth();
	void SetMaxDroppedWidth(long);
	CString GetFontName();
	void SetFontName(LPCTSTR);
	long GetFontWidth();
	void SetFontWidth(long);
	long GetFontHeight();
	void SetFontHeight(long);
	long GetComponentStructure();
	void SetComponentStructure(long);
	OLE_COLOR GetBackColor();
	void SetBackColor(OLE_COLOR);
	CString Get_NameSpace();
	void Set_NameSpace(LPCTSTR);

// Operations
public:
	VARIANT PopUpBrowseDialog(LPCTSTR bstrNameSpace);
	void AboutBox();
};

#endif // __NSENTRY1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\toolcwnd.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ToolCWnd.cpp : implementation file
//

#include "precomp.h"
#include <shlobj.h>
#include <afxcmn.h>
#include "wbemidl.h"
#include "resource.h"
#include "NSEntry.h"
#include "ToolCWnd.h"
#include "NameSpaceTree.h"
#include "MachineEditInput.h"
#include "BrowseDialogPopup.h"
#include "NSEntryCtl.h"
#include "BrowseTBC.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CToolCWnd

CToolCWnd::CToolCWnd()
{
	m_pParent = NULL;
}

CToolCWnd::~CToolCWnd()
{
}


BEGIN_MESSAGE_MAP(CToolCWnd, CWnd)
	//{{AFX_MSG_MAP(CToolCWnd)
	ON_WM_PAINT()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CToolCWnd message handlers

void CToolCWnd::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	m_pToolBar->Invalidate();
	m_pToolBar->UpdateWindow();

	COLORREF crBack = GetSysColor(COLOR_3DFACE);

	CPen cpLine( PS_SOLID,1, crBack);
	CPen *pcpOld = dc.SelectObject(&cpLine);

	CRect rcBounds;
	GetClientRect(&rcBounds);

	dc.MoveTo(0,0);
	dc.LineTo(rcBounds.Width(),0);
	dc.MoveTo(0,1);
	dc.LineTo(rcBounds.Width(),1);

	dc.SelectObject(pcpOld);

//	m_pParent->FireNameSpaceEntryRedrawn();

	// Do not call CWnd::OnPaint() for painting messages
}


int CToolCWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_pToolBar->SetLocalParent(m_pParent);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\toolcwnd.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ToolCWnd.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CToolCWnd window
class CNSEntryCtrl;
class CBrowseTBC;

class CToolCWnd : public CWnd
{
// Construction
public:
	CToolCWnd();
	void SetLocalParent(CNSEntryCtrl *pParent)
	{m_pParent = pParent;}
	void SetBrowseToolBar(CBrowseTBC *pToolBar)
	{m_pToolBar = pToolBar;}

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CToolCWnd)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CToolCWnd();

	// Generated message map functions
protected:
	CNSEntryCtrl *m_pParent;
	CBrowseTBC *m_pToolBar;
	CToolTipCtrl m_ttip;

	friend class CBrowseTBC;
	friend class CNSEntryCtrl;
	//{{AFX_MSG(CToolCWnd)
	afx_msg void OnPaint();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\security\cathelp.cpp ===
//=--------------------------------------------------------------------------=

// CatHelp.Cpp

//=--------------------------------------------------------------------------=

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "precomp.h"

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\nsentryctl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// NSEntryCtl.h : Declaration of the CNSEntryCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CNSEntryCtrl : See NSEntryCtl.cpp for implementation.

const int IDC_NAMESPACE = 0;
const int IDC_BROWSEBUTTON = 1;

const int BUTTONCX = 23;
const int BUTTONCY = 24;

const int TOOLBARCX = 23 - 1;
const int TOOLBARCY = 24;

#define COLOR_DIRTY_CELL_TEXT  RGB(0, 0, 255) // Dirty text color = BLUE
#define COLOR_CLEAN_CELL_TEXT RGB(0, 0, 0)    // Clean text color = BLACK

struct ParsedObjectPath;

class CNameSpace;
class CToolCWnd;
class CBrowseTBC;
class CBrowseDialogPopup;
class CNameSpaceTree;
class CMachineEditInput;
class CEditInput;

//class COpenNamespaceMsgThread;
#define SETNAMESPACE WM_USER + 34
#define SETNAMESPACETEXT WM_USER + 35
#define INITIALIZE_NAMESPACE 300
#define FOCUSCONNECT WM_USER + 56
#define FOCUSTREE WM_USER + 57
#define FOCUSEDIT WM_USER + 58




class CNSEntryCtrl : public COleControl
{
	DECLARE_DYNCREATE(CNSEntryCtrl)

// Constructor
public:
	CNSEntryCtrl();
	COLORREF GetColor()
		{return TranslateColor(GetBackColor());}
	BOOL TestNameSpace(CString *pcsNameSpace,BOOL bMessage = FALSE);
	CString GetServerName();
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNSEntryCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual BOOL OnDoVerb(LONG iVerb, LPMSG lpMsg, HWND hWndParent, LPCRECT lpRect);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CNSEntryCtrl();
	CString GetCurrentNamespace() {return m_csNameSpace;}
	CString m_csNameSpace;
	DECLARE_OLECREATE_EX(CNSEntryCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CNSEntryCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CNSEntryCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CNSEntryCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CNSEntryCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	afx_msg LRESULT SetNamespace(WPARAM uParam, LPARAM lParam);
	afx_msg LRESULT SetNamespaceTextMsg(WPARAM uParam, LPARAM lParam);
	afx_msg LRESULT InitializeNamespace(WPARAM, LPARAM);
	afx_msg LRESULT FocusEdit(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CNSEntryCtrl)
	afx_msg BSTR GetNameSpace();
	afx_msg void SetNameSpace(LPCTSTR lpszNewValue);
	afx_msg long OpenNamespace(LPCTSTR bstrNamespace, long lNoFireEvent);
	afx_msg void SetNamespaceText(LPCTSTR lpctstrNamespace);
	afx_msg BSTR GetNamespaceText();
	afx_msg long IsTextValid();
	afx_msg void ClearOnLoseFocus(long lClearOnLoseFocus);
	afx_msg void ClearNamespaceText(LPCTSTR lpctstrNamespace);
	afx_msg void SetFocusToEdit();
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CNSEntryCtrl)
	void FireNotifyNameSpaceChanged(LPCTSTR bstrNewNameSpace, BOOL boolValid)
		{FireEvent(eventidNotifyNameSpaceChanged,EVENT_PARAM(VTS_BSTR  VTS_BOOL), bstrNewNameSpace, boolValid);}
	void FireNameSpaceEntryRedrawn()
		{FireEvent(eventidNameSpaceEntryRedrawn,EVENT_PARAM(VTS_NONE));}
	void FireGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
		{FireEvent(eventidGetIWbemServices,EVENT_PARAM(VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT), lpctstrNamespace, pvarUpdatePointer, pvarServices, pvarSC, pvarUserCancel);}
	void FireRequestUIActive()
		{FireEvent(eventidRequestUIActive,EVENT_PARAM(VTS_NONE));}
	void FireChangeFocus(long lGettingFocus)
		{FireEvent(eventidChangeFocus,EVENT_PARAM(VTS_I4), lGettingFocus);}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CNSEntryCtrl)
	dispidNameSpace = 1L,
	dispidOpenNamespace = 2L,
	dispidSetNamespaceText = 3L,
	dispidGetNamespaceText = 4L,
	dispidIsTextValid = 5L,
	dispidClearOnLoseFocus = 6L,
	dispidClearNamespaceText = 7L,
	dispidSetFocusToEdit = 8L,
	eventidNotifyNameSpaceChanged = 1L,
	eventidNameSpaceEntryRedrawn = 2L,
	eventidGetIWbemServices = 3L,
	eventidRequestUIActive = 4L,
	eventidChangeFocus = 5L,
	//}}AFX_DISP_ID
	};
protected:

	//IWbemLocator *m_pLocator;

	//IWbemServices *GetServices() {return m_pServices;}
	//IWbemLocator *GetLocator() {return m_pLocator;}

	long m_lWidth;
	long m_lHeight;

	long m_lClearOnLoseFocus;
	BOOL m_bFocusEdit;

	BOOL m_bSizeSet;
	BOOL m_bChildrenCreated;

	TEXTMETRIC m_tmFont;
	CFont m_cfFont;
	BOOL m_bMetricSet;
	CString m_csFontName;
	long m_nFontHeight;
	long m_nFontWidth;
	long m_nFontWeight;

	BOOL OpenNameSpace(CString *pcsNameSpace,BOOL bMessage = FALSE, BOOL bPredicate = FALSE, BOOL bNewPointer = FALSE);

	IWbemServices *GetIWbemServices(CString &rcsNamespace, BOOL bRetry = TRUE);

	void ReleaseErrorObject(IWbemClassObject *&rpErrorObject);
	void ErrorMsg
		(CString *pcsUserMsg,
		SCODE sc,
		IWbemClassObject *pErrorObject,
		BOOL bLog,
		CString *pcsLogMsg,
		char *szFile,
		int nLine,
		UINT uType = MB_ICONEXCLAMATION);
	void LogMsg
		(CString *pcsLogMsg, char *szFile, int nLine);

	IWbemClassObject *GetClassObject (IWbemServices *pProv,CString *pcsClass);

	//IWbemLocator *InitLocator();
	IWbemServices *  InitServices
		(CString *pcsNameSpace, BOOL bNewPointer);
	SCODE m_sc;
	BOOL m_bUserCancel;

	CSize m_csizeButton;
	void CreateControlFont();
	void InitializeLogFont
		(LOGFONT &rlfFont, CString csName, int nHeight, int nWeight);
	CSize GetTextExtent(CString *pcsText);

	void SetChildControlGeometry();

	CNameSpace *m_pcnsNameSpace;
	CBrowseTBC *m_pctbcBrowse;
	CBitmap m_cbmBrowse;
	CToolCWnd *m_pcwBrowse;
	CBrowseDialogPopup m_cbdpBrowse;
	CRect m_rNameSpace;
	CRect m_rToolBar;
	CRect m_rBrowseButton;

	void CreateToolBar();
	void CreateComboBox();

	ParsedObjectPath *ParseObjectPath(CString *pcsPath);

	void FixUpComboOnPopupOK();
	void FixUpComboOnPopupCancel();

	BOOL m_bNoFireEvent;

	CString GetMachineName();

	CString m_pcsNamespaceToInit;

	CString m_csNamespaceText;

	BOOL ConnectedToMachineP(CString &csMachine);

	int m_cRetryCounter;

private:
	friend class CNameSpace;
	friend class CContainedToolBar;
	friend class CBrowseTBC;
	friend class CBrowseDialogPopup;
	friend class CNameSpaceTree;
	friend class CToolCWnd;
	friend class CMachineEditInput;
	friend class CEditInput;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\nsentry\nsentryctl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// NSEntryCtl.cpp : Implementation of the CNSEntryCtrl OLE control class.

#include "precomp.h"
#include <shlobj.h>
#include <afxcmn.h>
#include <nddeapi.h>
#include <initguid.h>
#include "wbemidl.h"
#include "resource.h"
#include "LoginDlg.h"
#include "NSEntry.h"
#include "NameSpaceTree.h"
#include "MachineEditInput.h"
#include "BrowseDialogPopup.h"
#include "NSEntryCtl.h"
#include "NSEntryPpg.h"
#include "namespace.h"
#include "ToolCWnd.h"
#include "BrowseTBC.h"
#include "EditInput.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include "MsgDlgExterns.h"


#define CCS_NOHILITE            0x00000010L

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//c:\jpow\vcpp42\insttoviewer\debug\insttoviewer.exe


IMPLEMENT_DYNCREATE(CNSEntryCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CNSEntryCtrl, COleControl)
	//{{AFX_MSG_MAP(CNSEntryCtrl)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_DESTROY()
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
	ON_MESSAGE(SETNAMESPACE, SetNamespace )
	ON_MESSAGE(SETNAMESPACETEXT, SetNamespaceTextMsg )
	ON_MESSAGE(INITIALIZE_NAMESPACE, InitializeNamespace)
	ON_MESSAGE(FOCUSEDIT,FocusEdit)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CNSEntryCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CNSEntryCtrl)
	DISP_PROPERTY_EX(CNSEntryCtrl, "NameSpace", GetNameSpace, SetNameSpace, VT_BSTR)
	DISP_FUNCTION(CNSEntryCtrl, "OpenNamespace", OpenNamespace, VT_I4, VTS_BSTR VTS_I4)
	DISP_FUNCTION(CNSEntryCtrl, "SetNamespaceText", SetNamespaceText, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CNSEntryCtrl, "GetNamespaceText", GetNamespaceText, VT_BSTR, VTS_NONE)
	DISP_FUNCTION(CNSEntryCtrl, "IsTextValid", IsTextValid, VT_I4, VTS_NONE)
	DISP_FUNCTION(CNSEntryCtrl, "ClearOnLoseFocus", ClearOnLoseFocus, VT_EMPTY, VTS_I4)
	DISP_FUNCTION(CNSEntryCtrl, "ClearNamespaceText", ClearNamespaceText, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CNSEntryCtrl, "SetFocusToEdit", SetFocusToEdit, VT_EMPTY, VTS_NONE)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CNSEntryCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CNSEntryCtrl, COleControl)
	//{{AFX_EVENT_MAP(CNSEntryCtrl)
	EVENT_CUSTOM("NotifyNameSpaceChanged", FireNotifyNameSpaceChanged, VTS_BSTR  VTS_BOOL)
	EVENT_CUSTOM("NameSpaceEntryRedrawn", FireNameSpaceEntryRedrawn, VTS_NONE)
	EVENT_CUSTOM("GetIWbemServices", FireGetIWbemServices, VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT)
	EVENT_CUSTOM("RequestUIActive", FireRequestUIActive, VTS_NONE)
	EVENT_CUSTOM("ChangeFocus", FireChangeFocus, VTS_I4)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CNSEntryCtrl, 1)
	PROPPAGEID(CNSEntryPropPage::guid)
END_PROPPAGEIDS(CNSEntryCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CNSEntryCtrl, "WBEM.NSPickerCtrl.1",
	0xc3db0bd3, 0x7ec7, 0x11d0, 0x96, 0xb, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CNSEntryCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DNSEntry =
		{ 0xc3db0bd1, 0x7ec7, 0x11d0, { 0x96, 0xb, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const IID BASED_CODE IID_DNSEntryEvents =
		{ 0xc3db0bd2, 0x7ec7, 0x11d0, { 0x96, 0xb, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwNSEntryOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CNSEntryCtrl, IDS_NSENTRY, _dwNSEntryOleMisc)

// ===========================================================================
//
//	Font Height
//
// ===========================================================================
#define CY_FONT 15


// Utility Functions

BOOL FindNoCase(CString &cs1, CString &cs2)
{
	CString csTemp1 = cs1;
	CString csTemp2 = cs2;

	csTemp1.MakeUpper();
	csTemp2.MakeUpper();

	return csTemp1.Find(csTemp2) == 0;

}


/////////////////////////////////////////////////////////////////////////////
// CNSEntryCtrl::CNSEntryCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CNSEntryCtrl

BOOL CNSEntryCtrl::CNSEntryCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to afxRegInsertable.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_NSENTRY,
			IDB_NSENTRY,
			afxRegInsertable | afxRegApartmentThreading,
			_dwNSEntryOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CNSEntryCtrl::CNSEntryCtrl - Constructor

CNSEntryCtrl::CNSEntryCtrl()
{
	InitializeIIDs(&IID_DNSEntry, &IID_DNSEntryEvents);

	m_bChildrenCreated = FALSE;

	m_bMetricSet = FALSE;
	m_bSizeSet = FALSE;
	//m_pLocator = NULL;
	m_pcnsNameSpace = NULL;
	m_pctbcBrowse = NULL;
	m_pcwBrowse = NULL;
	m_sc = S_OK;
	m_bNoFireEvent = FALSE;
	m_csFontName = _T("MS Shell Dlg");
	m_nFontHeight = CY_FONT;
	m_nFontWeight = (short) FW_NORMAL;
	m_lClearOnLoseFocus = TRUE;
	m_bFocusEdit  = FALSE;

}


/////////////////////////////////////////////////////////////////////////////
// CNSEntryCtrl::~CNSEntryCtrl - Destructor

CNSEntryCtrl::~CNSEntryCtrl()
{

}


/////////////////////////////////////////////////////////////////////////////
// CNSEntryCtrl::OnDraw - Drawing function

void CNSEntryCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	if (GetSafeHwnd()) {
		COLORREF dwBackColor = GetSysColor(COLOR_3DFACE);
		CBrush br3DFACE(dwBackColor);
		pdc->FillRect(&rcBounds, &br3DFACE);
	}

	if (!AmbientUserMode( ) && GetSafeHwnd( ))
	{
		// May want to do something fancier, but for now just print
		// text.
//		pdc -> TextOut( rcBounds.left + 10, rcBounds.top + 10, _T("Namespace Entry"));
		return;
	}
	else	// In case an editor does not support ambient modes.
		if (GetSafeHwnd( ) == NULL)
			return;




	// So we can count on fundamental display characteristics.
	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);


/*	if ()
	{
		PostMessage(SETNAMESPACETEXT,0,0);
	}*/

	PostMessage(SETNAMESPACETEXT,0,0);

	m_pcwBrowse->Invalidate();
	m_pcwBrowse->UpdateWindow();
	m_pcnsNameSpace->RedrawWindow();
}


/////////////////////////////////////////////////////////////////////////////
// CNSEntryCtrl::DoPropExchange - Persistence support

void CNSEntryCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);



	// Call PX_ functions for each persistent custom property.

	CString csServer = GetServerName();

	PX_String(pPX, _T("NameSpace"), m_csNameSpace, _T(""));

	if (!m_bSizeSet)
	{
		m_bSizeSet = TRUE;
		int cx, cy;

		GetControlSize(&cx,&cy);

		m_lWidth = cx;
		m_lHeight = cy;

	}



}


/////////////////////////////////////////////////////////////////////////////
// CNSEntryCtrl::OnResetState - Reset control to default state

void CNSEntryCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CNSEntryCtrl::AboutBox - Display an "About" box to the user

void CNSEntryCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_NSENTRY);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CNSEntryCtrl message handlers

BSTR CNSEntryCtrl::GetNameSpace()
{
	m_csNameSpace.TrimLeft();
	m_csNameSpace.TrimRight();
	return m_csNameSpace.AllocSysString();
}

void CNSEntryCtrl::SetNameSpace(LPCTSTR lpszNewValue)
{

	m_pcsNamespaceToInit = lpszNewValue;
	CString csNameSpace = lpszNewValue;

	if (GetSafeHwnd() && AmbientUserMode() && lpszNewValue[0] != '\0')
	{
		m_pcnsNameSpace->SetTextDirty();
		m_pcnsNameSpace->SetWindowText(csNameSpace);
		m_pcnsNameSpace->OnEditDoneSafe(0,0 );

		BOOL bOpened = OpenNameSpace(&csNameSpace,FALSE,FALSE);
		if (bOpened)
		{
			m_pcnsNameSpace->SetTextClean();
		}
	//	m_pcnsNameSpace->SetTextClean();
	//	m_pcnsNameSpace->SetWindowText(csNameSpace);
	//	if (lpszNewValue[0] != '\0')
	//	{
	//		m_pcnsNameSpace->OnEditDoneSafe(0,0 );
	//	}

		SetModifiedFlag();
	}
	else if (GetSafeHwnd() && !AmbientUserMode())
	{
		m_csNameSpace = lpszNewValue;
		SetModifiedFlag();
	}
	else
	{
		m_csNameSpace = lpszNewValue;
	}

}

LRESULT CNSEntryCtrl::SetNamespace(WPARAM uParam, LPARAM lParam)
{
	CString *pcsNamespace = reinterpret_cast<CString *>(lParam);

	m_pcsNamespaceToInit = *pcsNamespace;
	CString csNameSpace = *pcsNamespace;

	if (GetSafeHwnd())
	{
		m_pcnsNameSpace->SetTextClean();
		m_pcnsNameSpace->SetWindowText(csNameSpace);
		if (csNameSpace.GetLength() > 0 )
		{
			m_pcnsNameSpace->OnEditDone(uParam,0 );
		}

		SetModifiedFlag();
	}



	FireNameSpaceEntryRedrawn();

	delete pcsNamespace;

	return 0;

}


// ***************************************************************************
//
// CNSEntryCtrl::OpenNameSpace
//
// Description:
//	  Connect to namespace server, fire an event, and reset the tree state.
//
// Parameters:
//	  CString *pcsNameSpace		Namespace to connect to.
//
// Returns:
//	  BOOL						TRUE if successful; FALSE otherwise.
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
BOOL CNSEntryCtrl::OpenNameSpace
(CString *pcsNameSpace,BOOL , BOOL bPredicate, BOOL bNewPointer /*= FALSE*/)
{
	CWaitCursor cwcWait;

	m_sc = S_OK;

	IWbemServices *pServices = InitServices(pcsNameSpace, bNewPointer);

	if (pServices)
	{

		if(!bPredicate)
		{
			m_csNameSpace = *pcsNameSpace;
			if (m_bNoFireEvent == FALSE)
			{
				FireNotifyNameSpaceChanged(*pcsNameSpace,TRUE);
				FireNameSpaceEntryRedrawn();
			}
		}

		pServices->Release();
		return TRUE;
	}
	else
	{
		if (m_bUserCancel)
		{
			FireNameSpaceEntryRedrawn();
			return FALSE;
		}

		//  (m_sc == S_OK) here if we are not talking to Security.ocx.
		if (m_sc == S_OK)
		{
			CString csUserMsg =
								_T("Cannot open namespace \"") + *pcsNameSpace +
								_T("\".");
			ErrorMsg
					(&csUserMsg, m_sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ );
		}

		FireNameSpaceEntryRedrawn();

		return FALSE;
	}
}

BOOL CNSEntryCtrl::TestNameSpace(CString *pcsNameSpace,BOOL bMessage)
{

	return OpenNameSpace(pcsNameSpace,bMessage,TRUE);

}

void CNSEntryCtrl::ReleaseErrorObject(IWbemClassObject *&rpErrorObject)
{
	if (rpErrorObject)
	{
		rpErrorObject->Release();
		rpErrorObject = NULL;
	}


}

void CNSEntryCtrl::ErrorMsg
(CString *pcsUserMsg, SCODE sc, IWbemClassObject *pErrorObject, BOOL bLog,
 CString *pcsLogMsg, char *szFile, int nLine,UINT uType)
{
	CString csCaption = _T("Namespace Connect Message");
	BOOL bErrorObject = sc != S_OK;
	BSTR bstrTemp1 = csCaption.AllocSysString();
	BSTR bstrTemp2 = pcsUserMsg->AllocSysString();
	DisplayUserMessage
		(bstrTemp1,bstrTemp2,
		sc,bErrorObject,uType);
	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);

	if (bLog)
	{
		LogMsg(pcsLogMsg,  szFile, nLine);

	}

}

void CNSEntryCtrl::LogMsg
(CString *pcsLogMsg, char *szFile, int nLine)
{


}

//***************************************************************************
//
// InitServices
//
// Purpose: Initialized Ole.
//
//***************************************************************************

IWbemServices * CNSEntryCtrl::InitServices
(CString *pcsNameSpace, BOOL bNewPointer)
{
    IWbemServices *pSession = 0;
    IWbemServices *pChild = 0;

	CString csObjectPath;

    // hook up to default namespace
	if (pcsNameSpace == NULL)
	{
		csObjectPath = _T("root\\cimv2");
	}
	else
	{
		csObjectPath = *pcsNameSpace;
	}

    CString csUser = _T("");

	pSession = GetIWbemServices(csObjectPath,bNewPointer);

    return pSession;

}

/*IWbemLocator *CNSEntryCtrl::InitLocator()
{

	IWbemLocator *pLocator = NULL;
	SCODE sc  = CoCreateInstance(CLSID_WbemLocator,
							 0,
							 CLSCTX_INPROC_SERVER,
							 IID_IWbemLocator,
							 (LPVOID *) &pLocator);
	if (sc != S_OK)
	{
			CString csUserMsg =
							_T("Cannot iniitalize the locator ");
			ErrorMsg
				(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 10);
			return 0;
	}

	return pLocator;


}
*/


// ***************************************************************************
//
// CNSEntryCtrl::GetControlFont
//
// Description:
//	  Create the font used by the control and get the font metrics.
//
// Parameters:
//	  NONE
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNSEntryCtrl::CreateControlFont()
{

	if (!m_bMetricSet) // Create the font used by the control.
	{
		CDC *pdc = CWnd::GetDC( );

		pdc -> SetMapMode (MM_TEXT);
		pdc -> SetWindowOrg(0,0);

		LOGFONT lfFont;
		InitializeLogFont
			(lfFont, m_csFontName,m_nFontHeight, m_nFontWeight);

		m_cfFont.CreateFontIndirect(&lfFont);

		CWnd::SetFont ( &m_cfFont , FALSE);
		CFont* pOldFont = pdc -> SelectObject( &m_cfFont );
		pdc->GetTextMetrics(&m_tmFont);
		pdc -> SelectObject(pOldFont);

		m_bMetricSet = TRUE;

		ReleaseDC(pdc);
	}

}

// ***************************************************************************
//
// CNSEntryCtrl::InitializeLogFont
//
// Description:
//	  Fill in LOGFONT structure.
//
// Parameters:
//	  LOGFONT &rlfFont	Structure to fill in.
//	  CString csName	Font name.
//	  int nHeight		Font height.
//	  int nWeight		Font weight.
//
// Returns:
//	  VOID
//
// Globals accessed:
//	  NONE
//
// Globals modified:
//	  NONE
//
// ***************************************************************************
void CNSEntryCtrl::InitializeLogFont
(LOGFONT &rlfFont, CString csName, int nHeight, int nWeight)
{
	{

	_tcscpy(rlfFont.lfFaceName, (LPCTSTR) csName);
	rlfFont.lfWeight = nWeight;
	rlfFont.lfHeight = nHeight;
	rlfFont.lfWidth = 0;
	rlfFont.lfQuality = DEFAULT_QUALITY;
	rlfFont.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
	rlfFont.lfEscapement = 0;
	rlfFont.lfOrientation = 0;
	rlfFont.lfWidth = 0;
	rlfFont.lfItalic = FALSE;
	rlfFont.lfUnderline = FALSE;
	rlfFont.lfStrikeOut = FALSE;
	rlfFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
	rlfFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	}
}

int CNSEntryCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	CreateControlFont(); // Create the font used by the control.


	if (!m_bChildrenCreated)
	{
		m_bChildrenCreated = TRUE;


		SetChildControlGeometry();

		CreateComboBox();
		CreateToolBar();

		InvalidateControl();
		SetModifiedFlag();
	}


	if (m_csNameSpace.GetLength() > 0 && AmbientUserMode())
	{
		CString *pcsNew;
		pcsNew = new CString(m_csNameSpace);
		PostMessage(SETNAMESPACE,0,(LPARAM) pcsNew);
	}

	m_cbdpBrowse.SetLocalParent(this);

	return 0;
}

void CNSEntryCtrl::OnSize(UINT nType, int cx, int cy)
{
	if (!GetSafeHwnd())
	{
		return;
	}

	COleControl::OnSize(nType, cx, cy);
	m_lWidth = cx;
	m_lHeight = cy;
	SetChildControlGeometry();

	m_pcnsNameSpace->MoveWindow(&m_rNameSpace,FALSE);
	m_pcwBrowse->MoveWindow(&m_rBrowseButton,FALSE);

	InvalidateControl();
}


// ***************************************************************************
//
//	CNSEntryCtrl::SetChildControlGeometry
//
//	Description:
//		Set the geometry of the children controls.
//
//	Parameters:
//		void
//
//	Returns:
//		void
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
void CNSEntryCtrl::SetChildControlGeometry()
{

	if (m_pcnsNameSpace && ::IsWindow(m_pcnsNameSpace->m_hWnd))
	{
		m_pcnsNameSpace->ModifyStyle( WS_VSCROLL, 0 ,  0 );
	}

	m_csizeButton.cx = BUTTONCX;
	m_csizeButton.cy = BUTTONCY;

	CRect rRect = CRect(0 ,
						0  ,
						(int) m_lWidth,
						(int) m_lHeight );




	int nNameSpaceX;
	int nNameSpaceY;
	int nNameSPaceXMax;

	int nBrowseButtonX;
	int nBrowseButtonY;

	int nNSButtonSeperation = 3;

	nNameSpaceX = rRect.TopLeft().x;
	nNameSpaceY = rRect.Height() - (rRect.Height() - 3);

	nBrowseButtonX =
		max(nNameSpaceX + nNSButtonSeperation,
				m_lWidth - (m_csizeButton.cx));


	nNameSPaceXMax = nBrowseButtonX - nNSButtonSeperation;

	//nBrowseButtonY = __max(0,m_lHeight - (BUTTONCY + 1));
	nBrowseButtonY = 0;

	m_rNameSpace = CRect(	nNameSpaceX,
							nNameSpaceY,
							nNameSPaceXMax,
							rRect.BottomRight().y + 80);


	m_rBrowseButton = CRect(nBrowseButtonX,
							nBrowseButtonY,
							nBrowseButtonX + BUTTONCX ,
							nBrowseButtonY + BUTTONCY  );


}


void CNSEntryCtrl::OnDestroy()
{

	CString csText;

	if (m_pcnsNameSpace->m_pceiInput->GetSafeHwnd() &&
		m_pcnsNameSpace->m_pceiInput->m_csTextSave.IsEmpty())
	{
		m_pcnsNameSpace->m_pceiInput->GetWindowText(csText);

		m_pcnsNameSpace->m_pceiInput->m_csTextSave = csText;
		m_pcnsNameSpace->m_pceiInput->m_clrTextSave =
			m_pcnsNameSpace->m_pceiInput->m_clrText;
	}

	delete m_pcnsNameSpace;
	m_pcnsNameSpace = NULL;

	delete m_pctbcBrowse;
	m_pctbcBrowse = NULL;

	delete m_pcwBrowse;
	m_pcwBrowse = NULL;


	m_cbmBrowse.DeleteObject();

	COleControl::OnDestroy();

}

void CNSEntryCtrl::CreateToolBar()
{
	m_pcwBrowse = new CToolCWnd;
	m_pcwBrowse->SetLocalParent(this);

	m_pctbcBrowse = new CBrowseTBC;

	m_pcwBrowse->SetBrowseToolBar(m_pctbcBrowse);

	if (m_pcwBrowse->Create
		(NULL, _T("ToolWnd"),
		WS_CHILD  |  WS_VISIBLE,
		m_rBrowseButton, this, IDC_BROWSEBUTTON	) == 0)
	{
				return;
	}



	if(m_pctbcBrowse->Create
		( WS_CHILD | WS_VISIBLE  |
			CCS_NOHILITE |CCS_NODIVIDER,
			m_rBrowseButton,
		m_pcwBrowse, IDC_BROWSEBUTTON) == 0)
	{
		return;
	}



	CSize csNarrow;
	csNarrow.cx = 15;
	csNarrow.cy = 15;
	m_pctbcBrowse->SetBitmapSize(csNarrow);
	csNarrow.cx=23;
	csNarrow.cy=22;
	m_pctbcBrowse->SetButtonSize(csNarrow);

	m_cbmBrowse.LoadBitmap(MAKEINTRESOURCE(IDB_BITMAPBROWSENARROW));

	m_pctbcBrowse->AddBitmap( 1, &m_cbmBrowse);

	TBBUTTON tbInit[1];
	tbInit[0].iBitmap = 0;
	tbInit[0].idCommand = 1;
	tbInit[0].fsState = TBSTATE_ENABLED;
	tbInit[0].fsStyle = TBSTYLE_BUTTON;
	tbInit[0].dwData = NULL;
	tbInit[0].iString = NULL;

	m_pctbcBrowse->AddButtons(1, tbInit);

	CSize csToolBar = m_pctbcBrowse->GetToolBarSize();

	// This is where we want to associate a string with
	// the tool for each button.

	if (m_pcwBrowse->m_ttip.Create(m_pcwBrowse,TTS_ALWAYSTIP))
		{
			m_pcwBrowse->m_ttip.Activate(TRUE);
			m_pcwBrowse->m_pToolBar->SetToolTips(&m_pcwBrowse->m_ttip );
		}

	CRect crToolBar(0,0,23,22);


	m_pcwBrowse->m_ttip.AddTool
		(m_pctbcBrowse,_T("Browse for Namespace"),&crToolBar,1);

	m_pcwBrowse->SetFont ( &m_cfFont , FALSE);
}


void CNSEntryCtrl::CreateComboBox()
{
	m_pcnsNameSpace = new CNameSpace;
	m_pcnsNameSpace->SetParent(this);

	if (m_pcnsNameSpace->Create(WS_CHILD  |
								WS_VISIBLE |
								WS_BORDER |
								ES_WANTRETURN |
								CBS_DROPDOWN |
								WS_VSCROLL |
								CBS_AUTOHSCROLL,
								m_rNameSpace,
								this,
								IDC_NAMESPACE) == 0)
	{
		return;
	}

	m_pcnsNameSpace->SetFont ( &m_cfFont , FALSE);



}

// ***************************************************************************
//
//	CNSEntryCtrl::GetTextExtent
//
//	Description:
//		Get the Extent of a string using the control's font.
//
//	Parameters:
//		CString *		Text
//
//	Returns:
//		CSize			Extent
//
//	Globals accessed:
//		NONE
//
//	Globals modified:
//		NONE
//
// ***************************************************************************
CSize CNSEntryCtrl::GetTextExtent(CString *pcsText)
{

	CSize csExtent;

	CDC *pdc = CWnd::GetDC( );

	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont* pOldFont = pdc -> SelectObject( &(m_cfFont) );
	csExtent = pdc-> GetTextExtent( *pcsText );

	pdc -> SelectObject(pOldFont);

	ReleaseDC(pdc);
	return csExtent;

}



CString CNSEntryCtrl::GetServerName
()
{
	CString csCurrentInput;
	CString csNameSpace;
	if (m_pcnsNameSpace && m_pcnsNameSpace->GetSafeHwnd())
	{
		m_pcnsNameSpace->GetWindowText(csCurrentInput);
		csNameSpace = csCurrentInput;
	}
	else
	{
		csNameSpace = m_csNameSpace;
	}

	CString csReturn;
	CString csTemp = _T("\\\\.\\");

	if ((!FindNoCase(csNameSpace,csTemp))
		//(csNameSpace.Find(_T("\\\\.\\")) != 0)
		&&
		(csNameSpace.GetLength() > 1 &&
			csNameSpace[0] == '\\' &&
			csNameSpace[1] == '\\'))
	{
		csReturn = csNameSpace.Mid(2);
		int iEnd = csReturn.Find('\\');
		if (iEnd > -1)
		{
			return csNameSpace.Left(iEnd + 2);
		}
		else
		{
			return csNameSpace;
		}

	}
	else
	{
		csReturn = _T("\\\\");
		csReturn += GetMachineName();
	}

	return csReturn;

}

CString CNSEntryCtrl::GetMachineName()
{
    static wchar_t ThisMachine[MAX_COMPUTERNAME_LENGTH+1];
    char ThisMachineA[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwSize = sizeof(ThisMachineA);
    GetComputerNameA(ThisMachineA, &dwSize);
    MultiByteToWideChar(CP_ACP, 0, ThisMachineA, -1,
			ThisMachine, dwSize);

    return ThisMachine;
}

BOOL CNSEntryCtrl::ConnectedToMachineP(CString &csMachine)
{
    CString csMatch = csMachine + '\\';
	CString csThisMachine = _T("\\\\");
	csThisMachine += GetMachineName();
	csThisMachine += '\\';

	INT_PTR nHistory = m_pcnsNameSpace->m_csaNameSpaceHistory.GetSize();
	INT_PTR nConnectionsFromDialog = m_cbdpBrowse.m_csaNamespaceConnectionsFromDailog.GetSize();

	if (nHistory == 0 && nConnectionsFromDialog == 0)
	{
		return FALSE;
	}

	int i;

	for (i = 0; i < nHistory; i++)
	{
		CString csHistoryItem =
			m_pcnsNameSpace->m_csaNameSpaceHistory.GetAt(i);
		CString csTemp1 = _T("\\\\.\\");
		CString csTemp2 = _T("root\\");
		if (FindNoCase(csHistoryItem,csTemp1) ||
			FindNoCase(csHistoryItem,csTemp2))
		{
			if (FindNoCase(csMatch,csThisMachine))
			{
				return TRUE;
			}
		}
		else
		{
			if (FindNoCase(csHistoryItem,csMatch))
			{
				return TRUE;
			}
		}

	}

	for (i = 0; i < nConnectionsFromDialog; i++)
	{
		CString csHistoryItem =
			m_cbdpBrowse.m_csaNamespaceConnectionsFromDailog.GetAt(i);
		CString csTemp1 = _T("\\\\.\\");
		CString csTemp2 = _T("root\\");
		if (FindNoCase(csHistoryItem,csTemp1) ||
			FindNoCase(csHistoryItem,csTemp2))
		{
			if (FindNoCase(csMatch,csThisMachine))
			{
				return TRUE;
			}
		}
		else
		{
			if (FindNoCase(csHistoryItem,csMatch))
			{
				return TRUE;
			}
		}

	}

	return FALSE;
}




ParsedObjectPath *CNSEntryCtrl::ParseObjectPath
(CString *pcsPath)
{
	BSTR bStr = pcsPath->AllocSysString();

	CObjectPathParser coppPath;
	ParsedObjectPath *ppopOutput;
	coppPath.Parse(bStr, &ppopOutput);
	SysFreeString(bStr);
	CString csClass = ppopOutput -> m_pClass;
	return ppopOutput;
}

long CNSEntryCtrl::OpenNamespace(LPCTSTR bstrNamespace, long lNoFireEvent)
{
	// TODO: Add your dispatch handler code here
	CString csNamespace = bstrNamespace;
	m_sc = S_OK;
	m_bNoFireEvent = lNoFireEvent;
	SetNameSpace((LPCTSTR)csNamespace);
	m_bNoFireEvent = FALSE;
	FireNameSpaceEntryRedrawn();
	return m_sc;
}

IWbemServices *CNSEntryCtrl::GetIWbemServices(CString &rcsNamespace, BOOL bRetry)
{
	if (bRetry)
	{
		m_cRetryCounter++;
	}
	else
	{
		m_cRetryCounter = 0;
	}

	if (m_cRetryCounter > 1)
	{
		return NULL;
	}

	IUnknown *pServices = NULL;

	BOOL bUpdatePointer= bRetry;

	m_sc = S_OK;
	m_bUserCancel = FALSE;

	VARIANT varUpdatePointer;
	VariantInit(&varUpdatePointer);
	varUpdatePointer.vt = VT_I4;
	if (bUpdatePointer == TRUE)
	{
		varUpdatePointer.lVal = 1;
	}
	else
	{
		varUpdatePointer.lVal = 0;
	}

	VARIANT varService;
	VariantInit(&varService);

	VARIANT varSC;
	VariantInit(&varSC);

	VARIANT varUserCancel;
	VariantInit(&varUserCancel);

	CString csNamespace = rcsNamespace;

	FireGetIWbemServices
		(csNamespace,  &varUpdatePointer,  &varService, &varSC,
		&varUserCancel);

	if (varService.vt == VT_UNKNOWN)
	{
		pServices = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}

	varService.punkVal = NULL;

	VariantClear(&varService);

	if (varSC.vt == VT_I4)
	{
		m_sc = varSC.lVal;
	}
	else
	{
		m_sc = WBEM_E_FAILED;
	}

	VariantClear(&varSC);

	if (varUserCancel.vt == VT_BOOL)
	{
		m_bUserCancel = varUserCancel.boolVal;
	}

	VariantClear(&varUserCancel);

	VariantClear(&varUpdatePointer);

	IWbemServices *pRealServices = NULL;
 	if (SUCCEEDED(m_sc) && !m_bUserCancel && pServices)
	{
		pRealServices = reinterpret_cast<IWbemServices *>(pServices);
		CString csClass = _T("__SystemClass");
		IWbemClassObject *pClass = GetClassObject (pRealServices,&csClass);
		if (!pClass)
		{
			pRealServices = GetIWbemServices(rcsNamespace,TRUE);
		}
		else
		{
			if (pClass)
			{
				pClass->Release();
			}
		}
	}
	// GetInterfaceFromGlobal returns 0x800706ba if the pointer has gone bad.
	else if (m_sc == 0x800706bf && !m_bUserCancel)
	{
		pRealServices = GetIWbemServices(rcsNamespace,TRUE);
	}


	InvalidateControl();
	return pRealServices;
}


LRESULT CNSEntryCtrl::InitializeNamespace(WPARAM, LPARAM)
{
	CString csNameSpace = m_pcsNamespaceToInit;

	m_pcsNamespaceToInit.Empty();

	if (GetSafeHwnd())
	{


		m_pcnsNameSpace->SetTextClean();
		m_pcnsNameSpace->SetWindowText(csNameSpace);
		if (csNameSpace.GetLength() > 0)
		{
			m_pcnsNameSpace->OnEditDone(0,0 );
		}

		SetModifiedFlag();
	}
	return 0;

}

void CNSEntryCtrl::SetNamespaceText(LPCTSTR lpctstrNamespace)
{
	m_csNamespaceText = lpctstrNamespace;
	m_csNamespaceText += _T(" ");
	InvalidateControl();

	if (GetSafeHwnd() && m_pcnsNameSpace && m_pcnsNameSpace->m_pceiInput
		&& m_pcnsNameSpace->m_pceiInput->GetSafeHwnd())
	{
		SetFocusToEdit();
		int i = m_csNamespaceText.GetLength() + 1;
		m_pcnsNameSpace->m_pceiInput->SetSel(i,i,TRUE);
		OnActivateInPlace(TRUE,NULL);
	}
}

LRESULT CNSEntryCtrl::SetNamespaceTextMsg(WPARAM uParam, LPARAM lParam)
{
	if (!m_csNamespaceText.IsEmpty() && m_pcnsNameSpace->m_pceiInput->GetSafeHwnd())
	{
		CString csText = m_csNamespaceText;
		m_csNamespaceText.Empty();
		m_pcnsNameSpace->SetTextDirty();
		m_pcnsNameSpace->m_pceiInput->SetWindowText(csText);
		m_pcnsNameSpace->SetEditSel(csText.GetLength() - 1, csText.GetLength() - 1);
	}

	return 0;

}


BSTR CNSEntryCtrl::GetNamespaceText()
{

	CString csText;

	if (m_pcnsNameSpace->m_pceiInput->m_csTextSave.IsEmpty()
				&& m_pcnsNameSpace->m_pceiInput->GetSafeHwnd())
	{
		m_pcnsNameSpace->m_pceiInput->GetWindowText(csText);
		csText.TrimLeft();
		csText.TrimRight();
		m_pcnsNameSpace->m_pceiInput->SetWindowText((LPCTSTR) csText);
		return csText.AllocSysString();
	}
	else if (m_pcnsNameSpace->m_pceiInput->GetSafeHwnd())
	{

		csText = m_pcnsNameSpace->m_pceiInput->m_csTextSave;
		csText.TrimLeft();
		csText.TrimRight();
		m_pcnsNameSpace->m_pceiInput->SetWindowText((LPCTSTR) csText);
		//return m_pcnsNameSpace->m_pceiInput->m_csTextSave.AllocSysString();
		return csText.AllocSysString();
	}
	else
	{
		return csText.AllocSysString();

	}
}

long CNSEntryCtrl::IsTextValid()
{
	// TODO: Add your dispatch handler code here
	if (m_pcnsNameSpace->m_pceiInput->m_csTextSave.IsEmpty())
	{
		COLORREF cr =
			m_pcnsNameSpace->m_pceiInput->m_clrText;
		return COLOR_CLEAN_CELL_TEXT == cr;
	}

	return COLOR_CLEAN_CELL_TEXT == m_pcnsNameSpace->m_pceiInput->m_clrTextSave;
}

void CNSEntryCtrl::ClearOnLoseFocus(long lClearOnLoseFocus)
{
	// TODO: Add your dispatch handler code here
	m_lClearOnLoseFocus = lClearOnLoseFocus;
}

void CNSEntryCtrl::SetFocusToEdit()
{
	if (m_pcnsNameSpace && m_pcnsNameSpace->m_pceiInput && m_pcnsNameSpace->m_pceiInput->GetSafeHwnd())
	{
		m_pcnsNameSpace->m_pceiInput->SetFocus();
	}
	else
	{
		m_bFocusEdit = TRUE;
	}
}

void CNSEntryCtrl::ClearNamespaceText(LPCTSTR lpctstrNamespace)
{

	// This leaves the namespace in the history.
	CString csNamespace = lpctstrNamespace;

	int nIndex = m_pcnsNameSpace->StringInArray
		(&m_pcnsNameSpace->m_csaNameSpaceHistory,&csNamespace,0);
	if (nIndex == -1)
	{
		m_pcnsNameSpace->m_csaNameSpaceHistory.Add(csNamespace);
	}

	m_pcnsNameSpace->SetWindowText(_T(""));
	m_pcnsNameSpace->m_pceiInput->SetWindowText(_T(""));

}

IWbemClassObject *CNSEntryCtrl::GetClassObject (IWbemServices *pProv,CString *pcsClass)
{
	IWbemClassObject *pClass = NULL;

	BSTR bstrTemp = pcsClass -> AllocSysString();
	SCODE sc =
		pProv->GetObject
			(bstrTemp,0,NULL, &pClass,NULL);
	::SysFreeString(bstrTemp);

	if (!SUCCEEDED(sc))
	{
		return NULL;
	}

	return pClass;
}

BOOL CNSEntryCtrl::OnDoVerb(LONG iVerb, LPMSG lpMsg, HWND hWndParent, LPCRECT lpRect)
{
	// TODO: Add your specialized code here and/or call the base class
	if (iVerb == OLEIVERB_UIACTIVATE && m_pcnsNameSpace->m_pceiInput->GetSafeHwnd())
	{
//		m_pcnsNameSpace->m_pceiInput->SetFocus();
	}
	return COleControl::OnDoVerb(iVerb, lpMsg, hWndParent, lpRect);
}

void CNSEntryCtrl::OnKillFocus(CWnd* pNewWnd)
{
	COleControl::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	FireChangeFocus(0);
}

void CNSEntryCtrl::OnSetFocus(CWnd* pOldWnd)
{
	COleControl::OnSetFocus(pOldWnd);

	FireChangeFocus(1);

	if (m_pcnsNameSpace->m_pceiInput->GetSafeHwnd())
	{
		m_pcnsNameSpace->m_pceiInput->SetFocus();
	}

}

LRESULT CNSEntryCtrl::FocusEdit(WPARAM, LPARAM)
{
	if (m_pcnsNameSpace && m_pcnsNameSpace->m_pceiInput && m_pcnsNameSpace->m_pceiInput->GetSafeHwnd())
	{
		m_pcnsNameSpace->m_pceiInput->SetFocus();
	}
	else
	{
		PostMessage(FOCUSEDIT,0,0);
	}

	return 0;

}

BOOL CNSEntryCtrl::PreTranslateMessage(MSG* lpMsg)
{
BOOL bDidTranslate;

	bDidTranslate = COleControl::PreTranslateMessage(lpMsg);

	if (bDidTranslate)
	{
		return bDidTranslate;
	}

	switch (lpMsg->message)
	{
	case WM_KEYDOWN:
	case WM_KEYUP:

		if (lpMsg->wParam == VK_TAB)
		{
			return FALSE;
		}
		if (lpMsg->wParam == VK_ESCAPE)
		{
		   TCHAR szClass[40];
			CWnd* pWndFocus = GetFocus();
			if (pWndFocus != NULL &&
				IsChild(pWndFocus) &&
				GetClassName(pWndFocus->m_hWnd, szClass, 39) &&
				_tcsicmp(szClass, _T("edit")) == 0)
			{
				pWndFocus->SendMessage(lpMsg->message, lpMsg->wParam, lpMsg->lParam);
				return TRUE;
			}
		 }
		if (lpMsg->wParam == VK_RETURN)
		{
		   TCHAR szClass[40];
			CWnd* pWndFocus = GetFocus();
			if (pWndFocus != NULL &&
				IsChild(pWndFocus) &&
				GetClassName(pWndFocus->m_hWnd, szClass, 39) &&
				_tcsicmp(szClass, _T("edit")) == 0)
			{
				pWndFocus->SendMessage(lpMsg->message, lpMsg->wParam, lpMsg->lParam);
				return TRUE;
			}
		 }
		break;
	}

	return PreTranslateInput (lpMsg);

#if 0
	CWnd* pWndFocus = NULL;
	TCHAR szClass[40];
	szClass[0] = '\0';
	switch (lpMsg->message)
	{
	case WM_KEYDOWN:
	if (lpMsg->wParam == VK_RETURN)
	{
	// Allow combo box edit control to process a CR.
		pWndFocus = GetFocus();
		if (((pWndFocus = GetFocus()) != NULL) &&
			IsChild(pWndFocus) &&
			(pWndFocus->GetStyle() & ES_WANTRETURN) &&
			GetClassName(pWndFocus->m_hWnd, szClass, 39) &&
			(_tcsicmp(szClass, _T("EDIT")) == 0))
		{
			m_pcnsNameSpace->m_pceiInput->SendMessage(WM_KEYDOWN, lpMsg->wParam, lpMsg->lParam);
			return TRUE;
		}
	}
	else if (lpMsg->wParam == VK_LEFT ||
			   lpMsg->wParam == VK_RIGHT ||
			   lpMsg->wParam == VK_NEXT ||
			   lpMsg->wParam == VK_PRIOR ||
			   lpMsg->wParam == VK_HOME ||
			   lpMsg->wParam == VK_END
			   )
		  {
			   TCHAR szClass[40];
				CWnd* pWndFocus = GetFocus();
				if (((pWndFocus = GetFocus()) != NULL) &&
					IsChild(pWndFocus) &&
					GetClassName(pWndFocus->m_hWnd, szClass, 39) &&
					(_tcsicmp(szClass, _T("EDIT")) == 0))
				{
					m_pcnsNameSpace->m_pceiInput->SendMessage(WM_KEYDOWN, lpMsg->wParam, lpMsg->lParam);
					return TRUE;
				}
		   }
		break;
   case WM_KEYUP:
	if (lpMsg->wParam == VK_RETURN)
	{
	// Allow combo box edit control to process a CR.
		pWndFocus = GetFocus();
		if (((pWndFocus = GetFocus()) != NULL) &&
			IsChild(pWndFocus) &&
			(pWndFocus->GetStyle() & ES_WANTRETURN) &&
			GetClassName(pWndFocus->m_hWnd, szClass, 39) &&
			(_tcsicmp(szClass, _T("EDIT")) == 0))
		{
			m_pcnsNameSpace->m_pceiInput->SendMessage(WM_KEYUP, lpMsg->wParam, lpMsg->lParam);
			return TRUE;
		}
	}
	else if (lpMsg->wParam == VK_LEFT ||
			   lpMsg->wParam == VK_RIGHT ||
			   lpMsg->wParam == VK_NEXT ||
			   lpMsg->wParam == VK_PRIOR ||
			   lpMsg->wParam == VK_HOME ||
			   lpMsg->wParam == VK_END
			   )
	  {
		   TCHAR szClass[40];
			CWnd* pWndFocus = GetFocus();
			if (((pWndFocus = GetFocus()) != NULL) &&
				IsChild(pWndFocus) &&
				GetClassName(pWndFocus->m_hWnd, szClass, 39) &&
				(_tcsicmp(szClass, _T("EDIT")) == 0))
			{
				m_pcnsNameSpace->m_pceiInput->SendMessage(WM_KEYUP, lpMsg->wParam, lpMsg->lParam);
				return TRUE;
			}
	   }
      break;

	}
#endif



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\security\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_STDAFX_H__9C3497DA_ED98_11D0_9647_00C04FD9B15B__INCLUDED_)
#define AFX_STDAFX_H__9C3497DA_ED98_11D0_9647_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9C3497DA_ED98_11D0_9647_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\security\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Security.rc
//
#define IDS_SECURITY                    1
#define IDD_ABOUTBOX_SECURITY           1
#define IDB_SECURITY                    1
#define IDI_ABOUTDLL                    1
#define IDS_SECURITY_PPG                2
#define IDS_SECURITY_PPG_CAPTION        200
#define IDD_PROPPAGE_SECURITY           200
#define IDB_SECURITYEDIT                202

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\security\security.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SECURITY_H__9C3497DC_ED98_11D0_9647_00C04FD9B15B__INCLUDED_)
#define AFX_SECURITY_H__9C3497DC_ED98_11D0_9647_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Security.h : main header file for SECURITY.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSecurityApp : See Security.cpp for implementation.

class CSecurityApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SECURITY_H__9C3497DC_ED98_11D0_9647_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\security\security.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Security.cpp : Implementation of CSecurityApp and DLL registration.

#include "precomp.h"
#include "Security.h"
#include "CatHelp.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CSecurityApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x9c3497d3, 0xed98, 0x11d0, { 0x96, 0x47, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const GUID CDECL BASED_CODE _ctlid =   { 0x9c3497d6, 0xed98, 0x11d0,
           { 0x96, 0x47, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b} };

const CATID CATID_SafeForScripting     =
   {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing  =
   {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};

////////////////////////////////////////////////////////////////////////////
// CSecurityApp::InitInstance - DLL initialization

BOOL CSecurityApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CSecurityApp::ExitInstance - DLL termination

int CSecurityApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	if (FAILED( CreateComponentCategory(CATID_SafeForScripting,
               L"Controls that are safely scriptable") ))
             return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( CreateComponentCategory(
           CATID_SafeForInitializing,
           L"Controls safely initializable from persistent data") ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForScripting) ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForInitializing) ))
         return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\cathelp.cpp ===
//=--------------------------------------------------------------------------=

// CatHelp.Cpp

//=--------------------------------------------------------------------------=

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "precomp.h"

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\security\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\security\securityctl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SECURITYCTL_H__9C3497E4_ED98_11D0_9647_00C04FD9B15B__INCLUDED_)
#define AFX_SECURITYCTL_H__9C3497E4_ED98_11D0_9647_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// SecurityCtl.h : Declaration of the CSecurityCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CSecurityCtrl : See SecurityCtl.cpp for implementation.

class CSecurityCtrl : public COleControl
{
	DECLARE_DYNCREATE(CSecurityCtrl)

// Constructor
public:
	CSecurityCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSecurityCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void OnFinalRelease();
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void OnDrawMetafile(CDC* pDC, const CRect& rcBounds);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CSecurityCtrl();
	CString m_csLoginComponent;
	DECLARE_OLECREATE_EX(CSecurityCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CSecurityCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CSecurityCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CSecurityCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CSecurityCtrl)
	afx_msg void OnDestroy();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnMove(int x, int y);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CSecurityCtrl)
	afx_msg BSTR GetLoginComponent();
	afx_msg void SetLoginComponent(LPCTSTR lpszNewValue);
	afx_msg void GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdateNamespace, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);
	afx_msg void PageUnloading();
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CSecurityCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CSecurityCtrl)
	dispidLoginComponent = 1L,
	dispidGetIWbemServices = 2L,
	dispidPageUnloading = 3L,
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SECURITYCTL_H__9C3497E4_ED98_11D0_9647_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\ocx\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

############################################################################
# Common Options to all ActiveXSuite OCXs
############################################################################
386_STDCALL=0

TARGETEXT=ocx
TARGETPATH=obj
TARGETTYPE=DYNLINK

C_DEFINES=$(C_DEFINES) /DSMSBUILD

USER_C_FLAGS=/EHa
MSC_OPTIMIZATION=/Ob2
DLLENTRY=_DllMainCRTStartup

USE_MSVCRT=1
USE_MFCVER=42
USE_MFCUNICODE=1
USE_MFC=1
PLATFORM_MFC_VER=0x0600

TARGETLIBS= $(TARGETLIBS) \
	$(ACTIVEXCONTROLS)\MFC60Hack\mfc42u.lib

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(STDLIBRARY_INC); \
	$(WMIIDL_INC); \
	$(ACTIVEX_WBEMUTIL_INC); \
	$(ACTIVEX_WBEMLOGINDLG_INC); \
	$(ARTWORK)

# The TARGETLIBS macro specifies additional libraries to link against your target
# image. Each library path specification should contain an asterisk (*)
# where the machine-specific subdirectory name should go.
TARGETLIBS=$(TARGETLIBS) \
	$(WMIIDL_LIB) \
	$(WBEMINT_LIB) \
	$(STDLIBRARY_LIB) \
	$(ACTIVEX_WBEMUTIL_LIB) \
	$(ACTIVEX_WBEMLOGINDLG_LIB) \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\gdi32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\version.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\mpr.lib\
	$(SDK_LIB_PATH)\odbccp32.lib\
	$(SDK_LIB_PATH)\vccomsup.lib\
	$(SDK_LIB_PATH)\comctl32.lib\
	$(SDK_LIB_PATH)\shell32.lib\
	$(SDK_LIB_PATH)\rpcrt4.lib \
	$(SDK_LIB_PATH)\Urlmon.lib \
	$(SDK_LIB_PATH)\comdlg32.lib \
	$(SDK_LIB_PATH)\htmlhelp.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\security\securityctl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// SecurityCtl.cpp : Implementation of the CSecurityCtrl ActiveX Control class.

#include "precomp.h"
#include <nddeapi.h>
#include <initguid.h>
#include <afxcmn.h>
#include "resource.h"
#include "wbemidl.h"
#include "LoginDlg.h"
#include "Security.h"
#include "SecurityCtl.h"
#include "SecurityPpg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CSecurityCtrl, COleControl)

#define DEFAULT_BACKGROUND_COLOR RGB(0xff, 0xff, 192)  // Yellow background color

/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CSecurityCtrl, COleControl)
	//{{AFX_MSG_MAP(CSecurityCtrl)
	ON_WM_DESTROY()
	ON_WM_ERASEBKGND()
	ON_WM_MOVE()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CSecurityCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CSecurityCtrl)
	DISP_PROPERTY_EX(CSecurityCtrl, "LoginComponent", GetLoginComponent, SetLoginComponent, VT_BSTR)
	DISP_FUNCTION(CSecurityCtrl, "GetIWbemServices", GetIWbemServices, VT_EMPTY, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	DISP_FUNCTION(CSecurityCtrl, "PageUnloading", PageUnloading, VT_EMPTY, VTS_NONE)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CSecurityCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CSecurityCtrl, COleControl)
	//{{AFX_EVENT_MAP(CSecurityCtrl)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CSecurityCtrl, 1)
	PROPPAGEID(CSecurityPropPage::guid)
END_PROPPAGEIDS(CSecurityCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CSecurityCtrl, "WBEM.LoginCtrl.1",
	0x9c3497d6, 0xed98, 0x11d0, 0x96, 0x47, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CSecurityCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DSecurity =
		{ 0x9c3497d4, 0xed98, 0x11d0, { 0x96, 0x47, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const IID BASED_CODE IID_DSecurityEvents =
		{ 0x9c3497d5, 0xed98, 0x11d0, { 0x96, 0x47, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwSecurityOleMisc =
	OLEMISC_INVISIBLEATRUNTIME |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;


IMPLEMENT_OLECTLTYPE(CSecurityCtrl, IDS_SECURITY, _dwSecurityOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CSecurityCtrl::CSecurityCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CSecurityCtrl

BOOL CSecurityCtrl::CSecurityCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to afxRegInsertable.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_SECURITY,
			IDB_SECURITY,
			afxRegInsertable | afxRegApartmentThreading,
			_dwSecurityOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CSecurityCtrl::CSecurityCtrl - Constructor

CSecurityCtrl::CSecurityCtrl()
{
	InitializeIIDs(&IID_DSecurity, &IID_DSecurityEvents);

	DllAddRef();
	// TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CSecurityCtrl::~CSecurityCtrl - Destructor

CSecurityCtrl::~CSecurityCtrl()
{

	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CSecurityCtrl::OnDraw - Drawing function

void CSecurityCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
		// So we can count on fundamental display characteristics.

	CBitmap bitmap;
	BITMAP  bmp;
	CPictureHolder picHolder;
	CRect rcSrcBounds;

	// Load clock bitmap
	bitmap.LoadBitmap(IDB_SECURITYEDIT);
	bitmap.GetObject(sizeof(BITMAP), &bmp);
	rcSrcBounds.right = bmp.bmWidth;
	rcSrcBounds.bottom = bmp.bmHeight;

	// Create picture and render
	picHolder.CreateFromBitmap((HBITMAP)bitmap.m_hObject, NULL, FALSE);
	picHolder.Render(pdc, rcBounds, rcSrcBounds);

}


/////////////////////////////////////////////////////////////////////////////
// CSecurityCtrl::DoPropExchange - Persistence support

void CSecurityCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.
	PX_String(pPX, _T("LoginComponent"), m_csLoginComponent, _T("ActiveXSuite"));
}


/////////////////////////////////////////////////////////////////////////////
// CSecurityCtrl::OnResetState - Reset control to default state

void CSecurityCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CSecurityCtrl::AboutBox - Display an "About" box to the user

void CSecurityCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_SECURITY);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CSecurityCtrl message handlers

void CSecurityCtrl::GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdateNamespace, VARIANT FAR* pvarService, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
	CString csNamespace = lpctstrNamespace;

	IWbemServices *pServices = NULL;
	BOOL bInvalidateMachine = FALSE;

	BOOL bUpdateService;

	if (pvarUpdateNamespace->vt == VT_I4 && pvarUpdateNamespace->lVal == 1)
	{
		bUpdateService = TRUE;
	}
	else
	{
		bUpdateService = FALSE;
	}

	SCODE sc;

#if 0
	LPOLECLIENTSITE pocs = GetClientSite();

	pocs->GetContainer(&pContainer);
#endif
	HWND hwnd = NULL;
	HWND hWndTop = NULL;
	IOleInPlaceSite *pInPlaceSite = NULL;
	if (SUCCEEDED(m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (LPVOID *)&m_pInPlaceSite)))
	{
		RECT rcClip;
		if (SUCCEEDED(m_pInPlaceSite->GetWindowContext(&m_pInPlaceFrame, &m_pInPlaceDoc, &m_rcPos, &rcClip, &m_frameInfo)))
		{
		}

		m_pInPlaceSite->GetWindow(&hwnd);
		do
		{
			hWndTop = hwnd;
			hwnd = ::GetParent(hwnd);
		}
		while (hwnd != NULL);
//		pInPlaceSite->Release();

	}

	PreModalDialog(hWndTop);

	BSTR bstrTemp2 = csNamespace.AllocSysString();
	BSTR bstrTemp3 = m_csLoginComponent.AllocSysString();

	sc = ::GetServicesWithLogonUI
		(hWndTop, bstrTemp2,
		bUpdateService,
		pServices,
		bstrTemp3);

	::SysFreeString(bstrTemp2);
	::SysFreeString(bstrTemp3);

	PostModalDialog(hWndTop);

	VariantClear(pvarService);
	VariantInit(pvarService);
	pvarService->vt = VT_UNKNOWN;
	pvarService->punkVal = reinterpret_cast<LPUNKNOWN>(pServices);

	VariantClear(pvarSC);
	VariantInit(pvarSC);
	pvarSC->vt = VT_I4;
	pvarSC->lVal = sc;

	VariantClear(pvarUserCancel);
	VariantInit(pvarUserCancel);
	pvarUserCancel->vt = VT_BOOL;
	pvarUserCancel->boolVal = (E_ABORT == sc);
}

void CSecurityCtrl::OnDestroy()
{
	COleControl::OnDestroy();
}

void CSecurityCtrl::PageUnloading()
{
	// TODO: Add your dispatch handler code here
	ClearIWbemServices();
}



BSTR CSecurityCtrl::GetLoginComponent()
{
	// Default the returned string to the m_csLoginComponent
	CString sz(m_csLoginComponent);

	// Get key to WMI information in registry
	HKEY hkeyWMI;
	LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
				_T("SOFTWARE\\Microsoft\\WBEM"),
				0,
				KEY_READ | KEY_QUERY_VALUE,
				&hkeyWMI);

	if (lResult == ERROR_SUCCESS)
	{
		// Get Core build number from registry
		TCHAR szCoreBuild[1024];
		DWORD cbCoreBuild = sizeof(szCoreBuild);
		LONG lCoreResult;
		DWORD dwCoreType;
		lCoreResult = RegQueryValueEx(hkeyWMI, _T("Build"), NULL,
			&dwCoreType, (LPBYTE)szCoreBuild, &cbCoreBuild);
		BOOL bCoreOk = (ERROR_SUCCESS == lCoreResult && (REG_SZ == dwCoreType || REG_EXPAND_SZ == dwCoreType));

		// Get SDK build number from registry
		TCHAR szSDKBuild[1024];
		DWORD cbSDKBuild = sizeof(szSDKBuild);
		LONG lSDKResult;
		DWORD dwSDKType;
		lSDKResult = RegQueryValueEx(hkeyWMI, _T("SDK Build"), NULL,
			&dwSDKType, (LPBYTE)szSDKBuild, &cbSDKBuild);
		BOOL bSDKOk = (ERROR_SUCCESS == lSDKResult && (REG_SZ == dwSDKType || REG_EXPAND_SZ == dwSDKType));

		// Reformat the string to return with the core and SDK build numbers
		// NOTE: "Core_Build" and "SDK_Build" are not a localizable strings.
		// They do not (or should not be displayed to the end user)
		if(bCoreOk && bSDKOk)
			sz.Format(_T("%s (Core_Build=%s SDK_Build=%s)"), (LPCTSTR)m_csLoginComponent, szCoreBuild, szSDKBuild);
		else if(bCoreOk)
			sz.Format(_T("%s (Core_Build=%s)"), (LPCTSTR)m_csLoginComponent, szCoreBuild);
		else if(bSDKOk)
			sz.Format(_T("%s (SDK_Build=%s)"), (LPCTSTR)m_csLoginComponent, szSDKBuild);

		RegCloseKey(hkeyWMI);
	}
	return sz.AllocSysString();
}

void CSecurityCtrl::SetLoginComponent(LPCTSTR lpszNewValue)
{
	m_csLoginComponent = lpszNewValue;

	SetModifiedFlag();
}

void CSecurityCtrl::OnFinalRelease()
{
	// TODO: Add your specialized code here and/or call the base class
	DllRelease();
	COleControl::OnFinalRelease();
}

BOOL CSecurityCtrl::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Add your specialized code here and/or call the base class

	return COleControl::PreCreateWindow(cs);
}

BOOL CSecurityCtrl::OnEraseBkgnd(CDC* pDC)
{
	// TODO: Add your message handler code here and/or call default
	return TRUE;
}

void CSecurityCtrl::OnMove(int x, int y)
{
	COleControl::OnMove(x, y);

	// TODO: Add your message handler code here
	InvalidateControl();
}

void CSecurityCtrl::OnSize(UINT nType, int cx, int cy)
{
	COleControl::OnSize(nType, cx, cy);

	// TODO: Add your message handler code here
	InvalidateControl();
}

void CSecurityCtrl::OnDrawMetafile(CDC* pDC, const CRect& rcBounds)
{
	// TODO: Add your specialized code here and/or call the base class

	COleControl::OnDrawMetafile(pDC, rcBounds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\security\securityppg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// SecurityPpg.cpp : Implementation of the CSecurityPropPage property page class.

#include "precomp.h"
#include "Security.h"
#include "SecurityPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CSecurityPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CSecurityPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CSecurityPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CSecurityPropPage, "WBEM.LoginPropPage.1",
	0x9c3497d7, 0xed98, 0x11d0, 0x96, 0x47, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// CSecurityPropPage::CSecurityPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CSecurityPropPage

BOOL CSecurityPropPage::CSecurityPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_SECURITY_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CSecurityPropPage::CSecurityPropPage - Constructor

CSecurityPropPage::CSecurityPropPage() :
	COlePropertyPage(IDD, IDS_SECURITY_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CSecurityPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CSecurityPropPage::DoDataExchange - Moves data between page and properties

void CSecurityPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CSecurityPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CSecurityPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\security\securityppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SECURITYPPG_H__9C3497E6_ED98_11D0_9647_00C04FD9B15B__INCLUDED_)
#define AFX_SECURITYPPG_H__9C3497E6_ED98_11D0_9647_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// SecurityPpg.h : Declaration of the CSecurityPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CSecurityPropPage : See SecurityPpg.cpp.cpp for implementation.

class CSecurityPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CSecurityPropPage)
	DECLARE_OLECREATE_EX(CSecurityPropPage)

// Constructor
public:
	CSecurityPropPage();

// Dialog Data
	//{{AFX_DATA(CSecurityPropPage)
	enum { IDD = IDD_PROPPAGE_SECURITY };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CSecurityPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SECURITYPPG_H__9C3497E6_ED98_11D0_9647_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\dlgexecquery.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// DlgExecQuery.cpp : implementation file
//

#include "precomp.h"
#include "hmmv.h"
#include "hmmvctl.h"
#include <wbemcli.h>
#include "DlgExecQuery.h"
#include "path.h"
#include "hmmverr.h"
#include "htmlhelp.h"
#include "htmtopics.h"
#include "WbemRegistry.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define QUERY_TIMEOUT 10000


IWbemClassObject *CreateSimpleClass(IWbemServices * pProv, CString *pcsNewClass, CString *pcsParentClass, int &nError, CString &csError );


CTripleStringArray::CTripleStringArray()
{

}


CTripleStringArray::~CTripleStringArray()
{
}


void CTripleStringArray::SetAt(int iElement, LPCTSTR pszQueryName, LPCTSTR pszQueryString, LPCTSTR pszQueryLang)
{
	m_saQueryName.SetAt(iElement, pszQueryName);
	m_saQueryString.SetAt(iElement, pszQueryString);
	m_saQueryLang.SetAt(iElement, pszQueryLang);
}


void CTripleStringArray::GetAt(int iElement, CString& sQueryName, CString& sQueryString, CString& sQueryLang)
{
	sQueryName = m_saQueryName.GetAt(iElement);
	sQueryString = m_saQueryString.GetAt(iElement);
	sQueryLang = m_saQueryLang.GetAt(iElement);
}

void CTripleStringArray::Add(LPCTSTR pszQueryName, LPCTSTR pszQueryString, LPCTSTR pszQueryLang)
{
	m_saQueryName.Add(pszQueryName);
	m_saQueryString.Add(pszQueryString);
	m_saQueryLang.Add(pszQueryLang);
}



int CTripleStringArray::FindQueryName(LPCTSTR pszQueryName)
{
	CString s;
	INT_PTR nElements = GetSize();
	for (int iElement = 0; iElement < nElements; ++iElement) {
		s = GetQueryName(iElement);
		if (s.CompareNoCase(pszQueryName) == 0) {
			return iElement;
		}
	}
	return -1;
}

void CTripleStringArray::RemoveAt(int iElement)
{
	m_saQueryName.RemoveAt(iElement);
	m_saQueryString.RemoveAt(iElement);
	m_saQueryLang.RemoveAt(iElement);
}





/////////////////////////////////////////////////////////////////////////////
// CDlgExecQuery dialog





CDlgExecQuery::CDlgExecQuery(CWBEMViewContainerCtrl* phmmv, CWnd* pParent /*=NULL*/)
: CDialog(CDlgExecQuery::IDD, pParent)
{
	m_phmmv = phmmv;
	m_psel = new CSelection(phmmv);

	SCODE sc = GetQueryList();

	ASSERT(SUCCEEDED(sc));


	//{{AFX_DATA_INIT(CDlgExecQuery)
	//}}AFX_DATA_INIT
}


CDlgExecQuery::~CDlgExecQuery()
{
	delete m_psel;
}

void CDlgExecQuery::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgExecQuery)
	DDX_Control(pDX, IDC_QUERY_LIST, m_lbQueryName);
	DDX_Control(pDX, IDC_EDIT_QUERY_NAME, m_edtQueryName);
	DDX_Control(pDX, IDC_EDIT_QUERY_STRING, m_edtQueryString);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgExecQuery, CDialog)
	//{{AFX_MSG_MAP(CDlgExecQuery)
	ON_BN_CLICKED(IDC_REMOVE_QUERY, OnRemoveQuery)
	ON_BN_CLICKED(IDC_SAVE_QUERY, OnSaveQuery)
	ON_BN_CLICKED(IDC_CLOSE, OnClose)
	ON_LBN_SELCHANGE(IDC_QUERY_LIST, OnSelchangeQueryList)
	ON_LBN_DBLCLK(IDC_QUERY_LIST, OnDblclkQueryList)
	ON_EN_CHANGE(IDC_EDIT_QUERY_NAME, OnChangeEditQueryName)
	ON_EN_CHANGE(IDC_EDIT_QUERY_STRING, OnChangeEditQueryString)
	ON_BN_CLICKED(IDC_HELPBTN, OnHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgExecQuery message handlers


// Use this function to get the query name from the edit controls
// This will trim whitespace before returning.
CString CDlgExecQuery::GetQueryName()
{
	CString sz;
	m_edtQueryName.GetWindowText(sz);
	sz.TrimLeft();
	sz.TrimRight();
	return sz;
}

void CDlgExecQuery::OnOK()
{
	if(GetDlgItem(IDC_SAVE_QUERY)->IsWindowEnabled() && GetQueryName().GetLength() > 0)
	{
		int nRet = MessageBox(_T("Do you want to save the query before executing?"), _T("Save Query Before Execute"), MB_YESNOCANCEL);
		switch(nRet)
		{
		case IDYES:
			OnSaveQuery();
			break;
		case IDNO:
			break;
		case IDCANCEL:
			return;
		}
	}
	// TODO: Add extra validation here
	m_sQueryName = GetQueryName();
	m_edtQueryString.GetWindowText(m_sQueryString);

	m_sQueryString.Replace(_T("\r\n"), _T(" "));
	m_sQueryString.Replace(_T("\n\r"), _T(" "));
	m_sQueryString.Replace(_T("\r"), _T(" "));
	m_sQueryString.Replace(_T("\n"), _T(" "));

	CDialog::OnOK();
}

void CDlgExecQuery::OnCancel()
{
	OnClose();
}


BOOL CDlgExecQuery::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO: Add extra initialization here
	INT_PTR nEntries = m_tsa.GetSize();
	for (int iEntry = 0; iEntry < nEntries; ++iEntry) {
		m_lbQueryName.AddString(m_tsa.GetQueryName(iEntry));
	}

	CWnd* pwndButton = GetDlgItem(IDOK);
	pwndButton->EnableWindow(FALSE);

	pwndButton = GetDlgItem(IDC_REMOVE_QUERY);
	pwndButton->EnableWindow(FALSE);


	pwndButton = GetDlgItem(IDC_SAVE_QUERY);
	pwndButton->EnableWindow(FALSE);

	m_edtQueryName.LimitText(63);
	m_edtQueryString.LimitText(1023);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}




SCODE CDlgExecQuery::GetQueryList()
{

	SCODE sc;


	// Find all the associations that reference the current object.
	CString sQuery;
	sQuery = _T("select * from Win32_wmiQuery");

	IEnumWbemClassObject* pEnum = NULL;
	CBSTR bsQuery(sQuery);
	CBSTR bsQueryLang(_T("WQL"));

	CString sNameSpace = m_phmmv->GetNameSpace();
	sc = m_psel->SetNamespace(sNameSpace);
	if (FAILED(sc)) {
		ASSERT(FALSE);
		return E_FAIL;
	}





	IWbemServices* psvc = m_psel->GetHmmServices();
	if (psvc == NULL) {
		ASSERT(FALSE);
		return E_FAIL;
	}



	sc = psvc->ExecQuery((BSTR) bsQueryLang, (BSTR) bsQuery, WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pEnum);

#if 0
	if (FAILED(sc)) {
		HmmvErrorMsg(IDS_ERR_REFQUERY_FAILED,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		return;
	}
#endif //0



	COleVariant varQueryName;
	COleVariant varQueryString;
	COleVariant varQueryLang;

	COleVariant varPropnameQueryName;
	COleVariant varPropnameQueryString;
	COleVariant varPropnameQueryLang;

	varPropnameQueryName = _T("key");
	varPropnameQueryString = _T("sQueryString");
	varPropnameQueryLang = _T("sQueryLanguage");

	CString sQueryName;
	CString sQueryString;
	CString sQueryLang;

	CIMTYPE cimtype;

	IWbemClassObject* pco;
	while (TRUE) {

		unsigned long nReturned;
		pco = NULL;
		sc = pEnum->Next(QUERY_TIMEOUT, 1, &pco, &nReturned);

		if (sc==WBEM_S_TIMEDOUT || sc==S_OK) {
			if (nReturned > 0) {
				// Add to list here
				ASSERT(nReturned == 1);

				sc = pco->Get(varPropnameQueryName.bstrVal, 0, &varQueryName, &cimtype, NULL);
				if (FAILED(sc) || (varQueryName.vt!=VT_BSTR)) {
					varQueryName = _T("");
				}

				sc = pco->Get(varPropnameQueryString.bstrVal, 0, &varQueryString, &cimtype, NULL);
				if (FAILED(sc) || (varQueryString.vt != VT_BSTR)) {
					varQueryString = _T("");
				}

				sc = pco->Get(varPropnameQueryLang.bstrVal, 0, &varQueryLang, &cimtype, NULL);
				if (FAILED(sc) || (varQueryLang.vt != VT_BSTR)) {
					varQueryLang = _T("");
				}


				sQueryName = varQueryName.bstrVal;
				sQueryString = varQueryString.bstrVal;
				sQueryLang = varQueryLang.bstrVal;
				m_tsa.Add(sQueryName, sQueryString, sQueryLang);

				pco->Release();
			}

		}
		else {
			break;
		}
	}

	pEnum->Release();
	return S_OK;
}



void CDlgExecQuery::OnSaveQuery()
{
	m_sQueryName = GetQueryName();
	m_edtQueryString.GetWindowText(m_sQueryString);

	int iEntry = m_tsa.FindQueryName(m_sQueryName);

	if(iEntry >= 0)
	{
		CString sOldQueryName, sOldQueryString, sOldQueryLang;
		m_tsa.GetAt(iEntry, sOldQueryName, sOldQueryString, sOldQueryLang);
		if(0 == m_sQueryString.CompareNoCase(sOldQueryString))
		{
			GetDlgItem(IDC_SAVE_QUERY)->EnableWindow(FALSE);
			return;
		}

		if(IDYES != MessageBox(_T("Replace existing saved query?"), _T("Replace Query"), MB_YESNO))
			return;
	}

	SCODE sc;


	BOOL bClassExists = m_psel->ClassExists(_T("Win32_wmiQuery"));
	if (!bClassExists) {
		CreateWmiQueryClass();
	}


	// TODO: Add your control notification handler code here
	BOOL bCreateNewQuery = FALSE;
	if (iEntry >= 0) {
		m_tsa.SetAt(iEntry, m_sQueryName, m_sQueryString, _T("WQL"));


		CString sPath;
//		sPath = _T("ROOT\\CIMV2:Win32_wmiQuery.key=\"");
		sPath = _T("Win32_wmiQuery.key=\"");
		sPath += m_sQueryName;
		sPath += _T("\"");
		sc = m_psel->SelectPath(sPath, TRUE);
	}
	else {
		sc = m_psel->SpawnInstance(_T("Win32_wmiQuery"), TRUE);
		if (SUCCEEDED(sc)) {
			m_tsa.Add(m_sQueryName, m_sQueryString, _T("WQL"));
			bCreateNewQuery = TRUE;
		}
		else {
			return;
		}
	}



	IWbemClassObject* pco = m_psel->GetClassObject();
	ASSERT(pco != NULL);
	if (pco == NULL) {
		return;
	}


	COleVariant varPropnameQueryName;
	COleVariant varPropnameQueryString;
	COleVariant varPropnameQueryLang;

	varPropnameQueryName = _T("key");
	varPropnameQueryString = _T("sQueryString");
	varPropnameQueryLang = _T("sQueryLanguage");

	COleVariant varQueryName;
	COleVariant varQueryString;
	COleVariant varQueryLang;



	varQueryName = m_sQueryName;
	varQueryString = m_sQueryString;
	varQueryLang = _T("WQL");


	sc = pco->Put(varPropnameQueryName.bstrVal, 0, &varQueryName, NULL);
	sc = pco->Put(varPropnameQueryString.bstrVal, 0, &varQueryString, NULL);
	sc = pco->Put(varPropnameQueryLang.bstrVal, 0, &varQueryLang, NULL);
	sc = m_psel->SaveClassObject();


	if (bCreateNewQuery) {
		int iSel = m_lbQueryName.AddString(m_sQueryName);
		m_lbQueryName.SetCurSel(iSel);
		m_lbQueryName.UpdateWindow();
	}
	// Allow the user to remove the selected item.
	CWnd* pwndButton = GetDlgItem(IDC_REMOVE_QUERY);
	pwndButton->EnableWindow(TRUE);
	GetDlgItem(IDC_SAVE_QUERY)->EnableWindow(FALSE);

}


void CDlgExecQuery::OnRemoveQuery()
{
	m_sQueryName = GetQueryName();
	m_edtQueryString.GetWindowText(m_sQueryString);


	SCODE sc;

	// TODO: Add your control notification handler code here
	int iEntry = m_tsa.FindQueryName(m_sQueryName);
	if (iEntry >= 0) {
		m_tsa.SetAt(iEntry, m_sQueryName, m_sQueryString, _T("WQL"));
		CString sPath;
		sPath = _T("Win32_wmiQuery.key=\"");
		sPath += m_sQueryName;
		sPath += _T("\"");

		sc = m_psel->SelectPath(sPath, TRUE);
		if (SUCCEEDED(sc)) {
			sc = m_psel->DeleteInstance();
		}
		m_tsa.RemoveAt(iEntry);

		int iString = m_lbQueryName.FindString(0, m_sQueryName);
		if (iString >= 0) {
			m_lbQueryName.DeleteString(iString);
			int nCount = m_lbQueryName.GetCount();
			if(nCount <= 0)
			{
				GetDlgItem(IDC_REMOVE_QUERY)->EnableWindow(FALSE);
				GetDlgItem(IDOK)->EnableWindow(FALSE);
				m_edtQueryName.SetWindowText(_T(""));
				m_edtQueryString.SetWindowText(_T(""));
			}
			else
			{
				m_lbQueryName.SetCurSel(min(iString, nCount-1));
				OnSelchangeQueryList();
			}

		}

	}
}

void CDlgExecQuery::OnClose()
{
	if(GetDlgItem(IDC_SAVE_QUERY)->IsWindowEnabled() && GetQueryName().GetLength() > 0)
	{
		int nRet = MessageBox(_T("Do you want to save the query before closing?"), _T("Save Query Before Closing"), MB_YESNOCANCEL);
		switch(nRet)
		{
		case IDYES:
			OnSaveQuery();
			break;
		case IDNO:
			break;
		case IDCANCEL:
			return;
		}
	}
	EndDialog(IDCANCEL);
}





BOOL SetProperty(IWbemServices * pProv, IWbemClassObject * pInst,
 LPCTSTR pszProperty, LPCTSTR pszPropertyValue)

{
	SCODE sc;
	CString sProperty(pszProperty);
	CString sPropertyValue(pszPropertyValue);

    VARIANTARG var;
	VariantInit(&var);
    var.vt = VT_BSTR;
    var.bstrVal = sPropertyValue.AllocSysString ( );
    if(var.bstrVal == NULL)
	{
        return WBEM_E_FAILED;
	}

	BSTR bstrTemp = sProperty.AllocSysString ( );
    sc = pInst->Put(bstrTemp ,WBEM_FLAG_USE_AMENDED_QUALIFIERS, &var,NULL);
	::SysFreeString(bstrTemp);
	if (sc != S_OK)
		{
			CString csUserMsg = _T("Cannot Put ");
			csUserMsg += pszProperty;
			HmmvErrorMsgStr(csUserMsg,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);

	}


	VariantClear(&var);
	return TRUE;
}




//***************************************************************************
//
// CreateSimpleClass
//
// Purpose: This creates a new class with a class name and parent.
//
//***************************************************************************

IWbemClassObject *CreateSimpleClass
(IWbemServices * pProv, CString *pcsNewClass, CString *pcsParentClass, int &nError,
CString &csError )
{
	IWbemClassObject *pNewClass = NULL;
    IWbemClassObject *pParentClass = NULL;

   	SCODE sc;


	BSTR bstrTemp =  pcsNewClass->AllocSysString();
	sc = pProv -> GetObject
		(bstrTemp ,0,NULL, &pNewClass,NULL);
	::SysFreeString(bstrTemp);

	if (sc == S_OK)
	{
		pNewClass->Release();
		CString csUserMsg =
			_T("An error occured creating the class ") + *pcsNewClass;
		csUserMsg +=
			_T(":  Class ") + *pcsNewClass;
		csUserMsg += _T(" already exists");
		HmmvErrorMsgStr(csUserMsg,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);

		return NULL;

	}

	if (pcsParentClass  && (pcsParentClass->GetLength() > 0))
	{
		bstrTemp = pcsParentClass->AllocSysString();
		sc = pProv -> GetObject
			(bstrTemp,0,NULL, &pParentClass,NULL);
		::SysFreeString(bstrTemp);
	}
	else
	{
		sc = pProv -> GetObject
			(NULL,0,NULL, &pParentClass,NULL);
	}

	if (sc != S_OK)
	{
		if (pcsParentClass)
		{
			CString csUserMsg =
				_T("An error occured creating the class ") + *pcsNewClass;
			csUserMsg +=
				_T(":  Cannot create the new class because the parent class object \"") + *pcsParentClass + _T("\" does not exist.");

			HmmvErrorMsgStr(csUserMsg,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);

		}
		else
		{
			CString csUserMsg =
				_T("An error occured creating the class ") + *pcsNewClass +  _T(" .");
			HmmvErrorMsgStr(csUserMsg,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);


		}
		return NULL;
	}


	if (pcsParentClass)
	{
		sc = pParentClass->SpawnDerivedClass(0,&pNewClass);
	}
	else
	{
		pNewClass = pParentClass;
		pNewClass->AddRef();
		sc = S_OK;
	}

	if (sc != S_OK)
	{
		pParentClass->Release();
		CString csUserMsg =
			_T("An error occured creating the class ") + *pcsNewClass;
		if (pcsParentClass)
		{
			csUserMsg +=
				_T(":  Cannot spawn derived class of ") + *pcsParentClass;
		}
		else
		{
			csUserMsg +=
				_T(":  Cannot spawn derived class");
		}
		HmmvErrorMsgStr(csUserMsg,  S_OK,   FALSE,  NULL, _T(__FILE__),  __LINE__);


		return NULL;
	}

	pParentClass->Release();


	// Init class __Class Property
	SetProperty (pProv, pNewClass, _T("__Class"), (LPCTSTR) *pcsNewClass );
	SetProperty(pProv, pNewClass, _T("key"), (LPCTSTR) _T(""));
	SetProperty(pProv, pNewClass, _T("sQueryString"), _T(""));
	SetProperty(pProv, pNewClass, _T("sQueryLanguage"), _T(""));


	COleVariant varKey;
	varKey = _T("key");

	IWbemQualifierSet* pqs = NULL;
	sc = pNewClass->GetPropertyQualifierSet(varKey.bstrVal, &pqs);
	if (SUCCEEDED(sc)) {
		LONG lFlavor = 0;
		lFlavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
		lFlavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;

		COleVariant varValue;
		varValue.ChangeType(VT_BOOL);
		varValue.boolVal = VARIANT_TRUE;
		sc = pqs->Put(varKey.bstrVal, &varValue, lFlavor);
		pqs->Release();
	}



	sc = pProv->PutClass(pNewClass,0,NULL,NULL);

	if (sc != S_OK)
	{
		CString csUserMsg=
		_T("An error occured creating the class ") + *pcsNewClass;
		csUserMsg += _T(":  Cannot PutClass on ") + *pcsNewClass;

		HmmvErrorMsgStr(csUserMsg,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);

		return NULL;
	}
	else
	{
		pNewClass->Release();
		pNewClass = NULL;
		BSTR bstrTemp = pcsNewClass->AllocSysString();
		sc = pProv -> GetObject
		(bstrTemp,0,NULL,&pNewClass,NULL);
		::SysFreeString(bstrTemp);

		if (sc != S_OK)
		{
			CString csUserMsg=
					_T("An error occured creating the class ") + *pcsNewClass;
			csUserMsg +=
					_T(":  Cannot get the new class.\"") ;


			HmmvErrorMsgStr(csUserMsg,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);

			return NULL;
		}
		return pNewClass;
	}
}



SCODE CDlgExecQuery::CreateWmiQueryClass()
{
	IWbemClassObject* pcoClass;

	CString sNewClass(_T("Win32_wmiQuery"));
	CString sError;
	int nError;


	pcoClass = ::CreateSimpleClass(m_psel->GetHmmServices(), &sNewClass, NULL, nError, sError);


	pcoClass->Release();
	return S_OK;
}

void CDlgExecQuery::OnSelchangeQueryList()
{
	int nPos = m_lbQueryName.GetCurSel();
	if (nPos < 0) {
		return;
	}

	CString sKey;
	m_lbQueryName.GetText(nPos, sKey);

	int iQueryName = m_tsa.FindQueryName(sKey);
	if (iQueryName >= 0) {
		m_tsa.GetAt(iQueryName, m_sQueryName, m_sQueryString, m_sQueryLang);
		m_edtQueryName.SetWindowText(m_sQueryName);
		m_edtQueryString.SetWindowText(m_sQueryString);

		CWnd* pwndButton = GetDlgItem(IDOK);
		pwndButton->EnableWindow(TRUE);

		// Allow the user to remove the selected item.
		pwndButton = GetDlgItem(IDC_REMOVE_QUERY);
		pwndButton->EnableWindow(TRUE);

		// The item has not yet been modified, so don't save.
		pwndButton = GetDlgItem(IDC_SAVE_QUERY);
		pwndButton->EnableWindow(FALSE);



	}

}

void CDlgExecQuery::OnDblclkQueryList()
{
	// TODO: Add your control notification handler code here

}

BOOL CDlgExecQuery::HasQuery()
{

	CString s;
	s = GetQueryName();
	if (s.IsEmpty()) {
		return FALSE;
	}

	m_edtQueryString.GetWindowText(s);
	if (s.IsEmpty()) {
		return FALSE;
	}
	return TRUE;
}


void CDlgExecQuery::OnChangeEditQueryName()
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CDialog::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

	// TODO: Add your control notification handler code here

	// Disable Save if there is no name or no query string
	GetDlgItem(IDC_SAVE_QUERY)->EnableWindow(GetQueryName().GetLength() && m_edtQueryString.GetWindowTextLength());

	// Don't let the user remove a query until it is saved
	GetDlgItem(IDC_REMOVE_QUERY)->EnableWindow(FALSE);
}

void CDlgExecQuery::OnChangeEditQueryString()
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CDialog::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

	// Disable Save if there is no name or no query string
	GetDlgItem(IDC_SAVE_QUERY)->EnableWindow(GetQueryName().GetLength() && m_edtQueryString.GetWindowTextLength());

	// Disable Save Execute if there is no query string
	GetDlgItem(IDOK)->EnableWindow(m_edtQueryString.GetWindowTextLength());

	// Don't let the user remove a query until it is saved
	GetDlgItem(IDC_REMOVE_QUERY)->EnableWindow(FALSE);
}

CString GetSDKDirectory()
{
	CString csHmomWorkingDir;
	HKEY hkeyLocalMachine;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hkeyLocalMachine);
	if (lResult != ERROR_SUCCESS) {
		return "";
	}

	HKEY hkeyHmomCwd;
	lResult = RegOpenKeyEx(
				hkeyLocalMachine,
				_T("SOFTWARE\\Microsoft\\Wbem"),
				0,
				KEY_READ | KEY_QUERY_VALUE,
				&hkeyHmomCwd);

	if (lResult != ERROR_SUCCESS) {
		RegCloseKey(hkeyLocalMachine);
		return "";
	}

	unsigned long lcbValue = 1024;
	LPTSTR pszWorkingDir = csHmomWorkingDir.GetBuffer(lcbValue);

	unsigned long lType;
	lResult = RegQueryValueEx(
				hkeyHmomCwd,
				_T("SDK Directory"),
				NULL,
				&lType,
				(unsigned char*) (void*) pszWorkingDir,
				&lcbValue);


	csHmomWorkingDir.ReleaseBuffer();
	RegCloseKey(hkeyHmomCwd);
	RegCloseKey(hkeyLocalMachine);

	if (lResult != ERROR_SUCCESS)
	{
		csHmomWorkingDir.Empty();
	}

	return csHmomWorkingDir;
}

void CDlgExecQuery::OnHelp()
{
	CString csPath;
	WbemRegString(SDK_HELP, csPath);

	CString csData = idh_wqlquerytool;

	HWND hWnd = NULL;
	try
	{
		HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD_PTR) (LPCTSTR) csData);
		if (!hWnd)
			MessageBox(L"Unable to launch the help file", L"Error launching help file.");
	}

	catch( ... )
	{
		// Handle any exceptions here.
		MessageBox(L"Unable to launch the help file", L"Error launching help file.");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\coloredt.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ColorEdit.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CColorEdit window

class CColorEdit : public CEdit
{
// Construction
public:
	CColorEdit();
	void SetBackColor(COLORREF clrBackground);
	COLORREF GetBackColor() {return m_clrBackground; }

	void SetTextColor(COLORREF clrText);
	COLORREF GetForeColor() {return m_clrText; }

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CColorEdit)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CColorEdit();

	// Generated message map functions
protected:
	//{{AFX_MSG(CColorEdit)
	afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	COLORREF m_clrBackground;
	COLORREF m_clrText;
	CBrush m_brBackground;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\coloredt.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ColorEdit.cpp : implementation file
//

#include "precomp.h"
#include "hmmv.h"
#include "ColorEdt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CColorEdit

CColorEdit::CColorEdit()
{
	m_clrText = RGB(0, 0, 0);		  // Black
	m_clrBackground = RGB(255, 255, 255); // White
}

CColorEdit::~CColorEdit()
{
}


BEGIN_MESSAGE_MAP(CColorEdit, CEdit)
	//{{AFX_MSG_MAP(CColorEdit)
	ON_WM_CTLCOLOR_REFLECT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CColorEdit message handlers

void CColorEdit::SetBackColor(COLORREF clrBackground)
{
	m_clrBackground = clrBackground;

}

void CColorEdit::SetTextColor(COLORREF clrText)
{
	m_clrText = clrText;
}

HBRUSH CColorEdit::CtlColor(CDC* pDC, UINT nCtlColor)
{

	// TODO: Return a non-NULL brush if the parent's handler should not be called

	pDC->SetTextColor(m_clrText);
	pDC->SetBkColor( m_clrBackground);	// text bkgnd

	return NULL;				// ctl bkgnd
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\dlghelpbox.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_DlgHelpBox_H__D2CE6B12_36C4_11D2_854F_00C04FD7BB08__INCLUDED_)
#define AFX_DlgHelpBox_H__D2CE6B12_36C4_11D2_854F_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgHelpBox.h : header file
//
class CRichEditCtrl;
class CWBEMViewContainerCtrl;
typedef interface IWbemClassObject IWbemClassObject;

/////////////////////////////////////////////////////////////////////////////
// CDlgHelpBox dialog
class CSignatureElement
{
public:
	CSignatureElement();

	CString m_sName;
	CString m_sDescription;
	CString m_sCimtype;
	int m_id;
	bool m_bIsOutParameter;
	bool m_bIsInParameter;
};

class CSignatureArray
{
public:
	~CSignatureArray();

	SCODE AddParameter(IWbemClassObject* pco, LPCTSTR pszName);
	CSignatureElement& operator[](int iElement);
	CSignatureElement& RetVal() {return m_seRetValue; }
	int GetSize() { return (int) m_array.GetSize(); }
private:
	CPtrArray m_array;
	CSignatureElement m_seRetValue;
};


class CDlgHelpBox : public CDialog
{
// Construction
public:
	CDlgHelpBox(CWnd* pParent = NULL);   // standard constructor
	void ShowHelpForClass(CWBEMViewContainerCtrl* phmmv, LPCTSTR pszClassPath);

// Dialog Data
	//{{AFX_DATA(CDlgHelpBox)
	enum { IDD = IDD_DLG_HELP };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgHelpBox)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgHelpBox)
	virtual BOOL OnInitDialog();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnMove(int x, int y);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	SCODE DisplayMethod(LPCTSTR pszMethodName, IWbemClassObject* pco, IWbemClassObject* pcoInSignature, IWbemClassObject* pcoOutSignature);
	void DisplaySignature(LPCTSTR pszMethodName, CSignatureArray& params);

	void DisplayMethodParameters(CSignatureArray& params);
	SCODE GetObjectDescription(IWbemClassObject* pco, COleVariant& varDescription);
	int AddSignature(IWbemClassObject* pcoInSignature, IWbemClassObject* pcoOutSignature);
	void MergeSignatures(CSignatureArray& params, IWbemClassObject* pcoInSignature, IWbemClassObject* pcoOutSignature);
	int AddMethodDescriptions(IWbemClassObject* pco);
	void AddHelpText(LPCTSTR pszText, DWORD dwEffects = 0, int nIndent = 0);



	CRichEditCtrl* m_pedit;
	int LoadDescriptionText(IWbemClassObject* pco);
	void AddHelpItem(BSTR bstrName, BSTR bstrText, int nIndent=0);
	void AddHelpItem2(BSTR bstrKind, BSTR bstrName, BSTR bstrText, int nIndent =0);

	void ExpandParagraphMarkers(CString& sText);
	void SetDescriptionMissingMessage();

	CString m_sPath;
	CWBEMViewContainerCtrl* m_phmmv;
	CRect m_rcWindowSave;
	BOOL m_bCaptureWindowRect;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DlgHelpBox_H__D2CE6B12_36C4_11D2_854F_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\dlgexecquery.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _DlgExecQuery_h
#define _DlgExecQuery_h

#if !defined(AFX_DLGEXECQUERY_H__A98D96B9_F458_11D2_B37F_00105AA680B8__INCLUDED_)
#define AFX_DLGEXECQUERY_H__A98D96B9_F458_11D2_B37F_00105AA680B8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgExecQuery.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgExecQuery dialog

#include "path.h"
class CWBEMViewContainerCtrl;
class CSelection;


class CTripleStringArray
{
public:
	CTripleStringArray();
	~CTripleStringArray();
	void SetAt(int iElement, LPCTSTR pszQueryName, LPCTSTR pszQueryString, LPCTSTR pszQueryLang);
	void GetAt(int iElement, CString& sQueryName, CString& sQueryString, CString& sQueryLang);
	void Add(LPCTSTR pszQueryName, LPCTSTR pszQueryString, LPCTSTR pszQueryLang);
	void RemoveAt(int iElement);
	SCODE CreateWmiQueryClass();

	LPCTSTR GetQueryName(int iElement) {return (LPCTSTR) m_saQueryName[iElement]; }
	int FindQueryName(LPCTSTR pszQeuryName);
	INT_PTR GetSize() {return m_saQueryName.GetSize(); }

private:
	CStringArray m_saQueryName;
	CStringArray m_saQueryString;
	CStringArray m_saQueryLang;

};

class CDlgExecQuery : public CDialog
{
// Construction
public:
	CDlgExecQuery(CWBEMViewContainerCtrl* phmmv, CWnd* pParent = NULL);   // standard constructor
	~CDlgExecQuery();
	SCODE GetQueryList();

	CString m_sQueryString;
	CString m_sQueryName;
	CString m_sQueryLang;

	SCODE CreateWmiQueryClass();

// Dialog Data
	//{{AFX_DATA(CDlgExecQuery)
	enum { IDD = IDD_EXECUTE_QUERY };
	CListBox	m_lbQueryName;
	CEdit	m_edtQueryName;
	CEdit	m_edtQueryString;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgExecQuery)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgExecQuery)
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnRemoveQuery();
	virtual BOOL OnInitDialog();
	afx_msg void OnSaveQuery();
	afx_msg void OnClose();
	afx_msg void OnSelchangeQueryList();
	afx_msg void OnDblclkQueryList();
	afx_msg void OnChangeEditQueryName();
	afx_msg void OnChangeEditQueryString();
	afx_msg void OnHelp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	CString GetQueryName();

	BOOL HasQuery();
	CSelection* m_psel;
	CWBEMViewContainerCtrl* m_phmmv;
	CTripleStringArray m_tsa;
};






//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGEXECQUERY_H__A98D96B9_F458_11D2_B37F_00105AA680B8__INCLUDED_)

#endif // _DlgExecQeury_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\filters.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// filters.cpp : implementation file
//

#include "precomp.h"
#include "hmmv.h"
#include "notify.h"
#include "hmomutil.h"
#include "filters.h"
#include "hmmvctl.h"
#include "PolyView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgFilters dialog


CDlgFilters::CDlgFilters(CWBEMViewContainerCtrl* phmmv /*=NULL*/)
	: CDialog(CDlgFilters::IDD,  (CWnd*) phmmv)
{
	//{{AFX_DATA_INIT(CDlgFilters)
	//}}AFX_DATA_INIT

	m_phmmv = phmmv;
}


void CDlgFilters::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgFilters)
	DDX_Control(pDX, IDC_FILTER_LIST, m_lcFilters);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgFilters, CDialog)
	//{{AFX_MSG_MAP(CDlgFilters)
	ON_LBN_DBLCLK(IDC_FILTER_LIST, OnDblclkFilterList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgFilters message handlers

long CDlgFilters::FindView(long lView)
{
	int nItems = m_lcFilters.GetCount();
	for (int iItem=0; iItem < nItems; ++iItem) {
		if (m_lcFilters.GetItemData(iItem) == (DWORD) lView) {
			return iItem;
		}
	}
	return -1;
}




BOOL CDlgFilters::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO: Add extra initialization here
	CPolyView* pview = m_phmmv->GetView();


	int iItem;
	long lPos = pview->StartViewEnumeration(VIEW_FIRST);
	CString sViewTitle;
	if (lPos != -1) {
		sViewTitle = pview->GetViewTitle(lPos);
		while (TRUE) {
			iItem = m_lcFilters.AddString(sViewTitle);
			m_lcFilters.SetItemData(iItem, (DWORD) lPos);

			BSTR bstrTitle;
			bstrTitle = NULL;
			lPos = pview->NextViewTitle(lPos, &bstrTitle);
			if (lPos == -1) {
				break;
			}

			if (bstrTitle != NULL) {
				sViewTitle = bstrTitle;
				::SysFreeString(bstrTitle);
			}


		}
	}

	// Select the current view in the listbox.
	lPos = pview->StartViewEnumeration(VIEW_CURRENT);
	iItem = FindView(lPos);
	if (iItem >= 0) {
		m_lcFilters.SetCurSel(iItem);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDlgFilters::OnDblclkFilterList()
{
	OnOK();
}

void CDlgFilters::OnOK()
{
	// TODO: Add extra validation here
	int iItem = m_lcFilters.GetCurSel();
	long lView = (long) m_lcFilters.GetItemData(iItem);

	m_phmmv->SelectView(lView);

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\dlghelpbox.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

// DlgHelpBox.cpp : implementation file
//

#include "precomp.h"
#include "hmmv.h"
#include "DlgHelpBox.h"
#include <afxcmn.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include "hmmvctl.h"
#include <wbemcli.h>
#include "hmomutil.h"
#include "utils.h"
#include "path.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CDlgHelpBox dialog


CDlgHelpBox::CDlgHelpBox(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgHelpBox::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgHelpBox)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pedit = new CRichEditCtrl;
	m_rcWindowSave.SetRectEmpty();
	m_bCaptureWindowRect = FALSE;
}


void CDlgHelpBox::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgHelpBox)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgHelpBox, CDialog)
	//{{AFX_MSG_MAP(CDlgHelpBox)
	ON_WM_SIZE()
	ON_WM_MOVE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgHelpBox message handlers

BOOL CDlgHelpBox::OnInitDialog()
{
	CDialog::OnInitDialog();
	m_bCaptureWindowRect = TRUE;

	if (m_rcWindowSave.IsRectEmpty()) {
		GetWindowRect(m_rcWindowSave);
	}
	else {
		MoveWindow(m_rcWindowSave);
	}


	long lResult = m_phmmv->PublicSaveState(TRUE, MB_YESNOCANCEL);
	switch(lResult) {
	case S_OK:			// The user saved
	case WBEM_S_FALSE:	// The user chose not to save.
		break;
	case E_FAIL:	// The user canceled the operation.
		EndDialog(IDCANCEL);
		break;
	}

	// TODO: Add extra initialization here

	CRect rcEdit;
	GetClientRect(rcEdit);
	DWORD dwStyle = WS_VSCROLL | ES_READONLY | ES_MULTILINE | ES_AUTOVSCROLL | WS_VISIBLE;
	m_pedit->Create(dwStyle, rcEdit, this, 105);

	m_pedit->SetFocus();

	COLORREF crPrev;
	crPrev = m_pedit->SetBackgroundColor(FALSE, RGB(0x0ff, 0x0ff, 0x0e0));

	SCODE sc;

	CString sClassPath;
	if (::PathIsClass(m_sPath)) {
		sClassPath = m_sPath;
	}
	else {
		sc = ::InstPathToClassPath(sClassPath, m_sPath);
	}

	COleVariant varClassPath;
	varClassPath = sClassPath;
	COleVariant varClassName;
	ClassFromPath(varClassName, varClassPath.bstrVal);
	CString sClassName;
	sClassName = varClassName.bstrVal;


	CString sCaption;
	sCaption.LoadString(IDS_HELP_CAPTION_PREFIX);
	sCaption += sClassName;
	SetWindowText(sCaption);


	CSelection sel(m_phmmv);

	sc = sel.SelectPath(sClassPath);

	if (FAILED(sc)) {
		SetDescriptionMissingMessage();
		m_pedit->SetSel(0, 0);
		m_pedit->SetScrollPos(SB_VERT, 0, TRUE);
		m_pedit->UpdateWindow();
		m_pedit->SetFocus();
		return FALSE;
	}

	// Now get the class, and get each description.
	IWbemClassObject* pco = sel.GetClassObject();

	if (pco == NULL) {
		SetDescriptionMissingMessage();
		m_pedit->SetSel(0, 0);
		m_pedit->SetScrollPos(SB_VERT, 0, TRUE);
		m_pedit->UpdateWindow();
		m_pedit->SetFocus();
		return FALSE;
	}

	int nDescriptions = LoadDescriptionText(pco);

	if (nDescriptions == 0) {
		SetDescriptionMissingMessage();
	}

	m_pedit->SetSel(0, 0);
	m_pedit->LineScroll(-0xFFFFFFF);
	m_pedit->SetScrollPos(SB_VERT, 0, TRUE);
	m_pedit->UpdateWindow();
	m_pedit->SetFocus();


	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


//*************************************************************
// CDlgHelpBox::LoadDescriptionText
//
// Load the description text from a class.  The description text
// is contained in the "Description" qualifiers on the class and
// each of its properties.
//
// Parameters:
//		[in] IWbemClassObject* pco
//			Pointer to the class object containing the description
//			text.
//
// Returns:
//		int
//			The number of property descriptions loaded.
//
//*************************************************************
int CDlgHelpBox::LoadDescriptionText(IWbemClassObject* pco)
{
	int nDescriptions = 0;

	CMosNameArray aPropNames;
	SCODE sc = aPropNames.LoadPropNames(pco, WBEM_FLAG_NONSYSTEM_ONLY);
	if (FAILED(sc)) {
		SetDescriptionMissingMessage();
		return 0;
	}


	COleVariant varQualName;
	varQualName = _T("Description");

	COleVariant varPropName;
	int nNames = aPropNames.GetSize();
	IWbemQualifierSet* pqs = NULL;
	LONG lFlavor;
	COleVariant varDescription;


	// Get the description for the class and add it to the rich edit control.
	pqs = NULL;
	sc = pco->GetQualifierSet(&pqs);
	if (SUCCEEDED(sc)) {

		lFlavor = 0;
		sc = pqs->Get(varQualName.bstrVal, 0, &varDescription, &lFlavor);
		if (SUCCEEDED(sc)) {
			AddHelpItem(NULL, varDescription.bstrVal);
		}
		else {
			AddHelpText(_T("<description missing>\r\n\r\n"));
		}
		pqs->Release();
		pqs = NULL;
	}
	else {
		AddHelpText(_T("<description missing>\r\n\r\n"));
	}
	++nDescriptions;



	// Iterate through each of the property names and load the description qualifier
	// for each property into the rich edit control.
	for (int iName=0; iName < nNames; ++iName) {
		varPropName = aPropNames[iName];
		CString sPropName = varPropName.bstrVal;


		varDescription.Clear();

		pqs = NULL;
		sc = pco->GetPropertyQualifierSet(varPropName.bstrVal, &pqs);
		if (FAILED(sc)) {
			continue;
		}

		lFlavor = 0;
		sc = pqs->Get(varQualName.bstrVal, 0, &varDescription, &lFlavor);
		if (SUCCEEDED(sc)) {
			AddHelpItem(varPropName.bstrVal, varDescription.bstrVal);
		}
		else {
			CString sText;
			sText.LoadString(IDS_MSG_MISSING_PROP_DESCRIPTION);
			COleVariant varText;
			varText = sText;
			AddHelpItem(varPropName.bstrVal, varText.bstrVal);
		}
		++nDescriptions;
		pqs->Release();
		pqs = NULL;
	}

	int nMethods = AddMethodDescriptions(pco);


	return nDescriptions + nMethods;
}


int CDlgHelpBox::AddMethodDescriptions(IWbemClassObject* pco)
{
	int nMethodDescriptions = 0;
	CString s;

	HRESULT hr;

	IWbemClassObject* pcoInSignature = NULL;
	IWbemClassObject* pcoOutSignature = NULL;
	BSTR bstrMethodName = NULL;
	hr = pco->BeginMethodEnumeration(0);
	if (SUCCEEDED(hr)) {
		while (true) {
			hr = pco->NextMethod( 0, &bstrMethodName, NULL, NULL);
			if (hr == WBEM_S_NO_MORE_DATA) {
				break;
			}
			if (FAILED(hr)) {
				break;
			}


			// The method name
			HRESULT hr = pco->GetMethod(bstrMethodName, 0, &pcoInSignature, &pcoOutSignature);
			if (SUCCEEDED(hr)) {
				++nMethodDescriptions;
				CString sMethodName;
				sMethodName = bstrMethodName;

				DisplayMethod(sMethodName, pco, pcoInSignature, pcoOutSignature);

				if (pcoInSignature) {
					pcoInSignature->Release();
					pcoInSignature = NULL;
				}

				if (pcoOutSignature) {
					pcoOutSignature->Release();
					pcoOutSignature = NULL;
				}
			}


			::SysFreeString(bstrMethodName);
			bstrMethodName = NULL;
		}
	}
	return nMethodDescriptions;
}


SCODE CDlgHelpBox::DisplayMethod(
	LPCTSTR pszMethodName,
	IWbemClassObject* pco,
	IWbemClassObject* pcoInSignature,
	IWbemClassObject* pcoOutSignature)
{
	SCODE sc;



	// Display the method signature
	COleVariant varDescription;
	CString s;

	CSignatureArray params;
	MergeSignatures(params, pcoInSignature, pcoOutSignature);
	DisplaySignature(pszMethodName, params);
	AddHelpText(_T("\r\n"));



	// The general description of the method contained in the method's
	// "Description" qualifier.
	COleVariant varMethodName;
	varMethodName = pszMethodName;
	IWbemQualifierSet* pqsMethod = NULL;
	sc = pco->GetMethodQualifierSet(varMethodName.bstrVal, &pqsMethod);
	if (SUCCEEDED(sc)) {
		long lFlavor = 0;
		COleVariant varQualName;
		COleVariant varDescription;
		varQualName = _T("Description");
		sc = pqsMethod->Get(varQualName.bstrVal, 0, &varDescription, &lFlavor);
		if (SUCCEEDED(sc)) {
			s = varDescription.bstrVal;
			ExpandParagraphMarkers(s);
			s += _T("\r\n\r\n");
			AddHelpText(s);
		}

		pqsMethod->Release();
	}


	DisplayMethodParameters(params);
	return S_OK;
}

void CDlgHelpBox::DisplayMethodParameters(CSignatureArray& params)
{
	CString s;
	int nParams = params.GetSize();
	for (int iParam=0; iParam < nParams; ++iParam) {
		CSignatureElement* pse = &params[iParam];

		AddHelpText(pse->m_sName, CFE_ITALIC);
		AddHelpText(_T("\r\n"));
		if (pse->m_sDescription.IsEmpty()) {
			AddHelpText(_T("<description missing>"), 0, 1);
		}
		else {
			s = pse->m_sDescription;
			ExpandParagraphMarkers(s);
			AddHelpText(s, 0, 1);
		}
		AddHelpText(_T("\r\n\r\n"), 0, 1);
	}
}


void CDlgHelpBox::MergeSignatures(CSignatureArray& params, IWbemClassObject* pcoInSignature, IWbemClassObject* pcoOutSignature)
{
	int nProps;
	int iProp;
	SCODE sc;
	CMosNameArray aPropNames;
	CString sPropName;

	if (pcoInSignature) {
		sc = aPropNames.LoadPropNames(pcoInSignature, WBEM_FLAG_NONSYSTEM_ONLY);
		if (FAILED(sc)) {
			return;
		}

		nProps = aPropNames.GetSize();
		for (iProp = 0; iProp < nProps; ++iProp) {
			sPropName = aPropNames[iProp];
			sc = params.AddParameter(pcoInSignature, sPropName);
		}
	}


	if (pcoOutSignature) {
		sc = aPropNames.LoadPropNames(pcoOutSignature, WBEM_FLAG_NONSYSTEM_ONLY);
		if (FAILED(sc)) {
			return;
		}

		nProps = aPropNames.GetSize();
		for (iProp = 0; iProp < nProps; ++iProp) {
			sPropName = aPropNames[iProp];
			sc = params.AddParameter(pcoOutSignature, sPropName);
		}
	}


}

void CDlgHelpBox::DisplaySignature(LPCTSTR pszMethodName, CSignatureArray& params)
{
	CString sReturnCimtype;
	int nParams = params.GetSize();
	int iParam;
	CString s;
	CSignatureElement* pse;
	CSignatureElement& seRetVal = params.RetVal();

	AddHelpText(seRetVal.m_sCimtype, CFE_BOLD);
	AddHelpText(_T(" "));


	AddHelpText(pszMethodName, CFE_BOLD, 0);
	AddHelpText(_T("("), CFE_BOLD, 0);
	BOOL bFirstParam = TRUE;


	for (iParam = 0; iParam < nParams; ++iParam) {
		pse = &params[iParam];
		if (pse->m_sName.CompareNoCase(_T("ReturnValue")) == 0) {
			continue;
		}

		if (bFirstParam) {
			bFirstParam = FALSE;
			AddHelpText(_T("\r\n"), 0, 0);
		}

		s = _T("[");
		if (pse->m_bIsInParameter) {
			s += _T("in");
		}

		if (pse->m_bIsOutParameter) {
			s += _T("out");
		}

		s += _T("] ");
		s += pse->m_sCimtype;
		s += _T(" ");
		AddHelpText(s, CFE_BOLD, 1);
		AddHelpText(pse->m_sName, 0, 1);
		if (iParam < (nParams - 1)) {
			AddHelpText(_T(","), CFE_BOLD, 1);
		}
		AddHelpText(_T("\r\n"), CFE_BOLD, 1);

	}

	AddHelpText(_T(");\r\n"), CFE_BOLD, 0);

}


SCODE CDlgHelpBox::GetObjectDescription(IWbemClassObject* pco, COleVariant& varDescription)
{
	IWbemQualifierSet* pqs = NULL;
	SCODE sc = pco->GetQualifierSet(&pqs);
	if (SUCCEEDED(sc)) {
		COleVariant varQualName;
		varQualName = _T("Description");

		long lFlavor = 0;
		sc = pqs->Get(varQualName.bstrVal, 0, &varDescription, &lFlavor);
		pqs->Release();
		pqs = NULL;
	}
	return sc;
}

//*************************************************************
// CDlgHelpBox::SetDescriptionMissingMessage
//
// This method is called when it is not possible to load
// a description of the class into the rich edit control.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CDlgHelpBox::SetDescriptionMissingMessage()
{
	CString sMessage;
	sMessage.LoadString(IDS_MSG_NO_HELP_FOR_CLASS);
	m_pedit->SetSel(0, -1);
	m_pedit->ReplaceSel(sMessage, FALSE);
}



//*************************************************************
// CDlgHelpBox::AddHelpItem
//
// Add a description item to the rich edit control.
//
// Parameters:
//		[in] BSTR bstrName
//			The parameter name.
//
//		[in] BSTR bstrText
//			The description text.
//
//		[in] int nIndent
//			The indention level.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CDlgHelpBox::AddHelpItem(BSTR bstrName, BSTR bstrText, int nIndent)
{


	// A NULL name is passed in for the class description so that just the
	// description text will appear at the top of the rich edit control.  This
	// distinguishes the class description from the property descriptions.
	if (bstrName != NULL) {
		// Add the property name
		CString sName;
		sName = bstrName;
		sName += _T("\r\n");
		if (nIndent > 0) {
			AddHelpText(sName, CFE_ITALIC, nIndent);
		}
		else {
			AddHelpText(sName, CFE_BOLD, nIndent);
		}
	}

	CString sText;
	sText = bstrText;
	ExpandParagraphMarkers(sText);
	sText += _T("\r\n");
	if (bstrName == NULL) {
		AddHelpText(sText, 0, nIndent);
	}
	else {
		AddHelpText(sText, 0, nIndent + 1);
	}
	AddHelpText(_T("\r\n"), 0, 0);
}


//*************************************************************
// CDlgHelpBox::AddHelpItem2
//
// Add a description item to the rich edit control.
//
// Parameters:
//		[in] BSTR bstrKind
//			The kind of parameter
//
//		[in] BSTR bstrName
//			The parameter name.
//
//		[in] BSTR bstrText
//			The description text.
//
//		[in] int nIndent
//			The indention level.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CDlgHelpBox::AddHelpItem2(BSTR bstrKind, BSTR bstrName, BSTR bstrText, int nIndent)
{

	CString sIndent;
	int nSpaceIndent = nIndent * 4;
	for (int i=0; i<nSpaceIndent; ++i) {
		sIndent = sIndent + _T(" ");
	}



	CString sText;
	sText = sIndent;
	sText += bstrKind;
	sText += _T(": ");
	AddHelpText(sText, CFE_BOLD);



	sText = bstrName;
	sText += _T("\r\n");
	AddHelpText(sText);


	sText = sIndent;
	sText += bstrText;
	ExpandParagraphMarkers(sText);
	sText += _T("\r\n\r\n");
	AddHelpText(sText);
}


void CDlgHelpBox::AddHelpText(LPCTSTR pszText, DWORD dwEffects, int nIndent)
{

	CString sText;
#if 0
	int nSpaceIndent = nIndent * 4;
	for (int i=0; i<nSpaceIndent; ++i) {
		sText = sText + _T(" ");
	}
#endif //0

	sText += pszText;


	TCHAR cf[sizeof(CHARFORMAT) + 128];
	CHARFORMAT* pcf = (CHARFORMAT*) cf;



	pcf->cbSize = sizeof(cf);
	pcf->bPitchAndFamily = FF_ROMAN | VARIABLE_PITCH | FF_SWISS  ;
	_tcscpy((TCHAR *)pcf->szFaceName, _T("MS Shell Dlg"));
	pcf->dwEffects = dwEffects;
	pcf->dwMask = CFM_FACE | CFM_BOLD | CFM_ITALIC | CFM_UNDERLINE;

	// bug#55983 - Formating is wrong because some text may be inserted with
	// just '\n' from the descriptions.  This causes GetTextLength() to report
	// more characters than are actually in the rich edit control.  To fix,
	// we call SetSel(-1, -1) to move to the end, then use GetSel(...) to find
	// out the REAL length.
#if 0
	iStartChar = m_pedit->GetTextLength();
	m_pedit->SetSel(iStartChar, -1);
#endif
	long nStart, nEnd;
	m_pedit->SetSel(-1, -1);
	m_pedit->GetSel(nStart, nEnd);
	m_pedit->ReplaceSel(sText, FALSE);
	m_pedit->SetSel(nStart, -1);
	m_pedit->SetSelectionCharFormat(*pcf);




	// One-third of an inch per tab stop (72 *
	int dxIndent = (1440 * nIndent) / 3;
	PARAFORMAT pf;
	pf.cbSize = sizeof(pf);
	pf.dwMask =  PFM_OFFSET | PFM_STARTINDENT;
	pf.wNumbering = 0;
	pf.wReserved = 0;
	pf.dxStartIndent = dxIndent;
	pf.dxRightIndent = 0;
	pf.dxOffset = dxIndent;
	pf.wAlignment = 0;
	pf.cTabCount = 0;


	m_pedit->SetParaFormat(pf);
}






CSignatureArray::~CSignatureArray()
{
	INT_PTR nParams = m_array.GetSize();
	for (INT_PTR iParam=0; iParam < nParams; ++iParam) {
		CSignatureElement* pse = (CSignatureElement*) (void*) m_array[iParam];
		delete pse;
	}
}

CSignatureElement& CSignatureArray::operator[](int iIndex)
{
	return *(CSignatureElement*) (void*) m_array[iIndex];
}


SCODE CSignatureArray::AddParameter(IWbemClassObject* pco, LPCTSTR pszName)
{

	static COleVariant varIdQual(_T("ID"));
	static COleVariant varInQual(_T("IN"));
	static COleVariant varOutQual(_T("OUT"));
	static COleVariant varDescriptionQual(_T("DESCRIPTION"));
	static COleVariant varCimtypeQual(_T("CIMTYPE"));

	COleVariant varIdValue;
	COleVariant varInValue;
	COleVariant varOutValue;
	COleVariant varDescriptionValue;
	COleVariant varCimtypeValue;
	COleVariant varPropName(pszName);
	CSignatureElement* pse = NULL;


	IWbemQualifierSet* pqs;
	SCODE sc = pco->GetPropertyQualifierSet(varPropName.bstrVal, &pqs);
	if (FAILED(sc)) {
		return sc;
	}


	// Get a pointer to place to deposit the parameter info.  This will
	// either be an element of the array or m_seRetVal for the return
	// value.
	long lFlavor = 0;
	if (_tcscmp(pszName, _T("ReturnValue")) == 0) {
		pse = &m_seRetValue;
		pse->m_id = 0;
	}
	else {
		sc = pqs->Get(varIdQual.bstrVal, 0, &varIdValue, &lFlavor);
		if (FAILED(sc)) {
			pqs->Release();
			return E_FAIL;
		}

		// Get the parameter ID
		sc = pqs->Get(varIdQual.bstrVal, 0, &varIdValue, &lFlavor);
		if (FAILED(sc)) {
			pqs->Release();
			return E_FAIL;
		}


		ASSERT(varIdValue.vt == VT_I4);
		if (varIdValue.vt != VT_I4) {
			varIdValue.ChangeType(VT_I4);
		}
		if (varIdValue.vt != VT_I4) {
			pqs->Release();
			return E_FAIL;
		}

		// Look to see if the parameter is already in the array.  If so, do nothing.
		INT_PTR nParams = m_array.GetSize();
		INT_PTR iParam;
		for (iParam=0; iParam<nParams; ++iParam) {
			CSignatureElement* pseFromArray = (CSignatureElement*) (void*) m_array[iParam];
			if (pseFromArray->m_id == varIdValue.iVal) {
				// The parameter is already in the array.
				pqs->Release();
				return S_OK;
			}
		}



		// Create a new new parameter, load it with information and add it to the
		// array
		pse = new CSignatureElement;
		pse->m_id = varIdValue.iVal;


		// Insert the parameter into the array or add it to the end.  The array is
		// sorted in ascending order using "id" as the key.
		BOOL bDidInsert = FALSE;
		for (iParam=0; iParam<nParams; ++iParam) {
			CSignatureElement* pseFromArray = (CSignatureElement*) (void*) m_array[iParam];
			if (pseFromArray->m_id >= pse->m_id) {
				m_array.InsertAt(iParam, (void*) pse);
				bDidInsert = TRUE;
				break;
			}
		}

		if (!bDidInsert) {
			// Add the new parameter to the end of the array if it has
			// the largest id value.
			m_array.SetAtGrow(nParams, (void*) pse);
		}
	}



	pse->m_sName = pszName;


	sc = pqs->Get(varInQual.bstrVal, 0, &varInValue, &lFlavor);
	if (SUCCEEDED(sc)) {
		if (varInValue.vt == VT_BOOL) {
			if (varInValue.boolVal) {
				pse->m_bIsInParameter = TRUE;
			}
		}
	}



	sc = pqs->Get(varOutQual.bstrVal, 0, &varOutValue, &lFlavor);
	if (SUCCEEDED(sc)) {
		if (varOutValue.vt == VT_BOOL) {
			if (varOutValue.boolVal) {
				pse->m_bIsOutParameter = TRUE;
			}
		}
	}

	sc = pqs->Get(varDescriptionQual.bstrVal, 0, &varDescriptionValue, &lFlavor);
	if (SUCCEEDED(sc)) {
		if (varDescriptionValue.vt == VT_BSTR) {
			pse->m_sDescription = varDescriptionValue.bstrVal;
		}
	}


	sc = pqs->Get(varCimtypeQual.bstrVal, 0, &varCimtypeValue, &lFlavor);
	if (SUCCEEDED(sc)) {
		if (varCimtypeValue.vt == VT_BSTR) {
			pse->m_sCimtype = varCimtypeValue.bstrVal;
		}
		else {
			pse->m_sCimtype = _T("void");
		}
	}
	else {
		pse->m_sCimtype = _T("void");
	}

	pqs->Release();

	return S_OK;
}

CSignatureElement::CSignatureElement()
{
	m_id = 0;
	m_bIsOutParameter = FALSE;
	m_bIsInParameter = FALSE;
	m_sCimtype = _T("void");

}






void CDlgHelpBox::OnSize(UINT nType, int cx, int cy)
{
	CDialog::OnSize(nType, cx, cy);

	if (m_bCaptureWindowRect && ::IsWindow(m_pedit->m_hWnd)) {
		CRect rcClient;
		GetWindowRect(m_rcWindowSave);
		GetClientRect(rcClient);
//		m_pedit->MoveWindow(rcClient);
		m_pedit->SetWindowPos(NULL, 0, 0, rcClient.right, rcClient.bottom, SWP_NOZORDER | SWP_DRAWFRAME);
		m_pedit->Invalidate(FALSE);
		InvalidateRect(NULL, FALSE);
	}
	// TODO: Add your message handler code here

}

void CDlgHelpBox::OnMove(int x, int y)
{
	CDialog::OnMove(x, y);

	if (m_bCaptureWindowRect && ::IsWindow(m_pedit->m_hWnd)) {
		GetWindowRect(m_rcWindowSave);
	}
}







//**********************************************************
// CDlgHelpBox::ShowHelpForClass
//
// This method is called to display the help dialog for the
// specified class.
//
// Parameters:
//		[in] CWBEMViewContainerCtrl* phmmv
//			Pointer to the view container control.
//
//		[in] LPCTSTR pszClassPath
//			The WBEM path to the class or instance containing the
//			description text in its "description" qualifiers.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CDlgHelpBox::ShowHelpForClass(CWBEMViewContainerCtrl* phmmv, LPCTSTR pszClassPath)
{
	m_phmmv = phmmv;
	m_sPath = pszClassPath;
	m_bCaptureWindowRect = FALSE;
	CWnd* pwndFocus = GetFocus();
	DoModal();
	if (pwndFocus) {
		pwndFocus->SetFocus();
	}
}


//**********************************************************
// CDlgHelpBox::ExpandParagraphMarkers
//
// The description text may contain "<P>" commands to
// separate paragraphs.  These are converted into
// a couple of carriage return line feed pairs.
//
// Parameters:
//		[in, out] CString& sText
//			The paragraph markers in sText are expanded.
//
// Returns:
//		Nothing.
//
//***********************************************************
void CDlgHelpBox::ExpandParagraphMarkers(CString& sText)
{
	CString sTemp;
	int iParaMarker;

	while(TRUE) {
		iParaMarker = sText.Find(_T("<P>"));
		if (iParaMarker == -1) {
			iParaMarker = sText.Find(_T("<p>"));
		}
		if (iParaMarker == -1) {
			sTemp += sText;
			if (!sTemp.IsEmpty()) {
				sText = sTemp;
			}
			break;
		}
		sTemp = sText.Left(iParaMarker);
		sTemp += _T("\r\n\r\n");
		sText = sText.Right(sText.GetLength() - (iParaMarker + 3));
	}
}










/*
#ifdef 0
class CSelection
{
public:
	CSelection(CWBEMViewContainerCtrl* phmmv);
	~CSelection();
	SCODE ConnectServer(LPCTSTR pszPath, IWbemServices** ppsvc);
	SCODE GetObjectFromPath(LPCTSTR pszPath, IWbemClassObject** ppco);

private:
	SCODE ServerAndNamespaceFromPath(COleVariant& varServer, COleVariant& varNamespace, BSTR bstrPath);
	COleVariant m_varServer;
	COleVariant m_varNamespace;
	CWBEMViewContainerCtrl* m_phmmv;
	IWbemServices* m_psvc;
};





CSelection::CSelection(CWBEMViewContainerCtrl* phmmv)
{
	m_phmmv = phmmv;
	m_varServer = _T("");
	m_varNamespace = _T("");
	m_psvc = NULL;
}

CSelection::~CSelection()
{
	if (m_psvc) {
		m_psvc->Release();
	}
}


//*****************************************************************
// CSelection::ConnectServer
//
// Call this method to connect to the HMOM Server.
//
// Parameters:
//		LPCTSTR pszPath
//			The object path.
//
//		IWbemServices** ppsvc
//			The services pointer is returned here.
//			The initial value is overwritten and will not be released.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise the HMOM status code.
//
//******************************************************************
SCODE CSelection::ConnectServer(LPCTSTR pszPath, IWbemServices** ppsvc)
{
	*ppsvc = NULL;

	COleVariant varPath;
	varPath = pszPath;

	// Currently a fully qualified path must be specified.
	COleVariant varServer;
	COleVariant varNamespace;
	SCODE sc;
	sc = ServerAndNamespaceFromPath(varServer, varNamespace, varPath.bstrVal);

	if (FAILED(sc)) {
		return E_FAIL;
	}


	if (varServer.vt == VT_NULL || varServer.bstrVal ==NULL) {
		varServer = ".";
	}

	if (varNamespace.vt == VT_NULL || varNamespace.bstrVal == NULL) {
		if (m_varNamespace.vt == VT_NULL || m_varNamespace.bstrVal == NULL) {
			return E_FAIL;
		}
		varNamespace = m_varNamespace;
	}



	// Release the current provider if we are already connected.
	if (m_psvc != NULL) {
		if (IsEqual(m_varServer.bstrVal, varServer.bstrVal)) {
			if (IsEqual(m_varNamespace.bstrVal, varNamespace.bstrVal)) {
				// Already connected to the same server and namespace.
				*ppsvc = m_psvc;
				return S_OK;
			}
		}

		m_psvc->Release();
		m_psvc = NULL;
		m_varNamespace.Clear();
		m_varServer.Clear();
	}

	m_varServer = varServer;
	m_varNamespace = varNamespace;
	if (m_varNamespace.vt==VT_BSTR && *m_varNamespace.bstrVal == 0) {
		m_varNamespace = m_varNamespace;
	}


	CString sServicesPath;
	sServicesPath = "\\\\";
	sServicesPath += varServer.bstrVal;
	if (*varNamespace.bstrVal) {
		sServicesPath += "\\";
		sServicesPath += varNamespace.bstrVal;
	}


	COleVariant varUpdatePointer;
	COleVariant varService;
	COleVariant varSC;
	COleVariant varUserCancel;

	varUpdatePointer.ChangeType(VT_I4);
	varUpdatePointer.lVal = FALSE;
	m_phmmv->PassThroughGetIHmmServices((LPCTSTR) sServicesPath,  &varUpdatePointer, &varService, &varSC, &varUserCancel);


	sc = E_FAIL;
	if (varSC.vt & VT_I4)
	{
		sc = varSC.lVal;
	}


	BOOL bCanceled = FALSE;
	if (varUserCancel.vt & VT_BOOL)
	{
		bCanceled  = varUserCancel.boolVal;
	}


	if ((sc == S_OK) &&
		!bCanceled &&
		(varService.vt & VT_UNKNOWN)){
		m_psvc = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}
	varService.punkVal = NULL;
	VariantClear(&varService);

	*ppsvc = m_psvc;
	return sc;
}





//***************************************************************************
// ServerAndNamespaceFromPath
//
// Extract the server name and namespace from a path if these path components
// present.
//
// Parameters:
//		[out] COleVariant& varServer
//			The server name value is returned here.
//
//		[out] COleVaraint& varNamespace
//			The namespace value is returned here.
//
//		[in] BSTR bstrPath
//			The path to parse.
//
// Returns:
//		SCODE
//			S_OK if the path was parsed successfully, a failure code otherwise.
//
//*****************************************************************************
SCODE CSelection::ServerAndNamespaceFromPath(COleVariant& varServer, COleVariant& varNamespace, BSTR bstrPath)
{
	SCODE sc = S_OK;
	ParsedObjectPath* pParsedPath = NULL;

	varServer.Clear();
	varNamespace.Clear();

    int iStatus = parser.Parse(bstrPath,  &pParsedPath);
	if (iStatus != 0) {
		return E_FAIL;
	}

	if (pParsedPath->m_pServer) {
		varServer = pParsedPath->m_pServer;
	}


	CString sNamespace;
	if (pParsedPath->m_dwNumNamespaces > 0) {
		for (DWORD dwNamespace=0; dwNamespace < pParsedPath->m_dwNumNamespaces; ++dwNamespace) {
			sNamespace = sNamespace + pParsedPath->m_paNamespaces[dwNamespace];
			if (dwNamespace < (pParsedPath->m_dwNumNamespaces - 1)) {
				sNamespace += _T("\\");
			}
		}
		varNamespace = sNamespace;
	}

	parser.Free(pParsedPath);
	return S_OK;
}

//******************************************************************
// CSelection::GetObjectFromPath
//
//
// Parameters:
//
// Returns:
//		SCODE
//			S_OK if the jump was completed, a failure code otherwise.
//
//******************************************************************
SCODE CSelection::GetObjectFromPath(LPCTSTR pszPath, IWbemClassObject** ppco)
{
	*ppco = NULL;
	if (m_psvc == NULL) {
		return E_FAIL;
	}

	COleVariant varPath;
	varPath = pszPath;

	// Get the new object from HMOM
	SCODE sc;
	sc = m_psvc->GetObject(varPath.bstrVal,  WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, ppco, NULL);
	if (FAILED(sc)) {
		return sc;
	}

	return sc;

}


#endif //0
  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\filters.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// filters.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgFilters dialog

class CWBEMViewContainerCtrl;
class CDlgFilters : public CDialog
{
// Construction
public:
	CDlgFilters(CWBEMViewContainerCtrl* phmmv);   // standard constructor
	long FindView(long lView);


// Dialog Data
	//{{AFX_DATA(CDlgFilters)
	enum { IDD = IDD_FILTERS };
	CListBox	m_lcFilters;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgFilters)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgFilters)
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkFilterList();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CWBEMViewContainerCtrl* m_phmmv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\globals.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _globals_h
#define _globals_h


#define SZ_MODULE_NAME "hmmv.ocx"

extern int HmmvMessageBox(CWBEMViewContainerCtrl* phmmv, LPCTSTR szMessage, UINT uType);
extern int HmmvMessageBox(CWBEMViewContainerCtrl* phmmv, UINT idsMessage, UINT uType);
#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\globals.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include "resource.h"
#include "hmmvctl.h"


static CString sHmmvMessageCaption;
static BOOL bDidLoadMessageCaption = FALSE;



//****************************************************************
// HmmvMessageBox
//
// Display a message box with the normal caption for the object viewer.
//
// Parameters:
//		[in] COleControl* pcontrol
//			The OLE control (
//		[in] LPCTSTR szMessage
//			The message to display.
//
//		[in] uType
//			The message box type.
//
// Returns:
//		The return code from ::MessageBox
//
//****************************************************************
int HmmvMessageBox(CWBEMViewContainerCtrl* phmmv, LPCTSTR szMessage, UINT uType)
{
	int iStatus;

	if (!bDidLoadMessageCaption) {
		sHmmvMessageCaption.LoadString(IDS_HMMV_MESSAGE_CAPTION);
		bDidLoadMessageCaption = TRUE;
	}

	phmmv->PreModalDialog( );
	HWND hwndFocus = ::GetFocus();
	iStatus = ::MessageBox(phmmv->m_hWnd, szMessage, (LPCTSTR) sHmmvMessageCaption, uType);
	if (::IsWindow(hwndFocus)) {
		::SetFocus(hwndFocus);
	}
	phmmv->PostModalDialog();
	return iStatus;
}


//****************************************************************
// HmmvMessageBox
//
// Display a message box with the normal caption for the object viewer.
//
// Parameters:
//		[in] UINT idsMessage
//			The resource ID of the message to display.
//
//		[in] uType
//			The message box type.
//
// Returns:
//		The return code from ::MessageBox
//
//****************************************************************
int HmmvMessageBox(CWBEMViewContainerCtrl* phmmv, UINT idsMessage, UINT uType)
{

	CString sMessage;
	sMessage.LoadString(idsMessage);

	return HmmvMessageBox(phmmv, (LPCTSTR) sMessage, uType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\hmmv.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// hmmv.cpp : Implementation of CWBEMViewContainerApp and DLL registration.

#include "precomp.h"
#include "hmmv.h"
#include "CatHelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



CWBEMViewContainerApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x5b3572a8, 0xd344, 0x11cf, { 0x99, 0xcb, 0, 0xc0, 0x4f, 0xd6, 0x44, 0x97 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const GUID CDECL BASED_CODE _ctlid =   { 0x5b3572ab, 0xd344, 0x11cf, { 0x99, 0xcb, 0, 0xc0, 0x4f, 0xd6, 0x44, 0x97 } };
const CATID CATID_SafeForScripting     =
   {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing  =
   {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};


////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerApp::InitInstance - DLL initialization

BOOL CWBEMViewContainerApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	m_hmod = GetModuleHandle(NULL);

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}


	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerApp::ExitInstance - DLL termination

int CWBEMViewContainerApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	if (FAILED( CreateComponentCategory(CATID_SafeForScripting,
               L"Controls that are safely scriptable") ))
             return ResultFromScode(SELFREG_E_CLASS);
	if (FAILED( CreateComponentCategory(
           CATID_SafeForInitializing,
           L"Controls safely initializable from persistent data") ))
         return ResultFromScode(SELFREG_E_CLASS);
	if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForScripting) ))
         return ResultFromScode(SELFREG_E_CLASS);
	if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForInitializing) ))
         return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);





	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\hmmv.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// hmmv.h : main header file for HMMV.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerApp : See hmmv.cpp for implementation.

class CWBEMViewContainerApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
	HMODULE m_hmod;
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

extern CWBEMViewContainerApp theApp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\hmmverr.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
// (c) 1996, 1997 by Microsoft Corporation
//
// error.cpp
//
// This file contains the interface to the error handling dialog, error log, and so on.
//
//  a-larryf    08-April-97   Created.
//
//***************************************************************************


#include "precomp.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "hmmverr.h"
#include <MsgDlgExterns.h>

//*********************************************************************
// HmmvReleaseErrorObject
//
// Releases an error object if it hasn't already been released.
//
// Parameters:
//		[in/out] IHmmCallResult *&  pcoError
//			A reference to the error object pointer.
//
//	Returns:
//		Nothing.
//
//********************************************************************
void HmmvReleaseErrorObject(IWbemCallResult *&  pcoError)
{
	if (pcoError)
	{
		pcoError->Release();
		pcoError = NULL;
	}
}


//********************************************************************************
// LogMsg
//
// Write an entry in the error log.
//
// Parameters:
//		[in] LPCTSTR szMessage
//			The error message string.
//
//		[in] LPCTSTR szFile
//			The file where the error occurred.
//
//		[in] int nLine
//			The line number where the error occurred.
//
// Returns:
//		Nothing.
//
//************************************************************************************
static void LogMsg(LPCTSTR szMessage, LPCTSTR szFile, int nLine)
{

}


//*******************************************************************************
// ErrorMsg
//
// Display an error dialog and write an entry in the error log.
//
// Parameters:
//		[in] LPCTSTR szUserMsg
//			The user message to display in the dialog box.
//
//		[in] BOOL bUseErrorobject
//			TRUE if the message dialog should get and use the HMOM error object.
//
//		[in] SCODE sc
//			The HMOM status code.
//
//		[in] LPCTSTR szLogMsg
//			The message to write to the log.  This parameter needs to be valid only
//			if bLog is TRUE.
//
//		[in] LPCTSTR szFile
//			The file where the error occurred.  This parameter needs to be valid only
//			if bLog is TRUE.
//
//		[in] int nLine
//			The line where the error occurred.  This parameter needs to be valid only
//			if bLog is TRUE.
//
//		[in] BOOL bLog
//			TRUE to write a message to the log file.
//
// Returns:
//			Nothing.
//
//*************************************************************************************************
void HmmvErrorMsgStr(
		LPCTSTR szUserMsg,
		SCODE sc,
		BOOL bUseErrorObject,
		LPCTSTR szLogMsg,
		LPCTSTR szFile,
		int nLine,
		BOOL bLog
)
{

	CString sUserMsg(szUserMsg);
	BSTR bstrUserMsg = sUserMsg.AllocSysString();

	HWND hwndFocus = ::GetFocus();
	DisplayUserMessage(L"WMI Object Viewer", bstrUserMsg, sc, bUseErrorObject);

	::SysFreeString(bstrUserMsg);
	if (::IsWindow(hwndFocus)) {
		::SetFocus(hwndFocus);
	}

	if (bLog)
	{
		LogMsg(szLogMsg,  szFile, nLine);
	}
}


//*******************************************************************************
// ErrorMsg
//
// This function is the same as the previous ErrorMsg except that it
// takes a string resource ID as its first parameter rather than a
// string pointer.
//
// Parameters:
//		Same as ErrorMsg above except for idsUserMsg which is
//		the resource id of the error message string.
//
// Returns:
//		Nothing.
//
//*********************************************************************************
extern void HmmvErrorMsg(
		UINT idsUserMsg,
		SCODE sc,
		BOOL bUseErrorObject,
		LPCTSTR szLogMsg,
		LPCTSTR szFile,
		int nLine,
		BOOL bLog)
{
	HWND hwndFocus1 = ::GetFocus();

	CString sUserMsg;
	sUserMsg.LoadString(idsUserMsg);
	HmmvErrorMsgStr((LPCTSTR) sUserMsg, sc, bUseErrorObject, szLogMsg, szFile, nLine, bLog);

	// Check to see if the focus changed.  If so, attempt to restore it
	// back to the original state.
	if (::IsWindow(hwndFocus1)) {
		::SetFocus(hwndFocus1);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\hmmvctl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
// (c) 1996, 1997 by Microsoft Corporation
//
// hmmvctl.h
//
// This file contains the implementation of the main view container as well
// as the generic view.
//
//
//  a-larryf    17-Sept-96   Created.
//
//***************************************************************************

#ifndef _HmmvCtl_h
#define _HmmvCtl_h


/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerCtrl : See HmmvCtl.cpp for implementation.

#include <afxcmn.h>
#include <afxwin.h>

#include "notify.h"
#include "utils.h"

class CTitleBar;
class CIcon;
class CWBEMViewContainerCtrl;
class CViewStack;
class CIconSource;

class CMultiView;
class CSingleView;
class CPolyView;
class CDlgHelpBox;


#define CX_ICON 32
#define CY_ICON 32
#define CX_SMALL_ICON 16
#define CY_SMALL_ICON 16

#define CY_FONT 15

class CHmmvTab;


#define PROPFILTER_SYSTEM		1
#define PROPFILTER_INHERITED	2
#define PROPFILTER_LOCAL		4


class CContainerContext
{
public:
	BOOL m_bIsShowingMultiView;
	BOOL m_bObjectIsNewlyCreated;
	BOOL m_bEmptyContainer;
	HWND m_hwndFocus;
};




class CGenericViewContext
{
public:
	CGenericViewContext(CSingleView* psv) {m_lContextHandle = NULL; }
	~CGenericViewContext();
	long m_lContextHandle;

private:
	CSingleView* m_psv;
};

enum IconSize;

class CWBEMViewContainerCtrl : public COleControl
{
	DECLARE_DYNCREATE(CWBEMViewContainerCtrl)

// Constructor
public:
	CWBEMViewContainerCtrl();
//	void TestShowInstances();
	CWnd* ReestablishFocus();


	///////////////////////////////////////////////////////////
	// These methods implement polymorphism for the views.
	//


	void RequestUIActive();
	virtual DWORD GetActivationPolicy( );
	virtual DWORD GetControlFlags( );
	void SelectView(long lPosition);

	CPolyView* GetView() {return m_pview; }
	void Notify(LONG lEvent);
//	void SetPropertyFilters(long lPropFilters);
//	long GetPropertyFilters() {return m_lPropFilters; }

	long PublicSaveState(BOOL bPromptUser, UINT nType); 

//	virtual BOOL PreTranslateMessage(MSG* pMsg);
	void NotifyDataChange();
	LPTSTR MessageBuffer() {return m_szMessageBuffer; }
	void Clear(BOOL bRedrawWindow=TRUE);
	SCODE JumpToObjectPathFromMultiview(LPCTSTR szObjectPath, BOOL bSetMultiviewClass, BOOL bAddToHistory=TRUE);
	SCODE JumpToObjectPath(BSTR bstrObjectPath, BOOL bSetMultiviewClass, BOOL bAddToHistory=TRUE);
	BOOL InStudioMode() {return m_bInStudioMode; }
	SCODE NotifyInstanceDeleted(COleVariant& varObjectPath) { return S_OK; }
	void NotifyContainerOfSelectionChange();
	BOOL CustomViewIsRegistered(CLSID& clsid, DWORD dwVersionMS, DWORD dwVersionLS);
	void PassThroughChangeRootOrNamespace(LPCTSTR szRootOrNamespace, long bChangeNamespace, long bEchoSelectObject) {FireNOTIFYChangeRootOrNamespace(szRootOrNamespace, bChangeNamespace, bEchoSelectObject); }
	void PassThroughGetIHmmServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);

	CFont& GetFont() {return m_font; }
	void MultiViewButtonClicked();
	void InvalidateControlRect(CRect* prc);
	BOOL ShowMultiView(BOOL bShowMultiView, BOOL bAddToHistory);
	BOOL ShowSingleView(BOOL bShowSingleView, BOOL bAddToHistory) {return ShowMultiView(!bShowSingleView, bAddToHistory); }
	BOOL m_bPathIsClass;
	void CreateInstance();
	void DeleteInstance();
	void GetWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel);




	// Context stack api.
	void PushView();
	void UpdateViewContext();
	SCODE ContextForward();
	SCODE ContextBack();
	BOOL QueryCanContextForward();
	BOOL QueryCanContextBack();
	void UpdateCreateDeleteButtonState();
	void GetContainerContext(CContainerContext& ctx);
	SCODE SetContainerContextPrologue(CContainerContext& ctx);
	SCODE SetContainerContextEpilogue(CContainerContext& ctx);
	void ClearGenericView() {Clear(); }
	BOOL ObjectIsNewlyCreated(SCODE& sc);


	
	void PublicShowInstances(LPCTSTR pszTitle, const VARIANT FAR& varPathArray){ShowInstances(pszTitle, varPathArray); }
	void UpdateToolbar();
	void OnDrawPreCreate(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	void InvokeHelp();
	void Query();
	BOOL IsEmptyContainer(){return m_bEmptyContainer; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWBEMViewContainerCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
//	afx_msg void OnContextMenu(CWnd*, CPoint point);
	BOOL m_bCreationFinished;

	~CWBEMViewContainerCtrl();

	DECLARE_OLECREATE_EX(CWBEMViewContainerCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CWBEMViewContainerCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CWBEMViewContainerCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CWBEMViewContainerCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CWBEMViewContainerCtrl)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnCmdShowObjectAttributes();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
public:
// Dispatch maps
	//{{AFX_DISPATCH(CWBEMViewContainerCtrl)
	long m_sc;
	afx_msg void OnStatusCodeChanged();
	afx_msg VARIANT GetObjectPath();
	afx_msg void SetObjectPath(const VARIANT FAR& newValue);
	afx_msg BSTR GetNameSpace();
	afx_msg void SetNameSpace(LPCTSTR lpszNewValue);
	afx_msg long GetStudioModeEnabled();
	afx_msg void SetStudioModeEnabled(long nNewValue);
	afx_msg long GetPropertyFilter();
	afx_msg void SetPropertyFilter(long nNewValue);
	afx_msg void ShowInstances(LPCTSTR szTitle, const VARIANT FAR& varPathArray);
	afx_msg long SaveState(long bPromptUser, long bUserCanCancel);
	afx_msg void QueryViewInstances(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
protected:
// Event maps
	//{{AFX_EVENT(CWBEMViewContainerCtrl)
	void FireGetIWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel)
		{FireEvent(eventidGetIWbemServices,EVENT_PARAM(VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT), szNamespace, pvarUpdatePointer, pvarServices, pvarSc, pvarUserCancel);}
	void FireNOTIFYChangeRootOrNamespace(LPCTSTR szRootOrNamespace, long bChangeNamespace, long bEchoSelectObject)
		{FireEvent(eventidNOTIFYChangeRootOrNamespace,EVENT_PARAM(VTS_BSTR  VTS_I4  VTS_I4), szRootOrNamespace, bChangeNamespace, bEchoSelectObject);}
	void FireRequestUIActive()
		{FireEvent(eventidRequestUIActive,EVENT_PARAM(VTS_NONE));}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CWBEMViewContainerCtrl)
	dispidObjectPath = 2L,
	dispidStatusCode = 1L,
	dispidNameSpace = 3L,
	dispidStudioModeEnabled = 4L,
	dispidPropertyFilter = 5L,
	dispidShowInstances = 6L,
	dispidSaveState = 7L,
	dispidQueryViewInstances = 8L,
	eventidGetIWbemServices = 1L,
	eventidNOTIFYChangeRootOrNamespace = 2L,
	eventidRequestUIActive = 3L,
	//}}AFX_DISP_ID
	};


public:
	void DrawBackground(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	void CalcViewRect(CRect& rcView);
	void CalcTitleRect(CRect& rcTitle);
	BOOL IsInSchemaStudioMode() {return TRUE; }

	//	void GetObjectByPath(IHmmServices * pProv);
	COleVariant m_varObjectPath;

	SCODE m_scResult;
	CString m_sTitle;
	CFont m_font;
	BOOL m_bDidInitialDraw;
	CTitleBar* m_pTitleBar;

	// Generic view
//	void UseClonedObject(IHmmClassObject* pcoClone);


	int m_cxViewLeftMargin;
	int m_cxViewRightMargin;
	int m_cyViewTopMargin;
	int m_cyViewBottomMargin;


private:

	void GetHmomWorkingDirectory();
	inline BOOL IsValidWindowPtr(CWnd* pwnd);
	HINSTANCE m_htmlHelpInst;
	void OnHelp();


	SCODE GetCurrentClass(COleVariant& varClassName);


	// Common message buffer scratch area for user messages
	TCHAR m_szMessageBuffer[1024];

	CString m_sNameSpace;
	CViewStack* m_pViewStack;
	CString m_sNewInstClassPath;	
	BOOL m_bObjectIsNewlyCreated;
	BOOL m_bInStudioMode;
	CDlgHelpBox* m_pdlgHelpBox;

	friend class CViewStack;

	CPolyView* m_pview;
	BOOL m_bFiredReadyStateChange;
	BOOL m_bUIActive;
	long m_lPropFilters;
	BOOL m_bSingleViewNeedsRefresh;
	BOOL m_bEmptyContainer;
	BOOL m_bDelayToolbarUpdate;
	BOOL m_bDeadObject;

};


//***********************************************************
// CWBEMViewContainerCtrl::IsValidWindowPtr
//
// Check to see if the window pointer is valid (not NULL and
// has a valid m_hWnd).
//
// Parameters:
//		CWnd* pwnd
//
// Returns:
//		TRUE if the window pointer is valid, FALSE otherwise.
//
//**********************************************************
BOOL CWBEMViewContainerCtrl::IsValidWindowPtr(CWnd* pwnd)
{
	if (pwnd!=NULL && pwnd->m_hWnd!=NULL) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}



#endif //_HmmvCtl_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\graph.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































