rface negotiation of the container Site.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK           -   The interface is supported.
//      E_NOINTERFACE  -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      CSimpleSite::AddRef         OBJ.CPP
//      COleClientSite::AddRef      IOCS.CPP
//      CAdviseSink::AddRef         IAS.CPP
//      COleInPlaceSite::AddRef     IOIPS.CPP
//
//
//********************************************************************

STDMETHODIMP CSimpleSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CSimpleSite::QueryInterface\r\n"));

    *ppvObj = NULL;     // must set out pointer parameters to NULL

    if ( IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return ResultFromScode(S_OK);
    }

    if ( IsEqualIID(riid, IID_IOleClientSite))
    {
        m_OleClientSite.AddRef();
        *ppvObj = &m_OleClientSite;
        return ResultFromScode(S_OK);
    }

    if ( IsEqualIID(riid, IID_IAdviseSink))
    {
        m_AdviseSink.AddRef();
        *ppvObj = &m_AdviseSink;
        return ResultFromScode(S_OK);
    }

    if ( IsEqualIID(riid, IID_IOleInPlaceSite))
    {
        m_OleInPlaceSite.AddRef();
        *ppvObj = &m_OleInPlaceSite;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleSite::AddRef
//
// Purpose:
//
//      Increments the reference count of the container Site.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the site.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::AddRef()
{
    TestDebugOut(TEXT("In CSimpleSite::AddRef\r\n"));

    return ++m_nCount;
}

//**********************************************************************
//
// CSimpleSite::Release
//
// Purpose:
//
//      Decrements the reference count of the container Site
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the Site.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::Release()
{
    TestDebugOut(TEXT("In CSimpleSite::Release\r\n"));

    if (--m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}

//**********************************************************************
//
// CSimpleSite::InitObject
//
// Purpose:
//
//      Used to initialize a newly create object (can't be done in the
//      constructor).
//
// Parameters:
//
//      BOOL fCreateNew -   TRUE if insert NEW object
//                          FALSE if create object FROM FILE
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::SetHostNames        Object
//      IOleObject::QueryInterface      Object
//      IViewObject2::GetExtent         Object
//      IOleObject::DoVerb              Object
//      IViewObject2::SetAdvise         Object
//      IViewObject2::Release           Object
//      GetClientRect                   Windows API
//      OleSetContainedObject           OLE API
//
//
//********************************************************************

void CSimpleSite::InitObject(BOOL fCreateNew)
{
    LPVIEWOBJECT2 lpViewObject2;
    RECT rect;

    TestDebugOut(TEXT("In CSimpleSite::InitObject\r\n"));

    // Set a View Advise
    m_lpOleObject->QueryInterface(IID_IViewObject2,
                                  (LPVOID FAR *)&lpViewObject2);
    lpViewObject2->SetAdvise(m_dwDrawAspect, ADVF_PRIMEFIRST, &m_AdviseSink);

    // get the initial size of the object
    lpViewObject2->GetExtent(m_dwDrawAspect, -1 /*lindex*/, NULL /*ptd*/,
                             &m_sizel);
    GetObjRect(&rect);  // get the rectangle of the object in pixels
    lpViewObject2->Release();

    // give the object the name of the container app/document
    m_lpOleObject->SetHostNames(OLESTR("Simple Application"),
                                OLESTR("Simple OLE 2.0 In-Place Container"));

    // inform object handler/DLL object that it is used in the embedding
    // container's context
    HRESULT hRes;
    if ((hRes = OleSetContainedObject(m_lpOleObject, TRUE))
        != ResultFromScode(S_OK) )
    {
       TestDebugOut(TEXT("Fail in OleSetContainedObject\n"));
    }

    if (fCreateNew)
    {
       // force new object to save to guarantee valid object in our storage.
       // OLE 1.0 objects may close w/o saving. this is NOT necessary if the
       // object is created FROM FILE; its data in storage is already valid.
       m_OleClientSite.SaveObject();

       // we only want to DoVerb(SHOW) if this is an InsertNew object.
       // we should NOT DoVerb(SHOW) if the object is created FromFile.
       m_lpOleObject->DoVerb(
               OLEIVERB_SHOW,
               NULL,
               &m_OleClientSite,
               -1,
               m_lpDoc->m_hDocWnd,
               &rect);
    }
}

//**********************************************************************
//
// CSimpleSite::PaintObj
//
// Purpose:
//
//      Paints the object
//
// Parameters:
//
//      HDC hDC     - Device context of the document window
//
// Return Value:
//      None
//
// Function Calls:
//      Function                        Location
//
//      CSimpleSite::GetObjRect         SITE.CPP
//      IOleObject::QueryInterface      Object
//      IViewObject::GetColorSet        Object
//      IViewObject::Release            Object
//      SetROP2                         Windows API
//      Rectamgle                       Windows API
//      CreateHatchBrush                Windows API
//      SelectObject                    Windows API
//      DeleteObject                    Windows API
//      CreatePalette                   Windows API
//      SelectPalette                   Windows API
//      RealizePalette                  Windows API
//      OleStdFree                      OLE2UI Function
//      OleDraw                         OLE API
//
//
//********************************************************************

void CSimpleSite::PaintObj(HDC hDC)
{
    RECT rect;

    // need to check to make sure there is a valid object
    // available.  This is needed if there is a paint msg
    // between the time that CSimpleSite is instantiated
    // and OleUIInsertObject returns.
    if (!m_lpOleObject)
        return;

    // convert it to pixels
    GetObjRect(&rect);

    LPLOGPALETTE pColorSet = NULL;
    LPVIEWOBJECT lpView = NULL;

    // get a pointer to IViewObject
    m_lpOleObject->QueryInterface(IID_IViewObject,(LPVOID FAR *) &lpView);

    // if the QI succeeds, get the LOGPALETTE for the object
    if (lpView)
        lpView->GetColorSet(m_dwDrawAspect, -1, NULL, NULL, NULL, &pColorSet);

    HPALETTE hPal=NULL;
    HPALETTE hOldPal=NULL;

    // if a LOGPALETTE was returned (not guarateed), create the palette and
    // realize it.NOTE:A smarter application would want to get the LOGPALETTE
    // for each of its visible objects, and try to create a palette that
    // satisfies all of the visible objects.  ALSO: OleStdFree() is use to
    // free the returned LOGPALETTE.
    if ((pColorSet))
    {
        hPal = CreatePalette((const LPLOGPALETTE) pColorSet);
        hOldPal = SelectPalette(hDC, hPal, FALSE);
        RealizePalette(hDC);
        OleStdFree(pColorSet);
    }

    // draw the object
    HRESULT hRes;
    hRes = OleDraw(m_lpOleObject, m_dwDrawAspect, hDC, &rect);
    if ((hRes != ResultFromScode(S_OK)) &&
        (hRes != ResultFromScode(OLE_E_BLANK)) &&
        (hRes != ResultFromScode(DV_E_NOIVIEWOBJECT)))
    {
       TestDebugOut(TEXT("Fail in OleDraw\n"));
    }

    // if the object is open, draw a hatch rect.
    if (m_fObjectOpen)
    {
        HBRUSH hBrush = CreateHatchBrush ( HS_BDIAGONAL, RGB(0,0,0) );
        HBRUSH hOldBrush = (HBRUSH) SelectObject (hDC, hBrush);
        SetROP2(hDC, R2_MASKPEN);
        Rectangle (hDC, rect.left, rect.top, rect.right, rect.bottom);
        SelectObject(hDC, hOldBrush);
        DeleteObject(hBrush);
    }

    // if we created a palette, restore the old one, and destroy
    // the object.
    if (hPal)
    {
        SelectPalette(hDC,hOldPal,FALSE);
        DeleteObject(hPal);
    }

    // if a view pointer was successfully returned, it needs to be released.
    if (lpView)
        lpView->Release();
}

//**********************************************************************
//
// CSimpleSite::GetObjRect
//
// Purpose:
//
//      Retrieves the rect of the object in pixels
//
// Parameters:
//
//      LPRECT lpRect - Rect structure filled with object's rect in pixels
//
// Return Value:
//      None
//
// Function Calls:
//      Function                        Location
//
//      XformWidthInHimetricToPixels    OLE2UI Function
//      XformHeightInHimetricToPixels   OLE2UI Function
//
//
//********************************************************************

void CSimpleSite::GetObjRect(LPRECT lpRect)
{
    // convert it to pixels
    lpRect->left = lpRect->top = 0;
    lpRect->right = XformWidthInHimetricToPixels(NULL,(int)m_sizel.cx);
    lpRect->bottom = XformHeightInHimetricToPixels(NULL,(int)m_sizel.cy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\app.cpp ===
//**********************************************************************
// File name: app.cpp
//
//    Implementation file for the CSimpleApp Class
//
// Functions:
//
//    See app.h for a list of member functions.
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include <testmess.h>


#ifdef WIN32
extern INT_PTR CALLBACK About(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
#endif

//**********************************************************************
//
// CSimpleApp::CSimpleApp()
//
// Purpose:
//
//      Constructor for CSimpleApp
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//********************************************************************
CSimpleApp::CSimpleApp()
{
    TestDebugOut("In CSimpleApp's Constructor \r\n");

    // Set Ref Count
    m_nCount = 0;

    // clear members
    m_hAppWnd = NULL;
    m_hInst = NULL;
    m_lpDoc = NULL;

    // clear flags
    m_fInitialized = FALSE;

    // Initialize effects we allow.
    m_dwSourceEffect = DROPEFFECT_COPY | DROPEFFECT_MOVE;
    m_dwTargetEffect = DROPEFFECT_COPY | DROPEFFECT_MOVE;
}

//**********************************************************************
//
// CSimpleApp::~CSimpleApp()
//
// Purpose:
//
//      Destructor for CSimpleApp Class.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      OutdebugString              Windows API
//      OleUninitialize             OLE API
//
//
//********************************************************************

CSimpleApp::~CSimpleApp()
{
    TestDebugOut("In CSimpleApp's Destructor\r\n");

    // need to uninit the library...
    if (m_fInitialized)
        OleUninitialize();
}

//**********************************************************************
//
// CSimpleApp::DestroyDocs()
//
// Purpose:
//
//      Destroys all of the open documents in the application (Only one
//      since this is an SDI app, but could easily be modified to
//      support MDI).
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::Close           DOC.CPP
//
//********************************************************************

void CSimpleApp::DestroyDocs()
{
    m_lpDoc->Close();   // we have only 1 document
}

//**********************************************************************
//
// CSimpleApp::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the Application level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK                -   The interface is supported.
//      S_FALSE             -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
//********************************************************************

STDMETHODIMP CSimpleApp::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In CSimpleApp::QueryInterface\r\n");

    *ppvObj = NULL;     // must set out pointer parameters to NULL

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Application level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::AddRef()
{
    TestDebugOut("In CSimpleApp::AddRef\r\n");
    return ++m_nCount;
}

//**********************************************************************
//
// CSimpleApp::Release
//
// Purpose:
//
//      Decrements the reference count at the application level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleApp::Release()
{
    TestDebugOut("In CSimpleApp::Release\r\n");

    if (--m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}

//**********************************************************************
//
// CSimpleApp::fInitApplication
//
// Purpose:
//
//      Initializes the application
//
// Parameters:
//
//      HANDLE hInstance    -   Instance handle of the application.
//
// Return Value:
//
//      TRUE    -   Application was successfully initialized.
//      FALSE   -   Application could not be initialized
//
// Function Calls:
//      Function                    Location
//
//      LoadIcon                    Windows API
//      LoadCursor                  Windows API
//      GetStockObject              Windows API
//      RegisterClass               Windows API
//
//
//********************************************************************

BOOL CSimpleApp::fInitApplication(HANDLE hInstance)
{
    WNDCLASS  wc;

    // Fill in window class structure with parameters that describe the
    // main window.

    wc.style = NULL;                    // Class style(s).
    wc.lpfnWndProc = MainWndProc;       // Function to retrieve messages for
                                        // windows of this class.
    wc.cbClsExtra = 0;                  // No per-class extra data.
    wc.cbWndExtra = 0;                  // No per-window extra data.
    wc.hInstance =(HINSTANCE) hInstance;           // Application that owns
                                                   // the class.
    wc.hIcon = LoadIcon((HINSTANCE)hInstance,TEXT("SimpDnd"));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  TEXT("SIMPLEMENU");    // Name of menu resource in
                                              // .RC file.
    wc.lpszClassName = TEXT("SimpDndAppWClass");  // Name used in
                                                  // CreateWindow call.

    if (!RegisterClass(&wc))
        return FALSE;

    wc.style = CS_DBLCLKS;              // Class style(s). allow DBLCLK's
    wc.lpfnWndProc = DocWndProc;        // Function to retrieve messages for
                                        // windows of this class.
    wc.cbClsExtra = 0;                  // No per-class extra data.
    wc.cbWndExtra = 0;                  // No per-window extra data.
    wc.hInstance = (HINSTANCE) hInstance;           // Application that owns
                                                    // the class.
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("SimpDndDocWClass");    // Name used in
                                                    //CreateWindow call.

    // Register the window class and return success/failure code.

    return (RegisterClass(&wc));
}

//**********************************************************************
//
// CSimpleApp::fInitInstance
//
// Purpose:
//
//      Instance initialization.
//
// Parameters:
//
//      HANDLE hInstance    -   App. Instance Handle.
//
//      int nCmdShow        -   Show parameter from WinMain
//
// Return Value:
//
//      TRUE    -   Initialization Successful
//      FALSE   -   Initialization Failed.
//
//
// Function Calls:
//      Function                    Location
//
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      GetProfileInt               Windows API
//      OleBuildVersion             OLE API
//      OleInitialize               OLE API
//      OleStdCreateDbAlloc         OLE2UI
//
// Comments:
//
//      Note that successful Initalization of the OLE libraries
//      is remembered so the UnInit is only called if needed.
//
//********************************************************************

BOOL CSimpleApp::fInitInstance (HANDLE hInstance, int nCmdShow)
{
    LPMALLOC lpMalloc = NULL;

#ifndef WIN32
   /* Since OLE is part of the operating system in Win32, we don't need to
    * check the version number in Win32.
    */
    DWORD dwVer = OleBuildVersion();

    // check to see if we are compatible with this version of the libraries
    if (HIWORD(dwVer) != rmm || LOWORD(dwVer) < rup)
    {
#ifdef _DEBUG
        TestDebugOut("WARNING: Incompatible OLE library version\r\n");
#else
        return FALSE;
#endif
    }
#endif // WIN32

#if defined( _DEBUG )
    /* OLE2NOTE: Use a special debug allocator to help track down
    **    memory leaks.
    */
    OleStdCreateDbAlloc(0, &lpMalloc);
#endif

    //  We try passing in our own allocator first - if that fails we
    //  try without overriding the allocator.

    if (SUCCEEDED(OleInitialize(lpMalloc)) ||
        SUCCEEDED(OleInitialize(NULL)))
    {
        m_fInitialized = TRUE;
    }

#if defined( _DEBUG )
    /* OLE2NOTE: release the special debug allocator so that only OLE is
    **    holding on to it. later when OleUninitialize is called, then
    **    the debug allocator object will be destroyed. when the debug
    **    allocator object is destoyed, it will report (to the Output
    **    Debug Terminal) whether there are any memory leaks.
    */
    if (lpMalloc) lpMalloc->Release();
#endif

    m_hInst = (HINSTANCE) hInstance;

    // Create the "application" windows
    m_hAppWnd = CreateWindow (TEXT("SimpDndAppWClass"),
                              TEXT("Simple OLE 2.0 Drag/Drop Container"),
                              WS_OVERLAPPEDWINDOW,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              NULL,
                              NULL,
                              (HINSTANCE) hInstance,
                              NULL);

    if (!m_hAppWnd)
        return FALSE;

    // if we have been launched by the test driver, tell it our window handle

    if( m_hDriverWnd )
    {
        PostMessage(m_hDriverWnd, WM_TESTREG, (WPARAM)m_hAppWnd, 0);
    }

    // delay before dragging should start, in milliseconds
    m_nDragDelay = GetProfileInt(
            TEXT("windows"),
            TEXT("DragDelay"),
            DD_DEFDRAGDELAY
    );

    // minimum distance (radius) before drag should start, in pixels
    m_nDragMinDist = GetProfileInt(
            TEXT("windows"),
            TEXT("DragMinDist"),
            DD_DEFDRAGMINDIST
    );

    // delay before scrolling, in milliseconds
    m_nScrollDelay = GetProfileInt(
            TEXT("windows"),
            TEXT("DragScrollDelay"),
            DD_DEFSCROLLDELAY
    );

    // inset-width of the hot zone, in pixels
    m_nScrollInset = GetProfileInt(
            TEXT("windows"),
            TEXT("DragScrollInset"),
            DD_DEFSCROLLINSET
    );

    // scroll interval, in milliseconds
    m_nScrollInterval = GetProfileInt(
            TEXT("windows"),
            TEXT("DragScrollInterval"),
            DD_DEFSCROLLINTERVAL
    );

    ShowWindow (m_hAppWnd, nCmdShow);
    UpdateWindow (m_hAppWnd);

    return m_fInitialized;
}





//+-------------------------------------------------------------------------
//
//  Member:     CSimpleApp::UpdateDragDropEffects
//
//  Synopsis:   Update drag/drop effects
//
//  Arguments:  [iMenuPos] - menu position either source or target
//              [iMenuCommand] - what command the menu selection maps to
//              [dwEffect] - new effects
//              [pdwEffectToUpdate] - where to store the effects
//
//  Algorithm:  Get the menu for either source or target. Then clear any
//              outstanding check marks. Check the appropriate item. Finally
//              update the effects that we allow.
//
//  History:    dd-mmm-yy Author    Comment
//     		06-May-94 Ricksa    author
//
//--------------------------------------------------------------------------
void CSimpleApp::UpdateDragDropEffects(
    int iMenuPos,
    int iMenuCommand,
    DWORD dwEffect,
    DWORD *pdwEffectToUpdate)
{
    // Get the menu that we want to process
    HMENU hMenuItem = GetSubMenu(m_hHelpMenu, iMenuPos);

    // Clear any current check marks
    for (int i = 0; i < 3; i++)
    {
        CheckMenuItem(hMenuItem, i, MF_BYPOSITION | MF_UNCHECKED);
    }

    // Check the appropriate item.
    CheckMenuItem(hMenuItem, iMenuCommand, MF_BYCOMMAND | MF_CHECKED);
    *pdwEffectToUpdate = dwEffect;
}


//**********************************************************************
//
// CSimpleApp::lCommandHandler
//
// Purpose:
//
//      Handles the processing of WM_COMMAND.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_COMMAND)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                    Location
//
//      IOleObject::DoVerb                          Object
//      GetClientRect                               Windows API
//      MessageBox                                  Windows API
//      DialogBox                                   Windows API
//      MakeProcInstance                            Windows API
//      FreeProcInstance                            Windows API
//      SendMessage                                 Windows API
//      DefWindowProc                               Windows API
//      CSimpleDoc::InsertObject                    DOC.CPP
//      CSimpleDoc::CopyObjectToClip                DOC.CPP
//      CSimpleDoc::Close                           DOC.CPP
//
//********************************************************************

LRESULT CSimpleApp::lCommandHandler (HWND hWnd, UINT message,
                                  WPARAM wParam, LPARAM lParam)
{
    RECT rect;

    // see if the command is a verb selections
    if (wParam >= IDM_VERB0)
    {
        // get the rectangle of the object
        m_lpDoc->m_lpSite->GetObjRect(&rect);

        if (m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(
                wParam - IDM_VERB0, NULL,
                &m_lpDoc->m_lpSite->m_OleClientSite, -1,
                m_lpDoc->m_hDocWnd, &rect)
                != ResultFromScode(S_OK))
        {
            TestDebugOut("Fail in IOleObject::DoVerb\n");
        }
    }
    else
    {
        switch (wParam)
        {
            // bring up the About box
            case IDM_ABOUT:
                {
#ifdef WIN32
                    DialogBox(m_hInst,          // current instance
                        TEXT("AboutBox"),       // resource to use
                        m_hAppWnd,              // parent handle
                        About);                 // About() instance address
#else
                    FARPROC lpProcAbout = MakeProcInstance((FARPROC)About,
                                                            m_hInst);

                    DialogBox(m_hInst,          // current instance
                        TEXT("AboutBox"),       // resource to use
                        m_hAppWnd,              // parent handle
                        lpProcAbout);           // About() instance address

                    FreeProcInstance(lpProcAbout);
#endif
                    break;
                }

            // bring up the InsertObject Dialog
            case IDM_INSERTOBJECT:
                m_lpDoc->InsertObject();
                break;

            // Copy the object to the Clipboard
            case IDM_COPY:
                m_lpDoc->CopyObjectToClip();
                break;

            // exit the application
            case IDM_EXIT:
                SendMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                break;

            case IDM_NEW:
                lCreateDoc(hWnd, 0, 0, 0);
                break;

            // Only allow copy from the source
            case IDM_SOURCE_COPY:
                UpdateDragDropEffects(SOURCE_EFFECTS_MENU_POS,
                    IDM_SOURCE_COPY, DROPEFFECT_COPY, &m_dwSourceEffect);
                break;

            // Only allow move from the source
            case IDM_SOURCE_MOVE:
                UpdateDragDropEffects(SOURCE_EFFECTS_MENU_POS,
                    IDM_SOURCE_MOVE, DROPEFFECT_MOVE, &m_dwSourceEffect);
                break;

            // Allow both copy and move from the source
            case IDM_SOURCE_COPYMOVE:
                UpdateDragDropEffects(SOURCE_EFFECTS_MENU_POS,
                    IDM_SOURCE_COPYMOVE, DROPEFFECT_COPY | DROPEFFECT_MOVE,
                        &m_dwSourceEffect);
                break;

            // Only accept copy in target
            case IDM_TARGET_COPY:
                UpdateDragDropEffects(TARGET_EFFECTS_MENU_POS,
                    IDM_TARGET_COPY, DROPEFFECT_COPY, &m_dwTargetEffect);
                break;

            // Only accept move in target
            case IDM_TARGET_MOVE:
                UpdateDragDropEffects(TARGET_EFFECTS_MENU_POS,
                    IDM_TARGET_MOVE, DROPEFFECT_MOVE, &m_dwTargetEffect);
                break;

            // Accept both move and copy in the target
            case IDM_TARGET_COPYMOVE:
                UpdateDragDropEffects(TARGET_EFFECTS_MENU_POS,
                    IDM_TARGET_COPYMOVE, DROPEFFECT_COPY | DROPEFFECT_MOVE,
                        &m_dwTargetEffect);
                break;

            default:
                return (DefWindowProc(hWnd, message, wParam, lParam));
        }   // end of switch

    }  // end of else

    return NULL;
}

//**********************************************************************
//
// CSimpleApp::lSizeHandler
//
// Purpose:
//
//      Handles the WM_SIZE message
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_SIZE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      LONG    -   returned from the "document" resizing
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::lResizeDoc      DOC.CPP
//
//
//********************************************************************

long CSimpleApp::lSizeHandler (HWND hWnd, UINT message,
                               WPARAM wParam, LPARAM lParam)
{
    RECT rect;

    GetClientRect(m_hAppWnd, &rect);
    return m_lpDoc->lResizeDoc(&rect);
}

//**********************************************************************
//
// CSimpleApp::lCreateDoc
//
// Purpose:
//
//      Handles the creation of a document object.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_CREATE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpleDoc::CSimpleDoc      DOC.CPP
//
//
//********************************************************************

long CSimpleApp::lCreateDoc (HWND hWnd, UINT message,
                             WPARAM wParam, LPARAM lParam)
{
    RECT rect;
    static BOOL fFirstTime = TRUE;

    if (m_lpDoc != NULL)
    {
        // There is a document defined already so we close it without
        // saving which is equivalent to deleting the object.
        m_lpDoc->Close();
        m_lpDoc = NULL;
    }

    GetClientRect(hWnd, &rect);

    m_lpDoc = CSimpleDoc::Create(this, &rect, hWnd);

    // First time initialization - for some reason the doc sets the
    // the application's m_hHelpMenu which we need. So we do the
    // initialization here.
    if (fFirstTime)
    {
        fFirstTime = FALSE;

        // Check default allowed effects for the source
        UpdateDragDropEffects(SOURCE_EFFECTS_MENU_POS, IDM_SOURCE_COPYMOVE,
            m_dwSourceEffect, &m_dwSourceEffect);

        // Check default allowed effects for the target
        UpdateDragDropEffects(TARGET_EFFECTS_MENU_POS, IDM_TARGET_COPYMOVE,
            m_dwTargetEffect, &m_dwTargetEffect);
    }

    return NULL;
}

//**********************************************************************
//
// CSimpleApp::HandleAccelerators
//
// Purpose:
//
//      To properly handle accelerators in the Message Loop
//
// Parameters:
//
//      LPMSG lpMsg -   A pointer to the message structure.
//
// Return Value:
//
//      TRUE    -   The accelerator was handled
//      FALSE   -   The accelerator was not handled
//
// Function Calls:
//      Function                                        Location
//
//
//********************************************************************

BOOL CSimpleApp::HandleAccelerators(LPMSG lpMsg)
{
    BOOL retval = FALSE;

    // we do not have any accelerators

    return retval;
}

//**********************************************************************
//
// CSimpleApp::PaintApp
//
// Purpose:
//
//      Handles the painting of the doc window.
//
//
// Parameters:
//
//      HDC hDC -   hDC to the Doc Window.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::PaintDoc        DOC.CPP
//
// Comments:
//
//      This is an app level function in case we want to do palette
//      management.
//
//********************************************************************

void CSimpleApp::PaintApp (HDC hDC)
{
    // at this level, we could enumerate through all of the
    // visible objects in the application, so that a palette
    // that best fits all of the objects can be built.

    // This app is designed to take on the same palette
    // functionality that was provided in OLE 1.0, the palette
    // of the last object drawn is realized.  Since we only
    // support one object at a time, it shouldn't be a big
    // deal.

    // if we supported multiple documents, we would enumerate
    // through each of the open documents and call paint.

    if (m_lpDoc)
    {
        m_lpDoc->PaintDoc(hDC);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\app.h ===
//**********************************************************************
// File name: app.h
//
//      Definition of CSimpleApp
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _APP_H_)
#define _APP_H_

#include <ole2.h>

class CSimpleDoc;

class CSimpleApp : public IUnknown
{            
public:

    int m_nCount;           // reference count
    HWND m_hAppWnd;         // main window handle
    HWND m_hDriverWnd;	    // window handle for the driver app.
    HINSTANCE m_hInst;      // application instance
    CSimpleDoc FAR * m_lpDoc;   // pointer to document object
    BOOL m_fInitialized;    // OLE initialization flag
    HMENU           m_hMainMenu;        
    HMENU           m_hFileMenu;
    HMENU           m_hEditMenu;
    HMENU           m_hHelpMenu;  
    HMENU           m_hCascadeMenu;     // OLE object's verb

    // Drag/Drop related fields
    int m_nDragDelay;       // time delay (in msec) before drag should start
    int m_nDragMinDist;     // min. distance (radius) before drag should start
    int m_nScrollDelay;     // time delay (in msec) before scroll should start
    int m_nScrollInset;     // Border inset distance to start drag scroll
    int m_nScrollInterval;  // scroll interval time (in msec)

    DWORD m_dwSourceEffect; // Allowed effects to source
    DWORD m_dwTargetEffect; // Allowed target effects
    
    CSimpleApp();           // Constructor
    ~CSimpleApp();          // Destructor
    
    // IUnknown Interfaces    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj); 
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release(); 

    // Initialization methods
    
    BOOL fInitApplication (HANDLE hInstance);
    BOOL fInitInstance (HANDLE hInstance, int nCmdShow);
    
    // Message handling methods
    
    LRESULT lCommandHandler (HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);
    long lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    long lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    BOOL HandleAccelerators (LPMSG lpMsg);
    void PaintApp(HDC hDC);
    void DestroyDocs();
    void UpdateDragDropEffects(int iMenuPos, int iMenuCommand, DWORD dwEffect,
        DWORD *pdwEffectToUpdate);
};

#endif  // _APP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\dxferobj.h ===
//**********************************************************************
// File name: dxferobj.h
//
//      Definition of CDataXferObj
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _DATAXFEROBJ_H_)
#define _DATAXFEROBJ_H_

class CSimpleSite;

interface CDataObject;

class CDataXferObj : public IDataObject
{
private:
    int m_nCount;                       // reference count
    SIZEL m_sizel;
    POINTL m_pointl;
    LPSTORAGE m_lpObjStorage;
    LPOLEOBJECT m_lpOleObject;

    // construction/destruction         
    CDataXferObj();
    ~CDataXferObj();

public:
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release (); 

    STDMETHODIMP DAdvise  ( FORMATETC FAR* pFormatetc, DWORD advf, 
    LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) 
        { return ResultFromScode(OLE_E_ADVISENOTSUPPORTED); }
    STDMETHODIMP DUnadvise  ( DWORD dwConnection) 
        { return ResultFromScode(OLE_E_ADVISENOTSUPPORTED); }
    STDMETHODIMP EnumDAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise)
        { return ResultFromScode(OLE_E_ADVISENOTSUPPORTED); }
    STDMETHODIMP EnumFormatEtc  ( DWORD dwDirection,
            LPENUMFORMATETC FAR* ppenumFormatEtc);
            STDMETHODIMP GetCanonicalFormatEtc  ( LPFORMATETC pformatetc,
            LPFORMATETC pformatetcOut)
        { pformatetcOut->ptd = NULL; return ResultFromScode(E_NOTIMPL);	}
    STDMETHODIMP GetData  (LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium );
    STDMETHODIMP GetDataHere  (LPFORMATETC pformatetc, LPSTGMEDIUM pmedium);  
    STDMETHODIMP QueryGetData  (LPFORMATETC pformatetc ); 
    STDMETHODIMP SetData  (LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
            BOOL fRelease)
        { return ResultFromScode(E_NOTIMPL); }                           

    static CDataXferObj FAR* Create(CSimpleSite FAR* lpSite,
            POINTL FAR* pPointl);

};       
#endif 	// _DATAXFEROBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\doc.cpp ===
//**********************************************************************
// File name: DOC.CPP
//
//      Implementation file for CSimpleDoc.
//
// Functions:
//
//      See DOC.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include "idt.h"
#include "dxferobj.h"

//**********************************************************************
//
// CSimpleDoc::Create
//
// Purpose:
//
//      Creation for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      LPRECT lpRect           -   Client area rect of "frame" window
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      RegisterDragDrop            OLE API
//      CoLockObjectExternal        OLE API
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      EnableMenuItem              Windows API
//
// Comments:
//
//      This routine was added so that failure could be returned
//      from object creation.
//
//********************************************************************

CSimpleDoc FAR * CSimpleDoc::Create(CSimpleApp FAR *lpApp, LPRECT lpRect,
                                    HWND hWnd)
{
    CSimpleDoc FAR * lpTemp = new CSimpleDoc(lpApp, hWnd);

    if (!lpTemp)
    {
        TestDebugOut("Memory allocation error\n");
        return NULL;
    }

    // create storage for the doc.
    HRESULT hErr = StgCreateDocfile (
        NULL,       // generate temp name
        STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE,
        0, &lpTemp->m_lpStorage);

    if (hErr != NOERROR)
        goto error;

    // create the document Window
    lpTemp->m_hDocWnd = CreateWindow(
            TEXT("SimpDndDocWClass"),
            NULL,
            WS_CHILD | WS_CLIPCHILDREN,
            lpRect->left,
            lpRect->top,
            lpRect->right,
            lpRect->bottom,
            hWnd,
            NULL,
            lpApp->m_hInst,
            NULL);

    if (!lpTemp->m_hDocWnd)
        goto error;

    ShowWindow(lpTemp->m_hDocWnd, SW_SHOWNORMAL);  // Show the window
    UpdateWindow(lpTemp->m_hDocWnd);               // Sends WM_PAINT message

#ifdef NOTREADY
    // Ensable InsertObject menu choice
    EnableMenuItem( lpApp->m_hEditMenu, 0, MF_BYPOSITION | MF_ENABLED);
#else
    // Ensable InsertObject menu choice
    EnableMenuItem( lpApp->m_hEditMenu, 1, MF_BYPOSITION | MF_ENABLED);
    // Disable Copy menu choice
    EnableMenuItem( lpApp->m_hEditMenu, 0, MF_BYPOSITION | MF_DISABLED |
                                           MF_GRAYED);
#endif // NOTREADY

    HRESULT  hRes;

    // It is *REQUIRED* to hold a strong LOCK on the object that is
    // registered as drop target. this call will result in at least one
    // ref count held on our document. later in CSimpleDoc::Close we will
    // unlock this lock which will make our document's ref count go to 0.
    // when the document's ref count goes to 0, it will be deleted.
    if ( (hRes=CoLockObjectExternal (&lpTemp->m_DropTarget, TRUE, 0))
         != ResultFromScode(S_OK) )
    {
       /* CoLockObjectExternal should never fail. If it fails, we don't want
        * to carry on since we don't have a guaranteed object lock.
        */
       goto error;
    }

    // Register our window as a DropTarget
    if (((hRes=RegisterDragDrop(lpTemp->m_hDocWnd, &lpTemp->m_DropTarget))
          !=ResultFromScode(S_OK))
          && (hRes != ResultFromScode(DRAGDROP_E_ALREADYREGISTERED)))
    {
       lpTemp->m_fRegDragDrop = FALSE;
    }
    else
    {
       lpTemp->m_fRegDragDrop = TRUE;
    }

    return (lpTemp);

error:
    TestDebugOut("Fail in CSimpleDoc::Create\n");
    delete (lpTemp);
    return NULL;

}

//**********************************************************************
//
// CSimpleDoc::Close
//
// Purpose:
//
//      Close CSimpleDoc object.
//      when the document's reference count goes to 0, the document
//      will be destroyed.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      RevokeDragDrop              OLE API
//      CoLockObjectExternal        OLE API
//      OleFlushClipboard           OLE API
//      ShowWindow                  Windows API
//      CSimpleSite::CloseOleObject SITE.CPP
//
//
//********************************************************************

void CSimpleDoc::Close(void)
{
    TestDebugOut("In CSimpleDoc::Close\r\n");

    HRESULT hRes;

    ShowWindow(m_hDocWnd, SW_HIDE);  // Hide the window

    // Remove our data transfer object from clipboard if it is there.
    // this will leave HGLOBAL based data behind on the clipboard
    // including OLE 1.0 compatibility formats.

    if (OleFlushClipboard() != ResultFromScode(S_OK))
    {
       TestDebugOut("Fail in OleFlushClipBoard\n");
    }

    // Revoke our window as a DropTarget
    if (m_fRegDragDrop)
    {
        if (((hRes=RevokeDragDrop(m_hDocWnd)) != ResultFromScode(S_OK)) &&
             (hRes!=ResultFromScode(DRAGDROP_E_NOTREGISTERED)))
        {
           /* if we fail in revoking the drag-drop, we will probably be
            * having memory leakage.
            */
           TestDebugOut("Fail in RevokeDragDrop\n");
        }
        else
        {
           m_fRegDragDrop = FALSE;
        }
    }

    // Close the OLE object in our document
    if (m_lpSite)
        m_lpSite->CloseOleObject();

    // Unlock the lock added in CSimpleDoc::Create. this will make
    // the document's ref count go to 0, and the document will be deleted.
    if ((hRes=CoLockObjectExternal (&m_DropTarget, FALSE, TRUE))
        !=ResultFromScode(S_OK))
    {
        /* if CoLockObjectExternal fails, this means that we cannot release
         * the reference count to our destinated object. This will cause
         * memory leakage.
         */
        TestDebugOut("Fail in CoLockObjectExternal\n");
    }
}

//**********************************************************************
//
// CSimpleDoc::CSimpleDoc
//
// Purpose:
//
//      Constructor for the CSimpleDoc Class
//
// Parameters:
//
//      CSimpleApp FAR * lpApp  -   Pointer to the CSimpleApp Class
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      GetMenu                     Windows API
//      GetSubMenu                  Windows API
//
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
                                 // tells us that we are passing this in
                                 // an initializer, before "this" is through
                                 // initializing.  This is ok, because
                                 // we just store the ptr in the other
                                 // constructor

CSimpleDoc::CSimpleDoc(CSimpleApp FAR * lpApp,HWND hWnd)
        : m_DropTarget(this), m_DropSource(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
    TestDebugOut("In CSimpleDoc's Constructor\r\n");
    m_lpApp = lpApp;
    m_lpSite = NULL;
    m_nCount = 0;
    // set up menu handles
    lpApp->m_hMainMenu = GetMenu(hWnd);
    lpApp->m_hFileMenu = GetSubMenu(lpApp->m_hMainMenu, 0);
    lpApp->m_hEditMenu = GetSubMenu(lpApp->m_hMainMenu, 1);
    lpApp->m_hHelpMenu = GetSubMenu(lpApp->m_hMainMenu, 2);
    lpApp->m_hCascadeMenu = NULL;
    m_fModifiedMenu = FALSE;

    // drag/drop related stuff
    m_fRegDragDrop = FALSE;       // is doc registered as drop target?
    m_fLocalDrag = FALSE;         // is doc source of the drag
    m_fLocalDrop = FALSE;         // was doc target of the drop
    m_fCanDropCopy = FALSE;       // is Drag/Drop copy/move possible?
    m_fCanDropLink = FALSE;       // is Drag/Drop link possible?
    m_fDragLeave = FALSE;         // has drag left
    m_fPendingDrag = FALSE;       // LButtonDown--possible drag pending
    m_ptButDown.x = m_ptButDown.y = 0; // LButtonDown coordinates

}

//**********************************************************************
//
// CSimpleDoc::~CSimpleDoc
//
// Purpose:
//
//      Destructor for CSimpleDoc
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                     Location
//
//      TestDebugOut            Windows API
//      GetMenuItemCount             Windows API
//      RemoveMenu                   Windows API
//      DestroyMenu                  Windows API
//      DestroyWindow                Windows API
//      CSimpleSite::Release         SITE.CPP
//      CSimpleSite::UnloadOleObject SITE.CPP
//      IStorage::Release            OLE API
//
//
//********************************************************************

CSimpleDoc::~CSimpleDoc()
{
    TestDebugOut("In CSimpleDoc's Destructor\r\n");

    // Release all pointers we hold to the OLE object, also release
    // the ref count added in CSimpleSite::Create. this will make
    // the Site's ref count go to 0, and the Site will be deleted.
    if (m_lpSite)
    {
        m_lpSite->UnloadOleObject();
        m_lpSite->Release();
        m_lpSite = NULL;
    }

    // Release the Storage
    if (m_lpStorage)
    {
        m_lpStorage->Release();
        m_lpStorage = NULL;
    }

    // if the edit menu was modified, remove the menu item and
    // destroy the popup if it exists
    if (m_fModifiedMenu)
    {
        int nCount = GetMenuItemCount(m_lpApp->m_hEditMenu);
        RemoveMenu(m_lpApp->m_hEditMenu, nCount-1, MF_BYPOSITION);
        if (m_lpApp->m_hCascadeMenu)
            DestroyMenu(m_lpApp->m_hCascadeMenu);
    }

    DestroyWindow(m_hDocWnd);
}


//**********************************************************************
//
// CSimpleDoc::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the Document level.
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      S_OK                -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP CSimpleDoc::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In CSimpleDoc::QueryInterface\r\n");

    *ppvObj = NULL;     // must set out pointer parameters to NULL

    // looking for IUnknown
    if (IsEqualIID( riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return ResultFromScode(S_OK);
    }

    // looking for IDropTarget
    if (IsEqualIID( riid, IID_IDropTarget))
    {
        m_DropTarget.AddRef();
        *ppvObj=&m_DropTarget;
        return ResultFromScode(S_OK);
    }

    // looking for IDropSource
    if (IsEqualIID( riid, IID_IDropSource))
    {
        m_DropSource.AddRef();
        *ppvObj=&m_DropSource;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleDoc::AddRef
//
// Purpose:
//
//      Increments the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The new reference count on the document object
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleApp::AddRef          APP.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::AddRef()
{
    TestDebugOut("In CSimpleDoc::AddRef\r\n");
    return ++m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::Release
//
// Purpose:
//
//      Decrements the document reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The new reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleDoc::Release()
{
    TestDebugOut("In CSimpleDoc::Release\r\n");

    if (--m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}

//**********************************************************************
//
// CSimpleDoc::InsertObject
//
// Purpose:
//
//      Inserts a new object to this document
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::Create         SITE.CPP
//      CSimpleSite::InitObject     SITE.CPP
//      CSimpleSite::Release        SITE.CPP
//      CSimpleSite::Revert         SITE.CPP
//      memset                      C Runtime
//      OleUIInsertObject           OLE2UI function
//      CSimpleDoc::DisableInsertObject DOC.CPP
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Insert Object menu choice is greyed out, to prevent
//      the user from inserting another.
//
//********************************************************************

void CSimpleDoc::InsertObject()
{
    OLEUIINSERTOBJECT io;
    UINT iret;
    TCHAR szFile[OLEUI_CCHPATHMAX];

    HRESULT hRes;

    m_lpSite = CSimpleSite::Create(this);

    if (!m_lpSite)
    {
       /* memory allocation problem. cannot continue.
        */
       TestDebugOut("Memory allocation error\n");
       return;
    }

    // clear the structure
    _fmemset(&io, 0, sizeof(OLEUIINSERTOBJECT));

    // fill the structure
    io.cbStruct = sizeof(OLEUIINSERTOBJECT);
    io.dwFlags = IOF_SELECTCREATENEW      | IOF_DISABLELINK     |
                 IOF_DISABLEDISPLAYASICON | IOF_CREATENEWOBJECT |
                 IOF_CREATEFILEOBJECT;
    io.hWndOwner = m_hDocWnd;
    io.lpszCaption = (LPTSTR)TEXT("Insert Object");
    io.iid = IID_IOleObject;
    io.oleRender = OLERENDER_DRAW;
    io.lpIOleClientSite = &m_lpSite->m_OleClientSite;
    io.lpIStorage = m_lpSite->m_lpObjStorage;
    io.ppvObj = (LPVOID FAR *)&m_lpSite->m_lpOleObject;
    io.lpszFile = szFile;
    io.cchFile = sizeof(szFile)/sizeof(TCHAR);
                                      // cchFile is the number of characters
    _fmemset((LPTSTR)szFile, 0, sizeof(szFile));

    // call OUTLUI to do all the hard work
    iret = OleUIInsertObject(&io);

    if (iret == OLEUI_OK)
    {
        m_lpSite->InitObject((BOOL)(io.dwFlags & IOF_SELECTCREATENEW));
        // disable Insert Object menu item
        DisableInsertObject();
    }
    else
    {
        m_lpSite->Release();
        m_lpSite = NULL;
        if (((hRes=m_lpStorage->Revert()) != ResultFromScode(S_OK)) &&
             (hRes!=ResultFromScode(STG_E_REVERTED)))
        {
           TestDebugOut("Fail in IStorage::Revert\n");
        }
    }
}

//**********************************************************************
//
// CSimpleDoc::lResizeDoc
//
// Purpose:
//
//      Resizes the document
//
// Parameters:
//
//      LPRECT lpRect   -   The size of the client are of the "frame"
//                          Window.
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                Location
//
//      MoveWindow                              Windows API
//
//
//********************************************************************

long CSimpleDoc::lResizeDoc(LPRECT lpRect)
{
    MoveWindow(
            m_hDocWnd,
            lpRect->left, lpRect->top,
            lpRect->right, lpRect->bottom, TRUE);

    return NULL;
}

//**********************************************************************
//
// CSimpleDoc::lAddVerbs
//
// Purpose:
//
//      Adds the objects verbs to the edit menu.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetMenuItemCount            Windows API
//      OleUIAddVerbMenu            OLE2UI function
//
//
//********************************************************************

long CSimpleDoc::lAddVerbs(void)
{
    // m_fModifiedMenu is TRUE if the menu has already been modified
    // once.  Since we only support one obect every time the application
    // is run, then once the menu is modified, it doesn't have
    // to be done again.
    if (m_lpSite && !m_fModifiedMenu)
    {
        int nCount = GetMenuItemCount(m_lpApp->m_hEditMenu);

        if (!OleUIAddVerbMenu ( m_lpSite->m_lpOleObject,
                           NULL,
                           m_lpApp->m_hEditMenu,
                           nCount + 1,
                           IDM_VERB0,
                           0,           // no maximum verb IDM enforced
                           FALSE,
                           1,
                           &m_lpApp->m_hCascadeMenu) )
        {
            TestDebugOut("Fail in OleUIAddVerbMenu\n");
        }

        m_fModifiedMenu = TRUE;
    }
    return (NULL);
}

//**********************************************************************
//
// CSimpleDoc::PaintDoc
//
// Purpose:
//
//      Paints the Document
//
// Parameters:
//
//      HDC hDC -   hDC of the document Window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::PaintObj       SITE.CPP
//
//
//********************************************************************

void CSimpleDoc::PaintDoc (HDC hDC)
{
    // if we supported multiple objects, then we would enumerate
    // the objects and call paint on each of them from here.

    if (m_lpSite)
        m_lpSite->PaintObj(hDC);

}

//**********************************************************************
//
// CSimpleDoc::DisableInsertObject
//
// Purpose:
//
//      Disable the ability to insert a new object in this document.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      RevokeDragDrop              OLE API
//      EnableMenuItem              Windows API
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Insert Object menu choice is greyed out, to prevent
//      the user from inserting another. Also we revoke ourself as
//      a potential drop target.
//
//********************************************************************

void CSimpleDoc::DisableInsertObject(void)
{
#ifdef NOTREADY
    // Disable InsertObject menu choice
    EnableMenuItem( m_lpApp->m_hEditMenu, 0, MF_BYPOSITION | MF_DISABLED |
                                             MF_GRAYED);
#else
    // Disable InsertObject menu choice
    EnableMenuItem( m_lpApp->m_hEditMenu, 1, MF_BYPOSITION | MF_DISABLED |
                                             MF_GRAYED);
    // Enable Copy menu choice
    EnableMenuItem( m_lpApp->m_hEditMenu, 0, MF_BYPOSITION | MF_ENABLED);
#endif // NOTREADY

    // We no longer accept dropping of objects
    if (m_fRegDragDrop)
    {
        HRESULT hRes;
        if (((hRes=RevokeDragDrop(m_hDocWnd))!=ResultFromScode(S_OK)) &&
             (hRes!=ResultFromScode(DRAGDROP_E_NOTREGISTERED)))
        {
           /* if we fail in revoking the drag-drop, we will probably be
            * having memory leakage.
            */
           TestDebugOut("Fail in RevokeDragDrop\n");
        }
        else
        {
           m_fRegDragDrop = FALSE;
        }
    }
}

//**********************************************************************
//
// CSimpleDoc::CopyObjectToClip
//
// Purpose:
//
//      Copy the embedded OLE object to the clipboard
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CDataXferObj::Create        DXFEROBJ.CPP
//      CDataXferObj::Release       DXFEROBJ.CPP
//      CDataXferObj::QueryInterface DXFEROBJ.CPP
//      OleSetClipboard             OLE API
//
// Comments:
//
//      This implementation only allows one object to be inserted
//      into a document.  Once the object has been inserted, then
//      the Copy menu choice is enabled.
//
//********************************************************************

void CSimpleDoc::CopyObjectToClip(void)
{
    LPDATAOBJECT lpDataObj;

    // Create a data transfer object by cloning the existing OLE object
    CDataXferObj FAR* pDataXferObj = CDataXferObj::Create(m_lpSite,NULL);
    if (! pDataXferObj)
    {
        /* memory allocation error !
         */
        MessageBox(NULL, TEXT("Out-of-memory"), TEXT("SimpDnD"),
                   MB_SYSTEMMODAL | MB_ICONHAND);
        return;
    }
    // initially obj is created with 0 refcnt. this QI will make it go to 1.
    pDataXferObj->QueryInterface(IID_IDataObject, (LPVOID FAR*)&lpDataObj);

    // put out data transfer object on the clipboard. this API will AddRef.
    if (OleSetClipboard(lpDataObj) != ResultFromScode(S_OK))
    {
       TestDebugOut("Fail in OleSetClipboard\n");
       lpDataObj->Release();
    }

    // Give ownership of data transfer object to clipboard
    pDataXferObj->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\doc.h ===
//**********************************************************************
// File name: doc.h
//
//      Definition of CSimpleDoc
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _DOC_H_ )
#define _DOC_H_

#include "idt.h"        
#include "ids.h"        

class CSimpleSite;
class CSimpleApp;

class CSimpleDoc : public IUnknown 
{   
public:                  
    int             m_nCount;           // reference count
    LPSTORAGE       m_lpStorage;        // IStorage* pointer for Doc
    BOOL            m_fModifiedMenu;    // is object's verb menu on menu

    // Drag/Drop related fields
    BOOL            m_fRegDragDrop;     // is doc registered as drop target?
    BOOL            m_fLocalDrag;       // is doc source of the drag
    BOOL            m_fLocalDrop;       // was doc target of the drop
    BOOL            m_fCanDropCopy;     // is Drag/Drop copy/move possible?
    BOOL            m_fCanDropLink;     // is Drag/Drop link possible?
    BOOL            m_fDragLeave;       // has drag left
    BOOL            m_fPendingDrag;     // LButtonDown--possible drag pending
    POINT           m_ptButDown;        // LButtonDown coordinates
    
    CSimpleSite FAR * m_lpSite;
    CSimpleApp FAR * m_lpApp;
    
    HWND m_hDocWnd;
                        
    CDropTarget m_DropTarget;
    CDropSource m_DropSource;

    static CSimpleDoc FAR* Create(CSimpleApp FAR *lpApp, LPRECT lpRect, 
            HWND hWnd);

    void Close(void);

    CSimpleDoc();          
    CSimpleDoc(CSimpleApp FAR *lpApp, HWND hWnd);
    ~CSimpleDoc();        
    
    // IUnknown Interface    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj); 
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release(); 
    
    void InsertObject(void);
    void DisableInsertObject(void);
    long lResizeDoc(LPRECT lpRect);
    long lAddVerbs(void);
    void PaintDoc(HDC hDC);
    
    // Drag/Drop and clipboard support methods
    void CopyObjectToClip(void);
    BOOL QueryDrag(POINT pt);
    DWORD DoDragDrop(void);
    void Scroll(DWORD dwScrollDir) { /*...scroll Doc here...*/ }

private:

    void FailureNotifyHelper(TCHAR *pszMsg, DWORD dwData);

};
    
#endif  // _DOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\dxferobj.cpp ===
//**********************************************************************
// File name: DXFEROBJ.CPP
//
//      Implementation file for CDataXferObj, data transfer object
//      implementation of IDataObject interface.
//
// Functions:
//
//      See DXFEROBJ.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include <enumfetc.h>
#include <assert.h>
#include "dxferobj.h"
#include "site.h"

//BUGBUG:  These should be fetched from real header files
#define CF_HDROP 15
typedef struct _dropfilestruct {
    DWORD pFiles;
    POINT pt;
    BOOL fNC;
    BOOL fWide;
} DROPFILESTRUCT;


CLIPFORMAT g_cfEmbeddedObject=RegisterClipboardFormat(CF_EMBEDDEDOBJECT);
CLIPFORMAT g_cfObjectDescriptor=RegisterClipboardFormat(CF_OBJECTDESCRIPTOR);

// List of formats offered by our data transfer object via EnumFormatEtc
static FORMATETC s_arrGetFmtEtcs[] =
{
    { g_cfEmbeddedObject, NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},
    { g_cfObjectDescriptor, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    { CF_METAFILEPICT, NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT}
};


//**********************************************************************
//
// CDataXferObj::Create
//
// Purpose:
//
//      Creation routine for CDataXferObj
//
// Parameters:
//
//      CSimpleSite FAR *lpSite   - Pointer to source CSimpleSite
//                                  this is the container site of the
//                                  source OLE object to be transfered
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      assert                      C Runtime
//
// Comments:
//      reference count of CDataXferObj will be 0 on return.
//
//********************************************************************

CDataXferObj FAR * CDataXferObj::Create(
		CSimpleSite FAR *lpSite,
		POINTL FAR* pPointl
)
{
    CDataXferObj FAR * lpTemp = new CDataXferObj();

    if (!lpTemp)
        return NULL;

    // create a sub-storage for the object
    HRESULT hErr = StgCreateDocfile(
    			NULL,
            STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE |
            STGM_DELETEONRELEASE,
            0,
            &lpTemp->m_lpObjStorage);

    assert(hErr == NOERROR);

    if (hErr != NOERROR)
    {
        delete lpTemp;
        return NULL;
    }

    // Clone the source object
    if (lpSite->m_lpOleObject)
    {
        // Object is loaded; ask the object to save into the new storage
        LPPERSISTSTORAGE pPersistStorage;

        if (lpSite->m_lpOleObject->QueryInterface(IID_IPersistStorage,
                (LPVOID FAR*)&pPersistStorage) != ResultFromScode(S_OK))
        {
           /* cannot find interface
            */
           return(NULL);
        }
        assert(pPersistStorage);
        if (OleSave(pPersistStorage, lpTemp->m_lpObjStorage, FALSE)
            != ResultFromScode(S_OK))
        {
            TestDebugOut("Fail in OleSave\n");
        }

        // pass NULL so that object application won't forget the real stg
        if (pPersistStorage->SaveCompleted(NULL) != ResultFromScode(S_OK))
        {
          TestDebugOut("Fail in IPersistStorage::SaveCompleted\n");
        }
        pPersistStorage->Release();
    }
    else
    {
        // Object not loaded so use cheaper IStorage CopyTo operation
        lpSite->m_lpObjStorage->CopyTo(0, NULL, NULL, lpTemp->m_lpObjStorage);
    }

    if (OleLoad(lpTemp->m_lpObjStorage, IID_IOleObject, NULL,
                (LPVOID FAR*)&lpTemp->m_lpOleObject)
        != ResultFromScode(S_OK))
    {
       /* we cannot load the embedded/linked object into the memory
        */
       return(NULL);
    }
    assert(lpTemp->m_lpOleObject);

    lpTemp->m_sizel = lpSite->m_sizel;
    if (pPointl)
    	lpTemp->m_pointl = *pPointl;
    else
    	lpTemp->m_pointl.x = lpTemp->m_pointl.y = 0;
    return lpTemp;
}

//**********************************************************************
//
// CDataXferObj::CDataXferObj
//
// Purpose:
//
//      Constructor for CDataXferObj
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//
//********************************************************************

CDataXferObj::CDataXferObj (void)
{
    // clear the reference count
    m_nCount = 0;

    m_lpObjStorage = NULL;
    m_lpOleObject = NULL;
    m_sizel.cx = m_sizel.cy = 0;
    m_pointl.x = m_pointl.y = 0;
}

//**********************************************************************
//
// CDataXferObj::~CDataXferObj
//
// Purpose:
//
//      Destructor for CDataXferObj
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::Release                     Object
//      IStorage::Release                       OLE API
//
//
//********************************************************************

CDataXferObj::~CDataXferObj ()
{
    TestDebugOut ("In CDataXferObj's Destructor \r\n");

    if (m_lpOleObject)
    {
       m_lpOleObject->Release();
       m_lpOleObject = NULL;

       // Release the storage for this object
       m_lpObjStorage->Release();
       m_lpObjStorage = NULL;
    }
}



//**********************************************************************
//
// CDataXferObj::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation of the CDataXferObj instance
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK            -   The interface is supported.
//      E_NOINTERFACE   -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      CDataXferObj::AddRef        DXFEROBJ.CPP
//
//
//********************************************************************

STDMETHODIMP CDataXferObj::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In CDataXferObj::QueryInterface\r\n");

    if (IsEqualIID( riid, IID_IUnknown) || IsEqualIID(riid, IID_IDataObject))
    {
        AddRef();
        *ppvObj = this;
        return NOERROR;
    }

    // unknown interface requested
    *ppvObj = NULL;     // must set out pointer parameters to NULL
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CDataXferObj::AddRef
//
// Purpose:
//
//      Increments the reference count of the CDataXferObj instance
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the object
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CDataXferObj::AddRef()
{
    TestDebugOut("In CDataXferObj::AddRef\r\n");

    return ++m_nCount;
}

//**********************************************************************
//
// CDataXferObj::Release
//
// Purpose:
//
//      Decrements the reference count of the CDataXferObj object
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the object.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CDataXferObj::Release()
{
    TestDebugOut("In CDataXferObj::Release\r\n");

    if (--m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}


/********************************************************************
** This IDataObject implementation is used for data transfer.
**
** The following methods are NOT supported for data transfer:
**		IDataObject::SetData	-- return E_NOTIMPL
**		IDataObject::DAdvise -- return OLE_E_ADVISENOTSUPPORTED
**				   ::DUnadvise
**				   ::EnumDAdvise
**		IDataObject::GetCanonicalFormatEtc -- return E_NOTIMPL
**						(NOTE: must set pformatetcOut->ptd = NULL)
*********************************************************************/

    	
//**********************************************************************
//
// CDataXferObj::QueryGetData
//
// Purpose:
//
//      Called to determine if our object supports a particular
//      FORMATETC.
//
// Parameters:
//
//      LPFORMATETC pformatetc  - Pointer to the FORMATETC being queried for.
//
// Return Value:
//
//      DV_E_FORMATETC    - The FORMATETC is not supported
//      S_OK              - The FORMATETC is supported.
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
// Comments:
//      we support the following formats:
//          "Embedded Object"
//          "Object Descriptor"
//          CF_METAFILEPICT
//
//********************************************************************
STDMETHODIMP CDataXferObj::QueryGetData (LPFORMATETC pformatetc)
{
    SCODE sc = DV_E_FORMATETC;

    TestDebugOut("In CDataXferObj::QueryGetData\r\n");

    // check the validity of the formatetc.

    if ( (pformatetc->cfFormat == g_cfEmbeddedObject) &&
         (pformatetc->dwAspect == DVASPECT_CONTENT) &&
         (pformatetc->tymed == TYMED_ISTORAGE) )
    {
        sc = S_OK;
    }

    else if ( (pformatetc->cfFormat == g_cfObjectDescriptor) &&
         (pformatetc->dwAspect == DVASPECT_CONTENT) &&
         (pformatetc->tymed == TYMED_HGLOBAL) )
    {
        sc = S_OK;
    }

    else if ( (pformatetc->cfFormat == CF_METAFILEPICT) &&
         (pformatetc->dwAspect == DVASPECT_CONTENT) &&
         (pformatetc->tymed == TYMED_MFPICT) )
    {
        sc = S_OK;
    }
    else if ( (pformatetc->cfFormat == CF_HDROP) &&
	 (pformatetc->dwAspect == DVASPECT_CONTENT) &&
	 (pformatetc->tymed == TYMED_HGLOBAL) )
    {
	sc = S_OK;
    }

    return ResultFromScode(sc);
}

extern BOOL gfUseEmptyEnumerator;

//**********************************************************************
//
// CDataXferObj::EnumFormatEtc
//
// Purpose:
//
//      Enumerates the formats that can be used to store data
//
// Parameters:
//
//      DWORD dwDirection                - format to be enumerated
//
//      LPENUMFORMATETC ppenumFormatEtc  - where to return the
//                                         instantiated enumerator
//
// Return Value:
//
//      S_OK              - if the operation is successful
//      E_OUTOFMEMORY     - if ran out of memory
//      E_NOTIMPL         - if dwDirection is not supported
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//      OleStdEnumFmtEtc_Create     OLE2UI
//
//**********************************************************************

STDMETHODIMP CDataXferObj::EnumFormatEtc(
		DWORD dwDirection,
		LPENUMFORMATETC FAR* ppenumFormatEtc
)
{
    SCODE sc = E_NOTIMPL;

    TestDebugOut("In CDataXferObj::EnumFormatEtc\r\n");
    *ppenumFormatEtc = NULL;

    if( gfUseEmptyEnumerator == TRUE )
    {
	return E_FAIL;
    }

    if (dwDirection == DATADIR_GET)
    {
        *ppenumFormatEtc = OleStdEnumFmtEtc_Create(
                sizeof(s_arrGetFmtEtcs)/sizeof(s_arrGetFmtEtcs[0]),
                s_arrGetFmtEtcs);
        if (*ppenumFormatEtc == NULL)
            sc = E_OUTOFMEMORY;
        else
        	   sc = S_OK;
    }
    return ResultFromScode(sc);
}


//**********************************************************************
//
// CDataXferObj::GetData
//
// Purpose:
//
//      Returns the data in the format specified in pformatetcIn.
//
// Parameters:
//
//      LPFORMATETC pformatetcIn    -   The format requested by the caller
//
//      LPSTGMEDIUM pmedium         -   The medium requested by the caller
//
// Return Value:
//
//      DV_E_FORMATETC    - Format not supported
//      S_OK              - Success
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      OleStdGetOleObjectData          OLE2UI API
//      OleStdGetMetafilePictFromOleObject OLE2UI API
//      OleStdGetObjectDescriptorDataFromOleObject OLE2UI API
//      ResultFromScode                 OLE API
//      IOleObject::QueryInterface      Object
//
// Comments:
//      we support GetData for the following formats:
//          "Embedded Object"
//          "Object Descriptor"
//          CF_METAFILEPICT
//
//********************************************************************

STDMETHODIMP CDataXferObj::GetData (
		LPFORMATETC pformatetcIn,
		LPSTGMEDIUM pmedium
)
{
    SCODE sc = DV_E_FORMATETC;

    TestDebugOut("In CDataXferObj::GetData\r\n");

    // we must set all out pointer parameters to NULL. */
    pmedium->tymed = TYMED_NULL;
    pmedium->pUnkForRelease = NULL;    // we transfer ownership to caller
    pmedium->hGlobal = NULL;

    // Check the FORMATETC and fill pmedium if valid.
    if ( (pformatetcIn->cfFormat == g_cfEmbeddedObject) &&
         (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
         (pformatetcIn->tymed == TYMED_ISTORAGE) )
    {
         LPPERSISTSTORAGE pPersistStorage;

         /* render CF_EMBEDDEDOBJECT by asking the object to save
         **    into a temporary, DELETEONRELEASE IStorage allocated by us.
         */
         HRESULT hRes;
         if ((hRes=m_lpOleObject->QueryInterface(
                 IID_IPersistStorage, (LPVOID FAR*)&pPersistStorage))
             != ResultFromScode(S_OK))
         {
             return(hRes);
         }

         assert(pPersistStorage);
         HRESULT hrErr = OleStdGetOleObjectData(
                    pPersistStorage,
                    pformatetcIn,
                    pmedium,
                    FALSE   /* fUseMemory -- (use file-base stg) */
         );
         pPersistStorage->Release();
         sc = GetScode( hrErr );

    }
    else if ( (pformatetcIn->cfFormat == g_cfObjectDescriptor) &&
         (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
         (pformatetcIn->tymed == TYMED_HGLOBAL) )
    {

         // render CF_OBJECTDESCRIPTOR data
         pmedium->hGlobal = OleStdGetObjectDescriptorDataFromOleObject(
                m_lpOleObject,
                TEXT("Simple OLE 2.0 Container"), //string to identify source
                DVASPECT_CONTENT,
                m_pointl,
                (LPSIZEL)&m_sizel
            );
         if (! pmedium->hGlobal)
             sc = E_OUTOFMEMORY;
         else
         {
             pmedium->tymed = TYMED_HGLOBAL;
             sc = S_OK;
         }

    }
    else if ( (pformatetcIn->cfFormat == CF_METAFILEPICT) &&
            (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
            (pformatetcIn->tymed == TYMED_MFPICT) )
    {

	// render CF_METAFILEPICT by drawing the object into a metafile DC
	pmedium->hGlobal = OleStdGetMetafilePictFromOleObject(
	     m_lpOleObject, DVASPECT_CONTENT, NULL, pformatetcIn->ptd);
	if (! pmedium->hGlobal)
	   sc = E_OUTOFMEMORY;
	else
	{
	   pmedium->tymed = TYMED_MFPICT;
	   sc = S_OK;
	}
    }
    else if ( (pformatetcIn->cfFormat == CF_HDROP) &&
	    (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
	    (pformatetcIn->tymed == TYMED_HGLOBAL) )
    {
	// testing for Win3.1 style drag drop.  If we offer
	// CF_HDROP ( basically, a list of filenames) in a data object
	// given to OLE DoDragDrop, then DoDragDrop will translate
	// OLE drag drop into Win3.1 drag drop for Win3.1 drop targets

	ULONG cbFile;
	char szFile[256];
	DROPFILESTRUCT *pdfs;
	char *pfile;


	cbFile = GetEnvironmentVariable("SystemRoot", szFile, sizeof(szFile));

	if( cbFile == 0 )
	{
	    sc = E_FAIL;
	    goto errRtn;
	}


	cbFile += sizeof("\\setup.txt");

	strcat(szFile, "\\setup.txt");
	
	pmedium->tymed = TYMED_HGLOBAL;

	pmedium->hGlobal = GlobalAlloc( GMEM_DDESHARE,
			    sizeof(DROPFILESTRUCT) +
			    cbFile + 3);

	if( pmedium->hGlobal )
	{
	    pdfs = (DROPFILESTRUCT *)GlobalLock(pmedium->hGlobal);

	    if( pdfs )
	    {
		pdfs->pFiles = sizeof(DROPFILESTRUCT);
		pfile = (char *)((BYTE *)pdfs) + sizeof(DROPFILESTRUCT);
		pdfs->fNC = FALSE;
		pdfs->fWide = FALSE;
		pdfs->pt.x = 0;
		pdfs->pt.y = 0;
		strcpy(pfile, szFile);
		// double-NULL terminate it
		pfile[strlen(pfile)+2] = '\0';

		GlobalUnlock(pmedium->hGlobal);

		sc = S_OK;
	    }
	    else
	    {
		sc = E_OUTOFMEMORY;
	    }
	}
	else
	{
	    sc = E_OUTOFMEMORY;
	}
    }

errRtn:

    return ResultFromScode( sc );
}

//**********************************************************************
//
// CDataXferObj::GetDataHere
//
// Purpose:
//
//      Called to get a data format in a caller supplied location
//
// Parameters:
//
//      LPFORMATETC pformatetc  - FORMATETC requested
//
//      LPSTGMEDIUM pmedium     - Medium to return the data
//
// Return Value:
//
//      NOERROR             - if OleStdGetOleObjectData success
//      DATA_E_FORMATETC    - We don't support the requested format
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      OleStdGetOleObjectData      OLE2UI API
//      IOleObject::QueryInterface  Object
//
//
//********************************************************************

STDMETHODIMP CDataXferObj::GetDataHere (
		LPFORMATETC pformatetc,
		LPSTGMEDIUM pmedium
)
{
    SCODE sc = DV_E_FORMATETC;

    TestDebugOut("In CDataXferObj::GetDataHere\r\n");

    // NOTE: pmedium is an IN parameter. we should NOT set
    //           pmedium->pUnkForRelease to NULL

    // Check the FORMATETC and fill pmedium if valid.
    if ( (pformatetc->cfFormat == g_cfEmbeddedObject) &&
         (pformatetc->dwAspect == DVASPECT_CONTENT) &&
         (pformatetc->tymed == TYMED_ISTORAGE) )
    {
         LPPERSISTSTORAGE pPersistStorage;

         /* render CF_EMBEDDEDOBJECT by asking the object to save
         **    into the IStorage allocated by the caller.
         */
         HRESULT hRes;

         if ((hRes=m_lpOleObject->QueryInterface(
                 IID_IPersistStorage, (LPVOID FAR*)&pPersistStorage))
             != ResultFromScode(S_OK))
         {
             return(hRes);
         }
         assert(pPersistStorage);
         HRESULT hrErr = OleStdGetOleObjectData(
                 pPersistStorage, pformatetc, pmedium,0 /*fUseMemory--N/A*/ );
         pPersistStorage->Release();
         sc = GetScode( hrErr );
    }
    return ResultFromScode( sc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\ias.h ===
//**********************************************************************
// File name: IAS.H
//
//      Definition of CAdviseSink
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IAS_H_ )
#define _IAS_H_

#include <assert.h>

class CSimpleSite;

interface CAdviseSink : public IAdviseSink
{
    CSimpleSite FAR * m_pSite;

    CAdviseSink(CSimpleSite FAR * pSite)
       {
        TestDebugOut("In IAS's constructor\r\n");
        m_pSite = pSite;
       };

    ~CAdviseSink()
       {
        TestDebugOut("In IAS's destructor\r\n");
       };

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    // *** IAdviseSink methods ***
    STDMETHODIMP_(void) OnDataChange (FORMATETC FAR* pFormatetc, STGMEDIUM FAR* pStgmed);
    STDMETHODIMP_(void) OnViewChange (DWORD dwAspect, LONG lindex);
    STDMETHODIMP_(void) OnRename (LPMONIKER pmk);
    STDMETHODIMP_(void) OnSave ();
    STDMETHODIMP_(void) OnClose ();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\ids.h ===
//**********************************************************************
// File name: ids.h
//
//      Definition of CDropSource
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IDS_H_ )
#define _IDS_H_

#include <assert.h>

class CSimpleDoc;

interface CDropSource : public IDropSource
{
    CSimpleDoc FAR * m_pDoc;

    CDropSource(CSimpleDoc FAR * pDoc)
       {
        TestDebugOut("In IDS's constructor\r\n");
        m_pDoc = pDoc;
       };

    ~CDropSource()
       {
        TestDebugOut("In IDS's destructor\r\n");
       };

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

       // *** IDropSource methods ***
    STDMETHODIMP QueryContinueDrag (BOOL fEscapePressed, DWORD grfKeyState);
    STDMETHODIMP GiveFeedback (DWORD dwEffect);

private:

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\pre.cpp ===
//**********************************************************************
// File name: pre.cpp
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\ids.cpp ===
//**********************************************************************
// File name: IDS.CPP
//
//      Implementation file for CDropSource
//
// Functions:
//
//      See IDS.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "app.h"
#include "doc.h"
#include "site.h"
#include "dxferobj.h"




//+-------------------------------------------------------------------------
//
//  Member:     CSimpleDoc::FailureNotifyHelper(
//
//  Synopsis:   Report a drag drop error
//
//  Arguments:  [pszMsg] - Message
//              [dwData] - Data to print out
//
//  Algorithm:  Print a message box for fatal errors during drag drop
//              operation.
//
//  History:    dd-mmm-yy Author    Comment
//     		06-May-94 Ricksa    author
//
//--------------------------------------------------------------------------
void CSimpleDoc::FailureNotifyHelper(TCHAR *pszMsg, DWORD dwData)
{
    TCHAR pszBuf[256];

    wsprintf(pszBuf, TEXT("%s %lx"), pszMsg, dwData);

    MessageBox(m_hDocWnd, pszBuf, TEXT("Drag/Drop Error"), MB_OK);
}



//**********************************************************************
//
// CSimpleDoc::QueryDrag
//
// Purpose:
//
//      Check to see if Drag operation should be initiated based on the
//      current position of the mouse.
//
// Parameters:
//
//      POINT pt                - position of mouse
//
// Return Value:
//
//      BOOL                    - TRUE if drag should take place,
//                                else FALSE
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::GetObjRect     SITE.CPP
//      PtInRect                    Windows API
//
//
//********************************************************************

BOOL CSimpleDoc::QueryDrag(POINT pt)
{
    // if pt is within rect of object, then start drag
    if (m_lpSite)
    {
        RECT rect;
        m_lpSite->GetObjRect(&rect);
        return ( PtInRect(&rect, pt) ? TRUE : FALSE );
    }
    else
        return FALSE;
}


//**********************************************************************
//
// CSimpleDoc::DoDragDrop
//
// Purpose:
//
//      Actually perform a drag/drop operation with the current
//      selection in the source document.
//
// Parameters:
//
//      none.
//
// Return Value:
//
//      DWORD                    - returns the result effect of the
//                                 drag/drop operation:
//                                      DROPEFFECT_NONE,
//                                      DROPEFFECT_COPY,
//                                      DROPEFFECT_MOVE, or
//                                      DROPEFFECT_LINK
//
// Function Calls:
//      Function                    Location
//
//      CDataXferObj::Create        DXFEROBJ.CPP
//      CDataXferObj::QueryInterface DXFEROBJ.CPP
//      CDataXferObj::Release       DXFEROBJ.CPP
//      DoDragDrop                  OLE API
//      TestDebugOut           Windows API
//      MessageBox                  Windows API
//
//
//********************************************************************

DWORD CSimpleDoc::DoDragDrop (void)
{
    DWORD       dwEffect     = 0;
    LPDATAOBJECT lpDataObj;

    TestDebugOut("In CSimpleDoc::DoDragDrop\r\n");

    // Create a data transfer object by cloning the existing OLE object
    CDataXferObj FAR* pDataXferObj = CDataXferObj::Create(m_lpSite,NULL);

    if (! pDataXferObj)
    {
        MessageBox(NULL, TEXT("Out-of-memory"), TEXT("SimpDnD"),
                   MB_SYSTEMMODAL | MB_ICONHAND);
        return DROPEFFECT_NONE;
    }

    // initially obj is created with 0 refcnt. this QI will make it go to 1.
    pDataXferObj->QueryInterface(IID_IDataObject, (LPVOID FAR*)&lpDataObj);
    assert(lpDataObj);

    m_fLocalDrop     = FALSE;
    m_fLocalDrag     = TRUE;

    HRESULT hRes;
    hRes=::DoDragDrop(lpDataObj,
                 &m_DropSource,
                 m_lpApp->m_dwSourceEffect, 	// we only allow copy
                 &dwEffect);

    if (hRes!=ResultFromScode(S_OK)
       && hRes!=ResultFromScode(DRAGDROP_S_DROP)
       && hRes!=ResultFromScode(DRAGDROP_S_CANCEL))
    {
        FailureNotifyHelper(
            TEXT("Unexpected error from DoDragDrop"), hRes);
    }

    // Validate the responses
    if (hRes == ResultFromScode(DRAGDROP_S_DROP))
    {
        // Drop was successful so make sure the effects make sense
        if (((dwEffect & m_lpApp->m_dwSourceEffect) == 0)
            && (dwEffect != DROPEFFECT_NONE))
        {
            FailureNotifyHelper(
                TEXT("Unexpected Effect on DRAGDROP_S_DROP from DoDragDrop"),
                    dwEffect);
        }
    }
    else if ((hRes == ResultFromScode(DRAGDROP_S_CANCEL))
        || (hRes == ResultFromScode(S_OK)))
    {
        // Drop was cancelled/or never happened so the effect s/b none
        if (dwEffect != DROPEFFECT_NONE)
        {
            FailureNotifyHelper(
                TEXT("Unexpected Effect on S_OK or Cancel from DoDragDrop"),
                    dwEffect);
        }
    }

    m_fLocalDrag     = FALSE;

    /* if after the Drag/Drop modal (mouse capture) loop is finished
    **    and a drag MOVE operation was performed, then we must delete
    **    the selection that was dragged.
    */
    if ( (dwEffect & DROPEFFECT_MOVE) != 0 )
    {
        // Dump our object - we never save it.
        m_lpApp->lCreateDoc(m_lpApp->m_hAppWnd, 0, 0, 0);
    }

    pDataXferObj->Release();    // this should destroy the DataXferObj
    return dwEffect;
}



//**********************************************************************
//
// CDropSource::QueryInterface
//
// Purpose:
//
//      Return a pointer to a requested interface
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      S_OK                -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleDoc::QueryInterface  DOC.CPP
//
//
//********************************************************************

STDMETHODIMP CDropSource::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In IDS::QueryInterface\r\n");

    // delegate to the document
    return m_pDoc->QueryInterface(riid, ppvObj);
}


//**********************************************************************
//
// CDropSource::AddRef
//
// Purpose:
//
//      Increments the reference count of CSimpleDoc. Since CDropSource is
//      a nested class of CSimpleDoc, we don't need a separate reference
//      count for the CDropSource. We can safely use the reference count
//      of CSimpleDoc here.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleDoc
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::AddRef          DOC.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropSource::AddRef()
{
    TestDebugOut("In IDS::AddRef\r\n");

    // delegate to the document Object
    return m_pDoc->AddRef();
}

//**********************************************************************
//
// CDropSource::Release
//
// Purpose:
//
//      Decrements the reference count of CSimpleDoc. Since CDropSource is
//      a nested class of CSimpleDoc, we don't need a separate reference
//      count for the CDropSource. We can safely use the reference count
//      of CSimpleDoc here.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleDoc
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::Release         DOC.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropSource::Release()
{
    TestDebugOut("In IDS::Release\r\n");

    // delegate to the document object
    return m_pDoc->Release();
}
    	
//**********************************************************************
//
// CDropSource::QueryContinueDrag
//
// Purpose:
//
//      Called to determine if a drop should take place or be canceled.
//
// Parameters:
//
//      BOOL fEscapePressed - TRUE if ESCAPE key has been pressed
//      DWORD grfKeyState   - key state
//
// Return Value:
//
//      DRAGDROP_S_CANCEL   - drag operation should be canceled
//      DRAGDROP_S_DROP     - drop operation should be performed
//      S_OK                - dragging should continue
//
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP CDropSource::QueryContinueDrag (
        BOOL    fEscapePressed,
        DWORD   grfKeyState
)
{
    if (fEscapePressed)
        return ResultFromScode(DRAGDROP_S_CANCEL);
    else
       if (!(grfKeyState & MK_LBUTTON))
          return ResultFromScode(DRAGDROP_S_DROP);
       else
          return NOERROR;
}

    	
//**********************************************************************
//
// CDropSource::GiveFeedback
//
// Purpose:
//
//      Called to set cursor feedback
//
// Parameters:
//
//      DWORD dwEffect      - drop operation to give feedback for
//
// Return Value:
//
//      DRAGDROP_S_USEDEFAULTCURSORS  - tells OLE to use standard cursors
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP CDropSource::GiveFeedback (DWORD dwEffect)
{
    return ResultFromScode(DRAGDROP_S_USEDEFAULTCURSORS);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\ias.cpp ===
//**********************************************************************
// File name: IAS.CPP
//
//      Implementation file of CAdviseSink
//
//
// Functions:
//
//      See IAS.H for Class Definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// CAdviseSink::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         - The requested interface
//
//      LPVOID FAR* ppvObj  - Place to return the interface
//
// Return Value:
//
//      HRESULT from CSimpleSite::QueryInterface
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::QueryInterface SITE.CPP
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function simply delegates to the Object class, which is
//      aware of the supported interfaces.
//
//********************************************************************

STDMETHODIMP CAdviseSink::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In IAS::QueryInterface\r\n");

    // delegate to the document Object
    return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CAdviseSink::AddRef
//
// Purpose:
//
//      Increments the reference count on the CSimpleSite. Since CAdviseSink
//      is a nested class of CSimpleSite, we don't need a separate reference
//      count for CAdviseSink. We can just use the reference count of
//      CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::AddRef         SITE.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::AddRef()
{
    TestDebugOut("In IAS::AddRef\r\n");

    // delegate to the container Site
    return m_pSite->AddRef();
}

//**********************************************************************
//
// CAdviseSink::Release
//
// Purpose:
//
//      Decrements the reference count on the CSimpleSite. Since CAdviseSink
//      is a nested class of CSimpleSite, we don't need a separate reference
//      count for CAdviseSink. We can just use the reference count of
//      CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::Release        SITE.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CAdviseSink::Release()
{
    TestDebugOut("In IAS::Release\r\n");

    // delegate to the container Site
    return m_pSite->Release();
}

//**********************************************************************
//
// CAdviseSink::OnDataChange
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      FORMATETC pFormatetc     -   data format infomation
//      STGMEDIUM pStgmed        -   storage medium on which data is passed
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnDataChange (FORMATETC FAR* pFormatetc,
                                               STGMEDIUM FAR* pStgmed)
{
    TestDebugOut("In IAS::OnDataChange\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnViewChange
//
// Purpose:
//
//      Notifies us that the view has changed and needs to be updated.
//
// Parameters:
//
//      DWORD dwAspect  - Aspect that has changed
//
//      LONG lindex     - Index that has changed
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      InvalidateRect              Windows API
//      IViewObject2::GetExtent     Object
//      IViewObject2::Release       Object
//      IOleObject::QueryInterface  Object
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnViewChange (DWORD dwAspect, LONG lindex)
{
    LPVIEWOBJECT2 lpViewObject2;
    TestDebugOut("In IAS::OnViewChange\r\n");

    // get a pointer to IViewObject2
    HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(
            IID_IViewObject2,
            (LPVOID FAR *)&lpViewObject2);

    if (hErr == NOERROR)
    {
        // get extent of the object
        // NOTE: this method will never be remoted; it can be called w/i
        // this async method
        lpViewObject2->GetExtent(DVASPECT_CONTENT, -1 , NULL,
                                 &m_pSite->m_sizel);
        lpViewObject2->Release();
    }

    // need to clean up the region
    InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);
}

//**********************************************************************
//
// CAdviseSink::OnRename
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      LPMONIKER pmk         -  pointer to moniker
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnRename (LPMONIKER pmk)
{
    TestDebugOut("In IAS::OnRename\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnSave
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnSave ()
{
    TestDebugOut("In IAS::OnSave\r\n");
}

//**********************************************************************
//
// CAdviseSink::OnClose
//
// Purpose:
//
//      Not Implemented (needs to be stubbed out)
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(void) CAdviseSink::OnClose()
{
    TestDebugOut("In IAS::OnClose\r\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\idt.cpp ===
//**********************************************************************
// File name: IDT.CPP
//
//      Implementation file for CDropTarget
//
// Functions:
//
//      See IDT.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include "idt.h"

extern CLIPFORMAT g_cfObjectDescriptor;


//**********************************************************************
//
// CDropTarget::QueryDrop
//
// Purpose:
//
//      Check if the desired drop operation (identified by the given key
//      state) is possible at the current mouse position (pointl).
//
// Parameters:
//
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      BOOL fDragScroll        - TRUE if drag scrolling cursor should
//                                be shown.
//      LPDWORD pdwEffect       - (OUT) drag effect that should occur
//
// Return Value:
//
//      BOOL                    - TRUE if drop could take place,
//                                else FALSE
//
// Function Calls:
//      Function                    Location
//
//      OleStdGetDropEffect         OLE2UI API
//
//
//********************************************************************

BOOL CDropTarget::QueryDrop (
    DWORD           grfKeyState,
    POINTL          pointl,
    BOOL            fDragScroll,
    LPDWORD         pdwEffect
)
{
    DWORD      dwScrollEffect = 0L;
    DWORD      dwOKEffects = m_pDoc->m_lpApp->m_dwTargetEffect & *pdwEffect;

    /* check if the cursor is in the active scroll area, if so need the
    **    special scroll cursor.
    */
    if (fDragScroll)
        dwScrollEffect = DROPEFFECT_SCROLL;

    /* if we have already determined that the source does NOT have any
    **    acceptable data for us, the return NO-DROP
    */
    if (! m_fCanDropCopy && ! m_fCanDropLink)
        goto dropeffect_none;

    /* OLE2NOTE: determine what type of drop should be performed given
    **    the current modifier key state. we rely on the standard
    **    interpretation of the modifier keys:
    **          no modifier -- DROPEFFECT_MOVE or whatever is allowed by src
    **          SHIFT       -- DROPEFFECT_MOVE
    **          CTRL        -- DROPEFFECT_COPY
    **          CTRL-SHIFT  -- DROPEFFECT_LINK
    */

    *pdwEffect = OleStdGetDropEffect(grfKeyState);
    if (*pdwEffect == 0)
    {
        // No modifier keys given. Try in order MOVE, COPY, LINK.
        if ((DROPEFFECT_MOVE & dwOKEffects) && m_fCanDropCopy)
            *pdwEffect = DROPEFFECT_MOVE;
        else if ((DROPEFFECT_COPY & dwOKEffects) && m_fCanDropCopy)
            *pdwEffect = DROPEFFECT_COPY;
        else if ((DROPEFFECT_LINK & dwOKEffects) && m_fCanDropLink)
            *pdwEffect = DROPEFFECT_LINK;
        else
            goto dropeffect_none;
    }
    else
    {
        /* OLE2NOTE: we should check if the drag source application allows
        **    the desired drop effect.
        */
        if (!(*pdwEffect & dwOKEffects))
            goto dropeffect_none;

        if ((*pdwEffect == DROPEFFECT_COPY || *pdwEffect == DROPEFFECT_MOVE)
                && ! m_fCanDropCopy)
            goto dropeffect_none;

        if (*pdwEffect == DROPEFFECT_LINK && ! m_fCanDropLink)
            goto dropeffect_none;
    }

    *pdwEffect |= dwScrollEffect;
    return TRUE;

dropeffect_none:

    *pdwEffect = DROPEFFECT_NONE;
    return FALSE;
}


//**********************************************************************
//
// CDropTarget::QueryDrop
//
// Purpose:
//
//     Check to see if Drag scroll operation should be initiated.
//
// Parameters:
//
//      POINTL pointl           - position of mouse
//
// Return Value:
//
//      BOOL                    - TRUE if scroll cursor should be given
//                                else FALSE
//
// Function Calls:
//      Function                    Location
//
//      ScreenToClient              WINDOWS API
//      GetClientRect               WINDOWS API
//
// Comments:
//     A Drag scroll operation should be initiated when the mouse has
//     remained in the active scroll area (11 pixels frame around border
//     of window) for a specified amount of time (50ms).
//
//********************************************************************

BOOL CDropTarget::DoDragScroll (POINTL pointl)
{
    DWORD dwScrollDir = SCROLLDIR_NULL;
    DWORD dwTime = GetCurrentTime();
    int nScrollInset = m_pDoc->m_lpApp->m_nScrollInset;
    int nScrollDelay = m_pDoc->m_lpApp->m_nScrollDelay;
    int nScrollInterval = m_pDoc->m_lpApp->m_nScrollInterval;
    POINT point;
    RECT rect;

    point.x = (int)pointl.x;
    point.y = (int)pointl.y;

    ScreenToClient( m_pDoc->m_hDocWnd, &point);
    GetClientRect ( m_pDoc->m_hDocWnd, (LPRECT) &rect );

    if (rect.top <= point.y && point.y<=(rect.top+nScrollInset))
        dwScrollDir = SCROLLDIR_UP;
    else if ((rect.bottom-nScrollInset) <= point.y && point.y <= rect.bottom)
        dwScrollDir = SCROLLDIR_DOWN;
    else if (rect.left <= point.x && point.x <= (rect.left+nScrollInset))
        dwScrollDir = SCROLLDIR_LEFT;
    else if ((rect.right-nScrollInset) <= point.x && point.x <= rect.right)
        dwScrollDir = SCROLLDIR_RIGHT;

    if (m_dwTimeEnterScrollArea)
    {
        /* cursor was already in Scroll Area */

        if (! dwScrollDir)
        {
            /* cusor moved OUT of scroll area.
            **      clear "EnterScrollArea" time.
            */
            m_dwTimeEnterScrollArea = 0L;
            m_dwNextScrollTime = 0L;
            m_dwLastScrollDir = SCROLLDIR_NULL;

        }
        else
           if (dwScrollDir != m_dwLastScrollDir)
           {
            /* cusor moved into a different direction scroll area.
            **      reset "EnterScrollArea" time to start a new 50ms delay.
            */
            m_dwTimeEnterScrollArea = dwTime;
            m_dwNextScrollTime = dwTime + (DWORD)nScrollDelay;
            m_dwLastScrollDir = dwScrollDir;

           }
           else
              if (dwTime && dwTime >= m_dwNextScrollTime)
              {
                 m_pDoc->Scroll ( dwScrollDir );    // Scroll document now
                 m_dwNextScrollTime = dwTime + (DWORD)nScrollInterval;
              }
    }
    else
    {
        if (dwScrollDir)
        {
            /* cusor moved INTO a scroll area.
            **   reset "EnterScrollArea" time to start a new 50ms delay.
            */
            m_dwTimeEnterScrollArea = dwTime;
            m_dwNextScrollTime = dwTime + (DWORD)nScrollDelay;
            m_dwLastScrollDir = dwScrollDir;
        }
    }

    return (dwScrollDir ? TRUE : FALSE);
}


// Support functions/macros
#define SetTopLeft(rc, pt)		\
	((rc)->top = (pt)->y,(rc)->left = (pt)->x)
#define SetBottomRight(rc, pt)		\
	((rc)->bottom = (pt)->y,(rc)->right = (pt)->x)
#define OffsetPoint(pt, dx, dy)		\
	((pt)->x += dx, (pt)->y += dy)


/* HighlightRect
** -------------
**    Invert rectangle on screen. used for drop target feedback.
*/

static int HighlightRect(HWND hwnd, HDC hdc, LPRECT rc)
{
    POINT pt1, pt2;
    int old = SetROP2(hdc, R2_NOT);
    HPEN hpen;
    HGDIOBJ hold;

    pt1.x = rc->left;
    pt1.y = rc->top;
    pt2.x = rc->right;
    pt2.y = rc->bottom;

    ScreenToClient(hwnd, &pt1);
    ScreenToClient(hwnd, &pt2);

    hold = SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
    hpen = (HPEN) SelectObject(hdc, CreatePen(PS_SOLID, 2,
                          GetSysColor(COLOR_ACTIVEBORDER)));

    Rectangle(hdc, pt1.x, pt1.y, pt2.x, pt2.y);

    SetROP2(hdc, old);

    hold = SelectObject(hdc, hold);
    hpen = (HPEN) SelectObject(hdc, hpen);

    DeleteObject(hpen);

  return 0;
}


//**********************************************************************
//
// CDropTarget::InitDragFeedback
//
// Purpose:
//
//      Initialize data used to draw drop target feedback.
//      As feedback we draw a rectangle the size of the object.
//
// Parameters:
//
//      LPDATAOBJECT pDataObj   - IDataObject from Drop source
//      POINTL pointl           - position of mouse
//
// Return Value:
//
//      none.
//
// Function Calls:
//      Function                    Location
//
//      IDataObject::GetData        Object
//      XformSizeInHimetricToPixels OLE2UI Library
//      GlobalLock                  WINDOWS API
//      GlobalUnlock                WINDOWS API
//      ReleaseStgMedium            OLE2 API
//      OffsetPoint                 IDT.CPP
//      SetTopLeft                  IDT.CPP
//      SetBottomRight              IDT.CPP
//
// Comments:
//      In order to know the size of the object before the object
//      is actually dropped, we render CF_OBJECTDESCRIPTOR format.
//      this data format tells us both the size of the object as
//      well as which aspect is the object is displayed as in the
//      source. If the object is currently displayed as DVASPECT_ICON
//      then we want to create the object also as DVASPECT_ICON.
//
//********************************************************************

void CDropTarget::InitDragFeedback(LPDATAOBJECT pDataObj, POINTL pointl)
{
    FORMATETC fmtetc;
    STGMEDIUM stgmed;
    POINT pt;
    int height, width;
    HRESULT hrErr;

    height = width = 100; // some default values
    pt.x = (int)pointl.x;
    pt.y = (int)pointl.y;

    // do a GetData for CF_OBJECTDESCRIPTOR format to get the size of the
    // object as displayed in the source. using this size, initialize the
    // size for the drag feedback rectangle.
    fmtetc.cfFormat = g_cfObjectDescriptor;
    fmtetc.ptd = NULL;
    fmtetc.lindex = -1;
    fmtetc.dwAspect = DVASPECT_CONTENT;
    fmtetc.tymed = TYMED_HGLOBAL;

    hrErr = pDataObj->GetData(&fmtetc, &stgmed);
    if (hrErr == NOERROR)
    {
        LPOBJECTDESCRIPTOR pOD=(LPOBJECTDESCRIPTOR)GlobalLock(stgmed.hGlobal);
        if (pOD != NULL)
        {
            XformSizeInHimetricToPixels(NULL, &pOD->sizel, &pOD->sizel);

            width = (int)pOD->sizel.cx;
            height = (int)pOD->sizel.cy;
            m_dwSrcAspect = pOD->dwDrawAspect;
        }

        GlobalUnlock(stgmed.hGlobal);
        ReleaseStgMedium(&stgmed);
    }

    m_ptLast = pt;
    m_fDragFeedbackDrawn = FALSE;
	
    OffsetPoint(&pt, -(width/2), -(height/2));
    SetTopLeft(&m_rcDragRect, &pt);

    OffsetPoint(&pt, width, height);
    SetBottomRight(&m_rcDragRect, &pt);
}


//**********************************************************************
//
// CDropTarget::UndrawDragFeedback
//
// Purpose:
//
//      Erase any drop target feedback.
//      As feedback we draw a rectangle the size of the object.
//
// Parameters:
//
//      none.
//
// Return Value:
//
//      none.
//
// Function Calls:
//      Function                    Location
//
//      GetDC                       WINDOWS API
//      ReleaseDC                   WINDOWS API
//      HighlightRect               IDT.CPP
//
// Comments:
//      In order to know the size of the object before the object
//      is actually dropped, we render CF_OBJECTDESCRIPTOR format.
//      this data format tells us both the size of the object as
//      well as which aspect is the object is displayed as in the
//      source. if the object is currently displayed as DVASPECT_ICON
//      then we want to create the object also as DVASPECT_ICON.
//
//********************************************************************

void CDropTarget::UndrawDragFeedback( void )
{
    if (m_fDragFeedbackDrawn)
    {
        m_fDragFeedbackDrawn = FALSE;
        HDC hDC = GetDC(m_pDoc->m_hDocWnd);
        HighlightRect(m_pDoc->m_hDocWnd, hDC, &m_rcDragRect);
        ReleaseDC(m_pDoc->m_hDocWnd, hDC);
    }
}


//**********************************************************************
//
// CDropTarget::DrawDragFeedback
//
// Purpose:
//
//      Compute new position of drop target feedback rectangle and
//      erase old rectangle and draw new rectangle.
//      As feedback we draw a rectangle the size of the object.
//
// Parameters:
//
//      POINTL pointl           - position of mouse
//
// Return Value:
//
//      none.
//
// Function Calls:
//      Function                    Location
//
//      OffsetPoint                 IDT.CPP
//      OffsetRect                  IDT.CPP
//      HighlightRect               IDT.CPP
//      GetDC                       WINDOWS API
//      ReleaseDC                   WINDOWS API
//
//
//********************************************************************

void CDropTarget::DrawDragFeedback( POINTL pointl )
{
    POINT ptDiff;

    ptDiff.x = (int)pointl.x - m_ptLast.x;
    ptDiff.y = (int)pointl.y - m_ptLast.y;

    if (m_fDragFeedbackDrawn && (ptDiff.x == 0 && ptDiff.y == 0))
        return;     // mouse did not move; leave rectangle as drawn

    HDC hDC = GetDC(m_pDoc->m_hDocWnd);
    if (m_fDragFeedbackDrawn)
    {
        m_fDragFeedbackDrawn = FALSE;
        HighlightRect(m_pDoc->m_hDocWnd, hDC, &m_rcDragRect);
    }

    OffsetRect(&m_rcDragRect, ptDiff.x, ptDiff.y);
    HighlightRect(m_pDoc->m_hDocWnd, hDC, &m_rcDragRect);
    m_fDragFeedbackDrawn = TRUE;
	 m_ptLast.x = (int)pointl.x;
    m_ptLast.y = (int)pointl.y;
	 ReleaseDC(m_pDoc->m_hDocWnd, hDC);
}


//**********************************************************************
//
// CDropTarget::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      S_OK                -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleDoc::QueryInterface  DOC.CPP
//
//
//********************************************************************

STDMETHODIMP CDropTarget::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In IDT::QueryInterface\r\n");

    // delegate to the document
    return m_pDoc->QueryInterface(riid, ppvObj);
}


//**********************************************************************
//
// CDropTarget::AddRef
//
// Purpose:
//
//      Increments the reference count of CSimpleDoc. Since CDropTarget is
//      a nested class of CSimpleDoc, we don't need a separate reference
//      count for CDropTarget. We can safely use the reference count of
//      CSimpleDoc.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleDoc
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::AddReff         DOC.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropTarget::AddRef()
{
    TestDebugOut("In IDT::AddRef\r\n");

    // delegate to the document Object
    return m_pDoc->AddRef();
}

//**********************************************************************
//
// CDropTarget::Release
//
// Purpose:
//
//      Decrements the reference count of CSimpleDoc. Since CDropTarget is
//      a nested class of CSimpleDoc, we don't need a separate reference
//      count for CDropTarget. We can safely use the reference count of
//      CSimpleDoc.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpleDoc
//
// Function Calls:
//      Function                    Location
//
//      CSimpleDoc::Release         DOC.CPP
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CDropTarget::Release()
{
    TestDebugOut("In IDT::Release\r\n");

    // delegate to the document object
    return m_pDoc->Release();
}


//**********************************************************************
//
// CDropTarget::DragEnter
//
// Purpose:
//
//      Called when the mouse first enters our DropTarget window
//
// Parameters:
//
//      LPDATAOBJECT pDataObj   - IDataObject from Drop source
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      LPDWORD pdwEffect       - (IN-OUT) drag effect that should occur
//                                ON INPUT, this is dwOKEffects that source
//                                passed to DoDragDrop API.
//                                ON OUTPUT, this is the effect that we
//                                want to take effect (used to determine
//                                cursor feedback).
//
// Return Value:
//
//      NOERROR
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      OleQueryCreateFromData      OLE2 API
//      DoDragScroll                IDT.CPP
//      QueryDrop                   IDT.CPP
//      InitDragFeedback            IDT.CPP
//      DrawDragFeedback            IDT.CPP
//
// Comments:
//      Callee should honor the dwEffects as passed in to determine
//      if the caller allows DROPEFFECT_MOVE.
//
//********************************************************************

STDMETHODIMP CDropTarget::DragEnter(LPDATAOBJECT pDataObj, DWORD grfKeyState,
                                     POINTL pointl, LPDWORD pdwEffect)
{
    TestDebugOut("In IDT::DragEnter\r\n");

    /* Determine if the drag source data object offers a data format
    **  that we understand. we accept only creating embedded objects.
    */
    m_fCanDropCopy = ((OleQueryCreateFromData(pDataObj) == NOERROR) ?
            TRUE : FALSE);
    m_fCanDropLink = FALSE; // linking NOT supported in this simple sample

    if (m_fCanDropCopy || m_fCanDropLink)
        InitDragFeedback(pDataObj, pointl);

    BOOL fDragScroll = DoDragScroll ( pointl );

    if (QueryDrop(grfKeyState,pointl,fDragScroll,pdwEffect))
    {
        DrawDragFeedback( pointl );
    }

    // with our drag drop optimization, pDataObj will actually be a
    // wrapper data object.  QueryGetData calls (currently) will be
    // propogated to the drag source (whereas EnumFormatetc is handled
    // locally).  Make sure we can do a QueryGetData.

    FORMATETC formatetc;
    formatetc.cfFormat = CF_METAFILEPICT;
    formatetc.tymed = TYMED_MFPICT;
    formatetc.ptd = NULL;
    formatetc.lindex = -1;
    formatetc.dwAspect = DVASPECT_CONTENT;

    // E_FAIL is usually returned if we could not get the drag source
    // data object.
    if( pDataObj->QueryGetData(&formatetc) == E_FAIL )
    {
	TestDebugOut("WARNING! QueryGetData failed!");
    }

    return NOERROR;
}


//**********************************************************************
//
// CDropTarget::DragOver
//
// Purpose:
//
//      Called when the mouse moves, key state changes, or a time
//      interval passes while the mouse is still within our DropTarget
//      window.
//
// Parameters:
//
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      LPDWORD pdwEffect       - (IN-OUT) drag effect that should occur
//                                ON INPUT, this is dwOKEffects that source
//                                passed to DoDragDrop API.
//                                ON OUTPUT, this is the effect that we
//                                want to take effect (used to determine
//                                cursor feedback).
//
// Return Value:
//
//      NOERROR
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      DoDragScroll                IDT.CPP
//      QueryDrop                   IDT.CPP
//      DrawDragFeedback            IDT.CPP
//      UndrawDragFeedback          IDT.CPP
//
// Comments:
//      Callee should honor the dwEffects as passed in to determine
//      if the caller allows DROPEFFECT_MOVE. OLE pulses the DragOver
//      calls in order that the DropTarget can implement drag scrolling
//
//********************************************************************

STDMETHODIMP CDropTarget::DragOver (DWORD grfKeyState, POINTL pointl,
                                    LPDWORD pdwEffect)
{
    TestDebugOut("In IDT::DragOver\r\n");

    BOOL fDragScroll = DoDragScroll ( pointl );

    if (QueryDrop(grfKeyState,pointl,fDragScroll,pdwEffect))
    {
        DrawDragFeedback( pointl );
    }
    else
    {
        UndrawDragFeedback();
    }

    return NOERROR;
}


//**********************************************************************
//
// CDropTarget::DragLeave
//
// Purpose:
//
//      Called when the mouse leaves our DropTarget window
//
// Parameters:
//
//      none.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      UndrawDragFeedback          IDT.CPP
//      ResultFromScode             OLE2 API
//
//
//********************************************************************

STDMETHODIMP CDropTarget::DragLeave ()
{
    TestDebugOut("In IDT::DragLeave\r\n");

    UndrawDragFeedback();

    return ResultFromScode(S_OK);
}


//**********************************************************************
//
// CDropTarget::Drop
//
// Purpose:
//
//      Called when a Drop operation should take place.
//
// Parameters:
//
//      LPDATAOBJECT pDataObj   - IDataObject from Drop source
//      DWORD grfKeyState       - current key state
//      POINTL pointl           - position of mouse
//      LPDWORD pdwEffect       - (IN-OUT) drag effect that should occur
//                                ON INPUT, this is dwOKEffects that source
//                                passed to DoDragDrop API.
//                                ON OUTPUT, this is the effect that we
//                                want to take effect (used to determine
//                                cursor feedback).
//
// Return Value:
//
//      S_OK if sucess or HRESULT of the error code if fails
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::Create         SITE.CPP
//      CSimpleSite::InitObject     SITE.CPP
//      OleCreateFromData           OLE2 API
//      DoDragScroll                IDT.CPP
//      QueryDrop                   IDT.CPP
//      InitDragFeedback            IDT.CPP
//      DrawDragFeedback            IDT.CPP
//      UndrawDragFeedback          IDT.CPP
//      GetScode                    OLE2 API
//      ResultFromScode             OLE2 API
//
// Comments:
//      Callee should honor the dwEffects as passed in to determine
//      if the caller allows DROPEFFECT_MOVE.
//
//********************************************************************

STDMETHODIMP CDropTarget::Drop (LPDATAOBJECT pDataObj, DWORD grfKeyState,
                                POINTL pointl, LPDWORD pdwEffect)
{
	 FORMATETC fmtetc;
    SCODE sc = S_OK;
	
    TestDebugOut("In IDT::Drop\r\n");

    UndrawDragFeedback();

    if (pDataObj && QueryDrop(grfKeyState,pointl,FALSE,pdwEffect))
    {
        m_pDoc->m_lpSite = CSimpleSite::Create(m_pDoc);
        if (!m_pDoc->m_lpSite)
        {
           /* memory allocation problem. cannot continue.
            */
           return(ResultFromScode(E_OUTOFMEMORY));
        }

        // keep same aspect as drop source
        m_pDoc->m_lpSite->m_dwDrawAspect = m_dwSrcAspect;

        // in order to specify a particular drawing Aspect we must
        // pass a FORMATETC* to OleCreateFromData
 	     fmtetc.cfFormat = NULL; 			// use whatever for drawing
	     fmtetc.ptd = NULL;
	     fmtetc.lindex = -1;
	     fmtetc.dwAspect = m_dwSrcAspect;	// desired drawing aspect
	     fmtetc.tymed = TYMED_NULL;

        HRESULT hrErr = OleCreateFromData (
                            pDataObj,
                            IID_IOleObject,
                            OLERENDER_DRAW,
                            &fmtetc,
                            &m_pDoc->m_lpSite->m_OleClientSite,
                            m_pDoc->m_lpSite->m_lpObjStorage,
                            (LPVOID FAR *)&m_pDoc->m_lpSite->m_lpOleObject);

        if (hrErr == NOERROR)
        {
            m_pDoc->m_lpSite->InitObject(FALSE /* fCreateNew */);
            m_pDoc->DisableInsertObject();
        }
        else
            sc = GetScode(hrErr);
    }

    return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\idt.h ===
//**********************************************************************
// File name: idt.h
//
//      Definition of CDropTarget
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IDT_H_ )
#define _IDT_H_

#include <assert.h>

class CSimpleDoc;

/* Flags to control direction for drag scrolling */
typedef enum tagSCROLLDIR {
    SCROLLDIR_NULL          = 0,
    SCROLLDIR_UP            = 1,
    SCROLLDIR_DOWN          = 2,
    SCROLLDIR_RIGHT         = 3,
    SCROLLDIR_LEFT          = 4
} SCROLLDIR;

interface CDropTarget : public IDropTarget
{
    CSimpleDoc FAR * m_pDoc;
    BOOL  m_fCanDropCopy;
    BOOL  m_fCanDropLink;
    DWORD m_dwSrcAspect;
	 RECT  m_rcDragRect;
    POINT m_ptLast;
    BOOL  m_fDragFeedbackDrawn;
    DWORD m_dwTimeEnterScrollArea;  // time of entering scroll border region
    DWORD m_dwLastScrollDir;        // current dir for drag scroll
    DWORD m_dwNextScrollTime;       // time for next scroll

    CDropTarget(CSimpleDoc FAR * pDoc)
       {
        TestDebugOut("In IDT's constructor\r\n");
        m_pDoc = pDoc;
        m_fCanDropCopy = FALSE;
        m_fCanDropLink = FALSE;
        m_fDragFeedbackDrawn = FALSE;
        m_dwTimeEnterScrollArea = 0L;
        m_dwNextScrollTime = 0L;
        m_dwLastScrollDir = SCROLLDIR_NULL;
       };

    ~CDropTarget()
       {
        TestDebugOut("In IDT's destructor\r\n");
       } ;

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

       // *** IDropTarget methods ***
    STDMETHODIMP DragEnter (LPDATAOBJECT pDataObj, DWORD grfKeyState,
            POINTL pt, LPDWORD pdwEffect);
    STDMETHODIMP DragOver  (DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect);
    STDMETHODIMP DragLeave ();
    STDMETHODIMP Drop (LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt,
            LPDWORD pdwEffect);

private:
    // Drag/Drop support methods
    BOOL QueryDrop (DWORD grfKeyState, POINTL pointl, BOOL fDragScroll,
            LPDWORD lpdwEffect);
    BOOL DoDragScroll( POINTL pointl );
	void InitDragFeedback(LPDATAOBJECT pDataObj, POINTL pointl);
    void DrawDragFeedback( POINTL pointl );
    void UndrawDragFeedback( void );
};

#endif  // _IDT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\iocs.cpp ===
//**********************************************************************
// File name: IOCS.CPP
//
//      Implementation file for COleClientSite
//
// Functions:
//
//      See IOCS.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"


//**********************************************************************
//
// COleClientSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK                -   The interface is supported.
//      E_NOINTERFACE       -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::QueryInterface SITE.CPP
//
//
//********************************************************************

STDMETHODIMP COleClientSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In IOCS::QueryInterface\r\n");

    // delegate to the container Site
    return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleClientSite::AddRef
//
// Purpose:
//
//      Increments the reference count to CSimpleSite. Since COleClientSite
//      is a nested class of CSimpleSite, we don't need an extra reference
//      count for COleClientSite. We can safely use the reference count of
//      CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::AddRef         SITE.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::AddRef()
{
    TestDebugOut("In IOCS::AddRef\r\n");

    // delegate to the container Site
    return m_pSite->AddRef();
}


//**********************************************************************
//
// COleClientSite::Release
//
// Purpose:
//
//      Decrements the reference count to CSimpleSite. Since COleClientSite
//      is a nested class of CSimpleSite, we don't need an extra reference
//      count for COleClientSite. We can safely use the reference count of
//      CSimpleSite.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the CSimpleSite
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleSite::Release        SITE.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleClientSite::Release()
{
    TestDebugOut("In IOCS::Release\r\n");

    // delegate to the container Site
    return m_pSite->Release();
}

//**********************************************************************
//
// COleClientSite::SaveObject
//
// Purpose:
//
//      Called by the object when it wants to be saved to persistant
//      storage
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IOleObject::QueryInterface          Object
//      IPersistStorage::SaveCompleted      Object
//      IPersistStorage::Release            Object
//      ResultFromScode                     OLE API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::SaveObject()
{
    LPPERSISTSTORAGE lpPS;
    SCODE sc = E_FAIL;

    TestDebugOut("In IOCS::SaveObject\r\n");

    // get a pointer to IPersistStorage
    HRESULT hErr = m_pSite->m_lpOleObject->QueryInterface(
                            IID_IPersistStorage,(LPVOID FAR *)&lpPS);

    // save the object
    if (hErr == NOERROR)
    {
        sc = GetScode( OleSave(lpPS, m_pSite->m_lpObjStorage, TRUE) );
        lpPS->SaveCompleted(NULL);
        lpPS->Release();
    }

    return ResultFromScode(sc);
}

//**********************************************************************
//
// COleClientSite::GetMoniker
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      DWORD  dwAssign         - the type of Moniker to be returned
//      DWORD  dwWhichMoniker   - which Moniker to be returned in ppmk
//      LPMONIKER ppmk          - point to where to return the Moniker
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker,
                                        LPMONIKER FAR* ppmk)
{
    TestDebugOut("In IOCS::GetMoniker\r\n");

    // need to null the out pointer
    *ppmk = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::GetContainer
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      LPOLECONTAINER ppContainer   -  point to where the interface to be
//                                      returned
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
    TestDebugOut("In IOCS::GetContainer\r\n");

    // NULL the out pointer
    *ppContainer = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::ShowObject
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      NOERROR
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::ShowObject()
{
    TestDebugOut("In IOCS::ShowObject\r\n");
    return NOERROR;
}

//**********************************************************************
//
// COleClientSite::OnShowWindow
//
// Purpose:
//
//      Object calls this method when it is opening/closing non-InPlace
//      Window
//
// Parameters:
//
//      BOOL fShow  - TRUE if Window is opening, FALSE if closing
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      InvalidateRect              Windows API
//      BringWindowToTop            Windows API
//      SetFocus                    Windows API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::OnShowWindow(BOOL fShow)
{
    TestDebugOut("In IOCS::OnShowWindow\r\n");
    m_pSite->m_fObjectOpen = fShow;
    InvalidateRect(m_pSite->m_lpDoc->m_hDocWnd, NULL, TRUE);

    // if object window is closing, then bring container window to top
    if (! fShow)
    {
        BringWindowToTop(m_pSite->m_lpDoc->m_hDocWnd);
        SetFocus(m_pSite->m_lpDoc->m_hDocWnd);
    }
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleClientSite::RequestNewObjectLayout
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleClientSite::RequestNewObjectLayout()
{
    TestDebugOut("In IOCS::RequestNewObjectLayout\r\n");
    return ResultFromScode(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\iocs.h ===
//**********************************************************************
// File name: IOCS.H
//
//      Definition of COleClientSite
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOCS_H_ )
#define _IOCS_H_

#include <assert.h>

class CSimpleSite;

interface COleClientSite : public IOleClientSite
{
    CSimpleSite FAR * m_pSite;

    COleClientSite(CSimpleSite FAR * pSite)
       {
        TestDebugOut("In IOCS's constructor\r\n");
        m_pSite = pSite;
       }

    ~COleClientSite()
       {
        TestDebugOut("In IOCS's destructor\r\n");
       }

    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IOleClientSite methods ***
    STDMETHODIMP SaveObject();
    STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker,
                            LPMONIKER FAR* ppmk);
    STDMETHODIMP GetContainer(LPOLECONTAINER FAR* ppContainer);
    STDMETHODIMP ShowObject();
    STDMETHODIMP OnShowWindow(BOOL fShow);
    STDMETHODIMP RequestNewObjectLayout();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>
#include <ole2.h>
#include <ole2ui.h>
#include <assert.h>
#include <string.h>
#include "simpdnd.h"
#include "resource.h"


extern "C" void TestDebugOut(LPSTR psz);

#ifndef WIN32
/* Since OLE is part of the operating system in Win32, we don't need to
 * check the version number in Win32.
 */
#include <ole2ver.h>
#endif  // WIN32

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\simpdnd.cpp ===
//**********************************************************************
// File name: Simple.cpp
//
//      Main source file for the Simple OLE 2.0 object container
//
// Functions:
//
//      WinMain         - Program entry point
//      MainWndProc     - Processes messages for the frame window
//      About           - Processes messages for the about dialog
//      DocWndProc      - Processes messages for the doc window
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include <stdlib.h>
#include <testmess.h>
#include "tests.h"


// This line is needed for the debug utilities in OLE2UI
extern "C" {
    OLEDBGDATA_MAIN(TEXT("SIMPDND"))
}

CSimpleApp FAR * lpCSimpleApp;
BOOL fBeVerbose = FALSE;
extern "C"
void TestDebugOut(LPSTR psz)
{
    if (fBeVerbose)
    {
	OutputDebugStringA(psz);
    }
}

BOOL gfUseEmptyEnumerator;


//**********************************************************************
//
// WinMain
//
// Purpose:
//
//      Program entry point
//
// Parameters:
//
//      HANDLE hInstance        - Instance handle for this instance
//
//      HANDLE hPrevInstance    - Instance handle for the last instance
//
//      LPSTR lpCmdLine         - Pointer to the command line
//
//      int nCmdShow            - Window State
//
// Return Value:
//
//      msg.wParam or FALSE if failure to initialize
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::CSimpleApp          APP.CPP
//      CSimpleApp::fInitApplication    APP.CPP
//      CSimpleApp::fInitInstance       APP.CPP
//      CSimpleApp::~CSimpleApp         APP.CPP
//      CSimpleApp::AddRef              APP.CPP
//      CSimpleApp::Release             APP.CPP
//      OleUIInitialize                 OLE2UI
//      OleUIUninitialize               OLE2UI
//      GetMessage                      Windows API
//      SetMessageQueue                 Windows API
//      MessageBox                      Windows API
//      TranslateMessage                Windows API
//      DispatchMessage                 Windows API
//
//
//********************************************************************

int PASCAL WinMain
#ifdef WIN32
   (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,
    int nCmdShow)
#else
   (HANDLE  hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
#endif
{
    MSG msg;
    LPSTR	pszTemp;
    fBeVerbose = GetProfileInt("OLEUTEST","BeVerbose",0);

    if(fBeVerbose == 0)
    {
	fBeVerbose = GetProfileInt("OLEUTEST","simpdnd",0);
    }

    // needed for LRPC to work properly...
    SetMessageQueue(96);

    lpCSimpleApp = new CSimpleApp;


    if (!lpCSimpleApp)
    {
       /* memory allocation problem. We cannot carry on.
        */
       MessageBox(NULL, TEXT("Out of Memory"), TEXT("SimpDnD"),
                  MB_SYSTEMMODAL | MB_ICONHAND);
       return(FALSE);
    }

    // we will add one ref count on our App. later when we want to destroy
    // the App object we will release this  ref count. when the App's ref
    // count goes to 0, it will be deleted.
    lpCSimpleApp->AddRef();

    // process the command line

    if( (pszTemp = strstr(lpCmdLine, "-driver")) )
    {
    	//we were launched by the test driver
	lpCSimpleApp->m_hDriverWnd = (HWND)strtoul(pszTemp+8, NULL, 10);
    }

    // check for the -empty flag (use empty enumerator)
    if( strstr(lpCmdLine, "-empty") )
    {
	gfUseEmptyEnumerator = TRUE;
    }

    // app initialization
    if (!hPrevInstance)
        if (!lpCSimpleApp->fInitApplication(hInstance))
        {
            lpCSimpleApp->Release();
            return (FALSE);
        }

    // instance initialization
    if (!lpCSimpleApp->fInitInstance(hInstance, nCmdShow))
    {
        lpCSimpleApp->Release();
        return (FALSE);
    }

#if 0
    /* Initialization required for OLE 2 UI library.  This call is
    **    needed ONLY if we are using the static link version of the UI
    **    library. If we are using the DLL version, we should NOT call
    **    this function in our application.
    */

    if (!OleUIInitialize(hInstance, hPrevInstance, TEXT(SZCLASSICONBOX),
                         TEXT(SZCLASSRESULTIMAGE)))
    {
        OleDbgOut(TEXT("Could not initialize OLEUI library\n"));
        lpCSimpleApp->Release();
        return FALSE;
    }
#endif
    // message loop
    while (GetMessage(&msg, NULL, NULL, NULL))
        if (!lpCSimpleApp->HandleAccelerators(&msg))
        {
            TranslateMessage(&msg);    /* Translates virtual key codes */
            DispatchMessage(&msg);     /* Dispatches message to window */
        }

#if 0
    // De-initialization for UI libraries.  Just like OleUIInitialize, this
    // funciton is needed ONLY if we are using the static link version of the
    // OLE UI library.
    OleUIUninitialize();
#endif

    // Release the ref count added on the App above. this will make
    // the App's ref count go to 0, and the App object will be deleted.
    lpCSimpleApp->Release();

    return (msg.wParam);         /* Returns the value from PostQuitMessage */
}


//**********************************************************************
//
// MainWndProc
//
// Purpose:
//
//      Processes messages for the frame window
//
// Parameters:
//
//      HWND hWnd       - Window handle for frame window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
//      LRESULT
//
// Function Calls:
//      Function                        Location
//
//      CSimpleApp::lCommandHandler     APP.CPP
//      CSimpleApp::DestroyDocs         APP.CPP
//      CSimpleApp::lCreateDoc          APP.CPP
//      CSimpleApp::lSizeHandler        APP.CPP
//      CSimpleDoc::lAddVerbs           DOC.CPP
//      PostQuitMessage                 Windows API
//      DefWindowProc                   Windows API
//      DestroyWindow                   Windows API
//
//
//********************************************************************

LRESULT FAR PASCAL EXPORT MainWndProc(HWND hWnd, UINT message,
                                   WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
    	case WM_TEST2:
	    StartTest2(lpCSimpleApp);
	    break;
    	case WM_TEST1:
	    StartTest1(lpCSimpleApp);
	    break;
        case WM_CLOSE:
            DestroyWindow(lpCSimpleApp->m_hAppWnd);
            break;

        case WM_COMMAND:           // message: command from application menu
            return lpCSimpleApp->lCommandHandler(hWnd, message, wParam,
                                                 lParam);
            break;

        case WM_CREATE:
#ifdef NOTREADY
            RemoveMenu(GetSubMenu(GetMenu(hWnd), 1), 0, MF_BYPOSITION);
#endif // NOTREADY
            return lpCSimpleApp->lCreateDoc(hWnd, message, wParam, lParam);
            break;

        case WM_DESTROY:                  // message: window being destroyed
            lpCSimpleApp->DestroyDocs();  // need to destroy the doc...
            PostQuitMessage(0);
            break;

        case WM_INITMENUPOPUP:
            // is this the edit menu?
            if ( LOWORD(lParam) == 1)
                return lpCSimpleApp->m_lpDoc->lAddVerbs();
            break;

        case WM_SIZE:
            return lpCSimpleApp->lSizeHandler(hWnd, message, wParam, lParam);

        default:                          // Passes it on if unproccessed
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (NULL);
}


//**********************************************************************
//
// About
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for dialog box
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
// Function Calls:
//      Function                    Location
//
//      EndDialog                   Windows API
//
//
//********************************************************************
INT_PTR
#ifdef WIN32
	CALLBACK
#else
   FAR PASCAL EXPORT
#endif
   About(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)

{
    switch (message)
    {
    case WM_INITDIALOG:              /* message: initialize dialog box */
       return (TRUE);

    case WM_COMMAND:                 /* message: received a command    */
        if (wParam == IDOK           /* "OK" box selected?             */
            || wParam == IDCANCEL)   /* System menu close command?     */
        {
           EndDialog(hDlg, TRUE);    /* Exits the dialog box           */
           return (TRUE);
        }
        break;
    }

    return (FALSE);                  /* Didn't process a message       */
}

//**********************************************************************
//
// DocWndProc
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for doc window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
//      long
//
// Function Calls:
//      Function                            Location
//
//      CSimpleApp::PaintApp                APP.CPP
//      BeginPaint                          Windows API
//      EndPaint                            Windows API
//      DefWindowProc                       Windows API
//      IOleObject::DoVerb                  Object
//      CSimpleSite::GetObjRect             SITE.CPP
//      CSimpleDoc::QueryDrag               DOC.CPP
//      CSimpleDoc::DoDragDrop              DOC.CPP
//      SetTimer                            Windows API
//      KillTimer                           Windows API
//      SetCapture                          Windows API
//      ReleaseCapture                      Windows API
//
//
//********************************************************************

LRESULT FAR PASCAL EXPORT DocWndProc(HWND hWnd, UINT message, WPARAM wParam,
                                  LPARAM lParam)
{
    HDC hDC;
    PAINTSTRUCT ps;

    switch (message)
    {
        case WM_PAINT:

            hDC = BeginPaint(hWnd, &ps);

            if (lpCSimpleApp)
                lpCSimpleApp->PaintApp (hDC);

            EndPaint(hWnd, &ps);
            break;

        case WM_LBUTTONDBLCLK:
        {
            POINT pt;

            pt.x = (int)(short)LOWORD (lParam );
            pt.y = (int)(short)HIWORD (lParam );

            if (lpCSimpleApp->m_lpDoc->m_lpSite &&
                lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject)
            {
                RECT rect;

                lpCSimpleApp->m_lpDoc->m_lpSite->GetObjRect(&rect);

                if ( PtInRect(&rect, pt) )
                {
                    // Execute object's default verb
                    lpCSimpleApp->m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(
                            OLEIVERB_PRIMARY, (LPMSG)&message,
                            &lpCSimpleApp->m_lpDoc->m_lpSite->m_OleClientSite,
                            -1, hWnd, &rect);
                }
            }
            break;
        }

        case WM_LBUTTONDOWN:
        {
            POINT pt;

            pt.x = (int)(short)LOWORD (lParam );
            pt.y = (int)(short)HIWORD (lParam );

            /* OLE2NOTE: check if this is a button down on the region
            **    that is a handle to start a drag operation. for us,
            **    this this is any where in the window. we
            **    do NOT want to start a drag immediately; we want to
            **    wait until the mouse moves a certain threshold. or a
            **    certain amount of time has elapsed. if
            **    LButtonUp comes before the drag is started, then
            **    the fPendingDrag state is cleared. we must capture
            **    the mouse to ensure the modal state is handled
            **    properly.
            */
            if (lpCSimpleApp->m_lpDoc->QueryDrag(pt) )
            {
                lpCSimpleApp->m_lpDoc->m_fPendingDrag = TRUE;
                lpCSimpleApp->m_lpDoc->m_ptButDown = pt;
                SetTimer(hWnd, 1, lpCSimpleApp->m_nDragDelay, NULL);
                SetCapture(hWnd);
            }
            break;
        }

        case WM_LBUTTONUP:

            if (lpCSimpleApp->m_lpDoc->m_fPendingDrag)
            {
                /* ButtonUP came BEFORE distance/time threshholds were
                **    exceeded. clear fPendingDrag state.
                */
                ReleaseCapture();
                KillTimer(hWnd, 1);
                lpCSimpleApp->m_lpDoc->m_fPendingDrag = FALSE;
            }
            break;

        case WM_MOUSEMOVE:
        {
           if (lpCSimpleApp->m_lpDoc->m_fPendingDrag)
           {
            	int  x = (int)(short)LOWORD (lParam );
            	int  y = (int)(short)HIWORD (lParam );
            	POINT pt = lpCSimpleApp->m_lpDoc->m_ptButDown;
            	int nDragMinDist = lpCSimpleApp->m_nDragMinDist;
            	
               if (! ( ((pt.x - nDragMinDist) <= x)
                        && (x <= (pt.x + nDragMinDist))
                        && ((pt.y - nDragMinDist) <= y)
                        && (y <= (pt.y + nDragMinDist)) ) )
               {
                    // mouse moved beyond threshhold to start drag
                    ReleaseCapture();
                    KillTimer(hWnd, 1);
                    lpCSimpleApp->m_lpDoc->m_fPendingDrag = FALSE;

                    // perform the modal drag/drop operation.
                    lpCSimpleApp->m_lpDoc->DoDragDrop( );
               }
           }
        	  break;
        }

        case WM_TIMER:
        {
            // drag time delay threshhold exceeded -- start drag
            ReleaseCapture();
            KillTimer(hWnd, 1);
            lpCSimpleApp->m_lpDoc->m_fPendingDrag = FALSE;

            // perform the modal drag/drop operation.
            lpCSimpleApp->m_lpDoc->DoDragDrop( );
        	   break;
        }
	
    	  default:                       /* Passes it on if unproccessed */
        	   return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\simpdnd.h ===
//**********************************************************************
// File name: simpdnd.h
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#define IDM_ABOUT 100
#define IDM_INSERT  101
#define IDM_VERB0 1000

int PASCAL WinMain
#ifdef WIN32
   (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);
#else
   (HANDLE  hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);
#endif


BOOL InitApplication(HANDLE hInstance);
BOOL InitInstance(HANDLE hInstance, int nCmdShow);

LRESULT FAR PASCAL EXPORT MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT FAR PASCAL EXPORT DocWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef WIN32
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
#else
BOOL FAR PASCAL EXPORT About(HWND hDlg, UINT message, WPARAM wParam, LONG lParam);
#endif

#ifndef LATER
#define SZCLASSICONBOX "SimpDndIBClass"
#define SZCLASSRESULTIMAGE "SimpDndRIClass"
#endif


#ifdef WIN32

// Macro for TestDebugOut
#ifdef UNICODE
#undef TestDebugOut
#define TestDebugOut(A); TestDebugOutW(TEXT(A));
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by SIMPDND.RC
//
#define IDM_OPEN                        102
#define IDC_DRAGPENDING                 102
#define IDM_SAVE                        103
#define IDM_SAVEAS                      104
#define IDM_PRINT                       105
#define IDM_EXIT                        106
#define IDM_UNDO                        107
#define IDM_CUT                         108
#define IDM_COPY                        109
#define IDM_PASTE                       110
#define ID_EDIT_INSERTOBJECT            111
#define IDM_INSERTOBJECT                111
#define IDM_NEW                         112
#define IDM_SOURCE_COPY                 113
#define IDM_SOURCE_MOVE                 114
#define IDM_SOURCE_COPYMOVE             115
#define IDM_TARGET_COPY                 116
#define IDM_TARGET_MOVE                 117
#define IDM_TARGET_COPYMOVE             118

// Menu positions of source/target effects menus
#define SOURCE_EFFECTS_MENU_POS         0
#define TARGET_EFFECTS_MENU_POS         1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         113
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\site.h ===
//**********************************************************************
// File name: SITE.H
//
//      Definition of CSimpleSite
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _SITE_H_ )
#define _SITE_H_

#include <ole2.h> 
#include "ias.h"
#include "iocs.h"

class CSimpleDoc;

class CSimpleSite : public IUnknown
{
public:
    int m_nCount;
    LPOLEOBJECT m_lpOleObject;
    DWORD m_dwDrawAspect;
    SIZEL m_sizel;
    BOOL m_fObjectOpen;
    LPSTORAGE m_lpObjStorage;

    CAdviseSink m_AdviseSink;
    COleClientSite m_OleClientSite;
    
    CSimpleDoc FAR * m_lpDoc;
    
    // IUnknown Interfaces    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj); 
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release(); 
    
    HRESULT InitObject(BOOL fCreateNew);
    static CSimpleSite FAR * Create(CSimpleDoc FAR *lpDoc);
    CSimpleSite(CSimpleDoc FAR *lpDoc);
    ~CSimpleSite();          
    void PaintObj(HDC hDC);
    void GetObjRect(LPRECT lpRect);
    void CloseOleObject(void); 
    void UnloadOleObject(void);
};

#endif  // _SITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\tests.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	tests.h
//
//  Contents: 	Declarations for the unit test functions
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//  		07-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef __TESTS_H
#define __TESTS_H

void StartTest1(CSimpleApp *);
void StartTest2(CSimpleApp *);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\tests.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:   	tests.cpp
//
//  Contents:	Implementations of the Upper Layer unit tests
//
//  Classes:
//
//  Functions: 	StartTest1
//
//  History:    dd-mmm-yy Author    Comment
//		07-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"
#include <testmess.h>

const CLSID CLSID_SimpleServer = {0xbcf6d4a0, 0xbe8c, 0x1068, { 0xb6, 0xd4,
	0x00, 0xdd, 0x01, 0x0c, 0x05, 0x09 }};

const CLSID CLSID_Paintbrush = {0x0003000a, 0, 0, { 0xc0, 0,0,0,0,0,0,0x46 }};

//+-------------------------------------------------------------------------
//
//  Function:	StartTest1
//
//  Synopsis:	Starts unit test1, inserting a simple server object into
//		this (simpdnd) container.
//
//  Effects:
//
//  Arguments:	pApp	-- a pointer to the CSimpleApp that we're a part of
//
//  Requires:
//
//  Returns:
//
//  Signals:    			
//
//  Modifies:
//			
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//     		07-Feb-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void StartTest1( CSimpleApp *pApp )
{
	HRESULT hresult;
	static FORMATETC formatetc;

	//insert the simple server object

	formatetc.dwAspect = DVASPECT_CONTENT;
	formatetc.cfFormat = NULL;
	formatetc.lindex = -1;

	//need to create the client site

	pApp->m_lpDoc->m_lpSite = CSimpleSite::Create(pApp->m_lpDoc);

	hresult = OleCreate(CLSID_SimpleServer, IID_IOleObject,
		OLERENDER_DRAW, &formatetc,
		&pApp->m_lpDoc->m_lpSite->m_OleClientSite,
		pApp->m_lpDoc->m_lpSite->m_lpObjStorage,
		(void **)&(pApp->m_lpDoc->m_lpSite->m_lpOleObject));

	if( hresult != NOERROR )
	{
		goto errRtn;
	}

	//initialize the object
							
	hresult = pApp->m_lpDoc->m_lpSite->InitObject(TRUE);

	if( hresult == NOERROR )
	{
		//tell it to paint itself, then we'll quit
		PostMessage(pApp->m_lpDoc->m_hDocWnd, WM_PAINT, 0L, 0L);
		PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_SUCCESS,
		(LPARAM)hresult);
		PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
		return;
	}

errRtn:
	PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_FAILURE,
		(LPARAM)hresult);
	PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
	return;
}


//+-------------------------------------------------------------------------
//
//  Function:	StartTest2
//
//  Synopsis:	Starts unit Test2, inserting a paintbrush object into
//		this (simpdnd) container.
//
//  Effects:
//
//  Arguments:	pApp	-- a pointer to the CSimpleApp that we're a part of
//
//  Requires:
//
//  Returns:
//
//  Signals:    			
//
//  Modifies:
//			
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//     		24-May-94 kevinro & alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void StartTest2( CSimpleApp *pApp )
{
	HRESULT hresult;
	static FORMATETC formatetc;

	//insert the simple server object

	formatetc.dwAspect = DVASPECT_CONTENT;
	formatetc.cfFormat = NULL;
	formatetc.lindex = -1;

	//need to create the client site

	pApp->m_lpDoc->m_lpSite = CSimpleSite::Create(pApp->m_lpDoc);

	hresult = OleCreate(CLSID_Paintbrush, IID_IOleObject,
		OLERENDER_DRAW, &formatetc,
		&pApp->m_lpDoc->m_lpSite->m_OleClientSite,
		pApp->m_lpDoc->m_lpSite->m_lpObjStorage,
		(void **)&(pApp->m_lpDoc->m_lpSite->m_lpOleObject));

	if( hresult != NOERROR )
	{
		goto errRtn;
	}

	//initialize the object
							
	hresult = pApp->m_lpDoc->m_lpSite->InitObject(TRUE);

	//
	// The DDE layer is going to ignore all of the parameters except
	// the verb index. The parameters here are mostly dummies.
	//
	if (hresult == NOERROR)
	{
		hresult = pApp->m_lpDoc->m_lpSite->m_lpOleObject->DoVerb(0,
				NULL,
				&(pApp->m_lpDoc->m_lpSite->m_OleClientSite),
				-1,
				NULL,
				NULL);
	}

	if( hresult == NOERROR )
	{
		//tell it to paint itself, then we'll quit
		PostMessage(pApp->m_lpDoc->m_hDocWnd, WM_PAINT, 0L, 0L);
		PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_SUCCESS,
		(LPARAM)hresult);
		PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
		return;
	}

errRtn:
	PostMessage(pApp->m_hDriverWnd, WM_TESTEND, TEST_FAILURE,
		(LPARAM)hresult);
	PostMessage(pApp->m_hAppWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpdnd\site.cpp ===
//**********************************************************************
// File name: SITE.CPP
//
//      Implementation file for CSimpleSite
//
// Functions:
//
//      See SITE.H for class definition
//
// Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "iocs.h"
#include "ias.h"
#include "app.h"
#include "site.h"
#include "doc.h"

//**********************************************************************
//
// CSimpleSite::Create
//
// Purpose:
//
//      Creation routine for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpleSite::CSimpleSite    SITE.CPP
//      CSimpleSite::~CSimpleSite   SITE.CPP
//      CSimpleSite::AddRef         SITE.CPP
//      IStorage::CreateStorage     OLE API
//      assert                      C Runtime
//
//
//********************************************************************

CSimpleSite FAR * CSimpleSite::Create(CSimpleDoc FAR *lpDoc)
{
    CSimpleSite FAR * lpTemp = new CSimpleSite(lpDoc);

    if (!lpTemp)
        return NULL;

    // create a sub-storage for the object
    HRESULT hErr = lpDoc->m_lpStorage->CreateStorage( OLESTR("Object"),
                STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &lpTemp->m_lpObjStorage);

    assert(hErr == NOERROR);

    if (hErr != NOERROR)
    {
        delete lpTemp;
        return NULL;
    }

    // we will add one ref count on our Site. later when we want to destroy
    // the Site object we will release this  ref count. when the Site's ref
    // count goes to 0, it will be deleted.
    lpTemp->AddRef();

    return lpTemp;
}

//**********************************************************************
//
// CSimpleSite::CSimpleSite
//
// Purpose:
//
//      Constructor for CSimpleSite
//
// Parameters:
//
//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
                                 // tells us that we are passing this in
                                 // an initializer, before "this" is through
                                 // initializing.  This is ok, because
                                 // we just store the ptr in the other
                                 // constructors

CSimpleSite::CSimpleSite (CSimpleDoc FAR *lpDoc) : m_OleClientSite(this),
                                                   m_AdviseSink(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
    // remember the pointer to the doc
    m_lpDoc = lpDoc;
    m_sizel.cx = 0;
    m_sizel.cy = 0;

    // clear the reference count
    m_nCount = 0;

	 m_dwDrawAspect = DVASPECT_CONTENT;
    m_lpOleObject  = NULL;
    m_fObjectOpen  = FALSE;
}

//**********************************************************************
//
// CSimpleSite::~CSimpleSite
//
// Purpose:
//
//      Destructor for CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::Release                     Object
//      IStorage::Release                       OLE API
//
//
//********************************************************************

CSimpleSite::~CSimpleSite ()
{
    TestDebugOut ("In CSimpleSite's Destructor \r\n");

    if (m_lpOleObject)
       m_lpOleObject->Release();

    if (m_lpObjStorage)
       m_lpObjStorage->Release();
}


//**********************************************************************
//
// CSimpleSite::CloseOleObject
//
// Purpose:
//
//      Call IOleObject::Close on the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleObject::Close                       Object
//
//
//********************************************************************

void CSimpleSite::CloseOleObject (void)
{
    LPVIEWOBJECT lpViewObject = NULL;

    TestDebugOut ("In CSimpleSite::CloseOleObject \r\n");

    if (m_lpOleObject)
    {
       m_lpOleObject->Close(OLECLOSE_NOSAVE);
    }
}


//**********************************************************************
//
// CSimpleSite::UnloadOleObject
//
// Purpose:
//
//      Close and release all pointers to the object of the CSimpleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      CSimpleSite::CloseOleObject             SITE.CPP
//      IOleObject::QueryInterface              Object
//      IViewObject::SetAdvise                  Object
//      IViewObject::Release                    Object
//      IOleObject::Release                     Object
//
//
//********************************************************************

void CSimpleSite::UnloadOleObject (void)
{
    TestDebugOut ("In CSimpleSite::UnloadOleObject \r\n");

    if (m_lpOleObject)
    {
       LPVIEWOBJECT lpViewObject;
       CloseOleObject();    // ensure object is closed; NOP if already closed

       m_lpOleObject->QueryInterface(IID_IViewObject,
                                     (LPVOID FAR *)&lpViewObject);

       if (lpViewObject)
       {
           // Remove the view advise
           lpViewObject->SetAdvise(m_dwDrawAspect, 0, NULL);
           lpViewObject->Release();
       }

       m_lpOleObject->Release();
       m_lpOleObject = NULL;
   }
}


//**********************************************************************
//
// CSimpleSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation of the container Site.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      CSimpleSite::AddRef         OBJ.CPP
//      COleClientSite::AddRef      IOCS.CPP
//      CAdviseSink::AddRef         IAS.CPP
//
//
//********************************************************************

STDMETHODIMP CSimpleSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut("In CSimpleSite::QueryInterface\r\n");

    *ppvObj = NULL;     // must set out pointer parameters to NULL

    if ( IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return ResultFromScode(S_OK);
    }

    if ( IsEqualIID(riid, IID_IOleClientSite))
    {
        m_OleClientSite.AddRef();
        *ppvObj = &m_OleClientSite;
        return ResultFromScode(S_OK);
    }

    if ( IsEqualIID(riid, IID_IAdviseSink))
    {
        m_AdviseSink.AddRef();
        *ppvObj = &m_AdviseSink;
        return ResultFromScode(S_OK);
    }

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// CSimpleSite::AddRef
//
// Purpose:
//
//      Increments the reference count of the container Site.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the site.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::AddRef()
{
    TestDebugOut("In CSimpleSite::AddRef\r\n");

    return ++m_nCount;
}

//**********************************************************************
//
// CSimpleSite::Release
//
// Purpose:
//
//      Decrements the reference count of the container Site
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the Site.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpleSite::Release()
{
    TestDebugOut("In CSimpleSite::Release\r\n");

    if (--m_nCount == 0)
    {
        delete this;
        return 0;
    }
    return m_nCount;
}

//**********************************************************************
//
// CSimpleSite::InitObject
//
// Purpose:
//
//      Used to initialize a newly create object (can't be done in the
//      constructor).
//
// Parameters:
//
//      BOOL fCreateNew -   TRUE if insert NEW object
//                          FALSE if create object FROM FILE
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::SetHostNames        Object
//      IOleObject::QueryInterface      Object
//      IViewObject2::GetExtent         Object
//      IOleObject::DoVerb              Object
//      IViewObject2::SetAdvise         Object
//      IViewObject2::Release           Object
//      GetClientRect                   Windows API
//      OleSetContainedObject           OLE API
//
//
//********************************************************************

HRESULT CSimpleSite::InitObject(BOOL fCreateNew)
{
    LPVIEWOBJECT2 lpViewObject2;
    RECT rect;
    HRESULT hRes;

    // Set a View Advise
    hRes = m_lpOleObject->QueryInterface(IID_IViewObject2,
                                  (LPVOID FAR *)&lpViewObject2);
    if (hRes == ResultFromScode(S_OK))
    {
       hRes = lpViewObject2->SetAdvise(m_dwDrawAspect, ADVF_PRIMEFIRST,
                                &m_AdviseSink);

       if( FAILED(hRes))
       {
      		goto errRtn;
       }
       // get the initial size of the object

       hRes = lpViewObject2->GetExtent(m_dwDrawAspect, -1 /*lindex*/, NULL /*ptd*/,
                                &m_sizel);

       //
       // Is OK if the object is actually blank
       //
       if( FAILED(hRes) && (hRes != OLE_E_BLANK) )
       {
       		goto errRtn;
       }

       lpViewObject2->Release();
    }
    GetObjRect(&rect);  // get the rectangle of the object in pixels

    // give the object the name of the container app/document
    hRes  = m_lpOleObject->SetHostNames(OLESTR("Simple Application"),
                                OLESTR("Simple OLE 2.0 Drag/Drop Container"));

    if( FAILED(hRes) )
    {
       goto errRtn;
    }

    // inform object handler/DLL object that it is used in the embedding
    // container's context
    if (OleSetContainedObject(m_lpOleObject, TRUE) != ResultFromScode(S_OK))
    {
       TestDebugOut("Fail in OleSetContainedObject\n");
    }

    if (fCreateNew)
    {
       // force new object to save to guarantee valid object in our storage.
       // OLE 1.0 objects may close w/o saving. this is NOT necessary if the
       // object is created FROM FILE; its data in storage is already valid.
       m_OleClientSite.SaveObject();

       // we only want to DoVerb(SHOW) if this is an InsertNew object.
       // we should NOT DoVerb(SHOW) if the object is created FromFile.
       hRes = m_lpOleObject->DoVerb(
               OLEIVERB_SHOW,
               NULL,
               &m_OleClientSite,
               -1,
               m_lpDoc->m_hDocWnd,
               &rect);
    }

errRtn:
    return hRes;

}

//**********************************************************************
//
// CSimpleSite::PaintObj
//
// Purpose:
//
//      Paints the object
//
// Parameters:
//
//      HDC hDC     - Device context of the document window
//
// Return Value:
//      None
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::QueryInterface      Object
//      IViewObject::GetColorSet        Object
//      IViewObject::Release            Object
//      CreateHatchBrush                Windows API
//      SelectObject                    Windows API
//      SetROP2                         Windows API
//      Rectangle                       Windows API
//      DeleteObject                    Windows API
//      CreatePalette                   Windows API
//      SelectPalette                   Windows API
//      RealizePalette                  Windows API
//      OleStdFree                      OUTLUI Function
//      OleDraw                         OLE API
//      CSimpleSite::GetObjRect         SITE.CPP
//
//
//********************************************************************

void CSimpleSite::PaintObj(HDC hDC)
{
    RECT rect;

    // need to check to make sure there is a valid object
    // available.  This is needed if there is a paint msg
    // between the time that CSimpleSite is instantiated
    // and OleUIInsertObject returns.
    if (!m_lpOleObject)
        return;

    // convert it to pixels
    GetObjRect(&rect);

    LPLOGPALETTE pColorSet = NULL;
    LPVIEWOBJECT lpView = NULL;

    // get a pointer to IViewObject
    m_lpOleObject->QueryInterface(IID_IViewObject,(LPVOID FAR *) &lpView);

    // if the QI succeeds, get the LOGPALETTE for the object
    if (lpView)
        lpView->GetColorSet(m_dwDrawAspect, -1, NULL, NULL, NULL, &pColorSet);

    HPALETTE hPal=NULL;
    HPALETTE hOldPal=NULL;

    // if a LOGPALETTE was returned (not guarateed), create the palette and
    // realize it.  NOTE: A smarter application would want to get the LOGPALETTE
    // for each of its visible objects, and try to create a palette that
    // satisfies all of the visible objects.  ALSO: OleStdFree() is use to
    // free the returned LOGPALETTE.
    if ((pColorSet))
    {
        hPal = CreatePalette((const LPLOGPALETTE) pColorSet);
        hOldPal = SelectPalette(hDC, hPal, FALSE);
        RealizePalette(hDC);
        OleStdFree(pColorSet);
    }

    // draw the object
    HRESULT hRes;
    hRes = OleDraw(m_lpOleObject, m_dwDrawAspect, hDC, &rect);
    if ((hRes != ResultFromScode(S_OK)) &&
        (hRes != ResultFromScode(OLE_E_BLANK)) &&
        (hRes != ResultFromScode(DV_E_NOIVIEWOBJECT)))
    {
        TestDebugOut("Fail in OleDraw\n");
    }

    // if the object is open, draw a hatch rect.
    if (m_fObjectOpen)
    {
        HBRUSH hBrush = CreateHatchBrush ( HS_BDIAGONAL, RGB(0,0,0) );
        HBRUSH hOldBrush = (HBRUSH) SelectObject (hDC, hBrush);
        SetROP2(hDC, R2_MASKPEN);
        Rectangle (hDC, rect.left, rect.top, rect.right, rect.bottom);
        SelectObject(hDC, hOldBrush);
        DeleteObject(hBrush);
    }

    // if we created a palette, restore the old one, and destroy
    // the object.
    if (hPal)
    {
        SelectPalette(hDC,hOldPal,FALSE);
        DeleteObject(hPal);
    }

    // if a view pointer was successfully returned, it needs to be released.
    if (lpView)
        lpView->Release();
}

//**********************************************************************
//
// CSimpleSite::GetObjRect
//
// Purpose:
//
//      Retrieves the rect of the object in pixels
//
// Parameters:
//
//      LPRECT lpRect - Rect structure filled with object's rect in pixels
//
// Return Value:
//      None
//
// Function Calls:
//      Function                        Location
//
//      XformWidthInHimetricToPixels    OLE2UI Function
//      XformHeightInHimetricToPixels   OLE2UI Function
//
//
//********************************************************************

void CSimpleSite::GetObjRect(LPRECT lpRect)
{
    // convert it to pixels
    lpRect->left   = lpRect->top = 0;
    lpRect->right  = XformWidthInHimetricToPixels(NULL,(int)m_sizel.cx);
    lpRect->bottom = XformHeightInHimetricToPixels(NULL,(int)m_sizel.cy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\app.h ===
//**********************************************************************
// File name: app.h
//
//      Definition of CSimpSvrApp
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _APP_H_)
#define _APP_H_

class CSimpSvrDoc;
interface CClassFactory;

class CSimpSvrApp : public IUnknown
{
private:

    int m_nCount;               // reference count

    HINSTANCE m_hInst;          // application instance
    BOOL m_fStartByOle;         // TRUE if app started by OLE
    DWORD m_dwRegisterClass;    // returned by RegisterClassFactory

    LPOLEOBJECT m_OleObject;    // pointer to "dummy" object


    CSimpSvrDoc FAR * m_lpDoc;   // pointer to document object
    BOOL m_fInitialized;         // OLE initialization flag

    RECT nullRect;               // used in inplace negotiation

    // Convert to/from owner draw menus
    void HandleChangeColors(void);


public:

    HWND m_hAppWnd;             // main window handle

    HACCEL m_hAccel;            // Accelerators


    // IUnknown Interfaces
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // Initialization methods

    CSimpSvrApp();           // Constructor
    ~CSimpSvrApp();          // Destructor


    BOOL fInitApplication (HANDLE hInstance);
    BOOL fInitInstance (HANDLE hInstance, int nCmdShow, CClassFactory FAR * lpClassFactory);

    // Message handling methods

    LRESULT lCommandHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    long lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    long lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    void PaintApp(HDC hDC);
    void HandleDrawItem(LPDRAWITEMSTRUCT lpdis);

    //  Utility functions
    void ParseCmdLine(LPSTR lpCmdLine);
    void SetStatusText();
    BOOL IsInPlaceActive();
    void ShowAppWnd(int nCmdShow=SW_SHOWNORMAL);
    void HideAppWnd();


    // member variable access
    inline HWND GethAppWnd() { return m_hAppWnd; };
    inline HINSTANCE GethInst() { return m_hInst; };
    inline BOOL IsStartedByOle() { return m_fStartByOle; };
    inline BOOL IsInitialized() { return m_fInitialized; };
    inline DWORD GetRegisterClass() { return m_dwRegisterClass; };
    inline CSimpSvrDoc FAR * GetDoc() { return m_lpDoc; };
    inline void ClearDoc() { m_lpDoc = NULL; };
    inline LPOLEOBJECT GetOleObject() { return m_OleObject; };

    friend interface CClassFactory;  // make the contained class a friend
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\doc.h ===
//**********************************************************************
// File name: doc.h
//
//      Definition of CSimpSvrDoc
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _DOC_H_ )
#define _DOC_H_

class CSimpSvrApp;
class CSimpSvrObj;

class CSimpSvrDoc : IUnknown
{
private:
    int m_nCount;

    CSimpSvrApp FAR * m_lpApp;
    CSimpSvrObj FAR * m_lpObj;
    HMENU m_hMainMenu;
    HMENU m_hColorMenu;
    HMENU m_hHelpMenu;

    HWND m_hDocWnd;
    HWND m_hHatchWnd;

public:
    static CSimpSvrDoc FAR * Create(CSimpSvrApp FAR *lpApp, LPRECT lpRect,HWND hWnd);

    CSimpSvrDoc();
    CSimpSvrDoc(CSimpSvrApp FAR *lpApp, HWND hWnd);
    ~CSimpSvrDoc();

// IUnknown Interfaces
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    long lResizeDoc(LPRECT lpRect);
    long lAddVerbs();

    BOOL Load(LPTSTR lpszFileName);
    void PaintDoc(HDC hDC);
    void lButtonDown(WPARAM wParam,LPARAM lParam);

    HRESULT CreateObject(REFIID riid, LPVOID FAR *ppvObject);

    void Close();
    void SetStatusText();
    void ShowDocWnd();
    void ShowHatchWnd();
    void CSimpSvrDoc::HideDocWnd();
    void CSimpSvrDoc::HideHatchWnd();

// member access
    inline HMENU GetMainMenu() { return m_hMainMenu; };
    inline HMENU GetColorMenu() { return m_hColorMenu; };
    inline HMENU GetHelpMenu() { return m_hHelpMenu; } ;
    inline HWND GethDocWnd() { return m_hDocWnd; };
    inline HWND GethHatchWnd() { return m_hHatchWnd; };
    inline HWND GethAppWnd() { return m_lpApp->GethAppWnd(); };
    inline CSimpSvrApp FAR * GetApp() { return m_lpApp; };
    inline CSimpSvrObj FAR * GetObj() { return m_lpObj; };
    inline void ClearObj() { m_lpObj = NULL; };

};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\doc.cpp ===
//**********************************************************************
// File name: DOC.CPP
//
//      Implementation file for CSimpSvrDoc.
//
// Functions:
//
//      See DOC.H for Class Definition
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// CSimpSvrDoc::Create
//
// Purpose:
//
//      Creation for the CSimpSvrDoc Class
//
// Parameters:
//
//      CSimpSvrApp FAR * lpApp  -   Pointer to the CSimpSvrApp Class
//
//      LPRECT lpRect           -   Client area rect of "frame" window
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      StgCreateDocfile            OLE API
//      CreateWindow                Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      CSimpSvrDoc::CSimpSvrDoc    DOC.CPP
//      CreateHatchWindow           OLE2UI
//
// Comments:
//
//      This routine was added so that failure could be returned
//      from object creation.
//
//********************************************************************

CSimpSvrDoc FAR * CSimpSvrDoc::Create(CSimpSvrApp FAR *lpApp, LPRECT lpRect,HWND hWnd)
{
    CSimpSvrDoc FAR * lpTemp = new CSimpSvrDoc(lpApp, hWnd);

    if (!lpTemp)
        return NULL;

    // create the document Window
    lpTemp->m_hDocWnd = CreateWindow(
            TEXT("DocWClass"),
            NULL,
            WS_CHILD | WS_CLIPSIBLINGS,
            lpRect->left,
            lpRect->top,
            lpRect->right,
            lpRect->bottom,
            hWnd,
            NULL,
            lpApp->GethInst(),
            NULL);

    if (!lpTemp->m_hDocWnd)
        goto error;

    lpTemp->ShowDocWnd();

    lpTemp->m_hHatchWnd = CreateHatchWindow( lpTemp->m_hDocWnd, lpApp->GethInst());

    lpTemp->HideHatchWnd();

    return (lpTemp);

error:
    delete (lpTemp);
    return NULL;

}

//**********************************************************************
//
// CSimpSvrDoc::CSimpSvrDoc
//
// Purpose:
//
//      Constructor for the CSimpSvrDoc Class
//
// Parameters:
//
//      CSimpSvrApp FAR * lpApp  -   Pointer to the CSimpSvrApp Class
//
//      HWND hWnd               -   Window Handle of "frame" window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      GetMenu                     Windows API
//      GetSubMenu                  Windows API
//
// Comments:
//
//********************************************************************

CSimpSvrDoc::CSimpSvrDoc(CSimpSvrApp FAR * lpApp,HWND hWnd)
{
    TestDebugOut(TEXT("In CSimpSvrDoc's Constructor\r\n"));
    m_lpApp = lpApp;
    m_nCount = 0;
    m_lpObj = NULL;

    // set up menu handles
    m_hMainMenu = GetMenu(hWnd);
    m_hColorMenu = GetSubMenu(m_hMainMenu, 1);
    m_hHelpMenu = GetSubMenu(m_hMainMenu, 2);


}

//**********************************************************************
//
// CSimpSvrDoc::~CSimpSvrDoc
//
// Purpose:
//
//      Destructor for CSimpSvrDoc
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      DestroyWindow               Windows API
//      CSimpSvrApp::ClearDoc       APP.CPP
//
// Comments:
//
//********************************************************************

CSimpSvrDoc::~CSimpSvrDoc()
{
    TestDebugOut(TEXT("In CSimpSvrDoc's Destructor\r\n"));

    // Clear the Doc object pointer so that the SimpSvrApp won't be able
    // to access invalid objects. (same for the SimpSvrObj)
    if (m_lpApp)
       m_lpApp->ClearDoc();

    if (m_lpObj)
       m_lpObj->ClearDoc();

    DestroyWindow(m_hHatchWnd);
    DestroyWindow(m_hDocWnd);
}


//**********************************************************************
//
// CSimpSvrDoc::QueryInterface
//
// Purpose:
//
//      Return a pointer to a requested interface
//
// Parameters:
//
//      REFIID riid         -   ID of interface to be returned
//      LPVOID FAR* ppvObj  -   Location to return the interface
//
// Return Value:
//
//      E_NOINTERFACE -   Always
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrApp::QueryInterface APP.CPP
//
// Comments:
//
//      Since the document could contain multiple objects, all
//      interfaces except those associated with the document should
//      be returned.  In this implementation, there are no doc level
//      interfaces.
//
//********************************************************************

STDMETHODIMP CSimpSvrDoc::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CSimpSvrDoc::QueryInterface\r\n"));

    SCODE sc = E_NOINTERFACE;

    if (IsEqualIID(riid, IID_IUnknown))
       {
       AddRef();
       *ppvObj = this;
       sc = S_OK;
       }

    return ResultFromScode(sc);
}

//**********************************************************************
//
// CSimpSvrDoc::AddRef
//
// Purpose:
//
//      Increments the document level reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrApp::AddRef         APP.CPP
//
// Comments:
//
//      The reference count at this level reflects the total ref.
//      count of all interfaces on all objects contained within
//      this document.  Note that it also "trickles up" the
//      ref count to the app level.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrDoc::AddRef()
{
    TestDebugOut(TEXT("In CSimpSvrDoc::AddRef\r\n"));
    // AddRef the app, but return the doc count
    m_lpApp->AddRef();

    return ++m_nCount;
}

//**********************************************************************
//
// CSimpSvrDoc::Release
//
// Purpose:
//
//      Decrements the document level reference count
//
// Parameters:
//
//      None
//
// Return Value:
//
//      UINT    -   The current reference count on the document
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrApp::Release         APP.CPP
//
// Comments:
//
//      The reference count at this level reflects the total ref.
//      count of all interfaces on all objects contained within
//      this document.  Note that it also "trickles up" the
//      ref count to the app level.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrDoc::Release()
{
    TestDebugOut(TEXT("In CSimpSvrDoc::Release\r\n"));
    // Release the app, but return the app count
    m_lpApp->Release();

    if (--m_nCount== 0)
    {
        delete this;
        return(0);
    }
    return m_nCount;
}

//**********************************************************************
//
// CSimpSvrDoc::lResizeDoc
//
// Purpose:
//
//      Resizes the document
//
// Parameters:
//
//      LPRECT lpRect   -   The size of the client are of the "frame"
//                          Window.
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                Location
//
//      MoveWindow                              Windows API
//
//
//********************************************************************

long CSimpSvrDoc::lResizeDoc(LPRECT lpRect)
{
    MoveWindow(m_hDocWnd, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, TRUE);
    return NULL;
}


//**********************************************************************
//
// CSimpSvrDoc::PaintDoc
//
// Purpose:
//
//      Paints the Document
//
// Parameters:
//
//      HDC hDC -   hDC of the document Window
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::Draw                   OBJ.CPP
//      CSimpSvrObj::GetDataAdviseHolder    OBJ.H
//      CSimpSvrObj::GetDataObject          OBJ.H
//      CSimpAppObj::IsStartedByOle         APP.CPP
//      IDataAdviseHolder::SendOnDataChange OLE API
//
//
//********************************************************************

void CSimpSvrDoc::PaintDoc (HDC hDC)
{

    // if the object hasn't been created yet, then don't draw
    if (m_lpObj)
        m_lpObj->Draw(hDC,FALSE);
    else
        return;

    // Sending a data change every time we paint, but only if we
    // were started by OLE
    if (m_lpApp->IsStartedByOle())
            m_lpObj->SendOnDataChange( );
}



//**********************************************************************
//
// CSimpSvrDoc::CreateObject
//
// Purpose:
//      Handles the creation of a SimpSvrObj.
//
// Parameters:
//
//
// Return Value:
//
//      S_OK if the function succeeds, otherwise E_FAIL
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::CSimpSvrObj    OBJ.CPP
//      CSimpSvrOjb::QueryInterface OBJ.CPP
//
//
//********************************************************************

HRESULT CSimpSvrDoc::CreateObject(REFIID riid, LPVOID FAR *ppvObject)
{
    SCODE sc = E_FAIL;

    m_lpObj = new CSimpSvrObj(this);

    if (m_lpObj)
        {
        m_lpObj->QueryInterface(riid, ppvObject);
        sc = S_OK;
        }

    return ResultFromScode(sc);
}

//**********************************************************************
//
// CSimpSvrDoc::Close
//
// Purpose:
//
//      Closes the object
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      CSimpSvrObj::AddRef                     OBJ.CPP
//      CSimpSvrObj::Release                    OBJ.CPP
//      CSimpSvrObj::IsInPlaceActive            OBJ.H
//      CSimpSvrObj::GetOleInPlaceObject        OBJ.H
//      CSimpSvrObj::ClearOleClientSite         OBJ.H
//      CSimpSvrObj::GetDataAdviseHolder        OBJ.H
//      CSimpSvrObj::GetOleClientSite           OBJ.H
//      CSimpSvrObj::ClearDataAdviseHolder      OBJ.H
//      CSimpSvrObj::GetOleAdviseHolder         OBJ.H
//      CSimpSvrObj::ClearOleAdviseHolder       OBJ.H
//      IOleInPlaceObject::InPlaceDeactivate    Container
//      IOleClientSite::SaveObject              Container
//      IOleClientSite::OnShowWindow            Container
//      IOleClientSite::Release                 Container
//      IDataAdviseHolder::SendOnDataChange     OLE
//      IDataAdviseHolder::Release              OLE
//      IOleAdviseHolder::SendOnClose           OLE
//      IOleAdviseHolder::Release               OLE
//
//
//********************************************************************

void CSimpSvrDoc::Close()
{
    TestDebugOut(TEXT("In CSimpSvrDoc::Close() \r\n"));

    m_lpObj->AddRef(); // hold object alive

    // if the object is currently inplace active, then deactivate
    if (m_lpObj->IsInPlaceActive())
        m_lpObj->GetOleInPlaceObject()->InPlaceDeactivate();

    // unregister from the ROT...
    if (m_lpObj->GetRotRegister())
        {
        LPRUNNINGOBJECTTABLE lpRot;

        if (GetRunningObjectTable (0, &lpRot) == NOERROR )
            {
            lpRot->Revoke(m_lpObj->GetRotRegister());
            lpRot->Release();
            }
        }

    // if we have a clientsite, instruct it to save the object
    if (m_lpObj->GetOleClientSite())
        {
        m_lpObj->GetOleClientSite()->SaveObject();
        m_lpObj->GetOleClientSite()->OnShowWindow(FALSE);
        }

    // Do a final SendOnDataChange for those containers that have specified the
    // ADF_DATAONSTOP flag.
    if (m_lpObj->GetDataAdviseHolder())
        {
        m_lpObj->GetDataAdviseHolder()->SendOnDataChange( m_lpObj->GetDataObject(), 0, ADVF_DATAONSTOP);
        }


    // Tell the container that we are shutting down.
    if (m_lpObj->GetOleAdviseHolder())
        {
        m_lpObj->GetOleAdviseHolder()->SendOnClose();
        }

    // release our streams and storage
    m_lpObj->GetPersistStorage()->ReleaseStreamsAndStorage();

    // Disconnect the object.  NOTE: This call should not do anything
    // unless the container has cause a GP Fault or some other problem
    // has occured...
    TestDebugOut(TEXT("*** Before CoDisconnectObject *** \r\n"));

    CoDisconnectObject((LPUNKNOWN)m_lpObj, 0);

    TestDebugOut(TEXT("*** After CoDisconnectObject *** \r\n"));

    m_lpObj->Release(); // let object close

}


//**********************************************************************
//
// CSimpSvrDoc::SetStatusText
//
// Purpose:
//
//      Sets the Container's status bar text
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      CSimpSvrObj::IsInPlaceActive    OBJ.CPP
//      IOleInPlaceFrame::SetStatusText Container
//
// Comments:
//
//      Even though there is no status line in this sample, this
//      method must be called on WM_MENUSELECT to clear the last
//      message in the status line.
//
//********************************************************************

void CSimpSvrDoc::SetStatusText()
{
    if (m_lpObj->IsInPlaceActive())
        m_lpObj->GetInPlaceFrame()->SetStatusText(OLESTR("\0"));

}

//**********************************************************************
//
// CSimpSvrDoc::ShowDocWnd
//
// Purpose:
//
//      Shows the Document Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//      UpdateWindow                    Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::ShowDocWnd()
{
    ShowWindow(m_hDocWnd, SW_SHOWNORMAL);  // Show the window
    UpdateWindow(m_hDocWnd);               // Sends WM_PAINT message
}

//**********************************************************************
//
// CSimpSvrDoc::ShowHatchWnd
//
// Purpose:
//
//      Shows the hatch Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::ShowHatchWnd()
{
    ShowWindow(m_hHatchWnd, SW_SHOW);
}

//**********************************************************************
//
// CSimpSvrDoc::HideDocWnd
//
// Purpose:
//
//      Hides the DocumentWindow
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::HideDocWnd()
{
    ShowWindow(m_hDocWnd, SW_HIDE);
}

//**********************************************************************
//
// CSimpSvrDoc::HideHatchWnd
//
// Purpose:
//
//      Hides the Hatch Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//
// Comments:
//
//********************************************************************

void CSimpSvrDoc::HideHatchWnd()
{
    ShowWindow(m_hHatchWnd, SW_HIDE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\app.cpp ===
//**********************************************************************
// File name: app.cpp
//
//    Implementation file for the CSimpSvrApp Class
//
// Functions:
//
//    See app.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "app.h"
#include "doc.h"
#include "icf.h"
#include <msgfiltr.h>

#include "initguid.h"
DEFINE_GUID(GUID_SIMPLE, 0xBCF6D4A0, 0xBE8C, 0x1068, 0xB6, 0xD4, 0x00, 0xDD, 0x01, 0x0C, 0x05, 0x09);

#ifdef WIN32
extern INT_PTR CALLBACK About(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
#endif

//+-------------------------------------------------------------------------
//
//  Function:   SimpsvrMsgCallBack
//
//  Synopsis:   Tell Standard Message Filter not to toss windows messages
//
//  Arguments:  [pmsg] - first message in the queue
//
//  History:    dd-mmm-yy Author    Comment
//              19-May-94 ricksa    author
//
//--------------------------------------------------------------------------
BOOL CALLBACK SimpsvrMsgCallBack(MSG *pmsg)
{
    // We don't care about any of the in particular. We simply care that
    // our messages are not tossed not matter what.
    return TRUE;
}

//**********************************************************************
//
// CSimpSvrApp::CSimpSvrApp()
//
// Purpose:
//
//      Constructor for CSimpSvrApp
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      SetRectEmpty                Windows API
//
// Comments:
//
//
//********************************************************************

CSimpSvrApp::CSimpSvrApp()
{
    TestDebugOut(TEXT("In CSimpSvrApp's Constructor \r\n"));

    // Set Ref Count
    m_nCount = 0;

    // clear members
    m_hAppWnd = NULL;
    m_hInst = NULL;
    m_lpDoc = NULL;

    // clear flags
    m_fInitialized = FALSE;

    // used for inplace
    SetRectEmpty(&nullRect);
}

//**********************************************************************
//
// CSimpSvrApp::~CSimpSvrApp()
//
// Purpose:
//
//      Destructor for CSimpSvrApp Class.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      DestroyWindow               Windows API
//      CSimpSvrApp::IsInitialized  APP.H
//      OleUninitialize             OLE API
//
//********************************************************************

CSimpSvrApp::~CSimpSvrApp()
{
    TestDebugOut(TEXT("In CSimpSvrApp's Destructor\r\n"));

    /* The Simple Server is structured so that SimpSvrApp is ALWAYS the
     * last one to be released, after all the SimpSvrDoc and SimpSvrObj are
     * released. So, we don't need to do any clean up to the SimpSvrDoc
     * and SimpSvrObj objects.
     */

    // Revoke our message filter as the last step.
    CoRegisterMessageFilter(NULL, NULL);

    // need to uninit the library...
    if (IsInitialized())
        OleUninitialize();

    DestroyWindow(m_hAppWnd);
}


//**********************************************************************
//
// CSimpSvrApp::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at Application Level
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK          -   The interface is supported.
//      E_NOINTERFACE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//      IUnknown::AddRef            APP.CPP
//
//
//
//********************************************************************

STDMETHODIMP CSimpSvrApp::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CSimpSvrApp::QueryInterface\r\n"));

    SCODE sc = S_OK;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = this;
    else
        {
        *ppvObj = NULL;
        sc = E_NOINTERFACE;
        }

    if (*ppvObj)
        ((LPUNKNOWN)*ppvObj)->AddRef();

    // asking for something we don't understand at this level.
    return ResultFromScode(sc);
}

//**********************************************************************
//
// CSimpSvrApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Application level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrApp::AddRef()
{
    TestDebugOut(TEXT("In CSimpSvrApp::AddRef\r\n"));
    return ++m_nCount;
}

//**********************************************************************
//
// CSimpSvrApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the application.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces of all objects open
//      in the application.
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrApp::Release()
{
    TestDebugOut(TEXT("In CSimpSvrApp::Release\r\n"));

    if (--m_nCount==0)
    {
        delete this;
        return(0);
    }

    return m_nCount;
}

//**********************************************************************
//
// CSimpSvrApp::fInitApplication
//
// Purpose:
//
//      Initializes the application
//
// Parameters:
//
//      HANDLE hInstance    -   Instance handle of the application.
//
// Return Value:
//
//      TRUE    -   Application was successfully initialized.
//      FALSE   -   Application could not be initialized
//
// Function Calls:
//      Function                    Location
//
//      LoadIcon                    Windows API
//      LoadCursor                  Windows API
//      GetStockObject              Windows API
//      RegisterClass               Windows API
//      RegisterHatchWindowClass    OUTLUI.DLL
//
//
//********************************************************************

BOOL CSimpSvrApp::fInitApplication(HANDLE hInstance)
{
    WNDCLASS  wc;

    // Fill in window class structure with parameters that describe the
    // main window.

    wc.style = NULL;                    // Class style(s).
    wc.lpfnWndProc = MainWndProc;       // Function to retrieve messages for
                                        // windows of this class.
    wc.cbClsExtra = 0;                  // No per-class extra data.
    wc.cbWndExtra = 0;                  // No per-window extra data.
    wc.hInstance = (HINSTANCE) hInstance;           // Application that owns the class.
    wc.hIcon = LoadIcon((HINSTANCE) hInstance, TEXT("SimpSvr"));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);

    wc.lpszMenuName =  TEXT("SimpSvrMENU");    // Name of menu resource in .RC file.
    wc.lpszClassName = TEXT("SimpSvrWClass");  // Name used in call to CreateWindow.

    if (!RegisterClass(&wc))
        return FALSE;

    wc.style = CS_VREDRAW | CS_HREDRAW;                    // Class style(s).
    wc.lpfnWndProc = DocWndProc;        // Function to retrieve messages for
                                        // windows of this class.
    wc.cbClsExtra = 0;                  // No per-class extra data.
    wc.cbWndExtra = 0;                  // No per-window extra data.
    wc.hInstance = (HINSTANCE) hInstance;           // Application that owns the class.
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  NULL;

    wc.lpszClassName = TEXT("DocWClass");     // Name used in call to CreateWindow.

    // Register the window class and return success/failure code.

    if (!RegisterClass(&wc))
        return FALSE;

    return (RegisterHatchWindowClass((HINSTANCE) hInstance));
}

//**********************************************************************
//
// CSimpSvrApp::fInitInstance
//
// Purpose:
//
//      Instance initialization.
//
// Parameters:
//
//      HANDLE hInstance    -   App. Instance Handle.
//
//      int nCmdShow        -   Show parameter from WinMain
//
// Return Value:
//
//      TRUE    -   Initialization Successful
//      FALSE   -   Initialization Failed.
//
//
// Function Calls:
//      Function                    Location
//
//      CreateWindow                Windows API
//      InvalidateRect              Windows API
//      ShowWindow                  Windows API
//      UpdateWindow                Windows API
//      CoRegisterClassObject       OLE API
//      OleBuildVersion             OLE API
//      OleInitialize               OLE API
//      CSimpSvrDoc::CreateObject   DOC.CPP
//
// Comments:
//
//      Note that successful Initalization of the OLE libraries
//      is remembered so the UnInit is only called if needed.
//
//********************************************************************

BOOL CSimpSvrApp::fInitInstance (HANDLE hInstance, int nCmdShow,
                                 CClassFactory FAR * lpClassFactory)
{
    m_hInst = (HINSTANCE) hInstance;

#ifndef WIN32
   /* Since OLE is part of the operating system in Win32, we don't need to
    * check the version number in Win32.
    */
    DWORD dwVer = OleBuildVersion();

    // check to see if we are compatible with this version of the libraries
    if (HIWORD(dwVer) != rmm || LOWORD(dwVer) < rup)
    {
#ifdef _DEBUG
        TestDebugOut("WARNING: Incompatible OLE library version\r\n");
#else
        return FALSE;
#endif
    }

#endif // WIN32

    // initialize the libraries
    if (OleInitialize(NULL) == NOERROR)
        m_fInitialized = TRUE;

    // Load our accelerators
    if ((m_hAccel = LoadAccelerators(m_hInst, TEXT("SimpsvrAccel"))) == NULL)
    {
        // Load failed so abort
        TestDebugOut(TEXT("ERROR: Accelerator Table Load FAILED\r\n"));
        return FALSE;
    }


    // Create the "application" windows
    m_hAppWnd = CreateWindow (TEXT("SimpSvrWClass"),
                              TEXT("Simple OLE 2.0 Server"),
                              WS_OVERLAPPEDWINDOW,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              NULL,
                              NULL,
                              (HINSTANCE) hInstance,
                              NULL);

    if (!m_hAppWnd)
        return FALSE;

    // Because there default call control behavior tosses messages
    // which cause intermittent failures of the test, we install a
    // message filter to get around the problem.
    IMessageFilter *pmf = OleStdMsgFilter_Create(m_hAppWnd,
        TEXT("Simple OLE 2.0 Server"), SimpsvrMsgCallBack, NULL);

    if (pmf == NULL)
    {
        // this call failed so we are hosed. So fail the whole thing
        TestDebugOut(
            TEXT("CSimpSvrApp::fInitInstance OleStdMsgFilter_Create fails\n"));
        return FALSE;
    }

    HRESULT hr = CoRegisterMessageFilter(pmf, NULL);

    if (FAILED(hr))
    {
        // this call failed so we are hosed. So fail the whole thing
        TestDebugOut(
            TEXT("CSimpSvrApp::fInitInstance CoRegisterMessageFilter fails\n"));
        return FALSE;
    }

    // The message filter keeps a reference to this object so we don't have
    // to remember anything about it -- except of course to deregister it.
    pmf->Release();

    // if not started by OLE, then show the Window, and create a "fake" object, else
    // Register a pointer to IClassFactory so that OLE can instruct us to make an
    // object at the appropriate time.
    if (!m_fStartByOle)
        {
        ShowAppWnd(nCmdShow);
        m_lpDoc->CreateObject(IID_IOleObject, (LPVOID FAR *)&m_OleObject);
        InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
        }
    else
        {
        lpClassFactory = new CClassFactory(this);

        if (!lpClassFactory)
        {
           /* Memory allocation fails
            */
           return(FALSE);
        }

        // shouldn't pass an API an object with a zero ref count
        lpClassFactory->AddRef();

        if (
            CoRegisterClassObject(GUID_SIMPLE,
                                  (IUnknown FAR *)lpClassFactory,
                                  CLSCTX_LOCAL_SERVER,
                                  REGCLS_SINGLEUSE,
                                  &m_dwRegisterClass) != S_OK
           )
           TestDebugOut(TEXT("CSimpSvrApp::fInitInstance \
                                   CoRegisterClassObject fails\n"));

        // remove artificial Ref. count
        lpClassFactory->Release();
        }

    return m_fInitialized;
}


//+-------------------------------------------------------------------------
//
//  Member:     CSimpSvrApp::HandleDrawItem (public)
//
//  Synopsis:   Handles the Draw Item message for the owner draw menu for color
//
//  Arguments:	[lpdis]	-- pointer to draw item structure
//
//  Algorithm:  If the request is to draw the item, we create a solid brush
//              based on the color for the menu. Make a copy of the rectangle
//              input. Finally, we shrink the rectangle in size and then fill
//              it with the color.
//
//  History:    dd-mmm-yy Author    Comment
//              02-May-94 ricksa    author
//
//  Notes:
//
//--------------------------------------------------------------------------
void CSimpSvrApp::HandleDrawItem(LPDRAWITEMSTRUCT lpdis)
{
    HBRUSH hbr;
    RECT rc;

    if (lpdis->itemAction == ODA_DRAWENTIRE)
    {
        // Paint the color item in the color requested.
        hbr = CreateSolidBrush(lpdis->itemData);
        CopyRect((LPRECT)&rc, (LPRECT)&lpdis->rcItem);
        InflateRect((LPRECT)&rc, -10, -10);
        FillRect(lpdis->hDC, &rc, hbr);
        DeleteObject(hbr);
    }
}



//+-------------------------------------------------------------------------
//
//  Member:     CSimpSvrApp::HandleChangeColors (public)
//
//  Synopsis:   Handles change between owner draw and regular menu
//
//  Algorithm:  Reset the checked state of the menu item. If it is an owner
//              draw menu requested, then we reset all the menu items to that.
//              Otherwise, we set it to the reqular menu items.
//
//  History:    dd-mmm-yy Author    Comment
//              02-May-94 ricksa    author
//
//  Notes:
//
//--------------------------------------------------------------------------
void CSimpSvrApp::HandleChangeColors(void)
{
    // Get a handle to the Colors menu
    HMENU hMenu = m_lpDoc->GetColorMenu();

    // Get the current state of the item
    BOOL fOwnerDraw = GetMenuState(hMenu, IDM_COLOROWNERDR, MF_BYCOMMAND)
        & MF_CHECKED;

    // Toggle the state of the item.
    CheckMenuItem(hMenu, IDM_COLOROWNERDR,
        MF_BYCOMMAND | (fOwnerDraw ? MF_UNCHECKED : MF_CHECKED));

    if (!fOwnerDraw)
    {
        // Change the items to owner-draw items. Pass the RGB value for the
        // color as the application-supplied data. This makes it easier for
        // us to draw the items.
        ModifyMenu(hMenu, IDM_RED, MF_OWNERDRAW | MF_BYCOMMAND, IDM_RED,
            (LPSTR) RGB (255,0,0));
        ModifyMenu(hMenu, IDM_GREEN, MF_OWNERDRAW | MF_BYCOMMAND, IDM_GREEN,
             (LPSTR)RGB (0,255,0));
        ModifyMenu(hMenu, IDM_BLUE, MF_OWNERDRAW | MF_BYCOMMAND, IDM_BLUE,
             (LPSTR)RGB (0,0,255));
    }
    else
    {
        // Change the items to normal text items. */
        ModifyMenu(hMenu, IDM_RED, MF_BYCOMMAND, IDM_RED, "Red");
        ModifyMenu(hMenu, IDM_GREEN, MF_BYCOMMAND, IDM_GREEN, "Green");
        ModifyMenu(hMenu, IDM_BLUE, MF_BYCOMMAND, IDM_BLUE, "Blue");
    }
}


//**********************************************************************
//
// CSimpSvrApp::lCommandHandler
//
// Purpose:
//
//      Handles the processing of WM_COMMAND.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_COMMAND)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                                    Location
//
//      GetClientRect                               Windows API
//      MessageBox                                  Windows API
//      DialogBox                                   Windows API
//      MakeProcInstance                            Windows API
//      FreeProcInstance                            Windows API
//      SendMessage                                 Windows API
//      DefWindowProc                               Windows API
//      InvalidateRect                              Windows API
//      CSimpSvrDoc::InsertObject                   DOC.CPP
//      CSimpSvrObj::SetColor                       OBJ.CPP
//      CSimpSvrObj::RotateColor                    OBJ.CPP
//
//
//********************************************************************

LRESULT CSimpSvrApp::lCommandHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    // In Win32, the upper word of wParam is the notify code. Since we
    // don't care about this code, we dump it.
    wParam = LOWORD(wParam);

    switch (wParam) {
        // bring up the About box
        case IDM_ABOUT:
            {
#ifdef WIN32
                  DialogBox(m_hInst,               // current instance
                          TEXT("AboutBox"),                  // resource to use
                          m_hAppWnd,                   // parent handle
                          About);                      // About() instance address
#else
                  FARPROC lpProcAbout = MakeProcInstance((FARPROC)About, m_hInst);

                  DialogBox(m_hInst,               // current instance
                          TEXT("AboutBox"),                  // resource to use
                          m_hAppWnd,                   // parent handle
                          lpProcAbout);                // About() instance address

                  FreeProcInstance(lpProcAbout);
#endif  // WIN32

            break;
            }

        // exit the application
        case IDM_EXIT:
            SendMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
            break;

        case IDM_RED:
            m_lpDoc->GetObj()->SetColor (128, 0, 0);
            InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
            break;

        case IDM_GREEN:
            m_lpDoc->GetObj()->SetColor (0,128, 0);
            InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
            break;

        case IDM_BLUE:
            m_lpDoc->GetObj()->SetColor (0, 0, 128);
            InvalidateRect(m_lpDoc->GethDocWnd(), NULL, TRUE);
            break;

        case IDM_COLOROWNERDR:
            HandleChangeColors();
            break;

        default:
            return (DefWindowProc(hWnd, message, wParam, lParam));
           }   // end of switch
    return NULL;
}

//**********************************************************************
//
// CSimpSvrApp::lSizeHandler
//
// Purpose:
//
//      Handles the WM_SIZE message
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_SIZE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      LONG    -   returned from the "document" resizing
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpSvrDoc::lResizeDoc      DOC.CPP
//
//
//********************************************************************

long CSimpSvrApp::lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT rect;

    GetClientRect(m_hAppWnd, &rect);
    return m_lpDoc->lResizeDoc(&rect);
}

//**********************************************************************
//
// CSimpSvrApp::lCreateDoc
//
// Purpose:
//
//      Handles the creation of a document.
//
// Parameters:
//
//      HWND hWnd       -   Handle to the application Window
//
//      UINT message    -   message (always WM_CREATE)
//
//      WPARAM wParam   -   Same as passed to the WndProc
//
//      LPARAM lParam   -   Same as passed to the WndProc
//
// Return Value:
//
//      NULL
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CSimpSvrDoc::Create         DOC.CPP
//
//
//********************************************************************

long CSimpSvrApp::lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT rect;

    GetClientRect(hWnd, &rect);

    m_lpDoc = CSimpSvrDoc::Create(this, &rect, hWnd);

    return NULL;
}



//**********************************************************************
//
// CSimpSvrApp::PaintApp
//
// Purpose:
//
//      Handles the painting of the doc window.
//
//
// Parameters:
//
//      HDC hDC -   hDC to the Doc Window.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrDoc::PaintDoc        DOC.CPP
//
//
//
//********************************************************************

void CSimpSvrApp::PaintApp (HDC hDC)
{

    // if we supported multiple documents, we would enumerate
    // through each of the open documents and call paint.

    if (m_lpDoc)
        m_lpDoc->PaintDoc(hDC);

}

//**********************************************************************
//
// CSimpSvrApp::ParseCmdLine
//
// Purpose:
//
//      Determines if the app was started by OLE
//
//
// Parameters:
//
//      LPSTR lpCmdLine -   Pointer to the command line
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      lstrlen                     Windows API
//      lstrcmp                     Windows API
//
//
// Comments:
//
//      Parses the command line looking for the -Embedding or /Embedding
//      flag.
//
//********************************************************************

void CSimpSvrApp::ParseCmdLine(LPSTR lpCmdLine)
{
    CHAR szTemp[255];

    m_fStartByOle = TRUE;

    ::ParseCmdLine (lpCmdLine, &m_fStartByOle, szTemp);

}

//**********************************************************************
//
// CSimpSvrApp::SetStatusText
//
// Purpose:
//
//      Blanks out the text in the status bar
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrDoc::SetStatusText  DOC.CPP
//
//
//********************************************************************

void CSimpSvrApp::SetStatusText()
{
    m_lpDoc->SetStatusText();
}


//**********************************************************************
//
// CSimpSvrApp::IsInPlaceActive
//
// Purpose:
//
//      Safely determines from the app level if currently inplace active.
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      TRUE    - Inplace active
//      FALSE   - Not Inplace active
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrDoc::GetObject      DOC.H
//      CSimpSvrObj:IsInPlaceActive OBJ.H
//
//
//********************************************************************

BOOL CSimpSvrApp::IsInPlaceActive()
{
    BOOL retval = FALSE;

    if (m_lpDoc)
        if (m_lpDoc->GetObj())
            retval = m_lpDoc->GetObj()->IsInPlaceActive();

    return retval;
}

//**********************************************************************
//
// CSimpSvrApp::ShowAppWnd
//
// Purpose:
//
//      Shows the Application Window
//
// Parameters:
//
//      int nCmdShow    - Window State
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//      UpdateWindow                    Windows API
//      CoLockObjectExternal            OLE API
//
//********************************************************************

void CSimpSvrApp::ShowAppWnd(int nCmdShow)
{
    if (CoLockObjectExternal(this, TRUE, FALSE) != S_OK)
       TestDebugOut(TEXT("CSimpSvrApp::ShowAppWnd  \
                               CoLockObjectExternal fails\n"));
    ShowWindow (m_hAppWnd, nCmdShow);
    UpdateWindow (m_hAppWnd);
}

//**********************************************************************
//
// CSimpSvrApp::ShowAppWnd
//
// Purpose:
//
//      Hides the Application Window
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      ShowWindow                      Windows API
//      CoLockObjectExternal            OLE API
//
//********************************************************************

void CSimpSvrApp::HideAppWnd()
{
    if (CoLockObjectExternal(this, FALSE, TRUE) != S_OK)
       TestDebugOut(TEXT("CSimpSvrApp::HideAppWnd  \
                               CoLockObjectExternal fails\n"));
    ShowWindow (m_hAppWnd, SW_HIDE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\icf.h ===
//**********************************************************************
// File name: icf.h
//
//      Definition of CClassFactory
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _ICF_H_)
#define _ICF_H_

class CSimpSvrApp;

interface CClassFactory :  IClassFactory
{
private:
    int m_nCount;               // reference count
    CSimpSvrApp FAR * m_lpApp;

public:
    CClassFactory::CClassFactory(CSimpSvrApp FAR * lpApp)
        {
        TestDebugOut(TEXT("In CClassFactory's Constructor\r\n"));
        m_lpApp = lpApp;
        m_nCount = 0;
        };
    CClassFactory::~CClassFactory()
       {
       TestDebugOut(TEXT("In CClassFactory's Destructor\r\n"));
       };

    // IUnknown Methods

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP CreateInstance (LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              LPVOID FAR* ppvObject);
    STDMETHODIMP LockServer ( BOOL fLock);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\icf.cpp ===
//**********************************************************************
// File name: ICF.CPP
//
//    Implementation file for the CClassFactory Class
//
// Functions:
//
//    See icf.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "app.h"
#include "doc.h"
#include "icf.h"

//**********************************************************************
//
// CClassFactory::QueryInterface
//
// Purpose:
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CClassFactory::AddRef       ICF.CPP
//
//********************************************************************

STDMETHODIMP CClassFactory::QueryInterface  ( REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CClassFactory::QueryInterface\r\n"));

    SCODE sc = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) ||
         IsEqualIID(riid, IID_IClassFactory) )
        *ppvObj = this;
    else
        {
        *ppvObj = NULL;
        sc = E_NOINTERFACE;
        }

    if (*ppvObj)
        ((LPUNKNOWN)*ppvObj)->AddRef();

    // pass it on to the Application object
    return ResultFromScode(sc);
}

//**********************************************************************
//
// CClassFactory::AddRef
//
// Purpose:
//
//      Increments the reference count on CClassFactory and the application
//      object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The Reference count on CClassFactory
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//
//********************************************************************


STDMETHODIMP_(ULONG) CClassFactory::AddRef ()
{
    TestDebugOut(TEXT("In CClassFactory::AddRef\r\n"));

    return ++m_nCount;
}

//**********************************************************************
//
// CClassFactory::Release
//
// Purpose:
//
//      Decrements the reference count of CClassFactory and the
//      application object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//********************************************************************


STDMETHODIMP_(ULONG) CClassFactory::Release ()
{
    TestDebugOut(TEXT("In CClassFactory::Release\r\n"));

    if (--m_nCount== 0)
    {
        delete this;
        return(0);
    }
    return m_nCount;
}


//**********************************************************************
//
// CClassFactory::CreateInstance
//
// Purpose:
//
//      Instantiates a new OLE object
//
// Parameters:
//
//      LPUNKNOWN pUnkOuter     - Pointer to the controlling unknown
//
//      REFIID riid             - The interface type to fill in ppvObject
//
//      LPVOID FAR* ppvObject   - Out pointer for the object
//
// Return Value:
//
//      S_OK                    - Creation was successful
//      CLASS_E_NOAGGREGATION   - Tried to be created as part of an aggregate
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::CreateObject   DOC.CPP
//
//********************************************************************

STDMETHODIMP CClassFactory::CreateInstance ( LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              LPVOID FAR* ppvObject)
{
    HRESULT hErr;

    TestDebugOut(TEXT("In CClassFactory::CreateInstance\r\n"));

    // need to NULL the out parameter
    *ppvObject = NULL;

    // we don't support aggregation...
    if (pUnkOuter)
        {
        hErr = ResultFromScode(CLASS_E_NOAGGREGATION);
        goto error;
        }

    hErr = m_lpApp->m_lpDoc->CreateObject(riid, ppvObject);

error:
    return hErr;
}

//**********************************************************************
//
// CClassFactory::LockServer
//
// Purpose:
//      To lock the server and keep an open object application in memory
//
// Parameters:
//
//      BOOL fLock      - TRUE to lock the server, FALSE to unlock it
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CoLockObjectExternal        OLE API
//      ResultFromScode             OLE API
//
//
//********************************************************************

STDMETHODIMP CClassFactory::LockServer ( BOOL fLock)
{
    HRESULT hRes;

    TestDebugOut(TEXT("In CClassFactory::LockServer\r\n"));

    if ((hRes=CoLockObjectExternal(m_lpApp, fLock, TRUE)) != S_OK)
    {
       TestDebugOut(TEXT("CClassFactory::LockServer   \
                               CoLockObjectExternal fails\n"));
       return(hRes);
    }

    return ResultFromScode( S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\iec.cpp ===
//**********************************************************************
// File name: IEC.CPP
//
//    Implementation file for the CExternalConnection Class
//
// Functions:
//
//    See iec.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "iec.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// CExternalConnection::QueryInterface
//
// Purpose:
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
//********************************************************************

STDMETHODIMP CExternalConnection::QueryInterface (REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CExternalConnection::QueryInterface\r\n"));

    return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CExternalConnection::AddRef
//
// Purpose:
//
//      Increments the reference count on CSimpSvrObj object. Since
//      CExternalConnection is a nested class of CSimpSvrObj, we don't
//      need a separate reference count for CExternalConnection. We
//      can just use the reference count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of the CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
//********************************************************************

STDMETHODIMP_(ULONG) CExternalConnection::AddRef ()
{
    TestDebugOut(TEXT("In CExternalConnection::AddRef\r\n"));

    return( m_lpObj->AddRef() );
}

//**********************************************************************
//
// CExternalConnection::Release
//
// Purpose:
//
//      Decrements the reference count on CSimpSvrObj object. Since
//      CExternalConnection is a nested class of CSimpSvrObj, we don't
//      need a separate reference count for CExternalConnection. We
//      can just use the reference count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
//********************************************************************

STDMETHODIMP_(ULONG) CExternalConnection::Release ()
{
    TestDebugOut(TEXT("In CExternalConnection::Release\r\n"));

    return m_lpObj->Release();
}

//**********************************************************************
//
// CExternalConnection::AddConnection
//
// Purpose:
//
//      Called when another connection is made to the object.
//
// Parameters:
//
//      DWORD extconn   -   Type of connection
//
//      DWORD reserved  -   Reserved
//
// Return Value:
//
//      Strong connection count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//********************************************************************

STDMETHODIMP_(DWORD) CExternalConnection::AddConnection (DWORD extconn, DWORD reserved)
{
    TestDebugOut(TEXT("In CExternalConnection::AddConnection\r\n"));

    if (extconn & EXTCONN_STRONG)
        return ++m_dwStrong;

    return 0;
}

//**********************************************************************
//
// CExternalConnection::ReleaseConnection
//
// Purpose:
//
//      Called when a connection to the object is released.
//
// Parameters:
//
//      DWORD extconn               - Type of Connection
//
//      DWORD reserved              - Reserved
//
//      BOOL fLastReleaseCloses     - Close flag
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      COleObject::Close           IOO.CPP
//
//
//********************************************************************

STDMETHODIMP_(DWORD) CExternalConnection::ReleaseConnection (DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses)
{
    TestDebugOut(TEXT("In CExternalConnection::ReleaseConnection\r\n"));

    if (extconn & EXTCONN_STRONG)
        {
        DWORD dwSave = --m_dwStrong;

        if (!m_dwStrong && fLastReleaseCloses)
            m_lpObj->m_OleObject.Close(OLECLOSE_SAVEIFDIRTY);

        return dwSave;
        }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\ido.h ===
//**********************************************************************
// File name: ido.h
//
//      Definition of CDataObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IDO_H_)
#define _IDO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface CDataObject : public IDataObject
{
private:
    CSimpSvrObj FAR * m_lpObj;

public:
    CDataObject::CDataObject(CSimpSvrObj FAR * lpSimpSvrObj)
        {
        m_lpObj = lpSimpSvrObj;
        };

    CDataObject::~CDataObject() {};

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP DAdvise  ( FORMATETC FAR* pFormatetc, DWORD advf,
                    LPADVISESINK pAdvSink, DWORD FAR* pdwConnection);
    STDMETHODIMP DUnadvise  ( DWORD dwConnection);
    STDMETHODIMP EnumDAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise);
    STDMETHODIMP EnumFormatEtc  ( DWORD dwDirection,
                                  LPENUMFORMATETC FAR* ppenumFormatEtc);
    STDMETHODIMP GetCanonicalFormatEtc  ( LPFORMATETC pformatetc,
                                          LPFORMATETC pformatetcOut);
    STDMETHODIMP GetData  ( LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium );
    STDMETHODIMP GetDataHere  ( LPFORMATETC pformatetc, LPSTGMEDIUM pmedium );
    STDMETHODIMP QueryGetData  ( LPFORMATETC pformatetc );
    STDMETHODIMP SetData  ( LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease);


};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\ioipao.h ===
//**********************************************************************
// File name: IOIPAO.H
//
//      Definition of COleInPlaceActiveObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _IOIPAO_H_)
#define _IOIPAO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface COleInPlaceActiveObject : public IOleInPlaceActiveObject
{
private:
    CSimpSvrObj FAR * m_lpObj;

public:
    COleInPlaceActiveObject::COleInPlaceActiveObject(CSimpSvrObj FAR * lpSimpSvrObj)
        {
        m_lpObj = lpSimpSvrObj;     // set up the back ptr
        };
    COleInPlaceActiveObject::~COleInPlaceActiveObject() {};   // destructor

// IUnknown Methods

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP OnDocWindowActivate  ( BOOL fActivate) ;
    STDMETHODIMP OnFrameWindowActivate  ( BOOL fActivate) ;
    STDMETHODIMP GetWindow  ( HWND FAR* lphwnd);
    STDMETHODIMP ContextSensitiveHelp  ( BOOL fEnterMode);
    STDMETHODIMP TranslateAccelerator  ( LPMSG lpmsg);
    STDMETHODIMP ResizeBorder  ( LPCRECT lprectBorder,
                                 LPOLEINPLACEUIWINDOW lpUIWindow,
                                 BOOL fFrameWindow);
    STDMETHODIMP EnableModeless  ( BOOL fEnable);

};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\iec.h ===
//**********************************************************************
// File name: iec.h
//
//      Definition of CExternalConnection
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IEC_H_)
#define _IEC_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface CExternalConnection : public IExternalConnection
{
private:
    CSimpSvrObj FAR * m_lpObj;  // Ptr to object
    DWORD m_dwStrong;           // Connection Count

public:
    CExternalConnection::CExternalConnection(CSimpSvrObj FAR * lpSimpSvrObj)
        {
        m_lpObj = lpSimpSvrObj;
        m_dwStrong = 0;
        };

    CExternalConnection::~CExternalConnection() {};

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    // *** IExternalConnection methods ***
    STDMETHODIMP_(DWORD) AddConnection (DWORD extconn, DWORD reserved);
    STDMETHODIMP_(DWORD) ReleaseConnection (DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses);
};

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\ido.cpp ===
//**********************************************************************
// File name: IDO.CPP
//
//    Implementation file for the CDataObject Class
//
// Functions:
//
//    See ido.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ido.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// CDataObject::QueryInterface
//
// Purpose:
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
//********************************************************************


STDMETHODIMP CDataObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CDataObject::QueryInterface\r\n"));

    return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CDataObject::AddRef
//
// Purpose:
//
//      Increments the reference count on CSimpSvrObj. CDataObject is
//      a nested class of CSimpSvrObj, so we don't need a separate
//      reference count for CDataObject. We can just use the reference
//      count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new Reference count on CSimpSvrObject
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
//********************************************************************

STDMETHODIMP_(ULONG) CDataObject::AddRef ()
{
    TestDebugOut(TEXT("In CDataObject::AddRef\r\n"));

    return( m_lpObj->AddRef() );
}

//**********************************************************************
//
// CDataObject::Release
//
// Purpose:
//
//      Decrements the reference count on CSimpSvrObj. CDataObject is
//      a nested class of CSimpSvrObj, so we don't need a separate
//      reference count for CDataObject. We can just use the reference
//      count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of the CSimpSvrObj.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
//********************************************************************

STDMETHODIMP_(ULONG) CDataObject::Release ()
{
    TestDebugOut(TEXT("In CDataObject::Release\r\n"));

    return( m_lpObj->Release() );
}

//**********************************************************************
//
// CDataObject::QueryGetData
//
// Purpose:
//
//      Called to determine if our object supports a particular
//      FORMATETC.
//
// Parameters:
//
//      LPFORMATETC pformatetc  - Pointer to the FORMATETC being queried for.
//
// Return Value:
//
//      DATA_E_FORMATETC    - The FORMATETC is not supported
//      S_OK                - The FORMATETC is supported.
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//
//********************************************************************


STDMETHODIMP CDataObject::QueryGetData  ( LPFORMATETC pformatetc )
{
    SCODE sc = DATA_E_FORMATETC;

    TestDebugOut(TEXT("In CDataObject::QueryGetData\r\n"));

    // check the validity of the formatetc.
    if ( (pformatetc->cfFormat == CF_METAFILEPICT)  &&
         (pformatetc->dwAspect == DVASPECT_CONTENT) &&
         (pformatetc->tymed == TYMED_MFPICT) )
        sc = S_OK;

    return ResultFromScode(sc);
}

//**********************************************************************
//
// CDataObject::DAdvise
//
// Purpose:
//
//      Called by the container when it would like to be notified of
//      changes in the object data.
//
// Parameters:
//
//      FORMATETC FAR* pFormatetc   - The format the container is interested in.
//
//      DWORD advf                  - The type of advise to be set up.
//
//      LPADVISESINK pAdvSink       - Pointer to the containers IAdviseSink
//
//      DWORD FAR* pdwConnection    - Out parameter to return a unique connection id.
//
// Return Value:
//
//      passed on from IDataAdviseHolder
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CreateDataAdviseHolder      OLE API
//      IDataAdviseHolder::Advise   OLE API
//
//
//********************************************************************


STDMETHODIMP CDataObject::DAdvise  ( FORMATETC FAR* pFormatetc, DWORD advf,
                                     LPADVISESINK pAdvSink, DWORD FAR* pdwConnection)
{
    HRESULT hRes;

    TestDebugOut(TEXT("In CDataObject::DAdvise\r\n"));

    // if no DataAdviseHolder has been created, then create one.
    if (!m_lpObj->m_lpDataAdviseHolder)
    {
        hRes=CreateDataAdviseHolder(&m_lpObj->m_lpDataAdviseHolder);
        if (hRes != S_OK)
        {
           TestDebugOut(TEXT("CDataObject::DAdvise  \
                                   cannot CreateDataAdviseHolder\n"));
           return(hRes);
        }
    }

    // pass on to the DataAdviseHolder
    return m_lpObj->m_lpDataAdviseHolder->Advise( this, pFormatetc, advf,
                                                  pAdvSink, pdwConnection);
}

//**********************************************************************
//
// CDataObject::GetData
//
// Purpose:
//
//      Returns the data in the format specified in pformatetcIn.
//
// Parameters:
//
//      LPFORMATETC pformatetcIn    -   The format requested by the caller
//
//      LPSTGMEDIUM pmedium         -   The medium requested by the caller
//
// Return Value:
//
//      DATA_E_FORMATETC    - Format not supported
//      S_OK                - Success
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      CSimpSvrObj::GetMetaFilePict()  OBJ.CPP
//      ResultFromScode                 OLE API
//
//********************************************************************

STDMETHODIMP CDataObject::GetData  ( LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium )
{
    SCODE sc = DATA_E_FORMATETC;

    TestDebugOut(TEXT("In CDataObject::GetData\r\n"));

    // Check to the FORMATETC and fill pmedium if valid.
    if ( (pformatetcIn->cfFormat == CF_METAFILEPICT)  &&
         (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
         (pformatetcIn->tymed & TYMED_MFPICT) )
        {
        HANDLE hmfPict = m_lpObj->GetMetaFilePict();
        pmedium->tymed = TYMED_MFPICT;
        pmedium->hGlobal = hmfPict;
        pmedium->pUnkForRelease = NULL;
        sc = S_OK;
        }

    return ResultFromScode( sc );
}

//**********************************************************************
//
// CDataObject::DUnadvise
//
// Purpose:
//
//      Breaks down an Advise connection.
//
// Parameters:
//
//      DWORD dwConnection  - Advise connection ID.
//
// Return Value:
//
//      Returned from the DataAdviseHolder.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IDataAdviseHolder::Unadvise OLE
//
//********************************************************************

STDMETHODIMP CDataObject::DUnadvise  ( DWORD dwConnection)
{
    TestDebugOut(TEXT("In CDataObject::DUnadvise\r\n"));

    return m_lpObj->m_lpDataAdviseHolder->Unadvise(dwConnection);
}

//**********************************************************************
//
// CDataObject::GetDataHere
//
// Purpose:
//
//      Called to get a data format in a caller supplied location
//
// Parameters:
//
//      LPFORMATETC pformatetc  - FORMATETC requested
//
//      LPSTGMEDIUM pmedium     - Medium to return the data
//
// Return Value:
//
//      DATA_E_FORMATETC    - We don't support the requested format
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      In this simple implementation, we don't really support this
//      method, we just always return DATA_E_FORMATETC.
//
//********************************************************************


STDMETHODIMP CDataObject::GetDataHere  ( LPFORMATETC pformatetc,
                                         LPSTGMEDIUM pmedium )
{
    TestDebugOut(TEXT("In CDataObject::GetDataHere\r\n"));
    return ResultFromScode( DATA_E_FORMATETC);
}

//**********************************************************************
//
// CDataObject::GetCanonicalFormatEtc
//
// Purpose:
//
//      Returns a FORMATETC that is equivalent to the one passed in.
//
// Parameters:
//
//      LPFORMATETC pformatetc      - FORMATETC to be tested.
//
//      LPFORMATETC pformatetcOut   - Out ptr for returned FORMATETC.
//
// Return Value:
//
//      DATA_S_SAMEFORMATETC    - Use the same formatetc as was passed.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CoGetMalloc                 OLE API
//      IMalloc::Alloc              OLE
//      IMalloc::Release            OLE
//      _fmemcpy                    C run-time
//
//********************************************************************


STDMETHODIMP CDataObject::GetCanonicalFormatEtc  ( LPFORMATETC pformatetc,
                                                   LPFORMATETC pformatetcOut)
{
    HRESULT hresult;
    TestDebugOut(TEXT("In CDataObject::GetCanonicalFormatEtc\r\n"));

    if (!pformatetcOut)
        return ResultFromScode(E_INVALIDARG);

    /* OLE2NOTE: we must make sure to set all out parameters to NULL. */
    pformatetcOut->ptd = NULL;

    if (!pformatetc)
        return ResultFromScode(E_INVALIDARG);

    // OLE2NOTE: we must validate that the format requested is supported
    if ((hresult = QueryGetData(pformatetc)) != NOERROR)
        return hresult;

    /* OLE2NOTE: an app that is insensitive to target device (as
    **    SimpSvr is) should fill in the lpformatOut parameter
    **    but NULL out the "ptd" field; it should return NOERROR if the
    **    input formatetc->ptd what non-NULL. this tells the caller
    **    that it is NOT necessary to maintain a separate screen
    **    rendering and printer rendering. if should return
    **    DATA_S_SAMEFORMATETC if the input and output formatetc's are
    **    identical.
    */

    *pformatetcOut = *pformatetc;
    if (pformatetc->ptd == NULL)
        return ResultFromScode(DATA_S_SAMEFORMATETC);
    else
        {
        pformatetcOut->ptd = NULL;
        return NOERROR;
        }
}

//**********************************************************************
//
// CDataObject::SetData
//
// Purpose:
//
//      Called to set the data for the object.
//
// Parameters:
//
//      LPFORMATETC pformatetc      - the format of the data being passed
//
//      STGMEDIUM FAR * pmedium     - the location of the data.
//
//      BOOL fRelease               - Defines the ownership of the medium
//
// Return Value:
//
//      DATA_E_FORMATETC    - Not a valid FORMATETC for this object
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This simple object does not support having its data set, so an
//      error value is always returned.
//
//********************************************************************


STDMETHODIMP CDataObject::SetData  ( LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                                     BOOL fRelease)
{
    TestDebugOut(TEXT("In CDataObject::SetData\r\n"));
    return ResultFromScode( DATA_E_FORMATETC );
}

//**********************************************************************
//
// CDataObject::EnumFormatEtc
//
// Purpose:
//
//      Enumerates the formats supported by this object.
//
// Parameters:
//
//      DWORD dwDirection                       - Order of enumeration.
//
//      LPENUMFORMATETC FAR* ppenumFormatEtc    - Place to return a pointer
//                                                to the enumerator.
//
// Return Value:
//
//      OLE_S_USEREG    - Indicates that OLE should consult the REG DB
//                        to enumerate the formats.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This simple implementation just returns OLE_SUSEREG
//
//********************************************************************


STDMETHODIMP CDataObject::EnumFormatEtc  ( DWORD dwDirection,
                                           LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    TestDebugOut(TEXT("In CDataObject::EnumFormatEtc\r\n"));
    // need to NULL the out parameter
    *ppenumFormatEtc = NULL;
    return ResultFromScode( OLE_S_USEREG );
}

//**********************************************************************
//
// CDataObject::EnumDAdvise
//
// Purpose:
//
//      Returns an enumerator that enumerates all of the advises
//      set up on this data object.
//
// Parameters:
//
//      LPENUMSTATDATA FAR* ppenumAdvise    - An out ptr in which to
//                                            return the enumerator.
//
// Return Value:
//
//      Passed back from IDataAdviseHolder::EnumAdvise
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      IDAtaAdviseHolder::EnumAdvise   OLE
//
// Comments:
//
//      This just delegates to the DataAdviseHolder.
//
//********************************************************************


STDMETHODIMP CDataObject::EnumDAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise)
{
    TestDebugOut(TEXT("In CDataObject::EnumDAdvise\r\n"));
    // need to NULL the out parameter
    *ppenumAdvise = NULL;

    return m_lpObj->m_lpDataAdviseHolder->EnumAdvise(ppenumAdvise);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\ioipo.h ===
//**********************************************************************
// File name: ioipo.h
//
//      Definition of COleInPlaceObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _IOIPO_H_)
#define _IOIPO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface COleInPlaceObject : public IOleInPlaceObject
{
private:
    CSimpSvrObj FAR * m_lpObj;

public:
    COleInPlaceObject::COleInPlaceObject(CSimpSvrObj FAR * lpSimpSvrObj)
        {
        m_lpObj = lpSimpSvrObj;
        };
    COleInPlaceObject::~COleInPlaceObject() {};

//  IUnknown Methods
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP InPlaceDeactivate  ();
    STDMETHODIMP UIDeactivate  () ;
    STDMETHODIMP SetObjectRects  ( LPCRECT lprcPosRect, LPCRECT lprcClipRect);
    STDMETHODIMP GetWindow  ( HWND FAR* lphwnd) ;
    STDMETHODIMP ContextSensitiveHelp  ( BOOL fEnterMode);
    STDMETHODIMP ReactivateAndUndo  ();
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\ioipo.cpp ===
//**********************************************************************
// File name: IOIPO.CPP
//
//    Implementation file for the CClassFactory Class
//
// Functions:
//
//    See ioipo.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioipo.h"
#include "app.h"
#include "doc.h"
#include "math.h"

//**********************************************************************
//
// COleInPlaceObject::QueryInterface
//
// Purpose:
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In COleInPlaceObject::QueryInterface\r\n"));
    // need to NULL the out parameter
    *ppvObj = NULL;
    return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceObject::AddRef
//
// Purpose:
//
//      Increments the reference count of CSimpSvrObj. Since
//      COleInPlaceObject is a nested class of CSimpSvrObj, we don't need
//      to have a separate reference count for COleInPlaceObject. We can
//      use the reference count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceObject::AddRef ()
{
    TestDebugOut(TEXT("In COleInPlaceObject::AddRef\r\n"));
    return m_lpObj->AddRef();
}

//**********************************************************************
//
// COleInPlaceObject::Release
//
// Purpose:
//
//      Decrements the reference count of CSimpSvrObj. Since
//      COleInPlaceObject is a nested class of CSimpSvrObj, we don't need
//      to have a separate reference count for COleInPlaceObject. We can
//      use the reference count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceObject::Release ()
{
    TestDebugOut(TEXT("In COleInPlaceObject::Release\r\n"));
    return m_lpObj->Release();
}

//**********************************************************************
//
// COleInPlaceObject::InPlaceDeactivate
//
// Purpose:
//
//      Called to deactivat the object
//
// Parameters:
//
//      None
//
// Return Value:
//      NOERROR
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      IOleInPlaceSite::OnInPlaceDeactivate    Container
//      IOleInPlaceSite::Release                Container
//      CSimpSvrObj::DeactivateUI               OBJ.CPP
//      CSimpSvrObj::DoInPlaceHide              OBJ.CPP
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::InPlaceDeactivate()
{
     TestDebugOut(TEXT("In COleInPlaceObject::InPlaceDeactivate\r\n"));

     // if not inplace active, return NOERROR
     if (!m_lpObj->m_fInPlaceActive)
         return NOERROR;

     // clear inplace flag
     m_lpObj->m_fInPlaceActive = FALSE;

     // deactivate the UI
     m_lpObj->DeactivateUI();
     m_lpObj->DoInPlaceHide();

     // tell the container that we are deactivating.
     if (m_lpObj->m_lpIPSite)
         {
         HRESULT hRes;
         if ((hRes=m_lpObj->m_lpIPSite->OnInPlaceDeactivate()) != S_OK)
         {
            TestDebugOut(TEXT("COleInPlaceObject::InPlaceDeactivate  \
                                    OnInPlaceDeactivate fails\n"));
         }
         m_lpObj->m_lpIPSite->Release();
         m_lpObj->m_lpIPSite =NULL;
         }

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceObject::UIDeactivate
//
// Purpose:
//
//      Instructs us to remove our UI.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                                Location
//
//      TestDebugOut                       Windows API
//      CSimpSvrObj::DeactivateUI               OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::UIDeactivate()
{
    TestDebugOut(TEXT("In COleInPlaceObject::UIDeactivate\r\n"));

    m_lpObj->DeactivateUI();

    return ResultFromScode (S_OK);
}

//**********************************************************************
//
// COleInPlaceObject::SetObjectRects
//
// Purpose:
//
//      Called when the container clipping region or the object position
//      changes.
//
// Parameters:
//
//      LPCRECT lprcPosRect     - New Position Rect.
//
//      LPCRECT lprcClipRect    - New Clipping Rect.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IntersectRect               Windows API
//      OffsetRect                  Windows API
//      CopyRect                    Windows API
//      MoveWindow                  Windows API
//      CSimpSvrDoc::GethHatchWnd   DOC.H
//      CSimpSvrDoc::gethDocWnd     DOC.h
//      SetHatchWindowSize          OLE2UI
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::SetObjectRects  ( LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
    TestDebugOut(TEXT("In COleInPlaceObject::SetObjectRects\r\n"));

    RECT resRect;
    POINT pt;

    // Get the intersection of the clipping rect and the position rect.
    IntersectRect(&resRect, lprcPosRect, lprcClipRect);

    m_lpObj->m_xOffset = abs (resRect.left - lprcPosRect->left);
    m_lpObj->m_yOffset = abs (resRect.top - lprcPosRect->top);

    m_lpObj->m_scale = (float)(lprcPosRect->right - lprcPosRect->left)/m_lpObj->m_size.x;

    if (m_lpObj->m_scale == 0)
        m_lpObj->m_scale = 1.0F;

    TCHAR szBuffer[255];

    wsprintf(szBuffer, TEXT("New Scale %3d\r\n"), m_lpObj->m_scale);

    TestDebugOut(szBuffer);

    // Adjust the size of the Hatch Window.
    SetHatchWindowSize(m_lpObj->m_lpDoc->GethHatchWnd(),(LPRECT) lprcPosRect, (LPRECT) lprcClipRect, &pt);

    // offset the rect
    OffsetRect(&resRect, pt.x, pt.y);

    CopyRect(&m_lpObj->m_posRect, lprcPosRect);

    // Move the actual object window
    MoveWindow(m_lpObj->m_lpDoc->GethDocWnd(),
                   resRect.left,
                   resRect.top,
                   resRect.right - resRect.left,
                   resRect.bottom - resRect.top,
                   TRUE);


    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleInPlaceObject::GetWindow
//
// Purpose:
//
//      Returns the Window handle of the inplace object
//
// Parameters:
//
//      HWND FAR* lphwnd    - Out pointer in which to return the window
//                            Handle.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpleDoc::GethDocWnd      DOC.H
//
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::GetWindow  ( HWND FAR* lphwnd)
{
    TestDebugOut(TEXT("In COleInPlaceObject::GetWindow\r\n"));
    *lphwnd = m_lpObj->m_lpDoc->GethDocWnd();

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleInPlaceObject::ContextSensitiveHelp
//
// Purpose:
//
//      Used in performing Context Sensitive Help
//
// Parameters:
//
//      BOOL fEnterMode     - Flag to determine if enter or exiting
//                            Context Sensitive Help.
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This function is not implemented due to the fact that it is
//      beyond the scope of a simple object.  All *real* applications
//      are going to want to implement this function, otherwise any
//      container that supports context sensitive help will not work
//      properly while the object is in place.
//
//      See TECHNOTES.WRI include with the OLE SDK for details on
//      Implementing this method.
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::ContextSensitiveHelp  ( BOOL fEnterMode)
{
    TestDebugOut(TEXT("In COleInPlaceObject::ContextSensitiveHelp\r\n"));
    return ResultFromScode( E_NOTIMPL);
}

//**********************************************************************
//
// COleInPlaceObject::ReactivateAndUndo
//
// Purpose:
//
//      Called when the container wants to undo the last edit made in
//      the object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      INPLACE_E_NOTUNDOABLE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Since this server does not support undo, the value
//      INPLACE_E_NOTUNDOABLE is always returned.
//
//********************************************************************

STDMETHODIMP COleInPlaceObject::ReactivateAndUndo  ()
{
    TestDebugOut(TEXT("In COleInPlaceObject::ReactivateAndUndo\r\n"));
    return ResultFromScode( INPLACE_E_NOTUNDOABLE );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\ioipao.cpp ===
//**********************************************************************
// File name: IOIPAO.CPP
//
//    Implementation file for the CClassFactory Class
//
// Functions:
//
//    See ioipao.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioipao.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// COleInPlaceActiveObject::QueryInterface
//
// Purpose:
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::QueryInterface\r\n"));
    // need to NULL the out parameter
    return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleInPlaceActiveObject::AddRef
//
// Purpose:
//
//      Increments the reference count on CSimpSvrObj. Since
//      COleInPlaceActiveObject is a nested class of CSimpSvrObj, we don't
//      need a separate reference count for COleInPlaceActiveObject. We
//      can use the reference count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count on the CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceActiveObject::AddRef ()
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::AddRef\r\n"));

    return m_lpObj->AddRef();
}

//**********************************************************************
//
// COleInPlaceActiveObject::Release
//
// Purpose:
//
//      Decrements the reference count on CSimpSvrObj. Since
//      COleInPlaceActiveObject is a nested class of CSimpSvrObj, we don't
//      need a separate reference count for COleInPlaceActiveObject. We
//      can use the reference count of CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceActiveObject::Release ()
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::Release\r\n"));

    return m_lpObj->Release();
}

//**********************************************************************
//
// COleInPlaceActiveObject::OnDocWindowActivate
//
// Purpose:
//
//      Called when the doc window (in an MDI App) is (de)activated.
//
// Parameters:
//
//      BOOL fActivate  - TRUE if activating, FALSE if deactivating
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IOleInPlaceFrame::SetActiveObject   Container
//      CSimpSvrObject::AddFrameLevelUI     OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::OnDocWindowActivate  ( BOOL fActivate )
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::OnDocWindowActivate\r\n"));

    // Activating?
    if (fActivate)
        m_lpObj->AddFrameLevelUI();

    // No frame level tools to remove...

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceActiveObject::OnFrameWindowActivate
//
// Purpose:
//
//      Called when the Frame window is (de)activating
//
// Parameters:
//
//      BOOL fActivate  - TRUE if activating, FALSE if Deactivating
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      SetFocus                    Windows API
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::OnFrameWindowActivate  ( BOOL fActivate)
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::OnFrameWindowActivate\r\n"));

    // set the focus to the object window if we are activating.
/*    if (fActivate)
        SetFocus(m_lpObj->m_lpDoc->GethDocWnd()); */

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleInPlaceActiveObject::GetWindow
//
// Purpose:
//
//      Gets the objects Window Handle.
//
// Parameters:
//
//      HWND FAR* lphwnd    - Location to return the window handle.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::GethDocWnd     DOC.H
//
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::GetWindow  ( HWND FAR* lphwnd)
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::GetWindow\r\n"));
    // need to NULL the out parameter
    *lphwnd = m_lpObj->m_lpDoc->GethDocWnd();
    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleInPlaceActiveObject::ContextSensitiveHelp
//
// Purpose:
//
//      Used to implement Context Sensitive help
//
// Parameters:
//
//      None
//
// Return Value:
//
//      E_NOTIMPL
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      See TECHNOTES.WRI include with the OLE SDK for proper
//      implementation of this function.
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::ContextSensitiveHelp  ( BOOL fEnterMode )
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::ContextSensitiveHelp\r\n"));
    return ResultFromScode( E_NOTIMPL);
}

//**********************************************************************
//
// COleInPlaceActiveObject::TranslateAccelerator
//
// Purpose:
//
//      Used for translating accelerators in .DLL objects.
//
// Parameters:
//
//      LPMSG lpmsg - Pointer to a message
//
// Return Value:
//
//      S_FALSE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      This method should never be called since we are implemented
//      in an executable.
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::TranslateAccelerator  ( LPMSG lpmsg)
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::TranslateAccelerator\r\n"));
    // no accelerator table, return FALSE
    return ResultFromScode( S_FALSE );
}

//**********************************************************************
//
// COleInPlaceActiveObject::ResizeBorder
//
// Purpose:
//
//      Called when the border changes size.
//
// Parameters:
//
//      LPCRECT lprectBorder                - New Border
//
//      LPOLEINPLACEUIWINDOW lpUIWindow     - Pointer to UIWindow
//
//      BOOL fFrameWindow                   - True if lpUIWindow is the
//                                            frame window.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      Need to call SetBorderSpace again...
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::ResizeBorder  ( LPCRECT lprectBorder,
                                                      LPOLEINPLACEUIWINDOW lpUIWindow,
                                                      BOOL fFrameWindow)
{
    HRESULT hRes;

    TestDebugOut(TEXT("In COleInPlaceActiveObject::ResizeBorder\r\n"));

    // should always have an inplace frame...
    if ((hRes=m_lpObj->GetInPlaceFrame()->SetBorderSpace(NULL)) != S_OK)
    {
       TestDebugOut(TEXT("COleInPlaceActiveObject::ResizeBorder  \
                               SetBorderSpace fails\n"));
       return(hRes);
    }


    // There will only be a UIWindow if in an MDI container
    if (m_lpObj->GetUIWindow())
    {
        if((hRes=m_lpObj->GetUIWindow()->SetBorderSpace(NULL)) != S_OK)
        {
          TestDebugOut(TEXT("COleInPlaceActiveObject::ResizeBorder  \
                                  SetBorderSpace fails\n"));
          return(hRes);
        }
    }

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleInPlaceActiveObject::EnableModeless
//
// Purpose:
//
//      Called to enable/disable modeless dialogs.
//
// Parameters:
//
//      BOOL fEnable    - TRUE to enable, FALSE to disable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      Called by the container when a model dialog box is added/removed
//      from the screen.  The appropriate action for a server application
//      is to disable/enable any modeless dialogs currently being displayed.
//      Since this application doesn't display any modeless dialogs,
//      this method is essentially ignored.
//
//********************************************************************

STDMETHODIMP COleInPlaceActiveObject::EnableModeless  ( BOOL fEnable)
{
    TestDebugOut(TEXT("In COleInPlaceActiveObject::EnableModeless\r\n"));
    return ResultFromScode( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\pre.cpp ===
//**********************************************************************
// File name: pre.cpp
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\ioo.h ===
//**********************************************************************
// File name: ioo.h
//
//      Definition of COleObject
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOO_H_)
#define _IOO_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface COleObject : public IOleObject
{
private:
    CSimpSvrObj FAR * m_lpObj;
    BOOL m_fOpen;

public:
    COleObject::COleObject(CSimpSvrObj FAR * lpSimpSvrObj)
        {
        m_lpObj = lpSimpSvrObj;
        m_fOpen = FALSE;
        };
    COleObject::~COleObject()
        {
        };
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP SetClientSite (LPOLECLIENTSITE pClientSite);
    STDMETHODIMP Advise (LPADVISESINK pAdvSink, DWORD FAR* pdwConnection);
    STDMETHODIMP SetHostNames  ( LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    STDMETHODIMP DoVerb  (  LONG iVerb,
                            LPMSG lpmsg,
                            LPOLECLIENTSITE pActiveSite,
                            LONG lindex,
                            HWND hwndParent,
                            LPCRECT lprcPosRect);
    STDMETHODIMP GetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel);
    STDMETHODIMP Update  () ;
    STDMETHODIMP Close  ( DWORD dwSaveOption) ;
    STDMETHODIMP Unadvise ( DWORD dwConnection);
    STDMETHODIMP EnumVerbs  ( LPENUMOLEVERB FAR* ppenumOleVerb) ;
    STDMETHODIMP GetClientSite  ( LPOLECLIENTSITE FAR* ppClientSite);
    STDMETHODIMP SetMoniker  ( DWORD dwWhichMoniker, LPMONIKER pmk);
    STDMETHODIMP GetMoniker  ( DWORD dwAssign, DWORD dwWhichMoniker,
                               LPMONIKER FAR* ppmk);
    STDMETHODIMP InitFromData  ( LPDATAOBJECT pDataObject,
                                 BOOL fCreation,
                                 DWORD dwReserved);
    STDMETHODIMP GetClipboardData  ( DWORD dwReserved,
                                     LPDATAOBJECT FAR* ppDataObject);
    STDMETHODIMP IsUpToDate  ();
    STDMETHODIMP GetUserClassID  ( CLSID FAR* pClsid);
    STDMETHODIMP GetUserType  ( DWORD dwFormOfType, LPOLESTR FAR* pszUserType);
    STDMETHODIMP SetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel);
    STDMETHODIMP EnumAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise);
    STDMETHODIMP GetMiscStatus  ( DWORD dwAspect, DWORD FAR* pdwStatus);
    STDMETHODIMP SetColorScheme  ( LPLOGPALETTE lpLogpal);

    void OpenEdit(LPOLECLIENTSITE pActiveSite);

};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\ips.cpp ===
//**********************************************************************
// File name: ips.cpp
//
//    Implementation file for the CSimpSvrApp Class
//
// Functions:
//
//    See ips.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ips.h"
#include "app.h"
#include "doc.h"

DEFINE_GUID(GUID_SIMPLE, 0xBCF6D4A0, 0xBE8C, 0x1068, 0xB6, 0xD4, 0x00, 0xDD, 0x01, 0x0C, 0x05, 0x09);

//**********************************************************************
//
// CPersistStorage::QueryInterface
//
// Purpose:
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CPersistStorage::QueryInterface\r\n"));
    // need to NULL the out parameter
    return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CPersistStorage::AddRef
//
// Purpose:
//
//      Increments the reference count on CSimpSvrObj. Since CPersistStorage
//      is a nested class of CSimpSvrObj, we don't need an extra reference
//      count for CPersistStorage. We can safely use the reference count of
//      CSimpSvrObj.
//
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CPersistStorage::AddRef ()
{
    TestDebugOut(TEXT("In CPersistStorage::AddRef\r\n"));
    return m_lpObj->AddRef();
}

//**********************************************************************
//
// CPersistStorage::Release
//
// Purpose:
//
//      Decrements the reference count on CSimpSvrObj. Since CPersistStorage
//      is a nested class of CSimpSvrObj, we don't need an extra reference
//      count for CPersistStorage. We can safely use the reference count of
//      CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) CPersistStorage::Release ()
{
    TestDebugOut(TEXT("In CPersistStorage::Release\r\n"));
    return m_lpObj->Release();
}

//**********************************************************************
//
// CPersistStorage::InitNew
//
// Purpose:
//
//      Used to give a new OLE object a ptr to its storage.
//
// Parameters:
//
//      LPSTORAGE pStg  - Pointer to the storage
//
// Return Value:
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//      IStorage::AddRef            OLE
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::InitNew (LPSTORAGE pStg)
{
    TestDebugOut(TEXT("In CPersistStorage::InitNew\r\n"));

    // release any streams and storages that may be open
    ReleaseStreamsAndStorage();

    m_lpObj->m_lpStorage = pStg;

    // AddRef the new Storage
    if (m_lpObj->m_lpStorage)
	m_lpObj->m_lpStorage->AddRef();

    CreateStreams(m_lpObj->m_lpStorage);

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// CPersistStorage::GetClassID
//
// Purpose:
//
//      Returns the CLSID of this object.
//
// Parameters:
//
//      LPCLSID lpClassID   - Out ptr in which to return the CLSID
//
// Return Value:
//
//       S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::GetClassID  ( LPCLSID lpClassID)
{
     TestDebugOut(TEXT("In CPersistStorage::GetClassID\r\n"));

    *lpClassID = GUID_SIMPLE;

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// CPersistStorage::Save
//
// Purpose:
//
//      Instructs the object to save itself into the storage.
//
// Parameters:
//
//      LPSTORAGE pStgSave  - Storage in which the object should be saved
//
//      BOOL fSameAsLoad    - TRUE if pStgSave is the same as the storage
//                            that the object was originally created with.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CPersistStorage::InitNew    IPS.CPP
//      CSimpSvrObj::SaveToStorage  OBJ.CPP
//
//
// Comments:
//
//      A real app will want better error checking in this method.
//
//********************************************************************

STDMETHODIMP CPersistStorage::Save  ( LPSTORAGE pStgSave, BOOL fSameAsLoad)
{
    TestDebugOut(TEXT("In CPersistStorage::Save\r\n"));

    // save the data
    m_lpObj->SaveToStorage (pStgSave, fSameAsLoad);

    m_lpObj->m_fSaveWithSameAsLoad = fSameAsLoad;
    m_lpObj->m_fNoScribbleMode = TRUE;

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// CPersistStorage::SaveCompleted
//
// Purpose:
//
//      Called when the container is finished saving the object
//
// Parameters:
//
//      LPSTORAGE pStgNew   - ptr to the new storage
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP CPersistStorage::SaveCompleted  ( LPSTORAGE pStgNew)
{
    TestDebugOut(TEXT("In CPersistStorage::SaveCompleted\r\n"));

    if (pStgNew)
	{
	ReleaseStreamsAndStorage();
	m_lpObj->m_lpStorage = pStgNew;
	m_lpObj->m_lpStorage->AddRef();
	OpenStreams(pStgNew);
	}


    /* OLE2NOTE: it is only legal to perform a Save or SaveAs operation
    **    on an embedded object. if the document is a file-based document
    **    then we can not be changed to a IStorage-base object.
    **
    **      fSameAsLoad   lpStgNew     Type of Save     Send OnSave
    **    ---------------------------------------------------------
    **         TRUE        NULL        SAVE             YES
    **         TRUE        ! NULL      SAVE *           YES
    **         FALSE       ! NULL      SAVE AS          YES
    **         FALSE       NULL        SAVE COPY AS     NO
    **
    **    * this is a strange case that is possible. it is inefficient
    **    for the caller; it would be better to pass lpStgNew==NULL for
    **    the Save operation.
    */

    if ( pStgNew || m_lpObj->m_fSaveWithSameAsLoad)
	{
	if (m_lpObj->m_fNoScribbleMode)
	    if (
		m_lpObj->GetOleAdviseHolder()->SendOnSave()!=S_OK
					       // normally would clear a
												  // dirty bit
	       )
	       TestDebugOut(TEXT("SendOnSave fails\n"));
		m_lpObj->m_fSaveWithSameAsLoad = FALSE;
		}
	
	m_lpObj->m_fNoScribbleMode = FALSE;
												
    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// CPersistStorage::Load
//
// Purpose:
//
//      Instructs the object to be loaded from storage.
//
// Parameters:
//
//      LPSTORAGE pStg  - Ptr to the storage in which to be loaded
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      CSimpSvrObj::LoadFromStorage    OBJ.CPP
//
//
// Comments:
//
//      A real app will want better error checking in this method.
//
//********************************************************************

STDMETHODIMP CPersistStorage::Load  ( LPSTORAGE pStg)
{
    TestDebugOut(TEXT("In CPersistStorage::Load\r\n"));

    // remember the storage
    if (m_lpObj->m_lpStorage)
	{
	m_lpObj->m_lpStorage->Release();
	m_lpObj->m_lpStorage = NULL;
	}

    m_lpObj->m_lpStorage = pStg;

    m_lpObj->m_lpStorage->AddRef();

    OpenStreams(m_lpObj->m_lpStorage);

    m_lpObj->LoadFromStorage();


    return ResultFromScode( S_OK );
}


//**********************************************************************
//
// CPersistStorage::IsDirty
//
// Purpose:
//
//      Returns whether or not the object is dirty w/respect to its
//      Storage
//
// Parameters:
//
//      None
//
// Return Value:
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
// Comments:
//
//      This sample does not implement this function, although a
//      real application should.
//
//********************************************************************

STDMETHODIMP CPersistStorage::IsDirty()
{
    TestDebugOut(TEXT("In CPersistStorage::IsDirty\r\n"));
    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// CPersistStorage::HandsOffStorage
//
// Purpose:
//
//      Forces the object to release its handle to its storage.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//
//********************************************************************

STDMETHODIMP CPersistStorage::HandsOffStorage  ()
{
    TestDebugOut(TEXT("In CPersistStorage::HandsOffStorage\r\n"));

    ReleaseStreamsAndStorage();

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// CPersistStorage::CreateStreams
//
// Purpose:
//
//      Creates the streams that are held open for the object's lifetime.
//
// Parameters:
//
//      LPSTORAGE lpStg -   Storage in which to create the streams
//
// Return Value:
//
//      none
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//      IStream::Release            OLE
//      IStorage::CreateStream      OLE
//
//
//********************************************************************

void CPersistStorage::CreateStreams(LPSTORAGE lpStg)
{
    if (m_lpObj->m_lpColorStm)
	m_lpObj->m_lpColorStm->Release();

    if (m_lpObj->m_lpSizeStm)
	m_lpObj->m_lpSizeStm->Release();

    // create a stream to save the colors
    if (
	 lpStg->CreateStream ( OLESTR("RGB"),
			   STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
			   0,
			   0,
			   &m_lpObj->m_lpColorStm)
	 !=S_OK
       )
       TestDebugOut(TEXT("CreateStreams fails\n"));

    // create a stream to save the size
    if (
	 lpStg->CreateStream ( OLESTR("size"),
			   STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
			   0,
			   0,
			   &m_lpObj->m_lpSizeStm)
	 !=S_OK
       )
       TestDebugOut(TEXT("CreateStreams fails\n"));
}

//**********************************************************************
//
// CPersistStorage::OpenStreams
//
// Purpose:
//
//      Opens the streams in a storage.
//
// Parameters:
//
//      LPSTORAGE lpStg -   Storage in which to open the streams.
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStream::Release            OLE
//      IStorage::OpenStream        OLE
//
//
//********************************************************************

void CPersistStorage::OpenStreams(LPSTORAGE lpStg)
{
    if (m_lpObj->m_lpColorStm)
	m_lpObj->m_lpColorStm->Release();

    if (m_lpObj->m_lpSizeStm)
	m_lpObj->m_lpSizeStm->Release();

    // open the color stream
    if (
       lpStg->OpenStream ( OLESTR("RGB"),
			   0,
			   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
			   0,
			   &m_lpObj->m_lpColorStm)
       !=S_OK
       )
       TestDebugOut(TEXT("OpenStream fails\n"));


    // open the color stream
    if (
       lpStg->OpenStream ( OLESTR("size"),
			   0,
			   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
			   0,
			   &m_lpObj->m_lpSizeStm)
       !=S_OK
       )
       TestDebugOut(TEXT("OpenStream fails\n"));

}

//**********************************************************************
//
// CPersistStorage::ReleaseStreamsAndStorage
//
// Purpose:
//
//      Releases the stream and storage ptrs
//
// Parameters:
//
//      None
//
// Return Value:
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStream::Release            OLE
//      IStorage::Release           OLE
//
//********************************************************************

void CPersistStorage::ReleaseStreamsAndStorage()
{
    if (m_lpObj->m_lpColorStm)
	{
	m_lpObj->m_lpColorStm->Release();
	m_lpObj->m_lpColorStm = NULL;
	}

    if (m_lpObj->m_lpSizeStm)
	{
	m_lpObj->m_lpSizeStm->Release();
	m_lpObj->m_lpSizeStm = NULL;
	}

    if (m_lpObj->m_lpStorage)
	{
	m_lpObj->m_lpStorage->Release();
	m_lpObj->m_lpStorage = NULL;
	}
}

//**********************************************************************
//
// CPersistStorage::CreateStreams
//
// Purpose:
//
//      Creates temporary streams in a storage.
//
// Parameters:
//
//      LPSTORAGE lpStg                 - Pointer to the storage
//
//      LPSTREAM FAR* lplpTempColor     - Color Stream
//
//      LPSTREAM FAR* lplpTempSize      - Size Stream
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::Release           OLE
//
//
//********************************************************************

void CPersistStorage::CreateStreams(LPSTORAGE lpStg,
				    LPSTREAM FAR* lplpTempColor,
				    LPSTREAM FAR* lplpTempSize)
{
     // create a stream to save the colors
    if (
       lpStg->CreateStream ( OLESTR("RGB"),
			   STGM_READWRITE | STGM_SHARE_EXCLUSIVE |
			   STGM_CREATE,
			   0,
			   0,
			   lplpTempColor)
	 !=S_OK
       )
       TestDebugOut(TEXT("CreateStreams fails\n"));

    // create a stream to save the size
    if (
       lpStg->CreateStream ( OLESTR("size"),
			   STGM_READWRITE | STGM_SHARE_EXCLUSIVE |
			   STGM_CREATE,
			   0,
			   0,
			   lplpTempSize)
	 !=S_OK
       )
       TestDebugOut(TEXT("CreateStreams fails\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\obj.cpp ===
//**********************************************************************
// File name: obj.cpp
//
//    Implementation file for the CSimpSvrApp Class
//
// Functions:
//
//    See obj.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioo.h"
#include "ido.h"
#include "ips.h"
#include "icf.h"
#include "ioipao.h"
#include "ioipo.h"
#include "app.h"
#include "doc.h"

//**********************************************************************
//
// CSimpSvrObj::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the "Object" level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK          -   The interface is supported.
//      E_NOINTERFACE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      ResultFromScode             OLE API
//      IUnknown::AddRef            OBJ.CPP, IOO.CPP, IDO.CPP, IPS.CPP
//                                  IOIPO.CPP, IOIPAO.CPP
//
//
//********************************************************************

STDMETHODIMP CSimpSvrObj::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In CSimpSvrObj::QueryInterface\r\n"));

    SCODE sc = S_OK;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = this;
    else if (IsEqualIID(riid, IID_IOleObject))
        *ppvObj = &m_OleObject;
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppvObj = &m_DataObject;
    else if ( IsEqualIID(riid, IID_IPersistStorage) ||
              IsEqualIID(riid, IID_IPersist) )
        *ppvObj = &m_PersistStorage;
    else if (IsEqualIID(riid, IID_IOleInPlaceObject))
        *ppvObj = &m_OleInPlaceObject;
    else if (IsEqualIID(riid, IID_IOleInPlaceActiveObject))
        *ppvObj = &m_OleInPlaceActiveObject;
    else
       if (IsEqualIID(riid, IID_IExternalConnection))
         *ppvObj = &m_ExternalConnection;
    else
        {
        *ppvObj = NULL;
        sc = E_NOINTERFACE;
        }

    if (*ppvObj)
        ((LPUNKNOWN)*ppvObj)->AddRef();

    return ResultFromScode( sc );
}

//**********************************************************************
//
// CSimpSvrObj::AddRef
//
// Purpose:
//
//      Adds to the reference count at the Object level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the Object.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::AddRef         DOC.CPP
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces. (ie IDataObject,
//      IExternalConnection, IPersistStorage, IOleInPlaceActiveObject,
//      IOleObject, IOleInPlaceObject)
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrObj::AddRef ()
{
    TestDebugOut(TEXT("In CSimpSvrObj::AddRef\r\n"));

    m_lpDoc->AddRef();

    return ++m_nCount;
}

//**********************************************************************
//
// CSimpSvrObj::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the object.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::Release        DOC.CPP
//      CSimpSvrDoc::ClearObj       DOC.H
//
// Comments:
//
//      Due to the reference counting model that is used in this
//      implementation, this reference count is the sum of the
//      reference counts on all interfaces. (ie IDataObject,
//      IExternalConnection, IPersistStorage, IOleInPlaceActiveObject,
//      IOleObject, IOleInPlaceObject)
//
//********************************************************************

STDMETHODIMP_(ULONG) CSimpSvrObj::Release ()
{
    TestDebugOut(TEXT("In CSimpSvrObj::Release\r\n"));

    /* The SimpSvrObj destructor needs to access SimpSvrDoc. We want to
     * hold on to the SimpSvrDoc object until we have deleted our own.
     */
    CSimpSvrDoc *lpDoc=m_lpDoc;

    if (--m_nCount== 0)
    {
       /* We still have Doc object. But SimpSvrObj object is going away.
        * So, we need to clear the obj pointer in the Doc object.
        */
       lpDoc->ClearObj();

       delete this;

       lpDoc->Release();
       return(0);
    }

    lpDoc->Release();
    return m_nCount;
}

//**********************************************************************
//
// CSimpSvrObj::CSimpSvrObj
//
// Purpose:
//
//      Constructor for CSimpSvrObj. Initialize the members variables
//
// Parameters:
//
//      CSimpSvrDoc FAR * lpSimpSvrDoc - ptr to the doc object
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//
//********************************************************************
#pragma warning (disable : 4355)
                   // "this" used in base initializer list warning.  This
                   // can be disabled because we are not using "this" in
                   // the constructor for these objects, rather we are
                   // just storing it for future use...
CSimpSvrObj::CSimpSvrObj(CSimpSvrDoc FAR * lpSimpSvrDoc) :
                                             m_OleObject(this),
                                             m_DataObject(this),
                                             m_PersistStorage(this),
                                             m_OleInPlaceActiveObject(this),
                                             m_OleInPlaceObject(this),
                                             m_ExternalConnection(this)
#pragma warning (default : 4355) // Turn the warning back on

{
    m_lpDoc = lpSimpSvrDoc;
    m_nCount = 0;
    m_fInPlaceActive = FALSE;
    m_fInPlaceVisible = FALSE;
    m_fUIActive = FALSE;
    m_hmenuShared = NULL;
    m_hOleMenu = NULL;

    m_dwRegister = 0;

    m_lpFrame = NULL;
    m_lpCntrDoc = NULL;

    m_lpStorage = NULL;
    m_lpColorStm = NULL;
    m_lpSizeStm = NULL;
    m_lpOleClientSite = NULL;
    m_lpOleAdviseHolder = NULL;
    m_lpDataAdviseHolder = NULL;
    m_lpIPSite = NULL;

    // The default object is red
    m_red = 128;
    m_green = 0;
    m_blue = 0;

    m_size.x = 100;
    m_size.y = 100;

    m_xOffset = 0;
    m_yOffset = 0;

    m_scale = 1.0F;

    m_fSaveWithSameAsLoad = FALSE;
    m_fNoScribbleMode = FALSE;

}

//**********************************************************************
//
// CSimpSvrObj::~CSimpSvrObj
//
// Purpose:
//
//      Destructor for CSimpSvrObj
//
// Parameters:
//
//      None
//
// Return Value:
//      None
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      PostMessage                 Windows API
//      CSimpSvrDoc::GetApp         DOC.H
//      CSimpSvrDoc::GethAppWnd     DOC.H
//      CSimpSvrApp::IsStartedByOle APP.CPP
//      IDataAdviseHolder           OLE
//      IOleAdviseHolder            OLE
//      IOleClientSite              OLE
//
// Comment:
//      We need to release the DataAdviseHolder, OleClientSite and
//      OleAdviseHolder if they are created by our CSimpSvrObj.
//
//
//********************************************************************

CSimpSvrObj::~CSimpSvrObj()
{
    TestDebugOut(TEXT("In CSimpSvrObj's Destructor \r\n"));

    // if we were started by ole, post ourselves a close message
    if (m_lpDoc->GetApp()->IsStartedByOle())
        PostMessage(m_lpDoc->GethAppWnd(), WM_SYSCOMMAND, SC_CLOSE, 0L);

    /* We need to release our Data Advise Holder when we destroy our
     * object.
     */
    if (m_lpDataAdviseHolder)
    {
        m_lpDataAdviseHolder->Release();
    }

    if (m_lpOleAdviseHolder)
    {
        m_lpOleAdviseHolder->Release();
    }

    if (m_lpOleClientSite)
    {
        m_lpOleClientSite->Release();
    }
}

//**********************************************************************
//
// CSimpSvrObj::Draw
//
// Purpose:
//
//      Draws the object into an arbitrary DC
//
// Parameters:
//
//      HDC hDC - DC to draw into
//
// Return Value:
//
//      NONE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CreateBrushIndirect         Windows API
//      SelectObject                Windows API
//      Rectangle                   Windows API
//      DeleteObject                Windows API
//
//
//********************************************************************

void CSimpSvrObj::Draw (HDC hDC, BOOL m_fMeta)
{
    LOGBRUSH lb;

    TestDebugOut(TEXT("In CSimpSvrObj::Draw\r\n"));

    TCHAR szBuffer[255];

    wsprintf(szBuffer, TEXT("Drawing Scale %3d\r\n"),m_scale);

    TestDebugOut(szBuffer);

    if (!m_fMeta)
    {
        SetMapMode(hDC, MM_ANISOTROPIC);
        SetWindowOrg(hDC, (int)(m_xOffset/m_scale), (int)(m_yOffset/m_scale));
        SetWindowExt(hDC, m_size.x, m_size.y);
        SetViewportExt(hDC, (int)(m_size.x*m_scale), (int)(m_size.y*m_scale));
    }

    // fill out a LOGBRUSH
    lb.lbStyle = BS_SOLID;
    lb.lbColor = RGB(m_red, m_green, m_blue);
    lb.lbHatch = 0;

    // create the brush
    HBRUSH hBrush = CreateBrushIndirect(&lb);

    // select the brush
    HBRUSH hOldBrush = (HBRUSH) SelectObject(hDC, hBrush);
    HPEN hPen = CreatePen(PS_INSIDEFRAME, 6, RGB(0, 0, 0));

    HPEN hOldPen = (HPEN) SelectObject(hDC, hPen);

    // draw the rectangle
    Rectangle (hDC, 0, 0, m_size.x, m_size.y);

    // restore the pen
    hPen = (HPEN) SelectObject(hDC, hOldPen);

    // free the pen
    DeleteObject(hPen);

    // restore the old brush
    hBrush = (HBRUSH) SelectObject(hDC, hOldBrush);

    // free the brush
    DeleteObject(hBrush);
}

//**********************************************************************
//
// CSimpSvrObj::GetMetaFilePict
//
// Purpose:
//
//      Returns a handle to a metafile representation of the object.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      Handle to the metafile.
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      GlobalAlloc                     Windows API
//      GlobalLock                      Windows API
//      SetWindowOrg                    Windows API
//      SetWindowExt                    Windows API
//      CreateMetaFile                  Windows API
//      CloseMetaFile                   Windows API
//      GlobalUnlock                    Windows API
//      XformWidthInPixelsToHimetric    OLE2UI
//      XformHeightInPixelsToHimetric   OLE2UI
//      CSimpSvrObj::Draw               OBJ.CPP
//
//
//********************************************************************

HANDLE CSimpSvrObj::GetMetaFilePict()
{
    HANDLE hMFP;
    METAFILEPICT FAR * lpMFP;
    POINT pt;

    TestDebugOut(TEXT("In CSimpSvrObj::GetMetaFilePict\r\n"));

    // allocate the memory for the METAFILEPICT structure
    hMFP = GlobalAlloc (GMEM_SHARE | GHND, sizeof (METAFILEPICT) );
    if (!hMFP)
    {
       /* GlobalAlloc fails. Cannot allocate global memory.
        */
       return(NULL);
    }
    lpMFP = (METAFILEPICT FAR*) GlobalLock(hMFP);
    if (!lpMFP)
    {
       /* Cannot lock the allocated memory.
        */
       return(NULL);
    }

    // get the size of the object in HIMETRIC
    pt.x = XformWidthInPixelsToHimetric(NULL, m_size.x);
    pt.y = XformHeightInPixelsToHimetric(NULL, m_size.y);

    // fill out the METAFILEPICT structure
    lpMFP->mm = MM_ANISOTROPIC;
    lpMFP->xExt = pt.x;
    lpMFP->yExt = pt.y;

    // Create the metafile
    HDC hDC = CreateMetaFile(NULL);

    if (hDC)
    {
       SetWindowOrg (hDC, 0, 0);
       SetWindowExt (hDC, m_size.x,
                          m_size.y);

       Draw(hDC);

       lpMFP->hMF = CloseMetaFile(hDC);
    }

    // unlock the metafilepict
    GlobalUnlock(hMFP);

    return hMFP;
}


//**********************************************************************
//
// CSimpSvrObj::SaveToStorage
//
// Purpose:
//
//      Saves the object to the passed storage
//
// Parameters:
//
//      LPSTORAGE lpStg - Storage in which to save the object
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::CreateStream      OLE
//      IStream::Write              OLE
//      IStream::Release            OLE
//
// Comments:
//
//      A real app will want to do better error checking / returning
//
//********************************************************************

void CSimpSvrObj::SaveToStorage (LPSTORAGE lpStg, BOOL fSameAsLoad)
{
    TestDebugOut(TEXT("In CSimpSvrObj::SaveToStorage\r\n"));

    LPSTREAM lpTempColor, lpTempSize;

    if (!fSameAsLoad)
        m_PersistStorage.CreateStreams( lpStg, &lpTempColor, &lpTempSize);
    else
        {
        lpTempColor = m_lpColorStm;
        lpTempColor->AddRef();
        lpTempSize = m_lpSizeStm;
        lpTempSize->AddRef();
        }

    ULARGE_INTEGER uli;

    uli.LowPart = 0;
    uli.HighPart = 0;

    if ( lpTempColor->SetSize(uli) != S_OK )
       goto EXIT;            // we don't want to proceed further if fails
    if ( lpTempSize->SetSize(uli) != S_OK )
       goto EXIT;

    LARGE_INTEGER li;

    li.LowPart = 0;
    li.HighPart = 0;

    if ( lpTempColor->Seek(li, STREAM_SEEK_SET, NULL) != S_OK )
       goto EXIT;
    if ( lpTempSize->Seek(li, STREAM_SEEK_SET, NULL) != S_OK )
       goto EXIT;

    // write the colors to the stream
    if ( lpTempColor->Write(&m_red, sizeof(m_red), NULL) != S_OK )
       goto EXIT;
    if ( lpTempColor->Write(&m_green, sizeof(m_green), NULL) != S_OK )
       goto EXIT;
    if ( lpTempColor->Write(&m_blue, sizeof(m_blue), NULL) != S_OK )
       goto EXIT;

    // write the size to the stream
    if ( lpTempSize->Write(&m_size, sizeof(m_size), NULL) != S_OK )
       goto EXIT;

    TestDebugOut(TEXT("SaveToStorage exits normally\n"));

EXIT:
    lpTempColor->Release();
    lpTempSize->Release();
}

//**********************************************************************
//
// CSimpSvrObj::LoadFromStorage
//
// Purpose:
//
//      Loads the object from the passed storage
//
// Parameters:
//
//      LPSTORAGE lpStg     - Storage in which to load the object from
//
// Return Value:
//
//      None.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IStorage::OpenStream        OLE
//      IStream::Read               OLE
//      IStream::Release            OLE
//
//
//********************************************************************

void CSimpSvrObj::LoadFromStorage ()
{
    TestDebugOut(TEXT("In CSimpSvrObj::LoadFromStorage\r\n"));

    // Read the colors
    if ( m_lpColorStm->Read(&m_red, sizeof(m_red), NULL) != S_OK )
       return;
    if ( m_lpColorStm->Read(&m_green, sizeof(m_green), NULL) != S_OK )
       return;
    if ( m_lpColorStm->Read(&m_blue, sizeof(m_blue), NULL) != S_OK )
       return;

    // read the size
    if ( m_lpSizeStm->Read(&m_size, sizeof(m_size), NULL) != S_OK )
       return;

    TestDebugOut(TEXT("LoadFromStorage exits normally\n"));

}

//**********************************************************************
//
// CSimpSvrObj::DoInPlaceActivate
//
// Purpose:
//
//      Does the inplace activation for the object
//
// Parameters:
//
//      LONG lVerb  - Verb that caused this function to be called
//
// Return Value:
//
//      TRUE/FALSE depending on success or failure.
//
// Function Calls:
//      Function                                Location
//
//      IOleClientSite::QueryInterface          Container
//      IOleClientSite::ShowObject              Container
//      IOleInPlaceSite::CanInPlaceActivate     Container
//      IOleInPlaceSite::Release                Container
//      IOleInPlaceSite::OnInPlaceActivate      Container
//      IOleInPlaceSite::GetWindow              Container
//      IOleInPlaceSite::GetWindowContext       Container
//      IOleInPlaceSite::OnUIActivate           Container
//      IOleInPlaceSite::Release                Container
//      IOleInPlaceFrame::SetActiveObject       Container
//      IOleInPlaceUIWindow::SetActiveObject    Container
//      TestDebugOut                       Windows API
//      ShowWindow                              Windows API
//      SetParent                               Windows API
//      IntersectRect                           Windows API
//      OffsetRect                              Windows API
//      MoveWindow                              Windows API
//      CopyRect                                Windows API
//      SetFocus                                Windows API
//      SetHatchWindowSize                      OLE2UI
//      CSimpSvrObj::AssembleMenus              OBJ.CPP
//      CSimpSvrObj::AddFrameLevelUI            OBJ.CPP
//
//
// Comments:
//
//      Be sure to read TECHNOTES.WRI included with the OLE SDK
//      for details on implementing inplace activation.
//
//********************************************************************

BOOL CSimpSvrObj::DoInPlaceActivate (LONG lVerb)
{
    BOOL retval = FALSE;
    RECT posRect, clipRect;


    TestDebugOut(TEXT("In CSimpSvrObj::DoInPlaceActivate\r\n"));

    // if not currently in place active
    if (!m_fInPlaceActive)
    {
        // get the inplace site
        if (m_lpOleClientSite->QueryInterface(IID_IOleInPlaceSite,
                                      (LPVOID FAR *)&m_lpIPSite) != NOERROR)
            goto error;


        // if the inplace site could not be obtained, or refuses to inplace
        // activate then goto error.
        if (m_lpIPSite == NULL || m_lpIPSite->CanInPlaceActivate() != NOERROR)
        {
            if (m_lpIPSite)
                m_lpIPSite->Release();
            m_lpIPSite = NULL;
            goto error;
        }

        // tell the site that we are activating.
        if (m_lpIPSite->OnInPlaceActivate() != S_OK)
           TestDebugOut(TEXT("OnInPlaceActivate fails\n"));

        m_fInPlaceActive = TRUE;
    }

    // if not currently inplace visibl
    if (!m_fInPlaceVisible)
    {
        m_fInPlaceVisible = TRUE;

        // get the window handle of the site
        if (m_lpIPSite->GetWindow(&m_hWndParent) != S_OK)
           TestDebugOut(TEXT("GetWindow fails\n"));

        // get window context from the container
        m_FrameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
        if (m_lpIPSite->GetWindowContext ( &m_lpFrame,
                                     &m_lpCntrDoc,
                                     &posRect,
                                     &clipRect,
                                     &m_FrameInfo) != S_OK)
           TestDebugOut(TEXT("GetWindowContext fails\n"));

        if (sizeof(OLEINPLACEFRAMEINFO) != m_FrameInfo.cb)
        {
           TestDebugOut(TEXT("WARNING! GetWindowContext call "
                                  "modified FrameInfo.cb!\n"));
        }


        // show the hatch window
        m_lpDoc->ShowHatchWnd();

        // Set the parenting
        SetParent (m_lpDoc->GethHatchWnd(), m_hWndParent);
        SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethHatchWnd());

        // tell the client site to show the object
        if (m_lpOleClientSite->ShowObject() != S_OK)
           TestDebugOut(TEXT("ShowObject fails\n"));

        RECT resRect;

        // figure out the "real" size of the object
        IntersectRect(&resRect, &posRect, &clipRect);
        CopyRect(&m_posRect, &posRect);

        POINT pt;

        // adjust our hatch window size
        SetHatchWindowSize ( m_lpDoc->GethHatchWnd(),
                             &resRect,
                             &posRect,
                             &pt);

        // calculate the actual object rect inside the hatchwnd.
        OffsetRect (&resRect, pt.x, pt.y);

        // move the object window
        MoveWindow(m_lpDoc->GethDocWnd(),
                   resRect.left,
                   resRect.top,
                   resRect.right - resRect.left,
                   resRect.bottom - resRect.top,
                   FALSE);

        // create the combined window
        AssembleMenus();
    }

    // if not UIActive
    if (!m_fUIActive)
    {
        m_fUIActive = TRUE;

        // tell the inplace site that we are activating
        m_lpIPSite->OnUIActivate();

        // set the focus to our object window
        SetFocus(m_lpDoc->GethDocWnd());

        // set the active object on the frame
        if (m_lpFrame->SetActiveObject(&m_OleInPlaceActiveObject,
            OLESTR("Simple OLE 2.0 Server")) != S_OK)
           TestDebugOut(TEXT("SetActiveObject fails\n"));

        // set the active object on the Doc, if available.
        if (m_lpCntrDoc)
           if (m_lpCntrDoc->SetActiveObject(&m_OleInPlaceActiveObject,
               OLESTR("Simple OLE 2.0 Server")) != S_OK)
               TestDebugOut(TEXT("SetActiveObjet fails\n"));

        // add the frame level UI.
        AddFrameLevelUI();
    }

    retval = TRUE;
error:
    return retval;
}

//**********************************************************************
//
// CSimpSvrObj::AssembleMenus
//
// Purpose:
//
//      Creates the combined menus used during inplace activation.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      CreateMenu                      Windows API
//      IOleInPlaceFrame::InsertMenus   Container
//      InsertMenu                      Windows API
//      DestroyMenu                     Windows API
//      OleCreateMenuDescriptor         OLE API
//
//
//********************************************************************

void CSimpSvrObj::AssembleMenus()
{
    TestDebugOut(TEXT("In CSimpSvrObj::AssembleMenus\r\n"));
    OLEMENUGROUPWIDTHS menugroupwidths;

    m_hmenuShared = NULL;

    //  Create the menu resource
    m_hmenuShared = CreateMenu();

    // have the contaner insert its menus
    if (m_lpFrame->InsertMenus (m_hmenuShared, &menugroupwidths) == NOERROR)
    {
        int nFirstGroup = (int) menugroupwidths.width[0];

        // insert the server menus
        InsertMenu( m_hmenuShared, nFirstGroup, MF_BYPOSITION | MF_POPUP,
                    (UINT)m_lpDoc->GetColorMenu(), TEXT("&Color"));
        menugroupwidths.width[1] = 1;
        menugroupwidths.width[3] = 0;
        menugroupwidths.width[5] = 0;
    }
    else
    {
        // Destroy the menu resource
        DestroyMenu(m_hmenuShared);
        m_hmenuShared = NULL;
    }

    // tell OLE to create the menu descriptor
    m_hOleMenu = OleCreateMenuDescriptor(m_hmenuShared, &menugroupwidths);
    if (!m_hOleMenu)
       TestDebugOut(TEXT("OleCreateMenuDescriptor fails\n"));
}

//**********************************************************************
//
// CSimpSvrObj::AddFrameLevelUI
//
// Purpose:
//
//      Adds the Frame level user interface
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IOleInPlaceFrame::SetMenu           Container
//      IOleInPlaceFrame::SetBorderSpace    Container
//      IOleInPlaceUIWindow::SetBorderSpace Container
//      CSimpSvrDoc::GethDocWnd             DOC.H
//
//
//********************************************************************

void CSimpSvrObj::AddFrameLevelUI()
{
    TestDebugOut(TEXT("In CSimpSvrObj::AddFrameLevelUI\r\n"));

    // add the combined menu
    if ( m_lpFrame->SetMenu(m_hmenuShared, m_hOleMenu,
                            m_lpDoc->GethDocWnd()) != S_OK )
       return;

    // do hatched border
    SetParent (m_lpDoc->GethHatchWnd(), m_hWndParent);
    SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethHatchWnd());

    // set the border space.  Normally we would negotiate for toolbar
    // space at this point.  Since this server doesn't have a toolbar,
    // this isn't needed...
    if (m_lpFrame)
       if (m_lpFrame->SetBorderSpace(NULL) != S_OK)
          return;

    if (m_lpCntrDoc)
       if (m_lpCntrDoc->SetBorderSpace(NULL) != S_OK)
          return;

    TestDebugOut(TEXT("AddFrameLevelUI exits\n"));

}

//**********************************************************************
//
// CSimpSvrObj::DoInPlaceHide
//
// Purpose:
//
//      Hides the object while inplace actvie
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      SetParent                       Windows API
//      CSimpSvrDoc::GethDocWnd         DOC.H
//      CSimpSvrDoc::GethAppWnd         DOC.H
//      CSimpSvrDoc::GethHatchWnd       DOC.H
//      CSimpSvrObj::DisassembleMenus   OBJ.CPP
//      IOleInPlaceFrame::Release       Container
//      IOleInPlaceUIWindow::Release    Container
//
//
// Comments:
//
//      Be sure to read TECHNOTES.WRI included with the OLE SDK
//      for details on implementing inplace activation.
//
//********************************************************************

void CSimpSvrObj::DoInPlaceHide()
{
    TestDebugOut(TEXT("In CSimpSvrObj::DoInPlaceHide\r\n"));

    // if we aren't inplace visible, then this routine is a NOP,
    if (!m_fInPlaceVisible)
        return;

    m_fInPlaceVisible = FALSE;

    // change the parenting
    SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethAppWnd());
    SetParent (m_lpDoc->GethHatchWnd(),m_lpDoc->GethDocWnd());

    // rip down the combined menus
    DisassembleMenus();

    // release the inplace frame
    m_lpFrame->Release();

    m_lpFrame = NULL;  // only holding one ref. to frame.

    // release the UIWindow if it is there.
    if (m_lpCntrDoc)
        m_lpCntrDoc->Release();

    m_lpCntrDoc = NULL;

}

//**********************************************************************
//
// CSimpSvrObj::DisassembleMenus
//
// Purpose:
//
//      Disassembles the combined menus used in inplace activation
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut               Windows API
//      OleDestroyMenuDescriptor        OLE API
//      RemoveMenu                      Windows API
//      IOleInPlaceFrame::RemoveMenus   Container
//      DestroyMenu                     Windows API
//
// Comments:
//
//      Be sure to read TECHNOTES.WRI included with the OLE SDK
//      for details on implementing inplace activation.
//
//********************************************************************

void CSimpSvrObj::DisassembleMenus()
{
    // destroy the menu descriptor
    OleDestroyMenuDescriptor(m_hOleMenu);

    if (m_hmenuShared)
    {
        // remove the menus that we added
        RemoveMenu( m_hmenuShared, 1, MF_BYPOSITION);

        // have the container remove its menus
        if (m_lpFrame->RemoveMenus(m_hmenuShared) != S_OK)
           TestDebugOut(TEXT("RemoveMenus fails\n"));

        // Destroy the menu resource
        DestroyMenu(m_hmenuShared);

        m_hmenuShared = NULL;
    }
}

//**********************************************************************
//
// CSimpSvrObj::SendOnDataChange
//
// Purpose:
//
//      Uses the data advise holder to send a data change, then updates
//      the ROT to note the time of change.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      IDataAdviseHolder::SendOnDataChange     OLE API
//      GetRunningObjectTable                   OLE API
//      CoFileTimeNow                           OLE API
//      IRunningObjectTable::NoteChangeTime     OLE API
//
//
//********************************************************************

void CSimpSvrObj::SendOnDataChange()
{
    if (m_lpDataAdviseHolder)
        if (m_lpDataAdviseHolder->SendOnDataChange( (LPDATAOBJECT)
                                                   &m_DataObject, 0, 0))
           TestDebugOut(TEXT("SendOnDataChange fails\n"));

    LPRUNNINGOBJECTTABLE lpRot;

    GetRunningObjectTable(0, &lpRot);

    if ( lpRot && m_dwRegister)
    {

        FILETIME ft;
        CoFileTimeNow(&ft);

        lpRot->NoteChangeTime(m_dwRegister, &ft);

        lpRot->Release();
    }
}


//**********************************************************************
//
// CSimpSvrObj::DeactivateUI
//
// Purpose:
//
//      Breaks down the inplace ui
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      SetParent                               Windows API
//      IOleInPlaceUIWindow::SetActiveObject    Container
//      IOleInPlaceFrame::SetActiveObject       Container
//      IOleInPlaceSite::UIDeactivate           Container
//
//
//********************************************************************

void CSimpSvrObj::DeactivateUI()
{
    // if not UI active, or no pointer to IOleInPlaceFrame, then
    // return NOERROR
    if (!(m_fUIActive || m_lpFrame))
        return;
    else
    {
        m_fUIActive = FALSE;

        // remove hatching
        SetParent (m_lpDoc->GethDocWnd(), m_lpDoc->GethAppWnd());
        SetParent (m_lpDoc->GethHatchWnd(),m_lpDoc->GethDocWnd());

        // if in an MDI container, call SetActiveObject on the DOC.
        if (m_lpCntrDoc)
            if (m_lpCntrDoc->SetActiveObject(NULL, NULL) != S_OK)
               TestDebugOut(TEXT("Fail in SetActiveObject\n"));

        if (m_lpFrame->SetActiveObject(NULL, NULL) != S_OK)
           TestDebugOut(TEXT("Fail in SetActiveObject\n"));

        // tell the container that our UI is going away.
        if (m_lpIPSite)
            if (m_lpIPSite->OnUIDeactivate(FALSE) != S_OK)
               TestDebugOut(TEXT("Fail in OnUIDeactivate\n"));
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\obj.h ===
//**********************************************************************
// File name: obj.h
//
//      Definition of CSimpSvrObj
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _OBJ_H_)
#define _OBJ_H_

#include "ioipao.h"
#include "ioipo.h"
#include "ioo.h"
#include "ips.h"
#include "ido.h"
#include "iec.h"

class CSimpSvrDoc;
interface COleObject;
interface CPersistStorage;
interface CDataObject;
interface COleInPlaceActiveObject;
interface COleInPlaceObject;
interface CExternalConnection;

class CSimpSvrObj : public IUnknown
{
private:
    CSimpSvrDoc FAR * m_lpDoc;      // Back pointer
    int m_nCount;                   // reference count
    BOOL m_fInPlaceActive;          // Used during InPlace Negotiation
    BOOL m_fInPlaceVisible;         // "  "  "  "   "   "   "   "   "
    BOOL m_fUIActive;               // "  "  "  "   "   "   "   "   "
    HMENU m_hmenuShared;            // "  "  "  "   "   "   "   "   "
    HOLEMENU m_hOleMenu;            // "  "  "  "   "   "   "   "   "
    RECT m_posRect;                 // "  "  "  "   "   "   "   "   "
    OLEINPLACEFRAMEINFO m_FrameInfo;
    BOOL m_fSaveWithSameAsLoad;
    BOOL m_fNoScribbleMode;

    DWORD m_dwRegister;             // Registered in ROT

    int m_red, m_green, m_blue;     // current color
    POINT m_size;                   // current size
    int m_xOffset;
    int m_yOffset;
    float m_scale;

    HWND m_hWndParent;              // parent window handle

    // interfaces used
    LPSTORAGE m_lpStorage;
    LPSTREAM m_lpColorStm, m_lpSizeStm;
    LPOLECLIENTSITE m_lpOleClientSite;          // IOleClientSite
    LPOLEADVISEHOLDER m_lpOleAdviseHolder;      // IOleAdviseHolder
    LPDATAADVISEHOLDER m_lpDataAdviseHolder;    // IDataAdviseHolder
    LPOLEINPLACEFRAME m_lpFrame;                // IOleInPlaceFrame
    LPOLEINPLACEUIWINDOW m_lpCntrDoc;           // IOleInPlaceUIWindow
    LPOLEINPLACESITE m_lpIPSite;                // IOleInPlaceSite

    // interface implemented
    COleObject m_OleObject;                             // IOleObject
    CPersistStorage m_PersistStorage;                   // IPersistStorage
    CDataObject m_DataObject;                           // IDataObject
    COleInPlaceActiveObject m_OleInPlaceActiveObject;   // IOleInPlaceActiveObject
    COleInPlaceObject m_OleInPlaceObject;               // IOleInPlaceObject
    CExternalConnection m_ExternalConnection;

public:
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

// construction/destruction
    CSimpSvrObj(CSimpSvrDoc FAR * lpSimpSvrDoc);
    ~CSimpSvrObj();

// utility functions
    void Draw(HDC hDC, BOOL fMetaDC = TRUE);
    void PaintObj(HDC hDC);
    void lButtonDown(WPARAM wParam,LPARAM lParam);
    HANDLE GetMetaFilePict();
    void SaveToStorage (LPSTORAGE lpStg, BOOL fSameAsLoad);
    void LoadFromStorage ();

// visual editing helper functions
    BOOL DoInPlaceActivate (LONG lVerb);
    void AssembleMenus();
    void AddFrameLevelUI();
    void DoInPlaceHide();
    void DisassembleMenus();
    void SendOnDataChange();
    void DeactivateUI();

// member variable access
    inline BOOL IsInPlaceActive() { return m_fInPlaceActive; };
    inline BOOL IsInPlaceVisible() { return m_fInPlaceVisible; };
    inline BOOL IsUIActive() { return m_fUIActive; };
    inline HWND GetParent() { return m_hWndParent; };
    inline LPSTORAGE GetStorage() { return m_lpStorage; };
    inline LPOLECLIENTSITE GetOleClientSite() { return m_lpOleClientSite; };
    inline LPDATAADVISEHOLDER GetDataAdviseHolder() { return m_lpDataAdviseHolder; };
    inline LPOLEADVISEHOLDER GetOleAdviseHolder() { return m_lpOleAdviseHolder; };
    inline LPOLEINPLACEFRAME GetInPlaceFrame() { return m_lpFrame; };
    inline LPOLEINPLACEUIWINDOW GetUIWindow() { return m_lpCntrDoc; };
    inline LPOLEINPLACESITE GetInPlaceSite() { return m_lpIPSite; };
    inline COleObject FAR * GetOleObject() { return &m_OleObject; };
    inline CPersistStorage FAR * GetPersistStorage() { return &m_PersistStorage; };
    inline CDataObject FAR * GetDataObject() { return &m_DataObject; };
    inline COleInPlaceActiveObject FAR * GetOleInPlaceActiveObject() { return &m_OleInPlaceActiveObject; };
    inline COleInPlaceObject FAR * GetOleInPlaceObject() { return &m_OleInPlaceObject; };
    inline void ClearOleClientSite() { m_lpOleClientSite = NULL; };
    inline void ClearDataAdviseHolder() { m_lpDataAdviseHolder = NULL; };
    inline void ClearOleAdviseHolder() { m_lpOleAdviseHolder = NULL; };
    inline LPRECT GetPosRect() { return &m_posRect; };
    inline LPPOINT GetSize() { return &m_size; };
    inline LPOLEINPLACEFRAMEINFO GetFrameInfo() {return &m_FrameInfo;};
    inline DWORD GetRotRegister() { return m_dwRegister; };
    inline void ClearDoc() { m_lpDoc = NULL; };

    // member manipulation
    inline void SetColor (int nRed, int nGreen, int nBlue)
        { m_red = nRed; m_green = nGreen; m_blue = nBlue; };

    inline void RotateColor()
        { m_red+=10; m_green+=10; m_blue+=10;};


// all of the interface implementations should be friends of this
// class
friend interface COleObject;
friend interface CPersistStorage;
friend interface CDataObject;
friend interface COleInPlaceActiveObject;
friend interface COleInPlaceObject;
friend interface CExternalConnection;

};
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\ips.h ===
//**********************************************************************
// File name: ips.h
//
//      Definition of CPersistStorage
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _IPS_H_)
#define _IPS_H_


#include <ole2.h>
#include "obj.h"

class CSimpSvrObj;

interface CPersistStorage : IPersistStorage
{
private:
    CSimpSvrObj FAR * m_lpObj;
    BOOL m_fSameAsLoad;

public:
    CPersistStorage::CPersistStorage(CSimpSvrObj FAR * lpSimpSvrObj)
        {
        m_lpObj = lpSimpSvrObj;
        };
    CPersistStorage::~CPersistStorage() {};

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP InitNew (LPSTORAGE pStg);
    STDMETHODIMP GetClassID  ( LPCLSID lpClassID) ;
    STDMETHODIMP Save  ( LPSTORAGE pStgSave, BOOL fSameAsLoad) ;
    STDMETHODIMP SaveCompleted  ( LPSTORAGE pStgNew);
    STDMETHODIMP Load  ( LPSTORAGE pStg);
    STDMETHODIMP IsDirty  ();
    STDMETHODIMP HandsOffStorage  ();

    void ReleaseStreamsAndStorage();
    void OpenStreams(LPSTORAGE lpStg);
    void CreateStreams(LPSTORAGE lpStg);
    void CreateStreams(LPSTORAGE lpStg, LPSTREAM FAR *lpTempColor, LPSTREAM FAR *lpTempSize);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>

#include <ole2.h>
#include <ole2ui.h>
#include <assert.h>
#include <string.h>
#include "simpsvr.h"
#include "resource.h"
extern "C" void TestDebugOut(LPSTR psz);
#ifndef WIN32
/* Since OLE is part of the operating system in Win32, we don't need to
 * check the version number in Win32.
 */
#include <ole2ver.h>
#endif  // WIN32


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\ioo.cpp ===
//**********************************************************************
// File name: IOO.CPP
//
//    Implementation file for the COleObject Class
//
// Functions:
//
//    See ioo.h for a list of member functions.
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "ioo.h"
#include "app.h"
#include "doc.h"

#define VERB_OPEN 1

//**********************************************************************
//
// COleObject::QueryInterface
//
// Purpose:
//      Used for interface negotiation
//
// Parameters:
//
//      REFIID riid         -   Interface being queried for.
//
//      LPVOID FAR *ppvObj  -   Out pointer for the interface.
//
// Return Value:
//
//      S_OK            - Success
//      E_NOINTERFACE   - Failure
//
// Function Calls:
//      Function                    Location
//
//      CSimpSvrObj::QueryInterface OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP COleObject::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj)
{
    TestDebugOut(TEXT("In COleObject::QueryInterface\r\n"));
    return m_lpObj->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// COleObject::AddRef
//
// Purpose:
//
//      Increments the reference count on CSimpSvrObj. Since COleObject
//      is a nested class of CSimpSvrObj, we don't need an extra reference
//      count for COleObject. We can safely use the reference count of
//      CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count on the CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      OuputDebugString            Windows API
//      CSimpSvrObj::AddRef         OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleObject::AddRef ()
{
    TestDebugOut(TEXT("In COleObject::AddRef\r\n"));
    return m_lpObj->AddRef();
}

//**********************************************************************
//
// COleObject::Release
//
// Purpose:
//
//      Decrements the reference count on CSimpSvrObj. Since COleObject
//      is a nested class of CSimpSvrObj, we don't need an extra reference
//      count for COleObject. We can safely use the reference count of
//      CSimpSvrObj.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      The new reference count of CSimpSvrObj
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrObj::Release        OBJ.CPP
//
//
//********************************************************************

STDMETHODIMP_(ULONG) COleObject::Release ()
{
    TestDebugOut(TEXT("In COleObject::Release\r\n"));
    return m_lpObj->Release();
}

//**********************************************************************
//
// COleObject::SetClientSite
//
// Purpose:
//
//      Called to notify the object of it's client site.
//
// Parameters:
//
//      LPOLECLIENTSITE pClientSite     - ptr to new client site
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IOleClientSite::Release     Container
//      IOleClientSite::AddRef      Container
//
//
//********************************************************************

STDMETHODIMP COleObject::SetClientSite  ( LPOLECLIENTSITE pClientSite)
{
    TestDebugOut(TEXT("In COleObject::SetClientSite\r\n"));

    // if we already have a client site, release it.
    if (m_lpObj->m_lpOleClientSite)
        {
        m_lpObj->m_lpOleClientSite->Release();
        m_lpObj->m_lpOleClientSite = NULL;
        }

    // store copy of the client site.
    m_lpObj->m_lpOleClientSite = pClientSite;

    // AddRef it so it doesn't go away.
    if (m_lpObj->m_lpOleClientSite)
        m_lpObj->m_lpOleClientSite->AddRef();

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleObject::Advise
//
// Purpose:
//
//      Called to set up an advise on the OLE object.
//
// Parameters:
//
//      LPADVISESINK pAdvSink       - ptr to the Advise Sink for notification
//
//      DWORD FAR* pdwConnection    - place to return the connection ID.
//
// Return Value:
//
//      Passed back from IOleAdviseHolder::Advise.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CreateOleAdviseHolder       OLE API
//      IOleAdviseHolder::Advise    OLE
//
//
//********************************************************************

STDMETHODIMP COleObject::Advise ( LPADVISESINK pAdvSink, DWORD FAR* pdwConnection)
{
    TestDebugOut(TEXT("In COleObject::Advise\r\n"));

    // if we haven't made an OleAdviseHolder yet, make one.
    if (!m_lpObj->m_lpOleAdviseHolder)
    {
        HRESULT hRes;
        if ((hRes=CreateOleAdviseHolder(&m_lpObj->m_lpOleAdviseHolder))!=S_OK)
        {
           TestDebugOut(TEXT("CreateOleAdviseHolder fails\n"));
           return(hRes);
        }
    }

    // pass this call onto the OleAdviseHolder.
    return m_lpObj->m_lpOleAdviseHolder->Advise(pAdvSink, pdwConnection);
}

//**********************************************************************
//
// COleObject::SetHostNames
//
// Purpose:
//
//      Called to pass strings for Window titles.
//
// Parameters:
//
//      LPCOLESTR szContainerApp   -   ptr to string describing Container App
//
//      LPCOLESTR szContainerObj   -   ptr to string describing Object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This routine is called so that the server application can
//      set the window title appropriately.
//
//********************************************************************

STDMETHODIMP COleObject::SetHostNames  ( LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
    TestDebugOut(TEXT("In COleObject::SetHostNames\r\n"));

    return ResultFromScode( S_OK);
}

//**********************************************************************
//
// COleObject::DoVerb
//
// Purpose:
//
//      Called by the container application to invoke a verb.
//
// Parameters:
//
//      LONG iVerb                  - The value of the verb to be
//                                    invoked.
//
//      LPMSG lpmsg                 - The message that caused the
//                                    verb to be invoked.
//
//      LPOLECLIENTSITE pActiveSite - Ptr to the active client site.
//
//      LONG lindex                 - Used in extended layout
//
//      HWND hwndParent             - This should be the window handle of
//                                    the window in which we are contained.
//                                    This value could be used to "fake"
//                                    inplace activation in a manner similar
//                                    to Video for Windows in OLE 1.0.
//
//      LPCRECT lprcPosRect         - The rectangle that contains the object
//                                    within hwndParent.  Also used to
//                                    "fake" inplace activation.
//
// Return Value:
//
//      OLE_E_NOTINPLACEACTIVE      - Returned if attempted to undo while not
//                                    inplace active.
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      ShowWindow                          Windows API
//      CSimpSvrObj::DoInPlaceActivate      OBJ.CPP
//      CSimpSvrObj::DoInPlaceHide          OBJ.CPP
//      COleObject::OpenEdit                IOO.CPP
//      CSimpSvrDoc::GethDocWnd             DOC.H
//      COleInPlaceObj::InPlaceDeactivate   IOIPO.CPP
//
// Comments:
//
//      Be sure to look at TECHNOTES.WRI included with the OLE
//      SDK for a description of handling the inplace verbs
//      properly.
//
//********************************************************************

STDMETHODIMP COleObject::DoVerb  (  LONG iVerb,
                                    LPMSG lpmsg,
                                    LPOLECLIENTSITE pActiveSite,
                                    LONG lindex,
                                    HWND hwndParent,
                                    LPCRECT lprcPosRect)
{
    TestDebugOut(TEXT("In COleObject::DoVerb\r\n"));

    switch (iVerb)
        {
        case OLEIVERB_SHOW:
        case OLEIVERB_PRIMARY:
            if (m_fOpen)
                SetFocus(m_lpObj->m_lpDoc->GethAppWnd());
            else if (m_lpObj->DoInPlaceActivate(iVerb) == FALSE)
                OpenEdit(pActiveSite);
            break;

        case OLEIVERB_UIACTIVATE:
            if (m_fOpen)
                return ResultFromScode (E_FAIL);

            // inplace activate
            if (!m_lpObj->DoInPlaceActivate(iVerb))
                return ResultFromScode (E_FAIL);
            break;

        case OLEIVERB_DISCARDUNDOSTATE:
            // don't have to worry about this situation as we don't
            // support an undo state.
            if (!m_lpObj->m_fInPlaceActive)
                return ResultFromScode(OLE_E_NOT_INPLACEACTIVE);
            break;

        case OLEIVERB_HIDE:
            // if inplace active, do an "inplace" hide, otherwise
            // just hide the app window.
            if (m_lpObj->m_fInPlaceActive)
                {
                //  clear inplace flag
                m_lpObj->m_fInPlaceActive = FALSE;

                //  deactivate the UI
                m_lpObj->DeactivateUI();
                m_lpObj->DoInPlaceHide();
                }
            else
                m_lpObj->m_lpDoc->GetApp()->HideAppWnd();
            break;

        case OLEIVERB_OPEN:
        case VERB_OPEN:
            // if inplace active, deactivate
            if (m_lpObj->m_fInPlaceActive)
                m_lpObj->m_OleInPlaceObject.InPlaceDeactivate();

            // open into another window.
            OpenEdit(pActiveSite);
            break;

        default:
            if (iVerb < 0)
                return ResultFromScode(E_FAIL);
        }

    return ResultFromScode( S_OK);
}

//**********************************************************************
//
// COleObject::GetExtent
//
// Purpose:
//
//      Returns the extent of the object.
//
// Parameters:
//
//      DWORD dwDrawAspect  - The aspect in which to get the size.
//
//      LPSIZEL lpsizel     - Out ptr to return the size.
//
// Return Value:
//      S_OK        if the aspect is DVASPECT_CONTENT
//      E_FAIL      otherwise
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      XformWidthInPixelsToHimetric    OLE2UI
//      XformHeightInPixelsToHimetric   OLE2UI
//
//
//********************************************************************

STDMETHODIMP COleObject::GetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    TestDebugOut(TEXT("In COleObject::GetExtent\r\n"));

    SCODE sc = E_FAIL;

    // Only DVASPECT_CONTENT is supported....
    if (dwDrawAspect == DVASPECT_CONTENT)
        {
        sc = S_OK;

        // return the correct size in HIMETRIC...
        lpsizel->cx = XformWidthInPixelsToHimetric(NULL, m_lpObj->m_size.x);
        lpsizel->cy = XformHeightInPixelsToHimetric(NULL, m_lpObj->m_size.y);
        }

    return ResultFromScode( sc );
}

//**********************************************************************
//
// COleObject::Update
//
// Purpose:
//
//      Called to get the most up to date data
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      TestDebugOut                   Windows API
//      IDataAdviseHolder::SendOnDataChange OLE
//
//
//********************************************************************

STDMETHODIMP COleObject::Update()
{
    TestDebugOut(TEXT("In COleObject::Update\r\n"));

    // force an update
    m_lpObj->SendOnDataChange();

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleObject::Close
//
// Purpose:
//
//      Called when the OLE object needs to be closed
//
// Parameters:
//
//      DWORD dwSaveOption  - Flags to instruct the server how to prompt
//                            the user.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CSimpSvrDoc::Close          DOC.CPP
//
//
//********************************************************************

STDMETHODIMP COleObject::Close  ( DWORD dwSaveOption)
{
    TestDebugOut(TEXT("In COleObject::Close\r\n"));

    // delegate to the document object.
    m_lpObj->m_lpDoc->Close();

    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleObject::Unadvise
//
// Purpose:
//
//      Breaks down an OLE advise that has been set up on this object.
//
// Parameters:
//
//      DWORD dwConnection  - Connection that needs to be broken down
//
// Return Value:
//
//      Passed back from IOleAdviseHolder::Unadvise
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      IOleAdviseHolder::Unadvise  OLE
//
//
//********************************************************************

STDMETHODIMP COleObject::Unadvise ( DWORD dwConnection)
{
    TestDebugOut(TEXT("In COleObject::Unadvise\r\n"));

    // pass on to OleAdviseHolder.
    return m_lpObj->m_lpOleAdviseHolder->Unadvise(dwConnection);
}

//**********************************************************************
//
// COleObject::EnumVerbs
//
// Purpose:
//
//      Enumerates the verbs associated with this object.
//
// Parameters:
//
//      LPENUMOLEVERB FAR* ppenumOleVerb    - Out ptr in which to return
//                                            the enumerator
//
// Return Value:
//
//      OLE_S_USEREG    - Instructs OLE to use the verbs found in the
//                        REG DB for this server.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      In a .DLL, an application cannot return OLE_S_USEREG.  This is
//      due to the fact that the default object handler is not being
//      used, and the container is really making direct function calls
//      into the server .DLL.
//
//********************************************************************

STDMETHODIMP COleObject::EnumVerbs  ( LPENUMOLEVERB FAR* ppenumOleVerb)
{
    TestDebugOut(TEXT("In COleObject::EnumVerbs\r\n"));

    return ResultFromScode( OLE_S_USEREG );
}

//**********************************************************************
//
// COleObject::GetClientSite
//
// Purpose:
//
//      Called to get the current client site of the object.
//
// Parameters:
//
//      LPOLECLIENTSITE FAR* ppClientSite   - Out ptr in which to return the
//                                            client site.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleObject::GetClientSite  ( LPOLECLIENTSITE FAR* ppClientSite)
{
    TestDebugOut(TEXT("In COleObject::GetClientSite\r\n"));
    *ppClientSite = m_lpObj->m_lpOleClientSite;
    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleObject::SetMoniker
//
// Purpose:
//
//      Used to set the objects moniker
//
// Parameters:
//
//      DWORD dwWhichMoniker    - Type of moniker being set
//
//      LPMONIKER pmk           - Pointer to the moniker
//
// Return Value:
//      S_OK
//      E_FAIL                      if the Moniker cannot be set
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleObject::SetMoniker  ( DWORD dwWhichMoniker, LPMONIKER pmk)
{
    TestDebugOut(TEXT("In COleObject::SetMoniker\r\n"));

    LPMONIKER lpmk;
    HRESULT   hRes;

    if (! m_lpObj->GetOleClientSite())
        return ResultFromScode (E_FAIL);

    if (m_lpObj->GetOleClientSite()->GetMoniker (OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_OBJFULL, &lpmk) != NOERROR)
        return ResultFromScode (E_FAIL);


    if (m_lpObj->GetOleAdviseHolder())
    {
        if ((hRes=m_lpObj->GetOleAdviseHolder()->SendOnRename(lpmk))!=S_OK)
           TestDebugOut(TEXT("SendOnRename fails\n"));
    }

    LPRUNNINGOBJECTTABLE lpRot;

    if (GetRunningObjectTable(0, &lpRot) == NOERROR)
        {
        if (m_lpObj->m_dwRegister)
            lpRot->Revoke(m_lpObj->m_dwRegister);

        if ( ((hRes=lpRot->Register(0, m_lpObj, lpmk,
                                  &m_lpObj->m_dwRegister))!=S_OK) ||
             (hRes!=ResultFromScode(MK_S_MONIKERALREADYREGISTERED)))
           TestDebugOut(TEXT("Running Object Table Register fails\n"));

        lpRot->Release();
        }


    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleObject::GetMoniker
//
// Purpose:
//      returns a moniker from the client site
//
// Parameters:
//
//      DWORD dwAssign          - Assignment for the moniker
//
//      DWORD dwWhichMoniker    - Which moniker to return
//
//      LPMONIKER FAR* ppmk     - An out ptr to return the moniker
//
// Return Value:
//
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
//
//********************************************************************

STDMETHODIMP COleObject::GetMoniker  (  DWORD dwAssign, DWORD dwWhichMoniker,
                                        LPMONIKER FAR* ppmk)
{
    TestDebugOut(TEXT("In COleObject::GetMoniker\r\n"));
    // need to NULL the out parameter
    *ppmk = NULL;

    return m_lpObj->GetOleClientSite()->GetMoniker(OLEGETMONIKER_ONLYIFTHERE,
                                                   OLEWHICHMK_OBJFULL, ppmk);
}

//**********************************************************************
//
// COleObject::InitFromData
//
// Purpose:
//
//      Initialize the object from the passed pDataObject.
//
// Parameters:
//
//      LPDATAOBJECT pDataObject    - Pointer to data transfer object
//                                    to be used in the initialization
//
//      BOOL fCreation              - TRUE if the object is currently being
//                                    created.
//
//      DWORD dwReserved            - Reserved
//
// Return Value:
//
//      S_FALSE
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      We don't support this functionality, so we will always return
//      error.
//
//********************************************************************

STDMETHODIMP COleObject::InitFromData  ( LPDATAOBJECT pDataObject,
                                         BOOL fCreation,
                                         DWORD dwReserved)
{
    TestDebugOut(TEXT("In COleObject::InitFromData\r\n"));

    return ResultFromScode( S_FALSE );
}

//**********************************************************************
//
// COleObject::GetClipboardData
//
// Purpose:
//
//      Returns an IDataObject that is the same as doing an OleSetClipboard
//
// Parameters:
//
//      DWORD dwReserved                - Reserved
//
//      LPDATAOBJECT FAR* ppDataObject  - Out ptr for the Data Object.
//
// Return Value:
//
//      OLE_E_NOTSUPPORTED
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Support of this method is optional.
//
//********************************************************************

STDMETHODIMP COleObject::GetClipboardData  ( DWORD dwReserved,
                                             LPDATAOBJECT FAR* ppDataObject)
{
    TestDebugOut(TEXT("In COleObject::GetClipboardData\r\n"));
    // NULL the out ptr
    *ppDataObject = NULL;
    return ResultFromScode( E_NOTIMPL );
}

//**********************************************************************
//
// COleObject::IsUpToDate
//
// Purpose:
//
//      Determines if an object is up to date
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      Our embedded object is always up to date.  This function is
//      particularly useful in linking situations.
//
//********************************************************************

STDMETHODIMP COleObject::IsUpToDate()
{
    TestDebugOut(TEXT("In COleObject::IsUpToDate\r\n"));
    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleObject::GetUserClassID
//
// Purpose:
//
//      Returns the applications CLSID
//
// Parameters:
//
//      CLSID FAR* pClsid   - Out ptr to return the CLSID
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//      CPersistStorage::GetClassID IPS.CPP
//
// Comments:
//
//      This function is just delegated to IPS::GetClassID.
//
//********************************************************************

STDMETHODIMP COleObject::GetUserClassID  ( CLSID FAR* pClsid)
{
    TestDebugOut(TEXT("In COleObject::GetUserClassID\r\n"));

    return ( m_lpObj->m_PersistStorage.GetClassID(pClsid) );
}

//**********************************************************************
//
// COleObject::GetUserType
//
// Purpose:
//
//      Used to get a user presentable id for this object
//
// Parameters:
//
//      DWORD dwFormOfType      - The ID requested
//
//      LPOLESTR FAR* pszUserType  - Out ptr to return the string
//
// Return Value:
//
//      OLE_S_USEREG    - Use the reg db to get these entries.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comment:
//      In this implementation, we delegate to the default handler's
//      implementation using the registration database to provide
//      the requested info.
//
//********************************************************************

STDMETHODIMP COleObject::GetUserType  ( DWORD dwFormOfType,
                                        LPOLESTR FAR* pszUserType)
{
    TestDebugOut(TEXT("In COleObject::GetUserType\r\n"));

    return ResultFromScode( OLE_S_USEREG );
}

//**********************************************************************
//
// COleObject::SetExtent
//
// Purpose:
//
//      Called to set the extent of the object.
//
// Parameters:
//
//      DWORD dwDrawAspect  - Aspect to have its size set
//
//      LPSIZEL lpsizel     - New size of the object.
//
// Return Value:
//
//      E_NOTIMPL   - This function is not curently implemented.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      See TECHNOTES.WRI include with the OLE SDK for proper
//      implementation of this function.
//
//
//********************************************************************

STDMETHODIMP COleObject::SetExtent  ( DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    TestDebugOut(TEXT("In COleObject::SetExtent\r\n"));
    return ResultFromScode( E_NOTIMPL);
}

//**********************************************************************
//
// COleObject::EnumAdvise
//
// Purpose:
//
//      Returns an enumerate which enumerates the outstanding advises
//      associated with this OLE object.
//
// Parameters:
//
//      LPENUMSTATDATA FAR* ppenumAdvise - Out ptr in which to return
//                                         the enumerator.
//
// Return Value:
//
//      Passed on from IOleAdviseHolder::EnumAdvise.
//
// Function Calls:
//      Function                        Location
//
//      TestDebugOut               Windows API
//      IOleAdviseHolder::EnumAdvise    OLE
//
//
//********************************************************************

STDMETHODIMP COleObject::EnumAdvise  ( LPENUMSTATDATA FAR* ppenumAdvise)
{
    TestDebugOut(TEXT("In COleObject::EnumAdvise\r\n"));
    // need to NULL the out parameter
    *ppenumAdvise = NULL;

    // pass on to the OLE Advise holder.
    return m_lpObj->m_lpOleAdviseHolder->EnumAdvise(ppenumAdvise);
}

//**********************************************************************
//
// COleObject::GetMiscStatus
//
// Purpose:
//
//      Return status information about the object
//
// Parameters:
//
//      DWORD dwAspect          - Aspect interested in.
//
//      DWORD FAR* pdwStatus    - Out ptr in which to return the bits.
//
// Return Value:
//
//      OLE_S_USEREG            - Use the reg db to get these entries.
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comment:
//      In this implementation, we delegate to the default handler's
//      implementation using the registration database to provide
//      the requested info.
//
//
//********************************************************************

STDMETHODIMP COleObject::GetMiscStatus  ( DWORD dwAspect, DWORD FAR* pdwStatus)
{
    TestDebugOut(TEXT("In COleObject::GetMiscStatus\r\n"));
    // need to NULL the out parameter
    *pdwStatus = NULL;
    return ResultFromScode( OLE_S_USEREG );
}

//**********************************************************************
//
// COleObject::SetColorScheme
//
// Purpose:
//
//      Used to set the palette for the object to use.
//
// Parameters:
//
//      LPLOGPALETTE lpLogpal   - Pointer to the LOGPALETTE to be used.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      TestDebugOut           Windows API
//
// Comments:
//
//      This server ignores this method.
//
//********************************************************************

STDMETHODIMP COleObject::SetColorScheme  ( LPLOGPALETTE lpLogpal)
{
    TestDebugOut(TEXT("In COleObject::SetColorScheme\r\n"));
    return ResultFromScode( S_OK );
}

//**********************************************************************
//
// COleObject::OpenEdit
//
// Purpose:
//
//      Used to Open the object into a seperate window.
//
// Parameters:
//
//      LPOLECLIENTSITE pActiveSite - Pointer to the Active clientsite.
//
// Return Value:
//
//      None.
//
// Function Calls:
//      Function                        Location
//
//      IOleClientSite::OnShowWindow    Container
//      ShowWindow                      Windows API
//      UpdateWindow                    Windows API
//      TestDebugOut               Windows API
//      CSimpSvrDoc::GethAppWnd         DOC.H
//      CSimpSvrDoc::GethHatchWnd       DOC.H
//
//
//********************************************************************

void COleObject::OpenEdit(LPOLECLIENTSITE pActiveSite)
{
   if (m_lpObj->GetOleClientSite())
       m_lpObj->GetOleClientSite()->ShowObject();


    m_fOpen = TRUE;

    // tell the site we are opening so the object can be hatched out.
    if (m_lpObj->GetOleClientSite())
        m_lpObj->GetOleClientSite()->OnShowWindow(TRUE);


    m_lpObj->m_lpDoc->ShowDocWnd();

    m_lpObj->m_lpDoc->HideHatchWnd();

    // Show app window.
    m_lpObj->m_lpDoc->GetApp()->ShowAppWnd();

    SetFocus(m_lpObj->m_lpDoc->GethAppWnd());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\simpsvr.h ===
//**********************************************************************
// File name: simpsvr.h
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************
#define IDM_ABOUT 100
#define IDM_INSERT  101
#define IDM_VERB0 1000

int PASCAL WinMain
#ifdef WIN32
   (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);
#else
   (HANDLE  hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);
#endif

BOOL InitApplication(HANDLE hInstance);
BOOL InitInstance(HANDLE hInstance, int nCmdShow);
LRESULT FAR PASCAL EXPORT MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT FAR PASCAL EXPORT DocWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
#ifdef WIN32
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
#else
BOOL FAR PASCAL EXPORT About(HWND hDlg, UINT message, WORD wParam, LONG lParam);
#endif

#define SZCLASSICONBOX "SimpSvrIBClass"
#define SZCLASSRESULTIMAGE "SimpSvrRIClass"

#ifdef WIN32
   // The following functions are all obsolete in Win32.
   // By using the following macros, we can use the app in both Win16 and
   // Win32
	#define SetWindowOrg(h,x,y)       SetWindowOrgEx((h),(x),(y),NULL)
	#define SetWindowExt(h,x,y)       SetWindowExtEx((h),(x),(y),NULL)
   #define SetViewportExt(h,x,y)     SetViewportExtEx((h),(x),(y),NULL)
   #ifndef EXPORT
      #define EXPORT
   #endif
#else

   #ifndef EXPORT
      // _export is obsolete in Win32
      #define EXPORT _export
   #endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\simpsvr.cpp ===
//**********************************************************************
// File name: simpsvr.cpp
//
//      Main source file for the simple OLE 2.0 server
//
// Functions:
//
//      WinMain         - Program entry point
//      MainWndProc     - Processes messages for the frame window
//      About           - Processes messages for the about dialog
//      DocWndProc      - Processes messages for the doc window
//
// Copyright (c) 1993 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "obj.h"
#include "app.h"
#include "doc.h"
#include "icf.h"
#include <stdlib.h>
#include <testmess.h>

#define MEASUREITEMWIDTH  40
#define MEASUREITEMHEIGHT 40

// This line is needed for the debug utilities in OLE2UI
extern "C" {
    OLEDBGDATA_MAIN(TEXT("SIMPSVR"))
}

BOOL fBeVerbose = FALSE;
extern "C"
void TestDebugOut(LPSTR psz)
{
    if (fBeVerbose)
    {
	OutputDebugStringA(psz);
    }
}

CSimpSvrApp FAR * lpCSimpSvrApp;
CClassFactory FAR * lpClassFactory;

//**********************************************************************
//
// WinMain
//
// Purpose:
//
//      Program entry point
//
// Parameters:
//
//      HANDLE hInstance        - Instance handle for this instance
//
//      HANDLE hPrevInstance    - Instance handle for the last instance
//
//      LPSTR lpCmdLine         - Pointer to the command line
//
//      int nCmdShow            - Window State
//
// Return Value:
//
//      msg.wParam
//
// Function Calls:
//      Function                        Location
//
//      CSimpSvrApp::CSimpSvrApp          APP.CPP
//      CSimpSvrApp::fInitApplication    APP.CPP
//      CSimpSvrApp::fInitInstance       APP.CPP
//      CSimpSvrApp::HandleAccelerators  APP.CPP
//      CSimpSvrApp::~CSimpSvrApp         APP.CPP
//      OleUIInitialize                 OLE2UI
//      OleUIUninitialize               OLE2UI
//      GetMessage                      Windows API
//      TranslateMessage                Windows API
//      DispatchMessage                 Windows API
//
//
//********************************************************************

int PASCAL WinMain
#ifdef WIN32
   (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
#else
   (HANDLE  hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
#endif
{
    MSG msg;
    fBeVerbose = GetProfileInt("OLEUTEST","BeVerbose",0);

    if(fBeVerbose == 0)
    {
	fBeVerbose = GetProfileInt("OLEUTEST","simpsvr",0);
    }

    TestDebugOut(TEXT("Starting Simpsvr.....\n"));
	
    // recommended size for OLE apps
    SetMessageQueue(96);

    lpCSimpSvrApp = new CSimpSvrApp;

    if (!lpCSimpSvrApp)
    {
       /* memory allocation error. We cannot carry on.
        */
       MessageBox(NULL, TEXT("Out of Memory"), TEXT("SimpSvr"),
                  MB_SYSTEMMODAL | MB_ICONHAND);
       return(FALSE);
    }

    lpCSimpSvrApp->AddRef();      // need the app ref. count at 1 to hold the
                                  // app alive.

    lpCSimpSvrApp->ParseCmdLine(lpCmdLine);

    // app initialization
    if (!hPrevInstance)
        if (!lpCSimpSvrApp->fInitApplication(hInstance))
        {
            // We need to release CSimpSvrApp before we go away
            lpCSimpSvrApp->Release();
            return (FALSE);
        }

    // instance initialization
    if (!lpCSimpSvrApp->fInitInstance(hInstance, nCmdShow, lpClassFactory))
    {
        // We need to release CSimpSvrApp before we go away
        lpCSimpSvrApp->Release();
        return (FALSE);
    }

    /* Initialization required for OLE 2 UI library.  This call is
    **    needed ONLY if we are using the static link version of the UI
    **    library. If we are using the DLL version, we should NOT call
    **    this function in our application.
    **    The 3rd and 4th parameters passed the OleUIInitialize
    **    function are strings which are used to name two custom
    **    control classes used by the OLE2UI library. These strings
    **    must be unique for each application that uses the OLE2UI
    **    library. These strings are typically composed by combining
    **    the APPNAME with a suffix in order to be unique for a
    **    particular application. The special symbols "SZCLASSICONBOX"
    **    and "SZCLASSRESULTIMAGE" are used define these strings. These
    **    symbols must be defined in a header file that is included
    **    both in this file AND the resource file that included the
    **    "OLE2UI.RC" resoure file. These symbols should be used in the
    **    call to OleUIInitialize and are referenced in the INSOBJ.DLG
    **    and PASTESPL.DLG resouce files of the OLE2UI library.
    */
    if (!OleUIInitialize(hInstance, hPrevInstance, TEXT(SZCLASSICONBOX),
                         TEXT(SZCLASSRESULTIMAGE)))
    {
        OleDbgOut(TEXT("Could not initialize OLEUI library\n"));

        // We need to release CSimpSvrApp before we go away
        lpCSimpSvrApp->Release();

        return FALSE;
    }

    // message loop
    while (GetMessage(&msg, NULL, NULL, NULL))
    {
        // Is this an accelerator for us? -- Remember that this server
        // only has one window and only processes one object at a time.
        if (TranslateAccelerator(lpCSimpSvrApp->GethAppWnd(),
            lpCSimpSvrApp->m_hAccel, &msg))
        {
            // Yes -- so we can loop for the next message
            continue;
        }

        if (lpCSimpSvrApp->IsInPlaceActive())
        {
            // Only key messages need to be sent to OleTranslateAccelerator.
            // Any other message would result in an extra FAR call to occur
            // for that message processing...

            if ((msg.message >= WM_KEYFIRST) && (msg.message <= WM_KEYLAST))
            {
                // OleTranslateAccelerator MUST be called, even though this
                // application does not have an accelerator table.  This has
                // to be done in order for the mneumonics for the top level
                // menu items to work properly.

                if (OleTranslateAccelerator(
                    lpCSimpSvrApp->GetDoc()->GetObj()->GetInPlaceFrame(),
                        lpCSimpSvrApp->GetDoc()->GetObj()->GetFrameInfo(),
                            &msg) == NOERROR)
                {
                    continue;
                }
            }
        }

        TranslateMessage(&msg);    /* Translates virtual key codes  */
        DispatchMessage(&msg);     /* Dispatches message to window  */
    }

    // De-initialization for UI libraries.  Just like OleUIInitialize, this
    // funciton is needed ONLY if we are using the static link version of the
    // OLE UI library.
    OleUIUninitialize();

    return (msg.wParam);          /* Returns the value from PostQuitMessage */
}


//**********************************************************************
//
// MainWndProc
//
// Purpose:
//
//      Processes messages for the main frame window
//
// Parameters:
//
//      HWND hWnd       - Window handle for frame window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
//      long
//
// Function Calls:
//      Function                        Location
//
//      CSimpSvrApp::lCommandHandler     APP.CPP
//      CSimpSvrApp::DestroyDocs         APP.CPP
//      CSimpSvrApp::lCreateDoc          APP.CPP
//      CSimpSvrApp::lSizeHandler        APP.CPP
//      CGameDoc::lAddVerbs              DOC.CPP
//      PostQuitMessage                 Windows API
//      DefWindowProc                   Windows API
//
//
//********************************************************************

LRESULT FAR PASCAL EXPORT MainWndProc(HWND hWnd,UINT message,WPARAM wParam,
                                   LPARAM lParam)
{

    switch (message)
        {
        case WM_CLOSE:
            TestDebugOut(TEXT("*** In WM_CLOSE *** \r\n"));

            // if there is still a document
            if (lpCSimpSvrApp->GetDoc())

                // if there is still an object within a document
                if (lpCSimpSvrApp->GetDoc()->GetObj())
                   // this case occurs if there is still
                   // an outstanding Ref count on the object
                   // when the app is trying to go away.
                   // typically this case will occur in
                   // the "open" editing mode.
                   //
                    //  Close the document
                    lpCSimpSvrApp->GetDoc()->Close();

            // hide the app window
            lpCSimpSvrApp->HideAppWnd();

            // if we were started by ole, unregister the class factory,
            // otherwise remove the ref count on our dummy OLE object
            if (lpCSimpSvrApp->IsStartedByOle())
            {
                if (CoRevokeClassObject(lpCSimpSvrApp->GetRegisterClass())
                    != S_OK)
                    TestDebugOut(TEXT("Fail in CoRevokeClassObject\n"));
            }
            else
                lpCSimpSvrApp->GetOleObject()->Release();

            lpCSimpSvrApp->Release();  // This should close the app.

            break;

        case WM_COMMAND:           // message: command from application menu
            return lpCSimpSvrApp->lCommandHandler(hWnd, message,
                                                  wParam, lParam);
            break;

        case WM_CREATE:
            return lpCSimpSvrApp->lCreateDoc(hWnd, message, wParam, lParam);
            break;

        case WM_DESTROY:                  // message: window being destroyed
            PostQuitMessage(0);
            break;

        case WM_MEASUREITEM:
            ((LPMEASUREITEMSTRUCT)lParam)->itemWidth = MEASUREITEMWIDTH;
            ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = MEASUREITEMHEIGHT;
            break;

        case WM_DRAWITEM:
            lpCSimpSvrApp->HandleDrawItem((LPDRAWITEMSTRUCT) lParam);
            break;

        case WM_SIZE:
            return lpCSimpSvrApp->lSizeHandler(hWnd, message, wParam, lParam);

        default:                          // Passes it on if unproccessed
            return (DefWindowProc(hWnd, message, wParam, lParam));
        }
        return (NULL);
}


//**********************************************************************
//
// About
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for dialog box
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
//
// Function Calls:
//      Function                    Location
//
//      EndDialog                   Windows API
//
//
//********************************************************************

INT_PTR
#ifdef WIN32
	CALLBACK
#else
   FAR PASCAL EXPORT
#endif
   About(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    switch (message)
    {
    case WM_INITDIALOG:               /* message: initialize dialog box */
        return (TRUE);

    case WM_COMMAND:                  /* message: received a command */
        if (wParam == IDOK            /* "OK" box selected?          */
            || wParam == IDCANCEL)    /* System menu close command?  */
        {
           EndDialog(hDlg, TRUE);     /* Exits the dialog box        */
           return (TRUE);
        }
        break;
    }
    return (FALSE);                   /* Didn't process a message    */
}

//**********************************************************************
//
// DocWndProc
//
// Purpose:
//
//      Processes dialog box messages
//
// Parameters:
//
//      HWND hWnd       - Window handle for doc window
//
//      UINT message    - Message value
//
//      WPARAM wParam   - Message info
//
//      LPARAM lParam   - Message info
//
// Return Value:
//
// Function Calls:
//      Function                            Location
//
//      CSimpSvrApp::PaintApp                APP.CPP
//      BeginPaint                          Windows API
//      EndPaint                            Windows API
//      DefWindowProc                       Windows API
//      IOleObject::QueryInterface          Object
//      IOleInPlaceObject::UIDeactivate     Object
//      IOleObject::DoVerb                  Object
//      IOleInPlaceObject::Release          Object
//
//
//********************************************************************

LRESULT FAR PASCAL EXPORT DocWndProc(HWND hWnd,UINT message,WPARAM wParam,
                                  LPARAM lParam)
{
    HDC hDC;
    PAINTSTRUCT ps;

    switch (message)
    {
        case WM_COMMAND:           // message: command from application menu
            return lpCSimpSvrApp->lCommandHandler(hWnd, message,
                                                  wParam, lParam);
            break;

        case WM_PAINT:
            hDC = BeginPaint(hWnd, &ps);

            // tell the app class to paint itself
            if (lpCSimpSvrApp)
                lpCSimpSvrApp->PaintApp (hDC);

            EndPaint(hWnd, &ps);
            break;

        case WM_MENUSELECT:
            lpCSimpSvrApp->SetStatusText();
            break;

        case WM_MEASUREITEM:
            ((LPMEASUREITEMSTRUCT)lParam)->itemWidth = MEASUREITEMWIDTH;
            ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = MEASUREITEMHEIGHT;
            break;

        case WM_DRAWITEM:
            lpCSimpSvrApp->HandleDrawItem((LPDRAWITEMSTRUCT) lParam);
            break;


        default:                   /* Passes it on if unproccessed    */
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\simpsvr\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by SIMPSVR.RC
//
#define IDM_OPEN                        102
#define IDM_SAVE                        103
#define IDM_SAVEAS                      104
#define IDM_PRINT                       105
#define IDM_EXIT                        106
#define IDM_UNDO                        107
#define IDM_CUT                         108
#define IDM_COPY                        109
#define IDM_PASTE                       110
#define ID_EDIT_INSERTOBJECT            111
#define IDM_INSERTOBJECT                111
#define IDM_NEW                         112
#define IDM_RED                         113
#define IDM_GREEN                       114
#define IDM_BLUE                        115
#define IDM_COLOROWNERDR                116

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         117
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\cmdlinew\cbasecmd.cxx ===
//+------------------------------------------------------------------
//
// File:        cbasecmd.cxx
//
// Contents:    implementation for CBaseCmdlineObj
//
// Synoposis:   CBaseCmdlineObj encapsulates a single command line
//              switch, eg. /username:lizch. It specifies the switch
//              string (username) and stores the value (lizch) as
//              a string. This class also provides methods for
//              retrieving the value, displaying it and setting it
//              to a default, and displaying usage for this switch.
//
// Classes:     CBaseCmdlineObj
//
// Functions:
//
// History:     12/27/91    Lizch       Created
//              04/17/92    Lizch       Converted to NLS_STR
//              28 Aug 92   GeordiS     changed nlsNULL to nlsNULLSTR
//              31 Aug 92   GeordiS     changed nlsNULLSTR back.
//              09/09/92    Lizch       Changed SUCCESS and NERR_Success
//                                      to NO_ERROR
//              09/18/92    Lizch       Precompile headers
//              11/14/92    DwightKr    Updates for new version of NLS_STR
//              10/13/93    DeanE       Converted to WCHAR
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


LPCNSTR nszCmdlineBase = _TEXTN("Takes a string ");
LPCNSTR nszLineArgBase = _TEXTN("<string> ");


//+------------------------------------------------------------------
//
// Function:    CBaseCmdlineObj Constructor (1 of 2)
//
// Member:      CBaseCmdlineObj
//
// Synoposis:   Initialises switch string, usage values and whether the
//              switch is mandatory. This constructor gives no default value
//              for this switch.
//
// Arguments:   [nszSwitch]  - the expected switch string
//              [nszUsage]   - the usage statement to display
//              [fMustHave]  - whether the switch is mandatory or not.
//                             if it is, an error will be generated if
//                             the switch is not specified on the
//                             command line. Defaults to FALSE.
//              [nszLineArg] - line arg
//
// Returns:     none, but sets _iLastError
//
// History:     Created 04/17/92 Lizch
//
//-------------------------------------------------------------------
CBaseCmdlineObj::CBaseCmdlineObj(
        LPCNSTR nszSwitch,
        LPCNSTR nszUsage,
        BOOL   fMustHave,
        LPCNSTR nszLineArg)
{
    Init(nszSwitch, nszUsage, fMustHave, _TEXTN(""), nszLineArg);
}


//+------------------------------------------------------------------
//
// Function:    CBaseCmdlineObj Constructor (2 of 2)
//
// Member:      CBaseCmdlineObj
//
// Synoposis:   Initialises switch string, usage strings and default value.
//              This constructor is only used if a switch is optional.
//
// Effects:    Sets fMandatory to FALSE (ie. switch is optional)
//
// Arguments:   [nszSwitch]  - the expected switch string
//              [nszUsage]   - the usage statement to display
//              [nszDefault] - the value to be used if no switch is
//                             specified on the command line.
//              [nszLineArg] - line arg
//
// Returns:     none, but sets _iLastError
//
// History:     Created 04/17/92 Lizch
//
//-------------------------------------------------------------------
CBaseCmdlineObj::CBaseCmdlineObj(
        LPCNSTR nszSwitch,
        LPCNSTR nszUsage,
        LPCNSTR nszDefault,
        LPCNSTR nszLineArg)
{
    Init(nszSwitch, nszUsage, FALSE, nszDefault, nszLineArg);
    _fDefaultSpecified = TRUE;
}


//+------------------------------------------------------------------
//
// Function:    Init
//
// Member:      Private, called from constructors for CBaseCmdlineObj
//
// Synoposis:   Sets defaults for members and allocates memory
//              for switch string.
//
// Arguments:   [nszSwitch]  - the expected command line switch
//              [nszUsage]   - the usage statement for display
//              [fMustHave]  - whether the switch is mandatory or not.
//                             if it is, an error will be generated if
//                             the switch is not specified on the
//                             command line. Defaults to FALse
//              [nszDefault] - the value to be used if no switch is
//                             specified on the command line.
//              [nszLineArg] - line arg.
//
// Returns:     Nothing
//
// Modifies:    Out of memory error, or CMDLINE_NO_ERROR
//
// History:     12/29/91    Lizch   Created.
//              04/17/92    Lizch   Converted to NLS_STR
//              7/14/92     DeanE   Initialized _fFoundSwitch
//              07/31/92    Davey   Added _fSecondArg and _pnlsLineArgType,
//                                  and added nlsLineArg parameter.
//
//-------------------------------------------------------------------
void CBaseCmdlineObj::Init(
        LPCNSTR nszSwitch,
        LPCNSTR nszUsage,
        BOOL   fMustHave,
        LPCNSTR nszDefault,
        LPCNSTR nszLineArg)
{
    SetError(CMDLINE_NO_ERROR);

    // Initialize member variables
    _pValue            = NULL;
    _fMandatory        = fMustHave;
    _fDefaultSpecified = FALSE;
    _fSecondArg        = TRUE;
    _fFoundSwitch      = FALSE;

    SetSeparator(nchDefaultSep);
    SetEquater(nchDefaultEquater);

    // Allocate space and initialize member strings
    _pnszUsageString = new NCHAR[_ncslen(nszUsage)+1];
    if (_pnszUsageString == NULL)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
    }
    else
    {
        _ncscpy(_pnszUsageString, nszUsage);
    }

    _pnszSwitch = new NCHAR[_ncslen(nszSwitch)+1];
    if (_pnszSwitch == NULL)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
    }
    else
    {
        _ncscpy(_pnszSwitch, nszSwitch);
    }

    _pnszDefaultValue = new NCHAR[_ncslen(nszDefault)+1];
    if (NULL == _pnszDefaultValue)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
    }
    else
    {
        _ncscpy(_pnszDefaultValue, nszDefault);
    }

    // if the passed in linearg is NULL then use default one, use
    // NULL to keep arguments consistent in parameter lists.
    //
    if (nszLineArg == NULL)
    {
        _pnszLineArgType = NULL;
    }
    else
    {
        _pnszLineArgType = new NCHAR[_ncslen(nszLineArg)+1];
        if (NULL == _pnszLineArgType)
        {
            SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
        }
        else
        {
            _ncscpy(_pnszLineArgType, nszLineArg);
        }
    }
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj destructor
//
// Synoposis:   Frees any memory associated with the object
//
// History:     12/27/91 Lizch  Created.
//              04/17/92 Lizch  Changed to NLS_STR.
//              08/03/92 Davey  Added delete of _pnlsLineArgType
//
//-------------------------------------------------------------------
CBaseCmdlineObj::~CBaseCmdlineObj()
{
    delete (NCHAR *)_pValue;
    _pValue = NULL;

    delete _pnszUsageString;
    delete _pnszSwitch;
    delete _pnszDefaultValue;
    delete _pnszLineArgType;
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::SetValue, public
//
// Synopsis:    Stores the value specified after the switch string
//              (eg: "lizch" from "/username:lizch").
//
// Arguments:   [nszArg] - the string following the switch on
//                         the command line. Excludes the
//                         equator (eg. ':' in the above example)
//
// Returns:     CMDLINE_NO_ERROR or out of memory
//
// History:     12/27/91 Lizch  Created
//              04/17/92 Lizch  Converted to NLS_STR
//
//-------------------------------------------------------------------
INT CBaseCmdlineObj::SetValue(LPCNSTR nszArg)
{
    INT nRet = CMDLINE_NO_ERROR;

    // delete any existing pValue
    delete (NCHAR *)_pValue;
    _pValue = NULL;

    _pValue = new NCHAR[_ncslen(nszArg)+1];
    if (_pValue == NULL)
    {
        nRet = CMDLINE_ERROR_OUT_OF_MEMORY;
    }
    else
    {
        _ncscpy((NCHAR *)_pValue, nszArg);
    }

    return(nRet);
}



//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::ResetValue, public
//
// Synopsis:    Deletes the value so the object becomes "clean" again.
//              
//
// Returns:     CMDLINE_NO_ERROR or out of memory
//
// History:     06/13/97 MariusB  Created
//
//-------------------------------------------------------------------
void CBaseCmdlineObj::ResetValue()
{
    if (NULL != _pValue)
	{
		delete _pValue;
		_pValue = NULL;
	}
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::SetValueToDefault, public
//
// Synopsis:    Sets the default value for the switch. This value is
//              used if no switch is specified on the command line.
//
// Effects:     This is the base implementation for the virtual
//              method SetValueToDefault. It simply calls SetValue.
//              Derived classes may need to do more complex things,
//              eg, the default may be the name of the Domain Controller,
//
// Arguments:   none
//
// Returns:     CMDLINE_NO_ERROR or out of memory
//
// History:     Created              12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//
//-------------------------------------------------------------------
INT CBaseCmdlineObj::SetValueToDefault()
{
    return(SetValue(_pnszDefaultValue));
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::GetValue, public
//
// Synopsis:    Returns a pointer to the switch value
//
// Arguments:   none
//
// Returns:     a const CHAR pointer to the switch value, not including
//              the equater character
//
// History:     Created          05/27/92 Lizch
//
//-------------------------------------------------------------------
LPCNSTR CBaseCmdlineObj::GetValue()
{
    return((LPCNSTR)_pValue);
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::IsFound, public
//
// Synopsis:    Indicates whether this command line switch was found.
//
// Arguments:   none
//
// Returns:     TRUE if the switch was found, FALSE otherwise
//
// History:     Created          05/27/92 Lizch
//
//-------------------------------------------------------------------
BOOL CBaseCmdlineObj::IsFound()
{
    return(_fFoundSwitch);
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::SetFoundFlag, public
//
// Synopsis:    Sets whether this command line switch was found.
//
// Arguments:   TRUE if switch is found, FALSE otherwise
//
// Returns:     nothing
//
// History:     Created          05/27/92 Lizch
//
//-------------------------------------------------------------------
void CBaseCmdlineObj::SetFoundFlag(BOOL fFound)
{
    _fFoundSwitch = fFound;
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::IsRequired, public
//
// Synopsis:    Indicates whether this command line switch is mandatory.
//
// Arguments:   none
//
// Returns:     TRUE if the switch was manadatory, FALSE otherwise
//
// History:     Created          05/27/92 Lizch
//
//-------------------------------------------------------------------
BOOL CBaseCmdlineObj::IsRequired ()
{
    return(_fMandatory);
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::IsDefaultSpecified, public
//
// Synopsis:    Indicates whether this command line switch has a default
//              value.
//
// Arguments:   none
//
// Returns:     TRUE if the switch has a default, FALSE otherwise
//
// History:     Created          05/27/92 Lizch
//
//-------------------------------------------------------------------
BOOL CBaseCmdlineObj::IsDefaultSpecified ()
{
    return(_fDefaultSpecified);
}


//+------------------------------------------------------------------
//
//  Member:     CBaseCmdlineObj::SetSeparator, public
//
//  Synoposis:  Sets the valid switch separator character, i.e.
//              the '/' in /a:foo
//
//  Arguments:  [nchSeparator] - the new separator character
//
//  Returns:    Previous separator.
//
//  History:    05/23/91 Lizch  Created.
//              08/10/92 Davey  Changed to take only one char., added
//                              return of error code
//
//-------------------------------------------------------------------
NCHAR CBaseCmdlineObj::SetSeparator(NCHAR nchSeparator)
{
    NCHAR nchOld = _nchSeparator;

    _nchSeparator = nchSeparator;

    return(nchOld);
}


//+------------------------------------------------------------------
//
//  Member:     CBaseCmdlineObj::SetEquater, public
//
//  Synoposis:  Sets the set of valid equater characters, i.e.
//              the ':' in /a:foo
//
//  Arguments:  [nchEquater] - the new equater character
//
//  Returns:    Previous equater.
//
//  History:    05/23/91 Lizch  Created.
//              08/10/92 Davey  Changed to take only one char., added
//                              return of error code
//
//-------------------------------------------------------------------
NCHAR CBaseCmdlineObj::SetEquater(NCHAR nchEquater)
{
    NCHAR nchOld = _nchEquater;

    _nchEquater = nchEquater;

    return(nchOld);
}


//+------------------------------------------------------------------
//
//  Member:     CBaseCmdlineObj::GetSeparator, public
//
//  Synoposis:  Returns the separator character for this object.
//
//  Arguments:  None
//
//  Returns:    Current separator character.
//
//  History:    10/17/93    DeanE   Created
//
//-------------------------------------------------------------------
NCHAR CBaseCmdlineObj::GetSeparator()
{
    return(_nchSeparator);
}


//+------------------------------------------------------------------
//
//  Member:     CBaseCmdlineObj::GetEquater, public
//
//  Synoposis:  Returns the equater character for this object.
//
//  Arguments:  None
//
//  Returns:    Current equater character.
//
//  History:    10/17/93    DeanE   Created
//
//-------------------------------------------------------------------
NCHAR CBaseCmdlineObj::GetEquater()
{
    return(_nchEquater);
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::QuerySwitchString, public
//
// Synopsis:    Returns a pointer to the switch string, eg. the "mc" in
//              /mc:foo
//
// Arguments:   none
//
// Returns:     a const NCHAR pointer to the switch string
//
// History:     Created          05/27/92 Lizch
//
//-------------------------------------------------------------------
LPCNSTR CBaseCmdlineObj::QuerySwitchString()
{
    return(_pnszSwitch);
}


//+------------------------------------------------------------------
//
// Member:      CBaseCmdlineObj::DisplayValue, public
//
// Synoposis:   Prints the stored command line value according to
//              current display method.  Generally this will be to stdout.
//
// History:     Created          12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//
//-------------------------------------------------------------------
void CBaseCmdlineObj::DisplayValue()
{
    if (_pValue != NULL)
    {
        _sNprintf(_nszErrorBuf,
                 _TEXTN("Command line switch %s has value %s\n"),
                 _pnszSwitch,
                 (NCHAR *)_pValue);
        (*_pfnDisplay)(_nszErrorBuf);
    }
    else
    {
        DisplayNoValue();
    }
}


//+------------------------------------------------------------------
//
//  Member:     CBaseCmdlineObj::DisplayNoValue, protected
//
//  Synoposis:  Displays a "no value set" message.
//
//  History:    Created          05/14/92 Lizch
//
//-------------------------------------------------------------------
void CBaseCmdlineObj::DisplayNoValue()
{
      _sNprintf(_nszErrorBuf,
               _TEXTN("No value for command line switch %s\n"),
               _pnszSwitch);
      (*_pfnDisplay)(_nszErrorBuf);
}


//+------------------------------------------------------------------
//
//  Member:     CBaseCmdlineObj::DisplaySpecialUsage, protected
//
//  Synoposis:  Outputs special usage - for base class there is none.
//
//  History:    Created          05/14/92 Lizch
//
//-------------------------------------------------------------------
INT CBaseCmdlineObj::DisplaySpecialUsage(
        USHORT  usDisplayWidth,
        USHORT  usIndent,
        USHORT *pusWidth)
{
    return(CMDLINE_NO_ERROR);
}


//+-------------------------------------------------------------------
//
//  Method:     CBaseCmdLineObj::QueryCmdlineType, protected, const
//
//  Synoposis:  returns a character pointer to the cmdline type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR * reference to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CBaseCmdlineObj::QueryCmdlineType() const
{
    return(nszCmdlineBase);
}

//+-------------------------------------------------------------------
//
//  Method:     CBaseCmdLineObj::QueryLineArgType, protected, const
//
//  Synoposis:  returns a character pointer to the line arg type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR *reference to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CBaseCmdlineObj::QueryLineArgType() const
{
    // if user has not defined one then give default one
    if (_pnszLineArgType == NULL)
    {
        return(nszLineArgBase);
    }
    else
    {
        return(_pnszLineArgType);
    }
}


//+-------------------------------------------------------------------
//
//  Method:     CBaseCmdLineObj::DisplayUsageLine, protected
//
//  Synopsis:   Displays line usage information
//
//  Arguments:  [pusWidth]       - How much space is left on line to display
//                                 the usage.
//              [usDisplayWidth] - Max width allowed to display usage
//              [usIndent]       - Amount to indent for next line of usage
//
//  History:    28-Jul-92  davey    Created.
//
//  Notes:      Looks like:
//
//              test2 /mc:<worker> [/ml:<log_server>] [/mt:<test>]
//              [/mn:<tester-email>] [/mp:<path>] [/mo:<obj_name>]
//              [/md:<dispatcher>] [/?]
//
//--------------------------------------------------------------------
INT CBaseCmdlineObj::DisplayUsageLine(
        USHORT *pusWidth,
        USHORT  usDisplayWidth,
        USHORT  usIndent)
{
    INT    nRet            = CMDLINE_NO_ERROR;
    LPNSTR  pnszLine        = NULL;
    ULONG  cchLine;
    LPCNSTR nszLeftBracket  = _TEXTN("[");
    LPCNSTR nszRightBracket = _TEXTN("]");
    LPCNSTR nszType         = QueryLineArgType();
    NCHAR  nszSeparator[2];
    NCHAR  nszEquater[2];

    // Initialize separator and equater strings
    nszSeparator[0] = _nchSeparator;
    nszSeparator[1] = nchClNull;

    nszEquater[0] = _nchEquater;
    nszEquater[1] = nchClNull;

    // Determine length of the display line - Add one for terminating NULL
    cchLine = 1 + _ncslen(nszSeparator) + _ncslen(_pnszSwitch);

    if (FALSE == _fMandatory)
    {
        cchLine += _ncslen(nszLeftBracket) + _ncslen(nszRightBracket);
    }

    if (TRUE == _fSecondArg)
    {
        cchLine += _ncslen(nszEquater) + _ncslen(nszType);
    }

    // Build the display line
    pnszLine = new NCHAR[cchLine];
    if (NULL == pnszLine)
    {
        return(CMDLINE_ERROR_OUT_OF_MEMORY);
    }

    *pnszLine = nchClNull;
    if (FALSE == _fMandatory)
    {
        _ncscat(pnszLine, nszLeftBracket);
    }

    _ncscat(pnszLine, nszSeparator);
    _ncscat(pnszLine, _pnszSwitch);

    if (TRUE == _fSecondArg)
    {
        _ncscat(pnszLine, nszEquater);
        _ncscat(pnszLine, nszType);
    }

    if (FALSE == _fMandatory)
    {
        _ncscat(pnszLine, nszRightBracket);
    }

    nRet = DisplayWord(pnszLine, usDisplayWidth, usIndent, pusWidth);

    // Clean up and exit
    delete pnszLine;

    return(nRet);
}


//+-------------------------------------------------------------------
//
//  Method:     CBaseCmdLineObj::DisplayUsageDescr, protected
//
//  Synopsis:   Displays switch descriptions information
//
//  Arguments:  [usSwitchIndent] - Amount to indent for switches
//              [usDisplayWidth] - Max width allowed to display usage
//              [usUsageIndent]  - Amount to indent for next line of usage
//
//  History:    28-Jul-92  davey    Created.
//
//  Notes:      looks like.
//
//  /mc         Takes a list of strings specifying worker names.
//              These workers should have full names.
//              Don't you think so?
//              The strings in the list are separated by one of the following
//              character(s): ",; ".
//  /ml         Takes a string specifying log server name.
//  /mt         Takes a string specifying name of the test.
//  /mn         Takes a string specifying email name of the tester.
//  /mp         Takes a string specifying path name to log to.
//  /mo         Takes a string specifying name of the object.
//  /md         Takes a string specifying name of the dispatcher to use.
//  /?          Flag specifying command line usage. It defaults to FALSE.
//
//  Here's how the various indent values relate to each other:
//
//  <-------------------------usDisplayWidth------------------------->
//  <--usSwitchIndent-->/foo
//  <--------usUsageIndent----->Takes a list...
//
//--------------------------------------------------------------------
INT CBaseCmdlineObj::DisplayUsageDescr(
        USHORT usSwitchIndent,
        USHORT usDisplayWidth,
        USHORT usUsageIndent)
{
    INT    iRC;
    LPNSTR  pnszSwitch;
    LPNSTR  pnszUsage;
    LPNSTR  pnszDefault      = NULL;
    USHORT cchUsage;
    USHORT cchSwitch;
    USHORT cchPaddedSwitch;
    USHORT usLineSpaceLeft;
    LPCNSTR nszSpecify       = _TEXTN("specifying ");
    LPCNSTR nszDefault       = _TEXTN("It defaults to ");
    LPCNSTR nszType          = QueryCmdlineType();
    NCHAR  nszSeparator[2];

    // Initialize separator string
    nszSeparator[0] = _nchSeparator;
    nszSeparator[1] = nchClNull;

    // Calculate size of switch buffer - if this length is less than
    // usUsageIndent then allocate extra room to pad spaces out to
    // usUsageIndent and the usage will start on the same line; else
    // the usage will start on the next line with an indent.  Also,
    // the null-terminator is NOT accounted for in this value.
    //
    cchSwitch = (USHORT) (usSwitchIndent + _ncslen(nszSeparator) 
                               + _ncslen(_pnszSwitch) ) ;
    if (cchSwitch < usUsageIndent)
    {
        cchPaddedSwitch = usUsageIndent;
    }
    else
    {
        cchPaddedSwitch = (USHORT) (cchSwitch + usUsageIndent 
                                    + _ncslen(nszClNewLine) );
    }

    // Calculate size of usage buffer - null-terminator NOT accounted for
    //
    cchUsage = (USHORT) (_ncslen(nszType) +
                         _ncslen(nszSpecify) +
                         _ncslen(_pnszUsageString) );


    // Allocate buffers - add 1 for NULL-terminators
    pnszSwitch = new NCHAR[cchPaddedSwitch+1];
    pnszUsage  = new NCHAR[cchUsage+1];
    if (pnszSwitch == NULL || pnszUsage == NULL)
    {
        delete pnszSwitch;
        delete pnszUsage;
        return(CMDLINE_ERROR_OUT_OF_MEMORY);
    }

    // Initialize switch buffer - fill with usSwitchIndent spaces, then
    // append the separator and switch, then pad with spaces out to
    // usUsageIndent if necessary
    //
    for (USHORT i=0; i<usSwitchIndent; i++)
    {
        pnszSwitch[i] = nchClSpace;
    }

    pnszSwitch[usSwitchIndent] = nchClNull;
    _ncscat(pnszSwitch, nszSeparator);
    _ncscat(pnszSwitch, _pnszSwitch);

    if ((USHORT)_ncslen(pnszSwitch) >= usUsageIndent)
    {
        // Pad a new line.
        _ncscat(pnszSwitch, nszClNewLine);
    }
    // Pad spaces until usUsageIndemt
    for (i = (USHORT) _ncslen(pnszSwitch); i < cchPaddedSwitch; i++)
    {
        pnszSwitch[i] = nchClSpace;
    }
    pnszSwitch[cchPaddedSwitch] = nchClNull;

    // Initialize usage buffer
    _ncscpy(pnszUsage, nszType);
    _ncscat(pnszUsage, nszSpecify);
    _ncscat(pnszUsage, _pnszUsageString);

    // Now we're ready to output the strings - output the switch, then
    // set up the values needed to output the usage line.
    //
    (*_pfnDisplay)(pnszSwitch);
    usLineSpaceLeft = (USHORT) (usDisplayWidth - usUsageIndent);

    // Output the usage
    iRC = DisplayStringByWords(
                 pnszUsage,
                 usDisplayWidth,
                 usUsageIndent,
                 &usLineSpaceLeft);
    if (iRC != CMDLINE_NO_ERROR)
    {
        delete pnszSwitch;
        delete pnszUsage;
        return(iRC);
    }


    // output the special usage
    //
    iRC = DisplaySpecialUsage(usDisplayWidth, usUsageIndent, &usLineSpaceLeft);
    if (iRC != CMDLINE_NO_ERROR)
    {
        delete pnszSwitch;
        delete pnszUsage;
        return(iRC);
    }


    // output the default value string
    //
    if (_fDefaultSpecified)
    {
        // Default string is "  " + nszDefault + _pnszDefaultValue + "."
        pnszDefault = new NCHAR[_ncslen(_pnszDefaultValue) +
                                            _ncslen(nszDefault) + 4];
        if (pnszDefault == NULL)
        {
            iRC = CMDLINE_ERROR_OUT_OF_MEMORY;
        }
        else
        {
            _ncscpy(pnszDefault, _TEXTN("  "));
            _ncscat(pnszDefault, nszDefault);
            _ncscat(pnszDefault, _pnszDefaultValue);
            _ncscat(pnszDefault, _TEXTN("."));

            iRC = DisplayStringByWords(
                         pnszDefault,
                         usDisplayWidth,
                         usUsageIndent,
                         &usLineSpaceLeft);
        }

        if (iRC != CMDLINE_NO_ERROR)
        {
            delete pnszDefault;
            delete pnszSwitch;
            delete pnszUsage;
            return(iRC);
        }
    }


    // Next thing output should go on a new line
    //
    (*_pfnDisplay)(nszClNewLine);

    delete pnszSwitch;
    delete pnszUsage;
    delete pnszDefault;

    return(iRC);
}


//+-------------------------------------------------------------------
//
//  Method:     CBaseCmdLineObj::DisplayStringByWords, protected
//
//  Synopsis:   Writes out the strings word by word following indentation
//              and display width rules; words are delimeted by spaces.
//              The string begins on the current line at the current
//              location (usDisplayWidth-*pusSpaceLeft), including
//              any leading space characters.
//
//  Arguments:  [nszString]      - String to output.
//              [usDisplayWidth] - Max width allowed to display usage
//              [usIndent]       - Amount to indent for next line of usage
//              [pusSpaceLeft]   - Space left on this line
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
INT CBaseCmdlineObj::DisplayStringByWords(
        LPCNSTR  nszString,
        USHORT  usDisplayWidth,
        USHORT  usIndent,
        USHORT *pusSpaceLeft)
{
    INT    iRC      = CMDLINE_NO_ERROR;
    BOOL   fDone    = FALSE;
    LPNSTR  pnszWord = NULL;
    LPCNSTR pnchWord = nszString;
    LPCNSTR pnchTrav = nszString;
    USHORT i;

    // Skip leading spaces, but they are part of the first word
    while (nchClSpace == *pnchTrav)
    {
        pnchTrav++;
    }

    // Traverse the string until we get to the end
    while (!fDone)
    {
        // Traverse until we find a space, newline, or null
        switch(*pnchTrav)
        {
            case L' ':
                // Retrieve the word from the string
                iRC = CopyWord(pnchWord, pnchTrav-pnchWord, &pnszWord);
                if (iRC == CMDLINE_NO_ERROR)
                {
                    // Output the word
                    iRC = DisplayWord(
                                 pnszWord,
                                 usDisplayWidth,
                                 usIndent,
                                 pusSpaceLeft);
                }
                delete pnszWord;

                //Set up the next word
                pnchWord = pnchTrav++;

                // traverse to next non-space character
                while (nchClSpace == *pnchTrav)
                {
                    pnchTrav++;
                }
                break;

            case L'\n':
                // Retrieve the word from the string, including the newline
                iRC = CopyWord(pnchWord, ++pnchTrav-pnchWord, &pnszWord);
                if (iRC == CMDLINE_NO_ERROR)
                {
                    // Output the word
                    iRC = DisplayWord(
                                 pnszWord,
                                 usDisplayWidth,
                                 usIndent,
                                 pusSpaceLeft);
                }
                delete pnszWord;

                // Output usIndent spaces
                for (i=0; i<usIndent; i++)
                {
                    (*_pfnDisplay)(nszClSpace);
                }
                *pusSpaceLeft = (USHORT) (usDisplayWidth - usIndent);

                // traverse to next non-space character
                while (nchClSpace == *pnchTrav)
                {
                    pnchTrav++;
                }

                // Set up the next word - note leading blanks are skipped
                // so the word will be aligned with the indent
                //
                pnchWord = pnchTrav;
                break;

            case L'\0':
                // Output the current word
                iRC = DisplayWord(
                             pnchWord,
                             usDisplayWidth,
                             usIndent,
                             pusSpaceLeft);
                fDone = TRUE;
                break;

            default:
                // Skip to next character
                pnchTrav++;
                break;
        }

        if (iRC != CMDLINE_NO_ERROR)
        {
            fDone = TRUE;
        }
    }

    return(iRC);
}


//+-------------------------------------------------------------------
//
//  Method:     CBaseCmdLineObj::CopyWord, protected
//
//  Synopsis:   Copies cchWord characters starting at pnchWord into a
//              null-terminated string buffer (which the caller must
//              delete).
//
//  Arguments:  [pnchWord]  - place to copy from.
//              [cchWord]   - number of characters to copy.
//              [ppnszWord] - buffer returned to caller.
//
//  History:    15-Oct-93  DeanE    Created.
//
//--------------------------------------------------------------------
INT CBaseCmdlineObj::CopyWord(
        LPCNSTR pnchWord,
        ULONG  cchWord,
        LPNSTR *ppnszWord)
{
    INT iRC = CMDLINE_NO_ERROR;

    *ppnszWord = new NCHAR[cchWord+1];
    if (NULL == *ppnszWord)
    {
        iRC = CMDLINE_ERROR_OUT_OF_MEMORY;
    }
    else
    {
        _ncsncpy(*ppnszWord, pnchWord, cchWord);
        *(*ppnszWord + cchWord) = nchClNull;
    }

    return(iRC);
}


//+-------------------------------------------------------------------
//
//  Method:     CBaseCmdLineObj::DisplayWord, protected
//
//  Synopsis:   Writes out the given word according to the display
//              parameters.
//
//  Arguments:  [nszWord]        - word to output.
//              [usDisplayWidth] - Max width allowed to display usage.
//              [usIndent]       - Amount to indent for next line of usage.
//              [pusWidth]       - Space left on this line.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
INT CBaseCmdlineObj::DisplayWord(
        LPCNSTR  nszWord,
        USHORT  usDisplayWidth,
        USHORT  usIndent,
        USHORT *pusWidth)
{
    INT    nRet   = CMDLINE_NO_ERROR;
    LPCNSTR nszTmp = nszWord;
    LPNSTR  pnszBuf;
    USHORT cchWord;
    USHORT cchBuf;
    USHORT cchLine = (USHORT) (usDisplayWidth - usIndent);
    BOOL   fDone   = FALSE;

    // Add one for leading space
    cchWord = (USHORT) _ncslen(nszWord);

    // if there is enough room left on the current line, output word
    //
    if (cchWord <= *pusWidth)
    {
        (*_pfnDisplay)(nszWord);

        // update the remaining width
        *pusWidth = (USHORT) (*pusWidth - cchWord);
    }
    else
    {
        // Spit the word out on the next line, traversing more than
        // one line if necessary
        do
        {
            // Calculate how much of the word can be output
            if (_ncslen(nszTmp) <= cchLine)
            {
                cchBuf = (USHORT) _ncslen(nszTmp);
                fDone  = TRUE;
            }
            else
            {
                cchBuf = cchLine;
            }

            pnszBuf = new NCHAR[cchBuf+1];
            if (NULL == pnszBuf)
            {
                fDone = TRUE;
                nRet  = CMDLINE_ERROR_OUT_OF_MEMORY;
            }
            else
            {
                _ncsncpy(pnszBuf, nszTmp, cchBuf);
                *(pnszBuf+cchBuf) = L'\0';
            }
            nszTmp += cchBuf;

            // Output newline
            (*_pfnDisplay)(nszClNewLine);

            // Indent usIndent spaces
            for (USHORT i=0; i<usIndent; i++)
            {
                (*_pfnDisplay)(nszClSpace);
            }

            // Output buffer
            (*_pfnDisplay)(pnszBuf);

            delete pnszBuf;
        } while (!fDone);

        // Calculate remaining width on the current line
        *pusWidth = (USHORT) (usDisplayWidth - usIndent - cchBuf);
    }

    return(nRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\cmdlinew\cboolcmd.cxx ===
//+------------------------------------------------------------------
//
// File:        cboolcmd.cxx
//
// Contents:    implementation for CBoolCmdlineObj
//
// Synoposis:   Encapsulates a command line switch which takes a
//              Bool value. If the command line switch is present, the
//              value is set to TRUE, otherwise it is set to FALSE
//
// Classes:     CBoolCmdlineObj
//
// Functions:
//              AsciiToBool                       private, local
//              CBoolCmdlineObj::~CBoolCmdlineObj public
//              CBoolCmdlineObj::DisplayValue     public
//              CBoolCmdlineObj::GetValue         public
//              CBoolCmdlineObj::SetValue         public
//
// History:     06/15/92  DeanE    Created
//              07/29/92  davey    Added nlsType and nlsLineArgType
//              09/09/92  Lizch    Changed SUCCESS to NO_ERROR
//              09/18/92  Lizch    Precompile headers
//              11/14/92  DwightKr Updates for new version of NLS_STR
//              10/14/93  DeanE    Converted to WCHAR
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


INT StringToBool(LPCNSTR nszBool, BOOL *pBool);

LPCNSTR nszCmdlineBool = _TEXTN("Flag ");
LPCNSTR nszLineArgBool = _TEXTN("[TRUE|FALSE] ");

NCHAR nchBoolEquater = _TEXTN(':');

// BUGBUG - base Equater needs to be a string, then the equator for
//   a bool is L'<base equator><space>';
//

//+------------------------------------------------------------------
//
//  Function:   CBoolCmdlineObj Constructor
//
//  Member:     CBoolCmdlineObj
//
//  Synoposis:  Initialises switch string, usage strings and default value.
//
//  Effects:    Sets fSecondArg to FALSE, so that knows there is
//              no argument following switch.
//
//  Arguments:  [nszSwitch]  - the expected switch string
//              [nszUsage]   - the usage statement to display
//              [nszDefault] - the value to be used if no switch is
//                            specified on the command line.  Defaults
//                            to FALSE if not specified.
//
//  Returns:    none, but sets _iLastError
//
//  History:    Created               12/27/91 Lizch
//              Converted to NLS_STR  04/17/92 Lizch
//
//-------------------------------------------------------------------
CBoolCmdlineObj::CBoolCmdlineObj(
        LPCNSTR nszSwitch,
        LPCNSTR nszUsage,
        LPCNSTR nszDefault) :
        CBaseCmdlineObj(nszSwitch, nszUsage, nszDefault)
{
    _fSecondArg = TRUE;
    SetEquater(nchBoolEquater);
}


//+------------------------------------------------------------------
//
//  Member:     CBoolCmdlineObj::SetValue, public
//
//  Synposis:   Sets _pValue to point to the proper value of the switch
//
//  Arguments:  [nszString] - the string following the switch on the
//                            command line. Includes the equator (eg. ':'
//                            or '=' ), if any. It is ignored for this
//                            command line type.
//
//  Returns:    CMDLINE_NO_ERROR, CMDLINE_ERROR_OUT_OF_MEMORY
//
//  History:    Created   6/15/92  DeanE  Stolen from Security implementation
//
//-------------------------------------------------------------------
INT CBoolCmdlineObj::SetValue(LPCNSTR nszString)
{
    INT nRet = CMDLINE_NO_ERROR;

    // Delete old value if it exists
    delete (BOOL *)_pValue;
    _pValue = NULL;

    // Allocate space for a new value and initialize it
    _pValue = new BOOL;
    if (_pValue == NULL)
    {
        nRet = CMDLINE_ERROR_OUT_OF_MEMORY;
    }
    else
    {
        nRet = StringToBool(nszString, (BOOL *)_pValue);
        if (nRet != CMDLINE_NO_ERROR)
        {
            delete (BOOL *)_pValue;
            _pValue = NULL;
        }
    }

    return(nRet);
}


//+------------------------------------------------------------------
//
// Member:      CBoolCmdlineObj::GetValue, public
//
// Synposis:    Returns pointer to BOOL that has the value.
//
// Arguments:   void
//
// Returns:     BOOL *
//
// History:     Created   6/15/92  DeanE  Stolen from Security implementation
//
//-------------------------------------------------------------------
const BOOL *CBoolCmdlineObj::GetValue()
{
    return((BOOL *)_pValue);
}


//+------------------------------------------------------------------
//
// Member:      CBoolCmdlineObj::DisplayValue, public
//
// Synoposis:   prints the stored command line value according to
//              current display method.  This will generally be to stdout.
//
// History:     6/15/92  DeanE  Stolen from Security implementation
//              7/31/92  davey  Modified to match other cmdline objs.
//
//-------------------------------------------------------------------
void CBoolCmdlineObj::DisplayValue()
{
    if (_pValue != NULL)
    {
        if (*(BOOL *)_pValue == TRUE)
        {
            _sNprintf(_nszErrorBuf,
                     _TEXTN("Command line switch %s is Set\n"),
                     _pnszSwitch);
        }
        else
        {
            _sNprintf(_nszErrorBuf,
                     _TEXTN("Command line switch %s is Not Set\n"),
                     _pnszSwitch);
        }
    }
    else
    {
            _sNprintf(_nszErrorBuf,
                     _TEXTN("Command line switch %s has no value\n"),
                     _pnszSwitch);
    }

    (*_pfnDisplay)(_nszErrorBuf);
}


//+------------------------------------------------------------------
//
// Member:      CBoolCmdlineObj::~CBoolCmdlineObj, public
//
// Synoposis:   Cleans up CBoolCmdlineObj objects.
//
// History:     Created  6/15/92  DeanE  Stolen from Security implementation
//
//-------------------------------------------------------------------
CBoolCmdlineObj::~CBoolCmdlineObj()
{
    delete (BOOL *)_pValue;
    _pValue = (BOOL *)NULL;
}


//+------------------------------------------------------------------
//
// Function:    StringToBool
//
// Synoposis:   Converts ascii string to the equivalent Boolean value,
//              TRUE for "true", FALSE for "false", or TRUE for a null
//              string or string starting with a space.
//
// Arguments:   [nszBool] - string to convert
//              [pBool]   - pointer to converted boolean
//
// Returns:     CMDLINE_NO_ERROR, CMDLINE_ERROR_INVALID_VALUE
//
// History:     Created                     12/17/91 Lizch
//              Implemented as AsciiToBool  6/15/92  DeanE
//              Renamed StringToBool        10/13/93 DeanE
//
//-------------------------------------------------------------------
INT StringToBool(LPCNSTR nszBool, BOOL *pBool)
{
    INT iRC = CMDLINE_NO_ERROR;

    // If the string given to us is a null string or begins with a space,
    // the function was called from the parser and the command line arg
    // was given (with no value).  We want the value to be TRUE, however.
    //
    if ((nchClNull == *nszBool) || (nchClSpace == *nszBool))
    {
        *pBool = TRUE;
    }
    else
    // Otherwise we set the boolean to a value explicitly based on
    // the string passed, either 'true' or 'false', case insensitive
    //
    if (0 == _ncsicmp(nszBool, nszBoolTrue) ||
        0 == _ncsicmp(nszBool, nszBoolOne))
    {
        *pBool = TRUE;
    }
    else
    if (0 == _ncsicmp(nszBool, nszBoolFalse) ||
        0 == _ncsicmp(nszBool, nszBoolZero))
    {
        *pBool = FALSE;
    }
    else
    {
        iRC = CMDLINE_ERROR_INVALID_VALUE;
    }

    return(iRC);
}


//+-------------------------------------------------------------------
//
//  Method:     CBoolCmdlineObj::QueryCmdlineType, protected, const
//
//  Synoposis:  returns a character pointer to the  cmdline type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CBoolCmdlineObj::QueryCmdlineType() const
{
    return(nszCmdlineBool);
}


//+-------------------------------------------------------------------
//
//  Method:     CBoolCmdlineObj::QueryLineArgType, protected, const
//
//  Synoposis:  returns a character pointer to the line arg type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CBoolCmdlineObj::QueryLineArgType() const
{
    LPCNSTR nszRet;

    // if user has not defined one then give default one
    if (NULL == _pnszLineArgType)
    {
        nszRet = nszLineArgBool;
    }
    else
    {
        nszRet = _pnszLineArgType;
    }

    return(nszRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\cmdlinew\cintcmd.cxx ===
//+------------------------------------------------------------------
//
//  File:       cintcmd.cxx
//
//  Contents:   implementation for CIntCmdlineObj
//
//  Synoposis:  Encapsulates a command line switch which takes an
//              integer value, eg: /maxusers:10
//
//  Classes:    CIntCmdlineObj
//
//  Functions:
//
//  History:    12/27/91 Lizch      Created
//              04/17/92 Lizch      Converted to NLS_STR
//              07/29/92 davey      Added nlsType and nlsLineArgType
//              09/09/92 Lizch      Changed SUCCESS to NO_ERROR
//              09/18/92 Lizch      Precompile headers
//              11/14/92 DwightKr   Updates for new version of NLS_STR
//              10/14/93 DeanE      Converted to WCHAR
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


INT StringToInt (LPCNSTR nszInt, INT *pInt);


LPCNSTR nszCmdlineInt = _TEXTN("Takes an integer ");
LPCNSTR nszLineArgInt = _TEXTN("<int> ");


//+------------------------------------------------------------------
//
//  Member:     CIntCmdlineObj destructor
//
//  Synoposis:  Frees any memory associated with the object
//
//  History:    Added to allow casting of pValue 05/12/92 Lizch
//
//-------------------------------------------------------------------
CIntCmdlineObj::~CIntCmdlineObj()
{
    delete (INT *)_pValue;
    _pValue = NULL;
}


//+------------------------------------------------------------------
//
//  Member:     CIntCmdlineObj::SetValue, public
//
//  Synposis:   Stores the integer value specified after the switch
//              string, eg. 10 for /maxusers:10
//
//  Effects:    This implementation for the virtual method SetValue
//              converts the characters following the switch to an integer.
//              It allocates memory for the integer.  If there is no
//              equator character, or if there is no character following
//              the equator character, _pValue remains NULL.
//
//  Arguments:   [nszArg] -  the string following the switch on the
//                           command line. Includes the equator (eg.
//                           ':' or '=' ), if any.
//
//  Requires:
//
//  Returns:    CMDLINE_NO_ERROR, CMDLINE_ERROR_OUT_OF_MEMORY,
//              CMDLINE_ERROR_TOO_BIG, CMDLINE_ERROR_INVALID_VALUE
//
//  History:    Created              12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//
//-------------------------------------------------------------------
INT CIntCmdlineObj::SetValue(LPCNSTR nszArg)
{
    INT nRet;

    // delete any existing _pValue
    delete (INT *)_pValue;
    _pValue = NULL;

    _pValue = new INT;
    if (_pValue == NULL)
    {
        nRet = CMDLINE_ERROR_OUT_OF_MEMORY;
    }
    else
    {
        // I'm using this rather than c runtime atoi so that I
        // can detect error conditions like overflow and non-digits.
        //
        nRet = StringToInt(nszArg, (INT *)_pValue);
        if (nRet != CMDLINE_NO_ERROR)
        {
            delete (INT *)_pValue;
            _pValue = NULL;
        }
    }

    return(nRet);
}


//+------------------------------------------------------------------
//
//  Member:     CIntCmdlineObj::GetValue, public
//
//  Synopsis:   Returns a pointer to the switch value
//
//  Arguments:  none
//
//  Returns:    a integer pointer to the switch value, not including
//              the equater character
//
//  History:    Created          05/27/92 Lizch
//
//-------------------------------------------------------------------
const int * CIntCmdlineObj::GetValue()
{
    return((int *)_pValue);
}


//+------------------------------------------------------------------
//
//  Member:     CIntCmdlineObj::DisplayValue, public
//
//  Synoposis:  Prints the stored command line value according to
//              current display method.  This will generally be to stdout.
//
//  History:    Created              12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//
//-------------------------------------------------------------------
void CIntCmdlineObj::DisplayValue()
{
    if (_pValue != NULL)
    {
        _sNprintf(_nszErrorBuf,
                 _TEXTN("Command line switch %s has value %d\n"),
                 _pnszSwitch,
                 *(int *)_pValue);
        (*_pfnDisplay)(_nszErrorBuf);
    }
    else
    {
        DisplayNoValue();
    }
}


//+------------------------------------------------------------------
//
//  Function:   StringToInt
//
//  Synoposis:  Converts ascii string to integer, checking for overflow,
//              and illegal characters. Only +, - and digits are accepted
//
//  Arguments:  [nszInt] - ascii string to convert
//              [pInt]   - pointer to converted integer
//
//  Returns:    CMDLINE_NO_ERROR, CMDLINE_ERROR_INVALID_VALUE,
//              CMDLINE_ERROR_TOO_BIG
//
//  History:    Created 12/17/91 Lizch
//
//  Notes:      I'm using this rather than c runtime atoi so that I
//              can detect error conditions like overflow and non-digits.
//
//-------------------------------------------------------------------
INT StringToInt(LPCNSTR nszInt, INT *pInt)
{
    short sNegator = 1;
    INT   iResult  = 0;
    INT   iRC      = CMDLINE_NO_ERROR;

    // Skip any leading spaces - these can occur if the command line
    // switch incorporates spaces, eg "/a:   123"
    while (_isnspace(*nszInt))
    {
        nszInt++;
    }

    switch (*nszInt)
    {
    case L'-':
        sNegator = -1;
        nszInt++;
        break;

    case L'+':
        sNegator = 1;
        nszInt++;
        break;

    default:
        break;
    }

    for (;*nszInt != nchClNull; nszInt++)
    {
        if (!_isndigit(*nszInt))
        {
            iResult = 0;
            iRC = CMDLINE_ERROR_INVALID_VALUE;
            break;
        }

        iResult = (iResult * 10) + (*nszInt - '0');

        // Since iResult doesn't get it's sign added until later,
        // I can test for overflow by checking if it goes negative
        if (iResult < 0)
        {
            iResult = 0;
            iRC = CMDLINE_ERROR_TOO_BIG;
            break;
        }
    }

    *pInt = ((int)(iResult * sNegator));

    return(iRC);
}


//+-------------------------------------------------------------------
//
//  Method:     CIntCmdlineObj::QueryCmdlineType, protected, const
//
//  Synoposis:  returns a character pointer to the  cmdline type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CIntCmdlineObj::QueryCmdlineType() const
{
   return(nszCmdlineInt);
}


//+-------------------------------------------------------------------
//
//  Method:     CIntCmdlineObj::QueryLineArgType, protected, const
//
//  Synoposis:  returns a character pointer to the line arg type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CIntCmdlineObj::QueryLineArgType() const
{
    // if user has not defined one then give default one
    if (_pnszLineArgType == NULL)
    {
        return(nszLineArgInt);
    }
    else
    {
        return(_pnszLineArgType);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\cmdlinew\cbaseall.cxx ===
//+------------------------------------------------------------------
//
// File:        cbaseall.cxx
//
// Contents:    implementation for base class for all command line
//              classes, both the individual command line object
//              classes and the overall parsing class
//
// Synoposis:   This base class contains the print function pointer
//              the default print implementation and the constructor
//              error value.
//
// Classes:     CBaseCmdline
//
// Functions:
//
// History:     12/27/91 Lizch Created
//              04/17/92 Lizch Converted to NLS_STR
//              09/09/92 Lizch Changed SUCCESS to NO_ERROR
//              09/18/92 Lizch Precompile headers
//              10/13/93 DeanE Converted to WCHAR
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


void DefaultDisplayMethod(LPCNSTR nszMessage);
void (* CBaseCmdline::_pfnDisplay)(LPCNSTR nszMessage) = DefaultDisplayMethod;

NCHAR CBaseCmdline::_nszErrorBuf[];

//+------------------------------------------------------------------
//
// Function:   CBaseCmdline Constructor
//
// Member:     CBaseCmdline
//
// Synoposis:  Initialises error string and print function pointer
//
// History:    Created 05/17/92 Lizch
//
//-------------------------------------------------------------------
CBaseCmdline::CBaseCmdline()
{
    _pfnDisplay = DefaultDisplayMethod;
    _iLastError = CMDLINE_NO_ERROR;
}


//+------------------------------------------------------------------
//
// Function:    CBaseCmdline::SetDisplayMethod, public
//
// Member:      CBaseCmdline
//
// Synoposis:   Sets the print function pointer to the passed value. This
//              enables client programs to replace the default printf
//              print method with their own (eg. wprintf).
//
// Arguments:   [pfnNewDisplayMethod] - Function pointer that replaces
//                                      current display function.
//
// Returns:     none
//
// History:     Created 05/17/92 Lizch
//
//-------------------------------------------------------------------
void CBaseCmdline::SetDisplayMethod(
        void (* pfnNewDisplayMethod)(LPCNSTR nszMessage))
{
    _pfnDisplay = pfnNewDisplayMethod;
}


//+------------------------------------------------------------------
//
// Function:    DefaultDisplayMethod
//
// Synoposis:   Used to wrap the printf function to get around problems
//              equating a function pointer expecting a char * to the
//              printf function expecting (char *,...)
//
// Arguments:   [nszMessage] - Message to display.
//
// Returns:     none
//
// History:     Created 05/17/92 Lizch
//
//-------------------------------------------------------------------
void DefaultDisplayMethod(LPCNSTR nszMessage)
{
    _nprintf(_TEXTN("%s"), nszMessage);
}


//+------------------------------------------------------------------
//
// Function:    CBaseCmdline::QueryError, public
//
// Member:      CBaseCmdline
//
// Synoposis:   Returns the internal error indicator and resets it
//              to CMDLINE_NO_ERROR.
//
// Effects:     sets _iLastError to CMDLINE_NO_ERROR.
//
// Arguments:   none
//
// Returns:     the last error
//
// History:     Created 05/17/92 Lizch
//
//-------------------------------------------------------------------
INT CBaseCmdline::QueryError()
{
   INT iLastError = _iLastError;

   SetError(CMDLINE_NO_ERROR);

   return(iLastError);
}


//+------------------------------------------------------------------
//
// Function:    CBaseCmdline::SetError, public
//
// Member:      CBaseCmdline
//
// Synoposis:   Sets the internal error indicator to the passed value
//
// Effects:     sets _iLastError to passed value.
//
// Arguments:   [iLastError] - the new error value
//
// Returns:     nothing
//
// History:     Created 05/17/92 Lizch
//
//-------------------------------------------------------------------
void CBaseCmdline::SetError(INT iLastError)
{
    _iLastError = iLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\cmdlinew\cmdarg.cxx ===
//+------------------------------------------------------------------
//
//  File:       cmdarg.cxx
//
//  Contents:   implementation of CCmdlineArg class
//
//  Synoposis:  CCmdlineArg encapsulates an argv string.
//
//  Classes:    CCmdlineArg
//
//  Functions:
//
//  History:    12/30/91 Lizch Created
//              04/17/92 Lizch Converted to NLS_STR
//              09/18/92 Lizch Precompile headers
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


//+------------------------------------------------------------------
//
//  Function:   Constructor for CCmdlineArg
//
//  Synoposis:  Makes a copy of one argv string.
//
//  Arguments:  [nszArg] - an argv element
//
//  Returns:    nothing
//
//  History:    Created              12/30/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//
//-------------------------------------------------------------------
CCmdlineArg::CCmdlineArg(LPCNSTR nszArg)
{
    _fProcessed = FALSE;
    _pnszArgument = new NCHAR[_ncslen(nszArg)+1];
    if (NULL != _pnszArgument)
    {
        _ncscpy(_pnszArgument, nszArg);
    }
    else
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
    }
}


//+------------------------------------------------------------------
//
//  Function:   Destructor for CCmdlineArg
//
//  Synoposis:  Frees resources allocated in constructor.
//
//  Arguments:  None
//
//  Returns:    nothing
//
//  History:    Created              10/25/93 DeanE
//
//-------------------------------------------------------------------
CCmdlineArg::~CCmdlineArg()
{
    delete _pnszArgument;
}


//+------------------------------------------------------------------
//
//  Function:   IsProcessed
//
//  Synoposis:  Indicates whether this argument has been processed on
//              the command line. If FALSE, it probably indicates that
//              an unexpected switch was supplied.
//
//  Arguments:  none
//
//  Returns:    TRUE if processed, FALSE otherwise
//
//  History:    Created          05/30/92 Lizch
//
//-------------------------------------------------------------------
const BOOL CCmdlineArg::IsProcessed()
{
    return(_fProcessed);
}


//+------------------------------------------------------------------
//
//  Function:   SetProcessedFlag
//
//  Synoposis:  Sets whether this argument has been found on the command
//              line.
//
//  Arguments:  fProcessed - TRUE if found, FALSE otherwise
//
//  Returns:    nothing
//
//  History:    Created          05/30/92 Lizch
//
//-------------------------------------------------------------------
void CCmdlineArg::SetProcessedFlag(BOOL fProcessed)
{
    _fProcessed = fProcessed;
}


//+------------------------------------------------------------------
//
//  Function:   QueryArg
//
//  Synoposis:  Returns a pointer to this argument
//
//  Arguments:  none
//
//  Returns:    a NCHAR pointer to the argument
//
//  History:    Created          05/30/92 Lizch
//
//-------------------------------------------------------------------
LPCNSTR CCmdlineArg::QueryArg()
{
    return(_pnszArgument);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\cmdlinew\cstrlen.cxx ===
//+------------------------------------------------------------------
//
//  File:       cstrlen.cxx
//
//  Contents:   implementation for CStrLengthCmdlineObj
//
//  Synoposis:  Encapsulates a command line switch which takes an
//              length restricted string, eg: /password:<value>, where the
//              value must be between MINPASSWORD and MAXPASSWORD in
//              length
//
//  Classes:    CStrLengthCmdlineObj
//
//  History:    12/27/91 Lizch Created
//              04/17/92 Lizch Converted to NLS_STR
//              09/09/92 Lizch Changed SUCCESS to NO_ERROR
//              09/18/92 Lizch Precompile headers
//              10/18/93 DeanE Converted to WCHAR
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


LPCNSTR nszCmdlineString = _TEXTN("Takes a string ");
LPCNSTR nszLineArgString = _TEXTN("<string> ");


//+------------------------------------------------------------------
//
//  Member:     CStrLengthCmdlineObj::SetValue, public
//
//  Synoposis:  Stores the specified value, eg "lizch" from
//              "username:lizch"
//
//  Effects:    This SetValue simply checks for length within
//              specified range, and then calls the base SetValue
//
//  Arguments:  [nszArg] - the string following the switch on the
//                         command line. Excludes the equator (eg.
//                         ':' or '=' ), if any.
//
//  Returns:    CMDLINE_NO_ERROR or CMDLINE_ERROR_INVALID_VALUE
//
//  History:    Created          12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//-------------------------------------------------------------------
INT CStrLengthCmdlineObj::SetValue(LPCNSTR nszArg)
{
    UINT cchArg;

    cchArg = _ncslen(nszArg);
    if ((cchArg >= _uiMinLength) && (cchArg <= _uiMaxLength))
    {
        return(CBaseCmdlineObj::SetValue(nszArg));
    }
    else
    {
        return(CMDLINE_ERROR_INVALID_VALUE);
    }
}


//+-------------------------------------------------------------------
//
//  Method:     CStrLengthCmdlineObj::QueryCmdlineType, protected, const
//
//  Synoposis:  returns a character pointer to the  cmdline type.
//
//  Arguments:  None.
//
//  Returns:    const WCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CStrLengthCmdlineObj::QueryCmdlineType() const
{
    return(nszCmdlineString);
}


//+-------------------------------------------------------------------
//
//  Method:     CStrLengthCmdlineObj::QueryLineArgType, protected, const
//
//  Synoposis:  returns a character pointer to the line arg type.
//
//  Arguments:  None.
//
//  Returns:    const WCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CStrLengthCmdlineObj::QueryLineArgType() const
{
    // if user has not defined one then give default one
    if (_pnszLineArgType == NULL)
    {
        return(nszLineArgString);
    }
    else
    {
        return(_pnszLineArgType);
    }
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::DisplaySpecialUsage, protected
//
//  Synoposis:  Prints the switch usage statement according to current
//              display method.  Generally this will be stdout.
//
//  Arguments:  [usDisplayWidth] - total possible width available to display
//              [usIndent]       - amount to indent
//              [pusWidth]       - space to print on current line
//
//  Returns:    error code from QueryError,
//              error code from DisplayStringByWords
//
//  History:    05/14/91 Lizch    Created
//              07/29/92 Davey    Modified to work with new usage display
//-------------------------------------------------------------------
INT CStrLengthCmdlineObj::DisplaySpecialUsage(
        USHORT  usDisplayWidth,
        USHORT  usIndent,
        USHORT *pusWidth)
{
    NCHAR nszBuf[100];

    _sNprintf(nszBuf,
             _TEXTN("The string must be between %u and %u characters in length."),
             _uiMinLength,
             _uiMaxLength);

    return(DisplayStringByWords(
                  nszBuf,
                  usDisplayWidth,
                  usIndent,
                  pusWidth));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\cmdlinew\pch.cxx ===
//+------------------------------------------------------------------
//
// File:        pch.cxx
//
// Contents:    headers to precompile when building cmdline.lib
//
// Synoposis:
//
// Classes:
//
// Functions:
//
// History:     09/18/92 Lizch  Created
//
//-------------------------------------------------------------------
#include "pch.hxx"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\cmdlinew\cmdline.cxx ===
//+------------------------------------------------------------------
//
//  File:       cmdline.cxx
//
//  Contents:   implementation of CCmdline class
//
//  Synopsis:   CCmdline encapsulates the actual command line, and
//              parses it looking for expected switches.
//
//
//  Classes:    CCmdline
//
//  Functions:
//
//  History:    12/23/91 Lizch    Created
//              04/17/92 Lizch    Converted to NLS_STR
//              09/09/92 Lizch    Changed SUCCESS to NO_ERROR
//              09/18/92 Lizch    Precompile headers
//              11/14/92 DwightKr Updates for new version of NLS_STR
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


static void DelimitWithNulls(LPNSTR pnszArgline,
                             LPNSTR pnszDest,
                             UINT   *puiArgc);

//+------------------------------------------------------------------
//
//  Member:     CCmdline::CCmdline(int, char **, BOOL = FALSE)
//
//  Synopsis:   Copies argv and argc, and initialises defaults.
//
//  Effects:    Makes a copy of argv and argc. Argv (minus argv[0]) is
//              copied into an array of CCmdlineArg objects.
//              Argv[0] is copied into a program name data member.
//
//  Arguments:  [argc]           - count of arguments.
//              [argv]           - arguments.
//              [fInternalUsage] - Use internal Usage.
//
//  Returns:    None
//
//  Modifies:   aeLastError
//
//  History:    12/23/91 Lizch    Created.
//              04/17/92 Lizch    Converted to NLS_STR
//              07/28/92 Davey    Intialize _pfExtraUsage, _usIndent,
//                                _usDisplayWidth.
//                                Modified call to SetProgName,
//                                Added fInternalUsage parameter.
//              10/11/94 XimingZ  Initialize _pnszProgName.
//                                Call SetError before the first error return.
//                                Set _apArgs to NULL as it is deleted in
//                                case of memory allocatio failure.
//
//-------------------------------------------------------------------
CCmdline::CCmdline(int argc, char *argv[], BOOL fInternalUsage) :
        _apArgs(NULL),
        _uiNumArgs(0),
        _pfExtraUsage(NULL),
        _usIndent(CMD_INDENT),
        _usDisplayWidth(CMD_DISPLAY_WIDTH),
        _usSwitchIndent(CMD_SWITCH_INDENT),
        _pbcInternalUsage(NULL),
        _pnszProgName(NULL)
{
    INT   iRC;
    PNSTR pnszBuf;

    SetError(CMDLINE_NO_ERROR);

    if (fInternalUsage)
    {
        iRC = SetInternalUsage();
        if (CMDLINE_NO_ERROR != iRC)
            return;
    }

    pnszBuf = new NCHAR[strlen(argv[0])+1];
    if (NULL == pnszBuf)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
        return;
    }
    else
    {
#ifdef CTUNICODE
        mbstowcs(pnszBuf, argv[0], strlen(argv[0])+1);
#else
        strcpy(pnszBuf, argv[0]);
#endif

    }

    iRC = SetProgName(pnszBuf);
    delete pnszBuf;
    if (iRC != CMDLINE_NO_ERROR)
    {
        SetError(iRC);
        return;
    }


    // Don't include argv[0] in the argument count.
    _uiNumArgs = argc - 1;

    // Now set up an array of CCmdlineArg objects, each of which
    // encapsulates one argv element
    //
    _apArgs = new (CCmdlineArg *[_uiNumArgs]);
    if (_apArgs == NULL)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
        return;
    }

    for (INT i=0; i< (INT)_uiNumArgs; i++)
    {
        // Convert argv[i] to unicode
        pnszBuf = new NCHAR[strlen(argv[i+1])+1];
        if (NULL == pnszBuf)
        {
            _apArgs[i] = NULL;
        }
        else
        {
            // We check for errors in the next block
#ifdef CTUNICODE
            mbstowcs(pnszBuf, argv[i+1], strlen(argv[i+1])+1);
#else
            strcpy(pnszBuf, argv[i+1]);
#endif

            _apArgs[i] = new CCmdlineArg(pnszBuf);
            delete pnszBuf;
        }

        // If an allocation failed, rewind through those we have
        // allocated
        //
        if ((_apArgs[i] == NULL) || (_apArgs[i]->QueryError() != CMDLINE_NO_ERROR))
        {
            for (; i>=0; i--)
            {
                delete _apArgs[i];
            }

            delete [] _apArgs;
            _apArgs = NULL;
            SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
            break;
        }
    }
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::CCmdline(BOOL fInternalUsage = FALSE)
//
//  Synopsis:   Takes arguments from GetCommandLine(). To be used
//              with Windows programs whose startpoint is WinMain()
//
//  Effects:    Takes the arguments out of GetCommandLine(), and
//              copies them into an array of CCmdlineArg objects.
//
//  Arguments:  [fInternalUsage]  Use internal usage
//
//  Returns:    None
//
//  Modifies:   Not much really
//
//  History:    2/6/1995 jesussp  Created
//
//  Note:       For 16 bit, this will set the error to
//              CMDLINE_ERROR_USAGE_FOUND, as the GetCommandLine is
//              not support in WIN16.
//
//-------------------------------------------------------------------
CCmdline::CCmdline(BOOL fInternalUsage) :
        _apArgs(NULL),
        _uiNumArgs(0),
        _pfExtraUsage(NULL),
        _usIndent(CMD_INDENT),
        _usDisplayWidth(CMD_DISPLAY_WIDTH),
        _usSwitchIndent(CMD_SWITCH_INDENT),
        _pbcInternalUsage(NULL),
        _pnszProgName(NULL)
{

#if !defined (_WIN32)

    SetError(CMDLINE_ERROR_USAGE_FOUND);
    return;

#else

    INT    iRC;
    NCHAR  *pnszArgs,
           *pnszProg,
           *pnszDst;
    NCHAR  *pncArg;

    INT    iError;


    SetError(CMDLINE_NO_ERROR);

    if (fInternalUsage)
    {
        iRC = SetInternalUsage();
        if (CMDLINE_NO_ERROR != iRC)
            return;
    }

    // Obtain a copy of the command line

#if defined(CTUNICODE)
    pnszProg = new NCHAR[1+wcslen(GetCommandLineW())];
#else
    pnszProg = new NCHAR[1+strlen(GetCommandLineA())];
#endif

    if (NULL == pnszProg)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
        return;
    }

#if defined(CTUNICODE)
    wcscpy(pnszProg, GetCommandLineW());
#else
    strcpy(pnszProg, GetCommandLineA());
#endif

    // Skip through the command line looking for arguments

    pnszArgs = pnszProg;
    while (nchClSpace != *pnszArgs && nchClNull != *pnszArgs)
    {
        ++pnszArgs;
    }

    if (nchClSpace == *pnszArgs)
    {
        *pnszArgs++ = nchClNull;
    }

    // Now pnszProg points to a null-terminated string containing the
    // program name, and pnszArgs points to a null-terminated string
    // containing the program arguments...

    SetProgName(pnszProg);

    // Allocate memory for a buffer containing the different arguments
    // separated by nulls

    INT cBufSize = 1+_ncslen(pnszArgs);

    //
    // to accomodate for an extra null character
    //
    pnszDst = new NCHAR[1+cBufSize];
    if (NULL == pnszDst)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
        delete pnszProg;
        return;
    }

    // Parse the argument line and get a null-terminated string

    DelimitWithNulls(pnszArgs, pnszDst, &_uiNumArgs);


    // Set up an array of CCmdlineArg objects, each of which
    // encapsulates one argument
    //
    _apArgs = new (CCmdlineArg *[_uiNumArgs]);
    if (_apArgs == NULL)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
        return;
    }

    pncArg = pnszDst;

    for (INT i=0; i< (INT)_uiNumArgs; i++)
        {

	//  Copy argument string

        NCHAR *pnszBuf = new NCHAR[_ncslen(pncArg)+1];

        if (NULL == pnszBuf)
	{
	    _apArgs[i] = NULL;
        }
	else
        //  We check for errors until the next block
	{
            _ncscpy(pnszBuf, pncArg);
            _apArgs[i] = new CCmdlineArg(pnszBuf);
            delete pnszBuf;
        }

        //  If an allocation failed, rewind through those we have
        //  allocated
        if ((_apArgs[i] == NULL) || (_apArgs[i]->QueryError() != CMDLINE_NO_ERROR))
        {
            for (; i>=0; i--)
            {
                delete _apArgs[i];
            }

            delete [] _apArgs;
            _apArgs = NULL;
            SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
            break;
        }

        // Skip to the next argument (past a null byte)

	while (*pncArg++)
	{
	    ;
	}
    }

    // Release allocated memory

    delete pnszProg;
    delete pnszDst;

#endif // if !defined (_WIN32)

}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::~CCmdline()
//
//  Synopsis:   Destructor for CCmdline
//
//  Effects:    Deletes _apArgs
//
//  History:    12/23/91 Lizch   Created.
//              04/17/92 Lizch   Converted to NLS_STR
//              08/10/92 Davey   Added delete of _pnlsEquater/_pnlsSeparator
//              10/11/94 XimingZ Added checking _apArgs != NULL
//
//-------------------------------------------------------------------
CCmdline::~CCmdline()
{
    if (_apArgs != NULL)
    {
        for (UINT i=0; i<_uiNumArgs; i++)
        {
            delete _apArgs[i];
        }
        delete [] _apArgs;
    }

    delete _pbcInternalUsage;

    delete _pnszProgName;
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::Parse, public
//
//  Synoposis:  Parses the stored command line, matching actual with
//              expected command line switches.
//
//  Effects:    Calls FindSwitch which stores the command line values
//              (eg. "lizch" in "/user:lizch") in the individual command
//              line objects, via the polymorphic SetValue call.
//
//  Arguments:  [apExpectedArgs] - an array of all possible command line
//                                 objects
//              [iMaxArgs]       - the number of elements in that array.
//              [fExtras]        - if TRUE, a warning is given if an
//                                 unexpected command line argument is given.
//
//  Returns:    CMDLINE_NO_ERROR,
//              CMDLINE_ERROR_INVALID_FLAG.
//              CMDLINE_ERROR_ARGUMENT_MISSING
//              CMDLINE_ERROR_UNRECOGNISED_ARG
//              CMDLINE_ERROR_USAGE_FOUND
//
//  History:    12/23/91 Lizch   Created.
//              04/17/92 Lizch   Converted to NLS_STR.
//              08/10/92 Davey   Added internal usage check.
//				06/13/97 MariusB Reset found flag for each expected 
//								 arg. Reset the value of the arg if it 
//								 is not found, no default and not 
//								 required.
//-------------------------------------------------------------------
INT CCmdline::Parse(
        CBaseCmdlineObj *apExpectedArgs[],
        UINT             uiMaxArgs,
        BOOL             fCheckForExtras)
{
    INT  iRC = CMDLINE_NO_ERROR;
    UINT i;

    // Traverse the array of objects given, making sure none have errors
    for (i=0; i<uiMaxArgs; i++)
    {
        iRC = apExpectedArgs[i]->QueryError();
        if (CMDLINE_NO_ERROR != iRC)
        {
            return(iRC);
        }

		apExpectedArgs[i]->SetFoundFlag(FALSE);
    }

    // check for internal usage if defined.
    if (_pbcInternalUsage != NULL)
    {
        iRC = FindSwitch(_pbcInternalUsage, fCheckForExtras);
        if (iRC != CMDLINE_NO_ERROR)
        {
            DisplayUsage(apExpectedArgs, uiMaxArgs);
            return(iRC);
        }

        // if found, print out usage and return.
        if (_pbcInternalUsage->IsFound() == TRUE)
        {
            DisplayUsage(apExpectedArgs, uiMaxArgs);
            return(CMDLINE_ERROR_USAGE_FOUND);
        }
    }


    // look for each expected argument in turn.
    for (i=0; i<uiMaxArgs; i++)
    {
        CBaseCmdlineObj *pArg = apExpectedArgs[i];

        // Go along the actual command line, looking for this switch
        // CMDLINE_NO_ERROR doesn't necessarily indicate we found it,
        // just that nothing went wrong
        //
        iRC = FindSwitch(pArg, fCheckForExtras);
        if (iRC != CMDLINE_NO_ERROR)
        {
            break;
        }

        // We've gone through the entire command line. Check if any
        // switch was omitted. For those that had defaults specified,
        // set the default. For mandatory switches, generate an error.
        // Note that you should never have a default value for a
        // mandatory switch!
        //
        if ((pArg->IsFound()) == FALSE)
        {
            if (pArg->IsDefaultSpecified() == TRUE)
            {
                iRC = pArg->SetValueToDefault();
                if (iRC != CMDLINE_NO_ERROR)
                {
                    break;
                }
            }
            else
            {
                if ((pArg->IsRequired()) == TRUE)
                {
                    pArg->DisplayUsageDescr(
                                 _usSwitchIndent,
                                 _usDisplayWidth,
                                 _usIndent);

                    iRC = CMDLINE_ERROR_ARGUMENT_MISSING;
                    break;
                }
				else
				{
					// If the object is not found, it has no default 
					// value and it is not required, reset it. This 
					// action will not harm for normal use, but it 
					// will allow you to reuse the same set of command 
					// line object within the same app.

					pArg->ResetValue();
    			}
            }
        }
    }

    if (iRC == CMDLINE_NO_ERROR)
    {
        // We've got all our expected switches. Now check to see if
        // any switches are left on the command line unparsed,
        // if that's what the user wanted.
        //
        if (fCheckForExtras == TRUE)
        {
            for (i=0; i<_uiNumArgs; i++)
            {
                if (_apArgs[i]->IsProcessed() != TRUE)
                {
                    _sNprintf(_nszErrorBuf,
                             _TEXTN("Unrecognised switch %s\n"),
                             _apArgs[i]->QueryArg());
                    (*_pfnDisplay)(_nszErrorBuf);
                    iRC = CMDLINE_ERROR_UNRECOGNISED_ARG;
                }
            }
        }
    }
    else
    {
        DisplayUsage(apExpectedArgs, uiMaxArgs);
    }

    return(iRC);
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::FindSwitch, private
//
//  Synoposis:  Searches the command line for a given switch, checking
//              for separator and equator characters.
//
//  Effects:    Stores the value of the given switch, if any
//
//  Arguments:  [pArg]            - pointer to the switch object to search
//                                  for
//              [fCheckForExtras] - flag to see if should check for extra
//                                  args.
//
//  Returns:    CMDLINE_NO_ERROR
//              CMDLINE_ERROR_INVALID_VALUE
//              CMDLINE_ERROR_UNRECOGNISED_ARG
//
//  History:    12/23/91 Lizch    Created.
//              04/17/92 Lizch    Converted to NLS_STR
//              07/29/92 Davey    Converted to use DisplayUsageDescr
//                                Also fixed error output, was using
//                                printf, changed to sprintf.  Added
//                                Check for extras flag.
//              02/27/95 jesussp  Corrected the case when the switch
//                                name is non-existent
//				06/25/97 mariusb  Make /<switch>: and /<switch> 
//								  equivalent when the switch takes a 
//								  second argument (i.e. no equator 
//								  means the switch does not take a 
//								  second arg). Useful to specify NULL 
//								  values.
//  Notes:      Terminology to help understand this:
//	Example:    /username:lizch
//              The '/' is the separator
//              The ':' is the equator
//              'username' is the switch
//              'lizch' is the value
//
//-------------------------------------------------------------------
INT CCmdline::FindSwitch(CBaseCmdlineObj * const pArg, BOOL fCheckForExtras)
{
    INT    iRC = CMDLINE_NO_ERROR;
    LPCNSTR nszArg;
    LPCNSTR nszSep;
    LPCNSTR nszSwitch;
    LPCNSTR nszThisSwitch;
    LPCNSTR nszEquater;
    USHORT cchSwitch;
    USHORT usSecondArg  = 1;
    NCHAR  nchSeparator = pArg->GetSeparator();
    NCHAR  nchEquater   = pArg->GetEquater();
    NCHAR  nszSeparator[2];

    // If this switch does NOT take a second argument, we don't advance
    // past the equater when setting the value
    //
    if (!pArg->SecondArg())
    {
        usSecondArg = 0;
    }

    nszSeparator[0] = nchSeparator;
    nszSeparator[1] = nchClNull;

    for (UINT i=0; i<_uiNumArgs; i++)
    {
        nszArg = _apArgs[i]->QueryArg();

        // Find the separator character - it should be the first
        // character in the command line argument. If not, return
        // an error if fCheckForExtras == TRUE.
        //
        nszSep = nszArg;
        if (0 == _ncscspn(nszSep, nszSeparator))
        {
            // Get the switch value - first character after separator
            // up to but not including the equater
            //
            nszSwitch  = nszSep+1;
            nszEquater = nszSwitch;

            // Look for equater
            while ((nchClNull != *nszEquater) && (nchEquater != *nszEquater))
            {
                nszEquater++;
            }
            cchSwitch = (USHORT) (nszEquater - nszSwitch);

            nszThisSwitch = pArg->QuerySwitchString();

            // See if this switch is for this argument
            if (0 != cchSwitch &&
                cchSwitch == _ncslen(nszThisSwitch) &&
                0 == _ncsnicmp(nszSwitch, nszThisSwitch, cchSwitch))
            {
				// If we couldn't find the equater, decrease usSecondArg
				// which means we accept a NULL value for the switch. Thus
				// we make /<switch>: and /<switch> equivalent.
				if (nchEquater != *nszEquater && 1 == usSecondArg)
				{
					--usSecondArg;
				}
	
                // It is - get this switch's value
                _apArgs[i]->SetProcessedFlag(TRUE);

                // Now set the value of the switch (if any). How this is
                // done will vary from object to object: some won't take
                // values, some take lists of values etc.  The polymorphic
                // SetValue call handles this.  We don't want to pass
                // in the equater so add one to get to the beginning
                // of the value.
                //
                iRC = pArg->SetValue(nszSwitch+cchSwitch+usSecondArg);
                if (iRC != CMDLINE_NO_ERROR)
                {
                    pArg->DisplayUsageDescr(
                                 _usSwitchIndent,
                                 _usDisplayWidth,
                                 _usIndent);
                }

                pArg->SetFoundFlag(TRUE);
                // We have found the value for the given switch.

                break;
            } //if
        }
        else
        {
            // Error out if didn't find separator, only if checking for
            // extras
            //
            if (fCheckForExtras == TRUE)
            {
                _sNprintf(
                   _nszErrorBuf,
                   _TEXTN("The initial separator %c was not found on switch %s\n"),
                   nchSeparator,
                   nszArg);

                (*_pfnDisplay)(_nszErrorBuf);

                return(CMDLINE_ERROR_UNRECOGNISED_ARG);
            }
        }
    }

    return(iRC);
}




//+------------------------------------------------------------------
//
//  Member:     CCmdline::SetProgName, public
//
//  Synoposis:  Sets the program name to the passed value
//              This value can later be used in usage statements
//
//  Arguments:  [nszProgName] - the program name
//
//  Returns:    Error code
//
//  History:    Created     05/23/91 Lizch
//
//-------------------------------------------------------------------
INT CCmdline::SetProgName(PNSTR nszProgName)
{


    INT    nRet      = CMDLINE_NO_ERROR;
    NCHAR *pnchStart = nszProgName;
    NCHAR *pnchDot;

    // check for last slash.
    if (NULL != (pnchStart = _ncsrchr(nszProgName, '\\')))
    {
        pnchStart++;   // get past slash
    }
    else
    {
        // there was no slash so check for colon
        if (NULL != (pnchStart = _ncschr(nszProgName, ':')))
        {
            pnchStart++;   // get past colon
        }
        else
        {
            // there was no colon or slash so set to beginning of name
            pnchStart = nszProgName;
        }
    }

    if (NULL != (pnchDot = _ncschr(pnchStart, _TEXTN('.'))))
    {
        *pnchDot = nchClNull;
    }

    _pnszProgName = new NCHAR[_ncslen(pnchStart)+1];
    if (NULL == _pnszProgName)
    {
        nRet = CMDLINE_ERROR_OUT_OF_MEMORY;
    }
    else
    {
        _ncscpy(_pnszProgName, pnchStart);
    }

    return(nRet);

}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::GetProgName, public
//
//  Synoposis:  Returns a pointer to the program name
//
//  Arguments:  none
//
//  Returns:    a const NCHAR pointer to the program name
//
//  History:    Created         05/23/91 Lizch
//
//-------------------------------------------------------------------
const NCHAR *CCmdline::GetProgName()
{
    return(_pnszProgName);
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::SetExtraUsage, public
//
//  Synoposis:  Sets the extra usage file pointer.
//
//  Arguments:  [pfUsage] - function pointer to usage function.
//
//  History:    07/28/92 Davey Created.
//
//-------------------------------------------------------------------
void CCmdline::SetExtraUsage(PFVOID pfUsage)
{
    _pfExtraUsage = pfUsage;
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::SetIndent, public
//
//  Synoposis:  Sets the indent parameter for usage display.
//
//  Arguments:  [usIndent] - how much to indent second lines.
//
//  Returns:    codes from CheckParamerterConsistency
//
//  History:    07/28/92 Davey Created.
//
//-------------------------------------------------------------------
INT CCmdline::SetIndent(USHORT usIndent)
{
    _usIndent = usIndent;
    return(CheckParameterConsistency());
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::SetSwitchIndent, public
//
//  Synoposis:  Sets the switch indent parameter for usage display.
//
//  Arguments:  [usSwitchIndent] - how much to indent switch.
//
//  Returns:    codes from CheckParamerterConsistency
//
//  History:    07/28/92 Davey Created.
//
//-------------------------------------------------------------------
INT CCmdline::SetSwitchIndent(USHORT usSwitchIndent)
{
    _usSwitchIndent = usSwitchIndent;
    return(CheckParameterConsistency());
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::SetDisplayWidth, public
//
//  Synoposis:  Sets the amount of line space available for the
//              usage display.
//
//  Arguments:  [usDisplayWidth] - line space available
//
//  Returns:    codes from CheckParamerterConsistency
//
//  History:    07/28/92 Davey Created.
//
//-------------------------------------------------------------------
INT CCmdline::SetDisplayWidth(USHORT usDisplayWidth)
{
    _usDisplayWidth = usDisplayWidth;
    return(CheckParameterConsistency());
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::CheckParameterConsistency, private const
//
//  Synoposis:  Checks to make sure the display parameters are
//              useable.
//
//  Arguments:  None.
//
//  Returns:    CMDLINE_NO_ERROR
//              CMDLINE_ERROR_DISPLAY_PARAMS
//
//  History:    07/28/92 Davey Created.
//
//-------------------------------------------------------------------
INT CCmdline::CheckParameterConsistency(void) const
{
    if (_usSwitchIndent >= _usIndent)
    {
        return(CMDLINE_ERROR_DISPLAY_PARAMS);
    }
    if (_usIndent >= _usDisplayWidth)
    {
        return(CMDLINE_ERROR_DISPLAY_PARAMS);
    }

    return(CMDLINE_NO_ERROR);
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::QueryDisplayParameters, public
//
//  Synoposis:  Returns the three parameters which control the
//              usage display output.
//
//  Arguments:  [pusDisplayWidth] - returns display width
//              [pusSwitchIndent] - returns switch indent
//              [pusIndent]       - returns indent of second lines
//
//  History:    07/28/92 Davey Created.
//
//-------------------------------------------------------------------
void CCmdline::QueryDisplayParameters(
        USHORT *pusDisplayWidth,
        USHORT *pusSwitchIndent,
        USHORT *pusIndent) const
{
    *pusDisplayWidth = _usDisplayWidth;
    *pusSwitchIndent = _usSwitchIndent;
    *pusIndent       = _usIndent;
}


//+------------------------------------------------------------------
//
//  Member:     CCmdline::DisplayUsage, public
//
//  Synoposis:  Displays usage of switches,
//
//  Arguments:  apExpectedArgs: the array of command line objects
//              uiMaxArgs:      number of elements in the array
//
//  Returns:    Error code from QueryError
//
//  History:    07/28/92 Davey Created.
//
//  Notes:      Looks like:
//
//  Usage Instructions
//  test2         /mc:<worker> [/ml:<log_server>] [/mt:<test>]
//               [/mn:<tester-email>] [/mp:<path>] [/mo:<obj_name>]
//               [/md:<dispatcher>] [/?]
//
//   /mc         Takes a list of strings specifying worker names.
//               These workers should have full names.
//               Don't you think so?
//               The strings in the list are separated by one of the following
//               character(s): ",; ".
//   /ml         Takes a string specifying log server name.
//   /mt         Takes a string specifying name of the test.
//   /mn         Takes a string specifying email name of the tester.
//   /mp         Takes a string specifying path name to log to.
//   /mo         Takes a string specifying name of the object.
//   /md         Takes a string specifying name of the dispatcher to use.
//   /?          Flag specifying command line usage. It defaults to FALSE.
//
//   ***following is whatever is output by the function pfnExtraUsage****
//
//-------------------------------------------------------------------
INT CCmdline::DisplayUsage(
        CBaseCmdlineObj * const apExpectedArgs[],
        UINT                    uiMaxArgs)
{
    USHORT usWidth = _usDisplayWidth;
    USHORT StrLen;
    INT    iRC;
    USHORT cchProgName;
    PNSTR  pnszLine;
    USHORT i;

    (*_pfnDisplay)(_TEXTN("\nUsage Instructions\n"));

    // Start creating usage line.
    //

    // Determine length to make line buffer - if the size of the program
    // name is less than the indentation, the buffer needs to be at
    // least as big as the indentation, less 1 for an extra space that
    // gets printed.
    cchProgName = (USHORT) _ncslen(_pnszProgName);

    if (cchProgName < _usIndent)
    {
        // Add 1 for null term
        StrLen = (USHORT) (_usIndent + 1);
    }
    else
    {
        // Add 1 for null term, 1 for new line and indent in next line
        StrLen = (USHORT) (cchProgName + _usIndent + 2);
    }

    // copy program name
    //
    pnszLine = new NCHAR[StrLen];
    if (NULL == pnszLine)
    {
        return(CMDLINE_ERROR_OUT_OF_MEMORY);
    }

    _ncscpy(pnszLine, _pnszProgName);

    // if the size of the program name is less than indentation then
    // add in padding; else add in a new line and then padding.
    //
    if (cchProgName >= _usIndent)
    {
        _ncscat(pnszLine, nszClNewLine);
    }
    // fill in with spaces until get to indent position
    for (i = (USHORT) _ncslen(pnszLine); i < StrLen - 1; i++)
    {
        _ncscat(pnszLine, nszClSpace);
    }

    // output program name
    //
    (*_pfnDisplay)(pnszLine);

    // update remaining display width
    //
    usWidth = (USHORT) (usWidth - _usIndent);

    // done with pnszLine - delete it now to avoid leaks in case of
    // errors
    //
    delete pnszLine;

    // display the command line usage statement, required ones first
    //
    for (i=0; i<uiMaxArgs; i++)
    {
        if (apExpectedArgs[i]->IsRequired() == TRUE)
        {
            iRC = apExpectedArgs[i]->DisplayUsageLine(
                                            &usWidth,
                                            _usDisplayWidth,
                                            _usIndent);
            if (iRC)
            {
                SetError(iRC);
                return(iRC);
            }
        }
    }

    for (i=0; i<uiMaxArgs; i++)
    {
        if (apExpectedArgs[i]->IsRequired() == FALSE)
        {
            iRC = apExpectedArgs[i]->DisplayUsageLine(
                                            &usWidth,
                                            _usDisplayWidth,
                                            _usIndent);
            if (iRC)
            {
                SetError(iRC);
                return(iRC);
            }
        }
    }

    // print out if using internal usage.
    //
    if (_pbcInternalUsage != NULL)
    {
        iRC = _pbcInternalUsage->DisplayUsageLine(
                                        &usWidth,
                                        _usDisplayWidth,
                                        _usIndent);
        if (iRC)
        {
            SetError(iRC);
            return(iRC);
        }
    }


    // separate the line and descriptions
    (*_pfnDisplay)(_TEXTN("\n\n"));

    // display the switch descriptions, required ones first
    for (i=0; i<uiMaxArgs; i++)
    {
        if (apExpectedArgs[i]->IsRequired() == TRUE)
        {
            iRC = apExpectedArgs[i]->DisplayUsageDescr(
                                            _usSwitchIndent,
                                            _usDisplayWidth,
                                            _usIndent);
            if (iRC)
            {
                SetError(iRC);
                return(iRC);
            }
        }
    }

    for (i=0; i<uiMaxArgs; i++)
    {
        if (apExpectedArgs[i]->IsRequired() == FALSE)
        {
            iRC = apExpectedArgs[i] -> DisplayUsageDescr(
                                              _usSwitchIndent,
                                              _usDisplayWidth,
                                              _usIndent);
            if (iRC)
            {
                SetError(iRC);
                return(iRC);
            }
        }
    }

    // print out if using internal usage.
    //
    if (_pbcInternalUsage != NULL)
    {
        iRC = _pbcInternalUsage->DisplayUsageDescr(
                                        _usSwitchIndent,
                                        _usDisplayWidth,
                                        _usIndent);
        if (iRC)
        {
            SetError(iRC);
            return(iRC);
        }
    }


    (*_pfnDisplay)(_TEXTN("\n\n"));

    // invoke the special usage function if defined.
    if (_pfExtraUsage != NULL)
    {
        _pfExtraUsage();
    }

    return(CMDLINE_NO_ERROR);
}

//+------------------------------------------------------------------
//
//  Member:     CCmdline::SetInternalUsage, private
//
//  Synposis:   Sets the internal usage flag
//
//  Effects:    Modifies _pcbInternalUsage, so that it displays
//
//  Arguments:  none
//
//  Returns:    CMDLINE_NO_ERROR
//              CMDLINE_ERROR_OUT_OF_MEMORY
//
//
//  History:    02/06/95 jesussp  Created
//
//  Notes:
//-------------------------------------------------------------------

INT CCmdline::SetInternalUsage(void)
{
INT iError;             // Error to be returned

    _pbcInternalUsage = new CBoolCmdlineObj(_TEXTN("?"), _TEXTN("command line usage."));
    if (NULL == _pbcInternalUsage)
    {
        SetError(CMDLINE_ERROR_OUT_OF_MEMORY);
    }
    else
    {
        SetError(_pbcInternalUsage->QueryError());
    }
    iError = QueryError();
    if (CMDLINE_NO_ERROR != iError)
    {
        // Since QueryError always sets CMDLINE_NO_ERROR, we need to
        // call SetError to put the error back.
        SetError(iError);
    }
    return iError;
}

//+------------------------------------------------------------------
//
//  Function:   DelimitWithNulls, private
//
//  Synposis:   Delimits an argument string, putting a null byte
//              between parameters and an additional extra null byte
//              at the end of the string. For use by CCmdline
//              constructor.
//
//  Effects:    Copies pnszArgLine to pnszDest. Space must be
//              allocated for both strings. Modifies uiArgc.
//
//  Arguments:  [pnszArgLine]     The line with arguments
//              [pnszDest]        Null-delimited destination
//              [puiArgc]         Pointer to an argument count
//
//  Returns:    Nothing
//
//
//  History:    02/10/95 jesussp  Created
//
//  Notes:      Inspired on parse_cmdline(), crt32\startup\stdargv.c
//              pnszArgLine and pnszDest must point to valid memory
//              allocations. Also, the space allocation for
//              pnszDest must be greater than that of pnszArgLine.
//-------------------------------------------------------------------

static void DelimitWithNulls(LPNSTR  pnszArgLine,
                             LPNSTR  pnszDest,
                             UINT    *puiArgc)
{
    LPNSTR pncSrc = pnszArgLine;
    LPNSTR pncDst = pnszDest;

    BOOL    fInQuote    = 0;
    USHORT  ucBackSlash = 0;
    USHORT  ucQuotes    = 0;


    *puiArgc = 0;

    // Loop through the entire argument line

    for (;;)
    {
       // skip blanks
       while (*pncSrc && _isnspace(*pncSrc))
       {
          ++pncSrc;
       }

       // Reached the end of the string?
       if (nchClNull == *pncSrc)
       {
          // Put a null byte at the end only if we haven't had
          // any argument...

          if (0 == *puiArgc)
          {
              *pncDst++ = nchClNull;
          }
          break;
       }

       // We now have one more argument...
       ++(*puiArgc);

       // process one argument

       for (;;)
       {

          ucBackSlash = 0;

          while (nchClBackSlash == *pncSrc)
          {
              ++pncSrc; ++ucBackSlash;
          }

      	  if (nchClQuote == *pncSrc)
          {
             if (ucBackSlash % 2 == 0)   // Even number of backslashes?
      	     {
                fInQuote = !fInQuote;
      	        ++pncSrc;                // Eat up quote
      	     }
      	     ucBackSlash /= 2;
      	  }

          while (ucBackSlash--)
          {
      	      *pncDst++ = nchClBackSlash;
      	  }

      	  if (nchClNull == *pncSrc || (!fInQuote && _isnspace(*pncSrc)))
      	  {
      	     break;
      	  }

      	  *pncDst++ = *pncSrc++;
       }

       if (fInQuote)
       {
           *pncDst++ = nchClSpace;
       }
       else
       {
           *pncDst++ = nchClNull;
       }
    }

    // Complete the string, adding an extra nul character

    *pncDst = nchClNull;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\cmdlinew\wstrlist.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1993.
//
// File:        nstrlist.cxx
//
// Contents:    Implementation of class CnStrList
//
// Functions:   CnStrList::CnStrList
//              CnStrList::~CnStrList
//              CnStrList::QueryError
//              CnStrList::Next
//              CnStrList::Reset
//              CnStrList::Append
//
// History:     XimingZ   23-Dec-1993   Created
//
//------------------------------------------------------------------------

#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions

#include <wstrlist.hxx>

//+-----------------------------------------------------------------------
//
// Function:   CnStrList::CnStrList
//
// Synopsis:   Constructor, which creates a string list.
//
// Arguments:  [pnszItems]  -- Supplied string consisting of zero or more
//                             item strings separated by delimiters.  Two
//                             consecutive delimiters mean an item of
//                             an empty string in between.
//             [pnszDelims] -- Supplied set of delimiter characters.
//
// Returns:    Nothing
//
// History:    XimingZ   23-Dec-1993   Created
//
//------------------------------------------------------------------------

CnStrList::CnStrList(LPCNSTR pnszItems, LPCNSTR pnszDelims) :
    _head(NULL), _tail(NULL), _next(NULL), _iLastError(NSTRLIST_NO_ERROR)
{
    LPCNSTR  pnszNewItem;
    PNSTR   pnszLocalItems;
    PNSTR   pnszHead;
    BOOL    fDone;

    SetError(NSTRLIST_NO_ERROR);
    if (pnszItems == NULL)
    {
        // No items.
        return;
    }

    // Make a local copy of items.
    pnszLocalItems = new NCHAR[_ncslen(pnszItems) + 1];
    if (pnszLocalItems == NULL)
    {
        SetError(NSTRLIST_ERROR_OUT_OF_MEMORY);
        return;
    }
    _ncscpy(pnszLocalItems, pnszItems);
    pnszHead = pnszLocalItems;

    fDone = FALSE;
    while (fDone == FALSE)
    {
        pnszNewItem = (LPCNSTR)pnszLocalItems;  // Beginning of a new item.
        // Search for next delimiter or end of given string.
        while (*pnszLocalItems != _TEXTN('\0') &&
               _ncschr(pnszDelims, *pnszLocalItems) == NULL)
        {
            pnszLocalItems++;
        }

        if (*pnszLocalItems == _TEXTN('\0'))
        {
            // End of string.
            fDone = TRUE;
        }
        else
        {
            // Replace end of item with L'\0' for Append.
            *pnszLocalItems = _TEXTN('\0');
        }
        // Append the item to the list.
        if (Append(pnszNewItem) == FALSE)
        {
            SetError(NSTRLIST_ERROR_OUT_OF_MEMORY);
            fDone = TRUE;
        }
        pnszLocalItems++;
    }
    delete pnszHead;
}


//+-----------------------------------------------------------------------
//
// Function:   CnStrList::~CnStrList
//
// Synopsis:   Destructor.
//
// Arguments:  None.
//
// Returns:    Nothing
//
// History:    XimingZ   23-Dec-1993   Created
//
//------------------------------------------------------------------------

CnStrList::~CnStrList()
{
    NSTRLIST *pNext;

    while (_head != NULL)
    {
        pNext = _head->pNext;
        delete [] _head->pnszStr;
        delete [] _head;
        _head = pNext;
    }
}


//+-----------------------------------------------------------------------
//
// Function:   CnStrList::Next
//
// Synopsis:   Get next item.
//
// Arguments:  None.
//
// Returns:    Next item if there is one, or else NULL.
//
// History:    XimingZ   23-Dec-1993   Created
//
//------------------------------------------------------------------------

LPCNSTR CnStrList::Next()
{
    LPCNSTR pnsz;

    if (_next == NULL)
    {
        return NULL;
    }
    pnsz = _next->pnszStr;
    _next = _next->pNext;
    return pnsz;
}


//+-----------------------------------------------------------------------
//
// Function:   CnStrList::Reset
//
// Synopsis:   Reset the iterator.
//
// Arguments:  None
//
// Returns:    None
//
// History:    XimingZ   23-Dec-1993   Created
//
//------------------------------------------------------------------------

VOID CnStrList::Reset()
{
    _next = _head;
}


//+-----------------------------------------------------------------------
//
// Function:   CnStrList::Append
//
// Synopsis:   Append a string to the list.
//
// Arguments:  [pnszItem]  -- Supplied string.
//
// Returns:    TRUE if the function succeeds or else (out of memory) FALSE.
//
// History:    XimingZ   23-Dec-1993   Created
//
//------------------------------------------------------------------------

BOOL CnStrList::Append(LPCNSTR pnszItem)
{
    // Construct a new node.
    NSTRLIST *pNode = new NSTRLIST[1];
    if (pNode == NULL)
    {
        return FALSE;
    }
    pNode->pnszStr = new NCHAR [_ncslen(pnszItem) + 1];
    if (pNode->pnszStr == NULL)
    {
        delete [] pNode;
        return FALSE;
    }
    _ncscpy(pNode->pnszStr, pnszItem);
    pNode->pNext = NULL;

    // Add it to the list.
    if (_head == NULL)
    {
        _next = _head = pNode;
    }
    else
    {
        _tail->pNext = pNode;
    }
    _tail = pNode;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\cmdlinew\cstrlist.cxx ===
//+------------------------------------------------------------------
//
//  File:       cstrlist.cxx
//
//  Contents:   implementation for CStrListCmdlineObj
//
//  Synoposis:  Encapsulates a command line switch that takes a list
//              of strings.
//
//  Classes:    CStrListCmdlineObj
//
//  Functions:
//
//  History:    12/27/91 Lizch      Created
//              04/17/92 Lizch      Converted to NLS_STR
//              05/11/92 Lizch      Incorporated review feedback
//              07/07/92 Lizch      Added GetValue method
//              07/29/92 davey      Added nlsType and nlsLineArgType
//              09/09/92 Lizch      Changed SUCCESS to NO_ERROR
//              09/18/92 Lizch      Precompile headers
//              10/14/93 DeanE      Converted to WCHAR
//              12/23/93 XimingZ    Converted to CWStrList
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions

LPCNSTR nszDefaultDelims = _TEXTN(",; ");
LPCNSTR nszCmdlineType   = _TEXTN("Takes a list of strings ");
LPCNSTR nszLineArgType   = _TEXTN("<string_list>");


//+------------------------------------------------------------------
//
//  Function:   CStrListCmdlineObj Constructor (1 of 2)
//
//  Member:     CStrListCmdlineObj
//
//  Synoposis:  Initialises switch string, usage values and whether the
//              switch is mandatory. This constructor gives no default value
//              for this switch. Also initialises the Delimiters
//
//  Effects:
//
//  Arguments:  [nszSwitch]  - the expected switch string
//              [nszUsage]   - the usage statement to display
//              [fMustHave]  - whether the switch is mandatory or not.
//                             if it is, an error will be generated if
//                             the switch is not specified on the
//                             command line. Defaults to FALSE.
//              [nszLineArg] - line argument string
//
//  Returns:    none, but sets _iLastError
//
//  History:    04/17/92 Lizch Created
//              08/03/92 Davey Added nlsLineArg
//
//-------------------------------------------------------------------
CStrListCmdlineObj::CStrListCmdlineObj(
        LPCNSTR nszSwitch,
        LPCNSTR nszUsage,
        BOOL   fMustHave,
        LPCNSTR nszLineArg) :
        CBaseCmdlineObj(nszSwitch, nszUsage, fMustHave, nszLineArg),
        _pNStrList(NULL)
{
    SetDelims(nszDefaultDelims);
}


//+------------------------------------------------------------------
//
//  Function:   CStrListCmdlineObj Constructor (2 of 2)
//
//  Member:     CStrListCmdlineObj
//
//  Synoposis:  Initialises switch string, usage strings and default value.
//              Also initialises the Delimiters
//              This constructor is only used if a switch is optional.
//
//  Effects:    Sets fMandatory to FALSE (ie. switch is optional)
//
//  Arguments:  [nszSwitch]   - the expected switch string
//              [nszUsage]    - the usage statement to display
//              [nszDefault]  - the value to be used if no switch is
//                              specified on the command line.
//              [nszLineArg]  - line argument string
//
//  Returns:    none, but sets _iLastError
//
//  History:    04/17/92 Lizch Created.
//              08/03/92 Davey Added nlsLineArg
//
//-------------------------------------------------------------------
CStrListCmdlineObj::CStrListCmdlineObj(
        LPCNSTR nszSwitch,
        LPCNSTR nszUsage,
        LPCNSTR nszDefault,
        LPCNSTR nszLineArg) :
        CBaseCmdlineObj(nszSwitch, nszUsage, nszDefault, nszLineArg),
        _pNStrList(NULL)
{
    SetDelims(nszDefaultDelims);
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::SetDelims, public
//
//  Synoposis:  Sets Delimiters for items within the list.
//
//  Arguments:  [nszDelims] - the list of possible separators
//
//  Returns:    ERROR_NOT_ENOUGH_MEMORY or NO_ERROR
//
//  History:    Created              12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//
//-------------------------------------------------------------------
INT CStrListCmdlineObj::SetDelims(LPCNSTR nszDelims)
{
    INT nRet = CMDLINE_NO_ERROR;

    _pnszListDelims = new NCHAR[_ncslen(nszDelims)+1];
    if (NULL == _pnszListDelims)
    {
        nRet = CMDLINE_ERROR_OUT_OF_MEMORY;
    }
    else
    {
        _ncscpy(_pnszListDelims, nszDelims);
    }

    return(nRet);
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::~CStrListCmdlineObj
//
//  Synoposis:  Frees the string list associated with the object
//
//  History:    Created              12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//              Converted to WSTRLIST 12/23/93 XimingZ
//
//-------------------------------------------------------------------
CStrListCmdlineObj::~CStrListCmdlineObj()
{
    delete (NCHAR *)_pValue;
    _pValue = NULL;
    delete _pNStrList;
    delete _pnszListDelims;
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::SetValue, public
//
//  Synoposis:  Uses the CnStrList class to store the list of strings
//              following a command line switch, eg. "M1" "M2" "M3" from
//              "/computers:M1,M2,M3"
//
//  Arguments:  [nszArg] - the string following the switch on the command
//                         line. Excludes the equator (eg. ':' or '=' ).
//
//  Returns:    CMDLINE_NO_ERROR or CMDLINE_ERROR_OUT_OF_MEMORY
//
//  History:    Created                12/27/91 Lizch
//              Converted to NLS_STR   04/17/92 Lizch
//              Converted to CnStrList 12/23/93 XimingZ
//
//-------------------------------------------------------------------
INT CStrListCmdlineObj::SetValue(LPCNSTR nszArg)
{
    INT nRet = CMDLINE_NO_ERROR;

    // delete any existing pValue and pWStrList.
    if (_pValue != NULL)
    {
        delete (NCHAR *)_pValue;
        _pValue = NULL;
    }
    if (_pNStrList != NULL)
    {
        delete _pNStrList;
        _pNStrList = NULL;
    }


    if (nszArg == NULL)
    {
        _pValue = NULL;
    }
    else
    {
        _pValue = new NCHAR[_ncslen(nszArg)+1];
        if (_pValue == NULL)
        {
            nRet = CMDLINE_ERROR_OUT_OF_MEMORY;
        }
        else
        {
            _ncscpy((NCHAR *)_pValue, nszArg);
        }

        _pNStrList = new CnStrList(nszArg, _pnszListDelims);
        if (_pNStrList == NULL ||
            _pNStrList->QueryError() != NSTRLIST_NO_ERROR)
        {
            nRet = CMDLINE_ERROR_OUT_OF_MEMORY;
        }
    }
    return(nRet);
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::ResetValue, public
//
//  Synopsis:   Releases all the internal elements of the object.
//              
//              
//
//  Arguments:  [nszArg] - the string following the switch on the command
//                         line. Excludes the equator (eg. ':' or '=' ).
//
//  Returns:    CMDLINE_NO_ERROR or CMDLINE_ERROR_OUT_OF_MEMORY
//
//  History:    Created                06/13/97 MariusB
//
//-------------------------------------------------------------------
void CStrListCmdlineObj::ResetValue()
{
    // delete any existing pValue and pWStrList.
    if (_pValue != NULL)
    {
        delete (NCHAR *)_pValue;
        _pValue = NULL;
    }

    if (_pNStrList != NULL)
    {
        delete _pNStrList;
        _pNStrList = NULL;
    }
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::GetValue, public
//
//  Synposis:   Returns pointer to NCHAR string that holds the next value.
//              If no next value exists, NULL is returned. The returned
//              string will stay alive only within the lifetime of the
//              current CStrListCmdlineObj object and before any call to
//              SetValue.
//
//  Arguments:  void
//
//  Returns:    LPCNSTR
//
//  History:    Created   7/07/92  Lizch
//              Changed to CnStrList  12/23/93  XimingZ
//
//-------------------------------------------------------------------
LPCNSTR CStrListCmdlineObj::GetValue()
{
        if (_pNStrList == NULL)
        {
            return NULL;
        }
        return _pNStrList->Next();
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::Reset, public
//
//  Synposis:   Reset string iterator.
//
//  Arguments:  void
//
//  Returns:    none
//
//  History:    Created  12/23/93  XimingZ
//
//-------------------------------------------------------------------
VOID CStrListCmdlineObj::Reset()
{
        if (_pNStrList != NULL)
        {
            _pNStrList->Reset();
        }
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::DisplayValue, public
//
//  Synoposis:  Prints the stored command line value to stdout.
//
//  History:    Created              12/27/91 Lizch
//              Converted to NLS_STR 04/17/92 Lizch
//              Changed to CnStrList 12/23/93 XimingZ
//
//-------------------------------------------------------------------
void CStrListCmdlineObj::DisplayValue()
{
    if (_pValue != NULL)
    {
        LPCNSTR      pnszItem;
        CnStrList   StringList((NCHAR *)_pValue, _pnszListDelims);
        _sNprintf (_nszErrorBuf,
                  _TEXTN("Switch %ls specified the following strings\n"),
                  _pnszSwitch);
        (_pfnDisplay)(_nszErrorBuf);

        while ((pnszItem = StringList.Next()) != NULL)
        {
            _sNprintf(_nszErrorBuf, _TEXTN("\t%ls\n"), pnszItem);
            (*_pfnDisplay)(_nszErrorBuf);
        }

    }
    else
    {
        DisplayNoValue();
    }
}


//+-------------------------------------------------------------------
//
//  Method:     CStrListCmdlineObj::QueryCmdlineType, protected, const
//
//  Synoposis:  returns a character pointer to the  cmdline type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
const NCHAR *CStrListCmdlineObj::QueryCmdlineType() const
{
    return(nszCmdlineType);
}


//+-------------------------------------------------------------------
//
//  Method:     CStrListCmdlineObj::QueryLineArgType, protected, const
//
//  Synoposis:  returns a character pointer to the line arg type.
//
//  Arguments:  None.
//
//  Returns:    const NLS_STR reference to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
const NCHAR *CStrListCmdlineObj::QueryLineArgType() const
{
    // if user has not defined one then give default one
    if (_pnszLineArgType == NULL)
    {
        return(nszLineArgType);
    }
    else
    {
        return(_pnszLineArgType);
    }
}


//+------------------------------------------------------------------
//
//  Member:     CStrListCmdlineObj::DisplaySpecialUsage, protected
//
//  Synoposis:  Prints the switch usage statement to stdout
//
//  Arguments:  [usDisplayWidth] - total possible width available
//                                 to display
//              [usIndent]       - amount to indent.
//              [pusWidth]       - space to print on current line
//
//  Returns:    error code from QueryError,
//              error code from DisplayStringByWords
//
//  History:    12/27/91 Lizch    Created
//              04/17/92 Lizch    Converted to NLS_STR
//              07/29/92 Davey    Modified to work with new usage display
//
//-------------------------------------------------------------------
INT CStrListCmdlineObj::DisplaySpecialUsage(
        USHORT  usDisplayWidth,
        USHORT  usIndent,
        USHORT *pusWidth)
{
    NCHAR nszBuf[150];
    _sNprintf(nszBuf,
             _TEXTN(" The strings in the list are separated by one of the")
             _TEXTN(" following character(s): \"%ls\"."),
             _pnszListDelims);

    return(DisplayStringByWords(
                  nszBuf,
                  usDisplayWidth,
                  usIndent,
                  pusWidth));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\cmdlinew\culong.cxx ===
//+------------------------------------------------------------------
//
//  File:       culong.cxx
//
//  Contents:   implementation for CUlongCmdlineObj
//
//  Synoposis:  Encapsulates a command line switch which takes an
//              unsigned long value, eg: /maxusers:10
//
//  Classes:    CUlongCmdlineObj
//
//  Functions:
//
//  History:    06/15/92 DeanE      Stolen from CIntCmdlineObj code
//              07/29/92 davey      Added nlsType and nlsLineArgType
//              09/09/92 Lizch      Changed SUCCESS to NO_ERROR
//              09/18/92 Lizch      Precompile headers
//              11/14/92 DwightKr   Updates for new version of NLS_STR
//              10/14/93 DeanE      Converted to NCHAR
//
//-------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <cmdlinew.hxx>         // public cmdlinew stuff
#include "_clw.hxx"             // private cmdlinew stuff
#include <ctype.h>              // is functions


INT StringToUlong(LPCNSTR pnszInt, ULONG *pUlong);

LPCNSTR nszCmdlineUlong = _TEXTN("Takes an unsigned long ");
LPCNSTR nszLineArgUlong = _TEXTN("<ulong> ");


//+------------------------------------------------------------------
//
//  Member:     CUlongCmdlineObj destructor
//
//  Synoposis:  Frees any memory associated with the object
//
//  History:    Added to allow casting of pValue 05/12/92 Lizch
//              Integrated into CUlongCmdlineObj 6/15/92  DeanE
//
//-------------------------------------------------------------------
CUlongCmdlineObj::~CUlongCmdlineObj()
{
    delete (ULONG *)_pValue;
    _pValue = NULL;
}


//+------------------------------------------------------------------
//
//  Member:     CUlongCmdlineObj::SetValue, public
//
//  Synposis:   Stores the ulong value specified after the switch
//              string, eg. 10 for /maxusers:10
//
//  Effects:    This implementation for the virtual method SetValue
//              converts the characters following the switch to an unsigned
//              long.  It allocates memory for the ulong.
//              If there is no equator character, or if there
//              is no character following the equator character, _pValue
//              remains NULL.
//
//  Arguments:  [nszArg] - the string following the switch on the
//                         command line. Includes the equator (eg.
//                         ':' or '=' ), if any.
//
//  Returns:    CMDLINE_NO_ERROR, CMDLINE_ERROR_OUT_OF_MEMORY,
//              CMDLINE_ERROR_TOO_BIG, CMDLINE_ERROR_INVALID_VALUE
//
//  History:    Created                          12/27/91 Lizch
//              Converted to NLS_STR             4/17/92  Lizch
//              Integrated into CUlongCmdlineObj 6/15/92  DeanE
//
//-------------------------------------------------------------------
INT CUlongCmdlineObj::SetValue(LPCNSTR nszArg)
{
    INT iRC;

    // delete any existing _pValue
    delete (ULONG *)_pValue;
    _pValue = NULL;

    _pValue = new ULONG;
    if (_pValue == NULL)
    {
        return (CMDLINE_ERROR_OUT_OF_MEMORY);
    }

    // I'm using this rather than c runtime atol so that I
    // can detect error conditions like overflow and non-digits.
    iRC = StringToUlong(nszArg, (ULONG *)_pValue);
    if (iRC != CMDLINE_NO_ERROR)
    {
        delete (ULONG *)_pValue;
        _pValue = NULL;
    }

    return(iRC);
}


//+------------------------------------------------------------------
//
//  Member:     CUlongCmdlineObj::GetValue, public
//
//  Synposis:   Returns a pointer to ULONG that holds the value.
//
//  Arguments:  void
//
//  Returns:    ULONG value at *_pValue.
//
//  History:    Created                          12/27/91 Lizch
//              Converted to NLS_STR             4/17/92  Lizch
//              Integrated into CUlongCmdlineObj 6/15/92  DeanE
//
//-------------------------------------------------------------------
const ULONG *CUlongCmdlineObj::GetValue()
{
    return((ULONG *)_pValue);
}


//+------------------------------------------------------------------
//
//  Member:     CUlongCmdlineObj::DisplayValue, public
//
//  Synoposis:  Prints the stored command line value accordint to
//              current display method.  Generally this will be to stdout.
//
//  History:    Created                           12/27/91 Lizch
//              Converted to NLS_STR              4/17/92  Lizch
//              Integrated into CUlongCmdlineObj  6/15/92  DeanE
//
//-------------------------------------------------------------------
void CUlongCmdlineObj::DisplayValue()
{
    if (_pValue != NULL)
    {
        _sNprintf(_nszErrorBuf,
                 _TEXTN("Command line switch %s has value %lu\n"),
                 _pnszSwitch,
                 *(ULONG *)_pValue);
        (*_pfnDisplay)(_nszErrorBuf);
    }
    else
    {
        DisplayNoValue();
    }
}


//+------------------------------------------------------------------
//
//  Function:   StringToUlong
//
//  Synoposis:  Converts given string to unsigned long, checking for
//              overflow and illegal characters. Only +, - and digits
//              are accepted.
//
//  Arguments:  [nszUlong] - string to convert
//              [pUlong]   - pointer to converted unsigned long
//
//  Returns:    CMDLINE_NO_ERROR, CMDLINE_ERROR_INVALID_VALUE,
//              CMDLINE_ERROR_TOO_BIG
//
//  History:    Created                    12/17/91 Lizch
//              Converted to AsciiToUlong  6/15/92  DeanE
//              Added in conversion of Hex 12/27/94 DaveY
//
//  Notes:      I'm using this rather than c runtime atoi so that I
//              can detect error conditions like overflow and non-digits.
//              The sign is checked for and stored, although it is not
//              used - so a negative value will still be converted to
//              an unsigned equivalent.
//
//-------------------------------------------------------------------
INT StringToUlong(LPCNSTR nszUlong, ULONG *pUlong)
{
    short sNegator = 1;
    ULONG ulResult = 0;
    INT   iRC      = CMDLINE_NO_ERROR;

    // Skip any leading spaces - these can occur if the command line
    // switch incorporates spaces, eg "/a:   123"
    //
    while (_isnspace(*nszUlong))
    {
        nszUlong++;
    }

    // Get sign - ignore for now
    switch (*nszUlong)
    {
    case '-':
        sNegator = -1;
        nszUlong++;
        break;
    case '+':
        sNegator = 1;
        nszUlong++;
        break;
    default:
        break;
    }

    // see if using hex values
    if ((*nszUlong == _TEXTN('0')) && 
        ((*(nszUlong+1) == _TEXTN('x')) || (*(nszUlong+1) == _TEXTN('X'))))
    {
        nszUlong += 2;   // pass the "0x"

        int max = sizeof(ULONG) << 1;   // number of hex digits possible

        for(int i=0;  *nszUlong != NULL && i < max; i++, nszUlong++)
        {
            if ((_TEXTN('0') <= *nszUlong ) && (*nszUlong <= _TEXTN('9')))
            {
                ulResult = ulResult * 16 + (*nszUlong - _TEXTN('0'));
            }
            else if ((_TEXTN('A') <= *nszUlong ) && (*nszUlong <= _TEXTN('F')))
            {
                ulResult = ulResult * 16 + 10 + (*nszUlong - _TEXTN('A'));
            }
            else if ((_TEXTN('a') <= *nszUlong) && (*nszUlong <= _TEXTN('f')))
            {
                ulResult = ulResult * 16 + 10 + (*nszUlong - _TEXTN('a'));
            }
            else
            {
                iRC = CMDLINE_ERROR_INVALID_VALUE;
                ulResult = 0;
                break;
            }
        }
        if ((i >= max) && (*nszUlong != NULL))
        {
            iRC = CMDLINE_ERROR_INVALID_VALUE;
            ulResult = 0;
        }
        *pUlong = ulResult;
        return iRC;
    }


    // must be decimal

    for (;*nszUlong != L'\0'; nszUlong++)
    {
        if (!_isndigit(*nszUlong))
        {
            ulResult = 0;
            iRC = CMDLINE_ERROR_INVALID_VALUE;
            break;
        }

        ULONG ulPrevious = ulResult;

        ulResult = (ulResult * 10) + (*nszUlong - '0');

        // Check for overflow by checking that the previous result is less
        // than the current result - if the previous one was bigger, we've
        // overflowed!
        //
        if (ulResult < ulPrevious)
        {
            ulResult = 0;
            iRC = CMDLINE_ERROR_TOO_BIG;
            break;
        }
    }

    *pUlong = ulResult;

    return(iRC);
}


//+-------------------------------------------------------------------
//
//  Method:     CUlongCmdlineObj::QueryCmdlineType, protected, const
//
//  Synoposis:  returns a character pointer to the  cmdline type.
//
//  Arguments:  None.
//
//  Returns:    const NCHAR pointer to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CUlongCmdlineObj::QueryCmdlineType() const
{
    return(nszCmdlineUlong);
}


//+-------------------------------------------------------------------
//
//  Method:     CUlongCmdlineObj::QueryLineArgType, protected, const
//
//  Synoposis:  returns a character pointer to the line arg type.
//
//  Arguments:  None.
//
//  Returns:    const NLS_STR reference to string.
//
//  History:    28-Jul-92  davey    Created.
//
//--------------------------------------------------------------------
LPCNSTR CUlongCmdlineObj::QueryLineArgType() const
{
    // if user has not defined one then give default one
    if (_pnszLineArgType == NULL)
    {
        return(nszLineArgUlong);
    }
    else
    {
        return(_pnszLineArgType);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\datagen\dg_ascii.cxx ===
//+---------------------------------------------------------------------------
// //   Copyright (C) 1991, 1992 Microsoft Corporation.
//
//       File:  DG_ASCII.cxx
//
//   Contents:  Definition for DataGen DG_ASCII class.
//
//    Classes:  DG_ASCII    - Class to generate 8-bit random strings.
//
//  Functions:  DG_ASCII::DG_ASCII()
//              DG_ASCII::Generate()      All varieties
//              DG_ASCII::_LenMem()
//
//    History:  03-Oct-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//              11-Mar-92  RonJo     Ported to Win32 and separated DG and
//                                   DataGen functionality.
//
//----------------------------------------------------------------------------
#include <comtpch.hxx>
#pragma  hdrstop

#include <dg.hxx>
#include <math.h>
#include <time.h>


#ifdef DOCGEN
//+---------------------------------------------------------------------------
//
//     Member:  DG_ASCII::DG_ASCII, public
//
//   Synopsis:  Calls DG_INTEGER class constructor, and initializes _fNull.
//
//  Arguments:  [ulNewSeed] - the seed value to use as the internal seed.
//
//   Modifies:  _fNull
//
//  Algorithm:  Calls the DG_INTEGER constructor, and initializes _fNull.
//
//      Notes:  Implemented as an inline function.  See DataGen.hxx.
//
//    History:  03-Oct-91  RonJo     Created.
//
//----------------------------------------------------------------------------

DG_ASCII::DG_ASCII(ULONG ulNewSeed)
{
    //
    // Implemented as an inline function.
    //
}
#endif


//+---------------------------------------------------------------------------
//
//     Member:  DG_ASCII::Generate(range), public
//
//   Synopsis:  Produces a random 8-bit character, random length string.
//              The "randomness" of the characters may be constrained by
//              value parameters passed to the function, and the length
//              by length parameters passed to the function.
//
//  Arguments:  [**puchString] - pointer to where the pointer to the string
//                               will be stored up success of the function.
//
//              [*pulLength] - pointer to where the length of the string
//                             will be stored up success of the function.
//
//              [uchMinVal] - minimum value that a character may have.
//
//              [uchMaxVal] - maximum value that a character may have.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_OUT_OF_MEMORY -- if memory for the string cannot be
//                                     allocated.
//
//              DG_RC_BAD_STRING_PTR -- if the string pointer argument passed
//                                      in is invalid.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number pointer argument passed
//                                      in is invalid.
//
//              DG_RC_BAD_VALUES  -- if the minimum value is greater than the
//                                   maximum value.
//
//              DG_RC_BAD_LENGTHS  -- if the minimum length is greater than the
//                                    maximum length.
//
//   Modifies:  _usRet
//
//  Algorithm:  Allocate memory according to the length constraints, then
//              use the integer generator to fill in the string.
//
//      Notes:
//
//    History:  03-Oct-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//----------------------------------------------------------------------------

USHORT DG_ASCII::Generate(UCHAR **puchString,
                          ULONG   *pulLength,
                          UCHAR    uchMinVal,
                          UCHAR    uchMaxVal,
                          ULONG     ulMinLen,
                          ULONG     ulMaxLen)
{
    // Ensure that the length values are OK, and allocate the string
    // memory.
    //
    (VOID)_LenMem(puchString, pulLength, ulMinLen, ulMaxLen);
    if (_usRet != DG_RC_SUCCESS)
    {
        return _usRet;
    }

    // Now just fill in the string with random characters.
    //
    ULONG i = *pulLength;
    while(i-- > 0)
    {
        UCHAR uch;
        _usRet = DG_INTEGER::Generate(&uch, uchMinVal, uchMaxVal);
        if (_usRet == DG_RC_SUCCESS)
        {
            (*puchString)[i] = uch;
        }
        else
        {
            // Something went wrong, so free up the memory and stick a
            // NULL into the pointer.
            //
            delete [] *puchString;
            *puchString = NULL;
            *pulLength = 0;
            break;
        }
    }

    // We're all done so return.
    //
    return _usRet;
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_ASCII::Generate(NULL), public
//
//   Synopsis:  Generates a NULL terminated string by setting the _fNull
//              variable to TRUE, which causes an extra space containing
//              the NULL character to be put at the end the string, casting
//              the appropriate arguments, and calling the Generate(range)
//              member function to perform the actual work.
//
//  Arguments:  [**pszString] - pointer to where the pointer to the string
//                              will be stored up success of the function.
//
//              [uchMinVal] - minimum value that a character may have.
//
//              [uchMaxVal] - maximum value that a character may have.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  See the Generate(range) member function.
//
//   Modifies:  _fNull
//
//  Algorithm:  Set _fNull to TRUE and call the Generate(range) member
//              function to do the actual work.
//
//      Notes:
//
//    History:  03-Oct-91  RonJo     Created.
//
//----------------------------------------------------------------------------

USHORT DG_ASCII::Generate(CHAR **pszString,
                          UCHAR  uchMinVal,
                          UCHAR  uchMaxVal,
                          ULONG   ulMinLen,
                          ULONG   ulMaxLen)
{
    _fNull = TRUE;
    ULONG ulLength;
    return Generate((UCHAR **)pszString,
                              &ulLength,
                              uchMinVal,
                              uchMaxVal,
                               ulMinLen,
                               ulMaxLen);
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_ASCII::Generate(selection), public
//
//
//   Synopsis:  Produces a random 8-bit character, random length string.
//              The "randomness" of the characters is constrained by the
//              characters in the selection argument, and the length may be
//              constrained by the length parameters passed to the function.
//
//  Arguments:  [**puchString] - pointer to where the pointer to the string
//                               will be stored up success of the function.
//
//              [*pulLength] - pointer to where the length of the string
//                             will be stored up success of the function.
//
//              [*puchSelection] - the selection string from which char-
//                                 acters are chosen at random.
//
//              [ulSelLength] - the length of the selection string.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_OUT_OF_MEMORY -- if memory for the string cannot be
//                                  allocated.
//
//              DG_RC_BAD_STRING_PTR -- if the string pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_LENGTHS  -- if the minimum length is greater than the
//                                 maximum length.
//
//   Modifies:  _usRet
//
//  Algorithm:  Allocate memory according to the length constraints, then
//              repeatedly uses the integer generator to pick a character
//              from the selection to insert into the string until the
//              string is full.
//
//      Notes:  The probability of a given character being selected from
//              the selection string is directly related to the number of
//              times that character appears in the selection string.
//
//    History:  04-Oct-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//----------------------------------------------------------------------------

USHORT DG_ASCII::Generate(UCHAR **puchString,
                          ULONG   *pulLength,
                          UCHAR  *puchSelection,
                          ULONG     ulSelLength,
                          ULONG     ulMinLen,
                          ULONG     ulMaxLen)
{
    // Handle the special cases of:
    //   1) the puchSelection being NULL
    //   2) the puchSelection argument is empty (ulSelLength = 0)
    //
    if (puchSelection == NULL)
    {
        return Generate(puchString,
                        pulLength,
                        (UCHAR)0,
                        UCHAR_MAX,
                        ulMinLen,
                        ulMaxLen);
    }
    if (ulSelLength == 0)
    {
        *puchString = NULL;
        *pulLength = 0;
        return _usRet;
    }

    // Ensure that the length values are OK, and allocate the string
    // memory.
    //
    (VOID)_LenMem(puchString, pulLength, ulMinLen, ulMaxLen);
    if (_usRet != DG_RC_SUCCESS)
    {
        return _usRet;
    }

    // Now just fill in the string with characters randomly chosen from
    // the selection string.
    //
    ULONG i = *pulLength;
    while(i-- > 0)
    {
        ULONG ul;
        _usRet = DG_INTEGER::Generate(&ul, 0, ulSelLength - 1);
        if (_usRet == DG_RC_SUCCESS)
        {
            (*puchString)[i] = puchSelection[ul];
        }
        else
        {
            // Something went wrong, so free up the memory and stick a
            // NULL into the pointer.
            //
            delete [] *puchString;
            *puchString = NULL;
            *pulLength = 0;
            break;
        }
    }

    // We're all done so return.
    //
    return _usRet;
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_ASCII::Generate(selection, NULL), public
//
//
//   Synopsis:  Produces a random 8-bit character, random length, NULL-
//              terminated string.
//              The "randomness" of the characters is constrained by the
//              characters in the selection argument, and the length may be
//              constrained by the length parameters passed to the function.
//
//  Arguments:  [**puszString] - pointer to where the pointer to the string
//                               will be stored up success of the function.
//
//              [*puszSelection] - the selection string from which char-
//                                 acters are chosen at random.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_OUT_OF_MEMORY -- if memory for the string cannot be
//                                  allocated.
//
//              DG_RC_BAD_STRING_PTR -- if the string pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_LENGTHS  -- if the minimum length is greater than the
//                                 maximum length.
//
//   Modifies:  _usRet
//
//  Algorithm:  Allocate memory according to the length constraints, then
//              repeatedly uses the integer generator to pick a character
//              from the selection to insert into the string until the
//              string is full.
//
//      Notes:  The probability of a given character being selected from
//              the selection string is directly related to the number of
//              times that character appears in the selection string.
//
//    History:  04-Oct-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//               8-Jun-92  DeanE     Cut & Paste from Generate(NULL)
//
//----------------------------------------------------------------------------

USHORT DG_ASCII::Generate(UCHAR **puszString,
                          UCHAR  *puszSelection,
                          ULONG     ulMinLen,
                          ULONG     ulMaxLen)
{
    _fNull = TRUE;
    ULONG   ulLength;
    ULONG   ulSelLength;
    UCHAR *puszTemp = puszSelection;

    // Get length of puszSelection - we aren't linking with C run-time
    // so we have to determine the length ourselves
    //
    while (*puszTemp != NULL)
    {
       puszTemp++;
    }
    ulSelLength = puszTemp - puszSelection;

    return Generate((UCHAR **)puszString,
                              &ulLength,
                              puszSelection,
                               ulSelLength,
                               ulMinLen,
                               ulMaxLen);
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_ASCII::_LenMem, private
//
//   Synopsis:  Determine the size needed to create the ASCII string, and
//              then allocate that much memory for it.
//
//  Arguments:  [**puchString] - pointer to the pointer which will point to
//                               the beginning memory for the string.
//
//              [*pulLength] - pointer to the memory in which to store the
//                             length of the string.
//
//              [ulMinLen] - the minimum length of the string.
//
//              [ulMaxLen] - the maximum length of the string.
//
//    Returns:  DG_RC_SUCCESS -- if successful.
//
//              DG_RC_BAD_STRING_PTR -- if the string location pointer is
//                                      NULL.
//
//              DG_RC_BAD_LENGTH_PTR -- if the length location pointer is
//                                      NULL.
//
//              DG_RC_BAD_LENGTHS -- if the minimum length is greater than
//                                   the maximum lengths.
//
//              DG_RC_OUT_OF_MEMORY -- if space for the string cannot be
//                                     allocated.
//
//  Algorithm:  Verify the arguments.  Then if this is the default case,
//              generate a length with an expected value of 5 (see section
//              4.3 of the DataGen Design Specification for details).  If
//              this is not the default case, then generate a length using
//              the values provided.
//
//      Notes:
//
//    History:  03-Oct-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//----------------------------------------------------------------------------

VOID DG_ASCII::_LenMem(UCHAR **puchString,
                       ULONG   *pulLength,
                       ULONG     ulMinLen,
                       ULONG     ulMaxLen)
{
    // This value will produce an expected string length of 5 in
    // the default case.  Hence the name 'E5'.
    //
    const FLOAT E5 = 0.20F;

    // Perform parameter checks.
    //
    if (puchString == NULL)
    {
        _usRet = DG_RC_BAD_STRING_PTR;
    return;
    }
    else if (pulLength == NULL)
    {
        _usRet = DG_RC_BAD_LENGTH_PTR;
    return;
    }
    else if (ulMinLen > ulMaxLen)
    {
        _usRet = DG_RC_BAD_LENGTHS;
    return;
    }

    // If the default case is being used, then generate a length with the
    // expected value of 5.  Otherwise generate a number from the range
    // values given.  See section 4 of the DataGen Design Specification
    // for details.
    //
    if ((ulMinLen == 1) && (ulMaxLen == DG_DEFAULT_MAXLEN))
    {
        *pulLength = ulMinLen;
        while ((*pulLength < ulMaxLen) && (_Floater() > E5))
        {
            (*pulLength)++;
        }
    }
    else
    {
        ULONG ul;
        (VOID)DG_INTEGER::Generate(&ul, ulMinLen, ulMaxLen);
        if (_usRet == DG_RC_SUCCESS)
        {
            *pulLength = ul;
        }
        else
        {
            // Something went wrong, so stick a NULL
            // into the pointer, and a 0 into the length.
            //
            *puchString = NULL;
            *pulLength = 0;
            return;
        }
    }

    // Allocate memory based on the length.  If _fNull is true, then add 1
    // extra character for a terminating NULL character.  _fNull will be
    // true whenever we are generating a NULL terminated string.
    //
    if (_fNull == TRUE)
    {
        *puchString = new UCHAR[*pulLength + 1];
        if (*puchString != NULL)
        {
            (*puchString)[*pulLength] = NULL;
            _fNull = FALSE;
        }
    }
    else
    {
        *puchString = new UCHAR[*pulLength];
    }

    // Check for errors.
    //
    if (*puchString == NULL)
    {
        _usRet = DG_RC_OUT_OF_MEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\datagen\dg_int.cxx ===
//+---------------------------------------------------------------------------
//
//   Copyright (C) 1991, 1992 Microsoft Corporation.
//
//       File:  DG_INTEGER.cxx
//
//   Contents:  Definition for DataGen DG_INTEGER class.
//
//    Classes:  DG_INTEGER    - Class to produce random interegers of any
//                              integer data type.
//
//  Functions:  DG_INTEGER::DG_INTEGER()
//              DG_INTEGER::Generate()        All varieties
//
//    History:  28-Sep-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//              11-Mar-92  RonJo     Ported to Win32 and separated DG and
//                                   DataGen functionality.
//
//----------------------------------------------------------------------------
#include <comtpch.hxx>
#pragma  hdrstop

#include <dg.hxx>
#include <math.h>
#include <time.h>
#include <stdlib.h>


#ifdef DOCGEN
//+---------------------------------------------------------------------------
//
//     Member:  DG_INTEGER::DG_INTEGER, public
//
//   Synopsis:  Calls the DG_BASE constructor to perform needed setup.
//
//  Arguments:  [ulNewSeed] - the seed value to use as the internal seed.
//
//  Algorithm:  Calls the DG_BASE constructor.
//
//      Notes:  Implemented as an inline function.  See DataGen.hxx.
//
//    History:  28-Sep-91  RonJo     Created.
//
//----------------------------------------------------------------------------

DG_INTEGER::DG_INTEGER(ULONG ulNewSeed)
{
    //
    // Implemented as an inline function.
    //
}
#endif


//+---------------------------------------------------------------------------
//
//     Member:  DG_INTEGER::Generate(ULONG), public
//
//   Synopsis:  Generate a random ULONG number, bounded by ulMinVal and
//              ulMaxVal.
//
//  Arguments:  [*pulNumber] - pointer to where the user wants the random
//                             number stored.
//
//              [ulMinVal] - minimum value desired as a random number.
//
//              [ulMaxVal] - maximum value desired as a random number.
//
//              [bStd] - Use standard 'C' library random number generator
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number argument passed in is
//                                      invalid.
//
//              DG_RC_BAD_VALUES  -- if the minimum value is greater than the
//                                   maximum value.
//
//   Modifies:  _ulNumber
//
//  Algorithm:  Generate a new base number by multiplying it with a constant,
//              add 1, and take the modulo of the maximum unsigned long value.
//              Then take the new base number times the range determined by
//              the values, divide by the maximum unsigned long value and add
//              the minimum desired value.  This will produce a number in the
//              range [ulMinVal, ulMaxVal].
//
//      Notes:  See _Algorithms in C_ by Robert Sedgewick for full algorithm
//              explanation and constant, ulB, selection.
//
//    History:  28-Sep-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//              04-March-97  EyalS   modified to use std rand() by default
//                           (added bStd & code to use rand())
//
//
//----------------------------------------------------------------------------

USHORT DG_INTEGER::Generate(ULONG *pulNumber, ULONG ulMinVal, ULONG ulMaxVal, BOOL bStd)
{
    const ULONG ulB = 314159621;
    ULONG ulTmp;

    //
    // Extnesion: Use standard library random # generator
    //
    if(pulNumber != NULL &&
       bStd){
       //
       // use std 'c' library
       //

       //
       // init return number to low bound
       //
       *pulNumber = ulMinVal;
       ULONG ulRange = ulMaxVal - ulMinVal;
       if(ulRange >= RAND_MAX){
          //
          // We make the assumpution that if x = 3*y then
          // rand(x) ~= 3 * rand(y), that is equivalent not equal...
          // - cycle as long as RAND_MAX > remaining range as we subtract it
          //
          //
          for(ulTmp = ulRange;
              ulTmp > RAND_MAX;
              ulTmp-=RAND_MAX){
             *pulNumber += rand();
          }
          //
          // & the last remaining cycle;
          //
          if(ulTmp != 0)
            *pulNumber += rand() % ulTmp;
       }
       else{
          //
          // well the num is an int range, so just use it
          //
          if(ulRange != 0)
            *pulNumber += (ULONG)(rand() % (INT)(1 + ulRange));
       }

    }
    //
    // Original code
    //
    else if (pulNumber != NULL)
    {
        // Make the range a double so that when the multiplication is
        // performed, we will not need to worry about overflow and will
        // get higher precision.
        //
        DOUBLE dblRange = (DOUBLE)(ulMaxVal - ulMinVal);

        if (dblRange > 0.0)
        {
            // Must add 1.0 to the range to change the result from
            // [Min, Max) to [Min, Max].
            //
            dblRange += 1.0;
            _ulNumber = (_Multiply(_ulNumber, ulB) + 1) % ULONG_MAX;
            *pulNumber = (ULONG)(((_ulNumber * dblRange) / (double)(unsigned long)ULONG_MAX) + ulMinVal) % ULONG_MAX;
        }
        else if (dblRange == 0.0)
        {
            *pulNumber = ulMinVal;
        }
        else
        {
            _usRet = DG_RC_BAD_VALUES;
        }
    }
    else
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
    }
    return _usRet;
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_INTEGER::Generate(@), public
//
//   Synopsis:  All integer data type generator functions operate by calling
//              the ULONG generator function and casting the arguments
//              appropriately.
//
//  Arguments:  [*p@Number] - pointer to storage for the particular data
//                            type desired.
//
//              [@MinVal] - minimum value desired as a random number.
//
//              [@MaxVal] - maximum value desired as a random number.
//
//    Returns:  Returns what is produced by the ULONG Generate member
//              function, cast appropriately.
//
//  Algorithm:  See the Generate(ULONG) member function.
//
//      Notes:
//
//    History:  28-Sep-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Modified to use new return code policy.
//
//----------------------------------------------------------------------------

USHORT DG_INTEGER::Generate(SCHAR *pschNumber, SCHAR schMinVal, SCHAR schMaxVal)
{
    // Perform argument error checking.
    //
    if (pschNumber == NULL)
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
        return _usRet;
    }

    // Make space for the cast variables.
    //
    ULONG ulNumber;
    ULONG ulMinVal = (ULONG)schMinVal;
    ULONG ulMaxVal = (ULONG)schMaxVal;

    // Call the ULONG version to do the work.
    //
    (VOID)Generate(&ulNumber, ulMinVal, ulMaxVal);

    // If it went OK, assign the value.
    //
    if (_usRet == DG_RC_SUCCESS)
    {
        *pschNumber = (SCHAR)ulNumber;
    }
    return _usRet;
}

USHORT DG_INTEGER::Generate(UCHAR *puchNumber, UCHAR uchMinVal, UCHAR uchMaxVal)
{
    // Perform argument error checking.
    //
    if (puchNumber == NULL)
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
        return _usRet;
    }

    // Make space for the cast variables.
    //
    ULONG ulNumber;
    ULONG ulMinVal = (ULONG)uchMinVal;
    ULONG ulMaxVal = (ULONG)uchMaxVal;

    // Call the ULONG version to do the work.
    //
    (VOID)Generate(&ulNumber, ulMinVal, ulMaxVal);

    // If it went OK, assign the value.
    //
    if (_usRet == DG_RC_SUCCESS)
    {
        *puchNumber = (UCHAR)ulNumber;
    }
    return _usRet;
}

#ifndef WIN16

USHORT DG_INTEGER::Generate(SHORT *psNumber, SHORT sMinVal, SHORT sMaxVal)
{
    // Perform argument error checking.
    //
    if (psNumber == NULL)
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
        return _usRet;
    }

    // Make space for the cast variables.
    //
    ULONG ulNumber;
    ULONG ulMinVal = (ULONG)sMinVal;
    ULONG ulMaxVal = (ULONG)sMaxVal;

    // Call the ULONG version to do the work.
    //
    (VOID)Generate(&ulNumber, ulMinVal, ulMaxVal);

    // If it went OK, assign the value.
    //
    if (_usRet == DG_RC_SUCCESS)
    {
        *psNumber = (SHORT)ulNumber;
    }
    return _usRet;
}

USHORT DG_INTEGER::Generate(USHORT *pusNumber, USHORT usMinVal, USHORT usMaxVal)
{
    // Perform argument error checking.
    //
    if (pusNumber == NULL)
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
        return _usRet;
    }

    // Make space for the cast variables.
    //
    ULONG ulNumber;
    ULONG ulMinVal = (ULONG)usMinVal;
    ULONG ulMaxVal = (ULONG)usMaxVal;

    // Call the ULONG version to do the work.
    //
    (VOID)Generate(&ulNumber, ulMinVal, ulMaxVal);

    // If it went OK, assign the value.
    //
    if (_usRet == DG_RC_SUCCESS)
    {
        *pusNumber = (USHORT)ulNumber;
    }
    return _usRet;
}

#endif

USHORT DG_INTEGER::Generate(INT *pintNumber, INT intMinVal, INT intMaxVal)
{
    // Perform argument error checking.
    //
    if (pintNumber == NULL)
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
        return _usRet;
    }

    // Make space for the cast variables.
    //
    ULONG ulNumber;
    ULONG ulMinVal = (ULONG)intMinVal;
    ULONG ulMaxVal = (ULONG)intMaxVal;

    // Call the ULONG version to do the work.
    //
    (VOID)Generate(&ulNumber, ulMinVal, ulMaxVal);

    // If it went OK, assign the value.
    //
    if (_usRet == DG_RC_SUCCESS)
    {
        *pintNumber = (INT)ulNumber;
    }
    return _usRet;
}

USHORT DG_INTEGER::Generate(UINT *puintNumber, UINT uintMinVal, UINT uintMaxVal)
{
    // Perform argument error checking.
    //
    if (puintNumber == NULL)
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
        return _usRet;
    }

    // Make space for the cast variables.
    //
    ULONG ulNumber;
    ULONG ulMinVal = (ULONG)uintMinVal;
    ULONG ulMaxVal = (ULONG)uintMaxVal;

    // Call the ULONG version to do the work.
    //
    (VOID)Generate(&ulNumber, ulMinVal, ulMaxVal);

    // If it went OK, assign the value.
    //
    if (_usRet == DG_RC_SUCCESS)
    {
        *puintNumber = (UINT)ulNumber;
    }
    return _usRet;
}

USHORT DG_INTEGER::Generate(LONG *plNumber, LONG lMinVal, LONG lMaxVal)
{
    // Only need to cast the values here since LONGs and ULONGs take
    // up the same amount of space.
    //
    return Generate((ULONG *)plNumber, (ULONG)lMinVal, (ULONG)lMaxVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\datagen\dg_real.cxx ===
//+---------------------------------------------------------------------------
//
//   Copyright (C) 1991, 1992 Microsoft Corporation.
//
//       File:  DG_REAL.cxx
//
//   Contents:  Definition for DataGen DG_REAL class.
//
//    Classes:  DG_REAL    - Class to produce random floating point numbers
//                           for any floating point data type.
//
//  Functions:  DG_REAL::DG_REAL()
//              DG_REAL::Generate()        All varieties
//
//    History:  11-Mar-92  RonJo     Created.
//
//              21-Oct-92  RonJo     ifdef'ed the long double version because
//                                   Win32/NT does not support long doubles.
//                                   Made double version standalone to support
//                                   itself and the float version.
//
//----------------------------------------------------------------------------
#include <comtpch.hxx>
#pragma  hdrstop

#include <dg.hxx>
#include <math.h>
#include <time.h>


#ifdef DOCGEN
//+---------------------------------------------------------------------------
//
//     Member:  DG_REAL::DG_REAL, public
//
//   Synopsis:  Calls the DG_BASE constructor to perform needed setup.
//
//  Arguments:  [ulNewSeed] - the seed value to use as the internal seed.
//
//  Algorithm:  Calls the DG_BASE constructor.
//
//      Notes:  Implemented as an inline function.  See DataGen.hxx.
//
//    History:  11-Mar-92  RonJo     Created.
//
//----------------------------------------------------------------------------

DG_REAL::DG_REAL(ULONG ulNewSeed)
{
    //
    // Implemented as an inline function.
    //
}
#endif



// Take out long double version for Win32/NT because it does not
// support long doubles.
#ifndef FLAT
//+---------------------------------------------------------------------------
//
//     Member:  DG_REAL::Generate(LDOUBLE), public
//
//   Synopsis:  Generate a random LDOUBLE number, bounded by ldblMinVal and
//              ldblMaxVal.
//
//  Arguments:  [*pldblNumber] - pointer to where the user wants the random
//                               number stored.
//
//              [ldblMinVal] - minimum value desired as a random number.
//
//              [ldblMaxVal] - maximum value desired as a random number.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number argument passed in is
//                                      invalid.
//
//              DG_RC_BAD_VALUES  -- if the minimum value is greater than the
//                                   maximum value.
//
//   Modifies:  _ulNumber (through _Floater())
//
//  Algorithm:  Determine the range in which to generate the random number,
//              then use _Floater() to "select" a number within that range
//              and add it to the minimum value.  If the range is 0.0, then
//              simply use the minimum value.
//
//      Notes:
//
//    History:  11-Mar-92  RonJo     Created.
//
//----------------------------------------------------------------------------

USHORT DG_REAL::Generate(LDOUBLE *pldblNumber,
                         LDOUBLE ldblMinVal,
                         LDOUBLE ldblMaxVal)
{
    if (pldblNumber != NULL)
    {
        // Get the range.
        //
        LDOUBLE ldblRange = ldblMaxVal - ldblMinVal;

        if (ldblRange > 0.0)
        {
            const ULONG ulB = 602300421;

            _ulNumber = (_Multiply(_ulNumber, ulB) + 1) % ULONG_MAX;
            *pldblNumber = ldblRange * _Floater() + ldblMinVal;
        }
        else if (ldblRange == 0.0)
        {
            *pldblNumber = ldblMinVal;
        }
        else
        {
            _usRet = DG_RC_BAD_VALUES;
        }
    }
    else
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
    }
    return _usRet;
}
#endif // FLAT


//+---------------------------------------------------------------------------
//
//     Member:  DG_REAL::Generate(@), public
//
//   Synopsis:  All other floating point data type generator functions
//              operate by calling the LDOUBLE generator function and
//              casting the arguments appropriately.
//
//  Arguments:  [*p@Number] - pointer to storage for the particular data
//                            type desired.
//
//              [@MinVal] - minimum value desired as a random number.
//
//              [@MaxVal] - maximum value desired as a random number.
//
//    Returns:  Returns what is produced by the LDOUBLE Generate member
//              function, cast appropriately.
//
//  Algorithm:  See the Generate(LDOUBLE) member function.
//
//      Notes:
//
//    History:  11-Mar-92  RonJo     Created.
//
//              21-Oct-92  RonJo     Made the DOUBLE version stand alone, and
//                                   the FLOAT version use it because Win32/NT
//                                   does not support long doubles.
//
//----------------------------------------------------------------------------

USHORT DG_REAL::Generate(DOUBLE *pdblNumber, DOUBLE dblMinVal, DOUBLE dblMaxVal)
{
    if (pdblNumber != NULL)
    {
        // Get the range.
        //
        DOUBLE dblRange = dblMaxVal - dblMinVal;

        if (dblRange > 0.0)
        {
            const ULONG ulB = 602300421;

            _ulNumber = (_Multiply(_ulNumber, ulB) + 1) % ULONG_MAX;
            *pdblNumber = dblRange * _Floater() + dblMinVal;
        }
        else if (dblRange == 0.0)
        {
            *pdblNumber = dblMinVal;
        }
        else
        {
            _usRet = DG_RC_BAD_VALUES;
        }
    }
    else
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
    }
    return _usRet;
}

USHORT DG_REAL::Generate(FLOAT *pfltNumber, FLOAT fltMinVal, FLOAT fltMaxVal)
{
    // Perform argument error checking.
    //
    if (pfltNumber == NULL)
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
        return _usRet;
    }

    // Make space for the cast variables.
    //
    DOUBLE dblNumber;
    DOUBLE dblMinVal = (DOUBLE)fltMinVal;
    DOUBLE dblMaxVal = (DOUBLE)fltMaxVal;

    // Call the DOUBLE version to do the work.
    //
    (VOID)Generate(&dblNumber, dblMinVal, dblMaxVal);

    // If it went OK, assign the value.
    //
    if (_usRet == DG_RC_SUCCESS)
    {
        *pfltNumber = (FLOAT)dblNumber;
    }
    return _usRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\datagen\dg_bstr.cxx ===
//+---------------------------------------------------------------------------
//
//   Copyright (C) 1991, 1992 Microsoft Corporation.
//
//       File:  DG_BSTR.cxx
//
//   Contents:  Definition for DataGen DG_BSTR class.
//
//    Classes:  DG_BSTR    - Class to generate 16-bit random strings.
//
//  Functions:  DG_BSTR::DG_BSTR()
//              DG_BSTR::Generate()      A few varieties
//
//    History:  21-Mar-94  RickTu     Created. (Taken from DG_UNICODE).
//              12-Apr-96  MikeW      BSTR's are based off of OLECHAR not
//                                    WCHAR (for the Macintosh)
//
//----------------------------------------------------------------------------
#include <comtpch.hxx>
#pragma  hdrstop

#include <dg.hxx>
#include <math.h>
#include <time.h>


#ifdef DOCGEN
//+---------------------------------------------------------------------------
//
//     Member:  DG_BSTR::DG_BSTR, public
//
//   Synopsis:  Calls DG_UNICODE class constructor, and initializes _fNull.
//
//  Arguments:  [ulNewSeed] - the seed value to use as the internal seed.
//
//   Modifies:  _fNull
//
//  Algorithm:  Calls the DG_UNICODE constructor, and initializes _fNull.
//
//      Notes:  Implemented as an inline function.  See dg.hxx.
//
//    History:  21-Mar-94  RickTu     Created. (Taken from DG_UNICODE).
//
//----------------------------------------------------------------------------

DG_BSTR::DG_BSTR(ULONG ulNewSeed)
{
    //
    // Implemented as an inline function.
    //
}
#endif


//+---------------------------------------------------------------------------
//
//     Member:  DG_BSTR::Generate(range), public
//
//   Synopsis:  Produces a random ole character, random length string.
//              The "randomness" of the characters may be constrained by
//              value parameters passed to the function, and the length
//              by length parameters passed to the function.
//
//  Arguments:  [*pbstrString] - pointer to where the pointer to the string
//                               will be stored upon success of the function.
//
//              [*pulLength] - pointer to where the length of the string
//                             will be stored up success of the function.
//
//              [wchMinVal] - minimum value that a character may have.
//
//              [wchMaxVal] - maximum value that a character may have.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_OUT_OF_MEMORY -- if memory for the string cannot be
//                                     allocated.
//
//              DG_RC_BAD_STRING_PTR -- if the string pointer argument passed
//                                      in is invalid.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number pointer argument passed
//                                      in is invalid.
//
//              DG_RC_BAD_VALUES  -- if the minimum value is greater than the
//                                   maximum value.
//
//              DG_RC_BAD_LENGTHS  -- if the minimum length is greater than the
//                                    maximum length.
//
//  Algorithm:  Allocate memory according to the length constraints, then
//              use the integer generator to fill in the string.
//
//    History:  21-Mar-94  RickTu     Created.
//
//----------------------------------------------------------------------------

USHORT DG_BSTR::Generate(BSTR   *pbstrString,
                         ULONG    *pulLength,
                         OLECHAR   chMinVal,
                         OLECHAR   chMaxVal,
                         ULONG     ulMinLen,
                         ULONG     ulMaxLen)
{

    OLECHAR * pch;
    USHORT  usRC;

    //
    // DG_ASCII wants unsigned chars not chars and OLECHAR is a char on Mac
    //

#if defined(_MAC)
    typedef UCHAR BSTR_CHAR;
#else // !_MAC
    typedef WCHAR BSTR_CHAR;
#endif // !_MAC

    //
    // The only argument check we need to do is on pbstrString, the
    // rest of the arguments will be validated in the call to
    // DG_INTEGER::Generate
    //

    if (pbstrString==NULL)
    {
        return( DG_RC_BAD_STRING_PTR );
    }

    //
    // We're going to first create an Ole string, and then
    // turn it into a BSTR.
    //

    usRC = DG_BSTR_BASE::Generate((BSTR_CHAR **) &pch,
                                 pulLength,
                                 (BSTR_CHAR) chMinVal,
                                 (BSTR_CHAR) chMaxVal,
                                 ulMinLen,
                                 ulMaxLen
                                );

    if (usRC == DG_RC_SUCCESS)
    {
        *pbstrString = SysAllocStringLen( pch, *pulLength );
        delete [] pch;
        if (*pbstrString)
        {
            return( DG_RC_SUCCESS );
        }
        else
        {
            return( DG_RC_OUT_OF_MEMORY );
        }
    }
    else
    {
        pbstrString = NULL;
        return( usRC );
    }

}


//+---------------------------------------------------------------------------
//
//     Member:  DG_BSTR::Generate(NULL), public
//
//   Synopsis:  Generates a random Ole character BSTR.
//
//  Arguments:  [**pbstrString] - pointer to where the pointer to the BSTR
//                                will be stored upon success of the function.
//
//              [wchMinVal] - minimum value that a character may have.
//
//              [wchMaxVal] - maximum value that a character may have.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  See the Generate(range) member function.
//
//  Algorithm:  Call the Generate(range) member
//              function to do the actual work.
//
//      Notes:
//
//    History:  21-Mar-94  RickTu     Created.
//
//----------------------------------------------------------------------------

USHORT DG_BSTR::Generate(BSTR  *pbstrString,
                         OLECHAR   chMinVal,
                         OLECHAR   chMaxVal,
                         ULONG     ulMinLen,
                         ULONG     ulMaxLen)
{
    ULONG ulLength;
    return(Generate(pbstrString,
                    &ulLength,
                    chMinVal,
                    chMaxVal,
                    ulMinLen,
                    ulMaxLen));


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\datagen\dg_base.cxx ===
//+---------------------------------------------------------------------------
//
//   Copyright (C) 1991, 1992 Microsoft Corporation.
//
//       File:  DG_BASE.cxx
//
//   Contents:  Definition for DataGen DG_BASE class.
//
//    Classes:  DG_BASE    - Base class for all DataGen classes.
//
//  Functions:  DG_BASE::DG_BASE()
//              DG_BASE::~DG_BASE()
//              DG_BASE::SetSeed()
//              DG_BASE::GetSeed()
//              DG_BASE::Error()
//              DG_BASE::_Multiply()
//              DG_BASE::_Floater()
//              DG_BASE::_BitReverse()
//
//    History:  16-Sep-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Moved Error() member function form
//                                   DATAGEN class to DG_BASE class.
//
//              11-Mar-92  RonJo     Ported to Win32 and separated DG and
//                                   DataGen functionality.
//
//              04-Apr-95  DarrylA   Changed ULONG_MAX_SQRT calc to compile
//                                   time bit operation.
//
//----------------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <dg.hxx>
#include <math.h>
#include <time.h>


//
// CLASS WIDE VARIABLES
//

// To get the max sqrt, figure as follows.
// 0xffff = (2^16)-1
// sqrt(2^16) = 2^8
// We need the next smallest sqrt which is (2^8)-1, which is half the bits
// set in the original value, or max_sqrt(0xffff) = 0xff.
// So, right shift the number by half the number of bytes * bits-per-byte.

// Note that this is only valid if ULONG_MAX == ~(0U), otherwise the
// result may be too big. While this is probably always true, we will
// guarantee this here.

#if !(ULONG_MAX == 0xffffffffUL)
#error ULONG_MAX not as expected
#endif

ULONG DG_BASE::ULONG_MAX_SQRT = (ULONG_MAX >> ((sizeof(ULONG) * 8) / 2));


//+---------------------------------------------------------------------------
//
//     Member:  DG_BASE::DG_BASE, public
//
//   Synopsis:  Sets static member data ULONG_MAX_SQRT and calls SetSeed to
//              do the rest.
//
//  Arguments:  [ulNewSeed] -- The seed value to use as the internal seed.
//
//  Algorithm:  Sets ULONG_MAX_SQRT is it has not already been set,
//              initializes the return variable and the error strings,
//              and then calls SetSeed to do the rest of the work.
//
//      Notes:
//
//    History:  16-Sep-91  RonJo     Created.
//
//              25-Nov-91  RonJo     Added initialization of return variable
//                                   and the error strings.
//
//----------------------------------------------------------------------------

DG_BASE::DG_BASE(ULONG ulNewSeed)
{
    // Initialize the return variable and the error strings.
    //
    _usRet = DG_RC_SUCCESS;

    // Let SetSeed do the rest of the work.
    //
    (VOID)SetSeed(ulNewSeed);
}


#ifdef DOCGEN
//+---------------------------------------------------------------------------
//
//     Member:  DG_BASE::~DG_BASE, public
//
//   Synopsis:  Performs no function at this time.
//
//  Arguments:  None.
//
//  Algorithm:
//
//      Notes:  Implemented as an inline function.  See DataGen.hxx.
//
//    History:  16-Sep-91  RonJo     Created.
//
//----------------------------------------------------------------------------

DG_BASE::~DG_BASE(void)
{
    //
    // Implemented as an inline function.
    //
}
#endif  // DOCGEN


//+---------------------------------------------------------------------------
//
//     Member:  DG_BASE::SetSeed, public
//
//   Synopsis:  Sets up the random number tables based upon the new internal
//              seed.
//
//  Arguments:  [ulNewSeed] - the value to use as the new internal seed,
//                            _ulSeed.
//
//    Returns:  Always DG_RC_SUCCESS
//
//   Modifies:  _ulSeed
//              _ulNumber
//
//  Algorithm:  Sets the _ulSeed to ulNewSeed.  If _ulNewSeed is 0, then set
//              _ulSeed to the time.  Take _ulSeed, reverse the bits and xor
//              the result with _ulSeed to get the base number, _ulNumber.
//
//      Notes:
//
//    History:  16-Sep-91  RonJo     Created.
//
//----------------------------------------------------------------------------

USHORT DG_BASE::SetSeed(ULONG ulNewSeed)
{

    // If the new seed value is 0, set _ulSeed to the time, otherwise set
    // it to the seed value given.  GetTickCount gives a much more accurate
    // timing value, but it is not available under win16.
    //
#ifdef WIN16
    _ulSeed = (ulNewSeed == 0) ? (ULONG)time(NULL) : ulNewSeed;
#else
    _ulSeed = (ulNewSeed == 0) ? (ULONG)GetTickCount() : ulNewSeed;
#endif

    // Reverse the bits of the _ulSeed.
    //
    ULONG ulRevSeed = 0;
    _BitReverse(&_ulSeed, sizeof(ULONG), &ulRevSeed);
    // The base number is the xor of the _ulSeed and its bit reverse.
    //
    _ulNumber = _ulSeed ^ ulRevSeed;
    //
    // Allow for alternate random # generation
    //
    srand(_ulSeed);

    return DG_RC_SUCCESS;

}


//+---------------------------------------------------------------------------
//
//     Member:  DG_BASE::GetSeed, public
//
//   Synopsis:  Returns the internal seed value using the passed in pointer.
//
//  Arguments:  [*pulSeed] - pointer to where the user wants the internal
//                           seed value stored.
//
//    Returns:  DG_RC_SUCCESS -- if successful.
//
//   Modifies:  _usRet
//
//  Algorithm:  Sets *pulSeed to _ulSeed if pulSeed is not NULL.
//
//      Notes:  Implemented as an inline functions.  See DataGen.hxx.
//
//    History:  16-Sep-91  RonJo     Created.
//
//----------------------------------------------------------------------------

USHORT DG_BASE::GetSeed(ULONG *pulSeed)
{
    if (pulSeed != NULL)
    {
        *pulSeed = _ulSeed;
    }
    else
    {
        _usRet = DG_RC_BAD_NUMBER_PTR;
    }
    return _usRet;
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_BASE::_Multiply, protected
//
//   Synopsis:  Multiplies 2 unsigned long integers, ensuring that the result
//              does not produce overflow.
//
//  Arguments:  [ul1, ul2] - the 2 multiplication operands.
//
//    Returns:  Returns the result of the multiplication.
//
//  Algorithm:  By breaking down the operands into pieces less than the
//              square root of ULONG_MAX, we can garuantee that we will
//              not overflow.  The various pieces are then multiplied,
//              moduloed again, multiplied by the modulo value, the 2
//              moduloed pieces are mulitplied and added to the first
//              part of the result, and the final result is given a
//              final modulo by the maximum value.
//
//      Notes:  See _Algorithms in C_ by Robert Sedgewick for a full
//              explanation of this algorithm.
//
//    History:  28-Sep-91  RonJo     Created.
//
//----------------------------------------------------------------------------

ULONG DG_BASE::_Multiply(ULONG ulP, ULONG ulQ)
{

    // Assign variables for the different components of the arguement
    // breakdown.
    //
    ULONG ulP1 = ulP / ULONG_MAX_SQRT;
    ULONG ulP0 = ulP % ULONG_MAX_SQRT;
    ULONG ulQ1 = ulQ / ULONG_MAX_SQRT;
    ULONG ulQ0 = ulQ % ULONG_MAX_SQRT;

    // Return the result of the calculation.
    //
    return ((((ulP0 * ulQ1) + (ulP1 * ulQ0)) % ULONG_MAX_SQRT) * ULONG_MAX_SQRT + (ulP0 * ulQ0) % ULONG_MAX);

}


//+---------------------------------------------------------------------------
//
//     Member:  DG_BASE::_Floater, protected
//
//   Synopsis:  Using the base number, returns a floating point number
//              between 0 and 1 [0, 1).
//
//  Arguments:  None.
//
//   Modifies:  _ulNumber
//
//  Algorithm:  Multiply the base number by a constant, add 1, and take the
//              modulo of the maximum unsigned long number.  Replace the
//              base number with this result, then divide the new base number
//              by the maximum unsigned long number to get a number in the
//              range [0, 1).
//
//      Notes:  This function is primarily meant to produce probabilities
//              for selection algorithms used elsewhere.
//
//              See _Algorithms in C_ by Robert Sedgewick for constant, ulB,
//              selection.
//
//    History:  03-Oct-91  RonJo     Created.
//
//----------------------------------------------------------------------------

FLOAT DG_BASE::_Floater()
{
    const ULONG ulB = 602300421;

    _ulNumber = (_Multiply(_ulNumber, ulB) + 1) % ULONG_MAX;
    return((FLOAT)_ulNumber / (FLOAT)ULONG_MAX);
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_BASE::_BitReverse, private
//
//   Synopsis:  Reverses the bit ordering of a byte stream.
//
//  Arguments:  [*pvStream] -- Pointer to the stream of bytes to be bit
//                             reversed.
//
//              [cBytes] -- The number of bytes in the byte stream.
//
//              [pvRevStream] -- Pointer to the caller provided buffer to
//                               return the reversed bit byte stream.
//
//    Returns:  None
//
//   Modifies:  _usRet
//
//  Algorithm:  Reverses the bits in individual bytes while reversing the
//              byte order.
//
//      Notes:
//
//    History:  19-Sep-91  RonJo     Created.
//
//----------------------------------------------------------------------------

VOID DG_BASE::_BitReverse(VOID *pvStream, USHORT cBytes, VOID *pvRevStream)
{
    // Assign a constant to point to the top bit.  This assumes an 8 bit
    // byte and is the only assumption in the routine.  If you are using
    // a platform that has a different size byte, then this constant must
    // be changed.
    //
    const BYTE bTop = 0x80;

    // Assign pointers for overall reference to each byte stream.
    //
    BYTE *pbSrc = (BYTE *)pvStream;
    BYTE *pbDst = (BYTE *)pvRevStream;

    // Assign pointers for reference to each byte in the byte streams.
    // The source pointer starts at the beginning of the source stream,
    // whereas the destination points starts at the end of the destina-
    // tion stream.
    //
    BYTE *pbS = pbSrc;
    BYTE *pbD = pbDst + cBytes - 1;

    // Assign counter variables and a masking variable.
    //
    register i;
    BYTE bMask;

    // Loop through all the bytes in the stream.
    //
    while (cBytes > 0)
    {
        // Loop through the upper nibble of the source byte, putting the
        // bits in the lower nibble of the destination byte.
        //
        i = CHAR_BIT - 1;
        bMask = bTop;
        while (i > 0)
        {
            *pbD |= (*pbS & bMask) >> i;
            i--; i--;  // This is faster than i -= 2
            bMask >>= 1;
        }

        // Loop through the lower nibble of the source byte, putting the
        // bits in the upper nibble of the destination byte.
        //
        i = 1;
        while (i < CHAR_BIT)
        {
            *pbD |= (*pbS & bMask) << i;
            i++; i++;  // This is faster than i += 2
            bMask >>= 1;
        }

        // Move the respective byte pointers "up" their relative streams,
        // and deal with the next pair of bytes.
        //
        pbS++;
        pbD--;
        cBytes--;
    }

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\datagen\pch.cxx ===
//+------------------------------------------------------------------
//
// File:        pch.cxx
//
// Contents:    precompiled headers for dg.lib
//
// Synoposis:
//
// Classes:
//
// Functions:
//
// History:     10/18/93    DeanE   Created
//
//-------------------------------------------------------------------
#include "pch.hxx"

#pragma  hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\datagen\dg_uni.cxx ===
//+---------------------------------------------------------------------------
//
//   Copyright (C) 1991, 1992 Microsoft Corporation.
//
//       File:  DG_UNICODE.cxx
//
//   Contents:  Definition for DataGen DG_UNICODE class.
//
//    Classes:  DG_UNICODE    - Class to generate 8-bit random strings.
//
//  Functions:  DG_UNICODE::DG_UNICODE()
//              DG_UNICODE::Generate()      All varieties
//              DG_UNICODE::_LenMem()
//
//    History:  13-Mar-92  RonJo     Created.
//
//----------------------------------------------------------------------------
#include <comtpch.hxx>
#pragma  hdrstop

#include <dg.hxx>
#include <math.h>
#include <time.h>


#ifdef DOCGEN
//+---------------------------------------------------------------------------
//
//     Member:  DG_UNICODE::DG_UNICODE, public
//
//   Synopsis:  Calls DG_INTEGER class constructor, and initializes _fNull.
//
//  Arguments:  [ulNewSeed] - the seed value to use as the internal seed.
//
//   Modifies:  _fNull
//
//  Algorithm:  Calls the DG_INTEGER constructor, and initializes _fNull.
//
//      Notes:  Implemented as an inline function.  See DataGen.hxx.
//
//    History:  13-Mar-92  RonJo     Created.
//
//----------------------------------------------------------------------------

DG_UNICODE::DG_UNICODE(ULONG ulNewSeed)
{
    //
    // Implemented as an inline function.
    //
}
#endif


//+---------------------------------------------------------------------------
//
//     Member:  DG_UNICODE::Generate(range), public
//
//   Synopsis:  Produces a random 16-bit character, random length string.
//              The "randomness" of the characters may be constrained by
//              value parameters passed to the function, and the length
//              by length parameters passed to the function.
//
//  Arguments:  [**pwchString] - pointer to where the pointer to the string
//                               will be stored up success of the function.
//
//              [*pulLength] - pointer to where the length of the string
//                             will be stored up success of the function.
//
//              [wchMinVal] - minimum value that a character may have.
//
//              [wchMaxVal] - maximum value that a character may have.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_OUT_OF_MEMORY -- if memory for the string cannot be
//                                     allocated.
//
//              DG_RC_BAD_STRING_PTR -- if the string pointer argument passed
//                                      in is invalid.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number pointer argument passed
//                                      in is invalid.
//
//              DG_RC_BAD_VALUES  -- if the minimum value is greater than the
//                                   maximum value.
//
//              DG_RC_BAD_LENGTHS  -- if the minimum length is greater than the
//                                    maximum length.
//
//   Modifies:  _usRet
//
//  Algorithm:  Allocate memory according to the length constraints, then
//              use the integer generator to fill in the string.
//
//      Notes:  At this time, only wide character support is provided.  When
//              true UNICODE fuctionality becomes available in Win32, it will
//              be added here.
//
//    History:  13-Mar-92  RonJo     Created.
//
//----------------------------------------------------------------------------

USHORT DG_UNICODE::Generate(WCHAR **pwchString,
                            ULONG   *pulLength,
                            WCHAR    wchMinVal,
                            WCHAR    wchMaxVal,
                            ULONG     ulMinLen,
                            ULONG     ulMaxLen)
{
    // Ensure that the length values are OK, and allocate the string
    // memory.
    //
    (VOID)_LenMem(pwchString, pulLength, ulMinLen, ulMaxLen);
    if (_usRet != DG_RC_SUCCESS)
    {
        return _usRet;
    }

    // Now just fill in the string with random characters.
    //
    ULONG i = *pulLength;
    while(i-- > 0)
    {
        WCHAR wch;
        _usRet = DG_INTEGER::Generate(&wch, wchMinVal, wchMaxVal);
        if (_usRet == DG_RC_SUCCESS)
        {
            (*pwchString)[i] = wch;
        }
        else
        {
            // Something went wrong, so free up the memory and stick a
            // NULL into the pointer.
            //
            delete [] *pwchString;
            *pwchString = NULL;
            *pulLength = 0;
            break;
        }
    }

    // We're all done so return.
    //
    return _usRet;
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_UNICODE::Generate(NULL), public
//
//   Synopsis:  Generates a NULL terminated string by setting the _fNull
//              variable to TRUE, which causes an extra space containing
//              the NULL character to be put at the end the string, casting
//              the appropriate arguments, and calling the Generate(range)
//              member function to perform the actual work.
//
//  Arguments:  [**pwcsString] - pointer to where the pointer to the string
//                               will be stored up success of the function.
//
//              [wchMinVal] - minimum value that a character may have.
//
//              [wchMaxVal] - maximum value that a character may have.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  See the Generate(range) member function.
//
//   Modifies:  _fNull
//
//  Algorithm:  Set _fNull to TRUE and call the Generate(range) member
//              function to do the actual work.
//
//      Notes:
//
//    History:  19-May-92  RonJo     Created.
//
//----------------------------------------------------------------------------

USHORT DG_UNICODE::Generate(WCHAR **pwszString,
                            WCHAR    wchMinVal,
                            WCHAR    wchMaxVal,
                            ULONG     ulMinLen,
                            ULONG     ulMaxLen)
{
    _fNull = TRUE;
    ULONG ulLength;
    return Generate((WCHAR **)pwszString,
                               &ulLength,
                               wchMinVal,
                               wchMaxVal,
                                ulMinLen,
                                ulMaxLen);
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_UNICODE::Generate(selection), public
//
//
//   Synopsis:  Produces a random 16-bit character, random length string.
//              The "randomness" of the characters is constrained by the
//              characters in the selection argument, and the length may be
//              constrained by the length parameters passed to the function.
//
//  Arguments:  [**pwchString] - pointer to where the pointer to the string
//                               will be stored up success of the function.
//
//              [*pulLength] - pointer to where the length of the string
//                             will be stored up success of the function.
//
//              [*pwchSelection] - the selection string from which char-
//                                 acters are chosen at random.
//
//              [ulSelLength] - the length of the selection string.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_OUT_OF_MEMORY -- if memory for the string cannot be
//                                  allocated.
//
//              DG_RC_BAD_STRING_PTR -- if the string pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_LENGTHS  -- if the minimum length is greater than the
//                                 maximum length.
//
//   Modifies:  _usRet
//
//  Algorithm:  Allocate memory according to the length constraints, then
//              repeatedly uses the integer generator to pick a character
//              from the selection to insert into the string until the
//              string is full.
//
//      Notes:  The probability of a given character being selected from
//              the selection string is directly related to the number of
//              times that character appears in the selection string.
//
//    History:  13-Mar-92  RonJo     Created.
//
//----------------------------------------------------------------------------

USHORT DG_UNICODE::Generate(WCHAR **pwchString,
                            ULONG   *pulLength,
                            WCHAR  *pwchSelection,
                            ULONG     ulSelLength,
                            ULONG     ulMinLen,
                            ULONG     ulMaxLen)
{
    // Handle the special cases of:
    //   1) the pwchSelection being NULL
    //   2) the pwchSelection argument is empty (ulSelLength = 0)
    //
    if (pwchSelection == NULL)
    {
        return Generate(pwchString,
                        pulLength,
                        (WCHAR)0,
                        WCHAR_MAX,
                        ulMinLen,
                        ulMaxLen);
    }
    if (ulSelLength == 0)
    {
        *pwchString = NULL;
        *pulLength = 0;
        return _usRet;
    }

    // Ensure that the length values are OK, and allocate the string
    // memory.
    //
    (VOID)_LenMem(pwchString, pulLength, ulMinLen, ulMaxLen);
    if (_usRet != DG_RC_SUCCESS)
    {
        return _usRet;
    }

    // Now just fill in the string with characters randomly chosen from
    // the selection string.
    //
    ULONG i = *pulLength;
    while(i-- > 0)
    {
        ULONG ul;
        _usRet = DG_INTEGER::Generate(&ul, 0L, ulSelLength - 1L);
        if (_usRet == DG_RC_SUCCESS)
        {
            (*pwchString)[i] = pwchSelection[ul];
        }
        else
        {
            // Something went wrong, so free up the memory and stick a
            // NULL into the pointer.
            //
            delete [] *pwchString;
            *pwchString = NULL;
            *pulLength = 0;
            break;
        }
    }

    // We're all done so return.
    //
    return _usRet;
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_UNICODE::Generate(selection, NULL), public
//
//
//   Synopsis:  Produces a random 16-bit character, random length, NULL-
//              terminated string.
//              The "randomness" of the characters is constrained by the
//              characters in the selection argument, and the length may be
//              constrained by the length parameters passed to the function.
//
//  Arguments:  [**pwszString] - pointer to where the pointer to the string
//                               will be stored up success of the function.
//
//              [*pwszSelection] - the selection string from which char-
//                                 acters are chosen at random.
//
//              [ulMinLen] - minimum length that the string may be.
//
//              [ulMaxLen] - maximum length that the string may be.
//
//    Returns:  DG_RC_SUCCESS  -- if successful.
//
//              DG_RC_OUT_OF_MEMORY -- if memory for the string cannot be
//                                  allocated.
//
//              DG_RC_BAD_STRING_PTR -- if the string pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_NUMBER_PTR -- if the number pointer argument passed
//                                   in is invalid.
//
//              DG_RC_BAD_LENGTHS  -- if the minimum length is greater than the
//                                 maximum length.
//
//   Modifies:  _usRet
//
//  Algorithm:  Allocate memory according to the length constraints, then
//              repeatedly uses the integer generator to pick a character
//              from the selection to insert into the string until the
//              string is full.
//
//      Notes:  The probability of a given character being selected from
//              the selection string is directly related to the number of
//              times that character appears in the selection string.
//
//    History:  8-Jun-92  DeanE     Cut & paste from Generate(NULL).
//
//----------------------------------------------------------------------------

USHORT DG_UNICODE::Generate(WCHAR **pwszString,
                            WCHAR  *pwszSelection,
                            ULONG   ulMinLen,
                            ULONG   ulMaxLen)
{
    _fNull = TRUE;
    ULONG ulLength;
    ULONG ulSelLength;
    ulSelLength = wcslen(pwszSelection);
    return Generate(pwszString,
                    &ulLength,
                    pwszSelection,
                    ulSelLength,
                    ulMinLen,
                    ulMaxLen);
}


//+---------------------------------------------------------------------------
//
//     Member:  DG_UNICODE::_LenMem, private
//
//   Synopsis:  Determine the size needed to create the ASCII string, and
//              then allocate that much memory for it.
//
//  Arguments:  [**pwchString] - pointer to the pointer which will point to
//                               the beginning memory for the string.
//
//              [*pulLength] - pointer to the memory in which to store the
//                             length of the string.
//
//              [ulMinLen] - the minimum length of the string.
//
//              [ulMaxLen] - the maximum length of the string.
//
//    Returns:  DG_RC_SUCCESS -- if successful.
//
//              DG_RC_BAD_STRING_PTR -- if the string location pointer is
//                                      NULL.
//
//              DG_RC_BAD_LENGTH_PTR -- if the length location pointer is
//                                      NULL.
//
//              DG_RC_BAD_LENGTHS -- if the minimum length is greater than
//                                   the maximum lengths.
//
//              DG_RC_OUT_OF_MEMORY -- if space for the string cannot be
//                                     allocated.
//
//  Algorithm:  Verify the arguments.  Then if this is the default case,
//              generate a length with an expected value of 5 (see section
//              4.3 of the DataGen Design Specification for details).  If
//              this is not the default case, then generate a length using
//              the values provided.
//
//      Notes:
//
//    History:  13-Mar-92  RonJo     Created.
//
//----------------------------------------------------------------------------

VOID DG_UNICODE::_LenMem(WCHAR **pwchString,
                         ULONG   *pulLength,
                         ULONG     ulMinLen,
                         ULONG     ulMaxLen)
{
    // This value will produce an expected string length of 5 in
    // the default case.  Hence the name 'E5'.
    //
    const FLOAT E5 = 0.20F;

    // Perform parameter checks.
    //
    if (pwchString == NULL)
    {
        _usRet = DG_RC_BAD_STRING_PTR;
        return;
    }
    else if (pulLength == NULL)
    {
        _usRet = DG_RC_BAD_LENGTH_PTR;
        return;
    }
    else if (ulMinLen > ulMaxLen)
    {
        _usRet = DG_RC_BAD_LENGTHS;
        return;
    }

    // If the default case is being used, then generate a length with the
    // expected value of 5.  Otherwise generate a number from the range
    // values given.  See section 4 of the DataGen Design Specification
    // for details.
    //
    if ((ulMinLen == 1) && (ulMaxLen == DG_DEFAULT_MAXLEN))
    {
        *pulLength = ulMinLen;
        while ((*pulLength < ulMaxLen) && (_Floater() > E5))
        {
            (*pulLength)++;
        }
    }
    else
    {
        ULONG ul;
        _usRet = DG_INTEGER::Generate(&ul, ulMinLen, ulMaxLen);
        if (_usRet == DG_RC_SUCCESS)
        {
            *pulLength = ul;
        }
        else
        {
            // Something went wrong, so stick a NULL
            // into the pointer, and a 0 into the length.
            //
            *pwchString = NULL;
            *pulLength = 0;
            return;
        }
    }

    // Allocate memory based on the length.  If _fNull is true, then add 1
    // extra character for a terminating NULL character.  _fNull will be
    // true whenever we are generating a NULL terminated string.
    //
    if (_fNull == TRUE)
    {
        *pwchString = new WCHAR[*pulLength + 1];
        if (*pwchString != NULL)
        {
            (*pwchString)[*pulLength] = (WCHAR)0;
            _fNull = FALSE;
        }
    }
    else
    {
        *pwchString = new WCHAR[*pulLength];
    }

    // Check for errors.
    //
    if (*pwchString == NULL)
    {
        _usRet = DG_RC_OUT_OF_MEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\h\comtpch.cxx ===
//+------------------------------------------------------------------
//
// File:        comtpch.cxx
//
// Contents:    headers to precompile when building all directories
//              in common.
//
// History:     19-Nov-94   DaveY   Created
//
//-------------------------------------------------------------------

#include <comtpch.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\h\dummy.cxx ===
#include "comtpch.hxx"
#pragma hdrstop

void pch_dummy_function()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\h\diswarn.h ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      diswarn.h
//
//  Contents:  Pragma's to disable specific warnings at W4
//             This file is included through the use of the 
//             COMPILER_WARNING macro in build make files.
//             EG see the comtools\comday.mk file.
//
//  History:   02-Aug-95        DaveY   Taken from CTOLEUI's killwarn.hxx
//
//
//--------------------------------------------------------------------------
#ifndef __DISWARN_H__
#define __DISWARN_H__

//
// NT groups overall disable warning in sdk\inc\warning.h
//

#ifndef _MAC
#include <warning.h>
#endif


//
//  Removal of these warnings is temporary.  The reason for being here
//  is that build removes these warnings from build.wrn.
//  BUGBUG These are here for now, until they can be investigated more.
//


#pragma warning(disable: 4001)
#pragma warning(disable: 4010)
#pragma warning(disable: 4056)
#pragma warning(disable: 4061)
#pragma warning(disable: 4100)
#pragma warning(disable: 4101)
#pragma warning(disable: 4102)
#pragma warning(disable: 4127)
#pragma warning(disable: 4135)
#pragma warning(disable: 4201)
#pragma warning(disable: 4204)
#pragma warning(disable: 4208)
#pragma warning(disable: 4509)
#pragma warning(disable: 4047)
#pragma warning(disable: 4022)
#pragma warning(disable: 4053)


// these mainly come from midl files
#pragma warning(disable: 4211)
#pragma warning(disable: 4152)

//
// Turn off: access-declarations are deprecated; member using-declarations 
// provide a better alternative
//
#pragma warning(disable: 4516)


// Turn off: non standard extension used: bit field types other than int
//
#pragma warning(disable: 4214)


// Turn off: unreferenced inline function has been removed
//
#pragma warning(disable: 4514)


// nonstandard extension used : nameless struct/union
//
// Microsoft C/C++ allows structure declarations to be specified without a
// declarator when they are members of another structure or union.
// The following is an example of this error:
//
// struct S
// {
//      float y;
//      struct
//      {
//          int a, b, c;  // warning
//      };
// } *p_s;
//
//
// This extension can prevent your code from being portable to other
// compilers and will generate an error under the /Za command-line option.

#pragma warning(disable: 4201)


// Turn off: Macro not expanded
//
#pragma warning(disable: 4710)


// 'class' : copy constructor could not be generated
//
// The compiler was unable to generate a default constructor for the given
// class. No constructor was created.
//
// This warning can be caused by having an copy  operator for the
// base class that is not accessible by the derived class.
//
// This warning can be avoided by specifying a copy constructor for the class.

#pragma warning(disable: 4511)


// 'class' : assignment operator could not be generated
//
// The compiler was unable to generate a default constructor for the given
// class. No constructor was created.
//
// This warning can be caused by having an assignment operator for the
// base class that is not accessible by the derived class.
//
// This warning can be avoided by specifying a user-defined assignment
// operator for the class.

#pragma warning(disable: 4512)


#ifdef PPC

// Turn off for PPC only since PPC compiler doesn't get it right
// local variable may be used without having been initialized.
//
#pragma warning(disable: 4701)

#endif



#ifdef _MAC

// Turn off for _MAC only because it doesn't handle trigraphs in comments
// correctly
#pragma warning(disable: 4110)

// The Mac OS headers generate this
#pragma warning (disable: 4121)
#endif // _MAC

#endif  // __DISWARN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\h\uisift.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       uisift.h
//
//  Contents:   function declarations and macros for using sift code from C
//
//  History:    7-05-94   t-chripi   Created
//	   3-08-95   ericn       changed linkeage of C functions
//
//----------------------------------------------------------------------------

#ifndef __UISIFT_H__

#define __UISIFT_H__

//Sift success/error values

#define SIFT_NO_ERROR              0
#define SIFT_ERROR_BASE            10000
#define SIFT_ERROR_OUT_OF_MEMORY   (SIFT_ERROR_BASE+3)
#define SIFT_ERROR_INVALID_VALUE   (SIFT_ERROR_BASE+4)

#if defined(NOSIFT) || defined(WIN16) || defined(WIN32S) || (WIN32 == 200)

//  NULL out macros if Win16/Win32s/Chicago or NOSIFT is defined

#define UI_SIFT_INIT(name)
#define UI_SIFT_ON
#define UI_SIFT_OFF
#define UI_SIFT_DECLARE
#define UI_SIFT_DESTROY

#else   //  Win32 only

EXTERN_C VOID UiSiftDeclare(VOID** g_pptsoTestSift);
EXTERN_C VOID UiSiftInit(VOID** g_pptsoTestSift, LPCSTR lpProgName);
EXTERN_C VOID UiSiftOn(VOID** g_pptsoTestSift);
EXTERN_C VOID UiSiftOff(VOID** g_pptsoTestSift);
EXTERN_C VOID UiSiftDestroy(VOID** g_pptsoTestSift);

#define UI_SIFT_INIT(name) \
    UiSiftDeclare(&g_ptsoTestSift);          \
    UiSiftInit(&g_ptsoTestSift, (name))

#define UI_SIFT_ON \
    UiSiftOn(&g_ptsoTestSift)

#define UI_SIFT_OFF \
    UiSiftOff(&g_ptsoTestSift)

#define UI_SIFT_DECLARE             \
    VOID* g_ptsoTestSift

#define UI_SIFT_DESTROY \
    UiSiftDestroy(&g_ptsoTestSift)

#define SVR_SIFT_INIT(name) \
    SvrSiftInit((name))

#endif  // Win32

#endif  // __UISIFT_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\log\pch.cxx ===
//+------------------------------------------------------------------
//
// File:        pch.cxx
//
// Contents:    headers to precompile when building cmdline.lib
//
// Synoposis:
//
// Classes:
//
// Functions:
//
// History:     09/18/92 Lizch  Created
//
//-------------------------------------------------------------------
#include "pch.hxx"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\h\nchar.h ===
//+-------------------------------------------------------------------
//
//  Copyright (c) 1991-1993, Microsoft Corporation. All rights reserved
//
//  File:       nchar.h
//
//  Contents:   Definitions for generic international functions, mostly
//              defines which map string/formatted-io/ctype functions
//              to char, wchar_t versions.  To be used for compatibility
//              between single-byte, multi-byte and Unicode text models.
//
//  Note:       If CTUNICODE is defined then Unicode version is used
//              else Char version is used.
//
//  History:    16-Feb-94   NaveenB		Created
//              04-Oct-96   EricHans	New header from sdk
//				25-Feb-97	MariusB		tchar.h referral support
//
//	Note:
//		Many functionalities contained by this file are covered by the 
//		newer file tchar.h. If you want to replace all your nchar.h 
//		includes with tchar.h includes, just define __TCHAR_ONLY__
//		in your project and you'll receive a compilation error for 
//		each nchar.h inclusion. Email MariusB for any question.
//---------------------------------------------------------------------


#ifndef __NCHAR_HXX__
#define __NCHAR_HXX__

#if _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_NCHAR
#define _INC_NCHAR

#ifdef  _MSC_VER
#pragma warning(disable:4514)       /* disable unwanted C++ /W4 warning */
/* #pragma warning(default:4514) */ /* use this to reenable, if necessary */
#endif  /* _MSC_VER */

#ifdef __TCHAR_ONLY__
#error NCHAR.H is obsolete. Use TCHAR.H instead
#endif

#ifdef  __cplusplus
extern "C" {
#endif


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else   /* ndef _NTSDK */
/* current definition */
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _NTSDK */
#endif  /* _CRTIMP */


#define _fncscat    _ncscat
#define _fncschr    _ncschr
#define _fncscpy    _ncscpy
#define _fncscspn   _ncscspn
#define _fncslen    _ncslen
#define _fncsncat   _ncsncat
#define _fncsncpy   _ncsncpy
#define _fncspbrk   _ncspbrk
#define _fncsrchr   _ncsrchr
#define _fncsspn    _ncsspn
#define _fncsstr    _ncsstr
#define _fncstok    _ncstok

#define _fncsdup    _ncsdup
#define _fncsnset   _ncsnset
#define _fncsrev    _ncsrev
#define _fncsset    _ncsset

#define _fncscmp      _ncscmp
#define _fncsicmp     _ncsicmp
#define _fncsnccmp    _ncsnccmp
#define _fncsncmp     _ncsncmp
#define _fncsncicmp   _ncsncicmp
#define _fncsnicmp    _ncsnicmp

#define _fncscoll     _ncscoll
#define _fncsicoll    _ncsicoll
#define _fncsnccoll   _ncsnccoll
#define _fncsncoll    _ncsncoll
#define _fncsncicoll  _ncsncicoll
#define _fncsnicoll   _ncsnicoll

/* Redundant "logical-character" mappings */

#define _fncsclen   _ncsclen
#define _fncsnccat  _ncsnccat
#define _fncsnccpy  _ncsnccpy
#define _fncsncset  _ncsncset

#define _fncsdec    _ncsdec
#define _fncsinc    _ncsinc
#define _fncsnbcnt  _ncsnbcnt
#define _fncsnccnt  _ncsnccnt
#define _fncsnextc  _ncsnextc
#define _fncsninc   _ncsninc
#define _fncsspnp   _ncsspnp

#define _fncslwr    _ncslwr
#define _fncsupr    _ncsupr

#define _fnclen     _nclen
#define _fnccpy     _nccpy
#define _fnccmp     _nccmp


#ifdef  _CTUNICODE

/* ++++++++++++++++++++ UNICODE ++++++++++++++++++++ */



#ifndef _WCTYPE_N_DEFINED
typedef wchar_t wint_n;
typedef wchar_t wctype_n;
#define _WCTYPE_N_DEFINED
#endif

#ifndef __NCHAR_DEFINED
typedef wchar_t     _NCHAR;
typedef wchar_t     _NSCHAR;
typedef wchar_t     _NUCHAR;
typedef wchar_t     _NXCHAR;
typedef wint_t      _NINT;
#define __NCHAR_DEFINED
#endif

#ifndef _NCHAR_DEFINED
#if     !__STDC__
typedef wchar_t     NCHAR;
#endif
#define _NCHAR_DEFINED
#endif

#define _NEOF       WEOF

#define __TN(x)      L ## x


/* Program */

#define _nmain      wmain
#define _nWinMain   wWinMain
#define _nenviron   _wenviron
#define __nargv     __wargv

/* Formatted i/o */

#define _nprintf    wprintf
#define _fnprintf   fwprintf
#define _sNprintf   swprintf
#define _snNprintf  _snwprintf
#define _vnprintf   vwprintf
#define _vfnprintf  vfwprintf
#define _vsNprintf  vswprintf
#define _vsnNprintf _vsnwprintf
#define _nscanf     wscanf
#define _fnscanf    fwscanf
#define _snscanf    swscanf


/* Unformatted i/o */

#define _fgetnc     fgetwc
#define _fgetnchar  _fgetwchar
#define _fgetns     fgetws
#define _fputnc     fputwc
#define _fputnchar  _fputwchar
#define _fputns     fputws
#define _getnc      getwc
#define _getnchar   getwchar
#define _getns      _getws
#define _putnc      putwc
#define _putnchar   putwchar
#define _putns      _putws
#define _ungetnc    ungetwc


/* String conversion functions */

#define _ncstod     wcstod
#define _ncstol     wcstol
#define _ncstoul    wcstoul

#define _iton       _itow
#define _lton       _ltow
#define _ulton      _ultow
#define _ntoi       _wtoi
#define _ntol       _wtol


/* String functions */

#define _ncscat     wcscat
#define _ncschr     wcschr
#define _ncscpy     wcscpy
#define _ncscspn    wcscspn
#define _ncslen     wcslen
#define _ncsncat    wcsncat
#define _ncsncpy    wcsncpy
#define _ncspbrk    wcspbrk
#define _ncsrchr    wcsrchr
#define _ncsspn     wcsspn
#define _ncsstr     wcsstr
#define _ncstok     wcstok

#define _ncsdup     _wcsdup
#define _ncsnset    _wcsnset
#define _ncsrev     _wcsrev
#define _ncsset     _wcsset

#define _ncscmp     wcscmp
#define _ncsicmp    _wcsicmp
#define _ncsnccmp   wcsncmp
#define _ncsncmp    wcsncmp
#define _ncsncicmp  _wcsnicmp
#define _ncsnicmp   _wcsnicmp

#define _ncscoll    wcscoll
#define _ncsicoll   _wcsicoll
#define _ncsnccoll  _wcsncoll
#define _ncsncoll   _wcsncoll
#define _ncsncicoll _wcsnicoll
#define _ncsnicoll  _wcsnicoll


/* Execute functions */

#define _nexecl     _wexecl
#define _nexecle    _wexecle
#define _nexeclp    _wexeclp
#define _nexeclpe   _wexeclpe
#define _nexecv     _wexecv
#define _nexecve    _wexecve
#define _nexecvp    _wexecvp
#define _nexecvpe   _wexecvpe

#define _nspawnl    _wspawnl
#define _nspawnle   _wspawnle
#define _nspawnlp   _wspawnlp
#define _nspawnlpe  _wspawnlpe
#define _nspawnv    _wspawnv
#define _nspawnve   _wspawnve
#define _nspawnvp   _wspawnvp
#define _nspawnvp   _wspawnvp
#define _nspawnvpe  _wspawnvpe

#define _nsystem    _wsystem


/* Time functions */

#define _nasctime   _wasctime
#define _nctime     _wctime
#define _nstrdate   _wstrdate
#define _nstrtime   _wstrtime
#define _nutime     _wutime
#define _ncsftime   wcsftime


/* Directory functions */

#define _nchdir     _wchdir
#define _ngetcwd    _wgetcwd
#define _ngetdcwd   _wgetdcwd
#define _nmkdir     _wmkdir
#define _nrmdir     _wrmdir


/* Environment/Path functions */

#define _nfullpath  _wfullpath
#define _ngetenv    _wgetenv
#define _nmakepath  _wmakepath
#define _nputenv    _wputenv
#define _nsearchenv _wsearchenv
#define _nsplitpath _wsplitpath


/* Stdio functions */

#define _nfdopen    _wfdopen
#define _nfsopen    _wfsopen
#define _nfopen     _wfopen
#define _nfreopen   _wfreopen
#define _nperror    _wperror
#define _npopen     _wpopen
#define _ntempnam   _wtempnam
#define _ntmpnam    _wtmpnam


/* Io functions */

#define _naccess    _waccess
#define _nchmod     _wchmod
#define _ncreat     _wcreat
#define _nfindfirst _wfindfirst
#define _nfindfirsti64  _wfindfirsti64
#define _nfindnext  _wfindnext
#define _nfindnexti64   _wfindnexti64
#define _nmktemp    _wmktemp
#define _nopen      _wopen
#define _nremove    _wremove
#define _nrename    _wrename
#define _nsopen     _wsopen
#define _nunlink    _wunlink

#define _nfinddata_t    _wfinddata_t
#define _nfinddatai64_t _wfinddatai64_t


/* Stat functions */

#define _nstat      _wstat
#define _nstati64   _wstati64


/* Setlocale functions */

#define _nsetlocale _wsetlocale


/* Redundant "logical-character" mappings */

#define _ncsclen    wcslen
#define _ncsnccat   wcsncat
#define _ncsnccpy   wcsncpy
#define _ncsncset   _wcsnset

#define _ncsdec     _wcsdec
#define _ncsinc     _wcsinc
#define _ncsnbcnt   _wcsncnt
#define _ncsnccnt   _wcsncnt
#define _ncsnextc   _wcsnextc
#define _ncsninc    _wcsninc
#define _ncsspnp    _wcsspnp

#define _ncslwr     _wcslwr
#define _ncsupr     _wcsupr
#define _ncsxfrm    wcsxfrm


#if     (__STDC__ || defined(_NO_INLINING)) && !defined(_M_M68K)
#define _nclen(_pc) (1)
#define _nccpy(_pc1,_cpc2) ((*(_pc1) = *(_cpc2)))
#define _nccmp(_cpc1,_cpc2) ((*(_cpc1))-(*(_cpc2)))
#else   /* __STDC__ */

#if 0
__inline size_t __cdecl _nclen(const wchar_t *_cpc) { return (_cpc,1); }
__inline void __cdecl _nccpy(wchar_t *_pc1, const wchar_t *_cpc2) { *_pc1 = (wchar_t)*_cpc2; }
__inline int __cdecl _nccmp(const wchar_t *_cpc1, const wchar_t *_cpc2) { return (int) ((*_cpc1)-(*_cpc2)); }
#endif
#endif  /* __STDC__ */


/* ctype functions */

#define _isnalnum   iswalnum
#define _isnalpha   iswalpha
#define _isnascii   iswascii
#define _isncntrl   iswcntrl
#define _isndigit   iswdigit
#define _isngraph   iswgraph
#define _isnlower   iswlower
#define _isnprint   iswprint
#define _isnpunct   iswpunct
#define _isnspace   iswspace
#define _isnupper   iswupper
#define _isnxdigit  iswxdigit

#define _tonupper   towupper
#define _tonlower   towlower

#define _isnlegal(_c)   (1)
#define _isnlead(_c)    (0)
#define _isnleadbyte(_c)    (0)


#if     (__STDC__ || defined(_NO_INLINING)) && !defined(_M_M68K)
#define _wcsdec(_cpc1, _cpc2) ((_cpc2)-1)
#define _wcsinc(_pc)    ((_pc)+1)
#define _wcsnextc(_cpc) ((unsigned int) *(_cpc))
#define _wcsninc(_pc, _sz) (((_pc)+(_sz)))
#define _wcsncnt(_cpc, _sz) ((wcslen(_cpc)>_sz) ? _sz : wcslen(_cpc))
#define _wcsspnp(_cpc1, _cpc2) ((*((_cpc1)+wcsspn(_cpc1,_cpc2))) ? ((_cpc1)+wcsspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */

// BUGBUG [erichans] for some bizarre reason this body conflicts with tchar.h
#if 0 
__inline wchar_t * __cdecl _wcsdec(const wchar_t * _cpc1, const wchar_t * _cpc2) { return (wchar_t *)(_cpc1,(_cpc2-1)); }
__inline wchar_t * __cdecl _wcsinc(const wchar_t * _pc) { return (wchar_t *)(_pc+1); }
__inline unsigned int __cdecl _wcsnextc(const wchar_t * _cpc) { return (unsigned int)*_cpc; }
__inline wchar_t * __cdecl _wcsninc(const wchar_t * _pc, size_t _sz) { return (wchar_t *)(_pc+_sz); }
__inline size_t __cdecl _wcsncnt( const wchar_t * _cpc, size_t _sz) { size_t len; len = wcslen(_cpc); return (len>_sz) ? _sz : len; }
__inline wchar_t * __cdecl _wcsspnp( const wchar_t * _cpc1, const wchar_t * _cpc2) { return (*(_cpc1 += wcsspn(_cpc1,_cpc2))!='\0') ? (wchar_t*)_cpc1 : NULL; }
#endif

#endif  /* __STDC__ */


#else   /* ndef _CTUNICODE */

/* ++++++++++++++++++++ SBCS and MBCS ++++++++++++++++++++ */

#include <string.h>


#define _NEOF       EOF

#define __TN(x)      x


/* Program */

#define _nmain      main
#define _nWinMain   WinMain
#ifdef  _POSIX_
#define _nenviron   environ
#else
#define _nenviron  _environ
#endif
#define __nargv     __argv


/* Formatted i/o */

#define _nprintf    printf
#define _fnprintf   fprintf
#define _sNprintf   sprintf
#define _snNprintf  _snprintf
#define _vnprintf   vprintf
#define _vfnprintf  vfprintf
#define _vsNprintf  vsprintf
#define _vsnNprintf _vsnprintf
#define _nscanf     scanf
#define _fnscanf    fscanf
#define _snscanf    sscanf


/* Unformatted i/o */

#define _fgetnc     fgetc
#define _fgetnchar  _fgetchar
#define _fgetns     fgets
#define _fputnc     fputc
#define _fputnchar  _fputchar
#define _fputns     fputs
#define _getnc      getc
#define _getnchar   getchar
#define _getns      gets
#define _putnc      putc
#define _putnchar   putchar
#define _putns      puts
#define _ungetnc    ungetc


/* String conversion functions */

#define _ncstod     strtod
#define _ncstol     strtol
#define _ncstoul    strtoul

#define _iton       _itoa
#define _lton       _ltoa
#define _ulton      _ultoa
#define _ntoi       atoi
#define _ntol       atol


/* String functions */

#define _ncscat     strcat
#define _ncscpy     strcpy
#define _ncslen     strlen
#define _ncsxfrm    strxfrm
#define _ncsdup     _strdup


/* Execute functions */

#define _nexecl     _execl
#define _nexecle    _execle
#define _nexeclp    _execlp
#define _nexeclpe   _execlpe
#define _nexecv     _execv
#define _nexecve    _execve
#define _nexecvp    _execvp
#define _nexecvpe   _execvpe

#define _nspawnl    _spawnl
#define _nspawnle   _spawnle
#define _nspawnlp   _spawnlp
#define _nspawnlpe  _spawnlpe
#define _nspawnv    _spawnv
#define _nspawnve   _spawnve
#define _nspawnvp   _spawnvp
#define _nspawnvpe  _spawnvpe

#define _nsystem    system


/* Time functions */

#define _nasctime   asctime
#define _nctime     ctime
#define _nstrdate   _strdate
#define _nstrtime   _strtime
#define _nutime     _utime
#define _ncsftime   strftime


/* Directory functions */

#define _nchdir     _chdir
#define _ngetcwd    _getcwd
#define _ngetdcwd   _getdcwd
#define _nmkdir     _mkdir
#define _nrmdir     _rmdir


/* Environment/Path functions */

#define _nfullpath  _fullpath
#define _ngetenv    getenv
#define _nmakepath  _makepath
#define _nputenv    _putenv
#define _nsearchenv _searchenv
#define _nsplitpath _splitpath


/* Stdio functions */

#ifdef  _POSIX_
#define _nfdopen    fdopen
#else
#define _nfdopen    _fdopen
#endif
#define _nfsopen    _fsopen
#define _nfopen     fopen
#define _nfreopen   freopen
#define _nperror    perror
#define _npopen     _popen
#define _ntempnam   _tempnam
#define _ntmpnam    tmpnam


/* Io functions */

#define _nchmod     _chmod
#define _ncreat     _creat
#define _nfindfirst _findfirst
#define _nfindfirsti64  _findfirsti64
#define _nfindnext  _findnext
#define _nfindnexti64   _findnexti64
#define _nmktemp    _mktemp

#ifdef _POSIX_
#define _nopen      open
#define _naccess    access
#else
#define _nopen      _open
#define _naccess    _access
#endif

#define _nremove    remove
#define _nrename    rename
#define _nsopen     _sopen
#define _nunlink    _unlink

#define _nfinddata_t    _finddata_t
#define _nfinddatai64_t _finddatai64_t


/* ctype functions */

#define _isnascii   isascii
#define _isncntrl   iscntrl
#define _isnxdigit  isxdigit


/* Stat functions */

#define _nstat      _stat
#define _nstati64   _stati64


/* Setlocale functions */

#define _nsetlocale setlocale


#ifdef _MBCS

/* ++++++++++++++++++++ MBCS ++++++++++++++++++++ */




#ifndef __NCHAR_DEFINED
typedef char            _NCHAR;
typedef signed char     _NSCHAR;
typedef unsigned char   _NUCHAR;
typedef unsigned char   _NXCHAR;
typedef unsigned int    _NINT;
#define __NCHAR_DEFINED
#endif

#ifndef _NCHAR_DEFINED
#if     !__STDC__
typedef char            NCHAR;
#endif
#define _NCHAR_DEFINED
#endif


#ifdef _MB_MAP_DIRECT

/* use mb functions directly - types must match */

/* String functions */

#define _ncschr     _mbschr
#define _ncscspn    _mbscspn
#define _ncsncat    _mbsnbcat
#define _ncsncpy    _mbsnbcpy
#define _ncspbrk    _mbspbrk
#define _ncsrchr    _mbsrchr
#define _ncsspn     _mbsspn
#define _ncsstr     _mbsstr
#define _ncstok     _mbstok

#define _ncsnset    _mbsnbset
#define _ncsrev     _mbsrev
#define _ncsset     _mbsset

#define _ncscmp     _mbscmp
#define _ncsicmp    _mbsicmp
#define _ncsnccmp   _mbsncmp
#define _ncsncmp    _mbsnbcmp
#define _ncsncicmp  _mbsnicmp
#define _ncsnicmp   _mbsnbicmp

#define _ncscoll    _mbscoll
#define _ncsicoll   _mbsicoll
#define _ncsnccoll  _mbsncoll
#define _ncsncoll   _mbsnbcoll
#define _ncsncicoll _mbsnicoll
#define _ncsnicoll  _mbsnbicoll


/* "logical-character" mappings */

#define _ncsclen    _mbslen
#define _ncsnccat   _mbsncat
#define _ncsnccpy   _mbsncpy
#define _ncsncset   _mbsnset


/* MBCS-specific mappings */

#define _ncsdec     _mbsdec
#define _ncsinc     _mbsinc
#define _ncsnbcnt   _mbsnbcnt
#define _ncsnccnt   _mbsnccnt
#define _ncsnextc   _mbsnextc
#define _ncsninc    _mbsninc
#define _ncsspnp    _mbsspnp

#define _ncslwr     _mbslwr
#define _ncsupr     _mbsupr

#define _nclen      _mbclen
#define _nccpy      _mbccpy

#define _nccmp(_cpuc1,_cpuc2)   _ncsnccmp(_cpuc1,_cpuc2,1)


#else /* _MB_MAP_DIRECT */

#if     (__STDC__ || defined(_NO_INLINING)) && !defined(_M_M68K)

/* use type-safe linked-in function thunks */

/* String functions */

_CRTIMP char * __cdecl _ncschr(const char *, unsigned int);
_CRTIMP size_t __cdecl _ncscspn(const char *, const char *);
_CRTIMP char * __cdecl _ncsncat(char *, const char *, size_t);
_CRTIMP char * __cdecl _ncsncpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _ncspbrk(const char *, const char *);
_CRTIMP char * __cdecl _ncsrchr(const char *, int);
_CRTIMP size_t __cdecl _ncsspn(const char *, const char *);
_CRTIMP char * __cdecl _ncsstr(const char *, const char *);
_CRTIMP char * __cdecl _ncstok(char *, const char *);

_CRTIMP char * __cdecl _ncsnset(char *, unsigned int, size_t);
_CRTIMP char * __cdecl _ncsrev(char *);
_CRTIMP char * __cdecl _ncsset(char *, unsigned int);

_CRTIMP int __cdecl _ncscmp(const char *, const char *);
_CRTIMP int __cdecl _ncsicmp(const char *, const char *);
_CRTIMP int __cdecl _ncsnccmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _ncsncmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _ncsncicmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _ncsnicmp(const char *, const char *, size_t);

_CRTIMP int __cdecl _ncscoll(const char *, const char *);
_CRTIMP int __cdecl _ncsicoll(const char *, const char *);
_CRTIMP int __cdecl _ncsnccoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _ncsncoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _ncsncicoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _ncsnicoll(const char *, const char *, size_t);


/* "logical-character" mappings */

_CRTIMP size_t __cdecl _ncsclen(const char *);
_CRTIMP char * __cdecl _ncsnccat(char *, const char *, size_t);
_CRTIMP char * __cdecl _ncsnccpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _ncsncset(char *, unsigned int, size_t);


/* MBCS-specific mappings */

_CRTIMP char * __cdecl _ncsdec(const char *, const char *);
_CRTIMP char * __cdecl _ncsinc(const char *);
_CRTIMP size_t __cdecl _ncsnbcnt(const char *, size_t);
_CRTIMP size_t __cdecl _ncsnccnt(const char *, size_t);
_CRTIMP unsigned int __cdecl _ncsnextc (const char *);
_CRTIMP char * __cdecl _ncsninc(const char *, size_t);
_CRTIMP char * __cdecl _ncsspnp(const char *, const char *);

_CRTIMP char * __cdecl _ncslwr(char *);
_CRTIMP char * __cdecl _ncsupr(char *);

_CRTIMP size_t __cdecl _nclen(const char *);
_CRTIMP void __cdecl _nccpy(char *, const char *);


#else   /* __STDC__ */

/* the default: use type-safe inline function thunks */

#define _PUC    unsigned char *
#define _CPUC   const unsigned char *
#define _PC     char *
#define _CPC    const char *
#define _UI     unsigned int


/* String functions */

__inline _PC _ncschr(_CPC _s1,_UI _c) {return (_PC)_mbschr((_CPUC)_s1,_c);}
__inline size_t _ncscspn(_CPC _s1,_CPC _s2) {return _mbscspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _ncsncat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _ncsncpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _ncspbrk(_CPC _s1,_CPC _s2) {return (_PC)_mbspbrk((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _ncsrchr(_CPC _s1,_UI _c) {return (_PC)_mbsrchr((_CPUC)_s1,_c);}
__inline size_t _ncsspn(_CPC _s1,_CPC _s2) {return _mbsspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _ncsstr(_CPC _s1,_CPC _s2) {return (_PC)_mbsstr((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _ncstok(_PC _s1,_CPC _s2) {return (_PC)_mbstok((_PUC)_s1,(_CPUC)_s2);}

__inline _PC _ncsnset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnbset((_PUC)_s1,_c,_n);}
__inline _PC _ncsrev(_PC _s1) {return (_PC)_mbsrev((_PUC)_s1);}
__inline _PC _ncsset(_PC _s1,_UI _c) {return (_PC)_mbsset((_PUC)_s1,_c);}

__inline int _ncscmp(_CPC _s1,_CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _ncsicmp(_CPC _s1,_CPC _s2) {return _mbsicmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _ncsnccmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _ncsncmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _ncsncicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _ncsnicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicmp((_CPUC)_s1,(_CPUC)_s2,_n);}

__inline int _ncscoll(_CPC _s1,_CPC _s2) {return _mbscoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _ncsicoll(_CPC _s1,_CPC _s2) {return _mbsicoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _ncsnccoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _ncsncoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _ncsncicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _ncsnicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicoll((_CPUC)_s1,(_CPUC)_s2,_n);}


/* "logical-character" mappings */

__inline size_t _ncsclen(_CPC _s1) {return _mbslen((_CPUC)_s1);}
__inline _PC _ncsnccat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _ncsnccpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _ncsncset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnset((_PUC)_s1,_c,_n);}


/* MBCS-specific mappings */

__inline _PC _ncsdec(_CPC _s1,_CPC _s2) {return (_PC)_mbsdec((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _ncsinc(_CPC _s1) {return (_PC)_mbsinc((_CPUC)_s1);}
__inline size_t _ncsnbcnt(_CPC _s1,size_t _n) {return _mbsnbcnt((_CPUC)_s1,_n);}
__inline size_t _tcsnccnt(_CPC _s1,size_t _n) {return _mbsnccnt((_CPUC)_s1,_n);}
__inline _PC _ncsninc(_CPC _s1,size_t _n) {return (_PC)_mbsninc((_CPUC)_s1,_n);}
__inline _PC _tcsspnp(_CPC _s1,_CPC _s2) {return (_PC)_mbsspnp((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _ncslwr(_PC _s1) {return (_PC)_mbslwr((_PUC)_s1);}
__inline _PC _ncsupr(_PC _s1) {return (_PC)_mbsupr((_PUC)_s1);}

__inline size_t _nclen(_CPC _s1) {return _mbclen((_CPUC)_s1);}
__inline void _nccpy(_PC _s1,_CPC _s2) {_mbccpy((_PUC)_s1,(_CPUC)_s2); return;}


/* inline helper */
__inline _UI _ncsnextc(_CPC _s1) {_UI _n=0; if (_ismbblead((_UI)*(_PUC)_s1)) _n=((_UI)*_s1++)<<8; _n+=(_UI)*_s1; return(_n);}


#endif /* __STDC__ */

#endif /* _MB_MAP_DIRECT */


/* MBCS-specific mappings */

#define _nccmp(_cp1,_cp2)   _ncsnccmp(_cp1,_cp2,1)


/* ctype functions */

#define _isnalnum   _ismbcalnum
#define _isnalpha   _ismbcalpha
#define _isndigit   _ismbcdigit
#define _isngraph   _ismbcgraph
#define _isnlegal   _ismbclegal
#define _isnlower   _ismbclower
#define _isnprint   _ismbcprint
#define _isnpunct   _ismbcpunct
#define _isnspace   _ismbcspace
#define _isnupper   _ismbcupper

#define _tonupper   _mbctoupper
#define _tonlower   _mbctolower

#define _isnlead    _ismbblead
#define _isnleadbyte    isleadbyte

#else   /* !_MBCS */

/* ++++++++++++++++++++ SBCS ++++++++++++++++++++ */


#ifndef __NCHAR_DEFINED
typedef char            _NCHAR;
typedef signed char     _NSCHAR;
typedef unsigned char   _NUCHAR;
typedef char            _NXCHAR;
typedef int             _NINT;
#define __NCHAR_DEFINED
#endif

#ifndef _NCHAR_DEFINED
#if     !__STDC__
typedef char            NCHAR;
#endif
#define _NCHAR_DEFINED
#endif


/* String functions */

#define _ncschr     strchr
#define _ncscspn    strcspn
#define _ncsncat    strncat
#define _ncsncpy    strncpy
#define _ncspbrk    strpbrk
#define _ncsrchr    strrchr
#define _ncsspn     strspn
#define _ncsstr     strstr
#define _ncstok     strtok

#define _ncsnset    _strnset
#define _ncsrev     _strrev
#define _ncsset     _strset

#define _ncscmp     strcmp
#define _ncsicmp    _stricmp
#define _ncsnccmp   strncmp
#define _ncsncmp    strncmp
#define _ncsncicmp  _strnicmp
#define _ncsnicmp   _strnicmp

#define _ncscoll    strcoll
#define _ncsicoll   _stricoll
#define _ncsnccoll  _strncoll
#define _ncsncoll   _strncoll
#define _ncsncicoll _strnicoll
#define _ncsnicoll  _strnicoll


/* "logical-character" mappings */

#define _ncsclen    strlen
#define _ncsnccat   strncat
#define _ncsnccpy   strncpy
#define _ncsncset   _strnset


/* MBCS-specific functions */

#define _ncsdec     _strdec
#define _ncsinc     _strinc
#define _ncsnbcnt   _strncnt
#define _ncsnccnt   _strncnt
#define _ncsnextc   _strnextc
#define _ncsninc    _strninc
#define _ncsspnp    _strspnp

#define _ncslwr     _strlwr
#define _ncsupr     _strupr
#define _ncsxfrm    strxfrm

#define _isnlead(_c)    (0)
#define _isnleadbyte(_c)    (0)

#if     (__STDC__ || defined(_NO_INLINING)) && !defined(_M_M68K)
#define _nclen(_pc) (1)
#define _nccpy(_pc1,_cpc2) (*(_pc1) = *(_cpc2))
#define _nccmp(_cpc1,_cpc2) (((unsigned char)*(_cpc1))-((unsigned char)*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _nclen(const char *_cpc) { return (_cpc,1); }
__inline void __cdecl _nccpy(char *_pc1, const char *_cpc2) { *_pc1 = *_cpc2; }
__inline int __cdecl _nccmp(const char *_cpc1, const char *_cpc2) { return (int) (((unsigned char)*_cpc1)-((unsigned char)*_cpc2)); }
#endif  /* __STDC__ */


/* ctype-functions */

#define _isnalnum   isalnum
#define _isnalpha   isalpha
#define _isndigit   isdigit
#define _isngraph   isgraph
#define _isnlower   islower
#define _isnprint   isprint
#define _isnpunct   ispunct
#define _isnspace   isspace
#define _isnupper   isupper

#define _tonupper   toupper
#define _tonlower   tolower

#define _isnlegal(_c)   (1)


/* the following is optional if functional versions are available */

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#if     (__STDC__ || defined(_NO_INLINING)) && !defined(_M_M68K)
// BUGBUG [erichans] for some bizarre reason this conflicts with tchar.h
#if 0
#define _strdec(_cpc1, _cpc2) ((_cpc2)-1)
#define _strinc(_pc)    ((_pc)+1)
#define _strnextc(_cpc) ((unsigned int) *(_cpc))
#define _strninc(_pc, _sz) (((_pc)+(_sz)))
#define _strncnt(_cpc, _sz) ((strlen(_cpc)>_sz) ? _sz : strlen(_cpc))
#define _strspnp(_cpc1, _cpc2) ((*((_cpc1)+strspn(_cpc1,_cpc2))) ? ((_cpc1)+strspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline char * __cdecl _strdec(const char * _cpc1, const char * _cpc2) { return (char *)(_cpc1,(_cpc2-1)); }
__inline char * __cdecl _strinc(const char * _pc) { return (char *)(_pc+1); }
__inline unsigned int __cdecl _strnextc(const char * _cpc) { return (unsigned int)*_cpc; }
__inline char * __cdecl _strninc(const char * _pc, size_t _sz) { return (char *)(_pc+_sz); }
__inline size_t __cdecl _strncnt( const char * _cpc, size_t _sz) { size_t len; len = strlen(_cpc); return (len>_sz) ? _sz : len; }
__inline char * __cdecl _strspnp( const char * _cpc1, const char * _cpc2) { return (*(_cpc1 += strspn(_cpc1,_cpc2))!='\0') ? (char*)_cpc1 : NULL; }
#endif

#endif  /* __STDC__ */


#endif  /* _MBCS */

#endif  /* _UNICODE */


/* Generic text macros to be used with string literals and character constants.
   Will also allow symbolic constants that resolve to same. */

#define _TN(x)       __TN(x)
#define _TEXTN(x)    __TN(x)


#ifdef __cplusplus
}
#endif

#endif  /* _INC_NCHAR */

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  CTUNICODE

typedef WCHAR *PNCHAR;
typedef NCHAR *LPNCHAR;

typedef LPWSTR LPNCH, PNCH;
typedef LPWSTR PNSTR, LPNSTR;
typedef LPCWSTR LPCNSTR;
typedef LPWSTR LP;
#define __TEXTN(quote) L##quote

#else   /* CTUNICODE */

typedef char NCHAR, *PNCHAR;
typedef unsigned char NBYTE , *PNBYTE ;
typedef NCHAR   *LPNCHAR;

typedef LPSTR LPNCH, PNCH;
typedef LPSTR PNSTR, LPNSTR;
typedef LPCSTR LPCNSTR;
#define __TEXTN(quote) quote

#endif /* CTUNICODE */

typedef const NCHAR CNCHAR;

#ifdef CTUNICODE
#define NSF    __TEXTN("%ls")
#else  // ANSI
#define NSF    __TEXTN("%hs")
#endif

#endif  // __NCHAR_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\log\common.cxx ===
//+-------------------------------------------------------------------
//
//  File:       common.cxx
//
//  Contents:   The common methods for logsvr and the log sub-projects
//
//  Classes:    LOGCLASS  Actually, this is a macroname that is defined
//                          at compile time
//
//  Functions:  DelString(PCHAR *)
//              LOGCLASS ::InitLogging(VOID)
//              LOGCLASS ::FreeLogging(VOID)
//              LOGCLASS ::SetLogFile(VOID)
//              LOGCLASS ::AddComponent(PCHAR, PCHAR)
//              LOGCLASS ::SetEventCount(VOID)
//              LOGCLASS ::LogOpen(VOID)
//              LOGCLASS ::OpenLogFile(VOID)
//              LOGCLASS ::LogData(VOID)
//              LOGCLASS ::WriteToLogFile(VOID)
//              LOGCLASS ::WriteHeader(VOID)
//              LOGCLASS ::WriteBinItem(CHAR, PVOID, USHORT)
//              LOGCLASS ::CheckDir(PCHAR)
//              LOGCLASS ::NewString(PCHAR *, CPPSZ)
//              LOGCLASS ::SetInfo(CPPSZ, CPPSZ, CPPSZ, CPPSZ)
//              LOGCLASS ::SetStrData(PCHAR, va_list)
//              LOGCLASS ::CloseLogFile(VOID)
//              LOGCLASS ::SetBinData(USHORT, PVOID)
//              LOGCLASS ::LogPrintf(HANDLE, PCHAR, ...)
//              LOGCLASS ::FlushLogFile(USHORT)
//              LOGCLASS ::SetIsComPort(CPPSZ)
//              LOGCLASS ::LogEventCountVOID)
//
//  History:    26-Sep-90  DaveWi    Initial Coding
//              18-Oct-90  DaveWi    Redesigned to be #included in log.cxx
//                                   and logsvr.cxx.
//              25-Sep-91  BryanT    Converted to C 7.0
//              14-Oct-91  SarahJ    DCR 527 - changed WriteBinItem to not
//                                     pad length argument to fixed length
//              30-Oct-91  SarahJ    removed def for CCHMAXPATH
//              30-Oct-91  SarahJ    removed addition of 11 spaces after event
//                                    count for no purpose in LogEventCount
//              14-Nov-91  SarahJ    replaced code to pad the event count
//                                    with spaces as it has a purpose! Also
//                                    explained padding in comment with code.
//              09-Feb-92  BryanT    Win32 work and general cleanup.
//              16-Jul-92  DeanE     Added wchar string support by changing
//                                   vsprintf to w4vsprintf
//                                   BUGBUG - the above addition may still
//                                   not work because the string formed is
//                                   then processed by non wchar functions
//               1-Aug-92  DwightKr  Renamed CPCHAR as CPPSZ.  CPCHAR
//                                   conflicted with the 297 version of
//                                   windows.h
//              17-Sep-92  SarahJ    Bug fixes and memory usage improvements
//              30-Oct-92  Sarahj    Removed the use of pszTester from mn:
//                                   or elsewhere
//
//--------------------------------------------------------------------

#include <pch.cxx>
// BUGBUG Precompiled header does not work on Alpha for some unknown reason and
// so we temporarily remove it.
// #pragma hdrstop

VOID DelString(PCHAR  *psz);
VOID DelString(LPWSTR *wsz);


#define LOGCLASS Log


//
// The SEEK_TO macro takes two different arguments.  Either FILE_BEGIN
// which makes it seek to the beginning of the file or FILE_END where
// it seeks to the end.
//

#define SEEK_TO(n) \
((fIsComPort==FALSE && \
  ~0 == SetFilePointer(hLogFile,0,NULL,(n)) ? -1 : NO_ERROR))

#define COUNT_BUFLEN    12      // Buf len for logged data len buffer

#define SLASH_STRING  "\\"
#define wSLASH_STRING L"\\"

//+-------------------------------------------------------------------
//
//  Function:   DelString(PCHAR *)
//
//  Synopsis:   Given a pointer to a string, delete the memory if necessary
//               and set the pointer to NULL
//
//  Arguments:  [pszOrig]  Original string to delete
//
//  Returns:    <nothing>
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
VOID DelString(PCHAR *pszOrig)
{
    if (*pszOrig != NULL)
    {
        delete *pszOrig;
        *pszOrig = NULL;
    }
}

//+-------------------------------------------------------------------
//
//  Function:   DelString(LPWSTR *)
//
//  Synopsis:   Given a pointer to a string, delete the memory if necessary
//               and set the pointer to NULL
//
//  Arguments:  [wszOrig]  Original string to delete
//
//  Returns:    <nothing>
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
VOID DelString(LPWSTR *wszOrig)
{
    if (*wszOrig != NULL)
    {
        delete *wszOrig;
        *wszOrig = NULL;
    }
}

//+-------------------------------------------------------------------
//
//  Function:   wcNametoMbs(PCHAR *)
//
//  Synopsis:   Given a pointer to a WCHAR string, return a CHAR copy
//
//  Arguments:  [pwcName] - WCHAR string to copy
//
//  Returns:    <nothing>
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
PCHAR LOGCLASS::wcNametombs(PWCHAR pwcName)
{
    PCHAR pszName = NULL;
    if (pwcName != NULL)
    {
        size_t sizLen = wcslen(pwcName);
        if ((pszName = new char[sizLen+1]) == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            memset(pszName, 0, sizLen +1);
            if (wcstombs(pszName, pwcName, sizLen) == (size_t)0)
            {
                delete[] pszName;
                ulLastError = ERROR_INVALID_DATA;
            }
        }
    }
    return pszName;
}


//+-------------------------------------------------------------------
//
//  Class:      LOGCLASS  (Actually, this is a macroname that is defined
//                          at compile time)
//
//  Purpose:
//
//  Interface:
//
//  History:    ??-???-??  ???????? Created
//
//  Notes:      The macro LOGCLASS is set in 'makefile'.  The methods in
//              the file are used in the Log class and in the LogSvr class.
//              In the makefile for building the Log class library log.lib,
//              LOGCLASS is defined as "Log". In building logsvr.exe,
//              LOGCLASS is defined as "LogSvr".  This was done because the
//              original version of this code was developed under
//              Glockenspiel 1.x which does not support multiple inheritance
//              and the inheritance tree for the classes which Log and LogSvr
//              inherit are such that this was the best way to allow for
//              maintaining only one version of these methods.
//
//--------------------------------------------------------------------

//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::InitLogging(VOID)
//
//  Synopsis:   Initialize the classes data members.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
void LOGCLASS :: InitLogging(VOID)
{
    pszLoggingDir = NULL;
    pszMachineName = NULL;
    pszObjectName = NULL;
    pszTestName = NULL;
    pszPath = NULL;
    pszStatus = NULL;
    pszVariation = NULL;
    pvBinData = NULL;
    pszStrData = NULL;
    pszLogFileName = NULL;

    wszLoggingDir = NULL;
    wszMachineName = NULL;
    wszObjectName = NULL;
    wszTestName = NULL;
    wszPath = NULL;
    wszStatus = NULL;
    wszVariation = NULL;
    wszStrData = NULL;
    wszLogFileName = NULL;

    fIsComPort = FALSE;
    fFlushWrites = FALSE;
    fInfoSet = FALSE;
    ulEventCount = 0L;
    ulEventTime = 0L;
    usBinLen = 0;
    hLogFile = INVALID_HANDLE_VALUE;
}

//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::FreeLogging(VOID)
//
//  Synopsis:   Reset existing Logging members back to initial state
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
void LOGCLASS :: FreeLogging()
{
    va_list vaDummy = LOG_VA_NULL;
    CloseLogFile();

    fIsComPort   = FALSE;
    fFlushWrites = FALSE;
    fInfoSet     = FALSE;

    if(FALSE == fIsUnicode)
    {
        SetLoggingDir((PCHAR) NULL);
        SetMachineName((PCHAR) NULL);
        SetObjectName((PCHAR) NULL);
        SetTestName((PCHAR) NULL);
        SetPath((PCHAR) NULL);
        SetStatus((PCHAR) NULL);
        SetVariation((PCHAR) NULL);
        SetStrData((PCHAR) NULL, vaDummy);
    }
    else
    {
        SetLoggingDir((LPWSTR) NULL);
        SetMachineName((LPWSTR) NULL);
        SetObjectName((LPWSTR) NULL);
        SetTestName((LPWSTR) NULL);
        SetPath((LPWSTR) NULL);
        SetStatus((LPWSTR) NULL);
        SetVariation((LPWSTR) NULL);
        SetStrData((LPWSTR) NULL, vaDummy);
    }

    ulEventCount   = 0L;
    ulEventTime    = 0L;

    SetBinData(0, NULL);

}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::SetLogFile(VOID)
//
//  Synopsis:   Combine the logging file name components into a full path
//              file name.  If this new file name is not the same as that
//              referenced by element pszLogFileName, switch to log data
//              into the file in this new name.
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_PARAMETER
//              ERROR_NOT_ENOUGH_MEMORY
//               Any error from AddComponent, CheckDir, SetLogFileName,
//               or SetEventCount
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: SetLogFile()
{
    // if unicode, use the unicode version
    if(TRUE == fIsUnicode)
    {
        return wSetLogFile();
    }

    if (((pszLoggingDir != (PCHAR) NULL) &&
         (strlen(pszLoggingDir) > _MAX_PATH)) ||
        ((pszPath != NULL) && (strlen(pszPath) > _MAX_PATH)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    PCHAR pszNewFileName = new char[_MAX_PATH + 1];
    if(pszNewFileName == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Are we going to log to a COM port?
    //

    if(SetIsComPort((const char *)pszLoggingDir) != FALSE)
    {
        fIsComPort = TRUE;             // Yes.
        strcpy(pszNewFileName, pszLoggingDir);
    }
    else
    {
        if(SetIsComPort((const char *)pszPath) != FALSE)
        {
            fIsComPort = TRUE;         // Yes, locally
            strcpy(pszNewFileName, pszPath);
        }
        else
        {
            //
            // No -
            // For each component of the new log file path, append it to the
            // root logging directory.  Make sure only one back-slash exists
            // between each appended path component.
            //

            if(pszLoggingDir != NULL && *pszLoggingDir != NULLTERM)
            {
                strcpy(pszNewFileName, pszLoggingDir);
            }
            else
            {
                *pszNewFileName = NULLTERM;
            }


            ulLastError =
                AddComponent(pszNewFileName, pszPath) ||
                AddComponent(pszNewFileName, pszTestName);

        }
    }

    //
    // The the new file name was successfully built, see if it the same as
    // the name of the currently open log file (if one is open).  If is not
    // the same file name, close the open one (if open) and open the new
    // logging file.  If the open is successful, save the name of the newly
    // opened file for the next time thru here.
    //
    // A later version of this method could be written to create a LRU queue
    // of some max number of open logging files.  This version just keeps one
    // file open at a time, closing it only to switch to a different log file.
    //

    if(ulLastError == NO_ERROR)
    {
        if(fIsComPort == FALSE)
        {
            strcat(pszNewFileName, (const char *)".LOG");
        }

        if((pszLogFileName == NULL) ||
           (hLogFile == INVALID_HANDLE_VALUE) ||
           _stricmp(pszNewFileName, pszLogFileName) != SAME)
        {
            CloseLogFile();     // Make sure it is really closed

            //
            // Make sure the directory part of the logging file name exists.
            // Make each sub-directory that does not exist, then open the
            // logging file.
            //

            ulLastError = CheckDir(pszNewFileName);

            if(ulLastError == NO_ERROR)
            {
                DWORD dwFlags = GENERIC_WRITE;

                if(fIsComPort == FALSE)
                {
                    dwFlags |= GENERIC_READ;
                }
                hLogFile = CreateFileA(pszNewFileName,
                                       dwFlags,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                       NULL, OPEN_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL, NULL);

                if(hLogFile == INVALID_HANDLE_VALUE)
                {
                    ulLastError = GetLastError();
                }
                else
                {
                    if(SEEK_TO(FILE_END) != NO_ERROR)
                    {
                        ulLastError = GetLastError();
                    }
                    else
                    {
                        ulLastError =
                            SetLogFileName((const char *) pszNewFileName) ||
                            SetEventCount();
                    }
                }
            }
        }
    }

    delete [] pszNewFileName;
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::wSetLogFile(VOID)
//
//  Synopsis:   Combine the logging file name components into a full path
//              file name.  If this new file name is not the same as that
//              referenced by element pszLogFileName, switch to log data
//              into the file in this new name.
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_PARAMETER
//              ERROR_NOT_ENOUGH_MEMORY
//               Any error from AddComponent, CheckDir, SetLogFileName,
//               or SetEventCount
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: wSetLogFile()
{
    CHK_UNICODE(TRUE);

    if(((wszLoggingDir != NULL) &&
         (wcslen(wszLoggingDir) > _MAX_PATH)) ||
        ((wszPath != NULL) && (wcslen(wszPath) > _MAX_PATH)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    LPWSTR wszNewFileName = new WCHAR[_MAX_PATH + 1];
    if(wszNewFileName == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Are we going to log to a COM port?
    //

    if(SetIsComPort((LPCWSTR) wszLoggingDir) != FALSE)
    {
        fIsComPort = TRUE;             // Yes.
        wcscpy(wszNewFileName, wszLoggingDir);
    }
    else
    {
        if(SetIsComPort((LPCWSTR) wszPath) != FALSE)
        {
            fIsComPort = TRUE;         // Yes, locally
            wcscpy(wszNewFileName, wszPath);
        }
        else
        {
            //
            // No -
            // For each component of the new log file path, append it to the
            // root logging directory.  Make sure only one back-slash exists
            // between each appended path component.
            //

            if(wszLoggingDir != NULL && *wszLoggingDir != wNULLTERM)
            {
                wcscpy(wszNewFileName, wszLoggingDir);
            }
            else
            {
                *wszNewFileName = wNULLTERM;
            }


            ulLastError = AddComponent(wszNewFileName, wszPath) ||
                AddComponent(wszNewFileName, wszTestName);
        }
    }

    //
    // The the new file name was successfully built, see if it the same as
    // the name of the currently open log file (if one is open).  If is not
    // the same file name, close the open one (if open) and open the new
    // logging file.  If the open is successful, save the name of the newly
    // opened file for the next time thru here.
    //
    // A later version of this method could be written to create a LRU queue
    // of some max number of open logging files.  This version just keeps one
    // file open at a time, closing it only to switch to a different log file.
    //

    if (ulLastError == NO_ERROR)
    {
        if(fIsComPort == FALSE)
        {
            wcscat(wszNewFileName, L".LOG");
        }

        if((wszLogFileName == NULL) || (hLogFile == INVALID_HANDLE_VALUE) ||
            _wcsicmp(wszNewFileName, wszLogFileName) != SAME)
        {
            CloseLogFile();     // Make sure it is really closed

            //
            // Make sure the directory part of the logging file name exists.
            // Make each sub-directory that does not exist, then open the
            // logging file.
            //

            ulLastError = CheckDir(wszNewFileName);

            if(ulLastError == NO_ERROR)
            {
                DWORD dwFlags = GENERIC_WRITE;

                if(fIsComPort == FALSE)
                {
                    dwFlags |= GENERIC_READ;
                }
                hLogFile = CreateFileW(wszNewFileName,
                                       dwFlags,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                       NULL, OPEN_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL, NULL);

                if(hLogFile == INVALID_HANDLE_VALUE)
                {
                    ulLastError = GetLastError();
                }
                else
                {
                    if(SEEK_TO(FILE_END) != NO_ERROR)
                    {
                        ulLastError = GetLastError();
                    }
                    else
                    {
                        ulLastError = SetLogFileName((LPCWSTR) wszNewFileName)
                            || SetEventCount();
                    }
                }
            }
        }
    }

    delete [] wszNewFileName;
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::AddComponent(PCHAR, PCHAR)
//
//  Synopsis:   Append a path component to the given string in szNewName.
//              Make sure there is one and only one '\' between each
//              component and no trailing '\' is present.
//
//  Arguments:  [szNewName]   - Pointer to exist path (must not be NULL)
//              [szComponent] - New component to add
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_NAME
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: AddComponent(PCHAR szNewName, PCHAR szComponent)
{
    CHK_UNICODE(FALSE);

    PCHAR pch = NULL;

    // Path component provided?

    if (szComponent != NULL && *szComponent != NULLTERM)
    {
        int nLen = strlen((const char *)szComponent);

        //
        // Trim trailing and leading '\'s from the component to be appended,
        // then append the component to the file name.
        //

        pch = szComponent + nLen;

        while (pch > szComponent)
        {
            if (*pch == SLASH)
            {
                *pch = NULLTERM;
                pch--;
            }
            else
            {
                break;
            }
        }
        pch = szComponent;

        while (*pch == SLASH)
        {
            pch++;
        }

        //
        // Append one '\' to the file name then append the given component.
        //

        if (strlen((const char *)szNewName) + nLen + 1 < _MAX_PATH)
        {
            nLen = strlen((const char *)szNewName);

            if (nLen > 0)
            {                               // Add component separater
                szNewName[ nLen++] = SLASH;
            }
            strcpy(&szNewName[nLen], (const char *)pch);
        }
        else
        {
            ulLastError = ERROR_INVALID_NAME;
        }
    }

    return(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::AddComponent(LPWSTR, LPWSTR)
//
//  Synopsis:   Append a path component to the given string in szNewName.
//              Make sure there is one and only one '\' between each
//              component and no trailing '\' is present.
//
//  Arguments:  [wszNewName]   - Pointer to exist path (must not be NULL)
//              [wszComponent] - New component to add
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_NAME
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: AddComponent(LPWSTR wszNewName, LPWSTR wszComponent)
{
    CHK_UNICODE(TRUE);

    LPWSTR wch = NULL;

    // Path component provided?

    if(wszComponent != NULL && *wszComponent != wNULLTERM)
    {
        int nLen = wcslen((LPWSTR) wszComponent);

        //
        // Trim trailing and leading backslash from the component to be
        // appended, then append the component to the file name.
        //

        wch = wszComponent + nLen;

        while(wch > wszComponent)
        {
            if(*wch == wSLASH)
            {
                *wch = wNULLTERM;
                wch--;
            }
            else
            {
                break;
            }
        }
        wch = wszComponent;

        while(*wch == wSLASH)
        {
            wch++;
        }

        //
        // Append one backslash to the file name then append the
        // given component.
        //

        if(wcslen(wszNewName) + nLen + 1 < _MAX_PATH)
        {
            nLen = wcslen(wszNewName);

            if(nLen > 0)
            {                               // Add component separater
                wszNewName[nLen++] = wSLASH;
            }
            wcscpy(&wszNewName[nLen], wch);
        }
        else
        {
            ulLastError = ERROR_INVALID_NAME;
        }
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::SetEventCount(VOID)
//
//  Synopsis:   This version assumes the current event count is in ASCII
//              format at beginning of the file.  It is also assumed that
//              the value is in the range 0-65535 so it will fit in a small
//              buffer and in a USHORT.
//
//  Returns:    NO_ERROR if successful
//              Values from GetLastError() after CRT function is called
//              CORRUPT_LOG_FILE
//              ERROR_NOT_ENOUGH_MEMORY
//
//  Notes:      This should not need converting to unicode - dda
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: SetEventCount()
{
    //
    // If we're using a COM port, set the EventCount to 0 since
    // we can't read from it anyway
    //

    if(fIsComPort != FALSE)
    {
        ulEventCount = 0L;
        return NO_ERROR;
    }

    //
    // This version assumes the log file is a binary file, not normally
    // readable by the user without the LOGVIEWER utility.  It seeks to
    // the beginning of the file, reads into zsCount, translates szCount
    // to a ULONG, and seeks to the end.
    //

    if(SEEK_TO(FILE_BEGIN) != NO_ERROR)
    {
        ulLastError = GetLastError();
    }
    else
    {
        LONG lLen = GetFileSize(hLogFile, NULL);

        if(lLen == -1L)
        {
            ulLastError = GetLastError();
        }
        else if(lLen < MIN_LINE_HDR_LEN)
        {
            ulEventCount = 0L;         // The file has been newly created
        }
        else
        {
            PCHAR pszTmp = new CHAR[LINE_HDR_LEN+1];

            // Read the data line header

            if(pszTmp != NULL)
            {
                //
                // SarahJ - Event count is held in a ulong therefore its
                // maximum length as ascii will be 10 digits - and at this
                // point you have a mega file! This means that the maximum
                // length that the data can be is 2, and 99.9% of the time
                // will be 1. The below code depends on at most 2 chars being
                // used for the length.  First read MIN_LINE_HDR_LEN bytes
                // then read 1 more byte to find the :.
                //

                DWORD dwBytesRead;

                if(FALSE == ReadFile(hLogFile, (LPVOID) pszTmp,
                                     MIN_LINE_HDR_LEN, &dwBytesRead, NULL) ||
                   MIN_LINE_HDR_LEN != dwBytesRead)
                {
                    ulLastError = GetLastError();
                }
                else
                {
                    PCHAR pchTmp = &pszTmp[MIN_LINE_HDR_LEN - 1];
                    if(*pchTmp != ':')
                    {
                        if(FALSE == ReadFile(hLogFile, (LPVOID) pszTmp,
                                             1, &dwBytesRead, NULL) ||
                           1 != dwBytesRead)
                        {
                            ulLastError = GetLastError();
                        }
                    }
                    else if(*pchTmp != ':')
                    {
                        ulEventCount = 0L;
                    }
                    else
                    {
                        *pchTmp = NULLTERM;

                        // Get the # bytes in the event count value.  The line
                        // starts with x: where x is the LOG_EVENTS_ID
                        // ID character.

                        if(*pszTmp == LOG_EVENTS)
                        {
                            ULONG ulLen = (ULONG) atoi(&pszTmp[2]);

                            if(ulLen > 0)
                            {
                                PCHAR pszCount = new CHAR[ulLen + 1];

                                if(pszCount != NULL)
                                {
                                    // Read the event count value

                                    if(FALSE == ReadFile(hLogFile,
                                                         (LPVOID) pszTmp,
                                                         ulLen, &dwBytesRead,
                                                         NULL) ||
                                       ulLen != dwBytesRead)
                                    {
                                        ulLastError  = GetLastError();
                                        ulEventCount = 0L;
                                    }
                                    else
                                    {
                                        pszCount[ulLen] = NULLTERM;
                                        ulEventCount     = atol(pszCount);
                                    }
                                    delete pszCount;
                                }
                                else
                                {
                                    ulLastError  = ERROR_NOT_ENOUGH_MEMORY;
                                    ulEventCount = 0L;
                                }
                            }
                            else
                            {
                                ulEventCount = 0L;
                            }
                        }
                        else
                        {
                            ulLastError  = CORRUPT_LOG_FILE;
                            ulEventCount = 0L;
                        }
                    }
                    delete pszTmp;
                }
            }
            else
            {
                ulLastError  = ERROR_NOT_ENOUGH_MEMORY;
                ulEventCount = 0L;
            }
        }
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::LogOpen(VOID)
//
//  Synopsis:   If we are not in the LogSvr and if logging remotly, try
//              to a START record to the server.  If not, or if the attempt
//              fails, log the data locally. This may require opening the
//              local log file.
//
//  Returns:    NO_ERROR if successful
//              Results from Remote(), SetLogFile(), or OpenLogFile()
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: LogOpen()
{
    if(hLogFile == INVALID_HANDLE_VALUE)
    {
        //
        // Something failed in the remote logging attempt, or this is our
        // first call to open the log file, so set up to log locally.
        //

        ulLastError = SetLogFile();

        if(ulLastError != NO_ERROR)
        {
            return ulLastError;    // Setup failed...  Don't go any further.
        }
    }

    return OpenLogFile();
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::OpenLogFile(VOID)
//
//  Synopsis:   This version assumes that SetLogFile has already been called.
//
//  Returns:    Value of GetLastError() if a CRT function fails otherwise,
//              return code from FlushLogFile()
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: OpenLogFile()
{
    long lLen;

    //
    // If the logging file is empty, write a header to the file and set the
    // event counter to zero.
    //

    if(fIsComPort == FALSE)
    {
        lLen = GetFileSize(hLogFile, NULL);

        if(lLen == -1L)
        {
            ulLastError = GetLastError();
            return ulLastError;
        }
    }
    else
    {
        lLen = 0L;
    }

    if(lLen < LINE_HDR_LEN)
    {
        if(SEEK_TO(FILE_BEGIN) != NO_ERROR)
        {
            ulLastError = GetLastError();
        }
        else
        {
            ulLastError = WriteHeader();
        }
    }
    return FlushLogFile(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::LogData(VOID)
//
//  Synopsis:   If logging remotely, try to send data to the server.  If
//              not, or if the attempt fails, log the data locally.  This
//              may require opening the local log file.
//
//  Returns:    Result from WriteToLogFile
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: LogData()
{
    if(hLogFile == INVALID_HANDLE_VALUE)
    {
        //
        // This is our first call to open the log file
        //

        ulLastError = SetLogFile();

        if(ulLastError != NO_ERROR)
        {
            return ulLastError; // Setup failed; Don't go any further.
        }
    }

    // Log file opened OK, so write the data
    return WriteToLogFile();
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::WriteToLogFile(VOID)
//
//  Synopsis:   Write data out to the log file.
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: WriteToLogFile()
{
    // use unicode method
    if(TRUE == fIsUnicode)
    {
        return wWriteToLogFile();
    }

    char chBuf[COUNT_BUFLEN];

    int cLen = sprintf(chBuf, "%lu", ulEventCount + 1);

    ulLastError = WriteBinItem(LOG_EVENT_NUM, (PVOID) chBuf, cLen);

    if(ulLastError == NO_ERROR)
    {
        //
        // If the event time has not already been set, set it to the
        // current system time.
        //

        cLen = sprintf(chBuf, "%lu", (ulEventTime==0L) ?
                       time((time_t *) NULL) : ulEventTime);

        ulLastError = WriteBinItem(LOG_EVENT_TIME,
                                   (PVOID) chBuf, strlen((const char *)chBuf))

            || WriteBinItem(LOG_MACHINE,
                            (PVOID) pszMachineName,
                            (pszMachineName == NULL) ?
                            0 : strlen((const char *)pszMachineName))

            || WriteBinItem(LOG_OBJECT,
                            (PVOID) pszObjectName,
                            (pszObjectName == NULL) ?
                            0 : strlen((const char *)pszObjectName))

            || WriteBinItem(LOG_VARIATION,
                            (PVOID) pszVariation,
                            (pszVariation == NULL) ?
                            0 : strlen((const char *)pszVariation))

            || WriteBinItem(LOG_STATUS,
                            (PVOID) pszStatus,
                            (pszStatus == NULL) ?
                            0 : strlen((const char *)pszStatus))

            || WriteBinItem(LOG_STRING,
                            (PVOID) pszStrData,
                            (pszStrData == NULL) ?
                            0 : strlen((const char *)pszStrData))
            || WriteBinItem(LOG_BINARY, pvBinData, usBinLen);

        if(ulLastError == NO_ERROR)
        {
            ++ulEventCount; // Increment the count of logged events

            if(pszStatus != NULL
               && strcmp(pszStatus, LOG_DONE_TXT) == SAME)
            {
                CloseLogFile();        // Make sure the data has been flushed
            }
        }
    }

    // Clean up in preparation for next packet

    va_list vaDummy = LOG_VA_NULL;
    SetStatus((PCHAR) NULL);
    SetVariation((PCHAR) NULL);
    ulEventTime = 0L;
    SetBinData(0, NULL);
    SetStrData((PCHAR) NULL, vaDummy);

    return FlushLogFile(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::wWriteToLogFile(VOID)
//
//  Synopsis:   Write data out to the log file.
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: wWriteToLogFile()
{
    CHK_UNICODE(TRUE);

    WCHAR wchBuf[COUNT_BUFLEN];

    int cLen = swprintf(wchBuf, L"%lu", ulEventCount + 1);

    ulLastError = WriteBinItem(LOG_EVENT_NUM, (PVOID) wchBuf,
                               cLen * sizeof(WCHAR));

    if(ulLastError == NO_ERROR)
    {
        //
        // If the event time has not already been set, set it to the
        // current system time.
        //

        cLen = swprintf(wchBuf, L"%lu", (ulEventTime==0L) ?
                        time((time_t *) NULL) : ulEventTime);

        ulLastError = WriteBinItem(LOG_EVENT_TIME,
                                   (PVOID) wchBuf,
                                   wcslen(wchBuf) * sizeof(WCHAR))

            || WriteBinItem(LOG_MACHINE,
                            (PVOID) wszMachineName,
                            (wszMachineName == NULL) ?
                            0 : wcslen(wszMachineName) * sizeof(WCHAR))

            || WriteBinItem(LOG_OBJECT,
                            (PVOID) wszObjectName,
                            (wszObjectName == NULL) ?
                            0 : wcslen(wszObjectName) * sizeof(WCHAR))

            || WriteBinItem(LOG_VARIATION,
                            (PVOID) wszVariation,
                            (wszVariation == NULL) ?
                            0 : wcslen(wszVariation) * sizeof(WCHAR))

            || WriteBinItem(LOG_STATUS,
                            (PVOID) wszStatus,
                            (wszStatus == NULL) ?
                            0 : wcslen(wszStatus) * sizeof(WCHAR))

            || WriteBinItem(LOG_STRING,
                            (PVOID) wszStrData,
                            (wszStrData == NULL) ?
                            0 : wcslen(wszStrData) * sizeof(WCHAR))

            || WriteBinItem(LOG_BINARY, pvBinData, usBinLen);

        if(ulLastError == NO_ERROR)
        {
            ++ulEventCount; // Increment the count of logged events

            if(wszStatus != NULL &&
               wcscmp(wszStatus, wLOG_DONE_TXT) == SAME)
            {
                CloseLogFile();        // Make sure the data has been flushed
            }
        }
    }

    // Clean up in preparation for next packet

    va_list vaDummy = LOG_VA_NULL;

    SetStatus((LPWSTR) NULL);
    SetVariation((LPWSTR) NULL);
    ulEventTime = 0L;
    SetBinData(0, NULL);
    SetStrData((LPWSTR) NULL, vaDummy);

    return FlushLogFile(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::WriteHeader(VOID)
//
//  Synopsis:   Write data about this logging file.  This only happens
//              when the file is first created.
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: WriteHeader()
{
    LogEventCount();

    if (ulLastError == NO_ERROR)
    {
        if(FALSE == fIsUnicode)
        {
            ulLastError = WriteBinItem(LOG_TEST_NAME, (PVOID) pszTestName,
                                       (pszTestName == NULL) ?
                                       0 : strlen(pszTestName));

            if (ulLastError == NO_ERROR)
            {
                char chBuf[COUNT_BUFLEN];

                // Show when log file was started

                int cLen = sprintf(chBuf, "%lu", time((time_t *)NULL));

                ulLastError =
                    WriteBinItem(LOG_TEST_TIME, (PVOID) chBuf, cLen) ||
                    WriteBinItem(LOG_SERVER, (PVOID) NULL, 0);
            }
        }
        else
        {
            ulLastError = WriteBinItem(LOG_TEST_NAME, (PVOID) wszTestName,
                                       (wszTestName == NULL) ? 0 :
                                       wcslen(wszTestName) * sizeof(WCHAR));

            if (ulLastError == NO_ERROR)
            {
                WCHAR wchBuf[COUNT_BUFLEN];

                // Show when log file was started

                int cLen = swprintf(wchBuf, L"%lu", time((time_t *)NULL));

                ulLastError =
                    WriteBinItem(LOG_TEST_TIME, (PVOID) wchBuf,
                                 cLen * sizeof(WCHAR)) ||
                    WriteBinItem(LOG_SERVER, (PVOID) NULL, 0);
            }
        }
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::WriteBinItem(CHAR, PVOID, ULONG)
//
//  Synopsis:   Attempt to write Binary data to the log file
//
//  Arguments:  [chMark]     The Item ID for the data
//              [pvItem]     Pointer to the data data
//              [ulItemLen]  Length of data to write
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              19-Sep_92  SarahJ    Changed length to be ULONG so
//                                   Data 32K can be written (note
//                                   with header stuff it is > 32K)
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: WriteBinItem(CHAR chMark,
                               PVOID  pvItem,
                               ULONG ulItemLen)
{
    if(fIsComPort != FALSE && chMark == LOG_BINARY)
    {
        return NO_ERROR;       // Do not send binary data to a COM port
    }

    //
    // Write everything at the end of the file except for the # events in
    // the file.
    //

    if(SEEK_TO((chMark == LOG_EVENTS)? FILE_BEGIN : FILE_END) != NO_ERROR)
    {
        ulLastError = GetLastError();
        return ulLastError;
    }

    CHAR szLen[LINE_HDR_LEN+1];

    //
    // Every field of data starts with a header of the form 'x:nnnnn:' where
    // 'x'   is the given ID char and nnnnn is the # of bytes of data.
    //

    int nLen = sprintf(szLen, "%c:%u:", chMark, ulItemLen);


    //
    // SarahJ - changed to not pad the number out to LINE_HDR_LEN -3, but to
    // use minimum # of digits as per DCR 527
    //

    // We do not have to check dwBytesWritten because WriteFile will
    // fail on a file if all bytes not written.
    DWORD dwBytesWritten;

    if(FALSE == WriteFile(hLogFile, (CONST LPVOID) szLen, nLen,
                          &dwBytesWritten, NULL))
    {
        ulLastError = GetLastError();
        return ulLastError;
    }

    if(ulItemLen > 0 && ulLastError == NO_ERROR)
    {
        if(FALSE == WriteFile(hLogFile, (CONST LPVOID) pvItem, ulItemLen,
                              &dwBytesWritten, NULL))
        {
            ulLastError = GetLastError();
            return ulLastError;
        }
    }

    // Every field of data ends with a '\n'

    if(FALSE == WriteFile(hLogFile, (CONST LPVOID) "\n", sizeof(CHAR),
                          &dwBytesWritten, NULL))
    {
        ulLastError = GetLastError();
    }

    // carriage return for com port
    if(fIsComPort == TRUE &&
       FALSE == WriteFile(hLogFile, (CONST LPVOID) "\r", sizeof(CHAR),
                          &dwBytesWritten, NULL))
    {
        ulLastError = GetLastError();
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::CheckDir(PCHAR)
//
//  Synopsis:   Make sure each subdirectory in the given path exists.
//
//  Arguments:  [pszRelPath]  - Pathname to check, relative to
//                              current directory
//
//  Returns:    NO_ERROR if the the directory does exist or was
//              successfully made. A GetLastError() value otherwise.
//
//
//
//  Modifies:
//
//  History:     ??-???-??  ????????  Created
//       92-Apr-17  DwightKr  Added EINVAL to _mkdir() check.  We'll
//                            get this back on the N386 compiler if
//                            the directory already exists
//       01-Jul-92  Lizch     Gutted routine to use much simpler ctcopy code
//                            courtesy of DwightKr
//
//       16-Sep-92  SarahJ    Added check that _fullpath does not return NULL
//                            to fix bug 300
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: CheckDir(PCHAR pszRelPath)
{
    CHK_UNICODE(FALSE);

    char *pszToken;
    char *pszFileName;
    char pszPath[_MAX_PATH];
    char szDirToMake[_MAX_PATH] = "\0";

    if(fIsComPort != FALSE)
    {
        return NO_ERROR;       // COM port directories are an oxymoran.
    }

    if(0 != GetFullPathNameA(pszRelPath, _MAX_PATH - 1, pszPath, &pszFileName))
    {

#ifdef TRACE
        printf("Making directory %s\n", pszPath);
#endif

        // First, we need to remove the filename off the
        // end of the path so we do not create a dir with it! Look for
        // the last backslash. It is either at the end (no file - error),
        // the beginning (file at root - error), somewhere in between, or
        // not at all.
        if(NULL == (pszFileName = strrchr(pszPath, '\\')) ||
           pszFileName == pszPath ||
           '\0' == *(pszFileName + 1))
        {
            *pszPath = '\0';
        }
        else
        {
            *pszFileName = '\0';
        }

        // Just blindly create directories based on the backslashes parsed
        // by strtok. We will look at the return from GetLastError to
        // if we were successful at the end.

        pszToken = strtok(pszPath, SLASH_STRING);
        while(pszToken != NULL)
        {
            strcat(szDirToMake, pszToken);

            if(CreateDirectoryA(szDirToMake, NULL) == TRUE)
            {
#ifdef TRACE
                printf ("Made directory %s\n", szDirToMake);
#endif
                ulLastError = NO_ERROR;
            }
            else
            {
#ifdef TRACE
                printf("Didn't make directory %s\n", szDirToMake);
#endif
                ulLastError = GetLastError();
            }

            pszToken = strtok(NULL, SLASH_STRING);
            if(pszToken != NULL)
            {
                strcat(szDirToMake, SLASH_STRING);
            }
        }

        // Leave error checking until we have tryed to add all directories -
        // we might as well simply check whether the final addition worked.
        // At this point, if the error return indicates the path already
        // exists as a directory or file, we need to error out if it is
        // actually a file.

        if(ulLastError == ERROR_FILE_EXISTS ||
           ulLastError == ERROR_ACCESS_DENIED ||
           ulLastError == ERROR_ALREADY_EXISTS)
        {
            DWORD dwAttr;

            // Now check if it is a directory, in which case we are OK, else if
            // it is a file we need to error out.

            if(~0 == (dwAttr = GetFileAttributesA(szDirToMake)))
            {
                ulLastError = GetLastError();
            }
            else
            {
                if(FILE_ATTRIBUTE_DIRECTORY == dwAttr)
                {
#ifdef TRACE
                    printf ("Path already existed - success!\n");
#endif
                    ulLastError = NO_ERROR;
                }
            }
        }
    }
    else  // GetFullPathName failed
    {
         ulLastError = GetLastError();
         fprintf(stderr, "Bad relative path %s\n", pszRelPath);
#ifdef DBG
         *szDirToMake = '\0';    // just done for below error message
#endif
    }

#ifdef DBG
    if(ulLastError != NO_ERROR)
    {
        fprintf(stderr, "Fatal error making logging directory:\n\t\t %s.\n"
                "Error %u.\n", szDirToMake, ulLastError);
    }
#endif
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::CheckDir(LPWSTR)
//
//  Synopsis:   Make sure each subdirectory in the given path exists.
//
//  Arguments:  [wszRelPath]  - Pathname to check, relative to
//                              current directory
//
//  Returns:    NO_ERROR if the the directory does exist or was
//              successfully made. An GetLastError() value otherwise.
//
//
//
//  Modifies:
//
//  History:     ??-???-??  ????????  Created
//       92-Apr-17  DwightKr  Added EINVAL to _mkdir() check.  We'll
//                            get this back on the N386 compiler if
//                            the directory already exists
//       01-Jul-92  Lizch     Gutted routine to use much simpler ctcopy code
//                            courtesy of DwightKr
//
//       16-Sep-92  SarahJ    Added check that _fullpath does not return NULL
//                            to fix bug 300
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: CheckDir(LPWSTR wszRelPath)
{
    CHK_UNICODE(TRUE);

    LPWSTR wszFileName;
    LPWSTR wszToken;
    WCHAR  wszPath[_MAX_PATH];
    WCHAR  wszDirToMake[_MAX_PATH] = L"\0";

    if(fIsComPort != FALSE)
    {
        return NO_ERROR;       // COM port directories are an oxymoran.
    }

    // check good directory name - is the NULL valid??
    if(0 != GetFullPathNameW(wszRelPath, _MAX_PATH - 1, wszPath, NULL))
    {

#ifdef TRACE
        printf("Making directory %ls\n", wszPath);
#endif

        // First, we need to remove the filename off the
        // end of the path so we do not create a dir with it! Look for
        // the last backslash. It is either at the end (no file - error),
        // the beginning (file at root - error), somewhere in between, or
        // not at all.
        if(NULL == (wszFileName = wcsrchr(wszPath, '\\')) ||
           wszFileName == wszPath ||
           '\0' == *(wszFileName + 1))
        {
            *wszPath = '\0';
        }
        else
        {
            *wszFileName = '\0';
        }

        // Just blindly create directories based on the backslashes parsed
        // by wcstok. We will look at the return from GetLastError to
        // if we were successful at the end.

        wszToken = wcstok(wszPath, wSLASH_STRING);
        while(wszToken != NULL)
        {
            wcscat(wszDirToMake, wszToken);

            if(CreateDirectoryW(wszDirToMake, NULL) == TRUE)
            {
#ifdef TRACE
                fprintf(stderr, "Made directory %ls\n", wszDirToMake);
#endif
                ulLastError = NO_ERROR;
            }
            else
            {
#ifdef TRACE
                fprintf(stderr, "Didn't make directory %ls\n", wszDirToMake);
#endif
                ulLastError = GetLastError();
            }

            wszToken = wcstok(NULL, wSLASH_STRING);
            if(wszToken != NULL)
            {
                wcscat(wszDirToMake, wSLASH_STRING);
            }
        }

        // Leave error checking until we have tryed to add all directories -
        // we might as well simply check whether the final addition worked.
        // At this point, if the error return indicates the path already
        // exists as a directory or file, we need to error out if it is
        // actually a file.

        if(ulLastError == ERROR_FILE_EXISTS ||
           ulLastError == ERROR_ALREADY_EXISTS)
        {
            DWORD dwAttr;

            // Now check if it is a directory, in which case we are OK, else if
            // it is a file we need to error out.

            if(~0 == (dwAttr = GetFileAttributesW(wszDirToMake)))
            {
                ulLastError = GetLastError();
            }
            else
            {
                if(FILE_ATTRIBUTE_DIRECTORY == dwAttr)
                {
#ifdef TRACE
                    fprintf(stderr, "Path already existed - success!\n");
#endif
                    ulLastError = NO_ERROR;
                }
            }
        }
    }
    else  // GetFullPathName failed
    {
         ulLastError = GetLastError();
         fprintf(stderr, "Bad relative path %ls\n", wszRelPath);
#ifdef DBG
         *wszDirToMake = L'\0';    // just done for below error message
#endif
    }

#ifdef DBG
    if(ulLastError != NO_ERROR)
    {
        fprintf(stderr, "Fatal error making logging directory:\n\t\t %ls.\n"
                "Error %u.\n", wszDirToMake, ulLastError);
    }
#endif
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member: LOGCLASS ::NewString(PCHAR *, const char *)
//
//  Synopsis:   This method will delete the existing string if it exists,
//              and (if a new string is given) will create and return a
//              duplicate string.
//              The assumption, here, is that the original pointer was
//              properly initialized to NULL prior to calling this method
//              the firsttime for that original string.
//
//  Arguments:  [pszOrig]   - The original string
//              [pszNewStr] - The new and improved string
//
//  Returns:    Returns NULL if 'new' fails or if pszNew is NULL.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: NewString(PCHAR *pszOrig, const char * pszNewStr)
{
    CHK_UNICODE(FALSE);

    DelString(pszOrig);

    // If a new string was given, duplicate it.

    if(pszNewStr != NULL)
    {
        *pszOrig = new char[strlen(pszNewStr) + 1];
        if(*pszOrig == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            strcpy(*pszOrig, pszNewStr);
        }
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member: LOGCLASS ::NewString(LPWSTR *, LPCWSTR)
//
//  Synopsis:   This method will delete the existing string if it exists,
//              and (if a new string is given) will create and return a
//              duplicate string.
//              The assumption, here, is that the original pointer was
//              properly initialized to NULL prior to calling this method
//              the firsttime for that original string.
//
//  Arguments:  [wszOrig]   - The original string
//              [wszNewStr] - The new and improved string
//
//  Returns:    Returns NULL if 'new' fails or if pszNew is NULL.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: NewString(LPWSTR *wszOrig, LPCWSTR wszNewStr)
{
    CHK_UNICODE(TRUE);

    DelString(wszOrig);

    // If a new string was given, duplicate it.

    if(wszNewStr != NULL)
    {
        *wszOrig = new WCHAR[wcslen(wszNewStr) + 1];
        if(*wszOrig == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            wcscpy(*wszOrig, wszNewStr);
        }
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member: LOGCLASS ::SetInfo(const char *, const char *,
//                             const char *, const char *)
//
//  Synopsis:   Set the logging information about the test being run.
//              User is set to pszTest OR logged on username OR MY_NAME in
//              that order of preference.
//              Machinename is set to computername OR MY_NAME in
//              that order of preference.
//
//
//  Arguments:  [pszSrvr]    - Name of logging server
//              [pszTest]    - Name of the test being run
//              [pszSubPath] - Log file path qualifier
//              [pszObject]  - Name of object logging the data
//
//  Returns:    USHORT - NO_ERROR (NO_ERROR) if successful.  Otherwise,
//                       the return value from SetTestName,
//                       SetTester, SetPath, or SerObjectName.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              09-Feb-92  BryanT    Added Win32 support
//              01-Jul-92  Lizch     Fixed bug where testername was getting
//                                   overwritten if machinename not set.
//              30-Jul-92  SarahJ    Fixed memory trashing bug - SetTester
//                                   & SetmachineName were trashing environment
//                                   variables
//              30-Oct-92  SarahJ    Removed all signs of pszTester - it
//                                   was only mis-used
//--------------------------------------------------------------------
ULONG LOGCLASS :: SetInfo(const char * pszSrvr,
                          const char * pszTest,
                          const char * pszSubPath,
                          const char * pszObject)
{
    CHK_UNICODE(FALSE);

//BUGBUG Temp code
LPSTR pszTempMachineName = "MyMachineName";
    ulLastError =
        SetTestName(pszTest)   ||
        SetPath(pszSubPath)    ||
        SetObjectName(pszObject);

    if(ulLastError != NO_ERROR)
    {
        return ulLastError;
    }

    if(pszMachineName == NULL)
    {
        //
        // Get network computername.  The computername field
        // is used for pszMachineName
        //

#if defined (__WIN32__) || defined (WIN32)

        LPBYTE lpbBuffer = NULL;
/* BUGBUG
        PCHAR pszName;
*/
        //
        // Then, get the machine name, if not already set.
        //

        if(pszMachineName == NULL)
        {
// BUGBUG  Temporary code
            SetMachineName(pszTempMachineName);
// BUGBUG  End of temporary code

/* BUGBUG
            if(NERR_Success == NetWkstaGetInfo(NULL, 101, &lpbBuffer))
            {
                pszName =
                    wcNametombs((PWCHAR) ((PWKSTA_INFO_101)lpbBuffer)->
                                wki101_computername);
                SetMachineName(pszName);
                NetApiBufferFree(lpbBuffer);
                delete pszName;
            }
*/
        }

#else

/* BUGBUG
        USHORT usAvail = 0;

        USHORT usRC = NetWkstaGetInfo(NULL, 10, NULL, 0, &usAvail);

        if(usRC == NERR_BufTooSmall && usAvail > 0)
        {
            PCHAR pchBuf = (PCHAR)new CHAR[usAvail];

            if(pchBuf != NULL)
            {
                usRC = NetWkstaGetInfo(NULL, 10, pchBuf, usAvail, &usAvail);

                if(usRC == NO_ERROR)
                {
                    if(pszMachineName == NULL)
                    {
                        SetMachineName(((struct wksta_info_10 *)
                                        pchBuf)->wki10_computername);
                    }
                }
                delete pchBuf;
            }
        }
*/
// BUGBUG  Temporary code
            SetMachineName(pszTempMachineName);
// BUGBUG  End of temporary code
#endif          // defined (__WIN32__) || (WIN32)

        if(pszMachineName == NULL)
        {
            fprintf(stderr, "ERROR! machine name not set\n");
        }
    }

    if(ulLastError == NO_ERROR)
    {
        fInfoSet = TRUE;        // Note that info has been set
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member: LOGCLASS ::SetInfo(LPCWSTR, LPCWSTR,
//                             LPCWSTR, LPCWSTR)
//
//  Synopsis:   Set the logging information about the test being run.
//              User is set to pszTest OR logged on username OR MY_NAME in
//              that order of preference.
//              Machinename is set to computername OR MY_NAME in
//              that order of preference.
//
//
//  Arguments:  [wszSrvr]    - Name of logging server
//              [wszTest]    - Name of the test being run
//              [wszSubPath] - Log file path qualifier
//              [wszObject]  - Name of object logging the data
//
//  Returns:    USHORT - NO_ERROR (NO_ERROR) if successful.  Otherwise,
//                       the return value from SetTestName,
//                       SetTester, SetPath, or SerObjectName.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              09-Feb-92  BryanT    Added Win32 support
//              01-Jul-92  Lizch     Fixed bug where testername was getting
//                                   overwritten if machinename not set.
//              30-Jul-92  SarahJ    Fixed memory trashing bug - SetTester
//                                   & SetmachineName were trashing environment
//                                   variables
//              30-Oct-92  SarahJ    Removed all signs of pszTester - it
//                                   was only mis-used
//--------------------------------------------------------------------
ULONG LOGCLASS :: SetInfo(LPCWSTR wszSrvr,
                          LPCWSTR wszTest,
                          LPCWSTR wszSubPath,
                          LPCWSTR wszObject)
{
    CHK_UNICODE(TRUE);

    ulLastError =
        SetTestName(wszTest)   ||
        SetPath(wszSubPath)    ||
        SetObjectName(wszObject);

    if(ulLastError != NO_ERROR)
    {
        return ulLastError;
    }

    if(wszMachineName == NULL)
    {
        //
        // Get network computername.  The computername field
        // is used for pszMachineName
        //

#if defined (__WIN32__) || defined (WIN32)

/* BUGBUG
        LPBYTE lpbBuffer;

        //
        // Then, get the machine name, if not already set.
        //

        if(wszMachineName == NULL)
        {
            if(NERR_Success == NetWkstaGetInfo(NULL, 101, &lpbBuffer))
            {
                SetMachineName((LPWSTR) (((PWKSTA_INFO_101)lpbBuffer)->
                                         wki101_computername));
                NetApiBufferFree(lpbBuffer);
            }
        }
*/

#else

        USHORT usAvail = 0;

// BUGBUG
//        USHORT usRC = NetWkstaGetInfo(NULL, 10, NULL, 0, &usAvail);

        if(usRC == NERR_BufTooSmall && usAvail > 0)
        {
            LPWSTR wchBuf = new WCHAR[usAvail];

            if(wchBuf != NULL)
            {
// BUGBUG
//                usRC = NetWkstaGetInfo(NULL, 10, pchBuf, usAvail, &usAvail);

                if(usRC == NO_ERROR)
                {
                    if(wszMachineName == NULL)
                    {
                        SetMachineName(((struct wksta_info_10 *)
                                        pchBuf)->wki10_computername);
                    }

                }
                delete wchBuf;
            }
        }
#endif          // defined (__WIN32__) || (WIN32)


        if(wszMachineName == NULL)
        {
            fprintf(stderr, "ERROR! machine name not set\n");
        }

    }

    if(ulLastError == NO_ERROR)
    {
        fInfoSet = TRUE;        // Note that info has been set
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::SetStrData(PCHAR, va_list)
//
//  Synopsis:   Set the string information that is to be logged.
//
//  Effects:    Create a temporary buffer for the formatted string, format
//              the string and copy the new formated string to pszStrData.
//              This version limits the formatted string to STRBUFSIZ chars.
//              See LOG.H for STRBUFSIZ value.  The only check I know how
//              to make is to strlen the format string.  It not a fool-proof
//              check but it's better than nothing...
//
//  Arguments:  [pszFmt]  - Format to use for writing the string (printf-like)
//              [pArgs]   - Arguments to print
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              16-Sep-92  SarahJ     changed code to use _vsnprintf
//                                   so that we allocate 1K first
//                                   if that is too small then 32K
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: SetStrData(PCHAR pszFmt, va_list pArgs)
{
    CHK_UNICODE(FALSE);

    if (pszFmt == NULL || *pszFmt == NULLTERM)
    {
        NewString(&pszStrData, NULL);
    }
    else
    {
        //
        //   Start off by allocating 1K
        //
        PCHAR szTmpBuf = new CHAR[STDSTRBUFSIZ];
        if (szTmpBuf == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //  note _vsnprintf returns -1 if szTmpBuf gets more than 1K

            int iLen;
            if ((iLen = _vsnprintf(szTmpBuf,
                                   STDSTRBUFSIZ - 1,
                                   pszFmt,
                                   pArgs)) >= 0)
            {
                ulLastError = NewString(&pszStrData, (const char *)szTmpBuf);
            }
            else if (iLen == -1)
            {
            //
            // So we have more than 1K data, so lets leap to allocating 32K
            //
                delete [] szTmpBuf;
                szTmpBuf = new CHAR[HUGESTRBUFSIZ];
                if (szTmpBuf == NULL)
                {
                    ulLastError = ERROR_NOT_ENOUGH_MEMORY;
                }

                else if ((iLen =_vsnprintf(szTmpBuf,
                                    HUGESTRBUFSIZ - 1,
                                    pszFmt,
                                    pArgs)) >= 0)
                {
                    ulLastError = NewString(&pszStrData,
                                            (const char *) szTmpBuf);
                }
                else if (iLen == -1) //we have a ton of date - so truncate
                {
                    strcpy(&szTmpBuf[HUGESTRBUFSIZ - STR_TRUNC_LEN - 2],
                           STR_TRUNCATION);
                    ulLastError = NewString(&pszStrData,
                                            (const char *) szTmpBuf);
                }
            }

            if (iLen < -1)   // from either _vsnprintf
            {
                ulLastError = TOM_CORRUPT_LOG_DATA;
	    }
            delete [] szTmpBuf;
        }

    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::SetStrData(LPWSTR, va_list)
//
//  Synopsis:   Set the string information that is to be logged.
//
//  Effects:    Create a temporary buffer for the formatted string, format
//              the string and copy the new formated string to pszStrData.
//              This version limits the formatted string to STRBUFSIZ chars.
//              See LOG.H for STRBUFSIZ value.  The only check I know how
//              to make is to strlen the format string.  It not a fool-proof
//              check but it's better than nothing...
//
//  Arguments:  [wszFmt]  - Format to use for writing the string (printf-like)
//              [pArgs]   - Arguments to print
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              16-Sep-92  SarahJ     changed code to use _vsnprintf
//                                   so that we allocate 1K first
//                                   if that is too small then 32K
//
//--------------------------------------------------------------------
ULONG  LOGCLASS :: SetStrData(LPWSTR wszFmt, va_list pArgs)
{
    CHK_UNICODE(TRUE);

    if(wszFmt == NULL || *wszFmt == wNULLTERM)
    {
        NewString(&wszStrData, NULL);
    }
    else
    {
        //
        //   Start off by allocating 1K
        //
        LPWSTR wszTmpBuf = new WCHAR[STDSTRBUFSIZ];
        if(wszTmpBuf == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //  note _vsnprintf returns -1 if szTmpBuf gets more than 1K

            int iLen;
            if((iLen = _vsnwprintf(wszTmpBuf, STDSTRBUFSIZ - 1,
                                   wszFmt, pArgs))
               >= 0)
            {
                ulLastError = NewString(&wszStrData, (LPCWSTR) wszTmpBuf);
            }
            else if(iLen == -1)
            {
            //
            // So we have more than 1K data, so lets leap to allocating 32K
            //
                delete [] wszTmpBuf;
                wszTmpBuf = new WCHAR[HUGESTRBUFSIZ];
                if(wszTmpBuf == NULL)
                {
                    ulLastError = ERROR_NOT_ENOUGH_MEMORY;
                }

                else if((iLen = _vsnwprintf(wszTmpBuf, HUGESTRBUFSIZ-1,
                                            wszFmt, pArgs))
                        >= 0)
                {
                    ulLastError = NewString(&wszStrData,
                                            (LPCWSTR) wszTmpBuf);
                }
                else if(iLen == -1) //we have a ton of date - so truncate
                {
                    wcscpy(&wszTmpBuf[HUGESTRBUFSIZ - STR_TRUNC_LEN - 2],
                           wSTR_TRUNCATION);
                    ulLastError = NewString(&wszStrData, (LPCWSTR) wszTmpBuf);
                }
            }

            if(iLen < -1)   // from either _vsnwprintf
            {
                ulLastError = TOM_CORRUPT_LOG_DATA;
	    }
            delete [] wszTmpBuf;
        }

    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::CloseLogFile(VOID)
//
//  Synopsis:   If a logging file is open, write event count to the
//              beginning of the file and close the file
//
//  Returns:    <nothing> - sets ulLastError if there is an error
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
void  LOGCLASS :: CloseLogFile(VOID)
{
    if(hLogFile != INVALID_HANDLE_VALUE)
    {
        LogEventCount();

        if (ulLastError == NO_ERROR && SEEK_TO(FILE_END) != NO_ERROR)
        {
            ulLastError = GetLastError();
        }

        CloseHandle(hLogFile);
        hLogFile = INVALID_HANDLE_VALUE;
    }

    if(FALSE == fIsUnicode)
    {
        SetLogFileName((PCHAR) NULL);
    }
    else
    {
        SetLogFileName((LPWSTR) NULL);
    }
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::SetBinData(USHORT, PVOID)
//
//  Synopsis:   Given a buffer of binary data, copy it into the internal
//              temp buffer.
//
//  Arguments:  [usBytes] - Number of bytes to transfer
//              [pvData]  - Pointer to data buffer
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG LOGCLASS :: SetBinData(USHORT usBytes, PVOID pvData)
{
    if(pvBinData != NULL)
    {
        delete pvBinData;
        pvBinData = NULL;
        usBinLen  = 0;
    }

    if(usBytes > 0 && pvData != NULL)
    {
        // Change to BYTE support WCHAR and CHAR transparently
        // PUCHAR puchData = (PUCHAR)new CHAR[usBytes];
        PBYTE pbData = new BYTE[usBytes];

        if(pbData == NULL)
        {
            usBinLen    = 0;
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            memcpy(pbData, pvData, (size_t)usBytes);
            usBinLen    = usBytes;
            pvBinData   = (PVOID)pbData;
            ulLastError = NO_ERROR;
        }
    }
    else if((usBytes > 0 && pvData == NULL)
            || (usBytes == 0 && pvData != NULL))
    {
        ulLastError = ERROR_INVALID_PARAMETER;
    }
    else
    {
        ulLastError = NO_ERROR;
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::LogPrintf(HANDLE, PCHAR, ...)
//
//  Synopsis:   This version has a max formared output of STRBUFSIZ
//              (see log.h).  The only check I know how to make is to
//              strlen the format string.  It is not fool-proof but it's
//              better than nothing. The method allows a printf-like format
//              and args to be written to a file opened with 'open()'.
//
//  Arguments:  [nHandle] - Output File handle
//              [pszFmt]  - Format string for output
//              [...]     - Data to pass printf()
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              16-Sep-92  SarahJ    Changed this function to at most write
//                                   STDSTRBUFSIZ bytes.
//
//  Note:       I have assumed that LogPrintf does not print > 1K
//              and can find no use with more data.
//              If I am wrong then the code from SetStrData should be
//              copied here.
//
//--------------------------------------------------------------------
int LOGCLASS :: LogPrintf(HANDLE hHandle, PCHAR pszFmt, ...)
{
    CHK_UNICODE(FALSE);

    if(pszFmt == NULL || strlen(pszFmt) >= STDSTRBUFSIZ)
    {
        ulLastError = ERROR_INVALID_PARAMETER;
    }
    else
    {
        PCHAR szTmpBuf = new CHAR[STDSTRBUFSIZ];
        if(szTmpBuf == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            va_list pMarker;

            va_start(pMarker, pszFmt);

            // On other error, return will be negative and not -1...
            int nLen = _vsnprintf(szTmpBuf, STDSTRBUFSIZ - 1, pszFmt, pMarker);

            // ...if -1 then buffer has more than STDSTRBUFSIZ chars in it,
            // but we will not support more in this method - truncate.
            if(nLen == -1)
            {
                nLen = (STDSTRBUFSIZ - 1) * sizeof(CHAR);
            }

            DWORD dwBytesWritten;

            if(nLen >= 0)
            {
                if(FALSE == WriteFile(hHandle, (CONST LPVOID) szTmpBuf, nLen,
                                      &dwBytesWritten, NULL))
                {
                    ulLastError = NO_ERROR;
                }
                else
                {
                    ulLastError = GetLastError();
                }
            }
            else
            {
                ulLastError = ERROR_INVALID_PARAMETER;
            }
            delete szTmpBuf;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::LogPrintf(HANDLE, LPWSTR, ...)
//
//  Synopsis:   This version has a max formared output of STRBUFSIZ
//              (see log.h).  The only check I know how to make is to
//              strlen the format string.  It is not fool-proof but it's
//              better than nothing. The method allows a printf-like format
//              and args to be written to a file opened with 'open()'.
//
//  Arguments:  [hHandle] - Output File handle
//              [wszFmt]  - Format string for output
//              [...]     - Data to pass printf()
//
//  Returns:    NO_ERROR if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              16-Sep-92  SarahJ    Changed this function to at most write
//                                   STDSTRBUFSIZ bytes.
//
//  Note:       I have assumed that LogPrintf does not print > 1K
//              and can find no use with more data.
//              If I am wrong then the code from SetStrData should be
//              copied here.
//
//--------------------------------------------------------------------
int LOGCLASS :: LogPrintf(HANDLE hHandle, LPWSTR wszFmt, ...)
{
    CHK_UNICODE(TRUE);

    if(wszFmt == NULL || wcslen(wszFmt) >= STDSTRBUFSIZ)
    {
        ulLastError = ERROR_INVALID_PARAMETER;
    }
    else
    {
        LPWSTR wszTmpBuf = new WCHAR[STDSTRBUFSIZ];
        if(wszTmpBuf == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            va_list pMarker;

            va_start(pMarker, wszFmt);

            int nLen = _vsnwprintf(wszTmpBuf, STDSTRBUFSIZ - 1, wszFmt,
                                   pMarker);

            if(nLen == -1)   // if -1 then buffer has STDSTRBUFSIZ char in it
            {
                nLen = (STDSTRBUFSIZ - 1) * sizeof(WCHAR);
            }

            DWORD dwBytesWritten;

            if(nLen >= 0)
            {
                if(FALSE == WriteFile(hHandle, (CONST LPVOID) wszTmpBuf, nLen,
                                      &dwBytesWritten, NULL))
                {
                    ulLastError = NO_ERROR;
                }
                else
                {
                    ulLastError = GetLastError();
                }
            }
            else
            {
                ulLastError = ERROR_INVALID_PARAMETER;
            }
            delete wszTmpBuf;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::FlushLogFile(USHORT)
//
//  Synopsis:   This version checks if flushing was requested.  If yes,
//              the logging file is closed.  The method simply retirns
//              it's parameter which, in the calling code is the value
//              of ulLastError.
//
//  Arguments:  [usErr]  - Return value
//
//  Returns:    Whatever is passed as the first argument
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//------------------------------------------------------------------
ULONG LOGCLASS :: FlushLogFile(ULONG ulErr)
{
    if(fFlushWrites != FALSE && hLogFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hLogFile);
        hLogFile = INVALID_HANDLE_VALUE;

        if(FALSE == fIsUnicode)
        {
            SetLogFileName((PCHAR) NULL);
        }
        else
        {
            SetLogFileName((LPWSTR) NULL);
        }

        fIsComPort = FALSE;
    }
    return ulErr;
}


//+-------------------------------------------------------------------
//
//  Member: LOGCLASS ::SetIsComPort(const char *)
//
//  Synopsis:   This version sets the element fIsComPort to TRUE if the
//              given name is that of a COM port, else FALSE.  This
//              version checks if the given file name is "COMn*" where
//              'n' is a numerical value > 0.
//
//  Arguments:  [pszFileName] - The file name to test
//
//  Returns:    TRUE if it is a comm port, FALSE otherwise
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
BOOL LOGCLASS :: SetIsComPort(const char * pszFileName)
{
    CHK_UNICODE(FALSE);

    BOOL  fRC = TRUE;

    if ((pszFileName  != NULL) &&
         (*pszFileName != NULLTERM) &&
     (_strnicmp(pszFileName, (const char *)"COM", 3) == SAME) &&
         (strlen(pszFileName) > 3))
    {
        PCHAR cp = (PCHAR)&pszFileName[3];

        // Make sure everything after COM is a digit
        do
        {
            if (!isdigit(*cp))
            {
                fRC = FALSE;
            }
        } while (fRC && ++cp);
    }
    else
    {
        fRC = FALSE;
    }
    return(fRC);
}


//+-------------------------------------------------------------------
//
//  Member: LOGCLASS ::SetIsComPort(LPCWSTR)
//
//  Synopsis:   This version sets the element fIsComPort to TRUE if the
//              given name is that of a COM port, else FALSE.  This
//              version checks if the given file name is "COMn*" where
//              'n' is a numerical value > 0.
//
//  Arguments:  [wszFileName] - The file name to test
//
//  Returns:    TRUE if it is a comm port, FALSE otherwise
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
BOOL LOGCLASS :: SetIsComPort(LPCWSTR wszFileName)
{
    CHK_UNICODE(TRUE);

    BOOL  fRC = TRUE;

    if((wszFileName != NULL) && (*wszFileName != NULLTERM) &&
       (_wcsnicmp(wszFileName, L"COM", 3) == SAME) &&
       (wcslen(wszFileName) > 3))
    {
        LPWSTR cp = (LPWSTR) &wszFileName[3];

        // Make sure everything after COM is a digit
        do
        {
            if(!isdigit(*cp))
            {
                fRC = FALSE;
            }
        }
        while(fRC && ++cp);
    }
    else
    {
        fRC = FALSE;
    }

    return fRC;
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS ::LogEventCount(VOID)
//
//  Synopsis:   This method causes the number of logged events that are
//              in this file is written into this log file.
//
//  Returns:    <nothing>
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
void LOGCLASS :: LogEventCount()
{
    if(TRUE == fIsUnicode)
    {
        wLogEventCount();
        return;
    }

    CHAR chBuf[COUNT_BUFLEN];

    int cLen = sprintf(chBuf, "%lu", ulEventCount);

    //
    // The event count needs to be padded so that as the count gets larger
    // we can insert in the file without overwriting the next line
    //

    while(cLen < COUNT_BUFLEN - 1)
    {
        chBuf[cLen++] = ' ';
    }
    chBuf[COUNT_BUFLEN - 1] = NULLTERM;

    WriteBinItem(LOG_EVENTS, (PVOID) chBuf, COUNT_BUFLEN - 1);
}


//+-------------------------------------------------------------------
//
//  Member:     LOGCLASS :: wLogEventCount(VOID)
//
//  Synopsis:   This method causes the number of logged events that are
//              in this file is written into this log file.
//
//  Returns:    <nothing>
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
void LOGCLASS :: wLogEventCount()
{
    CHK_UNICODE(TRUE);

    WCHAR wchBuf[COUNT_BUFLEN];

    int cLen = swprintf(wchBuf, L"%lu", ulEventCount);

    //
    // The event count needs to be padded so that as the count gets larger
    // we can insert in the file without overwriting the next line
    //

    while(cLen < COUNT_BUFLEN - 1)
    {
        wchBuf[cLen++] = L' ';
    }
    wchBuf[COUNT_BUFLEN - 1] = wNULLTERM;

    WriteBinItem(LOG_EVENTS, (PVOID) wchBuf,
                 (COUNT_BUFLEN - 1) * sizeof(WCHAR));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\log\log.h ===
//+-------------------------------------------------------------------
//
//  File:       log.h
//
//  Contents:   Common definitions used by logsvr.cxx and log.cxx
//
//  History:    18-Sep-90  DaveWi    Initial Coding
//              14-Oct-91  SarahJ    added LOG_PASS_TXT etc
//              31-Oct-91  SarahJ    added MIN_LINE_HDR_LEN
//              10-Feb-92  BryanT    Merged logid.h with this file.
//              16-Sep-92  SarahJ    added STD and HUGESTRBUFSIZEe.
//
//--------------------------------------------------------------------

#ifndef _LOGSVR_LOG_H_INCLUDED_
#define _LOGSVR_LOG_H_INCLUDED_

extern BOOL  fDebugOn;

#define SAME                0

#define LOG_OPEN_PARMS      6          // # parms in LogOpen packet
#define LOG_WRITE_PARMS    11          // # parms in LogWrote packet

#define LINE_HDR_LEN        8          // # bytes at beginning of log file data
                                       // line; must be greater than 3

#define MIN_LINE_HDR_LEN    4          // Minimum length that the hdr
                                       // can be. ie n:<len>:

#define STDSTRBUFSIZ       1024        // Default length of a formatted
                                       // string to be sent to the log file
#define HUGESTRBUFSIZ      32767       // Max len (incl null) of a formated
                                       // string to be sent to the log file

                                       // String logged if output > 32K
#define STR_TRUNCATION  \
    "\n     ****     OUTPUT TRUNCATED    **** \n\n"
#define wSTR_TRUNCATION  \
    L"\n     ****     OUTPUT TRUNCATED    **** \n\n"
#define STR_TRUNC_LEN      50

#define SLASH            '\\'          // File name component sep
#define NULLTERM         '\0'          // String terminating null

#define wSLASH           L'\\'          // File name component sep
#define wNULLTERM        L'\0'          // String terminating null

#define INVALID_PARAM_COUNT (unsigned short)65000 // Invalid # params in packet
#define INVALID_API         (unsigned short)65001 // Invalid API name in packet
#define CORRUPT_LOG_FILE    (unsigned short)65002 // Log file is corrupted

//
// These next 3 defines are used internally by the logging code.
//

#define API_TERMINATE     "TRPCLogServerStop"
#define API_OPENLOGFILE   "TRPCOpenLogFile"
#define API_WRITETOFILE   "TRPCWriteToLogFile"

#define wAPI_TERMINATE    L"TRPCLogServerStop"
#define wAPI_OPENLOGFILE  L"TRPCOpenLogFile"
#define wAPI_WRITETOFILE  L"TRPCWriteToLogFile"

//
// Registered name of logsrvr.  This is the name used, in the logging server,
// to register the logging server with Mailtrck
//

#define LOGSRVR_OBJECT_NAME   "LOGSVR"
#define wLOGSRVR_OBJECT_NAME  L"LOGSVR"

//
// Text strings for status fields
//

#define LOG_PASS_TXT    "VAR_PASS"
#define LOG_FAIL_TXT    "VAR_FAIL"
#define LOG_ABORT_TXT   "VAR_ABORT"
#define LOG_WARN_TXT    "WARNING"
#define LOG_INFO_TXT    "INFO"
#define LOG_START_TXT   "START"
#define LOG_DONE_TXT    "DONE"

#define wLOG_PASS_TXT   L"VAR_PASS"
#define wLOG_FAIL_TXT   L"VAR_FAIL"
#define wLOG_ABORT_TXT  L"VAR_ABORT"
#define wLOG_WARN_TXT   L"WARN"
#define wLOG_INFO_TXT   L"INFO"
#define wLOG_START_TXT  L"START"
#define wLOG_DONE_TXT   L"DONE"

//
// LOG FILE LINE IDENTIFIERS:
//    One of these is the first char in every line in the raw log file.
//    These are for parsing command line parameters, so no WCHAR required.
//

#define LOG_EVENTS        'e'          // # events in log file
#define LOG_TEST_NAME     'n'          // Name of the test
#define LOG_TEST_TIME     't'          // Time test logging started
#define LOG_TESTER        'u'          // User running the test
#define LOG_SERVER        's'          // Logging server's name
#define LOG_EVENT_NUM     'E'          // Event's sequential # in log
#define LOG_EVENT_TIME    'T'          // Time the event happened
#define LOG_MACHINE       'M'          // Machine sending log data
#define LOG_OBJECT        'O'          // Name of logging object
#define LOG_VARIATION     'V'          // Variation number
#define LOG_STATUS        'S'          // Logged status
#define LOG_STRING        'Z'          // String data
#define LOG_BINARY        'B'          // Binary data

// Needed to initialize va_list types to NULL - MIPS and ALPHA are
// not ANSI-compatible wrt va_end
//
#ifdef _M_ALPHA
#define LOG_VA_NULL {NULL, 0}
#else
#define LOG_VA_NULL NULL
#endif

#endif          // _LOGSVR_LOG_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\log\newlog.cxx ===
//+-------------------------------------------------------------------
//
//  File:       log.cxx
//
//  Contents:   The code for the logging servers client logging methods
//
//  Functions:  Log::Log()
//              Log::~Log()
//              Log::Info(inc, char *[])
//              Log::WriteData(PCHAR)
//
//  History:    24-Sep-90  DaveWi    Initial Coding
//              11-Mar-94  DaveY     Miniature Log.
//              10-Aug-95  ChrisAB   Changed fopen()s to _fsopens() for
//                                   proper chicago operation
//
//--------------------------------------------------------------------

#include <comtpch.hxx>
#pragma hdrstop


extern "C"
{
#include <stdarg.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <direct.h>
#include <share.h>
}


#include "log.hxx"
#include "log.h"



#define CCH_MAX_CHARS 1024

// Set up a table of the status text values

const char * aStatus[] = { LOG_PASS_TXT,
                           LOG_FAIL_TXT,
                           LOG_WARN_TXT,
                           LOG_ABORT_TXT,
                           LOG_INFO_TXT,
                           LOG_START_TXT,
                           LOG_DONE_TXT };

#ifdef WIN16
#define OutputDebugStringA OutputDebugString
#endif


//+-------------------------------------------------------------------
//
//  Member:     Log::Log(int, char *[], DWORD)
//
//  Synopsis:   Log constructor with command line data given
//
//  Arguments:  [argc]  - Argument count
//              [argv]  - Argument array
//              [fUseUnicode] - whether we should use WCHARs
//
//  Returns:    Results from Info()
//
//  History:    ??-???-??  ????????  Created
//              Jun-11-92  DonCl     added line to zero out LogStats struct
//
//--------------------------------------------------------------------
Log :: Log(int argc, char *argv[], DWORD dwCharType) :
  fInfoSet(FALSE),
  ulLastError(ERROR_SUCCESS)
{

#if defined (_WIN32)

    //
    // Check the result of the CMutex Contructor and continue if 
    // it succeeded
    //
    ulLastError = hMtxSerialize.QueryError();
    if (ulLastError == ERROR_SUCCESS)
    {
        ulLastError = Info(argc, argv);
    }

#else 

    ulLastError = Info(argc, argv);

#endif
}


//+-------------------------------------------------------------------
//
//  Member:     Log::Log(PCHAR, PCHAR, PCHAR, PCHAR, PCHAR)
//
//  Synopsis:   Log constructor with internal data given
//
//  Arguments:  [pszSrvr]    - Name of logging server
//              [pszTest]    - Name of this test
//              [pszName]    - Name of test runner
//              [pszSubPath] - Users log file qualifer
//              [pszObject]  - Name of invoking object
//
//  Returns:
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              Jun-11-92  DonCl     added line to zero out LogStats struct
//
// BUGBUG wszName unused - left until all components can co-ordinate
//                         with this. SarahJ
//--------------------------------------------------------------------
Log :: Log(PCHAR pszSrvr,
           PCHAR pszTest,
           PCHAR pszName,
           PCHAR pszSubPath,
           PCHAR pszObject) : ulLastError(ERROR_SUCCESS)
{

#if defined (_WIN32)

    //
    // Check the result of the CMutex Contructor and continue if
    // it succeeded
    //
    ulLastError = hMtxSerialize.QueryError();
    if (ulLastError != ERROR_SUCCESS)
    {
        return;
    }

#endif
    InitLogging();

    // Print warning if server name given
/* BUGBUG Need to restore this once remote server is supported.
    if(NULL != pszSrvr)
    {
        fprintf(stderr, "Remote server not supported with this version of "
                "log.lib. Continuing.\n");
    }
*/

    ulLastError = SetInfo(NULL, pszTest,  pszSubPath, pszObject);
    if(ulLastError == ERROR_SUCCESS)
    {
        ulLastError = LogOpen();

        if(ulLastError == ERROR_SUCCESS)
        {
            WriteData("\n*LOG_START*-%s", pszShortLogFileName);
        }
    }
}


//+-------------------------------------------------------------------
//
//  Member:     Log::~Log()
//
//  Synopsis:   Destroy the Log Object
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
Log :: ~Log()
{
    if(fInfoSet != FALSE)
    {
        if(WriteData("\n*LOG_DONE*") != ERROR_SUCCESS)
        {    
            LogPrintf(stderr, "ERROR: Failed to log \"%s\" status\n",
                  LOG_DONE_TXT);
        }
    }
    SetLoggingDir((PCHAR) NULL);
    SetMachineName((PCHAR) NULL);
    SetObjectName((PCHAR) NULL);
    SetTestName((PCHAR) NULL);
    SetPath((PCHAR) NULL);
    SetStatus((PCHAR) NULL);
    SetLogFileName((PCHAR) NULL);
    SetShortLogFileName((PCHAR) NULL);
    CloseLogFile();
}

//+-------------------------------------------------------------------
//
//  Member:     Log::Info(int, char *[])
//
//  Synopsis:   Parse the command line and set the appropriate member variables
//
//  Arguments:  [argc] - Argument count
//              [argv] - Argument vector
//
//  Returns:
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              30-Oct-92  SarahJ    Updated parms to SetInfo
//
//--------------------------------------------------------------------
ULONG Log :: Info(int argc, char *argv[])
{
    USHORT usNdx;               // Index into cmnd line args
    PCHAR  pszTest    = NULL;   // Name of this test
    PCHAR  pszSubPath = NULL;   // Users log file qualifer
    PCHAR  pszObject  = NULL;   // Name of invoking object
    PCHAR  pch;                 // Temporary pointer into a string


    InitLogging();

    // All the argv processing is still done in CHARs
    if(ulLastError == ERROR_SUCCESS)
    {
        //
        // For every command line switch, check its validity and parse its
        // value.  This version allows / or - for switches.  If there are
        // no command line switches, this loop is skipped.  This is for the
        // case when Log() is called with no messages.
        //

        for(usNdx = 1; usNdx < (unsigned short) argc; ++usNdx)
        {
            char *szArg = argv[ usNdx];
            pch = szArg;

            // check for / -

            if(*szArg == '/' || *szArg == '-')
            {
                register int i = 1;
                pch++;

                //
                // Check if next char is m, ie handed down from manager code.
                // If so skip m
                //

                if (*pch == 'm' || *pch == 'M')
                {
                    pch++;
                    i++;
                }

                ++pch;           // Skip next char and check for :

                if(*pch++ == ':')
                {
                    switch(toupper(szArg[i]))
                    {
                      case 'O':       // Object name found

                        pszObject = (PCHAR)pch;
                        break;

                      case 'P':       // Directory Path switch found

                        pszSubPath = (PCHAR)pch;
                        break;

                      case 'L':       // Logging server name found

                        // BUGBUG We don't want this message spit to debugger
                        // all the time.
                        // BUGBUG OutputDebugStringA("Logging server not supported with "
                        // BUGBUG         "this version of log.lib. Continuing.\n");
                        break;

                      case 'T':       // Test name found

                        pszTest = (PCHAR)pch;
                        break;

                      default:        // Skip this unknown argument

                        break;
                    }
                }
            }
        }

        // If no test name was given, set pszTest to the apps base name.

        char szName[_MAX_FNAME];

        if(pszTest == NULL || *pszTest == NULLTERM)
        {
            GetBaseFilename(argv[0], szName);
            pszTest = szName;
        }

    }

    ulLastError = SetInfo(NULL, pszTest, pszSubPath, pszObject);

    // This was not here before, but it seems the log should be opened by now
    if(ERROR_SUCCESS == ulLastError)
    {
        ulLastError = LogOpen() || WriteData("\n*LOG_START*-%s", pszShortLogFileName);

    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteData(PCHAR, ...)
//
//  Synopsis:   Write a string to the Log file.
//
//  Arguments:  [pszFormat] - a printf-like format string
//              [...]       - The data to print out.
//
//  Returns:    ERROR_SUCCESS if successful
//              Any error code from Log::SetStrData() or Log::LogData
//              or CTCLock::QueryError()
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG Log :: WriteData(PCHAR psz, ...)
{

    CHAR szBuffer[CCH_MAX_CHARS];
    va_list varArgs;

#ifndef WIN16
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
    ULONG ulErr = clMemLock.QueryError();
    if (ulErr != NO_ERROR)
    {
        return ulErr;
    }
#endif

    szBuffer[0] = '\0';
    szBuffer[CCH_MAX_CHARS-1] = '\0';

    if ((psz != NULL) && (pfLog != NULL))
    {

        // Print the caller's string to a buffer
        va_start(varArgs, psz);
        _vsnprintf(szBuffer, CCH_MAX_CHARS-1, psz, varArgs);
        va_end(varArgs);

        int iRet = fprintf(pfLog, "%s\n", szBuffer);
        if (iRet < 0)
        {
            OutputDebugStringA("CTLOG::Failed to log data string : ");
            OutputDebugStringA(szBuffer);
            OutputDebugStringA("\n");
        }
        else 
        {
            fflush(pfLog);
        }
    }
    return(ERROR_SUCCESS);
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteData2(PCHAR)
//
//  Synopsis:   Write a string to the Log file.
//
//  Arguments:  [psz] - string to print out
//
//  Returns:    ERROR_SUCCESS if successful
//              Any error code from Log::SetStrData() or Log::LogData
//              or CTCLock::QueryError()
//
//  Modifies:   ulLastError
//
//  History:    3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG Log :: WriteData2(PCHAR psz)
{

#ifndef WIN16
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
    ULONG ulErr = clMemLock.QueryError();
    if (ulErr != NO_ERROR)
    {
        return ulErr;
    }
#endif

    if ((psz != NULL) && (pfLog != NULL))
    {

        int iRet = fprintf(pfLog, "%s", psz);
        if (iRet < 0)
        {
            OutputDebugStringA("CTLOG::Failed to log data string : ");
            OutputDebugStringA(psz);
            OutputDebugStringA("\n");
        }
        else 
        {
            fflush(pfLog);
        }
    }
    return(ERROR_SUCCESS);
}

#ifndef WIN16
//+-------------------------------------------------------------------
//
//  Member:     Log::WriteData2(PWCHAR)
//
//  Synopsis:   Write a string to the Log file.
//
//  Arguments:  [pwsz] - string to print out
//
//  Returns:    ERROR_SUCCESS if successful
//              Any error code from Log::SetStrData() or Log::LogData
//              or CTCLock::QueryError()
//
//  Modifies:   ulLastError
//
//  History:    3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG Log :: WriteData2(PWCHAR pwsz)
{

#ifndef WIN16
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
    ULONG ulErr = clMemLock.QueryError();
    if (ulErr != NO_ERROR)
    {
        return ulErr;
    }
#endif

    if ((pwsz != NULL) && (pfLog != NULL))
    {

        int iRet = fprintf(pfLog, "%ls", pwsz);
        if (iRet < 0)
        {
            OutputDebugStringA("CTLOG::Failed to log data string : ");
            // Note on Chicago this call will be stubbed out.
            OutputDebugStringW(pwsz);
            OutputDebugStringA("\n");
        }
        else 
        {
            fflush(pfLog);
        }
    }
    return(ERROR_SUCCESS);
}

#endif

//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVar
//
//  Synopsis:   Write a variation status to the Log file.
//
//  Arguments:  
//
//  Returns:    ERROR_SUCCESS if successful
//              Any error code from Log::SetStrData() or Log::LogData
//              or CTCLock::QueryError()
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG  Log :: WriteVar(PCHAR pszVariation,
                    USHORT usStatus,
                    PCHAR pszStrFmt, ... )
{

    CHAR szBuffer[CCH_MAX_CHARS];
    va_list varArgs;

#ifndef WIN16
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
    ULONG ulErr = clMemLock.QueryError();
    if (ulErr != NO_ERROR)
    {
        return ulErr;
    }
#endif

    szBuffer[0] = '\0';
    szBuffer[CCH_MAX_CHARS-1] = '\0';
    if (pfLog != NULL)
    {
        int iRet;

        if (pszStrFmt != NULL)
        {
            // Print the caller's string to a buffer
            va_start(varArgs, pszStrFmt);
            _vsnprintf(szBuffer, CCH_MAX_CHARS-1, pszStrFmt, varArgs);
            va_end(varArgs);

            iRet = fprintf(pfLog, "%s: %s: %s\n", aStatus[usStatus], 
                    pszVariation, szBuffer);
        }
        else
        {
            iRet = fprintf(pfLog, "%s: %s\n", aStatus[usStatus], pszVariation);    
        }
        if (iRet < 0)
        {
            OutputDebugStringA("CTLOG::Failed to log variation string : ");
            OutputDebugStringA(pszVariation);
            OutputDebugStringA("\n");
        }
        else 
        {
            fflush(pfLog);
        }
        fflush(pfLog);
    }

    return(ERROR_SUCCESS);

}


//+-------------------------------------------------------------------
//
//  Member:     Log ::InitLogging(VOID)
//
//  Synopsis:   Initialize the classes data members.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
void Log :: InitLogging(VOID)
{
    pszLoggingDir = NULL;
    pszMachineName = NULL;
    pszObjectName = NULL;
    pszTestName = NULL;
    pszPath = NULL;
    pszStatus = NULL;
    pszVariation = NULL;
    pszLogFileName = NULL;
    pszShortLogFileName = NULL;
    fInfoSet = FALSE;
    pfLog = NULL;
}


//+-------------------------------------------------------------------
//
//  Member:     Log ::SetLogFile(VOID)
//
//  Synopsis:   Combine the logging file name components into a full path
//              file name.  If this new file name is not the same as that
//              referenced by element pszLogFileName, switch to log data
//              into the file in this new name.
//
//  Returns:    ERROR_SUCCESS if successful, else
//              ERROR_INVALID_PARAMETER
//              ERROR_OUTOFMEMORY
//              ERROR_CANTOPEN
//               Any error from AddComponent, CheckDir, SetLogFileName,
//               or SetEventCount
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG Log :: SetLogFile()
{
    if (((pszLoggingDir != (PCHAR) NULL) &&
         (strlen(pszLoggingDir) > _MAX_PATH)) ||
        ((pszPath != NULL) && (strlen(pszPath) > _MAX_PATH)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    PCHAR pszNewFileName = new char[_MAX_PATH + 1];
    if(pszNewFileName == NULL)
    {
        return ERROR_OUTOFMEMORY;
    }

    //
    // No -
    // For each component of the new log file path, append it to the
    // root logging directory.  Make sure only one back-slash exists
    // between each appended path component.
    //

    if(pszLoggingDir != NULL && *pszLoggingDir != NULLTERM)
    {
        strcpy(pszNewFileName, pszLoggingDir);
    }
    else
    {
        *pszNewFileName = NULLTERM;
    }


    ulLastError =
        AddComponent(pszNewFileName, pszPath) ||
        AddComponent(pszNewFileName, pszTestName);

    //
    // The the new file name was successfully built, see if it the same as
    // the name of the currently open log file (if one is open).  If is not
    // the same file name, close the open one (if open) and open the new
    // logging file.  If the open is successful, save the name of the newly
    // opened file for the next time thru here.
    //
    // A later version of this method could be written to create a LRU queue
    // of some max number of open logging files.  This version just keeps one
    // file open at a time, closing it only to switch to a different log file.
    //

    if(ulLastError == ERROR_SUCCESS)
    {
        strcat(pszNewFileName, (const char *)".Log");


        ulLastError = SetLogFileName((const char *) pszNewFileName);
       
        if  (ulLastError == ERROR_SUCCESS)
        {
            char szName[_MAX_FNAME];
            GetBaseFilename(pszNewFileName, szName);
            ulLastError = SetShortLogFileName((const char *) szName);
        }

        if  (ulLastError == ERROR_SUCCESS)
        {
            // Changed this from fopen() to work on chicago 16 bit
            pfLog = _fsopen(pszNewFileName, "a", _SH_DENYNO);

            if(pfLog == NULL)
            {
                ulLastError = ERROR_CANTOPEN;
                OutputDebugStringA("CTLOG::Failed to create log file");
                OutputDebugStringA(pszNewFileName);
                OutputDebugStringA("\n");
            }
        }
    }

    delete [] pszNewFileName;
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log ::AddComponent(PCHAR, PCHAR)
//
//  Synopsis:   Append a path component to the given string in szNewName.
//              Make sure there is one and only one '\' between each
//              component and no trailing '\' is present.
//
//  Arguments:  [szNewName]   - Pointer to exist path (must not be NULL)
//              [szComponent] - New component to add
//
//  Returns:    ERROR_SUCCESS if successful
//              ERROR_INVALID_PARAMETER
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG Log :: AddComponent(PCHAR szNewName, PCHAR szComponent)
{

    PCHAR pch = NULL;

    // Path component provided?

    if (szComponent != NULL && *szComponent != NULLTERM)
    {
        int nLen = strlen((const char *)szComponent);

        //
        // Trim trailing and leading '\'s from the component to be appended,
        // then append the component to the file name.
        //

        pch = szComponent + nLen;

        while (pch > szComponent)
        {
            if (*pch == SLASH)
            {
                *pch = NULLTERM;
                pch--;
            }
            else
            {
                break;
            }
        }
        pch = szComponent;

        while (*pch == SLASH)
        {
            pch++;
        }

        //
        // Append one '\' to the file name then append the given component.
        //

        if (strlen((const char *)szNewName) + nLen + 1 < _MAX_PATH)
        {
            nLen = strlen((const char *)szNewName);

            if (nLen > 0)
            {                               // Add component separater
                szNewName[ nLen++] = SLASH;
            }
            strcpy(&szNewName[nLen], (const char *)pch);
        }
        else
        {
            ulLastError = ERROR_INVALID_PARAMETER;
        }
    }

    return(ulLastError);
}




//+-------------------------------------------------------------------
//
//  Member:     Log ::LogOpen(VOID)
//
//  Synopsis:   If we are not in the LogSvr and if logging remotly, try
//              to a START record to the server.  If not, or if the attempt
//              fails, log the data locally. This may require opening the
//              local log file.
//
//  Returns:    ERROR_SUCCESS if successful
//              Results from Remote(), SetLogFile(), or OpenLogFile()
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG Log :: LogOpen()
{
    if(pfLog == NULL)
    {
        //
        // Something failed in the remote logging attempt, or this is our
        // first call to open the log file, so set up to log locally.
        //

        ulLastError = SetLogFile();

        if(ulLastError != ERROR_SUCCESS)
        {
            return ulLastError;    // Setup failed...  Don't go any further.
        }
    }

    return ERROR_SUCCESS;
}


//+-------------------------------------------------------------------
//
//  Member: Log ::SetInfo(const char *, const char *,
//                             const char *, const char *)
//
//  Synopsis:   Set the logging information about the test being run.
//              User is set to pszTest OR logged on username OR MY_NAME in
//              that order of preference.
//              Machinename is set to computername OR MY_NAME in
//              that order of preference.
//
//
//  Arguments:  [pszSrvr]    - Name of logging server
//              [pszTest]    - Name of the test being run
//              [pszSubPath] - Log file path qualifier
//              [pszObject]  - Name of object logging the data
//
//  Returns:    USHORT - ERROR_SUCCESS (ERROR_SUCCESS) if successful.  Otherwise,
//                       the return value from SetTestName,
//                       SetTester, SetPath, or SerObjectName.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              09-Feb-92  BryanT    Added Win32 support
//              01-Jul-92  Lizch     Fixed bug where testername was getting
//                                   overwritten if machinename not set.
//              30-Jul-92  SarahJ    Fixed memory trashing bug - SetTester
//                                   & SetmachineName were trashing environment
//                                   variables
//              30-Oct-92  SarahJ    Removed all signs of pszTester - it
//                                   was only mis-used
//--------------------------------------------------------------------
ULONG Log :: SetInfo(const char * pszSrvr,
                          const char * pszTest,
                          const char * pszSubPath,
                          const char * pszObject)
{

    ulLastError =
        SetTestName(pszTest) ||
        SetPath(pszSubPath) ||
        SetObjectName(pszObject);

    if(ulLastError == ERROR_SUCCESS && pszMachineName == NULL)
    {
        SetMachineName("MyMachineName");

        if(pszMachineName == NULL)
        {
            // ulLastError has been set to error by SetMachineName.
            fprintf(stderr, "ERROR! machine name not set\n");
        }
    }

    if(ulLastError == ERROR_SUCCESS)
    {
        fInfoSet = TRUE;        // Note that info has been set
    }
    return ulLastError;
}

//+-------------------------------------------------------------------
//
//  Member:     Log ::OpenLogFile(VOID)
//
//  Synopsis:   Opens log file if not already open.
//
//  Returns:    ERROR_SUCCESS if successful, else ERROR_CANTOPEN
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG  Log :: OpenLogFile(VOID)
{
    ULONG ulErr = ERROR_SUCCESS;

    if(pfLog == NULL)
    {
        // changed this from fopen() to work on chicago 16 bit
        pfLog = _fsopen(pszLogFileName, "a", _SH_DENYNO);
        if(pfLog == NULL)
        {
            ulErr = ERROR_CANTOPEN;
        }
    }
    return(ulErr);
}

//+-------------------------------------------------------------------
//
//  Member:     Log ::CloseLogFile(VOID)
//
//  Synopsis:   If a logging file is open, write event count to the
//              beginning of the file and close the file
//
//  Returns:    <nothing> - sets ulLastError if there is an error
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
void  Log :: CloseLogFile(VOID)
{
    if(pfLog != NULL)
    {
        fclose(pfLog);
        pfLog = NULL;
    }

//    SetLogFileName((PCHAR) NULL);
}


//+-------------------------------------------------------------------
//
//
//  Member:     Log ::LogPrintf(HANDLE, PCHAR, ...)
//
//  Synopsis:   This version has a max formared output of STRBUFSIZ
//              (see log.h).  The only check I know how to make is to
//              strlen the format string.  It is not fool-proof but it's
//              better than nothing. The method allows a printf-like format
//              and args to be written to a file opened with 'open()'.
//
//  Arguments:  [nHandle] - Output File handle
//              [pszFmt]  - Format string for output
//              [...]     - Data to pass printf()
//
//  Returns:    ERROR_SUCCESS if successful
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              16-Sep-92  SarahJ    Changed this function to at most write
//                                   STDSTRBUFSIZ bytes.
//
//  Note:       I have assumed that LogPrintf does not print > 1K
//              and can find no use with more data.
//              If I am wrong then the code from SetStrData should be
//              copied here.
//
//--------------------------------------------------------------------
int Log :: LogPrintf(FILE *pf, PCHAR pszFmt, ...)
{
    return ERROR_SUCCESS;
}



//+-------------------------------------------------------------------
//
//  Member: Log ::NewString(PCHAR *, const char *)
//
//  Synopsis:   This method will delete the existing string if it exists,
//              and (if a new string is given) will create and return a
//              duplicate string.
//              The assumption, here, is that the original pointer was
//              properly initialized to NULL prior to calling this method
//              the firsttime for that original string.
//
//  Arguments:  [pszOrig]   - The original string
//              [pszNewStr] - The new and improved string
//
//  Returns:    ERROR_SUCCESS if successful, else ERROR_OUTOFMEMORY.
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
ULONG Log :: NewString(PCHAR *pszOrig, const char * pszNewStr)
{

    DelString(pszOrig);

    // If a new string was given, duplicate it.

    if(pszNewStr != NULL)
    {
        *pszOrig = new char[strlen(pszNewStr) + 1];
        if(*pszOrig == NULL)
        {
            ulLastError = ERROR_OUTOFMEMORY;
        }
        else
        {
            strcpy(*pszOrig, pszNewStr);
        }
    }

    return ulLastError;
}



//+-------------------------------------------------------------------
//
//  Function:   DelString(PCHAR *)
//
//  Synopsis:   Given a pointer to a string, delete the memory if necessary
//               and set the pointer to NULL
//
//  Arguments:  [pszOrig]  Original string to delete
//
//  Returns:    <nothing>
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
VOID Log :: DelString(PCHAR *pszOrig)
{
    if (*pszOrig != NULL)
    {
        delete *pszOrig;
        *pszOrig = NULL;
    }
}



//+-------------------------------------------------------------------
//
//  Function:   GetBaseFilename
//
//  Synopsis:   Return a filename with it's extension and path 
//              stripped off
//
//  Arguments:  [pszFileWithExtension]  -- The full filename
//              [pszBaseName]           -- Where to put the base name
//
//  Returns:    <nothing>
//
//  History:    15-Apr-96   MikeW   Created
//              17-Oct-96   EricHans Fixed to return with path stripped
//
//--------------------------------------------------------------------

void Log :: GetBaseFilename(LPSTR pszFileWithExtension, LPSTR pszBaseName)
{
    LPSTR   pszStartOfExtension;
    LPSTR   pszLastBackslash;
    UINT    nCharsInBase;

    pszStartOfExtension = strrchr(pszFileWithExtension, '.');

    // assume this is a fully qualified path or
    // just the filename itself
    pszLastBackslash = strrchr(pszFileWithExtension, '\\');

    if (NULL == pszStartOfExtension)
    {
        // find the end of the string
        pszStartOfExtension = strchr(pszFileWithExtension, '\0');
    }

    if (NULL == pszLastBackslash)
    {
        nCharsInBase = pszStartOfExtension - pszFileWithExtension;

        strncpy(pszBaseName, pszFileWithExtension,  nCharsInBase);
    }
    else
    {
        if (pszLastBackslash > pszStartOfExtension)
        {
            // boundary condition: there's actually a dot in the path
            // find the end of the string instead
            pszStartOfExtension = strchr(pszFileWithExtension, '\0');
        }

        nCharsInBase = (pszStartOfExtension - pszLastBackslash) - 1;    
    
        strncpy(pszBaseName, pszLastBackslash + 1, nCharsInBase);
    }

    pszBaseName[nCharsInBase] = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\log\log.cxx ===
//+-------------------------------------------------------------------
//
//  File:       log.cxx
//
//  Contents:   The code for the logging servers client logging methods
//
//  Functions:  Log::Log()
//              Log::Log(int, char *[])
//              Log::Log(PCHAR, PCHAR, PCHAR, PCHAR, PCHAR)
//              Log::Log(LPWSTR, LPWSTR, LPWSTR, LPWSTR, LPWSTR)
//              Log::~Log()
//              Log::Info(inc, char *[])
//              Log::WriteVar(PCHAR, USHORT, PCHAR, ...)
//              Log::WriteVar(LPWSTR, USHORT, LPWSTR, ...)
//              Log::WriteVar(PCHAR, USHORT, USHORT, PVOID, PCHAR, ...)
//              Log::WriteVar(LPWSTR, USHORT, USHORT, PVOID, LPWSTR, ...)
//              Log::WriteVarList(PCHAR, USHORT, PCHAR, va_list)
//              Log::WriteVarList(LPWSTR, USHORT, LPWSTR, va_list)
//              Log::WriteVarList(PCHAR, USHORT, USHORT, PVOID, PCHAR, va_list)
//              Log::WriteVarList(LPWSTR, USHORT, USHORT, PVOID,
//                                LPWSTR, va_list)
//              Log::WriteData(PCHAR, ...)
//              Log::WriteData(LPWSTR, ...)
//              Log::WriteData(USHORT, PVOID, PCHAR, ...)
//              Log::WriteData(USHORT, PVOID, LPWSTR, ...)
//              Log::WriteDataList(PCHAR, va_list)
//              Log::WriteDataList(LPWSTR, va_list)
//              Log::WriteDataList(USHORT, PVOID, PCHAR, va_list)
//              Log::WriteDataList(USHORT, PVOID, LPWSTR, va_list)
//
//  History:    24-Sep-90  DaveWi    Initial Coding
//              15-Aug-91  AliceSe   set local logging if error binding
//              25-Sep-91  BryanT    Converted to C 7.0
//              17-Oct-91  SarahJ    DCR 525 - changed status parm of
//                                    WriteVar methods to USHORT and validated
//                                    parm to be in expected range
//              31-Oct-91  SarahJ    Now takes /L or /mL for server parm
//              10-Feb-92  BryanT    Win32 work and cleanup
//               3-Jul-92  DeanE     Added WriteVarList, WriteDataList, and
//                                   changed existing WriteVar and WriteData
//                                   methods to call them
//               1-Aug-92  DwightKr  Renamed CPCHAR as CPPSZ.  CPCHAR
//                                   conflicted with the 297 version of
//                                   windows.h
//              31-Oct-92  SarahJ    Removed references to tester name
//
//--------------------------------------------------------------------

#include <pch.cxx>
// BUGBUG Precompiled header does not work on Alpha for some unknown reason and
// so we temporarily remove it.
// #pragma hdrstop


// Set up a table of the status text values

const char * aStatus[] = { LOG_PASS_TXT,
                           LOG_FAIL_TXT,
                           LOG_WARN_TXT,
                           LOG_ABORT_TXT,
                           LOG_INFO_TXT,
                           LOG_START_TXT,
                           LOG_DONE_TXT };

LPWSTR waStatus[] = { wLOG_PASS_TXT,
                      wLOG_FAIL_TXT,
                      wLOG_WARN_TXT,
                      wLOG_ABORT_TXT,
                      wLOG_INFO_TXT,
                      wLOG_START_TXT,
                      wLOG_DONE_TXT };


//+----------------------------------------------------------------------------
//
//    Function:  IncLogStats(), static
//
//    Synopsis:  Increments the appropriate member of the passed-in LogStats
//               struct based on value of the usStatus passed in.
//
//    Effects:   Maintains correct status of the LogStats struct so we can
//               keep a running count of the log records written.
//
//    Arguments: [out] LogStats& stStats - structure to modify
//               [in]  ULONG    usStat  - code tells which field to increment
//
//    Returns:   nothing
//
//    Modifies:  stStats
//
//    History:   11-Jun-92  DonCl    first version
//
//    Notes:     Used by different overloaded versions of WriteVar()
//
//-----------------------------------------------------------------------------

static VOID IncLogStats(LogStats& stStats, USHORT usStats)
{
    switch(usStats)
    {
      case LOG_PASS:
        stStats.ulPass++;
        break;

      case LOG_FAIL:
        stStats.ulFail++;
        break;

      case LOG_WARN:
        stStats.ulWarn++;
        break;

      case LOG_ABORT:
        stStats.ulAbort++;
        break;

      case LOG_INFO:
        stStats.ulInfo++;
        break;

      case LOG_START:
        stStats.ulStart++;
        break;

      case LOG_DONE:
        stStats.ulDone++;
        break;

        //
        // No default, if code is unrecognized, there is no appropriate error
        // action to take.
        //
    }
}

//+-------------------------------------------------------------------
//
//  Member:     Log::Log(DWORD)
//
//  Synopsis:   The log file is not opened if this constructor is used -
//              the user must subsequently call the Info() method.
//
//  Arguments:  [fUseUnicode] - whether we should use WCHARs
//
//  Modifies:   fInfoSet
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
Log :: Log(DWORD dwCharType) : fInfoSet(FALSE), ulLastError(NO_ERROR)
{
    if(LOG_ANSI == dwCharType)
    {
        fIsUnicode = FALSE;
    }
    else if(LOG_UNICODE == dwCharType)
    {
        fIsUnicode = TRUE;
    }
    else
    {
        ulLastError = (ULONG) E_INVALIDARG;
        return;
    }

    //
    // zero out the _LogStats member
    //
    memset((VOID *)(&_stLogStats), 0, sizeof(LogStats));
}


//+-------------------------------------------------------------------
//
//  Member:     Log::Log(int, char *[], DWORD)
//
//  Synopsis:   Log constructor with command line data given
//
//  Arguments:  [argc]  - Argument count
//              [argv]  - Argument array
//              [fUseUnicode] - whether we should use WCHARs
//
//  Returns:    Results from Info()
//
//  History:    ??-???-??  ????????  Created
//              Jun-11-92  DonCl     added line to zero out LogStats struct
//
//--------------------------------------------------------------------
Log :: Log(int argc, char *argv[], DWORD dwCharType) :
  fInfoSet(FALSE),
  ulLastError(NO_ERROR)
{
    if(LOG_ANSI == dwCharType)
    {
        fIsUnicode = FALSE;
    }
    else if(LOG_UNICODE == dwCharType)
    {
        fIsUnicode = TRUE;
    }
    else
    {
        ulLastError = (ULONG) E_INVALIDARG;
        return;
    }

    //
    // zero out the _LogStats member
    //
    memset((VOID *)(&_stLogStats), 0, sizeof(LogStats));

    ulLastError = Info(argc, argv);
}


//+-------------------------------------------------------------------
//
//  Member:     Log::Log(PCHAR, PCHAR, PCHAR, PCHAR, PCHAR)
//
//  Synopsis:   Log constructor with internal data given
//
//  Arguments:  [pszSrvr]    - Name of logging server
//              [pszTest]    - Name of this test
//              [pszName]    - Name of test runner
//              [pszSubPath] - Users log file qualifer
//              [pszObject]  - Name of invoking object
//
//  Returns:
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              Jun-11-92  DonCl     added line to zero out LogStats struct
//
// BUGBUG wszName unused - left until all components can co-ordinate
//                         with this. SarahJ
//--------------------------------------------------------------------
Log :: Log(PCHAR pszSrvr,
           PCHAR pszTest,
           PCHAR pszName,
           PCHAR pszSubPath,
           PCHAR pszObject) : fIsUnicode(FALSE), ulLastError(NO_ERROR)
{
    memset((VOID *)(&_stLogStats), 0, sizeof(LogStats));   // zero out

    InitLogging();

    // Print warning if server name given
    if(NULL != pszSrvr)
    {
        fprintf(stderr, "Remote server not supported with this version of "
                "log.lib. Continuing.\n");
    }

    ulLastError = SetInfo(NULL, pszTest,  pszSubPath, pszObject);
    if(ulLastError == NO_ERROR)
    {
        ulLastError = LogOpen() || WriteVar((PCHAR) NULL, LOG_START);
    }
}


//+-------------------------------------------------------------------
//
//  Member:     Log::Log(LPWSTR, LPWSTR, LPWSTR, LPWSTR, LPWSTR)
//
//  Synopsis:   Log constructor with internal data given
//
//  Arguments:  [wszSrvr]    - Name of logging server
//              [wszTest]    - Name of this test
//              [wszName]    - Name of test runner
//              [wszSubPath] - Users log file qualifer
//              [wszObject]  - Name of invoking object
//
//  Returns:
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              Jun-11-92  DonCl     added line to zero out LogStats struct
//
// BUGBUG wszName unused - left until all components can co-ordinate
//                         with this. SarahJ

//--------------------------------------------------------------------
Log :: Log(LPWSTR wszSrvr,
           LPWSTR wszTest,
           LPWSTR wszName,
           LPWSTR wszSubPath,
           LPWSTR wszObject) : fIsUnicode(TRUE), ulLastError(NO_ERROR)

{
    memset((VOID *)(&_stLogStats), 0, sizeof(LogStats));   // zero out

    InitLogging();

    // Print warning if server name given
    if(NULL != wszSrvr)
    {
        fprintf(stderr, "Remote server not supported with this version of "
                "log.lib. Continuing.\n");
    }

    ulLastError = SetInfo(NULL, wszTest,  wszSubPath, wszObject);
    if (ulLastError == NO_ERROR)
    {
        ulLastError = LogOpen() || WriteVar((LPWSTR) NULL, LOG_START);
    }
}


//+-------------------------------------------------------------------
//
//  Member:     Log::~Log()
//
//  Synopsis:   Destroy the Log Object
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
Log :: ~Log()
{
    if(fInfoSet != FALSE)
    {
        if(FALSE == fIsUnicode)
        {
            if(WriteVar((PCHAR) NULL, LOG_DONE) != NO_ERROR)
            {
                LogPrintf(stderr, "ERROR: Failed to log \"%s\" status\n",
                          LOG_DONE_TXT);
            }
        }
        else
        {
            if(WriteVar((LPWSTR) NULL, LOG_DONE) != NO_ERROR)
            {
                LogPrintf(stderr, "ERROR: Failed to log \"%ls\" status\n",
                          wLOG_DONE_TXT);
            }
        }
        FreeLogging();          // Make sure memory is freed & file closed
    }
}


//+-------------------------------------------------------------------
//
//  Member:     Log::Info(int, char *[])
//
//  Synopsis:   Parse the command line and set the appropriate member variables
//
//  Arguments:  [argc] - Argument count
//              [argv] - Argument vector
//
//  Returns:
//
//  Modifies:
//
//  History:    ??-???-??  ????????  Created
//              30-Oct-92  SarahJ    Updated parms to SetInfo
//
//--------------------------------------------------------------------
ULONG Log :: Info(int argc, char *argv[])
{
    USHORT usNdx;               // Index into cmnd line args
    PCHAR  pszTest    = NULL;   // Name of this test
    PCHAR  pszSubPath = NULL;   // Users log file qualifer
    PCHAR  pszObject  = NULL;   // Name of invoking object
    PCHAR  pch;                 // Temporary pointer into a string


    InitLogging();

    // All the argv processing is still done in CHARs
    if(ulLastError == NO_ERROR)
    {
        //
        // For every command line switch, check its validity and parse its
        // value.  This version allows / or - for switches.  If there are
        // no command line switches, this loop is skipped.  This is for the
        // case when Log() is called with no messages.
        //

        for(usNdx = 1; usNdx < (unsigned short) argc; ++usNdx)
        {
            char *szArg = argv[ usNdx];
            pch = szArg;

            // check for / -

            if(*szArg == '/' || *szArg == '-')
            {
                register int i = 1;
                pch++;

                //
                // Check if next char is m, ie handed down from manager code.
                // If so skip m
                //

                if (*pch == 'm' || *pch == 'M')
                {
                    pch++;
                    i++;
                }

                ++pch;           // Skip next char and check for :

                if(*pch++ == ':')
                {
                    switch(toupper(szArg[i]))
                    {
                      case 'O':       // Object name found

                        pszObject = (PCHAR)pch;
                        break;

                      case 'P':       // Directory Path switch found

                        pszSubPath = (PCHAR)pch;
                        break;

                      case 'L':       // Logging server name found

                        fprintf(stderr, "Logging server not supported with "
                                "this version of log.lib. Continuing.\n");
                        break;

                      case 'T':       // Test name found

                        pszTest = (PCHAR)pch;
                        break;

                      default:        // Skip this unknown argument

                        break;
                    }
                }
            }
        }

        // If no test name was given, set pszTest to the apps base name.

        char szName[_MAX_FNAME];

        if(pszTest == NULL || *pszTest == NULLTERM)
        {
            _splitpath(argv[0], NULL, NULL, szName, NULL);
            pszTest = szName;
        }

        // Here is where the WCHAR additions are
        if(FALSE == fIsUnicode)
        {
            ulLastError = SetInfo(NULL, pszTest, pszSubPath, pszObject);
        }
        else
        {
            // Convert the PCHARs to LPWSTRs
            // This one is guaranteed to be set to something
            LPWSTR  wszTest    = MbNameToWcs(pszTest);
            LPWSTR  wszSubPath = MbNameToWcs(pszSubPath);
            LPWSTR  wszObject  = MbNameToWcs(pszObject);

            if(NO_ERROR == ulLastError)
            {
                ulLastError = SetInfo(NULL, wszTest, wszSubPath, wszObject);
            }

            delete wszTest;
            delete wszSubPath;
            delete wszObject;
        }

    }

    // This was not here before, but it seems the log should be opened by now
    if(NO_ERROR == ulLastError)
    {
        ulLastError = LogOpen() || (FALSE == fIsUnicode) ?
            WriteVar((PCHAR) NULL, LOG_START) :
            WriteVar((LPWSTR) NULL, LOG_START);

    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVarList(PCHAR, USHORT, PCHAR, va_list)
//
//  Synopsis:   The WriteVar and WriteData methods allow the user to log
//              info in various forms.
//
//  Arguments:  [pszVar]    - Variation
//              [usStat]    - Status
//              [pszFormat] - Format string (like printf)
//              [vaArgs]    - Data for pszStrFmt
//
//  Returns:    NO_ERROR if successful or ERROR_INVALID_DATA otherwise
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//              17-Oct-91  SarahJ    Added check for LOG_MAX_STATUS
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Stolen from WriteVar method, renamed,
//                                   made to operate on va_lists.
//
//--------------------------------------------------------------------
ULONG Log :: WriteVarList(PCHAR   pszVar,
                          USHORT  usStat,
                          PCHAR   pszFormat,
                          va_list vaArgs)
{
    CHK_UNICODE(FALSE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    IncLogStats(_stLogStats, usStat);

    if(ulLastError == NO_ERROR)
    {
        if(fInfoSet)
        {
            // verify that the status is in allowed range

            if(usStat > LOG_MAX_STATUS)
            {
                LogPrintf(stderr,
                          "ERROR: Illegal status parameter %u for "
                          "Variation  %s\n",
                          usStat,
                          pszVar);
                ulLastError = ERROR_INVALID_DATA;
                return ulLastError;
            }

            ulLastError =
                SetStrData(pszFormat, vaArgs) ||
                SetVariation((const char *)pszVar) ||
                SetStatus(aStatus[usStat]) ||
                SetBinData(0, (PVOID)NULL);

            if(ulLastError == NO_ERROR)
            {
                ulLastError = LogData();       // Send data to the log file
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVarList(LPWSTR, USHORT, LPWSTR, va_list)
//
//  Synopsis:   The WriteVar and WriteData methods allow the user to log
//              info in various forms.
//
//  Arguments:  [wszVar]    - Variation
//              [usStat]    - Status
//              [wszFormat] - Format string (like printf)
//              [vaArgs]    - Data for pszStrFmt
//
//  Returns:    NO_ERROR if successful or ERROR_INVALID_DATA otherwise
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//              17-Oct-91  SarahJ    Added check for LOG_MAX_STATUS
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Stolen from WriteVar method, renamed,
//                                   made to operate on va_lists.
//
//--------------------------------------------------------------------
ULONG Log :: WriteVarList(LPWSTR  wszVar,
                          USHORT  usStat,
                          LPWSTR  wszFormat,
                          va_list vaArgs)
{
    CHK_UNICODE(TRUE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    IncLogStats(_stLogStats, usStat);

    if(ulLastError == NO_ERROR)
    {
        if(fInfoSet)
        {
            // verify that the status is in allowed range

            if(usStat > LOG_MAX_STATUS)
            {
                LogPrintf(stderr, L"ERROR: Illegal status parameter %u "
                          L"for Variation  %ls\n",
                          usStat, wszVar);
                ulLastError = ERROR_INVALID_DATA;
                return ulLastError;
            }

            ulLastError = SetStrData(wszFormat, vaArgs)
                || SetVariation((LPCWSTR) wszVar)
                || SetStatus(waStatus[usStat])
                || SetBinData(0, (PVOID) NULL);

            if(ulLastError == NO_ERROR)
            {
                ulLastError = LogData();       // Send data to the log file
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVar(PCHAR, USHORT, PCHAR, ...)
//
//  Synopsis:   The WriteVar and WriteData methods allow the user to log
//              info in various forms.
//
//  Arguments:  [pszVar]    - Variation
//              [usStat]    - Status
//              [pszFormat] - Format string (like printf)
//              [...]       - Data for pszStrFmt
//
//  Returns:    NO_ERROR if successful or ERROR_INVALID_DATA otherwise
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//              17-Oct-91  SarahJ    Added check for LOG_MAX_STATUS
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Modified to call WriteVarList
//
//--------------------------------------------------------------------
ULONG Log :: WriteVar(PCHAR pszVar, USHORT usStat, PCHAR pszFormat, ...)
{
    CHK_UNICODE(FALSE);

    va_list pMarker;

    if(pszFormat != NULL)
    {
        va_start(pMarker, pszFormat);
    }

    ulLastError = WriteVarList(pszVar, usStat, pszFormat, pMarker);

    if(pszFormat != NULL)
    {
        va_end(pMarker);
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVar(LPWSTR, USHORT, LPWSTR, ...)
//
//  Synopsis:   The WriteVar and WriteData methods allow the user to log
//              info in various forms.
//
//  Arguments:  [wszVar]    - Variation
//              [usStat]    - Status
//              [wszFormat] - Format string (like printf)
//              [...]       - Data for pszStrFmt
//
//  Returns:    NO_ERROR if successful or ERROR_INVALID_DATA otherwise
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//              17-Oct-91  SarahJ    Added check for LOG_MAX_STATUS
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Modified to call WriteVarList
//
//--------------------------------------------------------------------
ULONG Log :: WriteVar(LPWSTR wszVar, USHORT usStat, LPWSTR wszFormat, ...)
{
    CHK_UNICODE(TRUE);

    va_list pMarker;

    if(wszFormat != NULL)
    {
        va_start(pMarker, wszFormat);
    }

    ulLastError = WriteVarList(wszVar, usStat, wszFormat, pMarker);

    if(wszFormat != NULL)
    {
        va_end(pMarker);
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVarList(PCHAR, USHORT, USHORT, PVOID, PCHAR, va_list)
//
//  Synopsis:   Write data to the log file that contains binary data with
//              or without an accompanying string.
//
//  Arguments:  [pszVar]        - Variation
//              [usStat]        - Status code
//              [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [pszFormat]     - printf style format
//              [vaArgs]        - Data for pszStrFmt
//
//  Returns:
//
//  History:    ??-???-??  ????????  Created
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Stolen from WriteVar, renamed, supports
//                                   va_list type now.
//
//--------------------------------------------------------------------
ULONG Log :: WriteVarList(PCHAR   pszVar,
                           USHORT  usStat,
                           USHORT  usBytes,
                           PVOID   pvData,
                           PCHAR   pszFormat,
                           va_list vaArgs )
{
    CHK_UNICODE(FALSE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    IncLogStats(_stLogStats, usStat);

    if (ulLastError == NO_ERROR)
    {
        if (fInfoSet)
        {
            // verify that the status is in allowed range

            if (usStat > LOG_MAX_STATUS)
            {
                LogPrintf(stderr,
                          "ERROR: Illegal status parameter %u for "
                          "Variation  %s\n",
                          usStat,
                          pszVar);
                ulLastError = ERROR_INVALID_DATA;
                return ulLastError;
            }

            // Note if pszFormat is NULL, SetStrData will ignore vaArgs
            ulLastError = SetStrData(pszFormat, vaArgs);

            if (ulLastError == NO_ERROR)
            {
                ulLastError = SetVariation((const char *) pszVar)
                    || SetStatus(aStatus[usStat])
                    || SetBinData(usBytes, pvData);

                if (ulLastError == NO_ERROR)
                {
                    ulLastError = LogData();   // Send data to the log file
                }
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVarList(LPWSTR, USHORT, USHORT, PVOID,
//                                LPWSTR, va_list)
//
//  Synopsis:   Write data to the log file that contains binary data with
//              or without an accompanying string.
//
//  Arguments:  [wszVar]        - Variation
//              [usStat]        - Status code
//              [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [wszFormat]     - printf style format
//              [vaArgs]        - Data for pszStrFmt
//
//  Returns:
//
//  History:    ??-???-??  ????????  Created
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Stolen from WriteVar, renamed, supports
//                                   va_list type now.
//
//--------------------------------------------------------------------
ULONG Log :: WriteVarList(LPWSTR  wszVar,
                          USHORT  usStat,
                          USHORT  usBytes,
                          PVOID   pvData,
                          LPWSTR  wszFormat,
                          va_list vaArgs )
{
    CHK_UNICODE(TRUE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    IncLogStats(_stLogStats, usStat);

    if(ulLastError == NO_ERROR)
    {
        if(fInfoSet)
        {
            // verify that the status is in allowed range

            if(usStat > LOG_MAX_STATUS)
            {
                LogPrintf(stderr, L"ERROR: Illegal status parameter %u "
                          L"for Variation  %ls\n",
                          usStat, wszVar);
                ulLastError = ERROR_INVALID_DATA;
                return ulLastError;
            }

            // Note if wszFormat is NULL, SetStrData will ignore vaArgs
            ulLastError = SetStrData(wszFormat, vaArgs);

            if(ulLastError == NO_ERROR)
            {
                ulLastError =
                    SetVariation((LPCWSTR) wszVar) ||
                    SetStatus(waStatus[usStat]) ||
                    SetBinData(usBytes, pvData);

                if(ulLastError == NO_ERROR)
                {
                    ulLastError = LogData();   // Send data to the log file
                }
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVar(PCHAR, USHORT, USHORT, PVOID, PCHAR, ...)
//
//  Synopsis:   Write data to the log file that contains binary data with
//              or without an accompanying string.
//
//  Arguments:  [pszVar]        - Variation
//              [usStat]        - Status code
//              [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [pszFormat]     - printf style format
//              [...]           - Data for pszStrFmt
//
//  Returns:
//
//  History:    ??-???-??  ????????  Created
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Modified to call WriteVarList
//
//--------------------------------------------------------------------
ULONG Log :: WriteVar(PCHAR  pszVar,
                      USHORT usStat,
                      USHORT usBytes,
                      PVOID  pvData,
                      PCHAR  pszFormat,
                      ... )
{
    CHK_UNICODE(FALSE);

    va_list pMarker;

    if(pszFormat != NULL)
    {
        va_start(pMarker, pszFormat);
    }

    ulLastError = WriteVarList(pszVar,
                               usStat,
                               usBytes,
                               pvData,
                               pszFormat,
                               pMarker);

    if(pszFormat != NULL)
    {
        va_end(pMarker);
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteVar(LPWSTR, USHORT, USHORT, PVOID, LPWSTR, ...)
//
//  Synopsis:   Write data to the log file that contains binary data with
//              or without an accompanying string.
//
//  Arguments:  [wszVar]        - Variation
//              [usStat]        - Status code
//              [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [wszFormat]     - printf style format
//              [...]           - Data for pszStrFmt
//
//  Returns:
//
//  History:    ??-???-??  ????????  Created
//              11-Jun-92  DonCl     Added call to IncLogStats()
//               3-Jul-92  DeanE     Modified to call WriteVarList
//
//--------------------------------------------------------------------
ULONG Log :: WriteVar(LPWSTR wszVar,
                      USHORT usStat,
                      USHORT usBytes,
                      PVOID  pvData,
                      LPWSTR wszFormat,
                      ... )
{
    CHK_UNICODE(TRUE);

    va_list pMarker;

    if(wszFormat != NULL)
    {
        va_start(pMarker, wszFormat);
    }

    ulLastError = WriteVarList(wszVar,
                               usStat,
                               usBytes,
                               pvData,
                               wszFormat,
                               pMarker);

    if(wszFormat != NULL)
    {
        va_end(pMarker);
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteDataList(PCHAR, va_list)
//
//  Synopsis:   Write a string to the Log file.
//
//  Arguments:  [pszFormat] - a printf-like format string
//              [vaArgs]    - The data to print out.
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetStrData() or Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Stolen from WriteData, renamed, made
//                                   to work on a va_list
//
//--------------------------------------------------------------------
ULONG Log :: WriteDataList(PCHAR pszFormat, va_list vaArgs)
{
    CHK_UNICODE(FALSE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    if (ulLastError == NO_ERROR)
    {
        if (fInfoSet)
        {
            // Note if pszFormat is NULL, SetStrData will ignore vaArgs
            ulLastError = SetStrData(pszFormat, vaArgs);

            if (ulLastError == NO_ERROR)
            {
                ulLastError = LogData();        // Send data to the log file
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteDataList(LPWSTR, va_list)
//
//  Synopsis:   Write a string to the Log file.
//
//  Arguments:  [wszFormat] - a printf-like format string
//              [vaArgs]    - The data to print out.
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetStrData() or Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Stolen from WriteData, renamed, made
//                                   to work on a va_list
//
//--------------------------------------------------------------------
ULONG Log :: WriteDataList(LPWSTR wszFormat, va_list vaArgs)
{
    CHK_UNICODE(TRUE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    if(ulLastError == NO_ERROR)
    {
        if(fInfoSet)
        {
            // Note if wszFormat is NULL, SetStrData will ignore vaArgs
            ulLastError = SetStrData(wszFormat, vaArgs);

            if(ulLastError == NO_ERROR)
            {
                ulLastError = LogData();        // Send data to the log file
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteData(PCHAR, ...)
//
//  Synopsis:   Write a string to the Log file.
//
//  Arguments:  [pszFormat] - a printf-like format string
//              [...]       - The data to print out.
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetStrData() or Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG Log :: WriteData(PCHAR pszFormat, ...)
{
    CHK_UNICODE(FALSE);

    va_list pMarker;

    if (pszFormat != NULL)
    {
        va_start(pMarker, pszFormat);
    }

    ulLastError = WriteDataList(pszFormat, pMarker);

    if (pszFormat != NULL)
    {
        va_end(pMarker);
    }

    return(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteData(LPWSTR, ...)
//
//  Synopsis:   Write a string to the Log file.
//
//  Arguments:  [wszFormat] - a printf-like format string
//              [...]       - The data to print out.
//
//  Returns:    NO_ERROR if successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetStrData() or Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG Log :: WriteData(LPWSTR wszFormat, ...)
{
    CHK_UNICODE(TRUE);

    va_list pMarker;

    if(wszFormat != NULL)
    {
        va_start(pMarker, wszFormat);
    }

    ulLastError = WriteDataList(wszFormat, pMarker);

    if(wszFormat != NULL)
    {
        va_end(pMarker);
    }

    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteDataList(USHORT, PVOID, PCHAR, va_list)
//
//  Synopsis:   Write data to the log file that contains binary data
//              and possibly a string.
//
//  Arguments:  [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [pszFormat]     - printf style format
//              [vaArgs]        - Data for pszStrFmt
//
//  Returns:    NO_ERROR  If successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetSetData, Log::SetBinData, or
//              Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Stolen from WriteData, renamed, made
//                                   to support va_list
//
//--------------------------------------------------------------------
ULONG Log :: WriteDataList(USHORT  usBytes,
                           PVOID   pvData,
                           PCHAR   pszFormat,
                           va_list vaArgs)
{
    CHK_UNICODE(FALSE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    if (ulLastError == NO_ERROR)
    {
        if (fInfoSet)
        {
            // Set up to log the string data
            // Note if pszFormat is NULL, SetStrData will ignore vaArgs
            ulLastError = SetStrData(pszFormat, vaArgs);

            if (ulLastError == NO_ERROR)
            {
                // Set up to log the binary data

                ulLastError = SetBinData(usBytes, pvData);

                if (ulLastError == NO_ERROR)
                {
                    ulLastError = LogData();    // Send data to the log file
                }
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteDataList(USHORT, PVOID, LPWSTR, va_list)
//
//  Synopsis:   Write data to the log file that contains binary data
//              and possibly a string.
//
//  Arguments:  [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [wszFormat]     - printf style format
//              [vaArgs]        - Data for pszStrFmt
//
//  Returns:    NO_ERROR  If successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetSetData, Log::SetBinData, or
//              Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Stolen from WriteData, renamed, made
//                                   to support va_list
//
//--------------------------------------------------------------------
ULONG Log :: WriteDataList(USHORT  usBytes,
                           PVOID   pvData,
                           LPWSTR  wszFormat,
                           va_list vaArgs)
{
    CHK_UNICODE(TRUE);

#if defined(WIN32)
    CTCLock  clMemLock (hMtxSerialize);   // Serialize access to this object
#endif

    ulLastError = NO_ERROR;

    if(ulLastError == NO_ERROR)
    {
        if(fInfoSet)
        {
            // Set up to log the string data
            // Note if wszFormat is NULL, SetStrData will ignore vaArgs
            ulLastError = SetStrData(wszFormat, vaArgs);

            if(ulLastError == NO_ERROR)
            {
                // Set up to log the binary data

                ulLastError = SetBinData(usBytes, pvData);

                if(ulLastError == NO_ERROR)
                {
                    ulLastError = LogData();    // Send data to the log file
                }
            }
        }
        else
        {
            ulLastError = ERROR_INVALID_DATA;
        }
    }
    return ulLastError;
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteData(USHORT, PVOID, PCHAR, ...)
//
//  Synopsis:   Write data to the log file that contains binary data
//              and possibly a string.
//
//  Arguments:  [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [pszFormat]     - printf style format
//              [...]           - Data for pszStrFmt
//
//  Returns:    NO_ERROR  If successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetSetData, Log::SetBinData, or
//              Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG Log :: WriteData(USHORT usBytes, PVOID  pvData, PCHAR  pszFormat, ...)
{
    CHK_UNICODE(FALSE);

    va_list pMarker;

    if (pszFormat != NULL)
    {
        va_start(pMarker, pszFormat);
    }

    ulLastError = WriteDataList(usBytes, pvData, pszFormat, pMarker);

    if (pszFormat != NULL)
    {
        va_end(pMarker);
    }

    return(ulLastError);
}


//+-------------------------------------------------------------------
//
//  Member:     Log::WriteData(USHORT, PVOID, LPWSTR, ...)
//
//  Synopsis:   Write data to the log file that contains binary data
//              and possibly a string.
//
//  Arguments:  [usBytes]       - #bytes binary data
//              [pvData]        - The binary data
//              [wszFormat]     - printf style format
//              [...]           - Data for pszStrFmt
//
//  Returns:    NO_ERROR  If successful
//              ERROR_INVALID_DATA
//              Any error code from Log::SetSetData, Log::SetBinData, or
//              Log::LogData
//
//  Modifies:   ulLastError
//
//  History:    ??-???-??  ????????  Created
//               3-Jul-92  DeanE     Modified to call WriteDataList
//
//--------------------------------------------------------------------
ULONG Log :: WriteData(USHORT usBytes, PVOID  pvData, LPWSTR wszFormat, ...)
{
    CHK_UNICODE(TRUE);

    va_list pMarker;

    if(wszFormat != NULL)
    {
        va_start(pMarker, wszFormat);
    }

    ulLastError = WriteDataList(usBytes, pvData, wszFormat, pMarker);

    if(wszFormat != NULL)
    {
        va_end(pMarker);
    }

    return ulLastError;
}


//+----------------------------------------------------------------------------
//
//    Member:    Log::GetLogStats(), public
//
//    Synopsis:  returns _stLogStats structure inside log object
//
//    Effects:   Returns actual reference to the real thing.
//
//    Arguments: [out] LogStats& stStats  -  structure to fill in.
//
//    Returns:   nothing, except stStats now is value of structure.
//
//    Modifies:  stStats
//
//    History:   11 Jun 92   DonCl   first version
//
//    Notes:
//
//-----------------------------------------------------------------------------

VOID Log::GetLogStats(LogStats& stStats)
{
    stStats = _stLogStats;
}


//+-------------------------------------------------------------------
//
//  Function:   MbNametoWcs(PCHAR *)
//
//  Synopsis:   Given a pointer to a CHAR string, return a WCHAR copy
//
//  Arguments:  [pszName]  CHAR string to copy
//
//  Returns:    <nothing>
//
//  History:    ??-???-??  ????????  Created
//
//--------------------------------------------------------------------
LPWSTR Log :: MbNameToWcs(PCHAR pszName)
{
    LPWSTR wszName = NULL;
    if(pszName != NULL)
    {
        size_t sizLen = strlen(pszName);
        if((wszName = new WCHAR[sizLen + 1]) == NULL)
        {
            ulLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            if (mbstowcs(wszName, pszName, sizLen) == (size_t)0)
            {
                delete[] wszName;
                ulLastError = ERROR_INVALID_DATA;
            }
            wszName[sizLen] = wNULLTERM;
        }
    }
    return wszName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolerpc\include\ctolerpc.cxx ===
//+------------------------------------------------------------------
//
// File:        comtpch.cxx
//
// Contents:    headers to precompile when building all directories
//              in common.
//
// History:     19-Nov-94   DaveY   Created
//
//-------------------------------------------------------------------

#include <ctolerpc.h>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolerpc\include\dummy.cxx ===
#include "ctolerpc.h"
#pragma hdrstop

void pch_dummy_function()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolerpc\include\ctolerpc.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  All rights reserved.
//
//  File:       ctolerpc.h
//
//  Synopsis:   Global include file for the ctolerpc project
//
//  History:    31-Jul-96   MikeW   Created
//
//-----------------------------------------------------------------------------

#ifndef _CTOLERPC_H_
#define _CTOLERPC_H_



#include "KillWarn.h"

#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdarg.h>
#ifdef WIN16
#include <types16.h>
#endif
#include <tchar.h>
#include <direct.h>

#include "macport.h"        // Macintosh-specific stuff

#include "oletypes.h"       // Platform independent ole types
#include "olestr.h"         // ctprintf and olestr functions



#endif // _CTOLERPC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\comtools\memory\ctmem.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       $(COMTOOLS)\memory\ctmem.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    27-Oct-93   DarrylA     Created.
//              1-May-94    DeanE       Added Heap validation macros.
//              26-May-94   NaveenB     ported to build for 16-bit
//              06-Oct-94   NaveenB     added sifting of the test code
//                  capability
//              10-Oct-94   NaveenB     added IMallocAllocCtm and 
//                  IMallocFreeCtm
//
//----------------------------------------------------------------------
#include <comtpch.hxx>
#pragma hdrstop

#include <ctmem.hxx>

#ifdef WIN16
#include <types16.h>
#include <stdio.h>
#define NON_TASK_ALLOCATOR 
#define _TEXT(quote) quote
#else
#include <tchar.h>
#endif

#ifdef SIFTING_TEST_CODE

#include <sift.hxx>

ISift *g_psftSiftObject = NULL;

#define SIMULATE_FAILURE( dwRes )                               \
            ((NULL != g_psftSiftObject) &&                      \
                    (g_psftSiftObject->SimFail( ( dwRes ) )))   
#endif

DWORD dwCtValidateHeap = 1;

#if defined(WIN32) && !defined(_CHICAGO_) && !defined(_MAC)
   DWORD dwCtExceptionCode = (DWORD) CT_EXCEPTION_HEAP;
#endif

//+---------------------------------------------------------------------
//
//  Function:   new, new(FAIL_BEHAVIOR), delete
//
//  Synopsis:   Overrides to support the default behavior of the
//              commnot new and delete. Simply uses malloc and free.
//
//  History:    06-Oct-93   DarrylA    Created.
//
//  Notes:
//
//----------------------------------------------------------------------
PVOID __cdecl operator new(unsigned int nSize, FAIL_BEHAVIOR enfb)
{

    VDATEHEAP();

#ifdef SIFTING_TEST_CODE
    //  Check for memory failure if sifting
    if (SIMULATE_FAILURE(SR_PUBLIC_MEMORY))
    {
        if(ExceptOnFail == enfb)
        {
#if defined(WIN16) || defined(_MAC)
           OutputDebugString(
                    "Can not call new (ExceptOnFail) in Win16 or Mac\n");
#else
           RaiseException((ULONG) E_OUTOFMEMORY, 0, 0, NULL);
#endif
        }
    else
    {
            return(NULL);
        }
    }
#endif

#ifdef NON_TASK_ALLOCATOR

    PVOID pvTmp;

    pvTmp = (PVOID) malloc(nSize);
    if(ExceptOnFail == enfb)
    {
#if defined(WIN16) || defined(_MAC)
           OutputDebugString(
                    "Can not call new (ExceptOnFail) in Win16 or Mac\n");
#endif
        if(NULL == pvTmp)
        {
#if !defined(WIN16) && !defined(_MAC)
           RaiseException((ULONG) E_OUTOFMEMORY, 0, 0, NULL);
#endif
        }
    }
    return pvTmp;

#else      // TASK_ALLOCATOR

    PVOID pvTmp = NULL;

    pvTmp = CoTaskMemAlloc(nSize);
    if (NULL == pvTmp)
    {
        if (ExceptOnFail==enfb)
        {
#if !defined(WIN16) && !defined(_MAC)
            RaiseException((ULONG) E_OUTOFMEMORY, 0, 0, NULL);
#endif
        }
    }
    return(pvTmp);

#endif 

}

PVOID __cdecl operator new(unsigned int nSize)
{
    VDATEHEAP();

#ifdef SIFTING_TEST_CODE
    //  Check for memory failure if sifting
    if (SIMULATE_FAILURE(SR_PUBLIC_MEMORY))
    {
        return(NULL);
    }
#endif

#ifdef NON_TASK_ALLOCATOR

    return (PVOID) malloc(nSize);

#else      // TASK_ALLOCATOR

    PVOID pvTmp = CoTaskMemAlloc(nSize);
    return(pvTmp);

#endif
}


VOID __cdecl operator delete(void *pbData)
{
    VDATEHEAP();

#ifdef NON_TASK_ALLOCATOR

    if(NULL != pbData)
    {
        free(pbData);
    }

#else      // TASK_ALLOCATOR

    CoTaskMemFree(pbData);

#endif
}

//+---------------------------------------------------------------------
//
//  Function:   CtRealloc
//
//  Synopsis:   Adds support for realloc
//
//  History:    31-Dec-97   VaraT    Created.
//
//  Notes:
//
//----------------------------------------------------------------------
PVOID __cdecl CtRealloc(PVOID memBlock,
                         size_t nSize, FAIL_BEHAVIOR enfb)
{

    VDATEHEAP();

#ifdef SIFTING_TEST_CODE
    //  Check for memory failure if sifting
    if (SIMULATE_FAILURE(SR_PUBLIC_MEMORY))
    {
        if(ExceptOnFail == enfb)
        {
#if defined(WIN16) || defined(_MAC)
           OutputDebugString(
                    "Can not call Realloc (ExceptOnFail) in Win16 or Mac\n");
#else
           RaiseException((ULONG) E_OUTOFMEMORY, 0, 0, NULL);
#endif
        }
    else
    {
            return(NULL);
        }
    }
#endif

#ifdef NON_TASK_ALLOCATOR

    PVOID pvTmp;

    pvTmp = (PVOID) realloc(memBlock, nSize);
    if(ExceptOnFail == enfb)
    {
#if defined(WIN16) || defined(_MAC)
           OutputDebugString(
                    "Can not call new (ExceptOnFail) in Win16 or Mac\n");
#endif
        if(NULL == pvTmp && nSize != 0)
        {
#if !defined(WIN16) && !defined(_MAC)
           RaiseException((ULONG) E_OUTOFMEMORY, 0, 0, NULL);
#endif
        }
    }
    return pvTmp;

#else      // TASK_ALLOCATOR

    PVOID pvTmp = NULL;

    pvTmp = CoTaskMemRealloc(memBlock, nSize);
    if (NULL == pvTmp && nSize != 0)
    {
        if (ExceptOnFail==enfb)
        {
#if !defined(WIN16) && !defined(_MAC)
            RaiseException((ULONG) E_OUTOFMEMORY, 0, 0, NULL);
#endif
        }
    }
    return(pvTmp);

#endif 

}

PVOID __cdecl CtRealloc(PVOID memBlock, size_t nSize)
{
    VDATEHEAP();

#ifdef SIFTING_TEST_CODE
    //  Check for memory failure if sifting
    if (SIMULATE_FAILURE(SR_PUBLIC_MEMORY))
    {
        return(NULL);
    }
#endif

#ifdef NON_TASK_ALLOCATOR

    return (PVOID) realloc(memBlock, nSize);

#else      // TASK_ALLOCATOR

    PVOID pvTmp = CoTaskMemRealloc(memBlock, nSize);
    return(pvTmp);

#endif
}

//+--------------------------------------------------------------
//  Function:   IMallocAllocCtm 
//
//  Synopsis:   Calls the Ole memory allocator and returns the pointer
//              of the new allocated block.  Sifting capability is present
//
//  Arguments:  dwMemctx        specifies whether the memory block is
//                              private to a task or shared between
//                              processes
//              ulCb            size of the memory block
//
//  Returns:    pointer to the allocated block if succeeded else NULL.
//
//  History:    10-Oct-94   NaveenB   Created
//---------------------------------------------------------------

VOID FAR* IMallocAllocCtm(DWORD dwMemctx, ULONG ulCb)
{
    void FAR*   pMemory = NULL;
    LPMALLOC    lpIMalloc = NULL;

#ifdef SIFTING_TEST_CODE
    //  Check for memory failure if sifting
    if (SIMULATE_FAILURE(SR_PUBLIC_MEMORY))
    {
        return(NULL);
    }
#endif

    if (SUCCEEDED(CoGetMalloc(dwMemctx, &lpIMalloc)))
    {
    if (lpIMalloc != NULL)
    {
            pMemory = lpIMalloc->Alloc(ulCb);
            lpIMalloc->Release();
    }
    }
    else
    {
    OutputDebugString(_TEXT("CoGetMalloc Failed \n"));
    }
    return pMemory;
}

//+--------------------------------------------------------------
//  Function:   IMallocFreeCtm 
//
//  Synopsis:   Calls the Ole memory allocator and returns the pointer
//              of the new allocated block
//
//  Arguments:  dwMemctx        specifies whether the memory block is
//                              private to a task or shared between
//                              processes
//              pv              pointer to the memory block to free
//
//  Returns:    None
//
//  History:    10-Oct-94   NaveenB   Created
//---------------------------------------------------------------

VOID IMallocFreeCtm(DWORD dwMemctx, void FAR* pv)
{
    LPMALLOC    lpIMalloc = NULL;

    if (pv != NULL)
    {
        if (SUCCEEDED(CoGetMalloc(dwMemctx, &lpIMalloc)))
        {
        if (lpIMalloc != NULL)
        {
                lpIMalloc->Free(pv);
                lpIMalloc->Release();
        }
        }
        else
        {
        OutputDebugString(_TEXT("CoGetMalloc Failed \n"));
        }
    }
}

//+--------------------------------------------------------------
//  Function:   IMallocReallocCtm 
//
//  Synopsis:   Calls the Ole memory allocator and returns the pointer
//              of the new allocated block
//
//  Arguments:  dwMemctx        specifies whether the memory block is
//                              private to a task or shared between
//                              processes
//              pv              pointer to the memory block to free
//              cb              New count of allocated memory
//
//  Returns:    None
//
//  History:    5-Nov-97   VaraT   Created
//---------------------------------------------------------------

VOID FAR * IMallocReallocCtm(DWORD dwMemctx, void FAR* pv, DWORD ulCb)
{
    LPMALLOC    lpIMalloc = NULL;
    void FAR*   pMemory = NULL;

#ifdef SIFTING_TEST_CODE
    //  Check for memory failure if sifting
    if (SIMULATE_FAILURE(SR_PUBLIC_MEMORY))
    {
        return(NULL);
    }
#endif

    if (SUCCEEDED(CoGetMalloc(dwMemctx, &lpIMalloc)))
    {
        if (lpIMalloc != NULL)
        {
                pMemory = lpIMalloc->Realloc(pv, ulCb);
                lpIMalloc->Release();
        }
    }
    else
    {
        OutputDebugString(_TEXT("CoGetMalloc Failed \n"));
    }
    return pMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolerpc\include\killwarn.h ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      killwarn.hxx
//
//  Contents:  Pragma's to kill specific warnings at W4
//
//  History:   28-Nov-94        DeanE   Created
//--------------------------------------------------------------------------
#ifndef __KILLWARN_HXX__
#define __KILLWARN_HXX__

//
//  Quotes taken from vc user's manual
//


// Turn off: unreferenced inline function has been removed
#pragma warning(disable: 4514)

// nonstandard extension used : nameless struct/union
//
// Microsoft C/C++ allows structure declarations to be specified without a
// declarator when they are members of another structure or union.
// The following is an example of this error:
//
// struct S
// {
//      float y;
//      struct
//      {
//          int a, b, c;  // warning
//      };
// } *p_s;
//
//
// This extension can prevent your code from being portable to other
// compilers and will generate an error under the /Za command-line option.
#pragma warning(disable: 4201)

// 'identifier' : inconsistent DLL linkage. dllexport assumed
//
// The specified member function was declared in a class with dllexport
// linkage, and then was imported. This warning can also be caused by
// declaring a member function in a class with dllimport linkage as neither
// imported nor static nor inline.
//
// The function was compiled as dllexport.
#pragma warning(disable: 4273)

// 'class' : assignment operator could not be generated
//
// The compiler was unable to generate a default constructor for the given
// class. No constructor was created.
//
// This warning can be caused by having an assignment operator for the
// base class that is not accessible by the derived class.
//
// This warning can be avoided by specifying a user-defined assignment
// operator for the class.
#pragma warning(disable: 4512)

// 'function': function not expanded
//
// The given function was selected for inline expansion but the compiler did 
// not perform the inlining.
#pragma warning(disable:4710)

// trigraph not being substituted
#pragma warning (disable: 4110)

#ifdef _MAC
// alignment of a memeber was sensitive to packing
#pragma warning (disable: 4121)
#endif // _MAC

#endif  // __KILLWARN_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolerpc\include\oletypes.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  All rights reserved.
//
//  File:       oletypes.h
//
//  Synopsis:   There are several datatypes that Ole uses that are not the
//              same on all platforms.  This file defines several logical 
//              types to use in their place and associated conversion functions
//              to convert between the platform-independent logical types and
//              the "standard" representation of Windows-compatible types
//
//  History:    31-Jul-96   MikeW   Created
//
//-----------------------------------------------------------------------------

#ifndef _OLETYPES_H_
#define _OLETYPES_H_



#if defined(WIN16) || (defined(WIN32) && !defined(_MAC))

//
// Windows (16 or 32 bit) types
//

typedef HDC             OleDC;
typedef HGLOBAL         OleHandle;
typedef HMENU           OleMenuHandle;
typedef MSG             OleMessage;
typedef HMETAFILEPICT   OleMetafile;
typedef LOGPALETTE      OlePalette;
typedef RECT            OleRect;
typedef HWND            OleWindow;

#elif defined(_MAC)

//
// Macintosh types
//

typedef GrafPtr         OleDC;
typedef Handle          OleHandle;
typedef MenuHandle      OleMenuHandle;
typedef EventRecord     OleMessage;
typedef PicHandle       OleMetafile;
typedef OLECOLORSCHEME  OlePalette;
typedef Rect            OleRect;
typedef WindowPtr       OleWindow;

#endif



//
// Conversion Functions
//

HRESULT ConvertOleMessageToMSG(const OleMessage *, MSG **);
HRESULT ConvertOleWindowToHWND(OleWindow, HWND *);
HRESULT ConvertOleRectToRECT(const OleRect *, RECT **);
HRESULT ConvertOlePaletteToLOGPALETTE(const OlePalette *, LOGPALETTE **);
HRESULT ConvertOleHandleToHGLOBAL(OleHandle, HGLOBAL *);
HRESULT ConvertOleDCToHDC(OleDC, HDC *);
HRESULT ConvertOleMetafileToMETAFILEPICT(OleMetafile, HMETAFILEPICT *);

HRESULT ConvertMSGToOleMessage(const MSG *, OleMessage **);
HRESULT ConvertHWNDToOleWindow(HWND, OleWindow *);
HRESULT ConvertRECTToOleRect(const RECT *, OleRect **);
HRESULT ConvertLOGPALETTEToOlePalette(const LOGPALETTE *, OlePalette **);
HRESULT ConvertHGLOBALToOleHandle(HGLOBAL, OleHandle *);
HRESULT ConvertHDCToOleDC(HDC, OleDC *);
HRESULT ConvertMETAFILEPICTToOleMetafile(HMETAFILEPICT, OleMetafile *);

#endif // _OLETYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolerpc\oletypes\mac\oletypes.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  All rights reserved.
//
//  File:       oletypes.cxx
//
//  Synopsis:   Macintosh version of OleTypes
//
//  History:    31-Jul-96   MikeW   Created
//
//-----------------------------------------------------------------------------

#include <ctolerpc.h>

//
// Define these here so we don't have to globably include macos\windows.h
//

extern "C" 
{
WINUSERAPI HWND WINAPI          GetWindowWrapper(WindowRef rwnd);
WINUSERAPI WindowRef WINAPI     GetWrapperWindow(HWND hwnd);
}


//+----------------------------------------------------------------------------
//                                                                             
//  Functions:  ConvertOleMessageToMSG                                         
//                                                                             
//  Synopsis:   Covert OleMessage to MSG                                       
//                                                                             
//  Parameters: [event]     -- Pointer to a Mac EventRecord structure          
//              [pp_msg]    -- Where to put a Win32 MSG structure              
//                                                                             
//  Returns:    S_OK if all went well                                          
//                                                                             
//  History:    30-Jul-96   MikeW   Created                                    
//                                                                             
//  Notes:      OleMessage is an EventRecord
//
//              We currently only handle NULL event pointers                   
//                                                                             
//-----------------------------------------------------------------------------
                                                                               
HRESULT ConvertOleMessageToMSG(const OleMessage *event, MSG **pp_msg)               
{                                                                              
    *pp_msg = NULL;                                                            
                                                                               
    if (NULL != event)                                                         
    {                                                                          
        OutputDebugString("ConvertOleMessage only handles NULL events\r\n");   
        return E_NOTIMPL;                                                      
    }                                                                          
                                                                               
    return S_OK;                                                               
}                                                                              



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOleWindowToHWND
//
//  Synopsis:   Convert a Mac WindowPtr to a Win32 HWND
//
//  Parameters: [olewindow]         -- The OleWindow
//              [pp_hwnd]           -- Where to put the HWND
//
//  Returns:    S_OK if all went well
//
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleWindow is a WindowPtr
//
//-----------------------------------------------------------------------------

HRESULT ConvertOleWindowToHWND(OleWindow olewindow, HWND *hwnd)
{
    *hwnd = GetWindowWrapper(olewindow);

    if (NULL == *hwnd)
    {
        OutputDebugString("GetWindowWrapper failed \r\n");
        return E_FAIL;
    }
    else
    {
        return S_OK;
    }
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOleRectToRECT
//
//  Synopsis:   Convert a Mac Rect to a Win32 RECT
//
//  Parameters: [olerect]       -- The Rect
//              [pp_rect]       -- Where to put the RECT
//
//  Returns:    S_OK if all went well
//
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleRect is a RECT
//
//-----------------------------------------------------------------------------

HRESULT ConvertOleRectToRECT(const OleRect *olerect, RECT **pp_rect)
{
    *pp_rect = NULL;

    if (NULL == olerect)
    {
        return S_OK;
    }

    *pp_rect = new RECT;

    if (NULL == *pp_rect)
    {
        return E_OUTOFMEMORY;
    }

    (*pp_rect)->top    = olerect->top;
    (*pp_rect)->bottom = olerect->bottom;
    (*pp_rect)->left   = olerect->left;
    (*pp_rect)->right  = olerect->right;

    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOlePaletteToLOGPALETTE
//
//  Synopsis:   Convert an OlePalette to a Win32 LOGPALETTE structure
//
//  Parameters: [olepalette]        -- The OlePalette
//              [pp_logpalette]     -- Where to put the LOGPALETTE
//
//  Returns:    S_OK if all went well
//
//  History:    02-Aug-96   MikeW   Created
//
//  Notes:      OlePalette is an OLECOLORSCHEME.
//
//              The layout of an OLECOLOSCHEME is identical to a LOGPALETTE,
//              but some of the names of the structure member names are
//              different.
//
//-----------------------------------------------------------------------------

HRESULT ConvertOlePaletteToLOGPALETTE(
                const OlePalette *olepalette,
                LOGPALETTE      **pp_logpalette)
{
    *pp_logpalette = NULL;

    if (NULL == olepalette)
        return S_OK;

    UINT palette_size = sizeof(LOGPALETTE)
                        + (olepalette->numEntries - 1)
                          * sizeof(PALETTEENTRY);

    *pp_logpalette = (LOGPALETTE *) new BYTE[palette_size];

    if (NULL == *pp_logpalette)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        memcpy(*pp_logpalette, olepalette, palette_size);
        return S_OK;
    }
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOleHandleToHGLOBAL
//
//  Synopsis:   Convert an OleHandle to an HGLOBAL
//
//  Parameters: [olehandle]         -- The OleHandle
//              [hglobal]           -- Pointer to the HGLOBAL
//
//  Returns:    S_OK if all went well
//  
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleHandle is a Handle
//
//-----------------------------------------------------------------------------

HRESULT ConvertOleHandleToHGLOBAL(OleHandle olehandle, HGLOBAL *hglobal)
{
    long    size;
    void   *data = NULL;
    HRESULT hr = S_OK;

    size = GetHandleSize(olehandle);

    if (0 == size)
    {
        OutputDebugString("WARNING: ConvertOleHandleToHGLOBAL: "
                                   "GetHandleSize returned 0\r\n");
    }

    *hglobal = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, size);

    if (NULL == *hglobal)
    {
        hr = E_OUTOFMEMORY;
    }

    if (S_OK == hr)
    {
        data = GlobalLock(*hglobal);

        if (NULL == data)
        {
            hr = HRESULT_FROM_ERROR(GetLastError());
        }
    }

    if (S_OK == hr)
    {
        memcpy(data, *olehandle, size);
    }

    if (NULL != data)
    {
        GlobalUnlock(*hglobal);
    }

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Functions:  ConvertMSGToOleMessage
//
//  Synopsis:   Covert MGS to OleMessage
//
//  Parameters: [msg]       -- Pointer to a Win32 MSG structure
//              [pp_event]  -- Where to put a Mac EventRecord structure
//
//  Returns:    S_OK if all went well
//
//  History:    01-Aug-96   MikeW   Created
//
//  Notes:      OleMessage is an EventRecord
//
//              We currently only handle NULL MSG pointers
//
//-----------------------------------------------------------------------------

HRESULT ConvertMSGToOleMessage(const MSG *msg, OleMessage **pp_event)
{
    *pp_event = NULL;

    if (NULL != msg)
    {
        OutputDebugString("ConvertOleMessage only handles NULL messages\r\n");
        return E_NOTIMPL;
    }

    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertHWNDToOleWindow
//
//  Synopsis:   Convert a Win32HWND to a Mac WindowPtr
//
//  Parameters: [hwnd]          -- The HWND
//              [olewindow]     -- Where to put the OleWindow
//
//  Returns:    S_OK if all went well
//
//  History:    01-Aug-96   MikeW   Created
//
//  Notes:      OleWindow is a WindowPtr
//
//-----------------------------------------------------------------------------

HRESULT ConvertHWNDToOleWindow(HWND hwnd, OleWindow *olewindow)
{
    *olewindow = GetWrapperWindow(hwnd);

    if (NULL == *olewindow)
    {
        OutputDebugString("GetWindowWrapper failed \r\n");
        return E_FAIL;
    }
    else
    {
        return S_OK;
    }
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertRECTToOleRect
//
//  Synopsis:   Convert a WIN32 RECT to a OleRect
//
//  Parameters: [rect]          -- The RECT
//              [pp_rect]       -- Where to put the OleRect
//
//  Returns:    S_OK if all went well
//
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleRect is a RECT
//
//-----------------------------------------------------------------------------

HRESULT ConvertRECTToOleRect(const RECT *rect, OleRect **pp_olerect)
{
    *pp_olerect = NULL;

    if (NULL == rect)
    {
        return S_OK;
    }

    *pp_olerect = new OleRect;

    if (NULL == *pp_olerect)
    {
        return E_OUTOFMEMORY;
    }

    (*pp_olerect)->top    = (short) rect->top;
    (*pp_olerect)->bottom = (short) rect->bottom;
    (*pp_olerect)->left   = (short) rect->left;
    (*pp_olerect)->right  = (short) rect->right;

    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertHGLOBALToOleHandle
//
//  Synopsis:   Convert an HGLOBAL to an OleHandle
//
//  Parameters: [hglobal]           -- The HGLOBAL
//              [olehandle]         -- Pointer to the OleHandle
//
//  Returns:    S_OK if all went well
//
//  History:    01-Aug-96   MikeW   Created
//
//  Notes:      OleHandle is a Handle
//
//-----------------------------------------------------------------------------

HRESULT ConvertHGLOBALToOleHandle(HGLOBAL hglobal, OleHandle *olehandle)
{
    HRESULT hr = S_OK;
    void   *data = NULL;

    SetLastError(0);

    long size = GlobalSize(hglobal);

    if (0 == size)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (S_OK == hr)
    {
        *olehandle = NewHandle(size);

        if (NULL == *olehandle)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (S_OK == hr)
    {
        data = GlobalLock(hglobal);
        
        if (NULL == data)
        {
            hr = HRESULT_FROM_ERROR(GetLastError());
        }
    }

    if (S_OK == hr)
    {
        memcpy(**olehandle, data, size);
    }

    if (NULL != data)
    {
        GlobalUnlock(data);
    }

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertLOGPALETTEToOlePalette
//
//  Synopsis:   Convert a Win32 LOGPALETTE structure to a OlePalette
//
//  Parameters: [logpalette]        -- The LOGPALETTE
//              [pp_olepalette]     -- Where to put the OlePalette
//
//  Returns:    S_OK if all went well
//
//  History:    02-Aug-96   MikeW   Created
//
//  Notes:      OlePalette is an OLECOLORSCHEME.
//
//              The layout of an OLECOLOSCHEME is identical to a LOGPALETTE,
//              but some of the names of the structure member names are 
//              different.
//
//-----------------------------------------------------------------------------

HRESULT ConvertLOGPALETTEToOlePalette(
                const LOGPALETTE *logpalette, 
                OlePalette     **pp_olepalette)
{
    *pp_olepalette = NULL;

    if (NULL == logpalette)
        return S_OK;

    UINT palette_size = sizeof(LOGPALETTE)
                        + (logpalette->palNumEntries - 1) 
                          * sizeof(PALETTEENTRY);

    *pp_olepalette = (OLECOLORSCHEME *) new BYTE[palette_size];

    if (NULL == *pp_olepalette)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        memcpy(*pp_olepalette, logpalette, palette_size);
        return S_OK;
    }
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertHDCToOleDC
//
//  Synopsis:   Convert a Win32 HDC to an OleDC
//
//  Parameters: [hdc]           -- The HDC
//              [oledc]         -- The OleDC
//
//  Returns:    S_OK if all went well
//
//  History:    02-Aug-96   MikeW   Created
//
//  Notes:      OleDC is a GrafPtr
//
//-----------------------------------------------------------------------------

HRESULT ConvertHDCToOleDC(HDC hdc, OleDC *oledc)
{
    *oledc = CheckoutPort(hdc, CA_NONE);
    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertMETAFILEPICTToOleMetafile
//
//  Synopsis:   Convert a Win32 METAFILEPICT to an OleMetafile
//
//  Parameters: [metafilepict]      -- The METAFILEPICT
//              [olemetafile]       -- The ole metafile
//
//  Returns:    S_OK if all went well
//
//  History:    28-Aug-96   MikeW   Created
//
//  Notes:      OleMetafile is a PICT
//
//-----------------------------------------------------------------------------

HRESULT ConvertMETAFILEPICTToOleMetafile(
                        HMETAFILEPICT metafilepict,
                        OleMetafile  *olemetafile)
{
    PicHandle       pict = NULL;
    METAFILEPICT   *metadata = NULL;
    HRESULT         hr = S_OK;

    *olemetafile = NULL;

    metadata = (METAFILEPICT *) GlobalLock(metafilepict);

    if (NULL == metadata)
    {
        hr = E_FAIL;
    }

    if (S_OK == hr)
    {
        pict = CheckoutPict(metadata->hMF);

        if (NULL == pict)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        *olemetafile = (PicHandle) OleDuplicateData(
                                            (Handle) pict, 
                                            cfPict, 
                                            NULL);
   
        if (NULL == *olemetafile)
        {
            hr = E_FAIL;
        }
    }

    if (NULL != metadata)
    {
        GlobalUnlock(metafilepict);
    }
    if (NULL != pict)
    {
        CheckinPict(metadata->hMF);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolerpc\olestr\ctprintf.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  File:       ctprintf.cxx
//
//  Synopsis:   ct versions of the printf family
//
//  History:    30-May-96   MikeW   Created
//
//  Notes:      The ct version of the printf family adds two new format
//              specifiers: %os and %oc.  These specifiers mean ole-string
//              and ole-character respectively.
//
//              In the ANSI-version of this family these specifiers mean
//              "an octal digit followed by the letter s (or c)".  Code that
//              uses octal should be careful when using these functions.
//
//-----------------------------------------------------------------------------

#include <ctolerpc.h>
#pragma hdrstop



//
// MAX_FORMAT_SPECIFIER_BUFFER is the maximum length of a (munged) format
// specifier
//

const MAX_FORMAT_SPECIFIER_BUFFER = 1024;

//
// MAKE_UNICODE unconditionally makes a string or char constant Unicode
//

#define _MAKE_UNICODE(x)    L##x
#define MAKE_UNICODE(x)     _MAKE_UNICODE(x)



#ifndef UNICODE_ONLY

//+----------------------------------------------------------------------------
//
//  Function:   MungeFormatSpecifiersA
//
//  Synopsis:   Convert the 'os' and 'oc' printf-format specifier to the right 
//              thing to handle Ole strings and Ole chars.
//
//  Parameters: [format]            -- The format string to convert
//              [munged_format]     -- Where to put the munged format
//
//  Returns:    void
//
//  History:    30-May-96   MikeW   Created
//
//  Notes:      In the regular printf family "%os" and "%oc" evaluate to 
//              an octal number followed by a 's' or a 'c'.  To get these
//              cases to work always put some character (such as a space)
//              after a %o specifier.
//
//-----------------------------------------------------------------------------

void MungeFormatSpecifiersA(const char *format, char *munged_format)
{
    const char *start_of_uncopied_data;
    
    *munged_format = '\0';

    start_of_uncopied_data = format;
    format = strchr(format, '%');

    while (NULL != format)
    {
        //
        // Find the type of the format specifier.
        // Watch out for "%%" and "%<null terminator>".
        //

        do
        {
            ++format;
        }
        while ('%' != *format && '\0' != *format && !isalpha(*format));

        strncat(
                munged_format, 
                start_of_uncopied_data, 
                format - start_of_uncopied_data);

        start_of_uncopied_data = format;
        
        //
        // Munge it to the right thing for %os or %oc
        //

        if ('o' == *format && 's' == *(format + 1))
        {
            strcat(munged_format, OLE_STRING_SPECIFIER);
            format += 1;       
            start_of_uncopied_data += 2;
        }
        else if ('o' == *format && 'c' == *(format + 1))
        {
            strcat(munged_format, OLE_CHAR_SPECIFIER);
            format += 1;
            start_of_uncopied_data += 2;
        }

        format = strchr(format + 1, '%');
    }

    strcat(munged_format, start_of_uncopied_data);
}



//+----------------------------------------------------------------------------
//
//  Functions:  ctprintfA, ctsprintfA, ctsnprintfA, ctfprintfA
//              ctvprintfA, ctvsprintfA, ctvsnprintfA, ctvfprintfA
//      
//  Synopsis:   ct versions of standard ANSI printf family
//
//  History:    30-May-96   MikeW   Created
//
//-----------------------------------------------------------------------------

int ctprintfA(const char *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvprintfA(format, varargs);
}

int ctsprintfA(char *buffer, const char *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvsprintfA(buffer, format, varargs);
}

int ctsnprintfA(char *buffer, size_t count, const char *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvsnprintfA(buffer, count, format, varargs);
}

int ctfprintfA(FILE *stream, const char *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvfprintfA(stream, format, varargs);
}

int ctvprintfA(const char *format, va_list varargs)
{
    char munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersA(format, munged_format);
    return vprintf(munged_format, varargs);
}

int ctvsprintfA(char *buffer, const char *format, va_list varargs)
{
    char munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersA(format, munged_format);
    return vsprintf(buffer, munged_format, varargs);
}

int ctvsnprintfA(
            char *buffer, 
            size_t count, 
            const char *format, 
            va_list varargs)
{
    char munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersA(format, munged_format);
    return _vsnprintf(buffer, count, munged_format, varargs);
}

int ctvfprintfA(FILE *stream, const char *format, va_list varargs)
{
    char munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersA(format, munged_format);
    return vfprintf(stream, munged_format, varargs);
}

#endif // !UNICODE_ONLY



#ifndef ANSI_ONLY

//+----------------------------------------------------------------------------
//
//  Function:   MungeFormatSpecifiersW
//
//  Synopsis:   Convert the 'os' and 'oc' printf-format specifier to the right 
//              thing to handle Ole strings and Ole chars.
//
//  Parameters: [format]            -- The format string to convert
//              [munged_format]     -- Where to put the munged format
//
//  Returns:    void
//
//  History:    30-May-96   MikeW   Created
//
//  Notes:      In the regular printf family "%os" and "%oc" evaluate to 
//              an octal number followed by a 's' or a 'c'.  To get these
//              cases to work always put some character (such as a space)
//              after a %o specifier.
//
//-----------------------------------------------------------------------------

void MungeFormatSpecifiersW(const wchar_t *format, wchar_t *munged_format)
{
    const wchar_t *start_of_uncopied_data;
    
    *munged_format = L'\0';

    start_of_uncopied_data = format;
    format = wcschr(format, L'%');

    while (NULL != format)
    {
        //
        // Find the type of the format specifier.
        // Watch out for "%%" and "%<null terminator>".
        //

        do
        {
            ++format;
        }
        while (L'%' != *format && L'\0' != *format && !iswalpha(*format));

        wcsncat(
                munged_format, 
                start_of_uncopied_data, 
                format - start_of_uncopied_data);

        start_of_uncopied_data = format;
        
        //
        // Munge it to the right thing for %os or %oc
        //

        if (L'o' == *format && L's' == *(format + 1))
        {
            wcscat(munged_format, MAKE_UNICODE(OLE_STRING_SPECIFIER));
            format += 1;       
            start_of_uncopied_data += 2;
        }
        else if (L'o' == *format && L'c' == *(format + 1))
        {
            wcscat(munged_format, MAKE_UNICODE(OLE_CHAR_SPECIFIER));
            format += 1;
            start_of_uncopied_data += 2;
        }

        format = wcschr(format + 1, '%');
    }

    wcscat(munged_format, start_of_uncopied_data);
}



//+----------------------------------------------------------------------------
//
//  Functions:  ctprintfW, ctsprintfW, ctsnprintfW, ctfprintfW
//              ctvprintfW, ctvsprintfW, ctvsnprintfW, ctvfprintfW
//      
//  Synopsis:   ct versions of standard Unicode printf family
//
//  History:    30-May-96   MikeW   Created
//
//-----------------------------------------------------------------------------

int ctprintfW(const wchar_t *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvprintfW(format, varargs);
}

int ctsprintfW(wchar_t *buffer, const wchar_t *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvsprintfW(buffer, format, varargs);
}

int ctsnprintfW(wchar_t *buffer, size_t count, const wchar_t *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvsnprintfW(buffer, count, format, varargs);
}

int ctfprintfW(FILE *stream, const wchar_t *format, ...)
{
    va_list varargs;
    va_start(varargs, format);
    return ctvfprintfW(stream, format, varargs);
}

int ctvprintfW(const wchar_t *format, va_list varargs)
{
    wchar_t munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersW(format, munged_format);
    return vwprintf(munged_format, varargs);
}

int ctvsprintfW(wchar_t *buffer, const wchar_t *format, va_list varargs)
{
    wchar_t munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersW(format, munged_format);
    return vswprintf(buffer, munged_format, varargs);
}

int ctvsnprintfW(
            wchar_t *buffer, 
            size_t count, 
            const wchar_t *format, 
            va_list varargs)
{
    wchar_t munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersW(format, munged_format);
    return _vsnwprintf(buffer, count, munged_format, varargs);
}

int ctvfprintfW(FILE *stream, const wchar_t *format, va_list varargs)
{
    wchar_t munged_format[MAX_FORMAT_SPECIFIER_BUFFER];
    MungeFormatSpecifiersW(format, munged_format);
    return vfwprintf(stream, munged_format, varargs);
}

#endif // !ANSI_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolerpc\oletypes\windows\oletypes.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  All rights reserved.
//
//  File:       oletypes.cxx
//
//  Synopsis:   Windows versions of Ole types conversion routines
//
//  History:    30-Jul-96   MikeW   Created
//
//-----------------------------------------------------------------------------

#include <ctolerpc.h>



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOleMessageToMSG
//
//  Synopsis:   Convert an OleMessage to a MSG
//
//  Parameters: [olemessage]        -- Pointer to the OleMessage
//              [pp_msg]            -- Where to put the MSG pointer
//
//  Returns:    S_OK if all went well
//
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleMessage is a MSG
//
//-----------------------------------------------------------------------------

HRESULT ConvertOleMessageToMSG(const OleMessage * olemessage, MSG ** pp_msg)
{
    *pp_msg = NULL;

    if (NULL != olemessage)
    {
        *pp_msg = new MSG;

        if (NULL == *pp_msg)
        {
            return E_OUTOFMEMORY;
        }

        memcpy(*pp_msg, olemessage, sizeof(MSG));
    }

    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOleWindowToHWND
//
//  Synopsis:   Convert an OleWindow to a HWND
//
//  Parameters: [olewindow]         -- The OleWindow
//              [hwnd]              -- Where to put the HWND
//
//  Returns:    S_OK if all went well
//
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleWindow is a HWND
//
//-----------------------------------------------------------------------------

HRESULT ConvertOleWindowToHWND(OleWindow olewindow, HWND *hwnd)
{
    *hwnd = olewindow;
    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOleRectToRECT
//
//  Synopsis:   Convert an OleRect to a RECT
//
//  Parameters: [olerect]       -- The OleRect
//              [pp_rect]       -- Where to put the RECT
//
//  Returns:    S_OK if all went well
//
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleRect is a RECT
//
//-----------------------------------------------------------------------------

HRESULT ConvertOleRectToRECT(const OleRect *olerect, RECT **pp_rect)
{
    *pp_rect = NULL;

    if (NULL == olerect)
    {
        return S_OK;
    }

    *pp_rect = new RECT;

    if (NULL == *pp_rect)
    {
        return E_OUTOFMEMORY;
    }
    
    memcpy(*pp_rect, olerect, sizeof(RECT));
    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOlePaletteToLOGPALETTE
//
//  Synopsis:   Convert an OlePalette to a Win32 LOGPALETTE structure
//
//  Parameters: [olepalette]        -- The OlePalette
//              [pp_logpalette]     -- Where to put the LOGPALETTE
//
//  Returns:    S_OK if all went well
//
//  History:    11-Nov  MikeW   Created
//
//  Notes:      OlePalette is a LOGPALETTE. 
//
//-----------------------------------------------------------------------------

HRESULT ConvertOlePaletteToLOGPALETTE(
                const OlePalette *olepalette,
                LOGPALETTE      **pp_logpalette)
{
    *pp_logpalette = NULL;

    if (NULL == olepalette)
        return S_OK;

    //
    // Calculate the number of bytes we need for the entire LOGPALETTE
    // structure.  We subtract one because LOGPALETTE already has room
    // for one palette entry.
    //

    UINT palette_size = sizeof(LOGPALETTE)
                        + (olepalette->palNumEntries - 1)
                          * sizeof(PALETTEENTRY);

    *pp_logpalette = (LOGPALETTE *) new BYTE[palette_size];

    if (NULL == *pp_logpalette)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        memcpy(*pp_logpalette, olepalette, palette_size);
        return S_OK;
    }
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertOleHandleToHGLOBAL
//
//  Synopsis:   Convert an OleHandle to an HGLOBAL
//
//  Parameters: [olehandle]     -- The OleHandle
//              [hglobal]       -- Pointer to the HGLOBAL
//
//  Returns:    S_OK if all went well
//
//  History:    30-Jul-96   MikeW   Created
//
//  Notes:      OleHandle is an HGLOBAL
//
//              The HGLOBAL is always allocated with GMEM_MOVEABLE and 
//              GMEM_SHARE.
//
//-----------------------------------------------------------------------------

HRESULT ConvertOleHandleToHGLOBAL(OleHandle olehandle, HGLOBAL *hglobal)
{
    void   *olebytes = NULL;
    void   *bytes = NULL;
    HRESULT hr = S_OK;

    *hglobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, GlobalSize(olehandle));

    if (NULL == hglobal)
    {
        hr = E_OUTOFMEMORY;
    }

    if (S_OK == hr)
    {
        olebytes = GlobalLock(olehandle);

        if (NULL == olebytes)
        {
            hr = HRESULT_FROM_ERROR(GetLastError());
        }
    }

    if (S_OK == hr)
    {
        bytes = GlobalLock(*hglobal);

        if (NULL == olebytes)
        {
            hr = HRESULT_FROM_ERROR(GetLastError());
        }
    } 

    if (S_OK == hr)
    {
        memcpy(bytes, olebytes, GlobalSize(olehandle));
    }

    if (NULL != bytes)
    {
        GlobalUnlock(*hglobal);
    }
    if (NULL != olebytes)
    {
        GlobalUnlock(olehandle);
    }

    return hr;
}  



//+----------------------------------------------------------------------------
//
//  Function:   ConvertHWNDToOleWindow
//
//  Synopsis:   Convert a Win32 HWND to an OleWindow
//
//  Parameters: [hwnd]          -- The HWND
//              [olewindow]     -- Where to put the OleWindow
//
//  Returns:    S_OK if all went well
//
//  History:    11-Nov-96   MikeW   Created
//
//  Notes:      OleWindow is a HWND
//
//-----------------------------------------------------------------------------

HRESULT ConvertHWNDToOleWindow(HWND hwnd, OleWindow *olewindow)
{
    *olewindow = hwnd;

    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertRECTToOleRect
//
//  Synopsis:   Convert a WIN32 RECT to an OleRect
//
//  Parameters: [rect]          -- The RECT
//              [pp_olerect]    -- Where to put the OleRect
//
//  Returns:    S_OK if all went well
//
//  History:    11-Nov-96   MikeW   Created
//
//  Notes:      OleRect is a RECT
//
//-----------------------------------------------------------------------------

HRESULT ConvertRECTToOleRect(const RECT *rect, OleRect **pp_olerect)
{   
    *pp_olerect = NULL;

    if (NULL == rect)
    {
        return S_OK;
    }

    *pp_olerect = new OleRect;

    if (NULL == *pp_olerect)
    {
        return E_OUTOFMEMORY;
    }

    memcpy(*pp_olerect, rect, sizeof(RECT));
    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertHGLOBALToOleHandle
//
//  Synopsis:   Convert an HGLOBAL to an OleHandle
//
//  Parameters: [hglobal]           -- The HGLOBAL
//              [olehandle]         -- Pointer to the OleHandle
//
//  Returns:    S_OK if all went well
//
//  History:    05-Nov-96   BogdanT   Created
//
//  Notes:      OleHandle is a HGLOBAL
//
//-----------------------------------------------------------------------------

HRESULT ConvertHGLOBALToOleHandle(HGLOBAL hglobal, OleHandle *pOlehandle)
{
    HRESULT hr = S_OK;
    UINT    flags = 0;
    LPVOID  lpSrc = NULL, lpDest = NULL;

    *pOlehandle = NULL;
    
    SetLastError(0);

    long size = GlobalSize(hglobal);

    if (0 == size)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (S_OK == hr)
    {
        flags = GlobalFlags(hglobal);

        if (GMEM_INVALID_HANDLE == flags)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (S_OK == hr)
    {
        *pOlehandle = GlobalAlloc(flags, size);

        if (NULL == *pOlehandle)
        {
            hr =  HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (S_OK == hr)
    {
        lpSrc = GlobalLock(hglobal);

        if (NULL == lpSrc)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (S_OK == hr)
    {
        lpDest = GlobalLock(*pOlehandle);

        if (NULL == lpDest)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (S_OK == hr)
    {
        CopyMemory(lpDest, lpSrc, size);
        
        if(FALSE == GlobalUnlock(hglobal))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        if(FALSE == GlobalUnlock(*pOlehandle))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertHDCToOleDC
//
//  Synopsis:   Convert a Win32 HDC to an OleDC
//
//  Parameters: [hdc]           -- The HDC
//              [oledc]         -- The OleDC
//
//  Returns:    S_OK if all went well
//
//  History:    11-Nov-96   MikeW   Created
//
//  Notes:      OleDC is a hDC
//
//-----------------------------------------------------------------------------

HRESULT ConvertHDCToOleDC(HDC hdc, OleDC *oledc)
{
    *oledc = hdc;

    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertMETAFILEPICTToOleMetafile
//
//  Synopsis:   Convert a Win32 METAFILEPICT to an OleMetafile
//
//  Parameters: [metafilepict]      -- The METAFILEPICT
//              [olemetafile]       -- The ole metafile
//
//  Returns:    S_OK if all went well
//
//  History:    11-Nov-96   MikeW   Created
//
//  Notes:      OleMetafile is a HMETAFILEPICT
//
//-----------------------------------------------------------------------------

HRESULT ConvertMETAFILEPICTToOleMetafile(
                        HMETAFILEPICT metafilepict,
                        OleMetafile  *olemetafile)
{
    HRESULT         hr = S_OK;
    
    *olemetafile = (HMETAFILEPICT) OleDuplicateData(
                                            metafilepict,
                                            CF_METAFILEPICT,
                                            NULL);

    if (NULL == *olemetafile)
    {
        hr = HRESULT_FROM_ERROR(GetLastError());
    }

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Function:   ConvertLOGPALETTEToOlePalette
//
//  Synopsis:   Convert a Win32 LOGPALETTE structure to a OlePalette
//
//  Parameters: [logpalette]        -- The LOGPALETTE
//              [pp_olepalette]     -- Where to put the OlePalette
//
//  Returns:    S_OK if all went well
//
//  History:    17-Jan-97   EmanP   Created
//
//  Notes:      OlePalette is an LOGPALETTE.
//
//-----------------------------------------------------------------------------

HRESULT ConvertLOGPALETTEToOlePalette(
                const LOGPALETTE *logpalette,
                OlePalette     **pp_olepalette)
{
    *pp_olepalette = NULL;

    if (NULL == logpalette)
        return S_OK;

    UINT palette_size = sizeof(LOGPALETTE)
                        + (logpalette->palNumEntries - 1)
                          * sizeof(PALETTEENTRY);

    *pp_olepalette = (LOGPALETTE *) new BYTE[palette_size];

    if (NULL == *pp_olepalette)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        memcpy(*pp_olepalette, logpalette, palette_size);
        return S_OK;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolerpc\include\macport.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  All rights reserved.
//
//  File:       macport.h
//
//  Synopsis:   Defintions for unimplemented stubs & functions & structures
//              for the Macintosh.
//
//-----------------------------------------------------------------------------

#ifndef _MACPORT_H_
#define _MACPORT_H_


//
// WLM is REALLY bad about calling SetLastError when an error occurs.  This
// screws up the upper layer tests pretty badly.  Use this macro when you
// know an error exists and that error 0 (S_OK or ERROR_SUCCESS) is defitely
// wrong.
//

#define HRESULT_FROM_ERROR(x)  (x ? ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)) : E_FAIL)
 

#ifndef _MAC

//
// Stub out some Mac calls if were not building for the mac
//

#define MacInitializeCommandLine()
#define FixHr(x) x
#define MacGetFocus()

//
// Process ID's are completely different on the Mac then on Win32.
//

typedef DWORD ProcessId;


#else // _MAC

//
// Ole types
//

#include <variant.h>
#include <dispatch.h>


typedef DWORD  CLIPFORMAT;
typedef void * HMETAFILEPICT;

#define PHKEY unsigned long *

typedef DWORD REGSAM;

#define TYMED_ENHMF 64

//
// From wchar.h
//

#ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
#define _WCTYPE_T_DEFINED
#endif


//
// Wide-char string functions
//

int swprintf( wchar_t *buffer, const wchar_t *format, ... );
int _snwprintf( wchar_t *buffer, size_t count, const wchar_t *format, ... );
wchar_t towupper( wint_t c );
size_t wcslen( const wchar_t *string );
wchar_t *wcscpy( wchar_t *string1, const wchar_t *string2 );
wchar_t *wcsncpy( wchar_t *string1, const wchar_t *string2, size_t count );
int wcscmp( const wchar_t *string1, const wchar_t *string2 );
int _wcsicmp( const wchar_t *string1, const wchar_t *string2 );
wchar_t *wcscat( wchar_t *string1, const wchar_t *string2 );
wchar_t * __cdecl wcschr(const wchar_t *string, wchar_t ch);
wchar_t * __cdecl wcsrchr(const wchar_t *string, wchar_t ch);
wchar_t *wcstok( wchar_t *string1, const wchar_t *string2 );
int iswctype( wint_t c, wctype_t desc );
wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
long   __cdecl wcstol(const wchar_t *, wchar_t **, int);


//
// String conversion functions
//

WINBASEAPI
int
WINAPI
MultiByteToWideChar(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCSTR   lpMultiByteStr,
    int      cchMultiByte,
    LPWSTR   lpWideCharStr,
    int      cchWideChar);

WINBASEAPI
int
WINAPI
WideCharToMultiByte(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCWSTR  lpWideCharStr,
    int      cchWideChar,
    LPSTR    lpMultiByteStr,
    int      cchMultiByte,
    LPCSTR   lpDefaultChar,
    LPBOOL   lpUsedDefaultChar);

#define CP_ACP               0
#define CP_OEMCP             1
#define CP_MACCP             2


//
// More miscellaneous string things
//

LANGID GetSystemDefaultLangID();

#ifndef UNICODE_ONLY
WINBASEAPI
DWORD
WINAPI
FormatMessageA(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINBASEAPI
DWORD
WINAPI
FormatMessageW(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );
#endif //!ANSI_ONLY
#ifdef UNICODE
#define FormatMessage  FormatMessageW
#else
#define FormatMessage  FormatMessageA
#endif // !UNICODE



//
// Network functions
//

typedef struct  _NETRESOURCEA {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPSTR    lpLocalName;
    LPSTR    lpRemoteName;
    LPSTR    lpComment ;
    LPSTR    lpProvider;
}NETRESOURCEA, *LPNETRESOURCEA;
typedef struct  _NETRESOURCEW {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPWSTR   lpLocalName;
    LPWSTR   lpRemoteName;
    LPWSTR   lpComment ;
    LPWSTR   lpProvider;
}NETRESOURCEW, *LPNETRESOURCEW;
#ifdef UNICODE
typedef NETRESOURCEW NETRESOURCE;
typedef LPNETRESOURCEW LPNETRESOURCE;
#else
typedef NETRESOURCEA NETRESOURCE;
typedef LPNETRESOURCEA LPNETRESOURCE;
#endif // UNICODE

#define RESOURCETYPE_ANY        0x00000000
#define RESOURCETYPE_DISK       0x00000001
#define RESOURCETYPE_PRINT      0x00000002
#define RESOURCETYPE_RESERVED   0x00000008
#define RESOURCETYPE_UNKNOWN    0xFFFFFFFF

DWORD APIENTRY
WNetAddConnection2A(
     LPNETRESOURCEA lpNetResource,
     LPCSTR       lpPassword,
     LPCSTR       lpUserName,
     DWORD          dwFlags
    );
DWORD APIENTRY
WNetAddConnection2W(
     LPNETRESOURCEW lpNetResource,
     LPCWSTR       lpPassword,
     LPCWSTR       lpUserName,
     DWORD          dwFlags
    );
#ifdef UNICODE
#define WNetAddConnection2  WNetAddConnection2W
#else
#define WNetAddConnection2  WNetAddConnection2A
#endif // !UNICODE

DWORD APIENTRY
WNetCancelConnectionA(
     LPCSTR lpName,
     BOOL     fForce
    );
DWORD APIENTRY
WNetCancelConnectionW(
     LPCWSTR lpName,
     BOOL     fForce
    );
#ifdef UNICODE
#define WNetCancelConnection  WNetCancelConnectionW
#else
#define WNetCancelConnection  WNetCancelConnectionA
#endif // !UNICODE


//
// Command line functions
//

LPSTR GetCommandLineA();
#define GetCommandLine GetCommandLineA

HRESULT MacInitializeCommandLine();

DWORD GetCurrentDirectoryA(
      DWORD  nBufferLength,     // size, in characters, of directory buffer
      LPTSTR  lpBuffer  // address of buffer for current directory 
      );


// 
// Registry functions
//
// Turn off WLM's registry wrappers so we can talk directory to the API's
//

#undef RegCloseKey
#undef RegCreateKey
#undef RegOpenKey
#undef RegSetValue
#undef RegSetValueEx
#undef RegDeleteValue
#undef RegQueryValue
#undef RegQueryValueEx
#undef RegEnumKeyEx

#define RegSetValueEx   CtRegSetValueEx
#define RegQueryValueEx CtRegQueryValueEx

LONG RegCreateKeyEx(
    HKEY hKey,  // handle of an open key 
    LPCTSTR lpSubKey,   // address of subkey name 
    DWORD Reserved, // reserved 
    LPTSTR lpClass, // address of class string 
    DWORD dwOptions,    // special options flag 
    REGSAM samDesired,  // desired security access 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // address of key security structure 
    PHKEY phkResult,    // address of buffer for opened handle  
    LPDWORD lpdwDisposition     // address of disposition value buffer 
   );
LONG RegOpenKeyEx(
    HKEY hKey,  // handle of open key 
    LPCTSTR lpSubKey,   // address of name of subkey to open 
    DWORD ulOptions,    // reserved 
    REGSAM samDesired,  // security access mask 
    PHKEY phkResult     // address of handle of open key 
   );
LONG CtRegSetValueEx(
    HKEY hKey,  // handle of key to set value for  
    LPCTSTR lpValueName,    // address of value to set 
    DWORD Reserved, // reserved 
    DWORD dwType,   // flag for value type 
    CONST BYTE *lpData, // address of value data 
    DWORD cbData    // size of value data 
   );
LONG RegQueryValueEx(
    HKEY hKey,  // handle of key to query 
    LPTSTR lpValueName, // address of name of value to query 
    LPDWORD lpReserved, // reserved 
    LPDWORD lpType, // address of buffer for value type 
    LPBYTE lpData,  // address of data buffer 
    LPDWORD lpcbData    // address of data buffer size 
   );
LONG RegEnumKeyEx(
    HKEY hKey,  // handle of key to enumerate 
    DWORD dwIndex,  // index of subkey to enumerate 
    LPTSTR lpName,  // address of buffer for subkey name 
    LPDWORD lpcbName,   // address for size of subkey buffer 
    LPDWORD lpReserved, // reserved 
    LPTSTR lpClass, // address of buffer for class string 
    LPDWORD lpcbClass,  // address for size of class buffer 
    PFILETIME lpftLastWriteTime     // address for time key last written to 
   );


//
// Process ID's are completely different on the Mac then on Win32.
//

typedef ProcessSerialNumber ProcessId;

#define GetCurrentProcessId MacGetCurrentProcessId
#define OpenProcess         MacOpenProcess

#undef CreateProcess
#define CreateProcess MacCreateProcess

struct MAC_PROCESS_INFORMATION
{
    HANDLE      hProcess;
    HANDLE      hThread;
    ProcessId   dwProcessId;
    ProcessId   dwThreadId;
};

typedef MAC_PROCESS_INFORMATION * LPMAC_PROCESS_INFORMATION;

ProcessId MacGetCurrentProcessId();
HANDLE    MacOpenProcess(DWORD, BOOL, ProcessId);
BOOL      MacCreateProcess(
	     LPCTSTR,
	     LPTSTR,
	     LPSECURITY_ATTRIBUTES,
	     LPSECURITY_ATTRIBUTES,
	     BOOL,
	     DWORD,
	     LPVOID,
	     LPCTSTR,
	     LPSTARTUPINFO,
	     LPMAC_PROCESS_INFORMATION);

		


#define PROCESS_INFORMATION MAC_PROCESS_INFORMATION
#define LPPROCESS_INFORMATION LPMAC_PROCESS_INFORMATION


//
// The WLM IsBadXXX functions just check for NULL, but NULL is ok if the 
// byte count is 0.
//
// Use the weird trinary stuff to prevent warnings about constant boolean
// expressions if c is a constant.
//

#define IsBadReadPtr(p, c)  ((c) ? IsBadReadPtr((p), (c)) : FALSE)
#define IsBadWritePtr(p, c) ((c) ? IsBadWritePtr((p), (c)) : FALSE)

//
// MacOle uses some old values for HRESULTs
// (like 0x80000008 instead of 0x80004005 for E_FAIL)
// This function just converts such old values to
// new ones
//

HRESULT FixHr (HRESULT hrOld);

//
// On the mac, only the foreground app
// can use the clipboard
//
void MacGetFocus ();

BOOL MacIsFullPath (LPCSTR lpszFileName);

#endif // _MAC

#endif // _MACPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolerpc\include\olestr.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  File:       olestr.h
//
//  Synopsis:   ct versions of the printf family and olestr functions
//
//  History:    30-May-96   MikeW      Created.
//              12-Nov-97   a-sverrt   Added a couple more olestrxxx macros.
//
//  Notes:      The ct version of the printf family adds two new format
//              specifiers: %os and %oc.  These specifiers mean ole-string
//              and ole-character respectively.
//
//              In the ANSI-version of this family these specifiers mean
//              "an octal digit followed by the letter s (or c)".  Code that
//              uses octal should be careful when using these functions.
//
//-----------------------------------------------------------------------------

#ifndef _OLESTR_H_
#define _OLESTR_H_



//
// Determine if Ole is Unicode based or not
//

#if !defined(WIN16) && !defined(_MAC)
#define OLE_IS_UNICODE
#endif



//
// Use : as path separator on Mac
//

#ifdef _MAC

#define CH_SEP ':'
#define SZ_SEP TEXT(":")

#else

#define CH_SEP '\\'
#define SZ_SEP TEXT("\\")

#endif // _MAC



//
// Format specifiers for Unicode and Ansi strings and characters
//

#define UNICODE_STRING_SPECIFIER    "ls"
#define UNICODE_CHAR_SPECIFIER      "lc"
#define ANSI_STRING_SPECIFIER       "hs"
#define ANSI_CHAR_SPECIFIER         "hc"



//
// Format specifiers for Ole strings and characters
//

#ifdef OLE_IS_UNICODE

#define OLE_STRING_SPECIFIER    UNICODE_STRING_SPECIFIER
#define OLE_CHAR_SPECIFIER      UNICODE_CHAR_SPECIFIER 

#else // !OLE_IS_UNICODE

#define OLE_STRING_SPECIFIER    ANSI_STRING_SPECIFIER
#define OLE_CHAR_SPECIFIER      ANSI_CHAR_SPECIFIER 

#endif // !OLE_IS_UNICODE



//
// Unicode/Ansi indepedent ctprintf-family
//

#ifndef UNICODE_ONLY

int ctprintfA(const char *format, ...);
int ctsprintfA(char *buffer, const char *format, ...);
int ctsnprintfA(char *buffer, size_t count, const char *format, ...);
int ctfprintfA(FILE *stream, const char *format, ...);
int ctvprintfA(const char *format, va_list varargs);
int ctvsprintfA(char *buffer, const char *format, va_list varargs);
int ctvsnprintfA(
            char *buffer, 
            size_t count, 
            const char *format, 
            va_list varargs);
int ctvfprintfA(FILE *stream, const char *format, va_list varargs);

#endif // !UNICODE_ONLY



#ifndef ANSI_ONLY

int ctprintfW(const wchar_t *format, ...);
int ctsprintfW(wchar_t *buffer, const wchar_t *format, ...);
int ctsnprintfW(wchar_t *buffer, size_t count, const wchar_t *format, ...);
int ctfprintfW(FILE *stream, const wchar_t *format, ...);
int ctvprintfW(const wchar_t *format, va_list varargs);
int ctvsprintfW(wchar_t *buffer, const wchar_t *format, va_list varargs);
int ctvsnprintfW(
            wchar_t *buffer, 
            size_t count, 
            const wchar_t *format, 
            va_list varargs);
int ctvfprintfW(FILE *stream, const wchar_t *format, va_list varargs);

#endif //!ANSI_ONLY



#ifdef UNICODE

#define ctprintf        ctprintfW
#define ctsprintf       ctsprintfW
#define ctsnprintf      ctsnprintfW
#define ctfprintf       ctfprintfW
#define ctvprintf       ctvprintfW
#define ctvsprintf      ctvsprintfW
#define ctvsnprintf     ctvsnprintfW
#define ctvfprintf      ctvfprintfW

#else // !UNICODE

#define ctprintf        ctprintfA
#define ctsprintf       ctsprintfA
#define ctsnprintf      ctsnprintfA
#define ctfprintf       ctfprintfA
#define ctvprintf       ctvprintfA
#define ctvsprintf      ctvsprintfA
#define ctvsnprintf     ctvsnprintfA
#define ctvfprintf      ctvfprintfA

#endif // !UNICODE



//
// Unicode/Ansi independent ole string functions
//

#ifdef OLE_IS_UNICODE


#define  olembstowcs(x,y,z) mbstowcs(x,y,z)
#define  olestrcat          wcscat
#define  olestrchr          wcschr
#define  olestrcmp          wcscmp
#define  olestrcpy          wcscpy
#define _olestricmp        _wcsicmp
#define  olestrlen          wcslen
#define  olestrncmp         wcsncmp
#define  olestrncpy         wcsncpy
#define _olestrnicmp       _wcsnicmp
#define  olestrrchr         wcsrchr
#define  olestrstr          wcsstr
#define  olestrtok          wcstok
#define  olestrtol          wcstol
#define  olestrtoul         wcstoul
#define  olestrtombs(x,y,z) wcstombs(x,y,z)
#define  olewcstombs(x,y,z) wcstombs(x,y,z)
#define  tooleupper         towupper

#define _ltoole            _ltow

#define  olectsnprintf      ctsnprintfW
#define  olectsprintf       ctsprintfW
#define  olesscanf          swscanf
#define  olesprintf         swprintf

#else // !OLE_IS_UNICODE

#define  olembstowcs(x,y,z) strcpy(x,y)
#define  olestrcat          strcat
#define  olestrchr          strchr
#define  olestrcmp          strcmp
#define  olestrcpy          strcpy
#define _olestricmp        _stricmp
#define  olestrlen          strlen
#define  olestrncmp         strncmp
#define  olestrncpy         strncpy
#define _olestrnicmp       _strnicmp
#define  olestrrchr         strrchr
#define  olestrstr          strstr
#define  olestrtok          strtok
#define  olestrtol          strtol
#define  olestrtoul         strtoul
#define  olestrtombs(x,y,z) strncpy(x,y,z)
#define  olewcstombs(x,y,z) strcpy(x,y)      // srt: equivalent to converting in this case
#define  tooleupper         toupper

#define _ltoole            _ltoa

#define  olectsnprintf      ctsnprintfA
#define  olectsprintf       ctsprintfA
#define  olesscanf          sscanf
#define  olesprintf         sprintf

#endif // !OLE_IS_UNICODE



//
// String copy & conversion functions
//

#ifdef __cplusplus

HRESULT CopyString(LPCWSTR, LPSTR *);
HRESULT CopyString(LPCSTR,  LPWSTR *);
HRESULT CopyString(LPCSTR,  LPSTR *);
HRESULT CopyString(LPCWSTR, LPWSTR *);
HRESULT CopyString(LPCWSTR, LPSTR, int, int);
HRESULT CopyString(LPCSTR,  LPWSTR, int, int);


//+--------------------------------------------------------------------------
//
//  unsigned char thunks
//
//  DBCS chars are unsigned so the signed functions above won't match.
//  However, the signed functions are written to be DBCS aware so it's ok
//  to just cast & thunk.
//
//---------------------------------------------------------------------------

inline HRESULT CopyString(LPCWSTR pszSource, unsigned char **ppszDest)
{
    return CopyString(pszSource, (char **) ppszDest);
}

inline HRESULT CopyString(unsigned char *pszSource, LPWSTR *ppszDest)
{
    return CopyString((char *) pszSource, ppszDest);
}

inline HRESULT CopyString(unsigned char *pszSource, unsigned char ** ppszDest)
{
    return CopyString((char *) pszSource, (char **) ppszDest);
}

#endif // __cplusplus



HRESULT TStringToOleString(LPCTSTR pszSource, LPOLESTR *ppszDest);
HRESULT WStringToOleString(LPCWSTR pszSource, LPOLESTR *ppszDest);
HRESULT AStringToOleString(LPCSTR pszSource, LPOLESTR *ppszDest);

HRESULT OleStringToTString(LPCOLESTR pszSource, LPTSTR *ppszDest);
HRESULT OleStringToWString(LPCOLESTR pszSource, LPWSTR *ppszDest);
HRESULT OleStringToAString(LPCOLESTR pszSource, LPSTR *ppszDest);

HRESULT TStringToAString (LPCTSTR pszSource, LPSTR *ppszDest);
HRESULT AStringToTString (LPCSTR pszSource, LPTSTR *ppszDest);


#endif // _OLESTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolerpc\olestr\convert.cxx ===
//+--------------------------------------------------------------------------
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  File:       convert.cxx
//
//  Synopsis:   Functions for converting between LPSTR, LPWSTR, LPTSTR, and
//              LPOLESTR
//
//  Functions:  CopyString (all versions)
//
//              TStringToOleString
//              WStringToOleString
//              AStringToOleString
//              OleStringToTString
//              OleStringToWString
//              OleStringToAString
//
//  History:    01-Aug-96   MikeW   Created
//              31-Oct-96   MikeW   Re-wrote to be DBCS aware
//                                  and less code duplication
//
//---------------------------------------------------------------------------

#include <ctolerpc.h>
#pragma hdrstop


//
// NOTE!  There are seven functions called CopyString.  Collectively
//        they handle copying and converting strings composed of signed,
//        unsigned, and wide chars.  C++ polymorphism serves to distinguish
//        them from one another.
//
//        Three of the CopyString functions are implemented as inline
//        thunks defined in olestr.h
//

#ifndef WIN16

//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Convert a wide (Unicode) string to a multibyte string
//
//  Parameters: [pszSource]     -- The wide string
//              [ppszDest]      -- Where to put the multibyte string
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCWSTR pszSource, LPSTR *ppszDest)
{
    int     bufferSize;
    HRESULT hr = S_OK;

    *ppszDest = NULL;

    //
    // Find the length of the buffer needed for the multibyte string
    //

    bufferSize = WideCharToMultiByte(                        
                        CP_ACP,
                        0,
                        pszSource,
                        -1,
                        *ppszDest,
                        0,
                        NULL,
                        NULL);

    if (0 == bufferSize)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Allocate the buffer
    //

    if(S_OK == hr)
    {
        *ppszDest = new char[bufferSize];

        if (NULL == *ppszDest)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Do the conversion
    //

    if (S_OK == hr)
    {
        bufferSize = WideCharToMultiByte(
                                CP_ACP,
                                0,
                                pszSource,
                                -1,
                                *ppszDest,
                                bufferSize,
                                NULL,
                                NULL);

        if (0 == bufferSize)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //
    // Clean up if there's an error
    //

    if (S_OK != hr && NULL != *ppszDest)
    {
        delete [] *ppszDest;
        *ppszDest = NULL;
    }

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Convert a multibyte string to a wide (Unicode) string
//
//  Parameters: [pszSource]     -- The multibyte string
//              [ppszDest]      -- Where to put the wide string
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCSTR pszSource, LPWSTR *ppszDest)
{
    int     bufferSize;
    HRESULT hr = S_OK;

    *ppszDest = NULL;

    //
    // Find the length of the buffer needed for the multibyte string
    //

    bufferSize = MultiByteToWideChar(
                        CP_ACP,
                        0,
                        pszSource,
                        -1,
                        *ppszDest,
                        0);

    if (0 == bufferSize)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Allocate the buffer
    //

    if(S_OK == hr)
    {
        *ppszDest = new WCHAR[bufferSize];

        if (NULL == *ppszDest)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Do the conversion
    //

    if (S_OK == hr)
    {
        bufferSize = MultiByteToWideChar(
                            CP_ACP,
                            0,
                            pszSource,
                            -1,
                            *ppszDest,
                            bufferSize);

        if (0 == bufferSize)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //
    // Clean up if there's an error
    //

    if (S_OK != hr && NULL != *ppszDest)
    {
        delete [] *ppszDest;
        *ppszDest = NULL;
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Copy a wide (Unicode) string
//
//  Parameters: [pszSource]             -- The original string
//              [ppszDest]              -- The copy
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCWSTR pszSource, LPWSTR *ppszDest)
{
    int     bufferSize;
    HRESULT hr = S_OK;

    *ppszDest = NULL;

    // 
    // Find the length of the original string
    //

    bufferSize = wcslen(pszSource) + 1;

    //
    // Allocate the buffer
    //

    *ppszDest = new WCHAR[bufferSize];

    if (NULL == *ppszDest)
    {
        hr = E_OUTOFMEMORY;
    }

    //
    // Copy the string
    //

    if (S_OK == hr)
    {
        wcscpy(*ppszDest, pszSource);
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Convert a wide (Unicode) string to a multibyte string
//              cchSource can be -1 which means source is null terminated.
//
//  Parameters: [pszSource]     -- The wide string
//              [pszDest]       -- Where to put the multibyte string
//              [cchSource]     -- count of characters of source
//              [cchDest]       -- count of characters of destination
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCWSTR pszSource, LPSTR pszDest,
    int cchSource, int cchDest)
{
    int     bufferSize;
    HRESULT hr = S_OK;

    //
    // Find the length of the buffer needed for the multibyte string
    //

    bufferSize = WideCharToMultiByte(                        
                        CP_ACP,
                        0,
                        pszSource,
                        cchSource,
                        pszDest,
                        0,
                        NULL,
                        NULL);

    if (0 == bufferSize)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (bufferSize > cchDest)
    {
        hr = E_INVALIDARG;
    }

    //
    // Do the conversion
    //

    if (S_OK == hr)
    {
        bufferSize = WideCharToMultiByte(
                                CP_ACP,
                                0,
                                pszSource,
                                cchSource,
                                pszDest,
                                cchDest,
                                NULL,
                                NULL);

        if (0 == bufferSize)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Convert a multibyte string to a wide (Unicode) string
//              cchSource can be -1 which means source is null terminated.
//
//  Parameters: [pszSource]     -- The multibyte string
//              [pwszDest]      -- Where to put the wide string
//              [cchSource]     -- count of characters of source
//              [cchDest]       -- count of characters of destination
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCSTR pszSource, LPWSTR pwszDest,
        int cchSource, int cchDest)
{
    int     bufferSize;
    HRESULT hr = S_OK;

    //
    // Find the length of the buffer needed for the multibyte string
    //

    bufferSize = MultiByteToWideChar(
                        CP_ACP,
                        0,
                        pszSource,
                        cchSource,
                        pwszDest,
                        0);

    if (0 == bufferSize)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (bufferSize > cchDest)
    {
        hr = E_INVALIDARG;
    }

    //
    // Do the conversion
    //

    if (S_OK == hr)
    {
        bufferSize = MultiByteToWideChar(
                            CP_ACP,
                            0,
                            pszSource,
                            cchSource,
                            pwszDest,
                            cchDest);

        if (0 == bufferSize)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}


#endif


//+--------------------------------------------------------------------------
//
//  Function:   CopyString
//
//  Synopsis:   Copy a multibyte string
//
//  Parameters: [pszSource]             -- The original string
//              [ppszDest]              -- The copy
//
//  Returns:    S_OK if all went well
//
//  History:    31-Oct-96   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT CopyString(LPCSTR pszSource, LPSTR *ppszDest)
{
    int     bufferSize;
    HRESULT hr = S_OK;

    *ppszDest = NULL;

    // 
    // Find the length of the original string (in bytes for DBCS)
    //

    bufferSize = strlen(pszSource) + 1;

    //
    // Allocate the buffer
    //

    *ppszDest = new char[bufferSize];

    if (NULL == *ppszDest)
    {
        hr = E_OUTOFMEMORY;
    }

    //
    // Copy the string
    //

    if (S_OK == hr)
    {
        strcpy(*ppszDest, pszSource);
    }

    return hr;
}




//+----------------------------------------------------------------------------
//
//  -X-StringTo-Y-String functions
//
//  Synopsis:   Convert from a 'T' string to an Ole string
//
//  Parameters: [pszSource]     -- The T string
//              [ppszDest]      -- Where to put the Ole string
//
//  Returns:    S_OK if all went well
//
//  Notes:      The implementation of these functions are all identical.
//              C++ polymorphism serves to make sure the right version
//              of CopyString gets called.
//
//              If *ppszDest is non NULL when this function returns, the
//              caller is responsible for freeing the memory allocated at
//              [*ppszDest]
//
//              For the XStringToYString functions involving Ole types:
//              
//              If system and OLE use the same string type (e.g UNICODE on
//              NT; CHAR on MAC & Win16) , then this function allocates memory
//              for the new string and does a simple string copy.
//
//              If UNICODE is NOT defined, but OLE is unicode (as in Win95),
//              a CHAR to WCHAR conversion is performed.
//
//              If UNICODE is defined, but OLE is NOT unicode (not in any
//              system at present), a WCHAR to CHAR conversion is performed.
//
//-----------------------------------------------------------------------------

HRESULT TStringToOleString(LPCTSTR pszSource, LPOLESTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}


HRESULT OleStringToTString(LPCOLESTR pszSource, LPTSTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}


HRESULT AStringToOleString(LPCSTR pszSource, LPOLESTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}
HRESULT OleStringToAString(LPCOLESTR pszSource, LPSTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}

HRESULT AStringToTString(LPCSTR pszSource, LPTSTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}
HRESULT TStringToAString(LPCTSTR pszSource, LPSTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}

#ifndef WIN16

HRESULT WStringToOleString(LPCWSTR pszSource, LPOLESTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}
HRESULT OleStringToWString(LPCOLESTR pszSource, LPWSTR *ppszDest)
{
    if (NULL == pszSource)
    {
        *ppszDest = NULL;
        return S_OK;
    }
    else
    {
        return CopyString(pszSource, ppszDest);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\dbcs\test\main.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       main.cxx
//
//  Contents:   DBCS enabled OLE storage
//
//  History:	11/05/97    BogdanT    created
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include <dbcs.hxx>
#include <locale.h>

DH_DEFINE;

int __cdecl main(int argc, char *argv[])
{
    HRESULT hr          = S_OK;
    UINT nCount         = 0;
    LPTSTR ptszName    = NULL;
    LPWSTR pwszName    = NULL;
    LPSTORAGE  pIStg    = NULL;

    DH_FUNCENTRY(NULL, DH_LVL_TRACE1, _TEXT("main"));

    CDBCSStringGen dbcsgen;

    if(argc < 2)
    {
        printf("Usage: dbcstest <number of string>");
        exit(1);
    }

    dbcsgen.Init(0);

    for(nCount = atoi(argv[1]); nCount>0; nCount--)
    {
        hr = dbcsgen.GenerateRandomFileName(&ptszName);

        hr = TStrToWStr(ptszName, &pwszName);
        DH_HRCHECK(hr, TEXT("TStrToWStr")) ;        
        
        if(S_OK != hr)
            break;

        hr = StgCreateDocfile(pwszName, 
                              STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                              0,
                              &pIStg);

        DH_HRCHECK(hr, TEXT("StgCreateDocfile"));

        if(S_OK != hr)
            break;

        pIStg->Release();

        _tprintf(TEXT("%s\n"), ptszName);

        delete[] ptszName;
        delete[] pwszName;
    }

    return (int)hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\chancend.cxx ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  All rights reserved.
//
//  File:       chancend.cxx
//
//  Contents:   Implementation for ChanceNode objects.
//
//  Classes:    ChanceNode
//
//  Functions:  ChanceNode
//              ~ChanceNode
//              AppendChildStorage
//              AppendSisterStorage
//
//  History:    DeanE   12-Mar-96   Created
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug object declaration
//
DH_DECLARE;


//+--------------------------------------------------------------------------
//  Member:     ChanceNode::ChanceNode, public
//
//  Synopsis:   Constructor.  Initializes object with the values passed.
//
//  Arguments:  [cStg]     - Number of direct child storages of this node
//              [cStm]     - Number of streams to create in this node
//              [cbStmMin] - Minimum number of bytes/stream.
//              [cbStmMax] - Maximum number of bytes/stream.
//
//  Returns:    Nothing.
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------
ChanceNode::ChanceNode(
        ULONG cStg,
        ULONG cStm,
        ULONG cbStmMin,
        ULONG cbStmMax) : _pcnChild(NULL),
                          _pcnSister(NULL),
                          _pcnParent(NULL),
                          _cStorages(cStg),
                          _cStreams(cStm),
                          _cbMinStream(cbStmMin),
                          _cbMaxStream(cbStmMax)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceNode ctor"));

    DH_ASSERT(cbStmMin <= cbStmMax);
}


//+--------------------------------------------------------------------------
//  Member:     ChanceNode::~ChanceNode, public
//
//  Synopsis:   Destructor.  Deletes any children and sisters.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------
ChanceNode::~ChanceNode()
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceNode dtor"));

    delete _pcnChild;
    delete _pcnSister;
}


//+--------------------------------------------------------------------------
//  Member:     ChanceNode::AppendChildStorage, public
//
//  Synopsis:   Appends the node passed to the end of this nodes' child
//              node chain.
//
//  Arguments:  [pcnNew] - The new node to append.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------
HRESULT ChanceNode::AppendChildStorage(ChanceNode *pcnNew)
{
    ChanceNode *pcnTrav = this;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceNode::AppendChildStorage"));

    // Find the last child in the structure
    //
    while (NULL != pcnTrav->_pcnChild)
    {
        pcnTrav = pcnTrav->_pcnChild;
    }

    // Append the new node as a child of the last node,
    // increase the number of storages of the last node,
    // and make the new node point to the last node as it's parent
    //
    pcnTrav->_pcnChild = pcnNew;
    pcnTrav->_cStorages++;
    pcnNew->_pcnParent = pcnTrav;

    return(S_OK);
}


//+--------------------------------------------------------------------------
//  Member:     ChanceNode::AppendSisterStorage, public
//
//  Synopsis:   Appends the node passed to the end of this nodes' sister
//              node chain.
//
//  Arguments:  [pcnNew] - The new node to append.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------
HRESULT ChanceNode::AppendSisterStorage(ChanceNode *pcnNew)
{
    ChanceNode *pcnTrav = this;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceNode::AppendSisterStorage"));

    // Find the last sister of this node
    //
    while (NULL != pcnTrav->_pcnSister)
    {
        pcnTrav = pcnTrav->_pcnSister;
    }

    // Append the new node as a sister of the last node,
    // increase the number of storages of this nodes' parent,
    // and make the new node point to this nodes parent as it's parent
    //
    pcnTrav->_pcnSister = pcnNew;
    pcnTrav->_pcnParent->_cStorages++;
    pcnNew->_pcnParent = pcnTrav->_pcnParent;

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\dbcs\dbcs.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1995 - 1997.
//
//  File:       dbcs.cxx
//
//  Contents:   Contains DBCS string generator
//
//  History:    03-Nov-97       BogdanT     Created
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#include <dbcs.hxx>

DH_DECLARE;

//---------------------------------------------------------------------------
//
//  Method:     CDBCSStringGen::CDBCSStringGen
//
//  Synopsis:   Constructor
//
//  Parameters: none
//
//  History:    03-Nov-97       BogdanT     Created
//
//---------------------------------------------------------------------------
CDBCSStringGen::CDBCSStringGen()
{
#ifdef _MAC
    m_uCodePage     = 1252;
#else
    m_uCodePage     = GetACP();
#endif
    m_fSystemIsDBCS = TRUE;
    m_hDataFile     = NULL;
    m_ptszDataFile  = NULL;
    m_cFileNames    = 0;
    m_pdgi          = NULL;
}

//---------------------------------------------------------------------------
//
//  Method:     CDBCSStringGen::~CDBCSStringGen
//
//  Synopsis:   Destructor
//
//  Parameters: 
//
//  History:    03-Nov-97       BogdanT     Created
//
//---------------------------------------------------------------------------
CDBCSStringGen::~CDBCSStringGen()
{
    delete[] m_ptszDataFile;
    delete m_pdgi;
    if(NULL != m_hDataFile)
    {
        fclose(m_hDataFile);
    }
}

//---------------------------------------------------------------------------
//
//  Method:     CDBCSStringGen::Init
//
//  Synopsis:   Initialize the object
//
//  Parameters: [dwSeed]    -- used to seed the internal DG object
//
//  History:    03-Nov-97       BogdanT     Created
//
//---------------------------------------------------------------------------
HRESULT CDBCSStringGen::Init(DWORD dwSeed)
{
    HRESULT hr = S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("CDBCSStringGen::Init"));

    _tsetlocale(LC_ALL, TEXT("")); // set locale for RTL routine;
                                   // if we don't, console output won't work
                                   // with DBCS strings

    if(S_OK == hr)
    {
        m_pdgi = new DG_INTEGER(dwSeed);

        if(NULL == m_pdgi)
        {
            hr = E_OUTOFMEMORY;
            DH_HRCHECK(hr, TEXT("new DG_INTEGER"));
        }
    }

    if(S_OK == hr)
    {
        m_ptszDataFile = new TCHAR[_MAX_FNAME];

        if(NULL == m_ptszDataFile)
        {
            hr = E_OUTOFMEMORY;
            DH_HRCHECK(hr, TEXT("new TCHAR"));
        }
    }

    // check if system is DBCS and set the data file accordingly
    
    m_fSystemIsDBCS = TRUE;

    switch(m_uCodePage)
    {
        case CP_JPN:  _tcscpy(m_ptszDataFile, NAMEFILE_JPN);
                      DH_TRACE((DH_LVL_TRACE1, TEXT("DBCS Japan - ACP %d"), m_uCodePage));
                      break;

        case CP_CHS:  _tcscpy(m_ptszDataFile, NAMEFILE_CHS);
                      DH_TRACE((DH_LVL_TRACE1, TEXT("DBCS China - ACP %d"), m_uCodePage));
                      break;

        case CP_KOR:  _tcscpy(m_ptszDataFile, NAMEFILE_KOR);
                      DH_TRACE((DH_LVL_TRACE1, TEXT("DBCS Korea - ACP %d"), m_uCodePage));
                      break;

        case CP_CHT:  _tcscpy(m_ptszDataFile, NAMEFILE_CHT);
                      DH_TRACE((DH_LVL_TRACE1, TEXT("DBCS Taiwan/Hong Kong - ACP %d"), m_uCodePage));
                      break;

        default:      _tcscpy(m_ptszDataFile, TEXT(""));
                      DH_TRACE((DH_LVL_DFLIB, TEXT("SBCS - ACP %d"), m_uCodePage));
                      m_fSystemIsDBCS = FALSE;
                      break;
    }

    if(S_OK == hr)
    {
        if(m_fSystemIsDBCS)
        {
            DH_ASSERT(NULL!=m_ptszDataFile);
            m_hDataFile = _tfopen(m_ptszDataFile, TEXT("r"));

            if(NULL == m_hDataFile)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DH_HRCHECK(hr, TEXT("_tfopen"));
            }

            if(S_OK == hr)
            {
                m_cFileNames = CountNamesInFile();
            }
        }
    }

    return hr;
}

//---------------------------------------------------------------------------
//
//  Method:     CDBCSStringGen::CountNamesInFile
//
//  Synopsis:   Count number of filenames in data file
//
//  Parameters: none
//
//  History:    03-Nov-97       BogdanT     Created
//
//---------------------------------------------------------------------------
UINT CDBCSStringGen::CountNamesInFile()
{
    UINT cNames = 0;
    
    TCHAR lptszCrtLine[MAX_LINE_SIZE]; 

    if(FALSE == m_fSystemIsDBCS) // there is no data file if system is not DBCS
    {
        return 0;
    }

    DH_ASSERT(NULL != m_hDataFile);
    fseek(m_hDataFile, SEEK_SET, 0);

    // count all valid lines in the file

    while(_fgetts(lptszCrtLine, MAX_LINE_SIZE-1, m_hDataFile))
    {
        // we assume every line containing a filename starts with
        // a hex character
        // e.g. fc4b,8140,fc4b,2e,54,78,54
    
        if(_istxdigit(lptszCrtLine[0]))
        {
            cNames++;
        }
    }

    fseek(m_hDataFile, SEEK_SET, 0);

    return cNames;
}

//---------------------------------------------------------------------------
//
//  Method:     CDBCSStringGen::GenerateRandomFileName
//
//  Synopsis:   Generate a random filename from the current data file
//
//  Parameters: [pptszName] -- pointer to receive the generated name
//
//  History:    03-Nov-97       BogdanT     Created
//
//  Comments:   This function allocates space for the filename; the caller
//              is responsible for freeing the memory
//
//---------------------------------------------------------------------------
HRESULT CDBCSStringGen::GenerateRandomFileName(LPTSTR *pptszName)
{
    HRESULT hr          = S_OK;
    UINT uNameIndex     = 0xffff;
    LPSTR lpHex         = NULL;
    LPSTR lpName        = NULL;
    INT nStringLen      = 0;
    LPTSTR ptszDest     = NULL;

    CHAR szNameInHex[MAX_LINE_SIZE];
    CHAR szDBCSName[_MAX_FNAME];

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("CDBCSStringGen::GenerateRandomFileName"));

    DH_VDATEPTROUT(pptszName, LPTSTR*);

    if(0 == m_cFileNames)
    {
        return S_FALSE;
    }

    DH_ASSERT(NULL != m_pdgi);
    m_pdgi->Generate(&uNameIndex, 0, m_cFileNames-1);

    hr = GetFileNameFromFile(uNameIndex, szNameInHex);

    DH_HRCHECK(hr, TEXT("GetFileNameFromFile"));

    if(S_OK == hr)
    {
        // now convert ascii hex string
        // the strings look like this: fc4b,8140,fc4b,2e,54,78,54

        for(lpHex=szNameInHex, lpName = szDBCSName; *lpHex!='\0'; lpName++)
        {
            while(!isxdigit(*lpHex) && *lpHex!='\0')
            {
                lpHex++;
            }

            // bail if we reach the end
            if(*lpHex == '\0')
                break;
 
            *lpName = (CHAR)(16*Hex(*lpHex++));
            
            //
            // the only assumption we make is that the two hex digits that
            // represent each byte are not separated;
            //
            // you will get an assert in the next line if the file contains 
            // something like "1f,4 b"
            //                     ^-non hex digit here
            //
            DH_ASSERT(isxdigit(*lpHex));

            *lpName = (CHAR)(*lpName + (Hex(*lpHex++)));
        }

        *lpName = '\0';
    }

#ifdef UNICODE

    if(S_OK == hr)
    {
        // get the needed buffer size

        nStringLen = MultiByteToWideChar(
                   CP_ACP,
                   0,
                   szDBCSName,
                   -1,
                   NULL,
                   0) ;

        if(0 == nStringLen)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("MultiByteToWideChar"));
        }

    }

    if(S_OK == hr)
    {
        ptszDest = new WCHAR[nStringLen];

        if(NULL == ptszDest)
        {
            hr = E_OUTOFMEMORY;
            DH_HRCHECK(hr, TEXT("new WCHAR"));
        }
    }
    
    if(S_OK == hr)
    {
        if (nStringLen != MultiByteToWideChar(
                       CP_ACP,
                       0,
                       szDBCSName,
                       -1,
                       ptszDest,
                       nStringLen))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("MultiByteToWideChar"));
        }
    }

    if(S_OK == hr)
    {
        *pptszName = ptszDest;
    }
#else
    
    if(S_OK == hr)
    {
        nStringLen = strlen(szDBCSName);

        ptszDest = new CHAR[nStringLen+1];

        if(NULL == ptszDest)
        {
            hr = E_OUTOFMEMORY;
            DH_HRCHECK(hr, TEXT("new WCHAR"));
        }
    }

    if(S_OK == hr)
    {
        strcpy(ptszDest, szDBCSName);
    }

#endif //UNICODE

    if(S_OK == hr)
    {
        *pptszName = ptszDest;
    }
    
    DH_TRACE((DH_LVL_TRACE2, TEXT("GenerateRandomFileName: %s"), 
    (S_OK == hr)?*pptszName:TEXT("none")));

    return hr;
}

//---------------------------------------------------------------------------
//
//  Method:     CDBCSStringGen::GetFileNameFromFile
//
//  Synopsis:   Get a specific name from data file
//
//  Parameters: [nIndex] -- name to be retrieved
//              [lpDest] -- buffer to receive the string; must be big large
//                          enough
//
//  History:    03-Nov-97       BogdanT     Created
//
//
//---------------------------------------------------------------------------
HRESULT CDBCSStringGen::GetFileNameFromFile(UINT nIndex, LPSTR lpDest)
{
    HRESULT hr      = S_OK;
    UINT nCount     = 0;
    CHAR szBuf[MAX_LINE_SIZE];

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("CDBCSStringGen::GetFileNameFromFile"));

    DH_ASSERT(NULL != m_hDataFile);
    fseek(m_hDataFile, SEEK_SET, 0);

    DH_ASSERT(nIndex<m_cFileNames);

    do
    {
        if(!fgets(szBuf, MAX_LINE_SIZE-1, m_hDataFile))
        {
            hr = E_FAIL;
            DH_HRCHECK(hr, TEXT("fgets"));
            break;
        }

        if(isxdigit(szBuf[0]))  // ignore comments and other invalid lines
        {                       // the strings look like this: fc4b,8140,fc4b,2e,54
            nCount++;
        }
    }while(nCount<=nIndex);

    fseek(m_hDataFile, SEEK_SET, 0);

    if(S_OK == hr)
    {
        strcpy(lpDest, szBuf);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\chancedf.cxx ===
//-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  All rights reserved.
//
//  File:       chancedf.cxx
//
//  Contents:   Implementation for ChanceDF object.
//
//  Classes:    ChanceDF
//
//  Functions:  ChanceDF (public)
//              ~ChanceDF (public)
//              CreateFromParams (public)
//              CreateFromSize, multiple (public)
//              CreateFromFile (public)
//              Create (public)
//              GetSeed (public)
//              Generate (protected)
//              GenerateRoot (protected)
//              Init, multiple (public)
//              ParseRange(protected)
//              DeleteChanceDocFileTree (public)
//              GetModes (public)
//              AppendChildNode (protected)
//              AppendSisterNode (protected)
//              DeleteChanceDocFileSubTree (protected)
//              GetDocFileNameFromCmdline (private)
//              GetRandomChanceNode (protected)
//              GetDepthOfNode (private)
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Added more functions, enhanced.
//              BogdanT 30-Oct-96   Mac porting changes
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug object declaration

DH_DECLARE;

#define WSZ_DEF_VAL     OLESTR("none")

//--------------------------------------------------------------------------
//  Member:     ChanceDF::ChanceDF, public
//
//  Synopsis:   Constructor.  Initializes variables but real work is
//              done in ::Create*() methods.  This method cannot fail.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------

ChanceDF::ChanceDF() : _pdgi(NULL),
                       _pcnRoot(NULL),
                       _pcdfd(NULL),
                       _ptszName(NULL)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceDF ctor"));
}


//+--------------------------------------------------------------------------
//  Member:     ChanceDF::~ChanceDF, public
//
//  Synopsis:   Destructor.  Frees memory and releases objects.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------

ChanceDF::~ChanceDF()
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceDF dtor"));

    if(NULL != _pcdfd)
    {
        delete _pcdfd;
        _pcdfd = NULL;
    }

    if(NULL != _pdgi)
    {
        delete _pdgi;
        _pdgi = NULL;
    }

    if(NULL != _ptszName)
    {
        delete _ptszName;
        _ptszName = NULL;
    }

}

//--------------------------------------------------------------------------
//  Member:     ChanceDF::Init, public
//
//  Synopsis:   Initializes _pcdfd field in the ChanceDF object with default 
//              values
//
//  Arguments:  
//              
//
//  Returns:    HRESULT
//
//  History:    t-leonr   26-Jul-97   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT ChanceDF::Init()
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceDF::Init()"));

    if (NULL == _pcdfd)
    {
        _pcdfd = new CDFD;
        if (NULL == _pcdfd)
        {
            return(E_OUTOFMEMORY);
        }
    }
    _pcdfd->cDepthMin    = 0;
    _pcdfd->cDepthMax    = 2;
    _pcdfd->cStgMin      = 0;
    _pcdfd->cStgMax      = 3;
    _pcdfd->cStmMin      = 0;
    _pcdfd->cStmMax      = 5;
    _pcdfd->cbStmMin     = 0;
    _pcdfd->cbStmMax     = 5000;
    _pcdfd->ulSeed       = 0;
    _pcdfd->dwRootMode   = _pcdfd->dwStgMode = _pcdfd->dwStmMode =
                            STGM_READWRITE  |
                            STGM_DIRECT     |
                            STGM_SHARE_EXCLUSIVE; 
    return(S_OK);
}

//--------------------------------------------------------------------------
//  Member:     ChanceDF::Init, public
//
//  Synopsis:   Initializes the _pcdfd field in the ChanceDF object with the
//              values passed in the pcdfd.
//
//  Arguments:  pcdfd
//              
//
//  Returns:    HRESULT
//
//  History:    t-leonr   26-Jul-97   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT ChanceDF::Init(CDFD *pcdfd)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceDF::Init(pcdfd)"));

    if (NULL == _pcdfd)
    {
        _pcdfd = new CDFD;
        if (NULL == _pcdfd)
        {
            return(E_OUTOFMEMORY);
        }
    }
    memcpy(_pcdfd, pcdfd, sizeof(CDFD));
    return (S_OK);
}


//--------------------------------------------------------------------------
//  Member:     ChanceDF::CreateFromParams, public
//
//  Synopsis:   Creates the DocFile from the command line parameters.
//
//  Arguments:  [argc]
//              [argv]
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Enhanced
//              t-leonr 27-Jul-97   Add stuff about Init()
//
//  Notes:
//              Precedence of switches in the event of conflicts:
//              1) /dfsize:tiny, huge, etc
//              2) /dftemp:<template file name>
//              3) /dfdepth:min-max /dfstg:min-max /dfstm:min-max
//                 /dfstmlen:min-max
//              4) /dfRootMode:<mode> /dfStgMode:<mode> /dfStmMode:<mode>
//              5) /dfname:name for Root DocFile
//
//---------------------------------------------------------------------------

HRESULT ChanceDF::CreateFromParams(int argc, char **argv, LPTSTR ptName)
{
    HRESULT hr = E_FAIL;
    int     nErr;
    LPTSTR  ptszCmdSize     =   NULL;
    LPTSTR  ptszCmdDepth    =   NULL;
    LPTSTR  ptszCmdStg      =   NULL;
    LPTSTR  ptszCmdStm      =   NULL;
    LPTSTR  ptszCmdTemp     =   NULL;
    LPTSTR  ptszCmdStmLen   =   NULL;
    LPTSTR  ptszCmdName     =   NULL;
    LPTSTR  ptszCmdRootMode =   NULL;
    LPTSTR  ptszCmdStgMode  =   NULL;
    LPTSTR  ptszCmdStmMode  =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChanceDF::CreateFromParams"));

    if (NULL == _pcdfd)
    {
        hr = Init();
        DH_HRCHECK(hr, TEXT("ChanceDF::Init()"));
        if (FAILED(hr)) 
        {
            return hr;
        }
    }

    CBaseCmdlineObj  cmdOpenDF(OLESTR("Distrib"), OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdSize  (OLESTR("dfsize"),  OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdDepth (OLESTR("dfdepth"), OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdStg   (OLESTR("dfstg"),   OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdStm   (OLESTR("dfstm"),   OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdStmLen(OLESTR("dfstmlen"),OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdTemp  (OLESTR("dftemp"),  OLESTR(""), WSZ_DEF_VAL);
    CUlongCmdlineObj cmdSeed  (OLESTR("seed"),    OLESTR(""), _TEXTN("0"));
    CBaseCmdlineObj  cmdName  (OLESTR("dfname"),  OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdRootMode (OLESTR("dfRootMode"), OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdStgMode  (OLESTR("dfStgMode"),  OLESTR(""), WSZ_DEF_VAL);
    CBaseCmdlineObj  cmdStmMode  (OLESTR("dfStmMode"),  OLESTR(""), WSZ_DEF_VAL);

    CBaseCmdlineObj  *aAllArgs[] = {
                                       &cmdOpenDF,
                                       &cmdSize,
                                       &cmdDepth,
                                       &cmdStg,
                                       &cmdStm,
                                       &cmdStmLen,
                                       &cmdTemp,
                                       &cmdSeed,
                                       &cmdName,
                                       &cmdRootMode,
                                       &cmdStgMode,
                                       &cmdStmMode
                                   };

    CCmdline cmdline(argc, argv);

    nErr = cmdline.QueryError();
    if (CMDLINE_NO_ERROR != nErr)
    {
        DH_TRACE((DH_LVL_ERROR,_TEXT("CCmdline creation error = %d"),nErr));
        goto CleanUpExit;
    }

    // Parse the actual arguments
    //   ignore any extra parameters; last param==FALSE will
    //   do this
    //
    nErr = cmdline.Parse(aAllArgs,
                         sizeof(aAllArgs)/sizeof(CBaseCmdlineObj *),
                         FALSE);

    if (CMDLINE_NO_ERROR != nErr)
    {
        DH_TRACE((DH_LVL_ERROR,
                  _TEXT("Command line parsing error = %d"),
                  nErr));
        goto CleanUpExit;
    }


    // Initialize the seed value first - we'll always have a value
    // for this
    //
    if (0 != *cmdSeed.GetValue())
    {
        // only set seed from cmdline if it has not been put
        // into the cdfd earlier. (permits repro with new testdriver)
        if (0 == _pcdfd->ulSeed || -1 == _pcdfd->ulSeed)
        {
            _pcdfd->ulSeed = *cmdSeed.GetValue();
        }
    }

    // Next, hunt for arguments we actually got

    // Are we creating our docfile to test?
    _uOpenCreateDF = FL_DISTRIB_NONE;
    if (TRUE == cmdOpenDF.IsFound ())
    {
        LPTSTR ptszCmdOpen;
        //Convert OLECHAR to TCHAR
        hr = OleStringToTString (cmdOpenDF.GetValue (), &ptszCmdOpen);
        DH_HRCHECK (hr, TEXT("OleStringToTString"));
        
        if (S_OK == hr)
        {
            if (NULL == _tcsicmp (ptszCmdOpen, TEXT(SZ_DISTRIB_OPEN)) ||
                    NULL == _tcsicmp (ptszCmdOpen, TEXT(SZ_DISTRIB_OPENNODELETE)))
            {
                _uOpenCreateDF = FL_DISTRIB_OPEN;
            }
            else if (NULL == _tcsicmp (ptszCmdOpen, TEXT(SZ_DISTRIB_CREATE)))
            {
                _uOpenCreateDF = FL_DISTRIB_CREATE;
            }
        }
        delete ptszCmdOpen;
        ptszCmdOpen = 0;
    }

    // Initialize the mode values

    if(0 != olestrcmp(cmdRootMode.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdRootMode.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdRootMode.GetValue(), &ptszCmdRootMode);
        
            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
         
            if(S_OK == hr)
            { 
                hr = GetModes(&(_pcdfd->dwRootMode), ptszCmdRootMode);

                DH_HRCHECK(hr, TEXT("GetModes - dwRootMode")) ;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }

    if(0 != olestrcmp(cmdStgMode.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdStgMode.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdStgMode.GetValue(), &ptszCmdStgMode);
        
            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;

            if(S_OK == hr)
            {    
                hr = GetModes(&(_pcdfd->dwStgMode), ptszCmdStgMode);

                DH_HRCHECK(hr, TEXT("GetModes - dwStgMode")) ;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }

    if(0 != olestrcmp(cmdStmMode.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdStmMode.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdStmMode.GetValue(), &ptszCmdStmMode);
       
            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;

            if(S_OK == hr)
            {
                hr = GetModes(&(_pcdfd->dwStmMode), ptszCmdStmMode);

                DH_HRCHECK(hr, TEXT("GetModes - dwStmMode")) ;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }

    // Initialize the name value

    if(0 != olestrcmp(cmdName.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdName.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdName.GetValue(), &ptszCmdName);
            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }
    // if nothing on cmdline, put in what was given to us
    if (NULL != ptName && NULL == ptszCmdName)
    {
        ptszCmdName = new TCHAR[_tcslen (ptName) + 1];
        if (NULL != ptszCmdName)
        {
            _tcscpy (ptszCmdName, ptName);
        }
    }

    // Check if dfsize or dftemp given on command line - the call appropriate
    // functions

    if(0 != olestrcmp(cmdSize.GetValue(), WSZ_DEF_VAL)) 
    {
        if(NULL != *cmdSize.GetValue())
        {
            hr = OleStringToTString(cmdSize.GetValue(), &ptszCmdSize);
       
            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;

            if(S_OK == hr)
            { 
                hr = CreateFromSize(
                            ptszCmdSize, 
                            _pcdfd->ulSeed,
                            _pcdfd->dwRootMode,   // non existing values 
                            _pcdfd->dwStgMode,   // for seed and modes
                            _pcdfd->dwStmMode,
                            ptszCmdName);

                goto CleanUpExit;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }
    else
    if(0 != olestrcmp(cmdTemp.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdTemp.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdTemp.GetValue(), &ptszCmdTemp);

            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;

            if(S_OK == hr)
            {    
                hr = CreateFromFile(ptszCmdTemp, _pcdfd->ulSeed);

                goto CleanUpExit;
            }
        }

        if (FAILED(hr))
        {
           goto CleanUpExit;
        }
    }

    // If a size or template file were not specified, we'll need to
    // hunt for specific values on the command line, using defaults
    // for any we don't get
    //

    if(0 != olestrcmp(cmdDepth.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdDepth.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdDepth.GetValue(), &ptszCmdDepth);
        
            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;

            if(S_OK == hr)
            {
                hr = ParseRange(ptszCmdDepth, &(_pcdfd->cDepthMin), &(_pcdfd->cDepthMax));

                DH_HRCHECK(hr, TEXT("ParseRange - cmdDepth")) ;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }

    if(0 != olestrcmp(cmdStg.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdStg.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdStg.GetValue(), &ptszCmdStg);
    
            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;
   
            if(S_OK == hr)
            { 
                hr = ParseRange(ptszCmdStg, &(_pcdfd->cStgMin), &(_pcdfd->cStgMax));

                DH_HRCHECK(hr, TEXT("ParseRange - cmdStg")) ;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }

    if(0 != olestrcmp(cmdStm.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdStm.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdStm.GetValue(), &ptszCmdStm);
    
            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;
   
            if(S_OK == hr)
            { 
                hr = ParseRange(ptszCmdStm, &(_pcdfd->cStmMin), &(_pcdfd->cStmMax));

                DH_HRCHECK(hr, TEXT("ParseRange - cmdStm")) ;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }
            
    if(0 != olestrcmp(cmdStmLen.GetValue(), WSZ_DEF_VAL))
    {
        if(NULL != *cmdStmLen.GetValue())
        {
            //Convert OLECHAR to TCHAR
            hr = OleStringToTString(cmdStmLen.GetValue(), &ptszCmdStmLen);
        
            DH_HRCHECK(hr, TEXT("WStrToTStr")) ;
   
            if(S_OK == hr)
            { 
                hr = ParseRange(ptszCmdStmLen, &(_pcdfd->cbStmMin), &(_pcdfd->cbStmMax));

                DH_HRCHECK(hr, TEXT("ParseRange - cmdStmLen")) ;
            }
        }

        if (FAILED(hr))
        {
            goto CleanUpExit;
        }
    }

    hr = Create(NULL, ptszCmdName);

    DH_HRCHECK(hr, TEXT("Create")) ;

CleanUpExit:

    // Clean up

    if(NULL != ptszCmdSize)
    {
        delete ptszCmdSize;
        ptszCmdSize =NULL;
    }

    if(NULL != ptszCmdDepth)
    {
        delete ptszCmdDepth;
        ptszCmdDepth =NULL;
    }

    if(NULL != ptszCmdStg)
    {
        delete ptszCmdStg;
        ptszCmdStg =NULL;
    }

    if(NULL != ptszCmdStm)
    {
        delete ptszCmdStm;
        ptszCmdStm =NULL;
    }
   
    if(NULL != ptszCmdStmLen)
    {
        delete ptszCmdStmLen;
        ptszCmdStmLen =NULL;
    }
   
    if(NULL != ptszCmdName)
    {
        delete ptszCmdName;
        ptszCmdName =NULL;
    }
   
    if(NULL != ptszCmdRootMode)
    {
        delete ptszCmdRootMode;
        ptszCmdRootMode =NULL;
    }
   
    if(NULL != ptszCmdStgMode)
    {
        delete ptszCmdStgMode;
        ptszCmdStgMode =NULL;
    }
   
    if(NULL != ptszCmdStmMode)
    {
        delete ptszCmdStmMode;
        ptszCmdStmMode =NULL;
    }
   
    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::CreateFromSize, public
//
//  Synopsis:   Creates the DocFile from size option
//
//  Arguments:  [tszSize] - Size of DocFile.  Must be given. 
//              [ulSeed] - Seed value.
//              [dwRootMode] - Mode for Root Storage. 
//              [dwStgMode] - Mode for IStorage(s).  
//              [dwStmMode] - Mode for IStream(s).  
//              [ptszDocName] - Name of DocFile.  
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 2-July-96   Enhanced
//
//  Notes:      If the value for dwRootMode/dwStgMode/dwStmMode are not given
//              i.e. zero, then default values for the modes would be used.
//              If ptszDocName is NULL, then a random name is chosen for Doc
//              File in VirtualDF creation.
//---------------------------------------------------------------------------

HRESULT ChanceDF::CreateFromSize(
    LPCTSTR     tszSize, 
    ULONG       ulSeed,
    DWORD       dwRootMode,
    DWORD       dwStgMode,
    DWORD       dwStmMode,
    LPTSTR      ptszDocName)
{
    DFSIZE dfs = DF_ERROR;

    DH_FUNCENTRY(NULL,
                 DH_LVL_DFLIB,
                 _TEXT("ChanceDF::CreateFromSize - string"));

    DH_ASSERT(NULL != tszSize);

    if (0 == _tcsicmp(tszSize, TSZ_DFSIZE_TINY))
    {
        dfs = DF_TINY;
    }
    else
    if (0 == _tcsicmp(tszSize, TSZ_DFSIZE_SMALL))
    {
        dfs = DF_SMALL;
    }
    else
    if (0 == _tcsicmp(tszSize, TSZ_DFSIZE_MEDIUM))
    {
        dfs = DF_MEDIUM;
    }
    else
    if (0 == _tcsicmp(tszSize, TSZ_DFSIZE_LARGE))
    {
        dfs = DF_LARGE;
    }
    else
    if (0 == _tcsicmp(tszSize, TSZ_DFSIZE_HUGE))
    {
        dfs = DF_HUGE;
    }
    else
    if (0 == _tcsicmp(tszSize, TSZ_DFSIZE_DIF))
    {
        dfs = DF_DIF;
    }

    if (DF_ERROR == dfs)
    {
        return(E_FAIL);
    }

    return(CreateFromSize(
            dfs, 
            ulSeed, 
            dwRootMode, 
            dwStgMode, 
            dwStmMode, 
            ptszDocName));
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::CreateFromSize, public
//
//  Synopsis:   Creates DocFile from size option.
//
//  Arguments:  [dfs]  - DocFile size. 
//              [ulSeed] - Seed value.
//              [dwRootMode] - Mode for Root Storage. 
//              [dwStgMode] - Mode for IStorage(s).  
//              [dwStmMode] - Mode for IStream(s).  
//              [ptszDocName] - Name of DocFile.  
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Enhanced
//              t-leonr 27-Jul-97   Add stuff about Init(), use _pcdfd
//
//  Notes:      If the value for dwRootMode/dwStgMode/dwStmMode are not given
//              i.e. zero, then default values for the modes would be used.
//              If ptszDocName is NULL, then a random name is chosen for Doc
//              File in VirtualDF creation.
//---------------------------------------------------------------------------

HRESULT ChanceDF::CreateFromSize(
    DFSIZE      dfs, 
    ULONG       ulSeed,
    DWORD       dwRootMode,
    DWORD       dwStgMode,
    DWORD       dwStmMode,
    LPTSTR      ptszDocName)
{
    HRESULT hr = S_OK;

    DH_FUNCENTRY(&hr,
                 DH_LVL_DFLIB,
                 _TEXT("ChanceDF::CreateFromSize - dfs"));

    if (NULL == _pcdfd)
    {
        hr = Init();
        DH_HRCHECK(hr, TEXT("ChanceDF::Init()"));
        if (FAILED(hr)) 
        {
            return hr;
        }
    }

    _pcdfd->ulSeed = ulSeed;

    if(0 == dwRootMode)
    {
        _pcdfd->dwRootMode = STGM_READWRITE  |
                             STGM_DIRECT     |
                             STGM_SHARE_EXCLUSIVE;
    }
    else
    {
        _pcdfd->dwRootMode = dwRootMode;
    }

    if(0 == dwStgMode)
    {
        _pcdfd->dwStgMode = STGM_READWRITE  |
                            STGM_DIRECT     |
                            STGM_SHARE_EXCLUSIVE;
    }
    else
    {
        _pcdfd->dwStgMode = dwStgMode;
    }

    if(0 == dwStmMode)
    {
        _pcdfd->dwStmMode = STGM_READWRITE  |
                            STGM_DIRECT     |
                            STGM_SHARE_EXCLUSIVE;
    }
    else
    {
        _pcdfd->dwStmMode = dwStmMode;
    }

    switch (dfs)
    {
    case DF_TINY:
        _pcdfd->cDepthMin = 0;
        _pcdfd->cDepthMax = 0;
        _pcdfd->cStgMin   = 0;
        _pcdfd->cStgMax   = 0;
        _pcdfd->cStmMin   = 0;
        _pcdfd->cStmMax   = 3;
        _pcdfd->cbStmMin  = 0;
        _pcdfd->cbStmMax  = 100;
        break;

    case DF_SMALL:
        _pcdfd->cDepthMin = 0;
        _pcdfd->cDepthMax = 1;
        _pcdfd->cStgMin   = 0;
        _pcdfd->cStgMax   = 1;
        _pcdfd->cStmMin   = 0;
        _pcdfd->cStmMax   = 5;
        _pcdfd->cbStmMin  = 0;
        _pcdfd->cbStmMax  = 4000;
        break;

    case DF_MEDIUM:
        _pcdfd->cDepthMin = 1;
        _pcdfd->cDepthMax = 3;
        _pcdfd->cStgMin   = 1;
        _pcdfd->cStgMax   = 4;
        _pcdfd->cStmMin   = 1;
        _pcdfd->cStmMax   = 6;
        _pcdfd->cbStmMin  = 0;
        _pcdfd->cbStmMax  = 10240;
        break;

    case DF_LARGE:
        _pcdfd->cDepthMin = 2;
        _pcdfd->cDepthMax = 5;
        _pcdfd->cStgMin   = 2;
        _pcdfd->cStgMax   = 10;
        _pcdfd->cStmMin   = 0;
        _pcdfd->cStmMax   = 8;
        _pcdfd->cbStmMin  = 0;
        _pcdfd->cbStmMax  = 20480;
        break;

    case DF_HUGE:
        _pcdfd->cDepthMin = 5;
        _pcdfd->cDepthMax = 10;
        _pcdfd->cStgMin   = 5;
        _pcdfd->cStgMax   = 30;
        _pcdfd->cStmMin   = 0;
        _pcdfd->cStmMax   = 10;
        _pcdfd->cbStmMin  = 0;
        _pcdfd->cbStmMax  = 40000;
        break;

    case DF_DIF:
        _pcdfd->cDepthMin = 5;
        _pcdfd->cDepthMax = 10;
        _pcdfd->cStgMin   = 7;
        _pcdfd->cStgMax   = 10;
        _pcdfd->cStmMin   = 10;
        _pcdfd->cStmMax   = 15;
        _pcdfd->cbStmMin  = 100000;
        _pcdfd->cbStmMax  = 150000;
        break;

    case DF_ERROR:  // Fall through to error condition
    default:
        hr = E_FAIL;
        break;
    }

    if (SUCCEEDED(hr))
    {
        hr = Create(NULL, ptszDocName);

        DH_HRCHECK(hr, TEXT("Create")) ;
    }

    return(hr);
}


//+--------------------------------------------------------------------------
//  Member:     ChanceDF::CreateFromFile, public
//
//  Synopsis:   Creates DocFile through a given ini file.
//
//  Arguments:  [tszIni]
//              [ulSeed]
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------

HRESULT ChanceDF::CreateFromFile(
    LPCTSTR     /* UNREF tszIni */,
    ULONG       /* UNREF ulSeed */)
{
    DH_FUNCENTRY(NULL,
                 DH_LVL_DFLIB,
                 _TEXT("ChanceDF::CreateFromFile - NYI!"));


    DH_ASSERT(!_TEXT("::CreateFromFile NYI!"));

    return(E_FAIL);
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::Create, public
//
//  Synopsis:   Creates the ChanceDocFile tree.
//
//  Arguments:  [pcdfd] - pointer to CDFD structure.
//              [ptszDocName] - Name for DocFile.  May be NULL.
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              t-leonr 27-Jul-97   Add stuff about Init()
//
//  Notes:  Destructor will clean up a partially-created object so we
//          don't have to do a bunch of cleanup as we go
//
//          If ptszDocName is NULL, then a random name is chosen for Doc
//          File in VirtualDF creation.
//---------------------------------------------------------------------------

HRESULT ChanceDF::Create(CDFD *pcdfd, LPTSTR ptszDocName)
{
    HRESULT hr = S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChanceDF::Create"));

    if (NULL != pcdfd)
    {
        hr = Init(pcdfd);
        DH_HRCHECK(hr, TEXT("ChanceDF::Init(pcdfd)"));
    }
    else if (NULL == _pcdfd)
    {
        hr = Init();
        DH_HRCHECK(hr, TEXT("ChanceDF::Init()"));
    }
    if (FAILED(hr))
    {
        return hr;
    }
    
    // Create a DataGen object that will allow us to fill the count
    // parameters of all the ChanceDF components
    //
    _pdgi = new DG_INTEGER(_pcdfd->ulSeed);
    if (NULL == _pdgi)
    {
        return(E_OUTOFMEMORY);
    }


    // Store the actual seed value we used to create this tree - we'll
    // need it to initialize other DG objects later
    //
    _pdgi->GetSeed(&_pcdfd->ulSeed);

    // Report the Seed value so this structure can be recreated
    DH_LOG((LOG_INFO, _TEXT("ChanceDF::Create - Seed=%lu"), _pcdfd->ulSeed));


    // Finally, we must generate the ChanceDF tree
    hr = Generate();

    DH_HRCHECK(hr, TEXT("Generate")) ;

    //Store the name of docfile, if provided by user.
    if((S_OK == hr) && (NULL != ptszDocName))
    {
       hr = GetDocFileNameFromCmdline(ptszDocName);

       DH_HRCHECK(hr, TEXT("GetDocFileNameFromCmdline")) ;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::ParseRange, public
//
//  Synopsis:   Parses the range given from command line for different params.
//
//  Arguments:  [tszSwitch]
//              [pulMin]
//              [pulMax]
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Enhanced
//
//  Notes:      tszSwitch is of the format '/switch:min-max
//---------------------------------------------------------------------------

HRESULT ChanceDF::ParseRange(LPCTSTR tszSwitch, ULONG *pulMin, ULONG *pulMax)
{
    HRESULT     hr      = E_FAIL;
    LPCTSTR     ptszMin = tszSwitch;
    LPCTSTR     ptszMax = tszSwitch;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChanceDF::ParseRange"));
    DH_ASSERT(NULL != tszSwitch);
    DH_ASSERT(NULL != pulMin);
    DH_ASSERT(NULL != pulMax);

    // Advance the maximum pointer past the dash delimeter after
    // the minimum value
    //
    ptszMax = ptszMin;
    while ((*ptszMax != L'\0') && (*ptszMax++ != L'-'))
    {
        ;
    }

    // If neither of our pointers is pointing at the null
    // terminator, we can safely get the values
    //
    if ((L'\0' != *ptszMin) && (L'\0' != *ptszMax))
    {
        *pulMin = _ttol(ptszMin);
        *pulMax = _ttol(ptszMax);

        if (*pulMin <= *pulMax)
        {
            hr = S_OK;
        }
    }

    return (hr);
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::Generate, protected
//
//  Synopsis:   Generates the ChanceDocFile tree consisting of ChanceNodes.
//
//  Arguments:  void
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Enhanced
//  Notes:
//              Check the creation parameters
//              Generate the first child node at each level
//              Choose children nodes randomly to create additional siblings,
//              or children, if necessary. In growing the chance docfile tree, 
//              take care not to make sister of root node and do not increase 
//              depth of the tree by making child of nodes at max depth.
//
//              Called privately by public creation methods
//
//---------------------------------------------------------------------------

HRESULT ChanceDF::Generate()
{
    HRESULT      hr            = E_FAIL;
    ULONG        cDepth        = 0;
    ULONG        cRemStg       = 0;
    USHORT       usErr         = 0;
    ChanceNode **apcnFirstBorn = NULL;
    ChanceNode  *pcnRemStg     = NULL;
    ULONG        ulLoop;
    ChanceNode  *pcnOldNode    = NULL;
    UINT         cTypeNode     = 0;
    ULONG        cNumOfNodes   = 0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChanceDF::Generate"));

    // Sanity check parameters
    //   minimums for each category must be <= maximums
    //   must have at least as many storages as the minimum depth
    //   must have at least as many storages as the maximum depth
    //
    if ((_pcdfd->cDepthMin > _pcdfd->cDepthMax) ||
        (_pcdfd->cStgMin   > _pcdfd->cStgMax)   ||
        (_pcdfd->cStmMin   > _pcdfd->cStmMax)   ||
        (_pcdfd->cbStmMin  > _pcdfd->cbStmMax)  ||
        (_pcdfd->cDepthMin > _pcdfd->cStgMin)   ||
        (_pcdfd->cDepthMax > _pcdfd->cStgMax))
    {
        goto ErrExit;
    }

    // Determine the exact depth of the docfile
    //

    usErr = _pdgi->Generate(&cDepth, _pcdfd->cDepthMin, _pcdfd->cDepthMax);
    if (DG_RC_SUCCESS != usErr)
    {
        hr = E_FAIL;
        goto ErrExit;
    }

    // Adjust minimum and maximum number of storages to create down
    // by the number that would be created by cDepth.
    //

    _pcdfd->cStgMin = max(0, (LONG)(_pcdfd->cStgMin-cDepth));
    _pcdfd->cStgMax = max(0, (LONG)(_pcdfd->cStgMax-cDepth));

    // Calculate the number of extra storages to create
    //

    usErr = _pdgi->Generate(&cRemStg, _pcdfd->cStgMin, _pcdfd->cStgMax);
    if (DG_RC_SUCCESS != usErr)
    {
        hr = E_FAIL;
        goto ErrExit;
    }

    // Check if cDepth is zero, but cRemStg is >0, then make cDepth atleast 1,
    // becoz' we wouldn't have siblings of root.

    cDepth = ((cDepth == 0 && cRemStg > 0) ? 1 : cDepth);

    // Allocate a table of pointers to the first children at each
    // level
    //
    apcnFirstBorn = new ChanceNode*[cDepth+1];
    if (NULL == apcnFirstBorn)
    {
        hr = E_OUTOFMEMORY;
        goto ErrExit;
    }


    // Create root node - if this succeeds, we point our root
    // to it and if any subsequent errors occur while building the
    // rest of the tree the destructor will clean it up
    //
    hr = GenerateRoot();

    DH_HRCHECK(hr, TEXT("GenerateRoot")) ;

    if (FAILED(hr))
    {
        goto ErrExit;
    }
    apcnFirstBorn[0] = _pcnRoot;


    // Create levels of children nodes
    //
    hr = S_OK;
    ulLoop = 1;
    while ((ulLoop<=cDepth) && SUCCEEDED(hr))
    {
        hr = AppendChildNode(&apcnFirstBorn[ulLoop], apcnFirstBorn[ulLoop-1]);

        DH_HRCHECK(hr, TEXT("AppendChildNode")) ;

        ulLoop++;
    }

    if (FAILED(hr))
    {
        goto ErrExit;
    }

    // Now, fill in any remaining storage nodes that we need to
    //

    cNumOfNodes = ulLoop;
    ulLoop = 0;

    while ((ulLoop<cRemStg) && SUCCEEDED(hr))
    {
        usErr = _pdgi->Generate(&cTypeNode, SISTERNODE, CHILDNODE);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }

        if(S_OK == hr)
        {
            hr = GetRandomChanceNode(cNumOfNodes, &pcnOldNode);

            DH_HRCHECK(hr, TEXT("FindRandomChanceNode")) ;
        }

        if (SUCCEEDED(hr))
        {
            // In growing the chance docfile tree, take care not to make
            // sister of root node and do not increase max depth of the tree
            // by making child of nodes at max depth.

            if((SISTERNODE == cTypeNode) && (_pcnRoot != pcnOldNode)) 
            {
                hr = AppendSisterNode(&pcnRemStg, pcnOldNode);

                DH_HRCHECK(hr, TEXT("AppendSisterNode")) ;
            }
            else 
            {
                // Both conditons CHILDNODE == cTypeNode and
                // ((SISTERNODE == cTypeNode) && (_pcnRoot == pcnOldNode))
                // handled here
        
                if(NULL == pcnOldNode->_pcnChild) 
                {
                    if(GetDepthOfNode(pcnOldNode) < cDepth)
                    {
                        hr = AppendChildNode(&pcnRemStg, pcnOldNode);
                    
                        DH_HRCHECK(hr, TEXT("AppendChildNode")) ;
                    }
                    else
                    {
                        hr = AppendSisterNode(&pcnRemStg, pcnOldNode);

                        DH_HRCHECK(hr, TEXT("AppendSisterNode")) ;
                    }
                }
                else
                {
                    hr = AppendSisterNode(&pcnRemStg,pcnOldNode->_pcnChild);

                    DH_HRCHECK(hr, TEXT("AppendSisterNode")) ;
                }
            }
        }

        ulLoop++;   
        cNumOfNodes++;
    }


ErrExit:
    // All nodes are saved in the tree itself pointed to by _pcnRoot, and
    // we can safely delete this temporary scaffolding
    //
    delete []apcnFirstBorn;

    return(hr);
}


//+--------------------------------------------------------------------------
//  Member:     ChanceDF::GenerateRoot, protected
//
//  Synopsis:   Generates the root of ChanceDocFile tree.
//
//  Arguments:  void
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Enhanced
//---------------------------------------------------------------------------

HRESULT ChanceDF::GenerateRoot()
{
    USHORT usErr;
    ULONG  cStreams;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("GenerateRoot"));

    // Generate the number of streams the root will have
    usErr = _pdgi->Generate(&cStreams, _pcdfd->cStmMin, _pcdfd->cStmMax);
    if (DG_RC_SUCCESS != usErr)
    {
        return(E_FAIL);
    }

    _pcnRoot = new ChanceNode(0, cStreams, _pcdfd->cbStmMin, _pcdfd->cbStmMax);
    if (NULL == _pcnRoot)
    {
        return(E_OUTOFMEMORY);
    }

    return(S_OK);
}


//+--------------------------------------------------------------------------
//  Member:     ChanceDF::AppendChildNode, protected
//
//  Synopsis:   Appends the Child node to parent.
//
//  Arguments:  [ppcnNew]
//              [pcnParent]
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Enhanced
//
//  Notes:      Attach new node as a child of the parent node at the end of the
//              end of parents child chain.  If the parent is NULL, do nothing
//              with this node.
//
//---------------------------------------------------------------------------

HRESULT ChanceDF::AppendChildNode(ChanceNode **ppcnNew, ChanceNode *pcnParent)
{
    HRESULT hr      =   E_FAIL;
    ULONG   cStreams=   0;
    USHORT  usErr   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("AppendChildNode"));

    DH_ASSERT(NULL != pcnParent)
    DH_ASSERT(NULL != ppcnNew);

    *ppcnNew = NULL;

    // Determine number of streams to create
    usErr = _pdgi->Generate(&cStreams, _pcdfd->cStmMin, _pcdfd->cStmMax);
    if (DG_RC_SUCCESS != usErr)
    {
        hr = E_FAIL;
        goto ErrExit;
    }


    // Allocate and initialize the new node
    *ppcnNew = new ChanceNode(0, cStreams, _pcdfd->cbStmMin, _pcdfd->cbStmMax);
    if (NULL == *ppcnNew)
    {
        hr = E_OUTOFMEMORY;
        goto ErrExit;
    }


    // Append the new node to the list of sisters in the parent
    //
    hr = pcnParent->AppendChildStorage(*ppcnNew);

    DH_HRCHECK(hr, TEXT("AppendChildStorage")) ;

ErrExit:
    if (FAILED(hr))
    {
        delete *ppcnNew;
        *ppcnNew = NULL;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::AppendSisterNode, protected
//
//  Synopsis:   Appends the new node as sister of ChanceNode.
//
//  Arguments:  [ppcnNew]
//              [pcnSister]
//
//  Returns:    HRESULT
//
//  History:    DeanE   12-Mar-96   Created
//              Narindk 20-Apr-96   Enhanced
//---------------------------------------------------------------------------

HRESULT ChanceDF::AppendSisterNode(
        ChanceNode **ppcnNew,
        ChanceNode  *pcnSister)
{
    HRESULT hr      =   E_FAIL;
    ULONG   cStreams=   0;
    USHORT  usErr   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("AppendSisterNode"));

    DH_ASSERT(NULL != pcnSister)
    DH_ASSERT(NULL != ppcnNew);

    *ppcnNew = NULL;

    // Determine number of streams to create
    usErr = _pdgi->Generate(&cStreams, _pcdfd->cStmMin, _pcdfd->cStmMax);
    if (DG_RC_SUCCESS != usErr)
    {
        hr = E_FAIL;
        goto ErrExit;
    }


    // Allocate and initialize the new node
    *ppcnNew = new ChanceNode(0, cStreams, _pcdfd->cbStmMin, _pcdfd->cbStmMax);
    if (NULL == *ppcnNew)
    {
        hr = E_OUTOFMEMORY;
        goto ErrExit;
    }


    // Append the new node to the list of sisters in the parent
    //
    hr = pcnSister->AppendSisterStorage(*ppcnNew);

    DH_HRCHECK(hr, TEXT("AppendSisterStorage")) ;

ErrExit:
    if (FAILED(hr))
    {
        delete *ppcnNew;
        *ppcnNew = NULL;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::GetSeed, public
//
//  Synopsis:   Returns the seed value
//
//  Arguments:  void
//
//  Returns:    ULONG
//
//  History:    DeanE   12-Mar-96   Created
//---------------------------------------------------------------------------

ULONG ChanceDF::GetSeed()
{
    ULONG ulSeed = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("GetSeed"));

    if (NULL != _pdgi)
    {
        _pdgi->GetSeed(&ulSeed);
    }

    return(ulSeed);
}

//+--------------------------------------------------------------------------
//  Member:     ChanceDF::DeleteChanceDocFileTree, public
//
//  Synopsis:   Deletes the ChanceDocFile tree
//
//  Arguments:  [pcnTrav] - Pointer to ChanceNode
//
//  Returns:    HRESULT
//
//  History:    Narindk 24-Apr-96   Created
//
//  Notes:      First step is to check if the whole tree needs to be deleted or
//              just a part of it.  In case only a part of tree is to be
//              deleted, isolate the node from the remaining tree by readjusting
//              the pointers in the remaining tree.  Then call the function
//              DeleteChanceDocFileSubTree to delete the subtree.  In case,
//              the complete tree needs to be deleted, we call the function
//              DeleteChanceDocFileSubTree directly to delete the complete
//              tree.
//---------------------------------------------------------------------------

HRESULT ChanceDF::DeleteChanceDocFileTree(ChanceNode *pcnTrav)
{
    HRESULT hr              =   S_OK;
    ChanceNode *pTempNode   =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("DeleteChanceDocFileTree"));

    DH_VDATEPTRIN(pcnTrav, ChanceNode);
    DH_ASSERT(NULL != pcnTrav);

    if(S_OK == hr)
    {
        // This basically readjusts the tree, in case some other node except
        // for root of ChanceDocFile tree is passed, so only a part of tree is
        // getting deleted.

        if(NULL != pcnTrav->_pcnParent)
        {
           // Find its previous node whose pointers would need readjustment.

           pTempNode = pcnTrav->_pcnParent->_pcnChild;

           while ((pcnTrav != pcnTrav->_pcnParent->_pcnChild) &&
                  (pcnTrav != pTempNode->_pcnSister))
           {
                pTempNode = pTempNode->_pcnSister;
                DH_ASSERT(NULL != pTempNode);
           }

           // Readjust the child pointer or sister pointer as the case may be.

           pcnTrav->_pcnParent->_pcnChild = (pcnTrav == pTempNode) ?
                pcnTrav->_pcnSister : pcnTrav->_pcnParent->_pcnChild;
           pTempNode->_pcnSister = pcnTrav->_pcnSister;
        }
    }

    if(S_OK == hr)
    {
        // Call the function to delete the tree now.

        hr = DeleteChanceDocFileSubTree(&pcnTrav);

        DH_HRCHECK(hr, TEXT("DeleteChanceDocFileSubTree")) ;
    }

    return hr;
}

//--------------------------------------------------------------------------
//  Member:     ChanceDF::DeleteChanceDocFileSubTree, protected
//
//  Synopsis:   Does the real work of deletion of ChanceNodes in the tree.
//
//  Arguments:  [ppcnTrav] - Pointer to pointer to ChanceNode
//
//  Returns:    HRESULT
//
//  History:    Narindk 24-Apr-96   Created
//
//  Notes:      This function is called only through DeleteChanceDocFileTree.
//
//              Assign the passed in ChanceNode to a variable pTempRoot.
//              NULL the pTempRoot's parent.
//              Loop till the pTempRoot is not NULL to delete tree ieratively.
//                  - Assign pTempRoot to a temp variable pTempNode.
//                  - Traverse the tree to make pTempNode point to last child
//                    (_pcnChild).
//                  - Assign pTempNode's _pcnParent to pTempRoot
//                  - Assign the pTempRoot's _pcnChild pointer to point to the
//                    sister of pTempNode's _pcnSister rather than to itself,
//                    therby isolating itself.
//                  - Decrement the _cStorages of pTempRoot (used to verify).
//                  - Assign pTempNode's _pcnSister to NULL.
//                  - Assert to ensure the pTempNode's _cStorages is zero
//                    before deleting it.
//                  - Delete pTempNode.
//                  - Go back to top of loop and repeat till all nodes are
//                    deleted.
//---------------------------------------------------------------------------

HRESULT ChanceDF::DeleteChanceDocFileSubTree(ChanceNode **ppcnTrav)
{
    HRESULT     hr          =   S_OK;
    ChanceNode *pTempRoot   =   NULL;
    ChanceNode *pTempNode   =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("DeleteChanceDocFileSubTree"));

    DH_VDATEPTRIN(ppcnTrav, PCHANCENODE);
    DH_ASSERT(NULL != *ppcnTrav);

    if(S_OK == hr)
    {
        pTempRoot = *ppcnTrav;

        pTempRoot->_pcnParent = NULL;

        // Code to delete the tree iteratively

        while(NULL != pTempRoot)
        {
            pTempNode = pTempRoot;
            while(NULL != pTempNode->_pcnChild)
            {
                pTempNode = pTempNode->_pcnChild;
            }

            pTempRoot = pTempNode->_pcnParent;
            if(pTempRoot != NULL)
            {
                pTempRoot->_pcnChild = pTempNode->_pcnSister;

                // Decrease the storage count.  This would be used to verify
                // before deleting the ChanceNode.

                pTempRoot->_cStorages--;
            }

            pTempNode->_pcnSister = NULL;

            // Verify that number of children of this node are zero.  Assert if
            // not.

            DH_ASSERT(0 == pTempNode->_cStorages);

            // Delete the node

            delete pTempNode;
            pTempNode = NULL;
        }
    }

    return hr;
}

//--------------------------------------------------------------------------
//  Member:     ChanceDF::GetModes, public
//
//  Synopsis:   Gets the creation modes for Root Storage, child storages,
//              streams if provided on command line parameters.
//
//  Arguments:  [pDFMode]
//              [ptcsModeFlags]
//
//  Returns:    HRESULT
//
//  History:    Narindk 2-May-96   Created
//---------------------------------------------------------------------------

HRESULT ChanceDF::GetModes(
    DWORD                *pDFMode,
    LPCTSTR              ptcsModeFlags)
{
    HRESULT     hr = S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GetModes"));

    DH_VDATESTRINGPTR(ptcsModeFlags);
    DH_VDATEPTROUT(pDFMode, DWORD);

    DH_ASSERT(NULL != pDFMode);

    if(S_OK == hr)
    {
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_DIRREADSHEX))
        {
            *pDFMode = STGM_READ          |
                       STGM_DIRECT        |
                       STGM_SHARE_EXCLUSIVE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_DIRWRITESHEX))
        {
            *pDFMode = STGM_WRITE         |
                       STGM_DIRECT        |
                       STGM_SHARE_EXCLUSIVE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_DIRREADSHDENYW))
        {
            *pDFMode = STGM_READ          |
                       STGM_DIRECT        |
                       STGM_SHARE_DENY_WRITE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_DIRREADWRITESHEX))
        {
            *pDFMode = STGM_READWRITE     |
                       STGM_DIRECT        |
                       STGM_SHARE_EXCLUSIVE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_DIRREADWRITESHDENYN))
        {
            *pDFMode = STGM_READWRITE     |
                       STGM_DIRECT        |
                       STGM_SHARE_DENY_NONE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADWRITESHEX))
        {
            *pDFMode = STGM_READWRITE     |
                       STGM_TRANSACTED    |
                       STGM_SHARE_EXCLUSIVE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADWRITESHDENYW))
        {
            *pDFMode = STGM_READWRITE     |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_WRITE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADWRITESHDENYN))
        {
            *pDFMode = STGM_READWRITE     |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_NONE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADWRITESHDENYR))
        {
            *pDFMode = STGM_READWRITE     |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_READ;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADSHDENYN))
        {
            *pDFMode = STGM_READ          |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_NONE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADSHDENYR))
        {
            *pDFMode = STGM_READ          |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_READ;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADSHDENYW))
        {
            *pDFMode = STGM_READ          |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_WRITE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTREADSHEX))
        {
            *pDFMode = STGM_READ          |
                       STGM_TRANSACTED    |
                       STGM_SHARE_EXCLUSIVE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTWRITESHDENYN))
        {
            *pDFMode = STGM_WRITE         |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_NONE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTWRITESHDENYR))
        {
            *pDFMode = STGM_WRITE         |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_READ;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTWRITESHDENYW))
        {
            *pDFMode = STGM_WRITE         |
                       STGM_TRANSACTED    |
                       STGM_SHARE_DENY_WRITE;
        }
        else
        if (0 == _tcsicmp(ptcsModeFlags, TSZ_XACTWRITESHEX))
        {
            *pDFMode = STGM_WRITE         |
                       STGM_TRANSACTED    |
                       STGM_SHARE_EXCLUSIVE;
        }
        else
        {
            hr = E_INVALIDARG ;

            DH_ASSERT(!TEXT("ChanceDF::GetModes: Invalid Mode")) ;
        }
    }

    return hr;

}

//--------------------------------------------------------------------------
//  Member:     ChanceDF::GetDocFileNameFromCmdline, private
//
//  Synopsis:   Gets the user provided name for docfile to be created.
//
//  Arguments:  [tszName]
//
//  Returns:    HRESULT
//
//  History:    Narindk 2-May-96   Created
//---------------------------------------------------------------------------

HRESULT ChanceDF::GetDocFileNameFromCmdline(LPCTSTR tszName)
{
    HRESULT hr = S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChanceDF::GetDocFileName"));

    DH_VDATESTRINGPTR(tszName);

    _ptszName = new TCHAR[_tcslen(tszName)+1];

    if (_ptszName == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        _tcscpy(_ptszName, tszName);
    }

    return hr;
}

//--------------------------------------------------------------------------
//  Member:     ChanceDF::GetRandomChanceNode, protected
//
//  Synopsis:   Gets a random ChanceNode from the ChanceDocFile tree to which
//              a new ChanceNode would be added as Child or Sister during
//              generation of ChanceDF tree. 
//
//  Arguments:  [cNumOfNodes] :  Total number of ChanceNodes in ChanceDF tree 
//              [ppcn] : Out parameter to return random ChanceNode found.
//
//  Returns:    HRESULT
//
//  History:    Narindk 2-July-96   Created
//
//  Notes:      -Find a random number between 1 and total number of nodes in
//               the tree cNumOfNodes
//              -Initialize counter to 1.
//              -Initialze temp variable pcnTrav to _pcnRoot.
//              -In a infinite for loop-
//                  -while pcnTrav's _pcnChild is not NULL and counter is less 
//                   than cRandomNode, loop and update pcnTrav and counter.
//                  -If cRandomNode is equal to counter, then break out of
//                   for loop.
//                  -while pcnTrav's _pcnSister is NULL, loop and keep assign
//                   ing pcnTrav's _pcnParent to pcnTrav.
//                  -When pcnTrav's _pcnSister is not NULL, assign it to 
//                   pcnTrav, increment counter and go back to top of loop.
//
//              Pl. note that if cNumNodes is incorrectly given as more than
//              actual number of nodes in tree, then this function will throw
//              asserts.
//---------------------------------------------------------------------------

HRESULT ChanceDF::GetRandomChanceNode(ULONG cNumOfNodes, ChanceNode **ppcn)
{
    HRESULT     hr          = S_OK;
    ChanceNode  *pcnTrav    = NULL;
    ULONG       cRandomNode = 0;
    ULONG       counter     = 1;
    USHORT      usErr       = 0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ChanceDF::GetRandomChanceNode"));

    DH_VDATEPTROUT(ppcn, PCHANCENODE);

    DH_ASSERT(NULL != ppcn);
    DH_ASSERT(NULL != _pcnRoot);
    DH_ASSERT(NULL != _pdgi);
    DH_ASSERT(0 != cNumOfNodes);

    if(S_OK == hr)
    {
        // Initialize out parameter
        *ppcn = NULL;

        usErr = _pdgi->Generate(&cRandomNode, 1, cNumOfNodes);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        pcnTrav = _pcnRoot;

        for(;;)
        {
            DH_ASSERT((NULL != pcnTrav) && (counter <= cRandomNode));
            while((pcnTrav->_pcnChild != NULL) && (counter < cRandomNode))
            {
                pcnTrav = pcnTrav->_pcnChild;
                counter++;
            }

            if(cRandomNode == counter)
            {
                break;
            }

            while(NULL == pcnTrav->_pcnSister)
            {
                pcnTrav = pcnTrav->_pcnParent;
                DH_ASSERT(NULL != pcnTrav);
            }

            DH_ASSERT(NULL != pcnTrav->_pcnSister);
            pcnTrav = pcnTrav->_pcnSister;
            counter++;
        }
    }

    if(S_OK == hr)
    {
        *ppcn = pcnTrav;
    }

    return hr;
}

//--------------------------------------------------------------------------
//  Member:     ChanceDF::GetDepthOfNode, private
//
//  Synopsis:   Gets the depth of a ChanceNode in a ChanceDF tree
//
//  Arguments:  [pcn] - ChanceNode whose depth needs to be determined.
//
//  Returns:    HRESULT
//
//  History:    Narindk 2-July-96   Created
//
//  Notes:      -Assigned passed in ChanceNode to temp variable pcnTrav.
//              -Initialize cNodeDepth to zero.
//              -Loop till pcnTrav's _pcnParent is not NULL and keep on 
//               updating pcnTrav and cNodeDepth. 
//              -Depth returned is 0 to n-1 for 1 to nth level nodes.
//---------------------------------------------------------------------------

ULONG ChanceDF::GetDepthOfNode(ChanceNode *pcn)
{
    ChanceNode  *pcnTrav    = NULL;
    ULONG       cNodeDepth  = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ChanceDF::GetDepthOfNode"));

    DH_ASSERT(NULL != pcn);

    pcnTrav = pcn; 
    while(NULL != pcnTrav->_pcnParent)
    {
        cNodeDepth++;
        pcnTrav = pcnTrav->_pcnParent;
    }

    return cNodeDepth;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\vcnode.cxx ===
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  All rights reserved.
//
//  File:       vcnode.cxx
//
//  Contents:   Implementation for in-memory Virtual Container Node class.
//
//  Classes:    VirtualCtrNode (vcn)
//
//  Functions:  VirtualCtrNode()  
//              ~VirtualCtrNode()
//              Init
//              AppendChildCtr
//              AppendSisterCtr
//              AppendFirstChildStm
//              CreateRoot
//              CreateRootEx
//              Create
//              Open
//              OpenRoot
//              OpenRootEx
//              Close
//              Commit
//              Rename
//              Destroy
//              Stat
//              EnumElements 
//              SetElementTimes 
//              SetClass
//              SetStateBits
//              MoveElementTo
//              Revert
//              CopyTo 
//              AddRefCount
//              QueryInterface
//              CreateRootOnCustomILockBytes
//              OpenRootOnCustomILockBytes
//
//              NOTE: All above functions are public
//
//  History:    DeanE    21-Mar-96   Created
//              Narindk  24-Apr-96   Added more functions 
//              SCousens  2-Feb-97   Added Open/CreateRoot for NSS files
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug object declaration
//
DH_DECLARE;

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::VirtualCtrNode, public
//
//  Synopsis:   Constructor.  
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   21-Mar-96   Created
//---------------------------------------------------------------------------

VirtualCtrNode::VirtualCtrNode() : 
                          _pvcnChild(NULL),
                          _pvcnSister(NULL),
                          _pvcnParent(NULL),
                          _pvsnStream(NULL),
                          _cStreams(0),
                          _ptszName(NULL),
                          _cChildren(0),
                          _dwCRC(CRC_PRECONDITION),
                          _pstg(NULL)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::VirtualCtrNode"));
}


//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::~VirtualCtrNode, public
//
//  Synopsis:   Destructor.  Frees resources associated with this object,
//              including closing the storage if open and removing this
//              tree from memory.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   21-Mar-96   Created
//---------------------------------------------------------------------------

VirtualCtrNode::~VirtualCtrNode()
{
    ULONG ulRef =   0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::~VirtualCtrNode"));
    
    if(NULL != _ptszName)
    {
        delete _ptszName;
        _ptszName = NULL;
    }

    if ( NULL != _pstg )
    {
        ulRef = _pstg->Release();

        // Assert if ulRef is not zero, object is being destructed.
        DH_ASSERT(0 == ulRef);

        _pstg = NULL;
    }
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Init, public
//
//  Synopsis:   Initializes a storage node - does not open or create the
//              actual storage.
//
//  Arguments:  [tszName]    - Name of this storage
//              [cStg]       - Number of storages contained in this storage. 
//              [cStm]       - Number of streams contained in this storage. 
//
//  Returns:    S_OK if node initialized successfully, otherwise an error.
//
//  Notes:      BUGBUG - Not Nashville Safe...
//
//  History:    Narindk   18-Apr-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Init( LPTSTR tszName, ULONG cStg, ULONG cStm) 
{
    HRESULT hr = S_OK;

    DH_VDATESTRINGPTR(tszName);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Init"));

    DH_ASSERT(NULL != tszName);

    if( S_OK == hr)
    {
        _ptszName = new TCHAR[_tcslen(tszName)+1];

        if (_ptszName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            _tcscpy(_ptszName, tszName);

            _cChildren = cStg;
            _cStreams  = cStm;
        }
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::AppendChildCtr, public
//
//  Synopsis:   Appends the node passed to the end of this nodes' child
//              node chain.
//
//  Arguments:  [pcnNew] - The new node to append.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    17-Apr-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::AppendChildCtr(VirtualCtrNode *pvcnNew)
{
    HRESULT         hr          = S_OK;
    VirtualCtrNode  *pvcnTrav   = this;

    DH_VDATEPTRIN(pvcnNew, VirtualCtrNode);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::AppendChildCtr"));

    DH_ASSERT(NULL != pvcnNew);

    if(S_OK == hr)
    {
        // Find the last child in the structure
    
        while (NULL != pvcnTrav->_pvcnChild)
        {
            pvcnTrav = pvcnTrav->_pvcnChild;
        }

        // Append the new node as a child of the last node,
        // and make the new node point to the last node as it's parent
    
        pvcnTrav->_pvcnChild = pvcnNew;
        pvcnNew->_pvcnParent = pvcnTrav;
    }

    return hr;
}


//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::AppendSisterCtr, public
//
//  Synopsis:   Appends the node passed to the end of this nodes' sister 
//              node chain.
//
//  Arguments:  [pcnNew] - The new node to append.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    17-Apr-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::AppendSisterCtr(VirtualCtrNode *pvcnNew)
{
    HRESULT         hr          =   S_OK;
    VirtualCtrNode  *pvcnTrav   =   this;

    DH_VDATEPTRIN(pvcnNew, VirtualCtrNode);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::AppendSisterCtr"));

    DH_ASSERT(NULL != pvcnNew);

    if(S_OK == hr)
    {
        // Find the last sister in the chain 
    
        while (NULL != pvcnTrav->_pvcnSister)
        {
            pvcnTrav = pvcnTrav->_pvcnSister;
        }

        // Append the new node as a sister of the last node,
        // and make the new node point to this nodes parent as it's parent

        pvcnTrav->_pvcnSister = pvcnNew;
        pvcnNew->_pvcnParent = pvcnTrav->_pvcnParent;
    }

    return  hr;
}


//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::AppendFirstChildStm, public
//
//  Synopsis:   Appends the first stream to its parent storage 
//
//  Arguments:  [pcnNew] - The new node to append.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    17-Apr-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::AppendFirstChildStm(VirtualStmNode *pvsnNew)
{
    HRESULT         hr          = S_OK;
    VirtualCtrNode  *pvcnCurrent= this;

    DH_VDATEPTRIN(pvsnNew, VirtualStmNode);

    DH_FUNCENTRY(&hr,DH_LVL_DFLIB,TEXT("VirtualCtrNode::AppendFirstChildStm"));

    DH_ASSERT(NULL != pvsnNew);

    if(S_OK == hr)
    {
        // Append the new stream node (first stream node) to parent storage,
        // and make the new stream node point to storage as it's parent

        pvcnCurrent->_pvsnStream = pvsnNew;
        pvsnNew->_pvcnParent = pvcnCurrent;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::CreateRoot, public
//
//  Synopsis:   Wrapper for StgCreateDocFile that will create a new root
//              compound file in the file system.
//
//  Arguments:  [grfmode] - Access mode for opening new compound file.
//              [dwReserved] - Reserved by OLE for future use, must be zero.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    18-Apr-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::CreateRoot(DWORD grfMode, 
        DWORD   dwReserved, 
        DSKSTG  DiskStgType)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrTemp =   NULL;

    DH_ASSERT(0 == dwReserved);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::CreateRoot"));

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = StgCreateDocfile(pOleStrTemp, grfMode, dwReserved, &_pstg);

        DH_HRCHECK(hr, TEXT("StgCreateDocFile")) ;
        DH_TRACE ((DH_LVL_DFLIB, TEXT("StgCreateRootStorage:%s"), _ptszName));

        if (S_OK == hr)
        {
            if(!StorageIsFlat())
                DH_LOG ((LOG_INFO, TEXT("Created docfile:%s"), _ptszName));
            else
                DH_LOG ((LOG_INFO, TEXT("Created flatfile:%s"), _ptszName));
        }
    }

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }
 
    return  hr;
}


//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::CreateRootEx, public (overload)
//
//  Synopsis:   Wrapper for StgCreateDocFileEx that will create a new root
//              compound file in the file system.
//
//  Arguments:  [grfMode]     - Access mode for opening new compound file.
//              [stgfmt]      - Storage Format - enum.
//              [grfAttrs]    - Attributes (zero for now)
//              [pStgOptions] - STGOPTIONS.
//              [pTransaction]- Reserved by OLE for future use, must be zero.
//              [riid]        - should be IID_IStorage to get an IStorage
//
//  Returns:    S_OK for success or an error code.
//
//  History:    28-Jan-97   SCousens     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::CreateRootEx(DWORD grfMode, 
        DWORD  stgfmt,
        DWORD  grfAttrs,
        STGOPTIONS *pStgOptions,
        PVOID  pTransaction, 
        REFIID riid)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrTemp =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::CreateRoot"));

    DH_ASSERT(0 == stgfmt);   // want value of 0
    DH_ASSERT(0 == grfAttrs);        // want 0
    DH_ASSERT(NULL == pStgOptions); // want value of NULL for wrapper
    DH_ASSERT(NULL == pTransaction);
    DH_ASSERT(IsEqualIID (IID_IStorage, riid)); // want IStorages. may change

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR
        hr = TStringToOleString(_ptszName, &pOleStrTemp);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = StgCreateStorageEx (pOleStrTemp, 
                grfMode, 
                stgfmt, 
                grfAttrs, 
                pStgOptions, 
                pTransaction, 
                riid, 
                (void**)&_pstg);
        DH_HRCHECK(hr, TEXT("StgCreateDocFileEx")) ;
        DH_TRACE ((DH_LVL_DFLIB, TEXT("StgCreateRootStorageEx:%s"), _ptszName));

        if (S_OK == hr)
        {
            DH_LOG ((LOG_INFO, TEXT("Created docfile:%s"), _ptszName));
        }
    }

    // Clean up
    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }
 
    return  hr;
}


//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Create, public
//
//  Synopsis:   Wrapper for IStorage::CreateStorage that will create and 
//              open a new IStorage object within this storage object.
//
//  Arguments:  [grfmode] -     Access mode for creating & opening new storage 
//                              object.
//              [dwReserved1] - Reserved by OLE for future use, must be zero.
//              [dwReserved2] - Reserved by OLE for future use, must be zero.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    18-Apr-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Create(
    DWORD       grfMode, 
    DWORD       dwReserved1, 
    DWORD       dwReserved2)
{
    HRESULT     hr          =   S_OK;
    LPSTORAGE   pstg        =   NULL;
    LPOLESTR    pOleStrTemp =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Create"));

    DH_ASSERT(0 == dwReserved1);
    DH_ASSERT(0 == dwReserved2);

    DH_ASSERT(NULL != _pvcnParent);
    
    DH_ASSERT(NULL != _pvcnParent->_pstg);

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->CreateStorage(
                pOleStrTemp, 
                grfMode, 
                dwReserved1, 
                dwReserved2, 
                &_pstg);

        DH_HRCHECK(hr, TEXT("IStorage::CreateStorage")) ;
        DH_TRACE ((DH_LVL_DFLIB, TEXT("CreateStorage:%s"), _ptszName));
    }

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Open, public
//
//  Synopsis:   Wrapper for IStorage::OpenStorage that will open the named 
//              IStorage object within this storage object.
//
//  Arguments:  [grfmode] -    Access mode for opening the storage object. 
//              [dwReserved] - Reserved by OLE for future use, must be zero.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    24-Apr-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Open(
    LPSTORAGE   pstgPriority, 
    DWORD       grfmode, 
    SNB         snbExclude,  
    DWORD       dwReserved)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrTemp =   NULL;
    LPSTORAGE   pstg        =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Open"));

    DH_ASSERT(0 == dwReserved);

    // Check if it is root storage, if it is, then call OpenRoot and 
    // return here else proceed.
 
    if(NULL == this->_pvcnParent)
    {
        DH_LOG ((LOG_INFO, 
                TEXT("Test called Open to open root storage. Calling OpenRoot.")));
        hr = this->OpenRoot (pstgPriority, 
                grfmode, 
                snbExclude, 
                dwReserved);
        
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::OpenRoot"));

        return hr;
    }

    DH_ASSERT(NULL != _pvcnParent->_pstg);

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Open the storage.

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->OpenStorage(
                          pOleStrTemp,
                          pstgPriority,
                          grfmode,
                          snbExclude,
                          dwReserved,
                          &pstg);

        DH_HRCHECK(hr, TEXT("IStorage::OpenStorage"));
        DH_TRACE ((DH_LVL_DFLIB, TEXT("OpenStorage:%s"), _ptszName));
    }

    // Save it if function succeeds if _pstg is NULL.

    if((S_OK == hr) && (NULL == _pstg))
    { 
        _pstg = pstg;
    }

    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open"));

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::OpenRoot, public
//
//  Synopsis:   Wrapper for IStorage::OpenStorage that will open the named 
//              IStorage object within this storage object.
//
//  Arguments:  [grfmode] -     Access mode for creating & opening new storage 
//                              object.
//              [dwReserved1] - Reserved by OLE for future use, must be zero.
//              [dwReserved2] - Reserved by OLE for future use, must be zero.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    24-Apr-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::OpenRoot(
    LPSTORAGE   pstgPriority, 
    DWORD       grfmode, 
    SNB         snbExclude,  
    DWORD       dwReserved,
    DSKSTG      DiskStgType)
{
    HRESULT         hr          =   S_OK;
    IStorage        *pstg       =   NULL;
    LPOLESTR        pOleStrTemp =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::OpenRoot"));

    DH_ASSERT(0 == dwReserved);

    // Make sure this is the Root.
    DH_ASSERT(NULL == this->_pvcnParent);

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Open the root storage 

    if(S_OK == hr)
    {
#if (WINVER<0x500)          //NT5 is lockviolation fixed
        DG_INTEGER dgi(0);
        ULONG ulRandNum = 0;
        USHORT usErr = 0;
        int i = 0;
        
        // Try opening the docfile
        // StgOpenStorage returns STG_E_LOCKVIOLATION is concurrent API calls
        // are made, so this is the hack for workaround the problem.
        // BUGBUG : Remove this loop once the feature is implemented in OLE.
        // BUGBUG : ntbug#114779  Affects DCOM95 only. ntbug#41249 fixed
          
        for(i=0; i<NRETRIES; i++)  // NRETRIES has been defined as 20
        {
#endif
            hr = StgOpenStorage(
                    pOleStrTemp,
                    pstgPriority,
                    grfmode,
                    snbExclude,
                    dwReserved,
                    &pstg);

            DH_HRCHECK(hr, TEXT("StgOpenStorage"));
            DH_TRACE ((DH_LVL_DFLIB, TEXT("StgOpenRootStorage:%s"), _ptszName));

#if (WINVER<0x500)          //NT5 is lockviolation fixed
            if ( (S_OK == hr) || (STG_E_LOCKVIOLATION != hr) )
            {
                break;
            }

            // Sleep for a random amount of time
            // Note: No particular reason why the below random numbers have been used
            usErr = dgi.Generate(&ulRandNum, 1, 100 );
            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
                break;
            }
            else
            {
                Sleep(ulRandNum*50);            
            }
        }
#endif
    }

    if((S_OK == hr) && (NULL == _pstg))
    {
        _pstg = pstg;
    }

    DH_HRCHECK(hr, TEXT("VirtualCtrNode::OpenRoot"));

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::OpenRootEx, public (overload)
//
//  Synopsis:   Wrapper for StgOpenStorageEx that will open a previously 
//              created root compound file in the file system.
//
//  Arguments:  [grfMode]     - Access mode for opening the compound file.
//              [stgfmt]      - Storage Format - enum.
//              [grfAttrs]    - Attributes
//              [pStgOptions] - STGOPTIONS, must be NULL as on build 1795.
//              [pTransaction]- Reserved by OLE for future use, must be zero.
//              [riid]        - should be IID_IStorage to get an IStorage
//
//  Returns:    S_OK for success or an error code.
//
//  History:    28-Jan-97   SCousens     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::OpenRootEx(
    DWORD       grfMode, 
    DWORD       stgfmt, 
    DWORD       grfAttrs, 
    STGOPTIONS  *pStgOptions,
    PVOID       pTransaction,
    REFIID      riid)
{
    HRESULT         hr          =   S_OK;
    IStorage        *pstg       =   NULL;
    LPOLESTR        pOleStrTemp =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::OpenRoot"));

    // Make sure this is the Root.
    DH_ASSERT(NULL == this->_pvcnParent);
    DH_ASSERT(0 == stgfmt);   // want value of 0
    DH_ASSERT(0 == grfAttrs);        // want 0
    DH_ASSERT(NULL == pStgOptions);  // want value of NULL 
    DH_ASSERT(NULL == pTransaction);
    DH_ASSERT(IsEqualIID (IID_IStorage, riid)); // want IStorages. may change

    if (S_OK == hr)
    {
        // Convert _ptszName to OLECHAR
        hr = TStringToOleString(_ptszName, &pOleStrTemp);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Open the root storage 
    if (S_OK == hr)
    {
        DG_INTEGER dgi(0);
        ULONG ulRandNum = 0;
        USHORT usErr = 0;
        int i = 0;
        
        // Try opening the docfile
        // StgOpenStorage returns STG_E_LOCKVIOLATION is concurrent API calls
        // are made, so this is the hack for workaround the problem.
        // BUGBUG : Remove this loop once the feature is implemented in OLE.
          
        for(i=0; i<NRETRIES; i++)  // NRETRIES has been defined as 20
        {
            hr = StgOpenStorageEx(pOleStrTemp,
                    grfMode, 
                    stgfmt, 
                    grfAttrs,
                    pStgOptions,   
                    pTransaction,
                    riid, 
                    (void**)&pstg);

            DH_HRCHECK(hr, TEXT("StgOpenStorageEx"));
            DH_TRACE ((DH_LVL_DFLIB, TEXT("StgOpenRootStorageEx:%s"), _ptszName));

            if ( (S_OK == hr) || (STG_E_LOCKVIOLATION != hr) )
            {
                break;
            }

            // Sleep for a random amount of time
            // Note: No particular reason why the below random numbers have been used
            usErr = dgi.Generate(&ulRandNum, 1, 100 );
            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
                break;
            }
            else
            {
                Sleep(ulRandNum*50);
                DH_TRACE ((DH_LVL_TRACE4, 
                        TEXT("VirtualCtrNode::OpenRoot: Sleeping due to LOCKVIOLATION")));
            }
        }
    }

    if((S_OK == hr) && (NULL == _pstg))
    {
        _pstg = pstg;
    }

    DH_HRCHECK(hr, TEXT("VirtualCtrNode::OpenRoot"));

    // Clean up
    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Close, public
//
//  Synopsis:   Closes an open storage.
//
//  Arguments:  None
//
//  Returns:    HRESULT
//
//  History:    NarindK   25-Apr-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Close()
{
    HRESULT     hr      =   S_OK;
    ULONG       ulRef   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Close"));

    // When we create the storage, it is open.  We do not call release
    // on _pstg normally till the VirtualCtrNode object is destructed,  or
    // if explicitly this function is used to close the storage

    if ( NULL != _pstg )
    {
        ulRef = _pstg->Release();
    }
    else
    {
        DH_ASSERT(!TEXT("_pStg is already NULL!"));
    }

    DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
  
    if(0 == ulRef)
    {
        _pstg = NULL;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Commit, public
//
//  Synopsis:   Wrapper for IStorage::Commit that will commit any changes
//              made to an IStorage object since it was opened or last
//              committed to persistent storage. 
//
//  Arguments:  [grfCommitFlags] - Controls how object is committed to IStorage.
//
//  Returns:    S_OK                Commit operation was successful.
//              STG_E_NOTCURRENT    Another opening of storage object has commi
//                                  tted changes, possibility of overwriting.
//              STG_E_MEDIUMFULL    No space left on device to commit.
//              STG_E_TOOMANYOPENFILES too many open files.
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//              STG_E_INVALIDFLAG   Invalid flag.
//              STG_E_INVALIDPARAMETER Inalid parameter  
//
//  History:    29-Apr-96   NarindK     Created
//              12-Mar-97   MikeW       Removed HRCHECK after Commit
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Commit(DWORD grfCommitFlags)
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Commit"));

    DH_ASSERT(NULL != _pstg);

    if ( S_OK == hr )
    {
        hr = _pstg->Commit(grfCommitFlags);
    }
    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Rename, public
//
//  Synopsis:   Wrapper for IStorage::RenameElement that renames an element 
//              contained in an Storage object subject to transaction state
//              of IStorage object. 
//
//  Arguments:  [pptcsNewName] - Points to pointer to new name for the element. 
//
//  Returns:    S_OK                Object was successfully renamed. 
//              STG_E_ACCESSDENIED  Named element ptcsNewName alreadys exists. 
//              STG_E_FILENOTFOUND  Element couldn't be found.
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//              STG_E_INSUFFICIENTMEMORY Not enough memory to rename element.
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDNAME        Invalid name.  
//              STG_E_INVALIDPARAMETER   Invalid parameter  
//              STG_E_TOOMANYOPENFILES   too many open files.
//
//  History:    29-Apr-96   NarindK     Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Rename(LPCTSTR ptcsNewName)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrOld  =   NULL;
    LPOLESTR    pOleStrNew  =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Rename"));

    DH_VDATESTRINGPTR(ptcsNewName);

    DH_ASSERT(NULL != _pvcnParent);
    
    DH_ASSERT(NULL != _pvcnParent->_pstg);

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrOld);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        // Convert ptcsNewName to OLECHAR

        hr = TStringToOleString((LPTSTR)ptcsNewName, &pOleStrNew);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->RenameElement(pOleStrOld, pOleStrNew);

        DH_HRCHECK(hr, TEXT("IStorage::Rename")) ;
    }

    if(S_OK == hr)
    {
        // Change the name of VirtualCtrNode i.e. its _ptszName variable also

        // First delete the old name

        if(NULL != _ptszName)
        {
            delete _ptszName;
            _ptszName = NULL;
        }

        // Now copy the new name by allocating enough memory
        _ptszName = new TCHAR[_tcslen(ptcsNewName)+1];

        if (_ptszName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            _tcscpy(_ptszName, ptcsNewName);
        }
    }

    // Clean up

    if(NULL != pOleStrOld)
    {
        delete pOleStrOld;
        pOleStrOld = NULL;
    }

    if(NULL != pOleStrNew)
    {
        delete pOleStrNew;
        pOleStrNew = NULL;
    }

    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Destroy, public
//
//  Synopsis:   Wrapper for IStorage::DestroyElement that removes an element 
//              storage from this storage, subject to transaction mode in 
//              which it was opened.  The wrapper for IStorage::DestroyElement
//              that destorys a stream element from this storage is in
//              VirtualStmNode::Destroy. 
//
//  Arguments:  None 
//
//  Returns:    S_OK                Object was successfully renamed. 
//              STG_E_ACCESSDENIED  insufficient permissions. 
//              STG_E_FILENOTFOUND  Element couldn't be found.
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//              STG_E_INSUFFICIENTMEMORY Not enough memory to rename element.
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDNAME        Invalid name.  
//              STG_E_INVALIDPARAMETER   Invalid parameter  
//              STG_E_TOOMANYOPENFILES   too many open files.
//
//  History:    29-Apr-96   NarindK     Created
//
//  Notes:      The existing open instance of this element from this parent
//              instance becomes invalid after this function is called.
//
//              Use DestroyStorage in the util.cxx which is a wrapper to call
//              this function and also readjusts the VirtualDF tree.
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Destroy()
{
    HRESULT     hr          =   S_OK;
    LPSTORAGE   pstg        =   NULL;
    LPOLESTR    pOleStrTemp =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Destroy"));

    DH_ASSERT(NULL != _pvcnParent);
    
    DH_ASSERT(NULL != _pvcnParent->_pstg);
    
    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->DestroyElement(pOleStrTemp);

        DH_HRCHECK(hr, TEXT("IStorage::DestroyElement")) ;
    }

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Stat, public
//
//  Synopsis:   Returns relevant statistics concerning this open storage.
//
//  Arguments:  [pStatStg] - pointer to STATSTG structure.
//              [grfStatFlag] - Controls levels of returned statistics.
//
//  Returns:    S_OK                Statistics were successfully returned. 
//              STG_E_ACCESSDENIED  insufficient permissions. 
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//              STG_E_INSUFFICIENTMEMORY Not enough memory.
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//
//  History:    NarindK   8-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Stat(
    STATSTG         *pStatStg,
    DWORD           grfStatFlag)
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Stat"));

    DH_ASSERT(_pstg != NULL);

    DH_ASSERT(NULL != pStatStg);

    DH_ASSERT((
        (grfStatFlag == STATFLAG_DEFAULT) ||
        (grfStatFlag == STATFLAG_NONAME)));

    if(S_OK == hr)
    { 
        hr = _pstg->Stat(pStatStg, grfStatFlag);

        DH_HRCHECK(hr, TEXT("IStorage::Stat"));
    }

    // BUGBUG:  May remove to need DH_ assert macros to do invalid parameter
    // checking.

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::EnumElements, public
//
//  Synopsis:   Enumerates the elements immediately contained within this
//              storage object.
//
//  Arguments:  [dwReserved1] - Reserved by OLE 
//              [dwReserved2] - Reserved by OLE
//              [dwReserved3] - Reserved by OLE
//              [ppenumStatStg] - Points to where to return enumerator, NULL
//                              if an error.
//
//  Returns:    S_OK                     Enumeration successful. 
//              STG_E_INSUFFICIENTMEMORY Not enough memory.
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDPARAMETER   Invalid parameter. 
//              E_OUTOFMEMORY            Not enough memory.
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//
//  History:    NarindK   10-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::EnumElements(
   DWORD           dwReserved1,
   PVOID           pReserved2,
   DWORD           dwReserved3, 
   LPENUMSTATSTG   *ppenumStatStg)
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::EnumElements"));

    DH_ASSERT(_pstg != NULL);

    if(S_OK == hr)
    { 
        hr = _pstg->EnumElements(
                dwReserved1, 
                pReserved2, 
                dwReserved3, 
                ppenumStatStg);

        DH_HRCHECK(hr, TEXT("IStorage::EnumElements"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::SetElementTimes, public
//
//  Synopsis:   Sets the modification, access, and creation times of the 
//              indicated element of this storage object. 
//
//  Arguments:  [lpszName] -  Points to name of element to change 
//              [pctime]   -  Points to new creation time 
//              [patime]   -  Points to new access time 
//              [pmtime]   -  Points to new modification time 
//
//  Returns:    S_OK                     Time values successfully set. 
//              STG_E_ACCESSDENIED       insufficient permissions. 
//              STG_E_FILENOTFOUND       Element not found. 
//              STG_E_FILEALREADYEXITS   Specified file already exists. 
//              STG_E_TOOMANYOPENFILES   too many open files
//              STG_E_INSUFFICIENTMEMORY Not enough memory.
//              STG_E_INVALIDNAME        Invalid name.  
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDPARAMETER   Invalid parameter. 
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//
//  History:    NarindK   10-May-96   Created
//
//  Notes:      Ole implemntation doesn't support setting time on stream elem
//              so no function corresponding to VirtualStmNode for this.
//
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::SetElementTimes(
   FILETIME const  *pctime,
   FILETIME const  *patime,
   FILETIME const  *pmtime)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrTemp =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::SetElementTimes"));

    DH_ASSERT(NULL != _pvcnParent);
    
    DH_ASSERT(NULL != _pvcnParent->_pstg);
    
    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    { 
        hr = _pvcnParent->_pstg->SetElementTimes(
                pOleStrTemp, 
                pctime, 
                patime, 
                pmtime);

        DH_HRCHECK(hr, TEXT("IStorage::SetElementTimes"));
    }

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::SetClass, public
//
//  Synopsis:   Persistently stores the object's CLSID.
//
//  Arguments:  [rclsid] - Specifies CLSID to be associated with this storage.
//
//  Returns:    S_OK                CLSID successfully stored. 
//              STG_E_ACCESSDENIED  insufficient permissions. 
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//              STG_E_MEDIUMFULL    Not enough space on device.  
//
//  History:    NarindK   9-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::SetClass(REFCLSID rclsid)
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::SetClass"));

    DH_ASSERT(_pstg != NULL);

    if(S_OK == hr)
    { 
        hr = _pstg->SetClass(rclsid);

        DH_HRCHECK(hr, TEXT("IStorage::SetClass"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::SetStateBits, public
//
//  Synopsis:   Stores upto 32 bits of state information in this IStorage.
//
//  Arguments:  [grfStateBits] - New values of bits to be set
//              [grfMask]      - Binary mask to indicate significant bits.
//
//  Returns:    S_OK                State successfully set. 
//              STG_E_ACCESSDENIED  insufficient permissions. 
//              STG_E_INVALIDPARAMETER   Invalid parameter  
//              STG_E_INVALIDFLAG   Invalid flag in grfStateBits or grfMask  
//
//  History:    NarindK   9-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::SetStateBits(
    DWORD       grfStateBits,
    DWORD       grfMask)
{
    HRESULT     hr      =   S_OK;
    LPSTORAGE   pstg    =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::SetStateBits"));

    DH_ASSERT(_pstg != NULL);

    if(S_OK == hr)
    { 
        hr = _pstg->SetStateBits(grfStateBits, grfMask);

        DH_HRCHECK(hr, TEXT("IStorage::SetStateBits"));
    }

    return hr;
}


//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::MoveElementTo, public
//
//  Synopsis:   Moves an IStorage/IStream element to indicated new destination 
//              container. 
//
//  Arguments:  [ptszName] - Name of child IStorage/IStream present in this
//                           this _pstg to be moved 
//              [pvcnDest] - Pointer to destination virtual container
//              [lpszNewname] - Points to new name to element in its new 
//                              container
//              [grfFlags] - Specifies if to move as move or copy
//
//  Returns:    S_OK                Storage moved successfully. 
//              STG_E_ACCESSDENIED  insufficient permissions. 
//              STG_E_FILENOTFOUND       Element not found. 
//              STG_E_FILEALREADYEXITS   Specified file already exists. 
//              STG_E_TOOMANYOPENFILES   too many open files
//              STG_E_INSUFFICIENTMEMORY Not enough memory.
//              STG_E_INVALIDNAME        Invalid name.  
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDPARAMETER   Invalid parameter  
//              STG_E_INVALIDFLAG   Invalid flag in grfFlags 
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//
//  History:    NarindK   13-May-96   Created
//
//  Notes:      This moves a child storage/stream with name ptszName in present 
//              storage _pstg to a destination storage.  Make sure that the
//              child storage/stream to be moved is closed and the destination 
//              storage is open. 
//              The VirtualDF tree needs to be readjusted after this call.
//              Different methods of VirtualDF may need to be called as the
//              case may be - AdjustTreeOnStgMoveElement, AdjustTreeOnStmMove
//              Element, AdjustTreeOnStgCopyElement, AdjustTreeOnStmCopyElement
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::MoveElementTo(
    LPCTSTR         ptszName,
    VirtualCtrNode  *pvcnDest,
    LPCTSTR         ptszNewName,
    DWORD           grfFlags)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrOld  =   NULL;
    LPOLESTR    pOleStrNew  =   NULL;

    DH_VDATESTRINGPTR(ptszName);
    DH_VDATESTRINGPTR(ptszNewName);
    DH_VDATEPTRIN(pvcnDest, VirtualCtrNode);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::MoveElementTo"));

    DH_ASSERT(_pstg != NULL);
    DH_ASSERT(NULL != pvcnDest);
    DH_ASSERT(pvcnDest->_pstg != NULL);

    DH_ASSERT(NULL != ptszName);
    DH_ASSERT(NULL != ptszNewName);
    DH_ASSERT((grfFlags == STGMOVE_COPY) ||
              (grfFlags == STGMOVE_MOVE));

    if(S_OK == hr)
    {
        // Convert ptszName to OLECHAR

        hr = TStringToOleString((LPTSTR)ptszName, &pOleStrOld);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        // Convert ptszNewName to OLECHAR

        hr = TStringToOleString((LPTSTR)ptszNewName, &pOleStrNew);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    { 
        hr = _pstg->MoveElementTo(
                pOleStrOld,
                pvcnDest->_pstg,
                pOleStrNew,
                grfFlags);

        DH_HRCHECK(hr, TEXT("IStorage::MoveElementTo"));
    }

    // Clean up

    if(NULL != pOleStrOld)
    {
        delete pOleStrOld;
        pOleStrOld = NULL;
    }

    if(NULL != pOleStrNew)
    {
        delete pOleStrNew;
        pOleStrNew = NULL;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::Revert, public
//
//  Synopsis:   Discards all changes made in or made visible to thsi storage
//              object since it was opened or last committed.  
//
//  Arguments:  none 
//
//  Returns:    HRESULT
//              S_OK                        Revert operation successful. 
//              STG_E_INSUFFICIENTMEMORY    Out of memory.
//              STG_E_TOOMANYOPENFILES      Too many open files.
//              STG_E_REVERTED         Object has been invalidated by a revert
//                                     operation above it in transaction tree.
//
//  History:    NarindK   20-May-96   Created
//
//  Notes:      
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::Revert()
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::Revert"));

    DH_ASSERT(_pstg != NULL);

    if(S_OK == hr)
    {
        hr = _pstg->Revert();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Revert"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::CopyTo, public
//
//  Synopsis:   Copies  an IStorage element to indicated new destination 
//              container. 
//
//  Arguments:  [ciidExclude] - Speciefies number of elements in array pointed
//                              to by rgiidExclude. 
//              [rgiidExclude]- Specifies an array of interface identifiers the
//                              caller takes responsibility of moving from 
//                              source to destination.
//              [snbExclude] -  Points to a bloack of named elements not to
//                              to be copied into destination container.
//              [pvcnDest]-     Points to the open storage object where this
//                              open storage object is copied.
//
//  Returns:    S_OK                     Storage copied successfully. 
//              STG_E_ACCESSDENIED       insufficient permissions. 
//              STG_E_TOOMANYOPENFILES   too many open files
//              STG_E_INSUFFICIENTMEMORY Not enough memory.
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDPARAMETER   Invalid parameter 
//              STG_E_MEDIUMFULL         Storage medium is full 
//              STG_E_DESTLACKSINTERFACE Destination lacks an interface of the
//                                       source object to be copied.
//
//  History:    NarindK   20-May-96   Created
//
//  Notes:      This copies contents of storage _pstg to a destination storage.
//              The storage to be copied from and the destination storage to
//              be copied into is open. 
//              VirtualDF tree needs to be readjusted after this call. Virtual
//              DF's AdjustTreeOnCopyTo may be used.
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::CopyTo(
    DWORD           ciidExclude,
    IID const*      rgiidExclude,
    SNB             snbExclude,
    VirtualCtrNode  *pvcnDest)
{
    HRESULT     hr          =   S_OK;

    DH_VDATEPTRIN(pvcnDest, VirtualCtrNode);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::CopyTo"));

    DH_ASSERT(NULL != _pstg);
    DH_ASSERT(NULL != pvcnDest);
    DH_ASSERT(NULL != pvcnDest->_pstg);

    if(S_OK == hr)
    { 
        hr = _pstg->CopyTo(
                ciidExclude,
                rgiidExclude,
                snbExclude,
                pvcnDest->_pstg);

        DH_HRCHECK(hr, TEXT("IStorage::CopyTo"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::AddRefCount, public
//
//  Synopsis:   Increments the reference count on IStorage object. 
//
//  Arguments:  none 
//
//  Returns:    HRESULT
//
//  History:    NarindK   21-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::AddRefCount()
{
    HRESULT     hr      =   S_OK;
    ULONG       ulTmp   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::AddRefCount"));

    DH_ASSERT(_pstg != NULL);

    if(S_OK == hr)
    {
        ulTmp = _pstg->AddRef();
    }

    DH_HRCHECK(hr, TEXT("VirtualCtrNode::AddRefCount"));

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::QueryInterface, public
//
//  Synopsis:   Returns pointers to supported objects. 
//
//  Arguments:  none 
//
//  Returns:    HRESULT
//
//  History:    NarindK   21-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::QueryInterface(
    REFIID      riid, 
    LPVOID      *ppvObj)
{
    HRESULT     hr      =   S_OK;
    LPSTORAGE   pstg    =   NULL;

    DH_VDATEPTROUT(ppvObj, IUnknown *) ;
    
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualCtrNode::QueryInterface"));

    DH_ASSERT(ppvObj != NULL);

    DH_ASSERT(_pstg != NULL);

    if(S_OK == hr)
    {
        // Initilze the out parameter

        *ppvObj = NULL;

        hr = _pstg->QueryInterface(riid, ppvObj);
    }

    DH_HRCHECK(hr, TEXT("VirtualCtrNode::QueryInterface"));

    if(S_OK == hr)
    {
        DH_ASSERT(NULL != *ppvObj);
    }
    else
    {
        DH_ASSERT(NULL == *ppvObj);
    }

    return(hr);
}


//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::CreateRootOnCustomILockBytes,public
//
//  Synopsis:   Wrapper for StgCreateDocFileOnILockBytes that will create a new
//              root compound file in the file system based on custom ILockBytes
//
//  Arguments:  [grfmode] - Access mode for creating new compound file.
//              [pILockBytes] - Pointer to ILockBytes
//
//  Returns:    S_OK for success or an error code.
//
//  History:    1-Aug-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::CreateRootOnCustomILockBytes(
    DWORD       grfMode, 
    ILockBytes  *pILockBytes)
{
    HRESULT     hr          =   S_OK;

    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("VirtualCtrNode::CreateRootOnCustomILockBytes"));

    if(S_OK == hr)
    {
        hr = StgCreateDocfileOnILockBytes(
                pILockBytes,
                grfMode,
                0,
                &_pstg);

        DH_HRCHECK(hr, TEXT("StgCreateDocFileOnLockBytes")) ;
    }

    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualCtrNode::OpenRootOnCustomILockBytes, public
//
//  Synopsis:   Wrapper for StgOpenStorageOnILockBytes that will open the named 
//              IStorage root object on custom ILOckBytes provided. 
//
//  Arguments:  [pstgPrioirty] - Points to previous opening of root stg 
//              [grfmode] -     Access mode for creating & opening new storage 
//                              object.
//              [snbExclude] -  Points to a block of named elements not to
//                              to be excluded in open call.
//              [dwReserved] -  Reserved by OLE for future use, must be zero.
//              [pILockBytes] - Pointer to ILockBytes
//
//  Returns:    S_OK for success or an error code.
//
//  History:    3-Aug-96   NarindK     Created 
//---------------------------------------------------------------------------

HRESULT VirtualCtrNode::OpenRootOnCustomILockBytes(
    LPSTORAGE   pstgPriority, 
    DWORD       grfmode, 
    SNB         snbExclude,  
    DWORD       dwReserved,
    ILockBytes  *pILockBytes)
{
    HRESULT         hr          =   S_OK;
    IStorage        *pstg       =   NULL;

    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("VirtualCtrNode::OpenRootOnCustomILockBytes"));

    // Make sure this is the Root.
    
    DH_ASSERT(NULL == this->_pvcnParent);

    // Open the root storage 

    if(S_OK == hr)
    {
        hr = StgOpenStorageOnILockBytes(
                pILockBytes,
                pstgPriority,
                grfmode,
                snbExclude,
                dwReserved,
                &pstg);
    
        DH_HRCHECK(hr, TEXT("StgOpenStorage"));
    }

    if((S_OK == hr) && (NULL == _pstg))
    {
        _pstg = pstg;
    }

    DH_HRCHECK(hr, TEXT("VirtualCtrNode::OpenRootOnCustomILockBytes"));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\stgwrap.cxx ===
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  All rights reserved.
//
//  File:       stgwrap.cxx
//
//  Contents:   Wrap the StgOpen/Create apis
//              This is to permit nssfile and conversion testing 
//              and to test the new Stg*Ex apis
//              using the same codebase as the docfile tests with
//              minimal changes to that codebase.
//
//  Functions:  StgInitStgFormatWrapper
//              mStgCreateDocfile
//              mStgOpenStorage
//
//  Notes:      -Only do this fancy stuff if we are not doing 
//               vanilla docfile testing (ie _OLE_NSS_ is defd)
//              -Hook StgOpen/Create only if _OLE_NSS_ is defd
//               *and* _HOOK_STGAPI_ is defd also.
//
//  NOTE:       To turn on nss/cnv functionality you must add
//              -D_OLE_NSS_ -D_HOOK_STGAPI_ to you C_DEFINES
//              in daytona.mk
//
//  History:    SCousens  24-Feb-97   Created
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug object declaration
DH_DECLARE;

/* only do this fancy stuff if we are not doing vanilla docfile testing */

#ifdef _OLE_NSS_


// This is a global variable. We can do this because it controls
// the state for this entire process. No process will be mixing
// nssfile tests with conversion tests or any other combination.
// Doing it this way gives instant access at various times in the
// tests without rewriting anything.
// Setting of this variable will be done by passing a parameter
// on the commandline to start the process, and calling the init
// function below.

TSTTYPE g_uCreateType  = TSTTYPE_DEFAULT;  //DEFAULT, DOCFILE, NSSFILE 
TSTTYPE g_uOpenType    = TSTTYPE_DEFAULT;  //DEFAULT, DOCFILE, NSSFILE 
DWORD   g_fRegistryBits= REG_OPEN_AS | REG_CREATE_AS | REG_CNSS_ENABLE;
ULONG   g_ulSectorSize = DEFAULT_SECTOR_SIZE;
                         // DEFAULT_SECTOR_SIZE, LARGE_SECTOR_SIZE 

// internal functions
BOOL  StgCheckRegistry (void);
BOOL  StgCheckVolumeInformation (void);

//********************************************************************
// Function:  StgInitStgFormatWrapper (multiple)
//
// Synopsis:  Set the following global variables: 
//              g_uCreateType - type of storage to create
//              g_uOpenType   - type of storage to open
// 
//            1. Check the cmdline, set open and create modes 
//                (default, nssfile, docfile)
//            2. Check the registry. 
//                If NSS not set and want it, spew
//            3. Check disk sub storage type.
//                If !NTFS and want it, spew
// Return:     TRUE  if no issues
//             FALSE if nss set and not NTFS disk, 
//                      
//********************************************************************

BOOL  StgInitStgFormatWrapper (int argc, char *argv[])
{
    HRESULT hr   = S_OK;
    BOOL    fRet = TRUE;

    // check cmdline for open and create and sector size switches.
    CBaseCmdlineObj CCreateDF (OLESTR("CreateAs"), 
            OLESTR("Create doc/nss/flat file"), 
            OLESTR("default"));
    CBaseCmdlineObj COpenDF (OLESTR("OpenAs"), 
            OLESTR("Open doc/nss/flat file"), 
            OLESTR("default"));
    CBaseCmdlineObj CSectorSize (OLESTR("SectorSize"), 
            OLESTR("Sector size"), 
            OLESTR("default"));

    CBaseCmdlineObj *CArgList[] =
    {
        &CCreateDF,
        &COpenDF,
        &CSectorSize
    } ;

    CCmdline CCmdlineArgs(argc, argv);

    if (CMDLINE_NO_ERROR != CCmdlineArgs.QueryError())
    {
        hr = E_FAIL ;
    }

    if (S_OK == hr)
    {
        if (CMDLINE_NO_ERROR !=
                CCmdlineArgs.Parse(
                CArgList,
                ( sizeof(CArgList) / sizeof(CArgList[0]) ),
                FALSE))
        {
            hr = E_FAIL ;
        }
    }

    if (S_OK == hr)
    {
        // look for Create
        // default as docfile
        if (TRUE == CCreateDF.IsFound ())
        {
            if (NULL == _olestricmp (CCreateDF.GetValue (), OLESTR(SZ_NSSFILE)))
            {
                g_uCreateType = TSTTYPE_NSSFILE;
            }
            else if (NULL == _olestricmp (CCreateDF.GetValue (), OLESTR(SZ_DOCFILE)))
            {
                g_uCreateType = TSTTYPE_DOCFILE;
            }
            else if (NULL == _olestricmp (CCreateDF.GetValue (), OLESTR(SZ_FLATFILE)))
            {
                g_uCreateType = TSTTYPE_FLATFILE;
                g_uOpenType   = TSTTYPE_FLATFILE;
            }
        }

        // look for Open
        // default as docfile
        if (TRUE == COpenDF.IsFound ())
        {
            if (NULL == _olestricmp (COpenDF.GetValue (), OLESTR(SZ_NSSFILE)))
            {
                g_uOpenType = TSTTYPE_NSSFILE;
            }
            else if (NULL == _olestricmp (COpenDF.GetValue (), OLESTR(SZ_DOCFILE)))
            {
                g_uOpenType = TSTTYPE_DOCFILE;
            }
            else if (NULL == _olestricmp (COpenDF.GetValue (), OLESTR(SZ_FLATFILE)))
            {
                g_uCreateType = TSTTYPE_FLATFILE;
                g_uOpenType   = TSTTYPE_FLATFILE;
            }
        }

        // look for Sector size 
        // default as SECTORTYPE_DEDAULT 
        if (TRUE == CSectorSize.IsFound ())
        {
            if (NULL == _olestricmp (CSectorSize.GetValue (), OLESTR(SZ_DEFAULT)))
            {
                g_ulSectorSize = DEFAULT_SECTOR_SIZE;
            }
            else if (NULL == _olestricmp (CSectorSize.GetValue (), OLESTR(SZ_LARGE)))
            {
                g_ulSectorSize = LARGE_SECTOR_SIZE;
            }
        }
    }

    // Now check the registry for spewage reasons
    StgCheckRegistry ();

    // finally, is the disk sub-system compatible with NSS
    if (FALSE == StgCheckVolumeInformation ())
    {
        fRet = FALSE;
    }

    return fRet;
}

BOOL  StgInitStgFormatWrapper (TCHAR *pCreateType, TCHAR *pOpenType)
{
    BOOL fRet = TRUE;
    if (0 == _tcscmp(pCreateType, TSZ_NSSFILE))
    {
        g_uCreateType = TSTTYPE_NSSFILE;
    }
    else if (0 == _tcscmp(pCreateType, TSZ_DOCFILE))
    {
        g_uCreateType = TSTTYPE_DOCFILE;
    }
    else if (0 == _tcscmp(pCreateType, TSZ_FLATFILE))
    {
        g_uCreateType = TSTTYPE_FLATFILE;
        g_uOpenType   = TSTTYPE_FLATFILE;
    }

    if (0 == _tcscmp(pOpenType, TSZ_NSSFILE))
    {
        g_uOpenType = TSTTYPE_NSSFILE;
    }
    else if (0 == _tcscmp(pOpenType, TSZ_DOCFILE))
    {
        g_uOpenType = TSTTYPE_DOCFILE;
    }
    else if (0 == _tcscmp(pOpenType, TSZ_FLATFILE))
    {
        g_uCreateType = TSTTYPE_FLATFILE;
        g_uOpenType   = TSTTYPE_FLATFILE;
    }

    // Now check the registry, and override where necessary
    StgCheckRegistry ();

    // finally, is the disk sub-system compatible with NSS
    if (FALSE == StgCheckVolumeInformation ())
    {
        fRet = FALSE;
    }

    return fRet;
}

//********************************************************************
// Function:  StgCheckRegistryFor
//
// Synopsis:  Check the registry to see if OLE will create nssfiles.
//            Adjust g_fRegistrySet to whether NSS regvalues are set.
// 
// Return:    TRUE  if ok
//            FALSE if registry not set for NSS files
// 
//********************************************************************
BOOL  StgCheckRegistry (void)
{
    HKEY    hKey;
    LONG    lErr;
    TCHAR   tszData[10];
    DWORD   dwType, dwSize;
    LPCTSTR ptszRegKey = {TEXT("Software\\Microsoft\\OLE")};
    LPCTSTR ptszNssRegValue= {TEXT("EnableNtfsStructuredStorage")};
    LPCTSTR ptszCnssRegValue= {TEXT("EnableCNSS")};

    DH_FUNCENTRY (NULL, DH_LVL_DFLIB, TEXT("StgCheckRegistryForNSS"));

    // get whats in the registry
    lErr = RegOpenKeyEx (HKEY_LOCAL_MACHINE, ptszRegKey, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS == lErr)
    {
        dwSize = sizeof (tszData);
        lErr = RegQueryValueEx (hKey, 
                ptszNssRegValue, 
                0, 
                &dwType, 
                (LPBYTE)tszData, 
                &dwSize);
        if (ERROR_SUCCESS != lErr)
        {
            DH_TRACE ((DH_LVL_DFLIB, TEXT("RegQueryValueEx error; lErr=%#lx"), lErr));
        }
        else
        {
            // bit 2 /createas:
            if (TCHAR('Y') == tszData[0] || TCHAR('y') == tszData[0])
            {
                g_fRegistryBits |= REG_CREATE_AS;
            }
            else if (TCHAR('N') == tszData[0] || TCHAR('n') == tszData[0])
            {
                g_fRegistryBits &= ~REG_CREATE_AS;
            }
            // bit 1 /openas:
            if (TCHAR('Y') == tszData[1] || TCHAR('y') == tszData[1])
            {
                g_fRegistryBits |= REG_OPEN_AS;
            }
            else if (TCHAR('N') == tszData[1] || TCHAR('n') == tszData[1])
            {
                g_fRegistryBits &= ~REG_OPEN_AS;
            }
        }

        dwSize = sizeof (tszData);
        tszData[0] = tszData[1] = 0;
        lErr = RegQueryValueEx (hKey, 
                ptszCnssRegValue, 
                0, 
                &dwType, 
                (LPBYTE)tszData, 
                &dwSize);
        if (ERROR_SUCCESS != lErr)
        {
            DH_TRACE ((DH_LVL_DFLIB, TEXT("RegQueryValueEx error; lErr=%#lx"), lErr));
        }
        else
        {
            // bit 3 enable cnss
            if (TCHAR('Y') == tszData[0] || TCHAR('y') == tszData[0])
            {
                g_fRegistryBits |= REG_CNSS_ENABLE;
            }
            else if (TCHAR('N') == tszData[0] || TCHAR('n') == tszData[0])
            {
                g_fRegistryBits &= ~REG_CNSS_ENABLE;
            }
        }
        RegCloseKey (hKey);
    }
    else
    {
        DH_TRACE ((DH_LVL_DFLIB, TEXT("RegOpenKeyEx error; lErr=%#lx"), lErr));
    }

    return TRUE;
}

//********************************************************************
// Function:  StgCheckVolumeInformation
//
// Synopsis:  If not doing docfiles, check the disk sub-system. 
//            If not NTFS, spew
// 
// Return:    TRUE  if ok
//            FALSE if doing nss, disk not ntfs
// 
//********************************************************************
BOOL  StgCheckVolumeInformation (void)
{
    LPTSTR  pstrType = TSZ_DOCFILE;
    TCHAR   pFileSystemNameBuffer[10];
    DWORD   dwFileSystemFlags;
    BOOL    fVolInfo = FALSE;
    BOOL    fNTFS    = FALSE;

    // if we are forcing an nssfile somewhere, or we 
    // are going for default of nssfile
    if (TSTTYPE_NSSFILE == g_uOpenType || TSTTYPE_NSSFILE == g_uCreateType)
    {
        fVolInfo = GetVolumeInformation (NULL,
                NULL,
                0,
                NULL,
                0,
                &dwFileSystemFlags,
                pFileSystemNameBuffer,
                ARRAYSIZE (pFileSystemNameBuffer));

        // if we can detect the disk subsystem
        if (0 != fVolInfo)
        {
            // if not NTFS, 'fix' two flags
            if (0 == lstrcmp (pFileSystemNameBuffer, TEXT("NTFS")))
            {
                fNTFS = TRUE;
            }
        }

        if (FALSE == fNTFS)
        {
            DH_TRACE ((DH_LVL_ALWAYS, 
                    TEXT("WARNING: Disk subsystem not NTFS! NSS not possible!")));
        }
    }
    else
    {
        fNTFS = TRUE;
    }

    return fNTFS;
}

// hook the stgcreatedocfile stgopenstorage apis for debugging purposes -scousens

#ifdef _HOOK_STGAPI_

#undef StgCreateDocfile
#undef StgOpenStorage

//---------------------------------------------------------------
// @doc
// @func    mStgCreateDocfile |
//          Wraps calls to StgCreateDocfile. This is a mechanism
//          to conditionally get current code to call the 
//          StgCreateStorageEx API without changing the existing 
//          codebase.
//
// @rdesc   returns whatever the called function returned.
//
// @comm    condition set in StgInitStgFormatWrap
//
// @comm    The parameters that differ between the two APIs 
//          are essentially ignored/defaulted. 
//---------------------------------------------------------------
HRESULT mStgCreateDocfile(const OLECHAR FAR* pwcsName,
            DWORD grfMode,
            DWORD reserved,
            IStorage FAR * FAR *ppstgOpen)
{
    HRESULT hr;
   
    // With 1795 changes to "dwReserved" Parameter to -> version number,
    // sector size (allowed is 512, 4096 only) and reserved parameter as
    // typedef struct tagSTGOPTIONS
    // {
    //  USHORT usVersion;            // Version 1
    //  USHORT reserved;             // must be 0 for padding
    //  ULONG ulSectorSize;          // docfile header sector size (512)
    // } STGOPTIONS;

    STGOPTIONS  stgOptions;
    stgOptions.usVersion = 1;   
    stgOptions.reserved = (USHORT)reserved; // Take from function arg 
    stgOptions.ulSectorSize = g_ulSectorSize; 

    DH_FUNCENTRY (NULL, DH_LVL_STGAPI, TEXT("mStgCreateDocfile:"));

    // If default, use old api
    if (TSTTYPE_DEFAULT == g_uCreateType)
    {
        hr = StgCreateDocfile (pwcsName,
                grfMode,
                reserved,
                ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgCreateDocfile; mode=%#lx; hr=%#lx"), grfMode, hr));
    }
    // force docfile with StgCreateStorageEx (STGFMT_DOCFILE)
    else if (TSTTYPE_DOCFILE == g_uCreateType)
    {
        hr = StgCreateStorageEx (pwcsName,
                grfMode,
                STGFMT_DOCFILE,  //force it to be a docfile
                0,
                &stgOptions,
                (void*)reserved,
                IID_IStorage,
                (void**)ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgCreateStorageEx (df); mode=%#lx; sectorsize=%#lx; hr=%#lx"), grfMode, g_ulSectorSize,hr));
    }
    // force flatfile with StgCreateStorageEx (STGFMT_FILE)
    else if (TSTTYPE_FLATFILE == g_uCreateType)
    {
        hr = StgCreateStorageEx (pwcsName,
                grfMode,
                STGFMT_FILE,  //force it to be a flatfile
                0,
                &stgOptions,
                (void*)reserved,
                IID_IStorage,
                (void**)ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgCreateStorageEx (df); mode=%#lx; sectorsize=%#lx; hr=%#lx"), grfMode, g_ulSectorSize,hr));
    }
    // else try force nssfile with StgCreateStorageEx () 
    else 
    {
        hr = StgCreateStorageEx (pwcsName,
                grfMode,
                STGFMT_GENERIC,  //force it to be a nssfile (if possible)
                0,
                &stgOptions,
                (void*)reserved,
                IID_IStorage,
                (void**)ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgCreateStorageEx (df); mode=%#lx; hr=%#lx, sectorsize=%#lx"), grfMode, hr, g_ulSectorSize));
    }
    return (hr);
}

//---------------------------------------------------------------
// @doc
// @func    mStgOpenStorage |
//          Wraps calls to StgOpenStorage. This is a mechanism
//          to conditionally get current code to call the 
//          StgOpenStorageEx API without changing the existing 
//          codebase.
//
// @rdesc   returns whatever the called function returned.
//
// @comm    condition set in StgInitStgFormatWrap
//
// @comm    The parameters that differ between the two APIs 
//          are essentially ignored/defaulted. 
//---------------------------------------------------------------
HRESULT mStgOpenStorage (const OLECHAR FAR* pwcsName,
              IStorage FAR *pstgPriority,
              DWORD grfMode,
              SNB snbExclude,
              DWORD reserved,
              IStorage FAR * FAR *ppstgOpen)
{
    HRESULT hr;

    DH_FUNCENTRY (NULL, DH_LVL_STGAPI, TEXT("mStgOpenStorage:"));

    // If default, or we have snbs or priority stgs, use old api
    if (TSTTYPE_DEFAULT == g_uOpenType || 
            NULL != pstgPriority ||
            NULL != snbExclude)
    {
        hr = StgOpenStorage (pwcsName,
                pstgPriority,
                grfMode,
                snbExclude,
                reserved,
                ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgOpenStorage; mode=%#lx; hr=%#lx"), grfMode, hr));
    }
    // Force docfile with StgOpenStorageEx (STGFMT_DOCFILE) 
    else if (TSTTYPE_DOCFILE == g_uOpenType)
    {
        hr = StgOpenStorageEx (pwcsName,
                grfMode,
                STGFMT_DOCFILE,  //force it to be a docfile
                0,
                NULL,           // (void*)reserved -> STGOPTIONS*, BUGBUG
                (void*)reserved,
                IID_IStorage,
                (void**)ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgOpenStorageEx (df); mode=%#lx; hr=%#lx"), grfMode, hr));
    }
    // Force flatfile with StgOpenStorageEx (STGFMT_FILE) 
    else if (TSTTYPE_FLATFILE == g_uOpenType)
    {
        hr = StgOpenStorageEx (pwcsName,
                grfMode,
                STGFMT_FILE,  //force it to be a flatfile
                0,
                NULL,           // (void*)reserved -> STGOPTIONS*, BUGBUG
                (void*)reserved,
                IID_IStorage,
                (void**)ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgOpenStorageEx (df); mode=%#lx; hr=%#lx"), grfMode, hr));
    }
    // else try force nssfile with StgOpenStorageEx () 
    else
    {
        hr = StgOpenStorageEx (pwcsName,
                grfMode,
                STGFMT_GENERIC,  //force it to be a nssfile (if possible)
                0,
                NULL,           // (void*)reserved -> STGOPTIONS*, BUGBUG
                (void*)reserved,
                IID_IStorage,
                (void**)ppstgOpen);
        DH_TRACE((DH_LVL_STGAPI, TEXT("StgOpenStorageEx(nss); mode=%#lx; hr=%#lx"), grfMode, hr));
    }
    return (hr);
}
#endif  /* _HOOK_STGAPI_ */

#endif /* _OLE_NSS_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\createdf.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       init.cxx
//
//  Contents:   OLE storage base tests
//
//  Functions:  main 
//
//  History:    26-Feb-1997     SCousens    Created.
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug object declaration
DH_DECLARE;


// Private function
HRESULT MakeVirtualDF (
    IN  ChanceDF         *pChanceDF,
    OUT VirtualDF       **ppVirtualDF);

//----------------------------------------------------------------------------
//
//    FUNCTION: CreateTestDocfile [multiple]
//
//    PARAMS:   ppVirtualDF     - bucket for pVirtualDF  
//              pcdfd           - CDFD for chancedf
//              pCmdLine        - CommandLine (default)  
//              pFileName       - name of docfile (default)
//
//              ulSeed          - seed (to get name)
//
//    SYNOPSIS: Create a test docfile with semantics defined in 
//              given CDFD. 
//              Look on CmdLine (either given or result of 
//              GetCommandLine() call) to override values.
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    NOTES:    
//
//    HISTORY:  19-Mar-1997     SCousens     Created.
//
//----------------------------------------------------------------------------

HRESULT CreateTestDocfile (
        OUT VirtualDF   **ppvdf, 
        IN  CDFD         *pcdfd, 
        IN  LPTSTR        pCmdLine,
        IN  LPTSTR        pFileName)
{

    HRESULT          hr           = S_OK;
    ChanceDF        *pChanceDF    = NULL;
    LPTSTR           pDocFileName = NULL;
    LPTSTR           ptCommandLine= NULL;
    int              argc         = 0;
    char **          argv         = NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, TEXT("CreateTestDocfile"));
    DH_VDATEPTRIN  (pcdfd, CDFD);
    DH_VDATEPTROUT (ppvdf, VirtualDF *);

    *ppvdf = NULL;

    // Always create this. 
    // Create the new ChanceDocFile tree that would consist of chance nodes.
    pChanceDF = new ChanceDF();
    if(NULL == pChanceDF)
    {
        hr = E_OUTOFMEMORY;
    }
    DH_HRCHECK_ABORT (hr, TEXT("new ChanceDF"));

    // initialize chancedf with our desired cdfd
    hr = pChanceDF->Init (pcdfd);
    DH_HRCHECK_ABORT (hr, TEXT("pChanceDF->Init"));

    // Create argc/argv from either given cmdline, or GetCommandLine
    ptCommandLine = (NULL == pCmdLine) ? GetCommandLine () : pCmdLine;
    if (NULL != ptCommandLine)
    {
        LPSTR paCommandLine = NULL;
        hr = TStringToAString (ptCommandLine, &paCommandLine);
        DH_HRCHECK_ABORT (hr, TEXT("TStringToAString"));

        hr = CmdlineToArgs (paCommandLine, &argc, &argv);
        DH_HRCHECK_ABORT (hr, TEXT("CmdlineToArgs"));
        delete []paCommandLine;
    }

    // Create ChanceDF, using filename and cmdline override
    hr = pChanceDF->CreateFromParams (argc, argv, pFileName);
    DH_HRCHECK_ABORT (hr, TEXT("pChanceDF->CreateFromParams"));

    //cleanup argc/argv
   if (NULL != argv)
   {
       for (int count=0; count<argc; count++)
       {
           delete []argv[count];
       }
       delete []argv;
   }

    // Make VirtualDF
    hr = MakeVirtualDF (pChanceDF, ppvdf);
    DH_HRCHECK_ABORT (hr, TEXT("MakeVirtualDF"));

ErrReturn:
    // cleanup 
    delete []pDocFileName;
    delete pChanceDF;

    return hr;
}

//----------------------------------------------------------------------------
//
//    FUNCTION: CreateTestDocfile [multiple]
//
//    PARAMS:   ppVirtualDF     - bucket for pVirtualDF  
//              uType           - predefinede type for docfile
//              ulSeed          - seed
//              pCmdLine        - CommandLine (default)  
//              pFileName       - name of docfile (default)
//
//    SYNOPSIS: Create a test docfile with predefined semantics.
//              Create a CDFD and call CreateTestDocfile with
//              created CDFD
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    NOTES:    
//
//    HISTORY:  19-Mar-1997     SCousens     Created.
//
//----------------------------------------------------------------------------
HRESULT CreateTestDocfile (
        OUT VirtualDF   **ppvdf, 
        IN  DWORD         uType, 
        IN  ULONG         ulSeed,
        IN  LPTSTR        pCmdLine,
        IN  LPTSTR        pFileName)
{

    HRESULT          hr           = S_OK;
    CDFD             cdfd;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, TEXT("CreateTestDocfile"));
    DH_VDATEPTROUT (ppvdf, VirtualDF *);

    *ppvdf = NULL;

    // default modes
    cdfd.dwRootMode = cdfd.dwStgMode = cdfd.dwStmMode = 
            STGM_READWRITE  |
            STGM_DIRECT     |
            STGM_SHARE_EXCLUSIVE;

    cdfd.ulSeed = ulSeed;

    //FIXIT: BUGBUG: we need to define all the types of docfiles needed
    switch (uType)
    {
        case DF_TINY:
            cdfd.cDepthMin = 0;
            cdfd.cDepthMax = 0;
            cdfd.cStgMin   = 0;
            cdfd.cStgMax   = 0;
            cdfd.cStmMin   = 0;
            cdfd.cStmMax   = 3;
            cdfd.cbStmMin  = 0;
            cdfd.cbStmMax  = 100;
            break;

        case DF_SMALL:
            cdfd.cDepthMin = 0;
            cdfd.cDepthMax = 1;
            cdfd.cStgMin   = 0;
            cdfd.cStgMax   = 1;
            cdfd.cStmMin   = 0;
            cdfd.cStmMax   = 5;
            cdfd.cbStmMin  = 0;
            cdfd.cbStmMax  = 4000;
            break;

        case DF_MEDIUM:
            cdfd.cDepthMin = 1;
            cdfd.cDepthMax = 3;
            cdfd.cStgMin   = 1;
            cdfd.cStgMax   = 4;
            cdfd.cStmMin   = 1;
            cdfd.cStmMax   = 6;
            cdfd.cbStmMin  = 0;
            cdfd.cbStmMax  = 10240;
            break;

        case DF_LARGE:
            cdfd.cDepthMin = 2;
            cdfd.cDepthMax = 5;
            cdfd.cStgMin   = 2;
            cdfd.cStgMax   = 10;
            cdfd.cStmMin   = 0;
            cdfd.cStmMax   = 8;
            cdfd.cbStmMin  = 0;
            cdfd.cbStmMax  = 20480;
            break;

        case DF_HUGE:
            cdfd.cDepthMin = 5;
            cdfd.cDepthMax = 10;
            cdfd.cStgMin   = 5;
            cdfd.cStgMax   = 30;
            cdfd.cStmMin   = 0;
            cdfd.cStmMax   = 10;
            cdfd.cbStmMin  = 0;
            cdfd.cbStmMax  = 40000;
            break;

        case DF_DIF:
            cdfd.cDepthMin = 5;
            cdfd.cDepthMax = 10;
            cdfd.cStgMin   = 7;
            cdfd.cStgMax   = 10;
            cdfd.cStmMin   = 10;
            cdfd.cStmMax   = 15;
            cdfd.cbStmMin  = 100000;
            cdfd.cbStmMax  = 150000;
            break;

        default:
            hr = E_FAIL;
            break;
    }
    DH_HRCHECK_ABORT (hr, TEXT("set CDFD"));

    hr = CreateTestDocfile (ppvdf, 
            &cdfd, 
            pCmdLine,
            pFileName);
    DH_HRCHECK (hr, TEXT("CreateTestDocfile"));

ErrReturn:
    return hr;
}

//----------------------------------------------------------------------------
//    FUNCTION: MakeVirtualDF
//
//    PARAMS:   pChanceDF   - ptr to pChanceDF  
//              ppVirtualDF - bucket for pVirtualDF  
//
//    SYNOPSIS: This function should be called by
//              CreateTestDocfile
//              We need to create a storage file
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    HISTORY:  28-Feb-1997     SCousens     Created.
//----------------------------------------------------------------------------
HRESULT MakeVirtualDF (
    IN  ChanceDF         *pChanceDF,
    OUT VirtualDF       **ppVirtualDF)
{
    HRESULT          hr           = S_OK;
    HRESULT          hr2          = S_OK;
    VirtualCtrNode  *pvcnRoot     = NULL;

    // This is internal func. Shouldnt have to do this.
    DH_ASSERT (NULL != pChanceDF); 
    DH_ASSERT (NULL != ppVirtualDF); 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("MakeVirtualDF"));
    DH_VDATEPTRIN  (pChanceDF, ChanceDF);
    DH_VDATEPTROUT (ppVirtualDF, VirtualDF *);

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.
    *ppVirtualDF = new VirtualDF(); 
    if (NULL == *ppVirtualDF)
    {
        hr = E_OUTOFMEMORY;
    }
    DH_HRCHECK_ABORT (hr, TEXT("new VirtualDF"));

    // Generate inmemory tree and docfile on disk
    hr = (*ppVirtualDF)->GenerateVirtualDF (pChanceDF, &pvcnRoot);
    DH_HRCHECK_ABORT (hr, TEXT("pVirtualDF->GenerateVirtualDF"));

    // Commit all stms and stgs in newly created storage file
    hr = ParseVirtualDFAndCommitAllOpenStgs (pvcnRoot, 
            STGC_DEFAULT, 
            NODE_INC_TOPSTG);
    DH_HRCHECK (hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs"));

ErrReturn:
    // close the file
    hr2 = ParseVirtualDFAndCloseOpenStgsStms (pvcnRoot, NODE_INC_TOPSTG);
    DH_HRCHECK (hr2, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    hr = FirstError (hr, hr2);

    return hr;
}

//----------------------------------------------------------------------------
//
//    FUNCTION: CleanupTestDocfile 
//
//    PARAMS:   pVirtualDF  - pVirtualDF to be deleted
//              fDeleteFile - Delete file?
//
//    SYNOPSIS: Cleanup all items that were setup in CreateTestDocfile
//               - virtualdf
//               - delete docfile on disk (if there were no errors)
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    NOTES:    Caller must NULLIFY their pVirtualDF pointer passed in
//              as this function deletes it.
//
//    HISTORY:  28-Feb-1997     SCousens     Created.
//
//----------------------------------------------------------------------------
HRESULT CleanupTestDocfile (
    IN  VirtualDF       *pVirtualDF,
    IN  HRESULT          hrDeleteFile)
{                       
    LPTSTR          pFileName   =  NULL;
    HRESULT         hr          =  S_OK;
    VirtualCtrNode *pvcnRoot;

    DH_FUNCENTRY (&hr, DH_LVL_DFLIB, TEXT("CleanupTestDocfile"));
    DH_VDATEPTRIN (pVirtualDF, VirtualDF);

    // Make sure everything in the docfile is closed
    pvcnRoot = pVirtualDF->GetVirtualDFRoot ();
    if (NULL != pvcnRoot)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms (pvcnRoot, NODE_INC_TOPSTG);
        DH_HRCHECK (hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    // Get file name
    if ((S_OK == hrDeleteFile || ALWAYS == hrDeleteFile) && NULL != pvcnRoot)
    {
        pFileName= new TCHAR[_tcslen (pVirtualDF->GetDocFileName ())+1];
        if (pFileName != NULL)
        {
            _tcscpy (pFileName, pVirtualDF->GetDocFileName ());
        }
    }

    // Delete Virtual docfile tree
    if (NULL != pVirtualDF)
    {
        hr = pVirtualDF->DeleteVirtualDocFileTree (pvcnRoot);
        DH_HRCHECK (hr, TEXT("pVirtualDF->DeleteVirtualFileDocTree"));

        delete pVirtualDF;
        pVirtualDF = NULL;
    }

    // Delete the docfile on disk
    if ((S_OK == hr) && (NULL != pFileName))
    { 
        if (FALSE == DeleteFile(pFileName))
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            DH_HRCHECK (hr, TEXT("DeleteFile"));
        }
    }

    // Delete the docfile name
    if (NULL != pFileName)
    {
        delete []pFileName;
        pFileName = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\virtdf.cxx ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  All rights reserved.
//
//  File:       virtdf.cxx
//
//  Contents:   Implementation for in-memory Virtual Docfile class.
//
//  Classes:    VirtualDF
//
//  Functions:  VirtualDF (public)
//              ~VirtualDF (public)
//              GenerateVirtualDF (public)
//              DeleteVirtualDocFileTree (public)
//              GenerateVirtualDFRoot (protected)
//              GrowVirtualDFTree (protected)
//              DeleteVirtualDocFileSubTree (protected)
//              DeleteVirtualCtrNodeStreamTree (protected)
//              AppendVirtualStmNodesToVirtualCtrNode (protected)
//              AppendVirtualCtrNode (protected)
//              AppendVirtualStmNode (protected)
//              AdjustTreeOnStgMoveElement (public)
//              AdjustTreeOnStmMoveElement (public)
//              AdjustTreeOnStgCopyElement(public)
//              AdjustTreeOnStmCopyElement(public)
//              AdjustTreeOnCopyTo (public)
//              CopyVirtualDocFileTree (public)
//              CopyVirtualDFRooti (protected)
//              CopyGrowVirtualDFTree (protected)
//              CopyAppendVirtualStmNodesToVirtualCtrNode (protected)
//              CopyAppendVirtualCtrNode (protected)
//              CopyAppendVirtualStmNode (protected)
//              Associate (public)
//              DeleteVirtualCtrNodeStreamNode (public)
//              CommitCloseThenOpenDocfile (public)
//
//  History:    DeanE    21-Mar-96   Created
//              Narindk  22-Apr-96   Added more functions. 
//              SCousens  2-Feb-97   Added for Cnvrs/NSS 
//              SCousens  8-Apr-98   Handle stg collisions on createdf
//              georgis   2-Apr-98   Added support for large streams
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug object declaration

DH_DECLARE;

//+--------------------------------------------------------------------------
//  Member:     VirtualDF::VirtualDF, public [multiple]
//
//  Synopsis:   Constructor. This method cannot fail.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   21-Mar-96   Created
//              SCousens 2-Feb-97   Added for Cnvrs/NSS 
//---------------------------------------------------------------------------

VirtualDF::VirtualDF() : _ptszName(NULL),
                         _pvcnRoot(NULL),
                         _pdgi(NULL),
                         _pgdu(NULL),
                         _ulSeed(0),
                         _dwRootMode(0),
                         _dwStgMode(0),
                         _dwStmMode(0),
                         _dwStgType(STGTYPE_DOCFILE),
                         _pDBCSStrGen(NULL)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::VirtualDF"));
}

//+--------------------------------------------------------------------------
//  Member:     VirtualDF::VirtualDF, public [multiple]
//
//  Synopsis:   Constructor. This method cannot fail.
//
//  Arguments:  _fUseStgEx - whether to use the Ex apis
//
//  Returns:    Nothing.
//
//  History:    SCousens  4-Apr-97   Added for Cnvrs/NSS 
//---------------------------------------------------------------------------
VirtualDF::VirtualDF(STGTYPE dwStgFmt) : _ptszName(NULL),
                         _pvcnRoot(NULL),
                         _pdgi(NULL),
                         _pgdu(NULL),
                         _ulSeed(0),
                         _dwRootMode(0),
                         _dwStgMode(0),
                         _dwStmMode(0),
                         _dwStgType(dwStgFmt),
                         _pDBCSStrGen(NULL)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::VirtualDF"));
}


//+--------------------------------------------------------------------------
//  Member:     VirtualDF::~VirtualDF, public
//
//  Synopsis:   Destructor.  Frees resources associated with this docfile.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   21-Mar-96   Created
//---------------------------------------------------------------------------

VirtualDF::~VirtualDF()
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::~VirtualDF"));

    if(NULL != _pdgi)
    {
        delete _pdgi;
        _pdgi = NULL;
    }

    if(NULL != _pgdu)
    {
        delete _pgdu;
        _pgdu = NULL;
    }

    if(NULL != _ptszName)
    {
        delete _ptszName;
        _ptszName = NULL;
    }

    if(NULL != _pDBCSStrGen)
    {
        delete _pDBCSStrGen;
        _pDBCSStrGen = NULL;
    }
}


//----------------------------------------------------------------------------
//  Member:     VirtualDF::GenerateVirtualDF, public
//
//  Synopsis:   Creates a VirtualDocFile tree consisting of VirtualCtrNode
//              node(s) and VirtualStmNodes(s) based on the ChanceDocFile
//              created prior to this.
//
//  Arguments:  [pChanceDF] - Pointer to ChanceDocFile tree 
//              [ppvcnRoot] - Returned root of VirtualDocFile tree
//
//  Returns:    HRESULT 
//
//  History:    Narindk   22-Apr-96   Created
//              SCousens   2-Feb-97   Added for Cnvrs/NSS 
//
//  Notes:      This function calls GenerateVirtualDFRoot to generate Virtual
//              DF tree's root and GrowVirtualDFTree to generate rest of the
//              tree. If the function succeeds, it returns pointer to the root
//              of VirtualDocFile generated in ppvcnRoot parameter.
//              - Get seed from ChanceDocFile tree and construct DG_INTEGER &
//                DG_STRING objects.
//              - Get the modes for creating various storages/streams from thw
//                ChanceDocFile tree.
//              - Get name of rootdocfile, if given, from chancedocfile tree.
//              - Call GenerateVirtualDFRoot.
//              - Call GrowVirtualDFTree
//              - If successful, assign root of new VirtualDF in *ppvcnRoot. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::GenerateVirtualDF(
    ChanceDF        *pChanceDF, 
    VirtualCtrNode  **ppvcnRoot)
{
    HRESULT             hr                  =   S_OK;
    LPTSTR              ptszName            =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::GenerateVirtualDF"));

    DH_VDATEPTRIN(pChanceDF, ChanceDF) ;
    DH_VDATEPTROUT(ppvcnRoot, PVCTRNODE) ;

    DH_ASSERT(NULL != pChanceDF);
    DH_ASSERT(NULL != ppvcnRoot);


    if(S_OK == hr)
    {
        *ppvcnRoot = NULL;

        // Create a DataGen obj of type DG_INTEGER that will allow us to fill 
        // count parameters of VirtualDocFile tree components, excepting those 
        // which we got from already created ChanceDocFile tree.  Use the
        // same seed value as was used in creation of ChanceDocFile tree.
  
        // Get the value of seed used to create ChanceDocFile tree and store it.

        _ulSeed = pChanceDF->GetSeed();
 
        _pdgi = new(NullOnFail) DG_INTEGER(_ulSeed);

        if (NULL == _pdgi)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random strings.

        _pgdu = new(NullOnFail) DG_STRING(_ulSeed);

        if (NULL == _pgdu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Get the value of different creation modes.

        _dwRootMode = pChanceDF->GetRootMode();
        _dwStgMode  = pChanceDF->GetStgMode();
        _dwStmMode  = pChanceDF->GetStmMode();

        // Get user provided name for DocFile, if any

        ptszName = pChanceDF->GetDocFileName();

        if(NULL != ptszName)
        {
            _ptszName = new TCHAR[_tcslen(ptszName)+1];

            if (_ptszName == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                _tcscpy(_ptszName, ptszName);
            }
        }
    }

    if (S_OK == hr)
    {
        // Generates the root VirtualCtrNode for the VirtualDocFile tree.

        hr = GenerateVirtualDFRoot(pChanceDF->_pcnRoot);

        DH_HRCHECK(hr, TEXT("GenerateVirtualDFRoot")) ;
    }

    if (S_OK == hr)
    {
        // Generate remaining VirtualDF tree based on the ChanceDF tree.

        hr = GrowVirtualDFTree(pChanceDF->_pcnRoot, _pvcnRoot);

        DH_HRCHECK(hr, TEXT("GrowVirtualDFTree")) ;
    }

    // Fill the out parameter

    if(S_OK == hr)
    {
        *ppvcnRoot = _pvcnRoot;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::GenerateVirtualDFRoot, protected
//
//  Synopsis:   Creates the root VirtualCtrNode for the VirtualDocFile tree. 
//
//  Arguments:  [pcnRoot] - Pointer to root of ChanceDocFile tree 
//
//  Returns:    HRESULT 
//
//  History:    Narindk   22-Apr-96   Created
//              SCousens   2-Feb-97   Added for Cnvrs/NSS 
//
//  Notes:      - Generate a random name for RootDocFile if it is not provided
//                in the test.
//              - Creates VirtualCtrNode object and initializes it with info
//                based on corresponding ChanceDocFile root.
//              - Create real IStorage corresponding to this VirtualCtrNode.
//              - Creates IStreams corresponding to this VirtualCtrNode, if
//                required.
//              - Calculates in memory CRC for this IStorage and assigns it 
//                to _dwCRC variable.
//---------------------------------------------------------------------------

HRESULT VirtualDF::GenerateVirtualDFRoot(ChanceNode *pcnRoot)
{
    HRESULT hr      =   S_OK;

    DH_VDATEPTRIN(pcnRoot, ChanceNode) ; 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::GenerateVirtualDFRoot"));

    DH_ASSERT(NULL != pcnRoot);
    
    if(S_OK == hr)
    {
        if(NULL == _ptszName) 
        {
            // Create a random file name for this root. 

            // Hack for FE DBCS systems

            _pDBCSStrGen = new(NullOnFail) CDBCSStringGen;

            if (NULL == _pDBCSStrGen)
            {
                hr = E_OUTOFMEMORY;
            }

            if(S_OK == hr)
            {
                hr = _pDBCSStrGen->Init(_ulSeed);
            }

            if((S_OK == hr) && (_pDBCSStrGen->SystemIsDBCS()))
            {
                hr = _pDBCSStrGen->GenerateRandomFileName(&_ptszName);

                if(S_OK != hr)
                {
                    DH_TRACE((DH_LVL_TRACE1, 
                             TEXT("Unable to generate DBCS name. Fall back to GenerateRandomName")));

                    hr = GenerateRandomName(_pgdu, MINLENGTH, MAXLENGTH, &_ptszName);    
                }
            }
            else
            {
                hr = GenerateRandomName(_pgdu, MINLENGTH, MAXLENGTH, &_ptszName);
            }

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }
    }
 
    // Generate VirtualCtrNode for the root node.

    if(S_OK == hr)
    {
        _pvcnRoot = new VirtualCtrNode();

        if (NULL == _pvcnRoot)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        hr = _pvcnRoot->Init(
                _ptszName, 
                pcnRoot->_cStorages, 
                pcnRoot->_cStreams);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Init")) ;
    }

    // Call VirtualCtrNode::CreateRoot to create a corresponding Root Storage
    // on disk.

    if(S_OK == hr)
    {
        if (STGTYPE_DOCFILE == _dwStgType)
        {
            hr = _pvcnRoot->CreateRoot(
                    _dwRootMode | STGM_CREATE,
                    0);
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::CreateRoot")) ;
        }
        else
        {
            hr = _pvcnRoot->CreateRootEx(
                    _dwRootMode | STGM_CREATE,
                    STGFMT_GENERIC,
                    0,
                    NULL,
                    NULL);
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::CreateRootEx")) ;
        }

        // Generate VirtualStmNode(s) depending upon if root has streams in it.

        DH_ASSERT((pcnRoot->_cStreams) == (_pvcnRoot->_cStreams));
    }

 
    if ((S_OK == hr) && (0 != _pvcnRoot->_cStreams))
    {
       hr = AppendVirtualStmNodesToVirtualCtrNode(
                _pvcnRoot->_cStreams,
                _pvcnRoot,
                pcnRoot->_cbMinStream,
                pcnRoot->_cbMaxStream);

       DH_HRCHECK(hr, TEXT("AppendVirtualStmNodesToVirtualCtrNode")) ;

    }

    // Calculate the CRC for storage name

    if(S_OK == hr)
    { 
        hr = CalculateInMemoryCRCForStg(_pvcnRoot, &(_pvcnRoot->_dwCRC));

        DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStg")) ;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::GrowVirtualDFTree, protected
//
//  Synopsis:   Creates the ramaining VirtualDocFile tree. 
//
//  Arguments:  [pcnCurrent] - Pointer to current node of ChanceDocFile tree 
//              [pvcnCurrent] - Pointer to current VirtualCtrNode
//
//  Returns:    HRESULT 
//
//  History:    Narindk   13-Jun-96   Made into a new function 
//  
//  Notes:      The VirtualDocFile tree is created based on the corresponding
//              ChanceDocFile tree.  This function is called either from the
//              GenerateVirtualDF function or may call itself recursively. The
//              ChanceDocFile tree is traversed from the top down, and based
//              on its contents, a VirtualDF tree is generated topdown. 
//
//              First assign the passed in ChanceNode to pcnCurrentChild and
//              passed in VirtualCtrNode to pvcnFisrtBorn variables.
//              Loop till pcnCurrentChild's _pcnChild is non NULL & hr is S_OK
//              - Call AppendVirtualCtrNode to create a new node pvcnNextBorn
//                based on info from corresponding ChanceDocFile node and
//                append it to pvcnFirstBorn in the tree being generated.
//              - Assign pcnCurrentChild's _pcnChild to pcnCurrentSister.
//              -  Loop till pcnCurrentSister's _pcnSister is non NULL & hr=S_OK
//                      - Call AppendVirtualCtrNode to create a new node pvcn
//                        NextBornSister and append it to pvcnFirstBorn. Pl.
//                        note that append function would take care to append
//                        it to its older sister.
//                      - Assign pcnCurrentSister's _pcnSister to  variable
//                        pcnCurrentSister. 
//                      - If pcnCurrentSister's _pcnChild is non NULL, then
//                        make a recursive call to itself GrowVirtualDFTree. 
//                      - Reinitialize pvcnNextBornSister to NULL & go back to
//                        top of this inner loop and repeat.
//              - Assign  pvcnNextBorn to pvcnFirstBorn and reinitailize pvcn
//                NextBorn to NULL.
//              - Assign pcnCurrentChild's _pcnChild to pcnCurrentChild.
//              - Go to top of outer loop and repeat. 
//---------------------------------------------------------------------------
HRESULT VirtualDF::GrowVirtualDFTree(
    ChanceNode      *pcnCurrent,
    VirtualCtrNode  *pvcnCurrent)
{
    HRESULT             hr                  =   S_OK;
    VirtualCtrNode      *pvcnFirstBorn      =   NULL;
    VirtualCtrNode      *pvcnNextBorn       =   NULL;
    VirtualCtrNode      *pvcnNextBornSister =   NULL;
    ChanceNode          *pcnCurrentSister   =   NULL;
    ChanceNode          *pcnCurrentChild    =   NULL;

    DH_VDATEPTRIN(pcnCurrent, ChanceNode) ; 
    DH_VDATEPTRIN(pvcnCurrent, VirtualCtrNode) ; 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::GrowVirtualDFTree"));

    DH_ASSERT(NULL != pcnCurrent);
    DH_ASSERT(NULL != pvcnCurrent);

    if(S_OK == hr)
    {
        pvcnFirstBorn = pvcnCurrent;
        pcnCurrentChild = pcnCurrent;
    }

    while((NULL != pcnCurrentChild->_pcnChild) && (S_OK == hr))
    {
        int x=10;
        do 
        {
            hr = AppendVirtualCtrNode(
                    pvcnFirstBorn,
                    pcnCurrentChild->_pcnChild,
                    &pvcnNextBorn); 
            DH_HRCHECK(hr, TEXT("AppendVirtualCtrNode")) ;
            if (STG_E_FILEALREADYEXISTS == hr)
            {
                // delete the ctr node so we can try again.
                DeleteVirtualDocFileTree (pvcnNextBorn);
                // DeleteVirtualDocFileTree decrements the _cChildren,
                // but since no child was added in the first place,
                // restore it to its original value so we can try again.
                pvcnFirstBorn->_cChildren++;
                DH_TRACE ((DH_LVL_ALWAYS, 
                        TEXT("Above ERROR and ASSERT are OK.")));
            }
        } while (STG_E_FILEALREADYEXISTS == hr && --x);

        if(S_OK == hr) 
        {
            pcnCurrentSister = pcnCurrentChild->_pcnChild;

            while((NULL != pcnCurrentSister->_pcnSister) && (S_OK == hr))
            {
                int x=10;
                do
                {
                    hr = AppendVirtualCtrNode(
                             pvcnFirstBorn,
                             pcnCurrentSister->_pcnSister,
                             &pvcnNextBornSister);
                    DH_HRCHECK(hr, TEXT("AppendVirtualCtrNode")) ;
                    if (STG_E_FILEALREADYEXISTS == hr)
                    {
                        // delete the ctr node so we can try again.
                        DeleteVirtualDocFileTree (pvcnNextBornSister);
                        // DeleteVirtualDocFileTree decrements the _cChildren,
                        // but since no child was added in the first place,
                        // restore it to its original value so we can try again.
                        pvcnFirstBorn->_cChildren++;
                        DH_TRACE ((DH_LVL_ALWAYS, 
                                TEXT("Above ERROR and ASSERT are OK.")));
                    }
                } while (STG_E_FILEALREADYEXISTS == hr && --x);

                pcnCurrentSister = pcnCurrentSister->_pcnSister;

                // Check if there are any children of this sister node, if
                // yes, then make a recursive call to self.  

                if(NULL != pcnCurrentSister->_pcnChild)
                {
                    hr = GrowVirtualDFTree(
                            pcnCurrentSister,
                            pvcnNextBornSister);

                    DH_HRCHECK(hr, TEXT("GrowVirtualDFTree"));
                }

                // Reinitialize the variables

                pvcnNextBornSister = NULL;
            }
                
         }
         pvcnFirstBorn = pvcnNextBorn;
         pvcnNextBorn = NULL;

         pcnCurrentChild = pcnCurrentChild->_pcnChild;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::AppendVirtualCtrNode, protected
//
//  Synopsis:   Creates and appends VirtualCtrNode to VirtualDocFile tree 
//              being created. 
//
//  Arguments:  [pvcnParent] - Parent VirtualCtrNode for the new VirtualCtrNode
//              [pcnCurrent] - Corresponding ChanceNode in ChanceDocFile tree.  
//              [ppvcnNew] -   Pointer to pointer to new VirtualCtrNode to be 
//                             created.
//  Returns:    HRESULT 
//
//  History:    Narindk   23-Apr-96   Created
//
//  Notes:      - Generate a random name for VirtualCtrNode 
//              - Creates VirtualCtrNode object and initializes it with info
//                based on corresponding ChanceDocFile node.
//              - Appends this node to the VirtualDF tree being generated.
//              - Create real IStorage corresponding to this VirtualCtrNode.
//              - Creates IStreams corresponding to this VirtualCtrNode, if
//                required.
//              - Calculates in memory CRC for this IStorage and assigns it 
//                to _dwCRC variable.
//---------------------------------------------------------------------------

HRESULT VirtualDF::AppendVirtualCtrNode(
    VirtualCtrNode *pvcnParent,
    ChanceNode     *pcnCurrent,
    VirtualCtrNode **ppvcnNew) 
{
    HRESULT         hr              =   S_OK;
    LPTSTR          ptcsName        =   NULL ;
    VirtualCtrNode  *pvcnOldSister  =   NULL;

    DH_VDATEPTROUT(ppvcnNew, PVCTRNODE) ; 
    DH_VDATEPTRIN(pvcnParent, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pcnCurrent, ChanceNode) ; 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("AppendVirtualCtrNode"));
 
    DH_ASSERT(NULL != pvcnParent);
    DH_ASSERT(NULL != ppvcnNew);
    DH_ASSERT(NULL != pcnCurrent);

    if(S_OK == hr)
    { 
        *ppvcnNew = NULL;

        hr = GenerateRandomName(_pgdu, MINLENGTH, MAXLENGTH, &ptcsName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    { 
        // Allocate and Initialize new VirtualCtrNode

        *ppvcnNew = new VirtualCtrNode();
       
        if (NULL == *ppvcnNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        hr = (*ppvcnNew)->Init(
                ptcsName, 
                pcnCurrent->_cStorages, 
                pcnCurrent->_cStreams);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Init")) ;
    }

    // Append new VirtualCtr Node

    if(S_OK == hr)
    {
        if(NULL == pvcnParent->_pvcnChild)
        {
            hr = pvcnParent->AppendChildCtr(*ppvcnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendChildCtr")) ;
        }
        else
        {
            pvcnOldSister = pvcnParent->_pvcnChild;
            while(NULL != pvcnOldSister->_pvcnSister)
            {
                pvcnOldSister = pvcnOldSister->_pvcnSister;
            }

            hr = pvcnOldSister->AppendSisterCtr(*ppvcnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendSisterCtr")) ;
        }
    }
     
    // Call VirtualCtrNode::Create to create a corresponding Storage on disk.
    if(S_OK == hr)
    {
        hr = (*ppvcnNew)->Create(
                _dwStgMode | STGM_CREATE,
                0,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Create")) ;

        // Generate VirtualStmNode(s) depending upon if it has streams in it.
        DH_ASSERT((pcnCurrent->_cStreams) == ((*ppvcnNew)->_cStreams));
    }

    if ((S_OK == hr) && (0 != (*ppvcnNew)->_cStreams))
    {
       hr = AppendVirtualStmNodesToVirtualCtrNode(
                (*ppvcnNew)->_cStreams, 
                *ppvcnNew,
                pcnCurrent->_cbMinStream,
                pcnCurrent->_cbMaxStream);

       DH_HRCHECK(hr, TEXT("AppendVirtualStmNodesToVirtualCtrNode")) ;
    }

    // Calculate the CRC for storage name

    if(S_OK == hr)
    { 
        hr = CalculateInMemoryCRCForStg(*ppvcnNew, &((*ppvcnNew)->_dwCRC));

        DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStg")) ;
    }

    // Cleanup  
    
    if(NULL != ptcsName)
    {
        delete ptcsName;
        ptcsName = NULL;
    }
 
    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::AppendVirtualStmNodesToVirtualCtrNode, protected
//
//  Synopsis:   Creates and appends VirtualStmNode(s) to VirtualCtrNode 
//
//  Arguments:  [cStreams] -     Number of streams to be created 
//              [pvcn]     -     Pointer to VirtualCtrNode for which the streams
//                               need to be created and appended.
//              [cbMinStream] -  Minimum size of created stream. 
//              [cbMaxStream] -  Maximum size of created stream. 
//
//  Returns:    HRESULT 
//
//  History:    Narindk   23-Apr-96   Created
//
//  Notes:      if number of streams to be created and appended to parent 
//              VirtualCtrNode pvcn is not zero, then loop till cStreams is
//              not equal to zero.
//                  - Call AppendVirtualStmNode to create a new VirtualStmNode
//                    and append it to parent VirtualCtrNode.  Pl. note that
//                    this function would take care if the newly created node
//                    need to be appended to older VirtualStmNode sister.
//                  - Decrement cStreams and o back to top of loop & repeat.
//---------------------------------------------------------------------------

HRESULT VirtualDF::AppendVirtualStmNodesToVirtualCtrNode(
    ULONG           cStreams,
    VirtualCtrNode  *pvcn,
    ULONG           cbMinStream,
    ULONG           cbMaxStream)
{
    HRESULT         hr              =   S_OK;

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ; 

    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("::AppendVirtualStmNodesToVirtualCtrNode"));
 
    DH_ASSERT(0 != cStreams);
    DH_ASSERT(NULL != pvcn);

    while((S_OK == hr) && (0 != cStreams))
    {
        hr = AppendVirtualStmNode(
                pvcn, 
                cbMinStream, 
                cbMaxStream);

        DH_HRCHECK(hr, TEXT("AppendVirtualStmNode")) ;

        cStreams--;
    }

    return hr;
}
 
//----------------------------------------------------------------------------
//  Member:     VirtualDF::AppendVirtualStmNode, protected
//
//  Synopsis:   Creates and appends first VirtualStmNode to VirtualCtrNode 
//
//  Arguments:  [pvcnParent] - Pointer to VirtualCtrNode for which the streams
//                             need to be created and appended. 
//              [cbMinStream] -  Minimum size of created stream. 
//              [cbMaxStream] -  Maximum size of created stream. 
//
//  Returns:    HRESULT 
//
//  History:    Narindk   23-Apr-96   Created
//              georgis   02-Apr-98   Added support for large streams
//
//  Notes:      - Generate a random name for VirtualStmNode 
//              - Generates a random size for stream based on inforamtion
//                from corresponding ChanceDocFile tree node.
//              - Creates VirtualStmNode object and initializes it with above
//                info
//              - Appends this node to the parent VirtualCtrNode.
//              - Create real IStream corresponding to this VirtualStmNode.
//              - Set the size of stream based on size calculated above.
//              - Write into the stream random data of above size
//              - Calculates in memory CRC for this IStream and assigns it 
//                to _dwCRC variable.
//---------------------------------------------------------------------------

HRESULT VirtualDF::AppendVirtualStmNode(
    VirtualCtrNode *pvcnParent,
    ULONG          cbMinStream,
    ULONG          cbMaxStream)
{
    HRESULT         hr              =   S_OK;
    VirtualStmNode  *pvsnNew        =   NULL;
    VirtualStmNode  *pvsnOldSister  =   NULL;
    ULONG           cb              =   0;
    USHORT          usErr           =   0;
    LPTSTR          ptcsName        =   NULL ;
    BYTE            *pBuffer        =   NULL ;
    ULONG           culWritten      =   0; 
    ULARGE_INTEGER  uli;
 
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::AppendVirtualStmNode"));

    DH_VDATEPTRIN(pvcnParent, VirtualCtrNode) ; 
 
    DH_ASSERT(NULL != pvcnParent);

    if (S_OK == hr)
    {
        hr = GenerateRandomName(_pgdu, MINLENGTH, MAXLENGTH, &ptcsName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = _pdgi->Generate(&cb, cbMinStream, cbMaxStream);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }
 
    // Allocate a new VirtualStmNode

    if (S_OK == hr)
    {    
        pvsnNew = new VirtualStmNode();

        if (NULL == pvsnNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if(S_OK == hr)
    {
        hr = pvsnNew->Init(ptcsName, cb);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Init")) ;
    }

    if(S_OK == hr)
    { 

        if(NULL == pvcnParent->_pvsnStream)
        {
            // Append it to parent storage
 
            hr = pvcnParent->AppendFirstChildStm(pvsnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendFirstChildStm")) ;
        }
        else
        {
            pvsnOldSister = pvcnParent->_pvsnStream;

            while(NULL != pvsnOldSister->_pvsnSister)
            {
                pvsnOldSister = pvsnOldSister->_pvsnSister;
            }

            // Append it to preceding sister stream 
 
            hr = pvsnOldSister->AppendSisterStm(pvsnNew);

            DH_HRCHECK(hr, TEXT("VirtualStmNode::AppendSisterStm")) ;
        }
    }

    // Call VirtualStmNode::Create to create a corresponding Stream on disk.

    if(S_OK == hr)
    {
        // Since in OLE code: simpstg.cxx, it makes the following comparison:
        //   if (grfMode != (STGM_READWRITE | STGM_SHARE_EXCLUSIVE))
        //      return STG_E_INVALIDFLAG;
        // We can't pass _dwStmMode | STGM_CREATE like in normal mode, 
        // otherwise we will get STG_E_INVALIDFLAG error.

        if (_dwRootMode & STGM_SIMPLE)
        { 
            hr = pvsnNew->Create(
                    _dwStmMode | STGM_FAILIFTHERE,
                    0,
                    0);

            DH_HRCHECK(hr, TEXT("VirtualStmNode::Create")) ;
        }
        else

        {
            hr = pvsnNew->Create(
                    _dwStmMode | STGM_CREATE | STGM_FAILIFTHERE,
                    0,
                    0);

            DH_HRCHECK(hr, TEXT("VirtualStmNode::Create")) ;
        }


    }

    // Call VirtualStmNode::SetSize to set size of stream.

    if(S_OK == hr)
    { 
        ULISet32(uli, cb);

        hr = pvsnNew->SetSize(uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::SetSize")) ;
    }

    if(S_OK == hr)
    { 
        ULONG ulTotalWritten = 0;
        ULONG ulChunkSize =0;
        DWORD dwOffset=0;
        register DWORD dwCRC=CRC_PRECONDITION;

#if 0
        // Use for small chunks  
        hr = GenerateRandomName(_pgdu, STM_CHUNK_SIZE, STM_CHUNK_SIZE, (LPTSTR *) &pBuffer);
        DH_HRCHECK(hr, TEXT("GenerateRandomName"));
#else
		// If the chunk is very large, avoid generating many random numbers
		hr = GenerateRandomStreamData(_pgdu,(LPTSTR *) &pBuffer,STM_CHUNK_SIZE);
        DH_HRCHECK(hr, TEXT("GenerateRandomStreamData"));
#endif

        while ((S_OK == hr) && (ulTotalWritten < cb))
        {
            // Write the data from random offset to the end of the buffer 
            _pdgi->Generate(&dwOffset,0,STM_CHUNK_SIZE-2);
            ulChunkSize=min(cb-ulTotalWritten,STM_CHUNK_SIZE-dwOffset);
            
            hr = pvsnNew->Write(pBuffer+dwOffset, ulChunkSize, &culWritten);
            DH_HRCHECK(hr, TEXT("VirtualStmNode::Write")) ;
            
			if (S_OK == hr) // Skip if we are failing
			{
				ulTotalWritten+=culWritten;

				// Calculate the CRC now, to spare aditional Read
				for (register int i=0; i<culWritten; i++)
				{
					CRC_CALC(dwCRC,(BYTE) pBuffer[dwOffset+i])
				};
			}
        }

        // Update the vsnode created
        pvsnNew->_dwCRC.dwCRCData=dwCRC;

        hr=CalculateCRCForName(pvsnNew->_ptszName,&pvsnNew->_dwCRC.dwCRCName);
        DH_HRCHECK(hr, TEXT("CalculateCRCForName"));

        pvsnNew->_dwCRC.dwCRCSum=CRC_PRECONDITION;
        MUNGECRC(pvsnNew->_dwCRC.dwCRCSum,pvsnNew->_dwCRC.dwCRCData);
        MUNGECRC(pvsnNew->_dwCRC.dwCRCSum,pvsnNew->_dwCRC.dwCRCName);
    }

    // Since for simple mode docfile, access to streams follows a linear
    // pattern, it needs to close the current stream before creating and
    // open another stream. So for simple mode docfile, after the docfile
    // is created, all the elements are closed except the root storage.
    // For the normal mode docfile, after it is created, all the elements
    // are kept open.

    if ((S_OK == hr) && (_dwRootMode & STGM_SIMPLE))
    {
        hr = pvsnNew->Close();
        
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }


    // Cleanup

    if(NULL != ptcsName)
    {    
        delete ptcsName;
        ptcsName = NULL;
    }

    if(NULL != pBuffer)
    {    
        delete pBuffer;
        pBuffer = NULL;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::DeleteVirtualDocFileTree, public
//
//  Synopsis:   Deletes the VirtualDocFileTree from the passed in Virtual
//              CtrNode node down. 
//
//  Arguments:  [pvcnTrav]   - Pointer to VirtualCtrNode from which node
//                             downwards, including itself, the tree would
//                             be deleted. 
//
//  Returns:    HRESULT 
//
//  History:    Narindk   24-Apr-96   Created
//
//  Notes:      First step is to check if the whole tree needs to be deleted or
//              just a part of it.  In case only a part of tree is to be
//              deleted, isolate the node from the remaining tree by readjusting
//              the pointers in the remaining tree.  Then call the function
//              DeleteVirtualDocFileSubTree to delete the subtree.  In case,
//              the complete tree needs to be deleted, we call the function
//              DeleteVirtualDocFileSubTree directly to delete the complete
//              tree.
//---------------------------------------------------------------------------

HRESULT VirtualDF::DeleteVirtualDocFileTree(VirtualCtrNode *pvcnTrav)
{
    HRESULT hr                  =   S_OK;
    VirtualCtrNode *pTempNode   =   NULL;

    DH_VDATEPTRIN(pvcnTrav, VirtualCtrNode) ; 
    
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::DeleteVirtualDocFileTree"));
 
    DH_ASSERT(NULL != pvcnTrav);

    if(S_OK == hr)
    {
        // This basically readjusts the pointers in the tree if the passed in
        // VirtualCtrNode is not the root of the VirtualDF tree.

        if(NULL != pvcnTrav->_pvcnParent)
        {
            // Decrease the _cChildren variable of the parent VirtualCtrNode.
        
            pvcnTrav->_pvcnParent->_cChildren--;

           // Find its previous node whose pointers need readjustment.
           pTempNode = pvcnTrav->_pvcnParent->_pvcnChild;
           while ((pvcnTrav != pvcnTrav->_pvcnParent->_pvcnChild) &&
                  (pvcnTrav != pTempNode->_pvcnSister))
           {
               pTempNode = pTempNode->_pvcnSister;
               DH_ASSERT(NULL != pTempNode);
           }

           // Readjust the child pointer or sister pointer as the case may be.

           pvcnTrav->_pvcnParent->_pvcnChild = (pvcnTrav == pTempNode) ?
                pvcnTrav->_pvcnSister : pvcnTrav->_pvcnParent->_pvcnChild;
           pTempNode->_pvcnSister = pvcnTrav->_pvcnSister;
        }
    }

    if(S_OK == hr)
    {
        hr = DeleteVirtualDocFileSubTree(&pvcnTrav);

        DH_HRCHECK(hr, TEXT("DeleteVirtualDocFileSubTree")) ;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::DeleteVirtualDocFileSubTree, protected
//
//  Synopsis:   Deletes iteratively all VirtualCtrNode nodes under and including//              the passed in VirtualCtrNode and calls a function to delete
//              all VirtualStmNodes under the VirtualCtrNodes being deleted. 
//
//  Arguments:  [**ppvcnTrav]- Pointer to pointer to VirtualCtrNode from 
//                             which node under, including itself, the tree 
//                             would be deleted. 
//
//  Returns:    HRESULT 
//
//  History:    Narindk   24-Apr-96   Created
//
//  Notes:      This function is called only through DeleteVirtualDocFileTree.
// 
//              Assign the passed in VirtualCtrNode to a variable pTempRoot.
//              NULL the pTempRoot's parent.
//              Loop till the pTempRoot is not NULL to delete tree iteratively.
//                  - Assign pTempRoot to a temp variable pTempNode.
//                  - Traverse the tree to make pTempNode point to last child
//                    (_pvcnChild).
//                  - Assign pTempNode's _pvcnParent to pTempRoot
//                  - Assign the pTempRoot's _pvcnChild pointer to point to the
//                    sister of pTempNode's _pvcnSister rather than to itself,
//                    therby isolating itself.
//                  - Decrement the _cChildren of pTempRoot (used to verify).
//                  - Assign pTempNode's _pvcnSister to NULL.
//                  - if pTempNode's _pvsnStream is not NULL, call function
//                    DeleteVirtualCtrNodeStreamTree to delete all its Virtual
//                    StmNodes.
//                  - Assert to ensure the pTempNode's _cChildren and _cStreams
//                    are zero before deleting it.
//                  - Delete pTempNode.
//                  - Go back to top of loop and repeat till all nodes are
//                    deleted.             
//---------------------------------------------------------------------------

HRESULT VirtualDF::DeleteVirtualDocFileSubTree(VirtualCtrNode **ppvcnTrav)
{
    HRESULT         hr          =   S_OK;
    VirtualCtrNode *pTempRoot   =   NULL;
    VirtualCtrNode *pTempNode   =   NULL;

    DH_VDATEPTRIN(ppvcnTrav, PVCTRNODE) ; 
    
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::DeleteVirtualDocFileSubTree"));

    DH_ASSERT(NULL != *ppvcnTrav);

    if(S_OK == hr)
    {
        pTempRoot = *ppvcnTrav;
        pTempRoot->_pvcnParent = NULL;

        // This iteratives deletes the VirtualCtrNode and everything under it.

        while(NULL != pTempRoot)
        {
            pTempNode = pTempRoot;
            while(NULL != pTempNode->_pvcnChild)
            {
                pTempNode = pTempNode->_pvcnChild;
            }

            pTempRoot = pTempNode->_pvcnParent;
            if(pTempRoot != NULL)
            {
                pTempRoot->_pvcnChild = pTempNode->_pvcnSister;
            
                // Decrease the children count, this would be used to verify 
                // before deleting the VirtualCtrNode.

                pTempRoot->_cChildren--;
            }

            pTempNode->_pvcnSister = NULL;

            if(pTempNode->_pvsnStream != NULL) 
            {
                hr = DeleteVirtualCtrNodeStreamTree(pTempNode);

                DH_HRCHECK(hr, TEXT("DeleteVirtualCtrNodeStreamTree")) ;
            }

            // Confirm before deleting that all its sub child storages and
            // streams have been deleted, assert if not.
    
            DH_ASSERT(0 == pTempNode->_cChildren);
            DH_ASSERT(0 == pTempNode->_cStreams);

            delete pTempNode;
            pTempNode = NULL;
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::DeleteVirtualCtrNodeStreamTree, protected
//
//  Synopsis:   Deletes iteratively all VirtualStmNodes under the given 
//              VirtualCtrNode.
//
//  Arguments:  [*pvcnTrav]- Pointer to VirtualCtrNode for which all streams
//                           need to be deleted.
//
//  Returns:    HRESULT 
//
//  History:    Narindk   24-Apr-96   Created
//
//  Notes:      Loop till pvcnTrav's _pvsnStream is not NULL 
//              - Assign a temp variable pvsnTemp to point to _pvsnStream of
//                passed in VirtualCtrNode pvcnTrav.
//              - Assign pvcnTrav's _pvsnStream to point to pvsnTemp's _pvsn
//                Sister, thereby isolating the first VirtualStmNode.
//              - Decrease the _cStreams pf pvcnTrav (used to verify).
//              - Assign pvsnTemp's _pvsnSister to NULL.
//              - Delete pvsnTemp
//              - Go back to top of loop. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::DeleteVirtualCtrNodeStreamTree(VirtualCtrNode *pvcnTrav)
{
    HRESULT         hr          =   S_OK;
    VirtualStmNode  *pvsnTemp   =   NULL; 

    DH_VDATEPTRIN(pvcnTrav, VirtualCtrNode) ; 
    
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB,TEXT("::::DeleteVirtualCtrNodeStreamTree"));

    DH_ASSERT(NULL != pvcnTrav);

    if(S_OK == hr)
    {
        // This iteratively deletes all VirtualStmNodes.

        while(NULL != pvcnTrav->_pvsnStream)
        {
            pvsnTemp = pvcnTrav->_pvsnStream;
            pvcnTrav->_pvsnStream = pvsnTemp->_pvsnSister;

            // Decrease the stream count.  This would be used to verify before
            // deleting the parent VirtualCtrNode.

            pvcnTrav->_cStreams--;

            // Delete the node.

            pvsnTemp->_pvsnSister = NULL;
            delete pvsnTemp;
            pvsnTemp = NULL;
        }
    }

    return hr;
}


//----------------------------------------------------------------------------
//  Member:     VirtualDF::AdjustTreeOnStgMoveElement, public
//
//  Synopsis:   Adjusts the VirtualDocFileTree when IStorage::MoveElementTo 
//              as move is operated on a IStorage element 
//
//  Arguments:  [pvcnFrom]   - Pointer to VirtualCtrNode to be moved 
//              [pvcnTo]     - Pointer to VirtualCtrNode moved to
//
//  Returns:    HRESULT 
//
//  History:    Narindk   13-May-1996   Created
//
//  Notes;      Doesn't initialize the _pstg of moved tree elements 
//              as that would require opening of those moved storages/streams.
//              This readjusts the tree by removing the moved element from
//              its original position in tree & reinserting it in tree at its 
//              new destination.  This function is not used when the root it
//              self is moved, assert if root is being moved.
//
//              1. Decrease the pvcnFrom's _pvcnParent's _cChildren count
//                 indicating that pvcnFrom is being moved.
//              2. In the tree, find its previous node whose pointers would
//                 need readjustment.  Find its older sister if it has one,
//                 adjust its _pvcnSister pointer.  Or if the node being moved
//                 is _pvcnChild of its parent _pvcnParent, then adjust the
//                 _pvcnParent's _pvcnChild to _pvcnSister of node being moved.
//              3. NULL out pvcnFrom's _pvcnParent, _pvcnSister pointers thereby
//                 isolating this VirtualCtrNode.  NULL out _pstg too since 
//                 that would have been already move to by IStorage::MoveElement//                 To call prior to calling this function.
//              4. In destination node pvcnTo, check if it's _pvcnChild is NULL.
//                 if yes, then assign pvcnFrom to _pvcnTo's _pvcnChild. If it
//                 is not NULL, then traverse through its children to reach 
//                 last _pvcnSister and assign pvcnFrom to that.
//              5. Assign pvcnFrom's _pvcnParent to be pvcnTo.  Also increment
//                 pvcnTo's _cChildren count indicating the new VirtualCtrNode
//                 being moved here. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::AdjustTreeOnStgMoveElement(
    VirtualCtrNode  *pvcnFrom,
    VirtualCtrNode  *pvcnTo )
{
    HRESULT         hr          =   S_OK;
    VirtualCtrNode *pTempNode   =   NULL;
    VirtualCtrNode *pvcnTrav    =   NULL;

    DH_VDATEPTRIN(pvcnFrom, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pvcnTo, VirtualCtrNode) ; 
    
    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("::AdjustTreeOnStgMoveElement"));
 
    DH_ASSERT(NULL != pvcnTo);
    DH_ASSERT(NULL != pvcnFrom);

    // Assert if this is the root that is being moved.
    DH_ASSERT(NULL != pvcnFrom->_pvcnParent);

    if(S_OK == hr)
    {
        // Decrease the _cChildren variable of the parent VirtualCtrNode.
        
        pvcnFrom->_pvcnParent->_cChildren--;

        // Find its previous node whose pointers need readjustment.

        pTempNode = pvcnFrom->_pvcnParent->_pvcnChild;
        while ((pvcnFrom != pvcnFrom->_pvcnParent->_pvcnChild) &&
               (pvcnFrom != pTempNode->_pvcnSister))
        {
            pTempNode = pTempNode->_pvcnSister;
            DH_ASSERT(NULL != pTempNode);
        }

        // Readjust the child pointer or sister pointer as the case may be.

        pvcnFrom->_pvcnParent->_pvcnChild = (pvcnFrom == pTempNode) ?
             pvcnFrom->_pvcnSister : pvcnFrom->_pvcnParent->_pvcnChild;
        pTempNode->_pvcnSister = pvcnFrom->_pvcnSister;

        // NULL out its pointers
        pvcnFrom->_pvcnParent = NULL;
        pvcnFrom->_pvcnSister = NULL;
        pvcnFrom->_pstg = NULL;
    }

    if(S_OK == hr)
    {
        if(NULL != pvcnTo->_pvcnChild)
        {
            pvcnTrav = pvcnTo->_pvcnChild;
            while(NULL != pvcnTrav->_pvcnSister)
            {
                pvcnTrav = pvcnTrav->_pvcnSister;
            }
            pvcnTrav->_pvcnSister = pvcnFrom;
        }
        else
        {
            pvcnTo->_pvcnChild = pvcnFrom;
        }
        pvcnFrom->_pvcnParent = pvcnTo;
        pvcnTo->_cChildren++;
    }

    // The storage was closed prior to its move.  So do we need to reopen it 
    // from here now from moved destination.

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::AdjustTreeOnStmMoveElement, public
//
//  Synopsis:   Adjusts the VirtualDocFileTree when IStorage::MoveElementTo 
//              as move is operated on a IStream element 
//
//  Arguments:  [pvsnFrom]   - Pointer to VirtualStmNode to be moved 
//              [pvcnTo]     - Pointer to VirtualCtrNode moved to
//
//  Returns:    HRESULT 
//
//  History:    Narindk   9-July-1996   Created
//
//  Notes;      Doesn't initialize the _pstm of moved tree elements 
//              as that would require opening of the moved stream.
//              This readjusts the tree by removing the moved element from
//              its original position in tree & reinserting it in tree at its 
//              new destination.  
//
//              1. Decrease the pvcnFrom's _pvcnParent's _cStreams count
//                 indicating that pvsnFrom is being moved.
//              2. In the tree, find its previous node whose pointers would
//                 need readjustment.  Find its older sister if it has one,
//                 adjust its _pvsnSister pointer.  Or if the node being moved
//                 is _pvsnStream of its parent _pvcnParent, then adjust the
//                 _pvcnParent's _pvsnStream to _pvsnSister of node being moved.
//              3. NULL out pvsnFrom's _pvcnParent, _pvsnSister pointers thereby
//                 isolating this VirtualStmNode.  NULL out _pstm too since 
//                 that would have been already move to by IStorage::MoveElement//                 To call prior to calling this function.
//              4. In destination node pvcnTo,check if it's _pvsnStream is NULL.
//                 if yes, then assign pvsnFrom to _pvcnTo's _pvcnStream. If it
//                 is not NULL, then traverse through its stream nodes to reach 
//                 last _pvsnSister and assign pvsnFrom to that.
//              5. Assign pvsnFrom's _pvcnParent to be pvcnTo.  Also increment
//                 pvcnTo's _cStreams count indicating the new VirtualStmNode
//                 being moved here. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::AdjustTreeOnStmMoveElement(
    VirtualStmNode  *pvsnFrom,
    VirtualCtrNode  *pvcnTo )
{
    HRESULT         hr          =   S_OK;
    VirtualStmNode *pTempNode   =   NULL;
    VirtualStmNode *pvsnTrav    =   NULL;

    DH_VDATEPTRIN(pvsnFrom, VirtualStmNode) ; 
    DH_VDATEPTRIN(pvcnTo, VirtualCtrNode) ; 
    
    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("::AdjustTreeOnStmMoveElement"));
 
    DH_ASSERT(NULL != pvcnTo);
    DH_ASSERT(NULL != pvsnFrom);
    DH_ASSERT(NULL != pvsnFrom->_pvcnParent);

    if(S_OK == hr)
    {
        // Decrease the _cStreams variable of the parent VirtualCtrNode.
        
        pvsnFrom->_pvcnParent->_cStreams--;

        // Find its previous node whose pointers need readjustment.

        pTempNode = pvsnFrom->_pvcnParent->_pvsnStream;
        while ((pvsnFrom != pvsnFrom->_pvcnParent->_pvsnStream) &&
               (pvsnFrom != pTempNode->_pvsnSister))
        {
            pTempNode = pTempNode->_pvsnSister;
            DH_ASSERT(NULL != pTempNode);
        }

        // Readjust the pointer(s) as the case may be.

        pvsnFrom->_pvcnParent->_pvsnStream = (pvsnFrom == pTempNode) ?
             pvsnFrom->_pvsnSister : pvsnFrom->_pvcnParent->_pvsnStream;
        pTempNode->_pvsnSister = pvsnFrom->_pvsnSister;

        // NULL out its pointers
        pvsnFrom->_pvcnParent = NULL;
        pvsnFrom->_pvsnSister = NULL;
        pvsnFrom->_pstm = NULL;
    }

    if(S_OK == hr)
    {
        if(NULL != pvcnTo->_pvsnStream)
        {
            pvsnTrav = pvcnTo->_pvsnStream;
            while(NULL != pvsnTrav->_pvsnSister)
            {
                pvsnTrav = pvsnTrav->_pvsnSister;
            }
            pvsnTrav->_pvsnSister = pvsnFrom;
        }
        else
        {
            pvcnTo->_pvsnStream = pvsnFrom;
        }
        pvsnFrom->_pvcnParent = pvcnTo;
        pvcnTo->_cStreams++;
    }

    // The stream was closed prior to its move.  So do we need to reopen it 
    // from here now from moved destination.

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::AdjustTreeOnStgCopyElement, public
//
//  Synopsis:   Adjusts the VirtualDocFileTree when IStorage::MoveElementTo 
//              as copy is operated on a IStorage element 
//
//  Arguments:  [pvcnFrom]   - Pointer to VirtualCtrNode to be moved as copy
//              [pvcnTo]     - Pointer to VirtualCtrNode moved to
//
//  Returns:    HRESULT 
//
//  History:    Narindk   20-May-1996   Created
//
//  Notes;      Doesn't initialize the _pstg's/_pstm's of copied tree elements 
//              as that would require opening of those copied storages/streams.
//              This readjusts the tree by inserting the copied element in tree
//              at its new destination.  This function is not used when the 
//              root itself is copied, assert if root is being moved.
//
//              1. Call CopyVirtualDocFileTree function to copy pvcnFrom to
//                 pvcnNew.
//              2. In destination node pvcnTo, check if it's _pvcnChild is NULL.
//                 if yes, then assign pvcnFrom to _pvcnTo's _pvcnChild. If it
//                 is not NULL, then traverse through its children to reach 
//                 last _pvcnSister and assign pvcnFrom to that.
//              3. Assign pvcnFrom's _pvcnParent to be pvcnTo.  Also increment
//                 pvcnTo's _cChildren count indicating the new VirtualCtrNode
//                 being copied here.  Also assign pvcnNew's _pvcnSister to
//                 NULL. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::AdjustTreeOnStgCopyElement(
    VirtualCtrNode  *pvcnFrom,
    VirtualCtrNode  *pvcnTo )
{
    HRESULT hr                  =   S_OK;
    VirtualCtrNode *pvcnTrav    =   NULL;
    VirtualCtrNode *pvcnNew     =   NULL;

    DH_VDATEPTRIN(pvcnFrom, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pvcnTo, VirtualCtrNode) ; 
    
    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("::AdjustVirtualDocFileTreeOnStgCopyElement"));
 
    DH_ASSERT(NULL != pvcnTo);
    DH_ASSERT(NULL != pvcnFrom);

    // Assert if this is the root that is being copied.
    DH_ASSERT(NULL != pvcnFrom->_pvcnParent);

    if(S_OK == hr)
    {
        hr = CopyVirtualDocFileTree(pvcnFrom, NEW_STGSTM, &pvcnNew);
    }

    if(S_OK == hr)
    {
        if(NULL != pvcnTo->_pvcnChild)
        {
            pvcnTrav = pvcnTo->_pvcnChild;
            while(NULL != pvcnTrav->_pvcnSister)
            {
                pvcnTrav = pvcnTrav->_pvcnSister;
            }
            pvcnTrav->_pvcnSister = pvcnNew;
        }
        else
        {
            pvcnTo->_pvcnChild = pvcnNew;
        }
        pvcnNew->_pvcnParent = pvcnTo;
        pvcnTo->_cChildren++;
        pvcnNew->_pvcnSister = NULL;
    }

    // The storage was closed prior to its copy.  So do we need to open it 
    // now from copied destination.  How about other _pstg / _pstm for 
    // copied tree?

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::AdjustTreeOnStmCopyElement, public
//
//  Synopsis:   Adjusts the VirtualDocFileTree when IStorage::MoveElementTo 
//              as copy is operated on a IStream element 
//
//  Arguments:  [pvsnFrom]   - Pointer to VirtualstmNode to be moved as copy
//              [pvcnTo]     - Pointer to VirtualCtrNode moved to
//
//  Returns:    HRESULT 
//
//  History:    Narindk   9-July-1996   Created
//
//  Notes;      Doesn't initialize the _pstm of copied tree stream element 
//              as that would require opening of the copied stream.
//              This readjusts the tree by inserting the copied element in tree
//              at its new destination.  
//
//              1. Copy the VirtualStmNode to be copied to a new VirtualStmNode.
//              2. In destination node pvcnTo,check if it's _pvsnStream is NULL.
//                 if yes, then assign pvsnFrom to _pvcnTo's _pvsnStream. If it
//                 is not NULL, then traverse through its streams to reach 
//                 last _pvsnSister and assign pvsnFrom to that.
//              3. Assign pvsnFrom's _pvcnParent to be pvcnTo.  Also increment
//                 pvcnTo's _cStreams count indicating the new VirtualStmNode
//                 being copied here. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::AdjustTreeOnStmCopyElement(
    VirtualStmNode  *pvsnFrom,
    VirtualCtrNode  *pvcnTo )
{
    HRESULT        hr           =   S_OK;
    VirtualStmNode *pvsnTrav    =   NULL;
    VirtualStmNode *pvsnNew     =   NULL;

    DH_VDATEPTRIN(pvsnFrom, VirtualStmNode) ; 
    DH_VDATEPTRIN(pvcnTo, VirtualCtrNode) ; 
    
    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("::AdjustVirtualDocFileTreeOnStmCopyElement"));
 
    DH_ASSERT(NULL != pvcnTo);
    DH_ASSERT(NULL != pvsnFrom);

    // Copy the VirtualStmNode to be moved as copy

    if (S_OK == hr)
    {
        pvsnNew = new VirtualStmNode();

        if (NULL == pvsnNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        pvsnNew->_dwCRC.dwCRCName =  pvsnFrom->_dwCRC.dwCRCName;
        pvsnNew->_dwCRC.dwCRCData =  pvsnFrom->_dwCRC.dwCRCData;
        pvsnNew->_dwCRC.dwCRCSum =  pvsnFrom->_dwCRC.dwCRCSum;

        hr = pvsnNew->Init(pvsnFrom->_ptszName, pvsnFrom->_cb);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Init")) ;
    }

    if(S_OK == hr)
    {
        if(NULL != pvcnTo->_pvsnStream)
        {
            pvsnTrav = pvcnTo->_pvsnStream;
            while(NULL != pvsnTrav->_pvsnSister)
            {
                pvsnTrav = pvsnTrav->_pvsnSister;
            }
            pvsnTrav->_pvsnSister = pvsnNew;
        }
        else
        {
            pvcnTo->_pvsnStream = pvsnNew;
        }
        pvsnNew->_pvcnParent = pvcnTo;
        pvcnTo->_cStreams++;
    }

    // The stream was closed prior to its copy.  So do we need to open it 
    // now from copied destination.  

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::AdjustTreeOnCopyTo, public
//
//  Synopsis:   Adjusts the VirtualDocFileTree when IStorage::CopyTo 
//              is operated on a IStorage element 
//
//  Arguments:  [pvcnFrom]   - Pointer to VirtualCtrNode to be moved 
//              [pvcnTo]     - Pointer to VirtualCtrNode moved to
//
//  Returns:    HRESULT 
//
//  History:    Narindk   21-May-1996   Created
//  
//  Notes:      This function differs from VirtualDF::AdjustTreeOnStgCopyEle
//              ment bcause readjusts the tree in the lght that tree has to
//              readjusted since an IStorage elemnt is moved as copy to desti-
//              nation container by IStorage::MoveElementTo as copy.  But here,
//              we need to readjust the tree in the light thst the entire 
//              contents of an open IStorage object are copied into a dest
//              by IStorage::CopyTo
//
//              -Call CopyVirtualDocFileTree to copy everything under the node
//               pvcnFrom, where IStorage::CopyTo source is to pvcnNew.
//              -if pvcnNew has VirtualStmNode in it (_pvsnStream), then
//                  -Check if pvcnTo (dest) has _pvsnStream as NULL or not.
//                      -If not NULL, then loop to get to end of VirtualStm
//                       Nodes's _pvsnSister in the chain.
//                      -As appropriate, assign pvcnNew->_pvsnStream to the
//                       pvcnTo destination.
//                   -Adjust the _pvcnParent of pvcnNew->_pvsnStream to 
//                    point to pvcnTo and increase _cStream member of
//                    pvcnTo node.
//                   -Assign a temp variable pvsnTemp to point to the pvcnNew
//                    ->_pvsnStream and then loop through to end of all
//                    sister VirtualStmNodes and make their _pvcnParent as
//                    pvcnTo and keep on incrementing _cStreams member of
//                    pvcnTo with each new VirtualStmNode traversed.
//                   -Now all VirtualStmNodes fro pvcnNew have been copied
//                    to pvcnTo, their destination.
//              -Repeat same for any VirtualCtrNodes that pvcnNew may have.
//               if pvcnNew has VirtualCtrNode in it (_pvcnChild), then
//                  -Check if pvcnTo (dest) has _pvcnChild as NULL or not.
//                      -If not NULL, then loop to get to end of VirtualCtr
//                       Nodes's _pvcnSister in the chain.
//                      -As appropriate, assign pvcnNew->_pvcnChild to the
//                       pvcnTo destination.
//                   -Adjust the _pvcnParent of pvcnNew->_pvcnChild to 
//                    point to pvcnTo and increase _cChildren member of
//                    pvcnTo node.
//                   -Assign a temp variable pvcnTemp to point to the pvcnNew
//                    ->_pvcnChild and then loop through to end of all
//                    sister VirtualCtrNodes and make their _pvcnParent as
//                    pvcnTo and keep on incrementing _cChildren member of
//                    pvcnTo with each new VirtualCtrNode traversed.
//                   -Now all VirtualCtrNodes fro pvcnNew have been copied
//                    to pvcnTo, their destination.
//              -Now everhing under pvcnNew has been copied to pvcnTo, so
//               delete pvcnNew.
//---------------------------------------------------------------------------

HRESULT VirtualDF::AdjustTreeOnCopyTo(
    VirtualCtrNode  *pvcnFrom,
    VirtualCtrNode  *pvcnTo )
{
    HRESULT         hr          = S_OK;
    VirtualCtrNode  *pvcnNew    = NULL;
    VirtualCtrNode  *pvcnTrav   = NULL;
    VirtualCtrNode  *pvcnTemp   = NULL;
    VirtualStmNode  *pvsnTrav   = NULL;
    VirtualStmNode  *pvsnTemp   = NULL;

    DH_VDATEPTRIN(pvcnFrom, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pvcnTo, VirtualCtrNode) ; 
    
    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("::AdjustTreeOnCopyTo"));
 
    DH_ASSERT(NULL != pvcnTo);
    DH_ASSERT(NULL != pvcnFrom);

    // Assert if this is the root that is being copied.
    DH_ASSERT(NULL != pvcnFrom->_pvcnParent);

    if(S_OK == hr)
    {
        hr = CopyVirtualDocFileTree(pvcnFrom, NEW_STGSTM, &pvcnNew);
    }

    if(S_OK == hr)
    {
        if(NULL != pvcnNew->_pvsnStream)
        {
            // Append these VirtualStmNode to pvcnTo VirtualCtrNode.

            // BUGBUG: what if these VirtualStmNodes have same name stream in
            //         in destination too.

            if(NULL != pvcnTo->_pvsnStream)
            {
               pvsnTrav = pvcnTo->_pvsnStream;
               while(NULL != pvsnTrav->_pvsnSister)
               {
                  pvsnTrav = pvsnTrav->_pvsnSister;
               }
               pvsnTrav->_pvsnSister = pvcnNew->_pvsnStream;
            }
            else
            {
               pvcnTo->_pvsnStream = pvcnNew->_pvsnStream;
            }
            pvcnNew->_pvsnStream->_pvcnParent = pvcnTo;
            pvcnTo->_cStreams++;
 
            if(NULL != pvsnTrav)
            { 
                pvsnTemp = pvsnTrav->_pvsnSister;
            }
            else
            {
                pvsnTemp = pvcnTo->_pvsnStream;
            }

            while(NULL != pvsnTemp->_pvsnSister)
            {
                pvsnTemp->_pvsnSister->_pvcnParent = pvcnTo;
                pvcnTo->_cStreams++;
                pvsnTemp = pvsnTemp->_pvsnSister;
            }
        }
    }

    if(S_OK == hr)
    {
        if(NULL != pvcnNew->_pvcnChild)
        {
            // Append these storages to pvcnTo VirtualCtrNode.

            // BUGBUG: what if these VirtualCtrNodes have same name stroage in
            //         in destination too.

            if(NULL != pvcnTo->_pvcnChild)
            {
               pvcnTrav = pvcnTo->_pvcnChild;
               while(NULL != pvcnTrav->_pvcnSister)
               {
                  pvcnTrav = pvcnTrav->_pvcnSister;
               }
               pvcnTrav->_pvcnSister = pvcnNew->_pvcnChild;
            }
            else
            {
               pvcnTo->_pvcnChild = pvcnNew->_pvcnChild;
            }
            pvcnNew->_pvcnChild->_pvcnParent = pvcnTo;
            pvcnTo->_cChildren++;

            if(NULL != pvcnTrav)
            { 
                pvcnTemp = pvcnTrav->_pvcnSister;
            }
            else
            {
                pvcnTemp = pvcnTo->_pvcnChild;
            }

            while(NULL != pvcnTemp->_pvcnSister)
            {
                pvcnTemp->_pvcnSister->_pvcnParent = pvcnTo;
                pvcnTo->_cChildren++;
                pvcnTemp = pvcnTemp->_pvcnSister;
            }
        }
    }

    // All the VirtualCtrNodes and VirtualStmNodes under pvcnNew are now
    // adjusted under the pvcnTo node.  So delete the pvcnNew.

    if(NULL != pvcnNew)
    {
        pvcnNew->_pvcnChild = NULL;
        pvcnNew->_pvsnStream = NULL;

        delete pvcnNew;
        pvcnNew = NULL;
    }

    // BUGBUG: How about filling up of _pstg / _pstm fieds for copied tree 
    // nodes?  May be not required if somebody needs, these could be opened.

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::CopyVirtualDocFileTree, public
//
//  Synopsis:   Copies VirtualDocFileTree from old root to a new root with all
//              its structure.   
//
//  Arguments:  [pvcnOldTreeRoot]  - Pointer to VirtualCtrNode to be moved 
//              [treeOpType]   - OLD_STGSTM or NEW_STGSTM 
//              [ppvcnNewTreeRoot] - Pointer to VirtualCtrNode of new tree
//
//  Returns:    HRESULT 
//
//  History:    Narindk   19-May-1996   Created
//
//  Notes:      In case of transaction mode, where it is just needed to keep
//              a copy of virtualdocfile tree and no new IStroages/Istreams 
//              are in question, then the second parameter should be OLD_STGSTM 
//              However if say MoveTo/CopyTo where there would be new IStorages
//              /IStreams, it should be given NEW_STGSTM. 
//
//              This function call CopyVirtualDFRoot to copy root VirtualCtr
//              Node and calls CopyVirtualDFTree to copy rest of tree.
//              - Call CopyVirtualDFRoot.
//              - Call CopyGrowVirtualDFTree
//              - If successful, assign root of new VirtualDF in *ppvcnRoot. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::CopyVirtualDocFileTree(
    VirtualCtrNode  *pvcnOldTreeRoot,
    TREEOP          treeOpType,
    VirtualCtrNode  **ppvcnNewTreeRoot)
{
    HRESULT         hr                      =   S_OK;
    VirtualCtrNode  *pvcnTempNewTreeRoot    =   NULL;

    DH_VDATEPTRIN(pvcnOldTreeRoot, VirtualCtrNode) ; 
    DH_VDATEPTROUT(ppvcnNewTreeRoot, PVCTRNODE) ; 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::CopyVirtualDocFileTree"));
    
    DH_ASSERT(NULL != pvcnOldTreeRoot);
    DH_ASSERT(NULL != ppvcnNewTreeRoot);

    if (S_OK == hr)
    {
        // Initialize out parameter

        *ppvcnNewTreeRoot = NULL;

        // Generates the root VirtualCtrNode for the VirtualDocFile tree.

        hr = CopyVirtualDFRoot(
                pvcnOldTreeRoot, 
                treeOpType,
                &pvcnTempNewTreeRoot); 

        DH_HRCHECK(hr, TEXT("CopyVirtualDFRoot")) ;
    }

    if (S_OK == hr)
    {
        // Generate remaining new VirtualDF tree based on old VirtualDF tree.

        hr = CopyGrowVirtualDFTree(
                pvcnOldTreeRoot, 
                pvcnTempNewTreeRoot, 
                treeOpType);

        DH_HRCHECK(hr, TEXT("CopyGrowVirtualDFTree")) ;
    }
    
    // Fill the out parameter

    if(S_OK == hr)
    {
        *ppvcnNewTreeRoot = pvcnTempNewTreeRoot;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::CopyVirtualDFRoot, protected
//
//  Synopsis:   Creates the root VirtualCtrNode for the VirtualDocFile tree. 
//
//  Arguments:  [pvcnRootOld] - Pointer to root of old VirtualDocFile tree 
//              [treeOpType]   - OLD_STGSTM or NEW_STGSTM 
//              [ppvcnRootNew] - Pointer to pointer to new VirtualDF tree
//
//  Returns:    HRESULT 
//
//  History:    Narindk   19-May-96   Created
//
//  Notes:      - Creates VirtualCtrNode object and initializes it with info
//                based on corresponding old source VirtualDocFile root.
//              - Calls CopyAppendVirtualStmNodesToVirtualCtrNode to append
//                VirtualStmNodes to this VirtualCtrNode, if present in old
//                source tree, so required to be copied.
//              - Copies in memory CRC for this VirtualCtrNode _dwCRC from old
//                source VirtualCtrNode.
//              - if treeOpType is OLD_STGSTM, as would be in transaction tree
//                copy procedure, when no new disk IStorages/IStreams are made,
//                this assign's new VirtualCtrNode's _pstg to be old source
//                VirtualCtrNode's _pstg.
//---------------------------------------------------------------------------

HRESULT VirtualDF::CopyVirtualDFRoot(
    VirtualCtrNode  *pvcnRootOld, 
    TREEOP          treeOpType,
    VirtualCtrNode  **ppvcnRootNew) 
{
    HRESULT hr      =   S_OK;

    DH_VDATEPTRIN(pvcnRootOld, VirtualCtrNode) ; 
    DH_VDATEPTROUT(ppvcnRootNew, PVCTRNODE) ; 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::CopyVirtualDFRoot"));

    DH_ASSERT(NULL != pvcnRootOld);
    DH_ASSERT(NULL != ppvcnRootNew);
    
    // Generate VirtualCtrNode for the root node.

    if(S_OK == hr)
    {
        // Initialize out parameter

        *ppvcnRootNew = NULL;

        *ppvcnRootNew = new VirtualCtrNode();

        if (NULL == *ppvcnRootNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        hr = (*ppvcnRootNew)->Init(
                pvcnRootOld->_ptszName, 
                pvcnRootOld->_cChildren, 
                pvcnRootOld->_cStreams);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Init")) ;
    }

    if ((S_OK == hr) && (0 != (*ppvcnRootNew)->_cStreams))
    {
       hr = CopyAppendVirtualStmNodesToVirtualCtrNode(
                (*ppvcnRootNew)->_cStreams,
                 *ppvcnRootNew,
                 pvcnRootOld,
                 treeOpType);

       DH_HRCHECK(hr, TEXT("CopyAppendVirtualStmNodesToVirtualCtrNode")) ;
    }

    if(S_OK == hr)
    {   
        (*ppvcnRootNew)->_dwCRC = pvcnRootOld->_dwCRC;
    
        if(OLD_STGSTM == treeOpType)
        {
            (*ppvcnRootNew)->_pstg = pvcnRootOld->_pstg;
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::CopyGrowVirtualDFTree, protected
//
//  Synopsis:   Creates the ramaining VirtualDocFile tree. 
//
//  Arguments:  [pvcnFrom] - Pointer to current node of original VirtualDocFile///                           tree 
//              [pvcnTo] -   Pointer to current VirtualCtrNode of copied Virtual
//                           DocFile tree
//              [treeOpType]   - OLD_STGSTM or NEW_STGSTM 
//
//  Returns:    HRESULT 
//
//  History:    Narindk   13-June-96   Created
//  
//  Notes:      The copied VirtualDocFile tree is created based on corresponding
//              original VirtualDocFile tree.  This function is called either 
//              from the CopyGenerateVirtualDF function or may call itself 
//              recursively. The original VirtualDocFile tree is traversed from
//              the top down, and based on its contents, a new VirtualDF tree 
//              is generated topdown. 
//
//              First assign the passed in pvcnFrom to pvcnCurrentChild and
//              passed in pvcnTo to pvcnFisrtBorn variables.
//              Loop till pvcnCurrentChild's _pvcnChild is non NULL & hr is S_OK
//              - Call CopyAppendVirtualCtrNode to create a new node called
//                pvcnNextBorn based on info from corresponding old pvcnCurrent-
//                Child's _pvcnChild and append it to pvcnFirstBorn in the tree
//                being generated by copy.
//              - Assign pvcnCurrentChild's _pvcnChild to pvcnCurrentSister.
//              -  Loop till pvcnCurrentSister's _pvcnSister is non NULL  
//                      - Call CopyAppendVirtualCtrNode to create a new node 
//                        pvcnNextBornSister and append it to pvcnFirstBorn. Pl.
//                        note that append function would take care to append
//                        it to its older sister.
//                      - Assign pvcnCurrentSister's _pvcnSister to  variable
//                        pvcnCurrentSister. 
//                      - If pvcnCurrentSister's _pvcnChild is non NULL, then
//                        make a recursive call to self CopyGrowVirtualDFTree. 
//                      - Reinitialize pvcnNextBornSister to NULL & go back to
//                        top of this inner loop and repeat.
//              - Assign  pvcnNextBorn to pvcnFirstBorn and reinitailize pvcn
//                NextBorn to NULL.
//              - Assign pvcnCurrentChild's _pvcnChild to pvcnCurrentChild.
//              - Go to top of outer loop and repeat. 
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

HRESULT VirtualDF::CopyGrowVirtualDFTree(
    VirtualCtrNode  *pvcnFrom,
    VirtualCtrNode  *pvcnTo,
    TREEOP          treeOpType)
{
    HRESULT             hr                  =   S_OK;
    VirtualCtrNode      *pvcnFirstBorn      =   NULL;
    VirtualCtrNode      *pvcnNextBorn       =   NULL;
    VirtualCtrNode      *pvcnNextBornSister =   NULL;
    VirtualCtrNode      *pvcnCurrentSister  =   NULL;
    VirtualCtrNode      *pvcnCurrentChild   =   NULL;

    DH_VDATEPTRIN(pvcnFrom, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pvcnTo, VirtualCtrNode) ; 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::CopyGrowVirtualDFTree"));

    DH_ASSERT(NULL != pvcnFrom);
    DH_ASSERT(NULL != pvcnTo);

    if(S_OK == hr)
    {
        pvcnFirstBorn = pvcnTo;
        pvcnCurrentChild = pvcnFrom;
    }

    while((NULL != pvcnCurrentChild->_pvcnChild) && (S_OK == hr))
    {
        hr = CopyAppendVirtualCtrNode(
                pvcnFirstBorn,
                pvcnCurrentChild->_pvcnChild,
                treeOpType,
                &pvcnNextBorn); 
          
        DH_HRCHECK(hr, TEXT("CopyAppendVirtualCtrNode")) ;

        if(S_OK == hr) 
        {
            pvcnCurrentSister = pvcnCurrentChild->_pvcnChild;

            while((NULL != pvcnCurrentSister->_pvcnSister) && (S_OK == hr))
            {
                hr = CopyAppendVirtualCtrNode(
                         pvcnFirstBorn,
                         pvcnCurrentSister->_pvcnSister,
                         treeOpType,
                         &pvcnNextBornSister);

                DH_HRCHECK(hr, TEXT("CopyAppendVirtualCtrNode")) ;

                pvcnCurrentSister = pvcnCurrentSister->_pvcnSister;

                // Check if there are any children of this sister node, if
                // yes, then make a recursive call to self.  

                if(NULL != pvcnCurrentSister->_pvcnChild)
                {
                    hr = CopyGrowVirtualDFTree(
                            pvcnCurrentSister,
                            pvcnNextBornSister,
                            treeOpType);

                    DH_HRCHECK(hr, TEXT("CopyGrowVirtualDFTree"));
                }

                // Reinitialize the variables

                pvcnNextBornSister = NULL;
            }
                
         }
         pvcnFirstBorn = pvcnNextBorn;
         pvcnNextBorn = NULL;

         pvcnCurrentChild = pvcnCurrentChild->_pvcnChild;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::CopyAppendVirtualCtrNode, protected
//
//  Synopsis:   Creates and appends VirtualCtrNode to VirtualDocFile tree 
//              being created. 
//
//  Arguments:  [pvcnParent] - Parent VirtualCtrNode for the new VirtualCtrNode
//              [pcnSource] -  Corresponding VirtualCtrNode in old VirtualDF 
//                             tree. 
//              [treeOpType]   - OLD_STGSTM or NEW_STGSTM 
//              [ppvcnNew] -   Pointer to pointer to new VirtualCtrNode to be 
//                             created.
//
//  Returns:    HRESULT 
//
//  History:    Narindk   20-May-96   Created
//
//  Notes:      - Creates VirtualCtrNode object ppvcnNew & initializes it with 
//                info based on corresponding old source pvcnSource node.
//              - Appends this node to copy VirtualDF tree being generated.
//              - Calls CopyAppendVirtualStmNodesToVirtualCtrNode to append
//                VirtualStmNodes to this VirtualCtrNode, if present in old
//                source tree, so required to be copied.
//              - Copies in memory CRC for this VirtualCtrNode _dwCRC from old
//                source VirtualCtrNode.
//              - if treeOpType is OLD_STGSTM, as would be in transaction tree
//                copy procedure, when no new disk IStorages/IStreams are made,
//                this assign's new VirtualCtrNode's _pstg to be old source
//                VirtualCtrNode's _pstg.
//---------------------------------------------------------------------------

HRESULT VirtualDF::CopyAppendVirtualCtrNode(
    VirtualCtrNode *pvcnParent,
    VirtualCtrNode *pvcnSource,
    TREEOP         treeOpType,
    VirtualCtrNode **ppvcnNew) 
{
    HRESULT         hr              =   S_OK;
    VirtualCtrNode  *pvcnOldSister  =   NULL;

    DH_VDATEPTROUT(ppvcnNew, PVCTRNODE) ; 
    DH_VDATEPTRIN(pvcnParent, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pvcnSource, VirtualCtrNode) ; 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::CopyAppendChildVirtualCtrNode"));
 
    DH_ASSERT(NULL != pvcnParent);
    DH_ASSERT(NULL != ppvcnNew);
    DH_ASSERT(NULL != pvcnSource);

    if(S_OK == hr)
    { 
        *ppvcnNew = NULL;

        // Allocate and Initialize new VirtualCtrNode

        *ppvcnNew = new VirtualCtrNode();
       
        if (NULL == *ppvcnNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        hr = (*ppvcnNew)->Init(
                pvcnSource->_ptszName, 
                pvcnSource->_cChildren, 
                pvcnSource->_cStreams);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Init")) ;
    }

    // Append new VirtualCtr Node

    if(S_OK == hr)
    {
        if(NULL == pvcnParent->_pvcnChild)
        {
            hr = pvcnParent->AppendChildCtr(*ppvcnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendChildCtr")) ;
        }
        else
        {
            pvcnOldSister = pvcnParent->_pvcnChild;
            while(NULL != pvcnOldSister->_pvcnSister)
            {
                pvcnOldSister = pvcnOldSister->_pvcnSister;
            }

            hr = pvcnOldSister->AppendSisterCtr(*ppvcnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendSisterCtr")) ;
        }
    }
     
    if ((S_OK == hr) && (0 != (*ppvcnNew)->_cStreams))
    {
       hr = CopyAppendVirtualStmNodesToVirtualCtrNode(
                (*ppvcnNew)->_cStreams, 
                 *ppvcnNew,
                 pvcnSource,
                 treeOpType);

       DH_HRCHECK(hr, TEXT("CopyAppendVirtualStmNodesToVirtualCtrNode")) ;
    }

    if(S_OK == hr)
    {
       (*ppvcnNew)->_dwCRC = pvcnSource->_dwCRC; 

        if(OLD_STGSTM == treeOpType)
        {
            (*ppvcnNew)->_pstg = pvcnSource->_pstg;
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::CopyAppendVirtualStmNodesToVirtualCtrNode, protected
//
//  Synopsis:   Creates and appends VirtualStmNode(s) to VirtualCtrNode 
//
//  Arguments:  [cStreams] -     Number of streams to be created 
//              [pvcn]     -     Pointer to VirtualCtrNode for which the streams
//                               need to be created and appended.
//              [pvcnSource] -   Pointer to correspoding VirtualCtrNode in 
//                               old VirtualDF tree. 
//              [treeOpType] -   OLD_STGSTM or NEW_STGSTM
//
//  Returns:    HRESULT 
//
//  History:    Narindk   20-May-96   Created
//
//  Notes:      if number of streams to be created and appended to parent 
//              VirtualCtrNode pvcn is not zero, then loop till cStreams is
//              not equal to zero.
//                  - First time in loop, assign pvsnSource from pvcnSource's
//                    _pvcsnStream, otherwise assign pvsnSource's _pvsnSister
//                    to pvsnSource with each traversal of loop.
//                  - Call CopyAppendVirtualStmNode to create a new VirtualStm
//                    Node and append it to parent VirtualCtrNode. Pl. note that
//                    this function would take care if the newly created node
//                    need to be appended to older VirtualStmNode sister.
//                  - Decrement cStreams and go back to top of loop & repeat.
//---------------------------------------------------------------------------

HRESULT VirtualDF::CopyAppendVirtualStmNodesToVirtualCtrNode(
    ULONG           cStreams,
    VirtualCtrNode  *pvcn,
    VirtualCtrNode  *pvcnSource,
    TREEOP          treeOpType)
{
    HRESULT         hr              =   S_OK;
    VirtualStmNode  *pvsnSource     =   NULL;

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pvcnSource, VirtualCtrNode) ; 

    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("::CopyAppendVirtualStmNodesToVirtualCtrNode"));
 
    DH_ASSERT(0 != cStreams);
    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pvcnSource);

    while((S_OK == hr) && (0 != cStreams))
    {
        if(NULL == pvsnSource)
        {
            pvsnSource = pvcnSource->_pvsnStream;
        }
        else
        {
            pvsnSource = pvsnSource->_pvsnSister;
        }

        DH_ASSERT(NULL != pvsnSource);

        hr = CopyAppendVirtualStmNode(
                pvcn,   
                pvsnSource,
                treeOpType);

        DH_HRCHECK(hr, TEXT("CopyAppendFirstVirtualStmNode")) ;

        cStreams--;
 
    }
    return hr;
}
 
//----------------------------------------------------------------------------
//  Member:     VirtualDF::CopyAppendVirtualStmNode, protected
//
//  Synopsis:   Creates and appends first VirtualStmNode to VirtualCtrNode 
//
//  Arguments:  [pvcnParent] - Pointer to VirtualCtrNode for which the streams
//                             need to be created and appended. 
//              [pvsnSource] - Pointer to corresponding VirtualStmNode in old
//                             VirtualDF tree.
//              [treeOpType] - OLD_STGSTM or NEW_STGSTM
//
//  Returns:    HRESULT 
//
//  History:    Narindk   20-May-96   Created
//
//  Notes:      - Creates VirtualStmNode pvsnNew and initializes it with above
//                info from pvsnSource
//              - Appends this node to the parent VirtualCtrNode pvcnParent.
//              - Copies in memory CRC for this VirtualStmNode's _dwCRC from old
//                source pvsnSource.
//              - if treeOpType is OLD_STGSTM, as would be in transaction tree
//                copy procedure, when no new disk IStorages/IStreams are made,
//                this assign's new VirtualStmNode's _pstm to be pvsnSource's
//                _pstm 
//---------------------------------------------------------------------------

HRESULT VirtualDF::CopyAppendVirtualStmNode(
    VirtualCtrNode *pvcnParent,
    VirtualStmNode *pvsnSource,
    TREEOP         treeOpType)
{
    HRESULT         hr              =   S_OK;
    VirtualStmNode  *pvsnNew        =   NULL;
    VirtualStmNode  *pvsnOldSister  =   NULL;
 
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::CopyAppendFirstVirtualStmNode"));

    DH_VDATEPTRIN(pvcnParent, VirtualCtrNode) ; 
    DH_VDATEPTRIN(pvsnSource, VirtualStmNode) ; 
 
    DH_ASSERT(NULL != pvcnParent);
    DH_ASSERT(NULL != pvsnSource);

    if (S_OK == hr)
    {
        pvsnNew = new VirtualStmNode();

        if (NULL == pvsnNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if(S_OK == hr)
    {
        hr = pvsnNew->Init(pvsnSource->_ptszName, pvsnSource->_cb);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Init")) ;
    }

    if(S_OK == hr)
    {
        if(NULL == pvcnParent->_pvsnStream)
        { 
            // Append it to parent storage
 
            hr = pvcnParent->AppendFirstChildStm(pvsnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendFirstChildStm")) ;
        }
        else
        {
            pvsnOldSister = pvcnParent->_pvsnStream;
            
            while(NULL != pvsnOldSister->_pvsnSister)
            {
                pvsnOldSister = pvsnOldSister->_pvsnSister;
            }

            // Append it to preceding sister stream 
 
            hr = pvsnOldSister->AppendSisterStm(pvsnNew);

            DH_HRCHECK(hr, TEXT("VirtualStmNode::AppendSisterStm")) ;
        }
    }

    if(S_OK == hr)
    {
        pvsnNew->_dwCRC.dwCRCName =  pvsnSource->_dwCRC.dwCRCName; 
        pvsnNew->_dwCRC.dwCRCData =  pvsnSource->_dwCRC.dwCRCData; 
        pvsnNew->_dwCRC.dwCRCSum =  pvsnSource->_dwCRC.dwCRCSum; 

        if(OLD_STGSTM == treeOpType)
        {
            pvsnNew->_pstm = pvsnSource->_pstm;
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     VirtualDF::Associate, public
//
//  Synopsis:   Assocaies a VirtualDF tree with a VirtualCtrNode and its name.
//
//  Arguments:  [pvcn]    - Pointer to VirtualCtrNode to be associated with
//              [pIStorage] - pointer to Disk IStorage to associate with
//
//  Returns:    HRESULT 
//
//  History:    Narindk   6-June-96   Created
//
//  Notes:      This function is currently being used by GenerateVirtualDFFrom
//              DiskDF in util.cxx.  
//---------------------------------------------------------------------------

HRESULT VirtualDF::Associate(
    VirtualCtrNode *pvcn, 
    LPSTORAGE       pIStorage,
    ULONG           ulSeed)
{
    HRESULT     hr  =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::Associate"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode);
    DH_VDATEPTRIN(pIStorage, IStorage);

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pIStorage);

    // Associate name

    if(S_OK == hr)
    {
        _ptszName = new TCHAR[_tcslen(pvcn->_ptszName)+1];

        if (_ptszName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            _tcscpy(_ptszName, pvcn->_ptszName);
        }
    }

    // Associate given root IStorage with root VirtualCtrNode's _pstg and
    // also Associate root of VirtualDF _pvcnRoot with the passed in root
    // VirtualCtrNode.

    if(S_OK == hr)
    {
        pvcn->_pstg = pIStorage;
        _pvcnRoot = pvcn;
    }

    // Create the DataGens if we need to and if we can
    // If ulSeed is UL_INVALIDSEED, caller is not interested.
    if (UL_INVALIDSEED != ulSeed)
    {
        // We need a totally new set of datagens to prevent
        // duplicate names. So Generate a new seed.
        DG_INTEGER *pdgiNew = new DG_INTEGER (ulSeed);
        if (NULL != pdgiNew)
        {
            ULONG ulTmp = 0;
            if (DG_RC_SUCCESS == pdgiNew->Generate(&ulTmp, 0, 0xFFFFFFFF))
            {
                ulSeed = ulTmp;
            }
            delete pdgiNew;
        } 
        if (NULL == _pdgi)
        {
            _pdgi = new(NullOnFail) DG_INTEGER(ulSeed);
        }
        if (NULL == _pgdu)
        {
            _pgdu = new(NullOnFail) DG_STRING(ulSeed);
        }
        if (NULL == _pdgi || NULL == _pgdu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


//----------------------------------------------------------------------------
//  Member:     VirtualDF::DeleteVirtualCtrNodeStreamNode, public
//
//  Synopsis:   Deletes the VirtualStmNode passed in under the given 
//              VirtualCtrNode.
//
//  Arguments:  [*pvcn]- Pointer to VirtualCtrNode for which VirtualStmNode
//                       need to be deleted.
//              [*pvsn] - Pointer to VirtualStmNode to be deleted
//
//  Returns:    HRESULT 
//
//  History:    Narindk   9-July-96   Created
//
//  Notes:      - Assign a temp variable pvsnTemp to point to _pvsnStream of
//                passed in VirtualStmNode pvsn's _pvcnParent.
//              - Delete the corresponding VirtualStmNode from VirtualCtrNode
//                chain of VirtualStmNode and readjusts parent VirtualCtrNode
//                /child VirtualStmNodes pointers and _cStreams count of the
//                VirtualCtrNode.
//                  - In a loop, befor entering into which pvsnOldSister is
//                    set to NULL, find the passed in VirtualStmNode and
//                    break when found.
//                  - if VirtualStmNode to be deleted is first one in the
//                    VirtualStmNode chain of parent, then parent VirtualCtr
//                    Node's _pvsnStream ptr needs to be adjusted to point to
//                    "to be delted" VirtualStmNode's _pvsnSister.
//                  - If VirtualStmNode to be deleted is not first one in the
//                    VirtualStmNode chain, then its older sister is located
//                    and its _pvsnSister pointer is adjusted to "to be delted"
//                    VirtualStmNode's _pvsnSister.
//                  - Decrease the _cStreams count of the VirtualCtrNode parent
//                  - Delete the VirtualStmNode after setting its pointers to
//                    NULL. 
//---------------------------------------------------------------------------

HRESULT VirtualDF::DeleteVirtualCtrNodeStreamNode(VirtualStmNode *pvsn)
{
    HRESULT         hr              =   S_OK;
    VirtualStmNode  *pvsnTemp       =   NULL;
    VirtualStmNode  *pvsnOldSister  =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::DeleteVirtualCtrNodeStreamNode"));

    DH_VDATEPTRIN(pvsn, VirtualStmNode);

    DH_ASSERT(NULL != pvsn);
    DH_ASSERT(NULL != pvsn->_pvcnParent);

    if(S_OK == hr)
    {
        pvsnTemp = pvsn->_pvcnParent->_pvsnStream;
        pvsnOldSister = NULL;

        // This locates the VirtualStmNode to be deleted  and the
        // nodes whose pointers may need to be readjusted.

        while((pvsnTemp != pvsn) && (NULL != pvsnTemp->_pvsnSister))
        {
            pvsnOldSister = pvsnTemp;
            pvsnTemp = pvsnTemp->_pvsnSister;
        }

        DH_ASSERT(pvsnTemp == pvsn);

        // Adjust the pointers

        if(NULL == pvsnOldSister)
        {
            pvsn->_pvcnParent->_pvsnStream = pvsnTemp->_pvsnSister;
        }
        else
        {
            pvsnOldSister->_pvsnSister = pvsnTemp->_pvsnSister;
        }

        // Decrease the stream count of the parent VirtualCtrNode parent.

        pvsn->_pvcnParent->_cStreams--;

        // Delete the node after NULLing its pointers.

        pvsnTemp->_pvcnParent = NULL;
        pvsnTemp->_pvsnSister= NULL;
        delete pvsnTemp;
        pvsnTemp = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\vsnode.cxx ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  All rights reserved.
//
//  File:       vsnode.cxx
//
//  Contents:   Implementation for in-memory Virtual Stream Node class.
//
//  Classes:    VirtualStmNode (vsn)
//
//  Functions:  VirtualStmNode()
//              ~VirtualStmNode
//              Init
//              AppendSisterStm
//              Create
//              Read
//              Write
//              Open
//              Close
//              Seek
//              SetSize
//              Commit
//              Revert
//              Stat
//              CopyTo
//              AddRefCount
//              QueryInterface
//              LockRegion
//              UnlockRegion
//              Clone
//              Rename
//              Destroy
//
//              NOTE: All above functions are public
//
//  History:    DeanE   21-Mar-96   Created
//              Narindk 24-Apr-96   Added more functions. 
//              georgis 02-Apr-98   UpdateCRC
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug object declaration

DH_DECLARE;

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::VirtualStmNode, public
//
//  Synopsis:   Constructor.  No work done here and this method cannot
//              fail.  See ::Init method for real initialization work.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   21-Mar-96   Created
//---------------------------------------------------------------------------

VirtualStmNode::VirtualStmNode() : _ptszName(NULL),
                                   _cb(0),
                                   _pvsnSister(NULL),
                                   _pvcnParent(NULL),
                                   _pstm(NULL)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::VirtualStmNode"));
    _dwCRC.dwCRCName = CRC_PRECONDITION;
    _dwCRC.dwCRCData = CRC_PRECONDITION;
    _dwCRC.dwCRCSum = CRC_PRECONDITION;
}


//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::~VirtualStmNode, public
//
//  Synopsis:   Destructor.  Frees resources associated with this object,
//              including closing the storage if open and removing this
//              tree from memory.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    DeanE   21-Mar-96   Created
//---------------------------------------------------------------------------

VirtualStmNode::~VirtualStmNode()
{
    ULONG   ulRef   =   0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::~VirtualStmNode"));

    if(NULL != _ptszName)
    {
        delete _ptszName;
        _ptszName = NULL;
    }

    if ( NULL != _pstm )
    {
        ulRef = _pstm->Release();

        // Object is being destructed, assert if reference count is non zero.
        DH_ASSERT(0 == ulRef);

        _pstm = NULL;
    }
}


//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Init, public
//
//  Synopsis:   Initializes a stream node - does not open or create the
//              actual stream.
//
//  Arguments:  [tszName]    - Name of this stream
//              [cb]         - Size of this stream
//
//  Returns:    S_OK if node initialized successfully, otherwise an error.
//
//  History:    DeanE   21-Mar-96   Created
//              Narindk 24-Apr-96   Enhanced
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Init( LPTSTR tszName, ULONG cb)
{
    HRESULT hr = S_OK;

    DH_VDATESTRINGPTR(tszName);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Init"));

    DH_ASSERT(NULL != tszName);

    if(S_OK == hr)
    {
        _ptszName = new TCHAR[_tcslen(tszName)+1];

        if (_ptszName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            _tcscpy(_ptszName, tszName);
            _cb = cb;
        }
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::AppendSisterStm, public
//
//  Synopsis:   Appends the node passed to the end of this nodes' sister
//              node chain.
//
//  Arguments:  [pcnNew] - The new node to append.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    17-Apr-96   Narindk     Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::AppendSisterStm(VirtualStmNode *pvsnNew)
{
    HRESULT         hr          = S_OK;
    VirtualStmNode  *pvsnTrav   = this;

    DH_VDATEPTRIN(pvsnNew, VirtualStmNode);
 
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::AppendSisterStm"));

    DH_ASSERT(NULL != pvsnNew);

    if(S_OK == hr)
    {
        // Find the last sister in the chain 
    
        while (NULL != pvsnTrav->_pvsnSister)
        {
            pvsnTrav = pvsnTrav->_pvsnSister;
        }

        // Append the new node as a sister of the last node,
        // and make the new node point to this nodes parent as it's parent

        pvsnTrav->_pvsnSister = pvsnNew;
        pvsnNew->_pvcnParent = pvsnTrav->_pvcnParent;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Create, public
//
//  Synopsis:   Wrapper for IStorage::CreateStream that will create and
//              open a new IStream object within this storage object.
//
//  Arguments:  [grfmode] -     Access mode for creating & opening new storage
//                              object.
//              [dwReserved1] - Reserved by OLE for future use, must be zero.
//              [dwReserved2] - Reserved by OLE for future use, must be zero.
//
//  Returns:    S_OK                    Stream created successfully. 
//              STG_E_ACCESSDENIED      Insufficient permissions to create.
//              STG_E_INVALIDPOINTER    Bad pointer was passed in.
//              STG_E_FILEALREADYEXISTS File with specified name exists and
//                                      mode is set to STGM_FAILIFTHERE.
//              STG_TOOMANYOPENFILES    too many open files 
//              STG_E_INSUFFICIENTMEMORY Out of memory.
//              STG_E_INVALIDFLAG       Unsuppoeted value in grfmode.
//              STG_E_INVALIDPARAMETER  Invalid parameter.
//              STG_E_INVALIDNAME       Invalid value for ptcsName.
//              STG_E_REVERTED          Object has been invalidated by a revert
//                                      operation above it in transaction tree.
//
//  History:    18-Apr-96   NarindK     Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Create(
    DWORD       grfMode,
    DWORD       dwReserved1,
    DWORD       dwReserved2)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrTemp =   NULL;

    DH_ASSERT(0 == dwReserved1);
    DH_ASSERT(0 == dwReserved2);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Create"));

    DH_ASSERT(NULL != _pvcnParent);
    DH_ASSERT(NULL != _pvcnParent->_pstg);

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->CreateStream(
                pOleStrTemp, 
                grfMode, 
                dwReserved1, 
                dwReserved2, 
                &_pstm);

        DH_HRCHECK(hr, TEXT("IStorage::CreateStream")) ;
        DH_TRACE ((DH_LVL_DFLIB, TEXT("CreateStream:%s"), _ptszName));

    }

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Read, public
//
//  Synopsis:   Reads data from the stream starting at current seek pointer.
//
//  Arguments:  [pv] - Points to buffer in which stream data should be stored.
//              [cb] - Specifies number of bytes to read from the stream.
//              [pcbRead] - Points to the number if bytes actually read from
//                     from the stream.  Caller can specify it as NULL if not
//                     interested in this value.
//
//  Returns:    S_OK                    Data successfully read from stream. 
//              S_FALSE                 Data couldn't be read from the stream.
//              STG_E_ACCESSDENIED      Insufficient access.
//              STG_E_INVALIDPOINTER    Bad pointer passed in pv.
//              STG_E_REVERTED          Object has been invalidated by a revert
//                                      operation above it in transaction tree.
//              STG_E_WRITEFAULT        Disk error during a write operaion.
//              Other errors            Any ILockBytes or system errors.
//
//  History:    18-Apr-96   NarindK     Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Read(
    PVOID       pv, 
    ULONG       cb, 
    ULONG       *pcbRead)
{
    HRESULT     hr      =   S_OK;
    LPSTREAM    pstm    =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Read"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->Read(pv, cb, pcbRead);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Read"));
    }

    // BUBUG: To check invalid parameter checking, may have to remove DH_
    // validate macros.

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Write, public
//
//  Synopsis:   Writes data cb bytes from buffer pointed to by pv into stream 
//              starting at current seek pointer.
//
//  Arguments:  [pv] - Points to buffer containing data to be written to stream 
//              [cb] - Specifies number of bytes to write into the stream.
//              [pcbWritten] - Points to the number if bytes actually written  
//                     to the stream.  Caller can specify it as NULL if not
//                     interested in this value.
//
//  Returns:    S_OK                    Data successfully read from stream. 
//              S_E_MEDIUMFULL          No space left on device. 
//              STG_E_ACCESSDENIED      Insufficient access.
//              STG_E_CANTSAVE          Data cannot be written for reasons other
//                                      than no access or space.
//              STG_E_INVALIDPOINTER    Bad pointer passed in pv.
//              STG_E_REVERTED          Object has been invalidated by a revert
//                                      operation above it in transaction tree.
//              STG_E_WRITEFAULT        Disk error during a write operaion.
//              Other errors            Any ILockBytes or system errors.
//
//  History:    18-Apr-96   NarindK     Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Write(
    PVOID       pv, 
    ULONG       cb, 
    ULONG       *pcbWritten)
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Write"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->Write(pv, cb, pcbWritten);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Write"));
    }

    if (( S_OK == hr) && (NULL != pcbWritten))
    {
        if (cb != *pcbWritten)
        {
            hr = E_FAIL;

            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualStmNode::Write - bytes: Expected=%lu, Actual=%lu"),
                cb,
                *pcbWritten));

            DH_ASSERT(
                !TEXT("Expected and actual bytes written mismatch!"));
        }
    }

    // BUBUG: To check invalid parameter checking, may have to remove DH_
    // validate macros.

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Open, public
//
//  Synopsis:   Opens an existing named stream according to grfMode.
//                                   OLE doesn't support opening streams in
//              transacted mode, also doesn't allow opening the same stream 
//              from same open IStorage instance.
//
//  Arguments:  [pvReserved1] - Reserved for future use.  Must be NULL.
//              [grfmode]     - Mode in which stream should be opened.
//              [dwReserved2] - Reserved for future use.  Must be NULL. 
//
//  Returns:    HRESULT 
//              S_OK                    Stream was opened successfully.
//              STG_E_ACCESSDENIED      Insufficient access to open stream.
//              STG_E_FILENOTFOUND      Stream of specified name doesn't exist.
//              STG_E_INVALIDFLAG       Unsupported value in grfMode.
//              STG_E_INVALIDNAME       Invalid name.
//              STG_E_INVALIDPOINTER    Bad pointer passed in pv.
//              STG_E_REVERTED          Object has been invalidated by a revert
//                                      operation above it in transaction tree.
//              STG_E_INVALIDPARAMETER  Invalid parameter.
//
//  History:    NarindK   24-Apr-96   Created
//---------------------------------------------------------------------------
HRESULT VirtualStmNode::Open(
    PVOID       pvReserved1, 
    DWORD       grfmode, 
    DWORD       dwReserved2)
{
    HRESULT     hr          = S_OK;
    LPSTREAM    pstm        = NULL;
    LPOLESTR    pOleStrTemp =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Open"));

    DH_ASSERT(NULL == pvReserved1);
    DH_ASSERT(0 == dwReserved2);

    DH_ASSERT(NULL != _pvcnParent);
    DH_ASSERT(NULL != _pvcnParent->_pstg);

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->OpenStream(pOleStrTemp,
                              pvReserved1,
                              grfmode,
                              dwReserved2,
                              &pstm);

        DH_HRCHECK(hr, TEXT("IStorage::OpenStream"));
        DH_TRACE ((DH_LVL_DFLIB, TEXT("OpenStream:%s"), _ptszName));
    }
   
    if((S_OK == hr) && (NULL == _pstm))
    {
        _pstm = pstm;
    }

    DH_HRCHECK(hr, TEXT("VirtualStmNode::Open"));

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Close, public
//
//  Synopsis:   Closes an open stream.  
//
//  Arguments:  none 
//
//  Returns:    HRESULT 
//
//  History:    NarindK   25-Apr-96   Created
//---------------------------------------------------------------------------
HRESULT VirtualStmNode::Close()
{
    HRESULT     hr      =   S_OK;
    ULONG       ulRef   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Close"));

    DH_ASSERT(NULL != _pstm);

    // When we create the stream, it is open.  We do not call release
    // on _pstm normally till the VirtualStmNode object is destructed, or
    // if explicitly this function is used to close the stream.

    if ( NULL != _pstm )
    {
        ulRef = _pstm->Release();
    }
    else
    {
        DH_ASSERT(!TEXT("_pstm is already NULL!"));
    }

    DH_HRCHECK(hr, TEXT("VirtualStmNode::Close"));

    if(0 == ulRef)
    {
        _pstm = NULL;
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Seek, public
//
//  Synopsis:   Adjusts the location of seek pointer on the stream.  
//
//  Arguments:  [dlibMove]
//              [dwOrigin]
//              [plibNewPosition] 
//
//  Returns:    HRESULT 
//
//  History:    NarindK   25-Apr-96   Created
//---------------------------------------------------------------------------
HRESULT VirtualStmNode::Seek( 
    LARGE_INTEGER   dlibMove,
    DWORD           dwOrigin,
    ULARGE_INTEGER  *plibNewPosition)
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Seek"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->Seek(dlibMove, dwOrigin, plibNewPosition);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::SetSize, public
//
//  Synopsis:   Changes the size of the stream. 
//
//  Arguments:  [libNewSize]    Specifies new size of stream 
//
//  Returns:    HRESULT
//              S_OK                   Stream size was successfully changed.
//              STG_E_MEDIUMFULL       Lack of space prohibited change of size
//              STG_E_INVALIDFUNCTIONS High DWORD of libNewSize != 0
//              STG_E_WRITEFAULT       Disk error during a write operation. 
//              STG_E_REVERTED         Object has been invalidated by a revert
//                                     operation above it in transaction tree.
//              Other errors           Any ILockBytes or system errors.
//
//  History:    NarindK   29-Apr-96   Created
//---------------------------------------------------------------------------
HRESULT VirtualStmNode::SetSize(ULARGE_INTEGER  libNewSize)
{
    HRESULT     hr      =   S_OK;
    LPSTREAM    pstm    =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::SetSize"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->SetSize(libNewSize);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::SetSize"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Commit, public
//
//  Synopsis:   Commits any changes made to IStorage object containing the 
//              stream. 
//
//  Arguments:  [grfCommitFlags]    Controls how obect is committed to IStorage 
//
//  Returns:    HRESULT
//              S_OK                   Stream successfully committed.
//              STG_E_MEDIUMFULL       Commit failde due to lack of space 
//              STG_E_WRITEFAULT       Disk error during a write operation. 
//              STG_E_REVERTED         Object has been invalidated by a revert
//                                     operation above it in transaction tree.
//              Other errors           Any ILockBytes or system errors.
//
//  History:    NarindK   29-Apr-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Commit(DWORD  grfCommitFlags)
{
    HRESULT     hr      =   S_OK;
    LPSTREAM    pstm    =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Commit"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->Commit(grfCommitFlags);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Commit"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Revert, public
//
//  Synopsis:   Discards any changes made to stream object since it was opened
//              or last committed in transacted mode.  This function is a noop
//              in direct mode. 
//
//  Arguments:  none
//
//  Returns:    HRESULT
//              S_OK                   Stream successfully committed.
//              STG_E_WRITEFAULT       Disk error during a write operation. 
//              STG_E_REVERTED         Object has been invalidated by a revert
//                                     operation above it in transaction tree.
//              Other errors           Any ILockBytes or system errors.
//
//  History:    NarindK   29-Apr-96   Created
//
//  Notes:      OLE doesn't support IStream objects being opened in transacted
//              mode, os most applications don't need to call this function.
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Revert()
{
    HRESULT     hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Revert"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->Revert();

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Revert"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Stat, public
//
//  Synopsis:   Returns relevant statistics concerning this open stream. 
//
//  Arguments:  [pStatStg] - pointer to STATSTG structure.
//              [grfStatFlag] - Controls levels of returned statistics.
//
//  Returns:    S_OK                Stastics were successfully returned.
//              STG_E_ACCESSDENIED  Stm cannot be accessed.
//              STG_E_REVERTED      Object invalidated by a revert operation
//                                  above it in transaction tree.
//              STG_E_INSUFFICIENTMEMORY Not enough memory.
//              STG_E_INVALIDPOINTER     Invalid pointer.
////
//  History:    NarindK   8-May-96   Created
//---------------------------------------------------------------------------
HRESULT VirtualStmNode::Stat( 
    STATSTG         *pStatStg,
    DWORD           grfStatFlag)
{
    HRESULT     hr          =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Stat"));

    DH_ASSERT(_pstm != NULL);
    DH_ASSERT(NULL != pStatStg);
    DH_ASSERT((
        (grfStatFlag == STATFLAG_DEFAULT) || 
        (grfStatFlag == STATFLAG_NONAME)));


    if(S_OK == hr)
    {
        hr = _pstm->Stat(pStatStg, grfStatFlag);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Stat"));
    }

    // BUGBUG:  May remove to need DH_ assert macros to do invalid parameter
    // checking.

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::CopyTo, public
//
//  Synopsis:   Copies data from one stream to another strea, starting at the
//              current seek pointer in each stream. 
//
//  Arguments:  [pvsn] - pointer to VirtualStmNode into whose stream the data
//                       should be copied into. 
//              [cb] -   Specifies number of bytes to be read from source stream
//              [pcbRead] - Contains the number of bytes actually read from the
//                       source stream.
//              [pcbWritten] - Contains number of bytes actually written to the
//                       destination stream.
//
//  Returns:    S_OK                Stream successfully copied.
//              STG_E_MEDIUMFULL    Lack of space prohibited copy.
//              STG_E_READFAULT     Disk error during read.
//              STG_E_WRITEFAULT    Disk error during write opearion.
//              STG_E_INVALIDPOINTER     Invalid pointer.
//              STG_E_REVERTED      Object invalidated by a revert operation
//                                  above it in transaction tree.
//              STG_E_INSUFFICIENTMEMORY Not enough memory.
//              Other errors
//
//  History:    NarindK   9-May-96   Created
//
//  Notes:      BUGBUG: Currently not updating the _cb datasize member
//              of virtualstmnode objects involved. required?
//---------------------------------------------------------------------------
HRESULT VirtualStmNode::CopyTo( 
    VirtualStmNode  *pvsnDest,
    ULARGE_INTEGER  cb,
    ULARGE_INTEGER  *pcbRead,
    ULARGE_INTEGER  *pcbWritten)
{
    HRESULT     hr          =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::CopyTo"));

    DH_VDATEPTROUT(pvsnDest, VirtualStmNode);
    DH_ASSERT(NULL != _pstm);
    DH_ASSERT(NULL != pvsnDest);
    DH_ASSERT(NULL != pvsnDest->_pstm);

    if(S_OK == hr)
    {
        hr = _pstm->CopyTo(pvsnDest->_pstm, cb, pcbRead, pcbWritten);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::CopyTo"));
    }

    return hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::AddRefCount, public
//
//  Synopsis:   Increments the reference count on IStream object. 
//
//  Arguments:  none 
//
//  Returns:    HRESULT
//
//  History:    NarindK   21-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::AddRefCount()
{
    HRESULT     hr      =   S_OK;
    ULONG       ulTmp   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::AddRefCount"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        ulTmp = _pstm->AddRef();
    }

    DH_HRCHECK(hr, TEXT("VirtualStmNode::AddRefCount"));

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::QueryInterface, public
//
//  Synopsis:   Returns pointers to supported objects. 
//
//  Arguments:  none
//
//  Returns:    HRESULT
//
//  History:    NarindK   21-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::QueryInterface(
    REFIID      riid, 
    LPVOID      *ppvObj)
{
    HRESULT     hr      =   S_OK;

    DH_VDATEPTROUT(ppvObj, IUnknown *) ;
    
    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::QueryInterface"));

    DH_ASSERT(NULL != ppvObj);
    DH_ASSERT(NULL != _pstm);

    if(S_OK == hr)
    {
        // Initilze the out parameter

        *ppvObj = NULL;

        hr = _pstm->QueryInterface(riid, ppvObj);
    }

    DH_HRCHECK(hr, TEXT("VirtualStmNode::QueryInterface"));

    if(S_OK == hr)
    {
        DH_ASSERT(NULL != *ppvObj);
    }
    else
    {
        DH_ASSERT(NULL == *ppvObj);
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::LockRegion, public
//
//  Synopsis:   Locks a range of bytes in the stream. 
//
//  Arguments:  [libOffset] - Specifies beginning of region to lock.
//              [cb]        - Specifies length of region to be locked in bytes.
//              [dwLockType]- Specifies kind of lock beng requested. 
//
//  Returns:    HRESULT
//              S_OK                    Range of bytes was successfully locked.
//              STG_E_INVALIDFUNCTION   Function not supported in this release
//              STG_E_LOCKVIOLATION     Requested lock supported, but can't be
//                                      granted presently becoz of existing
//                                      lock.
//
//  History:    NarindK   22-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::LockRegion(
    ULARGE_INTEGER      libOffset,
    ULARGE_INTEGER      cb,
    DWORD               dwLockType)
{
    HRESULT     hr      =   S_OK;
    LPSTREAM    pstm    =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::LockRegion"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->LockRegion(libOffset, cb, dwLockType);
    }

    DH_HRCHECK(hr, TEXT("VirtualStmNode::LockRegion"));

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::UnlockRegion, public
//
//  Synopsis:   Unlocks a region of stream previously locked by IStream::
//              LockRegion
//
//  Arguments:  [libOffset] - Specifies beginning of region to lock.
//              [cb]        - Specifies length of region to be locked in bytes.
//              [dwLockType]- Specifies kind of lock beng requested. 
//
//  Returns:    HRESULT
//              S_OK                    Requested unlock granted.
//              STG_E_INVALIDFUNCTION   Function not supported in this release
//              STG_E_LOCKVIOLATION     Requested unlock can't be granted.
//
//  History:    NarindK   22-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::UnlockRegion(
    ULARGE_INTEGER      libOffset,
    ULARGE_INTEGER      cb,
    DWORD               dwLockType)
{
    HRESULT     hr          =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::UnlockRegion"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        hr = _pstm->UnlockRegion(libOffset, cb, dwLockType);
    }

    DH_HRCHECK(hr, TEXT("VirtualStmNode::UnlockRegion"));

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Clone, public
//
//  Synopsis:   Returns a new IStream object that is clone of this stream. 
//
//  Arguments:  [ppstm] -   Points to where new stream to be returned.
//
//  Returns:    HRESULT
//              S_OK                   Stream successfully copied. 
//              E_OUTOFMEMORY          Out of memory 
//              STG_E_INVALIDPOINTER    Bad pointer was passed in.
//              STG_E_INSUFFICIENTMEMORY Not enough memory 
//              STG_E_WRITEFAULT       Disk error during a write operation. 
//              STG_E_REVERTED         Object has been invalidated by a revert
//                                     operation above it in transaction tree.
//              Other errors           Any ILockBytes or system errors.
//
//  History:    NarindK   22-May-96   Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Clone(LPSTREAM  *ppstm)
{
    HRESULT     hr      =   S_OK;
    LPSTREAM    pstm    =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Clone"));

    DH_ASSERT(_pstm != NULL);

    if(S_OK == hr)
    {
        // Initialize out parameter

        *ppstm = NULL;

        hr = _pstm->Clone(ppstm);
    }

    DH_HRCHECK(hr, TEXT("VirtualStmNode::Clone"));

    if(S_OK == hr)
    {
        DH_ASSERT(NULL != *ppstm);
    }
    else
    {
        DH_ASSERT(NULL == *ppstm);
    }

    return(hr);
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Rename, public
//
//  Synopsis:   Wrapper for IStorage::RenameElement that renames a stream  
//              contained in an Storage object subject to transaction state
//              of IStorage object. 
//
//  Arguments:  [pptcsNewName] - Points to pointer to new name for the element. 
//
//  Returns:    S_OK                Object was successfully renamed. 
//              STG_E_ACCESSDENIED  Named element ptcsNewName alreadys exists. 
//              STG_E_FILENOTFOUND  Element couldn't be found.
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//              STG_E_INSUFFICIENTMEMORY Not enough memory to rename element.
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDNAME        Invalid name.  
//              STG_E_INVALIDPARAMETER   Invalid parameter  
//              STG_E_TOOMANYOPENFILES   too many open files.
//
//  History:    8-July-96   NarindK     Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Rename(LPCTSTR ptcsNewName)
{
    HRESULT     hr          =   S_OK;
    LPOLESTR    pOleStrOld  =   NULL;
    LPOLESTR    pOleStrNew  =   NULL;

    DH_VDATESTRINGPTR(ptcsNewName);

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Rename"));

    DH_ASSERT(NULL != _pvcnParent);
    
    DH_ASSERT(NULL != _pvcnParent->_pstg);

    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrOld);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        // Convert ptcsNewName to OLECHAR

        hr = TStringToOleString((LPTSTR)ptcsNewName, &pOleStrNew);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->RenameElement(pOleStrOld, pOleStrNew);

        DH_HRCHECK(hr, TEXT("IStorage::Rename")) ;
    }

    if(S_OK == hr)
    {
        // Change the name of VirtualStmNode i.e. its _ptszName variable also

        // First delete the old name

        if(NULL != _ptszName)
        {
            delete _ptszName;
            _ptszName = NULL;
        }

        // Now copy the new name by allocating enough memory
        _ptszName = new TCHAR[_tcslen(ptcsNewName)+1];

        if (_ptszName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            _tcscpy(_ptszName, ptcsNewName);
        }
    }

    // Clean up

    if(NULL != pOleStrOld)
    {
        delete pOleStrOld;
        pOleStrOld = NULL;
    }

    if(NULL != pOleStrNew)
    {
        delete pOleStrNew;
        pOleStrNew = NULL;
    }

    // BUGBUG: to do valid parameter checking, may need to change prototype
    // of function to take old name too.  Also remove DH_ validation checking

    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::Destroy, public
//
//  Synopsis:   Wrapper for IStorage::DestroyElement that removes a stream
//              from this storage, subject to transaction mode in which it
//              was opened.  The wrapper for IStorage::DestoryElement that
//              destroys a storage from this storage is in VirtualCtrNode::
//              Destroy.
//
//  Arguments:  None 
//
//  Returns:    S_OK                Object was successfully renamed. 
//              STG_E_ACCESSDENIED  insufficient permissions. 
//              STG_E_FILENOTFOUND  Element couldn't be found.
//              STG_E_REVERTED      Object invalidated by a revert operation 
//                                  above it in transaction tree.
//              STG_E_INSUFFICIENTMEMORY Not enough memory to rename element.
//              STG_E_INVALIDPOINTER     Invalid pointer.  
//              STG_E_INVALIDNAME        Invalid name.  
//              STG_E_INVALIDPARAMETER   Invalid parameter  
//              STG_E_TOOMANYOPENFILES   too many open files.
//
//  History:    8-July-96   NarindK     Created
//
//  Notes:      The existing open instance of this element from this parent
//              instance becomes invalid after this function is called.
//
//              Use utility function DestroyStream from util.cxx that is a
//              wrapper for this function and also readjusts the VirtualDF
//              tree.
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::Destroy()
{
    HRESULT         hr              =   S_OK;
    LPOLESTR        pOleStrTemp     =   NULL;
    VirtualStmNode  *pvsnTemp       =   NULL;
    VirtualStmNode  *pvsnOldSister  =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("VirtualStmNode::Destroy"));

    DH_ASSERT(NULL != _pvcnParent);
    
    DH_ASSERT(NULL != _pvcnParent->_pstg);
    
    if(S_OK == hr)
    {
        // Convert _ptszName to OLECHAR

        hr = TStringToOleString(_ptszName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if(S_OK == hr)
    {
        hr = _pvcnParent->_pstg->DestroyElement(pOleStrTemp);

        DH_HRCHECK(hr, TEXT("IStorage::DestroyElement")) ;
    }

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    return  hr;
}

//+--------------------------------------------------------------------------
//  Member:     VirtualStmNode::CalculateCRCs
//
//  Synopsis:   Updates the name and data crc
//
//  Arguments:  None.
//
//  Returns:    HRESULT
//
//  History:    02-Apr-98 georgis   Created
//---------------------------------------------------------------------------

HRESULT VirtualStmNode::UpdateCRC(DWORD dwChunkSize)
{
    HRESULT hr=S_OK;
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::UpdateCRC"));

    // Calculate the CRC for the stream data
    hr=CalculateStreamDataCRC(_pstm,0,&_dwCRC.dwCRCData,dwChunkSize);
    DH_HRCHECK(hr, TEXT("CalculateStreamDataCRC"));

    // Calculate the CRC for the stream name
    if ( S_OK == hr )
    {
        hr = CalculateCRCForName(_ptszName, &_dwCRC.dwCRCName);
        DH_HRCHECK(hr, TEXT("CalculateCRCForName")) ;
    }

    // Munge in dwCRCSum
    _dwCRC.dwCRCSum=CRC_PRECONDITION;
    MUNGECRC(_dwCRC.dwCRCSum,_dwCRC.dwCRCData);
    MUNGECRC(_dwCRC.dwCRCSum,_dwCRC.dwCRCName);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\util.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       util.cxx
//
//  Contents:   Implementation of utilities for common class library and for
//              tests.
//
// Functions:   - GenerateRandomName
//              - GetVirtualCtrNodeForTest
//              - GetVirtualStmNodeForTest
//              - DestroyStorage
//              - DestroyStream
//              - AddStorage
//              - AddStream
//              - CalculateCRCForName
//              - CalculateCRCForDataBuffer
//              - CalculateInMemoryCRCForStg
//              - CalculateInMemoryCRCForStm
//              - ReadAndCalculateDiskCRCForStm
//              - CalculateDiskCRCForStg
//              - EnumerateInMemoryDocFile
//              - OpenRandomVirtualCtrNodeStg
//              - CloseRandomVirtualCtrNodeStg
//              - ParseVirtualDFAndCloseOpenStgsStms
//              - ParseVirtualDFAndCommitAllOpenStgs
//              - CalculateCRCForDocFile
//              - CalculateCRCForDocFileStmData
//              - TStringToOleString
//              - EnumerateDiskDocFile
//              - GenerateVirtualDFFromDiskDF
//              - GenerateRemVirtualDFTree  [local to this file]
//              - GenVirtualCtrNode [local to this file]
//              - GenVirtualStmNode [local to this file]
//              - PrivAtol
//              - GenerateRandomString
//              - GenerateRandomStreamData
//              - ParseVirtualDFAndOpenAllSubStgsStms 
//              - CommitRandomVirtualCtrNodeStg
//
//  History:    17-Apr-96   Narindk  Created.
//               2-Feb-97   SCousens Added for Cnvrs/NSS 
//              31-Mar-98   SCousens Added GenerateRandomStreamData
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug  Object declaration

DH_DECLARE;


// CRC 32 Bitwise lookup table, logic taken from CRC-32 description in
// 'C Programmer's Guide to Netbios' book.

ULONG aulCrc[256] =
{
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

// Functions local to this file

HRESULT GenerateRemVirtualDFTree(
    VirtualCtrNode  *pvcnParent,
    LPSTORAGE       pIStgParent);

HRESULT GenVirtualCtrNode(
    LPTSTR          ptcsName,
    VirtualCtrNode  **ppvcnNew);

HRESULT GenVirtualStmNode(
    LPTSTR          ptcsName,
    DWORD           cbSize,
    VirtualStmNode  **ppvsnNew);

//+-------------------------------------------------------------------------
//  Function:   GenerateRandomName
//
//  Synopsis:   Generates a random name using datagen object.
//
//  Arguments:  [pgds] - Pointer to DG_STRING object.
//              [pptszName] - Pointer to pointer to returned string.
//              [ulMinLen] - Minimum length of string
//              [ulMaxLen] - Maximum length of string
//
//  Returns:    HRESULT.  S_OK if everything goes ok, error code otherwise.
//
//  History:    11-Nov-96  BogdanT    Changed the DG_UNICODE ptr. to DG_STRING
//              17-Apr-96  NarindK    Created.
//
//  Notes:      BUGBUG: This function need to be enhance to handle different
//              character sets.
//              Please note that the name generated may have an extension b/w
//              0 and FILEEXT_MAXLEN besides the length of name b/w ulMinLen and
//              ulMax Len.
//--------------------------------------------------------------------------

HRESULT GenerateRandomName(
    DG_STRING   *pgds,
    ULONG       ulMinLen,
    ULONG       ulMaxLen,
    LPTSTR      *pptszName)
{
    HRESULT     hr          =   S_OK;
    ULONG       cTemp       =   0;
    USHORT      usErr       =   0;
    ULONG       ulActMaxLen =   0;
    ULONG       ulActMinLen =   0;
    ULONG       ulNameLen   =   0;
    ULONG       ulExtLen    =   0;
    LPTSTR      ptszName    =   NULL;
    LPTSTR      ptszExt     =   NULL;
    LPWSTR      pwszName    =   NULL;
    LPWSTR      pwszExt     =   NULL;

    TCHAR       ptszFATCharSet[FAT_CHARSET_SIZE];
    // TCHAR       ptszOFSCharSet[OFS_CHARSET_SIZE];
    LPWSTR      pwszFATCharSet = NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("GenerateRandomName"));

    DH_VDATEPTRIN(pgds, DG_STRING) ;
    DH_VDATEPTROUT(pptszName, LPTSTR) ;

    DH_ASSERT(NULL != pgds);
    DH_ASSERT(NULL != pptszName);

    if (S_OK == hr)
    {
        // Initialize out parameter.

        *pptszName = NULL;

        // Sanity check.  Min length for name must be <= maximum length, if it
        // isn't then make maximum length equal to minimum length.

        if (ulMaxLen < ulMinLen)
        {
            ulMaxLen =  ulMinLen;
        }

        // If Maximum length provided is 0, then default maximum length would
        // be used.  If Minimum length provided is zero, then 1 would be used
        // for it.

        // BUGBUG:  We are using default maximum length for FAT system.

        ulActMaxLen = (ulMaxLen == 0 ? DEF_FATNAME_MAXLEN : ulMaxLen);
        ulActMinLen = (ulMinLen == 0 ? 1 : ulMinLen);

        // '\0', '\', '/', and ':' are invalid for IStorage/IStream names
        //                         (For doc file)
        // '*', '"' '<' '>' '?' are invalid for IStorage/IStream names on OFS

        // Initialize valid character set for FAT file names

        _tcscpy(ptszFATCharSet, _TEXT("abcdefghijklmnopqrstuvwxyz"));
        _tcscat(ptszFATCharSet, _TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZ"));
        _tcscat(ptszFATCharSet, _TEXT("0123456789"));

        //BUGBUG:  Check if these characters are not valid for IStorage/IStream
        //         names.

        // _tcscat(ptszFATCharSet, L"_^$~!#%&-{}()@'`");

        // Initialize valid character set for other file names.  BUGBUG: Not
        // using OFS character set at present.

        // for (TCHAR wch = 0x01; wch <= 0x7f; wch++)
        // {
        //    if (wch != L'\\' && wch != L'/' && wch != L'*' && wch != L'?')
        //    {
        //        ptszOFSCharSet[cTemp++] = wch;
        //    }
        // }
        // ptszOFSCharSet[cTemp] = NULL;

        // Call DataGen to generate a random file name
        // BUGBUG:  We are using FAT character set to generate random names.

#ifdef _MAC

	usErr = pgds->Generate(
		    (UCHAR **)&ptszName,     // force compiler to chose the right
		    (UCHAR *)ptszFATCharSet, // version of Generate
		    ulActMinLen,
		    ulActMaxLen);

#else

        if(S_OK == hr)
        {
            // Convert TCHAR to WCHAR

            hr = TStrToWStr(ptszFATCharSet, &pwszFATCharSet);
            DH_HRCHECK(hr, TEXT("TStrToWStr")) ;
        }

        usErr = pgds->Generate(
                    &pwszName,
                    pwszFATCharSet,
                    ulActMinLen,
                    ulActMaxLen);

#endif //_MAC

        if (usErr != DG_RC_SUCCESS)    // DataGen error
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        // Generate a random extension

#ifdef _MAC

	usErr = pgds->Generate(
		    (UCHAR **)&ptszExt,     // force compiler to chose the right
		    (UCHAR *)ptszFATCharSet, // version of Generate
		    0,
		    FILEEXT_MAXLEN);

#else

        usErr = pgds->Generate(
                  &pwszExt,
                  pwszFATCharSet,
                  0,
                  FILEEXT_MAXLEN);

#endif //_MAC

        if (usErr != DG_RC_SUCCESS)    // Failed to generate extension
        {
            hr = E_FAIL;

            delete pwszName;
            pwszName = NULL;
        }
    }

#ifndef _MAC 
	
    // In MAC version we don't use the WSZs so skip the conversions

    if(S_OK == hr)
    {
       //Convert WCHAR to TCHAR

       hr = WStrToTStr(pwszName, &ptszName);

       DH_HRCHECK(hr, TEXT("WStrToTStr")) ;
    }

    if((S_OK == hr) && (NULL != *pwszExt))
    {
       //Convert WCHAR to TCHAR

       hr = WStrToTStr(pwszExt, &ptszExt);

       DH_HRCHECK(hr, TEXT("WStrToTStr")) ;
    }

#endif //_MAC

    if (S_OK == hr)
    {
        ulNameLen = _tcslen(ptszName);

        if(NULL != ptszExt) 
        {
            ulExtLen = _tcslen(ptszExt);

            // If the length of the extension > 0, a '.' will be added.

            if (ulExtLen > 0)
            {
                ulNameLen += ulExtLen + 1;
            }
        }

        // Construct the full name

        *pptszName = new TCHAR[ulNameLen + 1];

        if(NULL == *pptszName)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        _tcscpy(*pptszName, ptszName);

        if (ulExtLen > 0)
        {
            _tcscat(*pptszName, _TEXT("."));
            _tcscat(*pptszName, ptszExt);
        }
    }

    // Clean up

    if (NULL != ptszExt)
    {
        delete ptszExt;
        ptszExt = NULL;
    }

    if (NULL != ptszName)
    {
        delete ptszName;
        ptszName = NULL;
    }

    if (NULL != pwszExt)
    {
        delete pwszExt;
        pwszExt = NULL;
    }

    if (NULL != pwszName)
    {
        delete pwszName;
        pwszName = NULL;
    }

    if (NULL != pwszFATCharSet)
    {
        delete pwszFATCharSet;
        pwszFATCharSet = NULL;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//  Function:   GetVirtualCtrNodeForTest
//
//  Synopsis:   Gets a random VirtualCtrNode for doing tests on it.
//
//  Arguments:  [pVirtualCtrNode] - Pointer to root node of subtree.
//              [pgdi]  - pointer to data generator object
//              [cMin]  - Minimum no of VirtualCtrNodes in subtree.
//                        Should be greater than zero and less than cMax.
//              [cMax]  - Maximum number of VirtualCtrNodes in subtree.
//                        Should be greater or equal to cMin
//              [ppVirtualCtrNodeForTest] - Returned VirtualCtrNode
//
//  Returns:    HRESULT
//
//  History:    27-Apr-96  NarindK    Created.
//              12-Mar-97  MikeW      Converted to use CtrNodes not VirtDF's
//
//  Notes:      If the number of actual maximum number of storages is known,
//              provide that to cMax parameter or else pass 0 to have
//              EnumerateInMemoryDocfile called for you to know actual number 
//              of storages (thereby VirtualCtrNodes) in the tree in test.  Pl.
//              note that if a test provides improper values for cMin/cMax, 
//              asserts would be thrown by the function.  However it is okay to
//              provide valid cMin and cMax values which are lesser than actual
//              number of VirtualCtrNodes in the tree.
//
//              Call OpenRandomVirtualCtrNodeStg after calling this function to
//              open up the storage of this random VirtualCtrNode.  This might 
//              not be required if the original VirtualDF tree is being used,
//              since during first creation of VirtualDF tree, when all stgs/
//              stms are created, they are open.  However if a InMemory Docfile 
//              is generated from Disk DocFile, then only the root storage is
//              open, all other storages/streams are closed.
//
//              -Pick up a random number cRandom between cMin and cmax by
//               DataGen obj pgdi.
//              -Assign root VirtualCtrNode of tree to pvcnTrav and increment
//               temp variable counter.
//              -if counter is equal to cRandom i.e. 1, then return root Virtual
//               CtrNode for test.
//              -Else start a forever loop till node is found
//                 -While pvcnTrav's _pvcnChild is not NULL and counter is less
//                  than cRandom, loop.
//                 -if counter equals cRandom, then node found, break out of
//                  forever loop.
//                 -Else while pvcnTrav's _pvcnSister is eual to NULL, loop
//                  assinging _pvcnParent to pvcnTrav
//                 -Assign pvcnTrav's _pvcnSister to pvcnTrav and increment
//                  counter and go back to start of forever loop
//              -With node found, return that to calling function.
//--------------------------------------------------------------------------

HRESULT GetVirtualCtrNodeForTest(
    VirtualCtrNode  *pVirtualCtrNode,
    DG_INTEGER      *pdgi,
    ULONG           cMin,
    ULONG           cMax,
    VirtualCtrNode  **ppVirtualCtrNodeForTest)
{
    HRESULT         hr          =   S_OK;
    VirtualCtrNode  *pvcnTrav   =   NULL;
    USHORT          usErr       =   0;
    ULONG           counter     =   0;
    ULONG           cRandom     =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GetVirtualCtrNodeForTest"));

    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTRIN(pVirtualCtrNode, VirtualCtrNode ) ;
    DH_VDATEPTROUT(ppVirtualCtrNodeForTest, PVCTRNODE) ;

    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pVirtualCtrNode);
    DH_ASSERT(NULL != ppVirtualCtrNodeForTest);

    // Sanity check: The tree must have atleast one virtualCtrNode in it,
    // and cMin must be <= cMax
    DH_ASSERT(cMin > 0);
    DH_ASSERT(cMin <= cMax || 0 == cMax);

    // Initialize out parameter
    *ppVirtualCtrNodeForTest = NULL;

    // If cMax is 0, find the number of CtrNodes under the given root.

    if (S_OK == hr && 0 == cMax)
    {
        hr = EnumerateInMemoryDocFile(pVirtualCtrNode, &cMax, NULL);

        if (S_OK == hr && cMax < cMin)
        {
            hr = E_UNEXPECTED;
        }
    }

    // Pick up a random number

    if(S_OK == hr)
    {
        usErr = pdgi->Generate(&cRandom, cMin, cMax);
        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        pvcnTrav = pVirtualCtrNode;
//        pvcnTrav = pVirtualDF->GetVirtualDFRoot();
//        DH_ASSERT(NULL != pvcnTrav);
        counter++;

        if(counter != cRandom)
        {
            for(;;)
            {
                DH_ASSERT((NULL != pvcnTrav) && (cRandom >= counter));
                while((pvcnTrav->GetFirstChildVirtualCtrNode() != NULL) &&
                      (counter < cRandom))
                {
                    pvcnTrav = pvcnTrav->GetFirstChildVirtualCtrNode();
                    counter++;
                }

                if(cRandom == counter)
                {
                    break;
                }

                while(NULL == pvcnTrav->GetFirstSisterVirtualCtrNode())
                {
                    pvcnTrav = pvcnTrav->GetParentVirtualCtrNode();
                    DH_ASSERT(NULL != pvcnTrav);
                }

                DH_ASSERT(NULL != pvcnTrav->GetFirstSisterVirtualCtrNode());
                pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
                counter++;
            }
        }
    }

    if(S_OK == hr)
    {
        // Return the out parameter

        *ppVirtualCtrNodeForTest = pvcnTrav;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   GetVirtualCtrNodeForTest
//
//  Synopsis:   Gets a random VirtualCtrNode for doing tests on it.
//
//  Arguments:  [pVirtualDF] - Pointer to VirtualDF tree.
//              [pgdi]  - pointer to data generator object
//              [cMin]  - Minimum no of VirtualCtrNodes in subtree.
//                        Should be greater than zero and less than cMax.
//              [cMax]  - Maximum number of VirtualCtrNodes in subtree.
//                        Should be greater or equal to cMin
//              [ppVirtualCtrNodeForTest] - Returned VirtualCtrNode
//
//  Returns:    HRESULT
//
//  History:    12-Mar-97  MikeW      Created
//
//  Notes:      Just thunk to the version of the routine that takes a
//              VirtualCtrNode instead of a VirtualDF.
//--------------------------------------------------------------------------

HRESULT GetVirtualCtrNodeForTest(
    VirtualDF       *pVirtualDF,
    DG_INTEGER      *pdgi,
    ULONG           cMin,
    ULONG           cMax,
    VirtualCtrNode  **ppVirtualCtrNodeForTest)
{
    DH_VDATEPTRIN(pVirtualDF, *pVirtualDF);

    //
    // Most of the parameter checking is left to the main version of this 
    // routine
    //

    return GetVirtualCtrNodeForTest(
                    pVirtualDF->GetVirtualDFRoot(),
                    pdgi,
                    cMin,
                    cMax,
                    ppVirtualCtrNodeForTest);
}

//+-------------------------------------------------------------------------
//  Function:   GetVirtualStmNodeForTest
//
//  Synopsis:   Gets a VirtualStmNode for doing tests on it.
//
//  Arguments:  [pVirtualCtrNode] - Pointer to root node of subtree.
//              [pgdi]  - pointer to data generator object
//              [cMin]  - Minimum no of VirtualStmNodes in VirtualDF tree.
//                        Should be greater than zero and less than cMax.
//              [cMax]  - Maximum number of VirtualStmNodes in VirtualDF tree.
//                        Should be greater or equal to cMin
//              [ppVirtualCtrNodeParent] - returned parent VirtualCtrNode
//              [ppVirtualStmNodeForTest] - returned VirtualStmNode
//
//  Returns:    HRESULT
//
//  History:    27-Apr-96  NarindK    Created.
//              12-Mar-97  MikeW      Converted to use CtrNodes not VirtDF's
//
//  Notes:      If the number of actual maximum number of storages is known,
//              provide that to cMax parameter or else pass 0 to have
//              EnumerateInMemoryDocfile called for you to know actual number
//              of storages (thereby VirtualCtrNodes) in the tree in test.  Pl.
//              note that if a test provides improper values for cMin/cMax,
//              asserts would be thrown by the function.  However it is okay to
//              provide valid cMin and cMax values which are lesser than actual
//              number of VirtualStmNodes in the tree.
//
//              Also note that this function returns a randomly picked Virtual
//              StmNode and its parent VirtualCtrNode (which is also randomly
//              picked based on VirtualStmNode).  The difference of this func
//              from GetVirtualCtrNode is that the random VirtualCtrNode picked
//              up is one having streams in it.  If none of VirtualCtrNodes
//              traversed have any streams in it, this returns an error.
//
//              -Pick up a random number cRandomStm between cMin and cMax by
//               DataGen obj pgdi.
//              -Assign root VirtualCtrNode of tree to pvcnTrav and increment
//               temp variable counter.
//              -Check in pvcnTrav's _cStreams > 0, if yes, then increment the
//               counter by that number.
//              -if counter is greater or equal cRandom , check return tha
//               desired VirtualStmNode of the root.
//              -Else start a forever loop till a valid node is found
//                 -While pvcnTrav's _pvcnChild is not NULL and counter is less
//                  than cRandomStg, loop.  In the loop, check if pvcnTrav's
//                  > 0, if yes, update the counter.
//                 -if counter is greater or equal to cRandomStg, then break
//                  out of the forever loop
//                 -Else while pvcnTrav's _pvcnSister is eual to NULL, loop
//                  assinging _pvcnParent to pvcnTrav
//                 -Assign pvcnTrav's _pvcnSister to pvcnTrav .  If pvcnTrav's
//                  _cStreams is > 0, then update the counter and go back to
//                  start of forever loop
//              -With parent VirtualCtrNode found, find the number of which
//               child VirtualStmNode of it to return by doing cRandomStm
//               minus (counter minus pvcnTrav's _cStreams count).  Assign this
//               calculated value to cChildStm.
//              -Assign pvsnTrav the value of pvcnTrav's _pvsnStream and decre
//               ment the cChildStm variable.
//              -While cChildStm != zer0 and NULL is not equal to pvsnTrav,loop
//                  -Assign pvsnTrav's _pvsnSister to pvsnTrav.
//                  -Decrement cChildStm and go back to top of loop.
//               -Return the parent VirtualCtrNode and random VirtualStmNode
//                to the caller.
//--------------------------------------------------------------------------

HRESULT GetVirtualStmNodeForTest(
    VirtualCtrNode  *pVirtualCtrNode,
    DG_INTEGER      *pdgi,
    ULONG           cMin,
    ULONG           cMax,
    VirtualCtrNode  **ppVirtualCtrNodeParent,
    VirtualStmNode  **ppVirtualStmNodeForTest)
{
    HRESULT         hr          =   S_OK;
    VirtualCtrNode  *pvcnTrav   =   NULL;
    VirtualStmNode  *pvsnTrav   =   NULL;
    USHORT          usErr       =   0;
    ULONG           counter     =   0;
    ULONG           cRandomStm  =   0;
    ULONG           cChildStm   =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GetVirtualStmNodeForTest"));

    DH_VDATEPTRIN(pVirtualCtrNode, VirtualCtrNode ) ;
    DH_VDATEPTRIN(pdgi, DG_INTEGER) ;
    DH_VDATEPTROUT(ppVirtualStmNodeForTest, PVSTMNODE) ;
    DH_VDATEPTROUT(ppVirtualCtrNodeParent, PVCTRNODE) ;

    // The pointer to parent pVirtualCtrNodeParent shouldn't be NULL.
    // cChildStmToFetch can be zero, in which case first stream is
    // is returned.

    DH_ASSERT(NULL != pdgi);
    DH_ASSERT(NULL != pVirtualCtrNode);
    DH_ASSERT(NULL != ppVirtualStmNodeForTest);
    DH_ASSERT(NULL != ppVirtualCtrNodeParent);

    // Sanity check: cMin must be <= cMax or cMax must be 0

    DH_ASSERT(cMin <= cMax || 0 == cMax);

    // if cMax is 0, find the number of stm nodes under the root

    if(S_OK == hr && cMax == 0)
    {
        hr = EnumerateInMemoryDocFile(pVirtualCtrNode, NULL, &cMax);

        if (S_OK == hr && cMax < cMin)
        {
            hr = E_UNEXPECTED;
        }
    }

    // Pick up a random number

    if(S_OK == hr)
    {
        // Initialize out parameter
        *ppVirtualCtrNodeParent = NULL;
        *ppVirtualStmNodeForTest = NULL;

        usErr = pdgi->Generate(&cRandomStm, cMin, cMax);
        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        pvcnTrav = pVirtualCtrNode;
//        pvcnTrav = pVirtualDF->GetVirtualDFRoot();
//        DH_ASSERT(NULL != pvcnTrav);

        if(0 != pvcnTrav->GetVirtualCtrNodeStreamCount())
        {
            counter = counter + pvcnTrav->GetVirtualCtrNodeStreamCount();
        }
    }

    if(counter < cRandomStm)
    {
        for(;;)
        {
            DH_ASSERT(NULL != pvcnTrav);
            while((pvcnTrav->GetFirstChildVirtualCtrNode() != NULL) &&
                  (counter < cRandomStm))
            {
                pvcnTrav = pvcnTrav->GetFirstChildVirtualCtrNode();

                if(0 != pvcnTrav->GetVirtualCtrNodeStreamCount())
                {
                   counter = counter + pvcnTrav->GetVirtualCtrNodeStreamCount();
                }
            }

            if(counter >= cRandomStm)
            {
                break;
            }

            while(NULL == pvcnTrav->GetFirstSisterVirtualCtrNode())
            {
                pvcnTrav = pvcnTrav->GetParentVirtualCtrNode();
                DH_ASSERT(NULL != pvcnTrav);
            }

            DH_ASSERT(NULL != pvcnTrav->GetFirstSisterVirtualCtrNode());
            pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();

            if(0 != pvcnTrav->GetVirtualCtrNodeStreamCount())
            {
                counter = counter + pvcnTrav->GetVirtualCtrNodeStreamCount();
            }
        }
    }

    if(S_OK == hr)
    {
        // Calculate which child stream needs to be picked up
        cChildStm = cRandomStm -
                    (counter - pvcnTrav->GetVirtualCtrNodeStreamCount());

        pvsnTrav = pvcnTrav->GetFirstChildVirtualStmNode();
        cChildStm--;

        DH_ASSERT(NULL != pvsnTrav);

        while((0 != cChildStm) && (NULL != pvsnTrav))
        {
           pvsnTrav = pvsnTrav->GetFirstSisterVirtualStmNode();
           cChildStm--;
        }

        // Return the out parameter

        *ppVirtualCtrNodeParent = pvcnTrav;
        *ppVirtualStmNodeForTest = pvsnTrav;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   GetVirtualStmNodeForTest
//
//  Synopsis:   Gets a VirtualStmNode for doing tests on it.
//
//  Arguments:  [pVirtualDF] - Pointer to VirtualDF tree.
//              [pgdi]  - pointer to data generator object
//              [cMin]  - Minimum no of VirtualStmNodes in VirtualDF tree.
//                        Should be greater than zero and less than cMax.
//              [cMax]  - Maximum number of VirtualStmNodes in VirtualDF tree.
//                        Should be greater or equal to cMin
//              [ppVirtualCtrNodeParent] - returned parent VirtualCtrNode
//              [ppVirtualStmNodeForTest] - returned VirtualStmNode
//
//  Returns:    HRESULT
//
//  History:    12-Mar-97  MikeW      Created
//
//  Notes:      Just thunk to the version of the routine that takes a
//              VirtualCtrNode instead of a VirtualDF.
//--------------------------------------------------------------------------

HRESULT GetVirtualStmNodeForTest(
    VirtualDF       *pVirtualDF,
    DG_INTEGER      *pdgi,
    ULONG           cMin,
    ULONG           cMax,
    VirtualCtrNode  **ppVirtualCtrNodeParent,
    VirtualStmNode  **ppVirtualStmNodeForTest)
{
    DH_VDATEPTRIN(pVirtualDF, *pVirtualDF);

    //
    // Most of the parameter checking is left to the main version of this
    // routine
    //

    return GetVirtualStmNodeForTest(
                    pVirtualDF->GetVirtualDFRoot(),
                    pdgi,
                    cMin,
                    cMax,
                    ppVirtualCtrNodeParent,
                    ppVirtualStmNodeForTest);
}

//+-------------------------------------------------------------------------
//  Function:   DestroyStorage
//
//  Synopsis:   Destorys a VirtualCtrNode and associated IStorage.
//
//  Arguments:  [pVirtualDF] - pointer to VirtualDocFile tree.
//              [pVirtualCtrNode] - Pointer to VirtualCtrNode
//
//  Returns:    HRESULT
//
//  History:    29-Apr-96  NarindK    Created.
//
//  Notes:      Call VirtualCtrNode::Destroy to destroy the node.
//              Call VirtualDF::DeleteVirtualDocFileTree to delete the corres-
//              ponding VirtualCtrNode from the VirtualDF tree.
//--------------------------------------------------------------------------

HRESULT DestroyStorage(
    VirtualDF       *pVirtualDF,
    VirtualCtrNode  *pVirtualCtrNode)
{
    HRESULT     hr  =   S_OK;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DestroyStorage"));

    DH_VDATEPTRIN(pVirtualDF, VirtualDF) ;
    DH_VDATEPTRIN(pVirtualCtrNode, VirtualCtrNode) ;

    DH_ASSERT(NULL != pVirtualCtrNode);
    DH_ASSERT(NULL != pVirtualDF);

    if(S_OK == hr)
    {
        hr = pVirtualCtrNode->Destroy();

        DH_HRCHECK(hr, TEXT("pVirtualCtrNode->Destroy()")) ;
    }

    if(S_OK == hr)
    {
        // Now adjust the VirtualDocFile tree.  This will decrease the
        // _cChildren variable value of the parent VrtualCtrNode too.

        hr = pVirtualDF->DeleteVirtualDocFileTree(pVirtualCtrNode);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//  Function:   DestroyStream
//
//  Synopsis:   Destorys a VirtualStmNode and associated IStream.
//
//  Arguments:  [pVirtualDF] - pointer to VirtualDF tree
//              [pVirtualStmNode] - Pointer to VirtualStmNode to be destoryed
//
//  Returns:    HRESULT
//
//  History:    9-July-96  NarindK    Created.
//
//  Notes:      Call VirtualStmNode::Destroy to destroy the IStream.
//              Call VirtualDF::DeleteVirtualCtrNodeStreamNode to delete corres-
//              ponding VirtualCtrNode from the VirtualDF tree.
//--------------------------------------------------------------------------

HRESULT DestroyStream(
    VirtualDF       *pVirtualDF,
    VirtualStmNode  *pVirtualStmNode)
{
    HRESULT         hr              =   S_OK;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DestroyStream"));

    DH_VDATEPTRIN(pVirtualStmNode, VirtualStmNode) ;
    DH_VDATEPTRIN(pVirtualDF, VirtualDF) ;

    DH_ASSERT(NULL != pVirtualDF);
    DH_ASSERT(NULL != pVirtualStmNode);

    if(S_OK == hr)
    {
        hr = pVirtualStmNode->Destroy();

        DH_HRCHECK(hr, TEXT("pVirtualStmNode->Destroy()")) ;
    }

    if(S_OK == hr)
    {
        // Now adjust the VirtualDocFile tree.  This will decrease the
        // _cStreams variable value of the parent VirtualCtrNode too.

        hr = pVirtualDF->DeleteVirtualCtrNodeStreamNode(pVirtualStmNode);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->DeleteVirtualCtrNodeStreamNode")) ;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//  Function:   AddStorage
//
//  Synopsis:   Adds a VirtualCtrNode and associated IStorage.
//
//  Arguments:  [pVirtualCtrNode] - Pointer to existing VirtualCtrNode
//              [ppNewVirtualCtrNode] _ Returned new VirtualCtrNode
//              [pName] - Name of new storage
//              [grfMode] - Mode in which new storage is to be opened
//
//  Returns:    HRESULT
//
//  History:    29-Apr-96  NarindK    Created.
//
//  Notes:      - Creates a simple new VirtualCtrNode and initializes it with
//                name passed in.  Its _cChildren and _cStreams are initialized
//                to zero.
//              - Append the newly created node pvcnNew to its parent node
//                pVirtualCtrNode.  This would be appended as _pvcnChild or
//                as _pvcnSister of existing old sister as the case might be.
//              - Increase the parent's pVirtualCtrNode's _cChildren variable
//                indicating the new VirtualCtrNode added.
//              - Create a disk IStorage corresponding to this VirtualCtrNode
//                based on passed in grfmode.
//              - If CreateStorage call returns STG_S_CONVERTED, it indicates
//                that an existing stream with specified name was replaced witho
//                a new storage object containing a single stream called 
//                CONTENTS.  If so, adjust the VirtualDF tree.
//              - If successful, copy pvcnNew into out parameter *ppNewVirtual
//                CtrNode, else delete the VirtualCtrNode allocated earlier.
//              Note: Please note that the CRC for node(s) created is not set.
//--------------------------------------------------------------------------

HRESULT AddStorage(
    VirtualDF       *pVirtualDF,
    VirtualCtrNode  *pVirtualCtrNode,
    LPTSTR          pName,
    DWORD           grfMode,
    VirtualCtrNode  **ppNewVirtualCtrNode)
{
    HRESULT         hr          = S_OK;
    HRESULT         hrTemp      = S_OK;
    VirtualCtrNode  *pvcnNew    = NULL;
    VirtualStmNode  *pvsnOld    = NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::AddStorage"));

    DH_VDATEPTRIN(pVirtualDF, VirtualDF) ;
    DH_VDATEPTRIN(pVirtualCtrNode, VirtualCtrNode) ;
    DH_VDATEPTROUT(ppNewVirtualCtrNode, PVCTRNODE) ;
    DH_VDATESTRINGPTR(pName);

    DH_ASSERT(NULL != pVirtualDF);
    DH_ASSERT(NULL != pVirtualCtrNode);
    DH_ASSERT(NULL != ppNewVirtualCtrNode);

    if(S_OK == hr)
    {
        // Initialize out parameter

        *ppNewVirtualCtrNode = NULL;

        // Allocate and Initialize new VirtualCtrNode

        hr = GenVirtualCtrNode(pName, &pvcnNew);

        DH_HRCHECK(hr, TEXT("GenVirtualCtrNode")) ;
    }

    // Append new VirtualCtr Node

    if(S_OK == hr)
    {
        if(0 == pVirtualCtrNode->GetVirtualCtrNodeChildrenCount())
        {
            hr = pVirtualCtrNode->AppendChildCtr(pvcnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendChildCtr")) ;
        }
        else
        {
            hr=pVirtualCtrNode->GetFirstChildVirtualCtrNode()->AppendSisterCtr(
                    pvcnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendSisterCtr")) ;
        }
    }

    if(S_OK == hr)
    {
        // Increment the _cChildren variable of parent VirtualCtrNode

        pVirtualCtrNode->IncreaseChildrenStgCount();

    }

    // Call VirtualCtrNode::Create to create a corresponding Storage on disk.

    if(S_OK == hr)
    {
        hr = pvcnNew->Create(
                grfMode,
                0,
                0);

         DH_HRCHECK(hr, TEXT("VirtualCtrNode::Create")) ;
    }

    // Fill in the output parameter

    if((S_OK == hr) || (STG_S_CONVERTED == hr))
    {
        if(STG_S_CONVERTED == hr)
        {
            VirtualStmNode  *pvsnNew    =   NULL;
            ULONG           cb          =   0;

            // Remember hr

            hrTemp = hr;

            // Delete the VirtualStmNode with stream that is converted to this
            // storage.  First find the corresponding VirtualStmNode with same
            // name.
            
            pvsnOld = 
              pvcnNew->GetParentVirtualCtrNode()->GetFirstChildVirtualStmNode();
            
            DH_ASSERT(NULL != pvsnOld);

            while((NULL != pvsnOld) &&
                  (0 != _tcscmp(pName, pvsnOld->GetVirtualStmNodeName())))
            {
                pvsnOld = pvsnOld->GetFirstSisterVirtualStmNode();
            }

            // Delete the old VirtualStmNode

            if((NULL != pvsnOld) &&
               (0 == _tcscmp(pName, pvsnOld->GetVirtualStmNodeName())))
            {
                // Remember size of VirtualStmNode
                cb = pvsnOld->GetVirtualStmNodeSize();

                hr = pVirtualDF->DeleteVirtualCtrNodeStreamNode(pvsnOld);
            }
            else
            {
                hr = E_FAIL;
            }

            // Generate a new VirtualStmNode for CONTENTS stream generated

            if(S_OK == hr)
            {
                hr = GenVirtualStmNode(TEXT("CONTENTS"), cb, &pvsnNew); 

                if(S_OK == hr)
                {
                    hr = pvcnNew->AppendFirstChildStm(pvsnNew);
                } 

                if(S_OK == hr)
                {
                    pvcnNew->IncreaseChildrenStmCount();
                }
            }
        }

        if(S_OK == hr)
        {
            *ppNewVirtualCtrNode = pvcnNew;

            if(STG_S_CONVERTED == hrTemp)
            {
                hr = hrTemp;
            }
        }
    }
    else
    {
        // Storage wasn't created successfully, delete the VirtualCtrNode   
        // being created. Adjust the VirtualDocFile tree.  This will decrease 
        // _cChildren variable value of the parent VirtualCtrNode too.

        hrTemp = pVirtualDF->DeleteVirtualDocFileTree(pvcnNew);

        DH_HRCHECK(hrTemp, TEXT("pVirtualDF->DeleteVirtualFileDocTree")) ;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//  Function:   AddStream
//
//  Synopsis:   Adds a VirtualStmNode & associated IStream to a VirtualCtrNode.
//              Set the size of stream if cbSize is nonzero, but doesn't write 
//              into it.
//
//  Arguments:  [pVirtualCtrNode] - Pointer to existing VirtualCtrNode
//              [ppNewVirtualStmNode] - Returned new VirtualStmNode
//              [pName] - Name of new stream
//              [grfMode] - Mode of new stream
//              [cbSize] - Size of new stream
//
//  Returns:    HRESULT
//
//  History:    29-Apr-96  NarindK    Created.
//
//  Notes:      - Creates a simple new VirtualStmNode and initializes it with
//                name & cbSize passed in.
//              - Append the newly created node pvsnNew to its parent node
//                pVirtualCtrNode.  This would be appended as _pvsnStream or
//                as _pvsnSister of existing old sister as the case might be.
//              - Increase the parent's pVirtualCtrNode's _cStreams variable
//                indicating the new VirtualStmNode added.
//              - Create a disk IStream corresponding to this VirtualStmNode.
//                based on passed in grfmode.
//              - If cbSize is non zero, do SetSize on stream.
//              - If successful, copy pvsnNew into out parameter *ppNewVirtual
//                StmNode, else delete the VirtualStmNode allocated earlier.
//              Note: Please note that the CRC for node created is not set.
//--------------------------------------------------------------------------

HRESULT AddStream(
    VirtualDF       *pVirtualDF,
    VirtualCtrNode  *pVirtualCtrNode,
    LPTSTR          pName,
    ULONG           cbSize,
    DWORD           grfMode,
    VirtualStmNode  **ppNewVirtualStmNode)
{
    HRESULT         hr          = S_OK;
    HRESULT         hrTemp      = S_OK;
    VirtualStmNode  *pvsnNew    = NULL;
    ULARGE_INTEGER  uli;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::AddStream"));

    DH_VDATEPTRIN(pVirtualDF, VirtualDF) ;
    DH_VDATEPTRIN(pVirtualCtrNode, VirtualCtrNode) ;
    DH_VDATEPTROUT(ppNewVirtualStmNode, PVSTMNODE) ;
    DH_VDATESTRINGPTR(pName);

    DH_ASSERT(NULL != pVirtualCtrNode);
    DH_ASSERT(NULL != ppNewVirtualStmNode);

    if(S_OK == hr)
    {
        // Initialize out parameter

        *ppNewVirtualStmNode = NULL;

        // Allocate and Initialize new VirtualStmNode

        hr = GenVirtualStmNode(pName, cbSize, &pvsnNew);

        DH_HRCHECK(hr, TEXT("GenVirtualStmNode")) ;
    }

    // Append new VirtualStm Node

    if(S_OK == hr)
    {
        if(0 == pVirtualCtrNode->GetVirtualCtrNodeStreamCount())
        {
            hr = pVirtualCtrNode->AppendFirstChildStm(pvsnNew);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::AppendFirstChildStm")) ;
        }
        else
        {
            hr=pVirtualCtrNode->GetFirstChildVirtualStmNode()->AppendSisterStm(
                    pvsnNew);

            DH_HRCHECK(hr, TEXT("VirtualStmNode::AppendSisterStm")) ;
        }
    }

    if(S_OK == hr)
    {
        // Increment the _cStreams variable of parent VirtualCtrNode

        pVirtualCtrNode->IncreaseChildrenStmCount();

    }

    // Call VirtualStmNode::Create to create a corresponding Stream on disk.

    if(S_OK == hr)
    {
        hr = pvsnNew->Create(
                grfMode,
                0,
                0);

         DH_HRCHECK(hr, TEXT("VirtualStmNode::Create")) ;
    }

    // Call VirtualStmNode::SetSize to set size of stream.

    if((S_OK == hr) && (0 != cbSize))
    {
        ULISet32(uli, cbSize);

        hr = pvsnNew->SetSize(uli);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::SetSize")) ;
    }

    // Fill in the output parameter

    if(S_OK == hr)
    {
        *ppNewVirtualStmNode = pvsnNew;
    }
    else
    {
        // Stream wasn't created successfully, so delete the VirtualStmNode.
        // Adjust the VirtualDocFile tree.  This will decrease the
        // _cStreams variable value of the parent VirtualCtrNode too.

        hrTemp = pVirtualDF->DeleteVirtualCtrNodeStreamNode(pvsnNew);

        DH_HRCHECK(
            hrTemp, 
            TEXT("pVirtualDF->DeleteVirtualCtrNodeStreamNode")) ;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//  Function:   CalculateCRCForName
//
//  Synopsis:   Calulates CRC for a IStorage/IStream's name.
//
//  Arguments:  [ptcsName]  - pointer to name of stream
//              [pdwCRCForName] - pointer to CRC
//
//  Returns:    HRESULT
//
//  History:    8-May-96  NarindK    Created.
//
//  Notes:      This is a common function used by other CRC utilities function
//              and also called directly is virtdf.cxx to calculate in memory
//              CRC for VirtualCtrNode. Since for VirtualCtrNodes/IStorages,
//              we CRC only name, we could use this function to calculate CRC.
//              - Assign passed in name to a temp. variable ptszTemp.
//              - Loop while *ptszTemp is not NULL, and call CRC_CALC macro
//                to generate CRC for the name.
//--------------------------------------------------------------------------

HRESULT CalculateCRCForName(
    const LPTSTR    ptcsName,
    DWORD           *pdwCRCForName)
{
    HRESULT hr          =   S_OK;
    LPTSTR  ptszTemp    =   NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CalculateCRCForName"));

    DH_VDATESTRINGPTR(ptcsName) ;
    DH_VDATEPTROUT(pdwCRCForName, DWORD) ;

    DH_ASSERT(NULL != ptcsName);
    DH_ASSERT(NULL != pdwCRCForName);

    if(S_OK == hr)
    {
        // Initialize out parameter

        *pdwCRCForName = CRC_PRECONDITION;

        ptszTemp = ptcsName;

        while(NULL != *ptszTemp)
        {
            CRC_CALC(*pdwCRCForName, (BYTE)*ptszTemp++);
        }
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   CalculateCRCForDataBuffer
//
//  Synopsis:   Calulates CRC for a given data Buffer.
//
//  Arguments:  [ptszBuffer]  - pointer to data buffer.
//              [culBufferSize]  - size of data buffer
//              [pdwCRCForName] - pointer to CRC
//
//  Returns:    HRESULT
//
//  History:    8-May-96  NarindK    Created.
//
//  Notes:      This is a common function used by other CRC utilities function
//              - Assign pointer to passed in buffer to pByteBuffer.
//              - Loop for culBufferSize, and call CRC_CALC macro
//                to generate CRC for the data buffer.
//--------------------------------------------------------------------------

HRESULT CalculateCRCForDataBuffer(
    const LPTSTR    ptszBuffer,
    ULONG           culBufferSize,
    DWORD           *pdwCRCForDataBuffer)
{
    HRESULT     hr          =   S_OK;
    LPBYTE      pByteBuffer =   NULL;
    ULONG       i           =   0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CalculateCRCForDataBuffer"));

    DH_VDATEPTRIN(ptszBuffer, TCHAR);
    DH_VDATEPTROUT(pdwCRCForDataBuffer, DWORD) ;

    DH_ASSERT(NULL != ptszBuffer);
    DH_ASSERT(NULL != pdwCRCForDataBuffer);

    // calculate the CRC for data of stream.

    if(S_OK == hr)
    {
        // Initialize out parameter

        *pdwCRCForDataBuffer = CRC_PRECONDITION;

        pByteBuffer = (BYTE *)ptszBuffer;

        if ( S_OK == hr )
        {
            for (i=0; i < culBufferSize; i++)
            {
                CRC_CALC(*pdwCRCForDataBuffer, pByteBuffer[i]);
            }
        }
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   CalculateInMemoryCRCForStg
//
//  Synopsis:   Calulate in memory CRC for a Stroage name
//
//  Arguments:  [pvsn]  - Pointer to VirtualCtrNode.
//              [pdwCRC] - pointer to computed CRC
//
//  Returns:    HRESULT
//
//  History:    8-May-96  NarindK    Created.
//
//  Notes:      For IStorages, only name is CRC'd.
//              - Call CalculateCRCForName to calculate CRC
//
//--------------------------------------------------------------------------

HRESULT CalculateInMemoryCRCForStg(
    VirtualCtrNode  *pvcn,
    DWORD           *pdwCRC)
{
    HRESULT     hr          = S_OK;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB,_TEXT("CalculateInMemoryCRCForStg"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;
    DH_VDATEPTROUT(pdwCRC, DWORD) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pdwCRC);

    // Now calulate the CRC for name of storage.

    if ( S_OK == hr )
    {
        // Initialize out parameter

        *pdwCRC = CRC_PRECONDITION;

        hr = CalculateCRCForName(pvcn->GetVirtualCtrNodeName(), pdwCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForName")) ;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//  Function:   CalculateInMemoryCRCForStm
//
//  Synopsis:   Calulates CRC for a IStream's data and name.
//
//  Arguments:  [pvsn]  - Pointer to VirtualStmNode.
//              [ptszBuffer] - Pointer to buffer used to write into stream
//              [culBufferSize] - Pointer to buffer size used to calculate CRC
//              [pdwCRC] - pointer to computed CRC
//
//  Returns:    HRESULT
//
//  History:    8-May-96  NarindK    Created.
//
//  Notes:      For IStreams, both name and data of stream are CRC'd.  Ensure
//              that stream is opened before this function is called.
//
//              This function is presently called directly in virtdf.cxx to
//              calculate in memory CRC for VirtualStmNode. Since for  the
//              VirtualStmNodes/IStreams, we CRC name and data, we could use
//              this function to calculate CRC if we pass it the stream name,
//              buffer, size of buffer as input parameters.
//              - Call CalculateCRCForDataBuffer to calculate dwCRCForData.
//              - Call CalculateCRCForName to calculate dwCRCForName.
//              - Compute the total CRC based on above two CRC's.
//
//--------------------------------------------------------------------------

HRESULT CalculateInMemoryCRCForStm(
    VirtualStmNode  *pvsn,
    const LPTSTR    ptszBuffer,
    ULONG           culBufferSize,
    DWCRCSTM        *pdwCRC)
{
    HRESULT     hr          = S_OK;
    DWORD       dwCRCForData= CRC_PRECONDITION;
    DWORD       dwCRCForName= CRC_PRECONDITION;
    ULONG       i           = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB,_TEXT("CalculateInMemoryCRCForStm"));

    DH_VDATEPTRIN(pvsn, VirtualStmNode) ;
    DH_VDATEPTROUT(pdwCRC, DWORD) ;
    DH_VDATEPTRIN(ptszBuffer, TCHAR);

    DH_ASSERT(NULL != pvsn);
    DH_ASSERT(NULL != ptszBuffer);
    DH_ASSERT(NULL != pdwCRC);

    if(S_OK == hr)
    {
        // Initialize CRC values to CRC_PRECONDITION

        pdwCRC->dwCRCName = pdwCRC->dwCRCData = pdwCRC->dwCRCSum = CRC_PRECONDITION;
    }

    // First calculate the CRC for data of stream.

    if(S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(ptszBuffer, culBufferSize,&dwCRCForData);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer")) ;

    }

    // Now calulate the CRC for name of stream.

    if ( S_OK == hr )
    {
        hr = CalculateCRCForName(pvsn->GetVirtualStmNodeName(), &dwCRCForName);

        DH_HRCHECK(hr, TEXT("CalculateCRCForName")) ;
    }

    // Compute the total CRC value based on above two CRC's and record 
    // individual CRC's for name and data

    if ( S_OK == hr )
    {
        pdwCRC->dwCRCData = dwCRCForData;
        pdwCRC->dwCRCName = dwCRCForName;
        MUNGECRC(pdwCRC->dwCRCSum,dwCRCForData);
        MUNGECRC(pdwCRC->dwCRCSum,dwCRCForName);
    }

    return hr;
}



//+-------------------------------------------------------------------------
//  Function:   CalculateStreamDataCRC
//
//  Synopsis:   Calculates the CRC of the stream data, 
//				using the IStream given (independent of virtualdf stuff)
//
//  Arguments:  [pStm]        - the Stream
//              [dwSize]      - the size if known, or zero => call Stat
//              [pdwCRC]      - pointer to data CRC
//              [dwChunkSize] - if >0 the stream will be read at chunks
//                              of this size.
//
//  Returns:    HRESULT
//
//  History:    02-Apr-98  georgis    Created.
//
//--------------------------------------------------------------------------

HRESULT CalculateStreamDataCRC(IStream *pStm,
                               DWORD dwSize,
                               DWORD *pdwCRC,
                               DWORD dwChunkSize)
{
    HRESULT     hr=S_OK;
    STATSTG     statstg;
    DWORD       dwBufferSize=0;
    BYTE        *pBuffer=NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CalculateStreamDataCRC"));

    DH_VDATEPTRIN(pStm, IStream);
    DH_VDATEPTROUT(pdwCRC, DWORD);
	*pdwCRC=0;	// invalid CRC

    // Ask for size if unknown (zero passed)
    if (0==dwSize)
    {
        hr = pStm->Stat(&statstg, STATFLAG_NONAME);
        DH_HRCHECK(hr, TEXT("IStorage::Stat"));
        dwSize=statstg.cbSize.LowPart; //BIGBUG: assume LowPart only
    }

    // Allocate the buffer
    if (S_OK == hr)
    {
        if (dwChunkSize>0)
        {
            dwBufferSize=dwChunkSize;
        }
        else
        {
            dwBufferSize=dwSize;
        }

        pBuffer = new BYTE[dwBufferSize];
        if (NULL==pBuffer)
        {
            hr=E_OUTOFMEMORY;
            DH_HRCHECK(hr,TEXT("new"));
        }
    }


    // Reset the stream
    if (S_OK== hr)
    { 
        LARGE_INTEGER li;

        LISet32(li,0L);
        hr=pStm->Seek(li,STREAM_SEEK_SET,NULL);
        DH_HRCHECK(hr,TEXT("Seek"));
    };

    
    // Do the actual read, calculate the CRC
    if (S_OK == hr)
    {
        DWORD dwTotalRead=0;
        DWORD dwRead=0;
        register DWORD dwCRC=CRC_PRECONDITION;
        
        while ((S_OK==hr)&&(dwTotalRead < dwSize))
        {
            hr=pStm->Read(pBuffer, dwBufferSize, &dwRead);
            DH_HRCHECK(hr,TEXT("Read"));
            dwTotalRead+=dwRead;

            if (S_OK==hr)
            {
                for (register int i=0; i<dwRead; i++)
                {
                    CRC_CALC(dwCRC,pBuffer[i]);
                }
            };
        }
        *pdwCRC=dwCRC;
    }

    if (NULL!=pBuffer)
    {
        delete pBuffer;
    };

    return hr;
}
                

//+-------------------------------------------------------------------------
//  Function:   ReadAndCalculateDiskCRCForStm
//
//  Synopsis:   Calulates CRC for a IStream's name and data.
//
//  Arguments:  [pvsn]  - pointer to VirtualStmNode
//              [pdwCRC] - pointer to CRC 
//
//  Returns:    HRESULT
//
//  History:    8-May-96  NarindK    Created.
//              2-Apr-98  georgis    use VirtualStmNode::UpdateCRC
//
//  Notes:      VirtualStmNode::UpdateCRC() actually obsoletes this function,
//              It remains for compatibility with the old tests                               
//
//              BUGBUG: all the DWCRCSTM structures are called dw* and 
//              all pointers to them pdw* . We should fix this
//
//--------------------------------------------------------------------------

HRESULT ReadAndCalculateDiskCRCForStm(
    VirtualStmNode  *pvsn,
    DWCRCSTM        *pdwCRC,
    DWORD           dwChunkSize)

{
    HRESULT     hr          = S_OK;
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ReadAndCalculateDiskCRCForStm"));

    DH_VDATEPTRIN(pvsn, VirtualStmNode) ;
    DH_VDATEPTROUT(pdwCRC, DWCRCSTM) ;

    hr=pvsn->UpdateCRC(dwChunkSize);
    DH_HRCHECK(hr, TEXT("pvsn->UpdateCRC")) ;

    pdwCRC->dwCRCSum =pvsn->GetVirtualStmNodeCRC();
    pdwCRC->dwCRCName=pvsn->GetVirtualStmNodeCRCName();
    pdwCRC->dwCRCData=pvsn->GetVirtualStmNodeCRCData();
    return hr;
}


//+-------------------------------------------------------------------------
//  Function:   CalculateDiskCRCForStg
//
//  Synopsis:   Calulates CRC for a IStrorage's name.
//
//  Arguments:  [pvcn]  - pointer to VirtualCtrNode
//              [pdwCRCForName] - pointer to CRC
//
//  Returns:    HRESULT
//
//  History:    8-May-96  NarindK    Created.
//
//  Notes:      For IStorages, only name is CRC'd.
//              -Call VirtualCtrNode::Stat to get information about storage.
//              -Call CalculateCRCForName to calculate CRC for name of the
//               storage obtained from STATSTG structure.
//--------------------------------------------------------------------------

HRESULT CalculateDiskCRCForStg(
    VirtualCtrNode  *pvcn,
    DWORD           *pdwCRCForName)
{
    HRESULT     hr          =   S_OK;
    LPMALLOC    pMalloc     =   NULL;
    LPTSTR      ptszName    =   NULL;
    STATSTG     statStg;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CalculateDiskCRCForStg"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;
    DH_VDATEPTROUT(pdwCRCForName, DWORD) ;

    // For IStorages, only name are CRC'd.

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT(NULL != pdwCRCForName);

    // Initialization
    statStg.pwcsName = NULL;

    // Get the statistics about ths opened stream

    if(S_OK == hr)
    {
        // Initialize out parameter

        *pdwCRCForName = CRC_PRECONDITION;

        hr = pvcn->Stat(&statStg, STATFLAG_DEFAULT);

        DH_HRCHECK(hr, TEXT("IStorage::Stat")) ;
    }

    // First get pMalloc that would be used to free up the name string from
    // STATSTG.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    if(S_OK == hr)
    {
       //Convert WCHAR to TCHAR

       hr = OleStringToTString(statStg.pwcsName, &ptszName);

       DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
    }

    if((S_OK == hr) && (NULL != ptszName))
    {
        hr = CalculateCRCForName(ptszName, pdwCRCForName);

        DH_HRCHECK(hr, TEXT("CalculateCRCForName")) ;
    }

    // Clean up

    if ( NULL != statStg.pwcsName)
    {
        pMalloc->Free(statStg.pwcsName);
        statStg.pwcsName = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    if(NULL != ptszName)
    {
        delete ptszName;
        ptszName = NULL;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   EnumerateInMemoryDocFile
//
//  Synopsis:   Enumerates a in memory docfile.
//
//  Arguments:  [pvcn]       - pointer to VirtualCtrNode
//              [pdwNumStg]  - pointer to number of Storages in doc hierarchy.
//              [pdwNumStm]  - pointer to number of streams in doc hierarchy
//
//  Returns:    HRESULT
//
//  History:    3-June-96  NarindK    Created.
//
//  Notes:      pdwNumStg, pdwNumStm may be NULL if user is not interested in
//              these values to be returned back. Includes the passed in pvcn
//              in pdwnumStg count.
//              -Count the passed in storage pvcn as 1 in pNumStg count.
//              -Check if pvcn's _pvsnStream is NULL or not by calling the
//               GetFirstChildVirtualStmNode() function, assign to pvsnTrav var
//              -If it is not NULL,loop till pvsnTrav is not NULL.
//                  -Increment pNumStm for stream found for this pvcn.
//                  -Assign pvcnTrav->_pvsnSister (GetFirstSisterVirtualStmNode)
//                   to pvsnTrav.
//                  -Go back to top of loop and repeat.
//              -Check if pvcn's _pvcnChild is NULL or not by calling the func
//               pvcn->GetFirstChildVirtualCtrNode() and assign it to pvcnTrav.
//              -Loop while pvcnTrav is not NULL and hr is S_OK.
//                  -Make a recursive call to self (EnumerateInMemoryDocFile)
//                  -Assign pvcnTrav->_pvcnSister to pvcnTrav. (Got thru'
//                   GetFirstSisterVirtualCtrNode function).
//                  -Update pNumStg and pNumStm based on above call, where out
//                   parameters are cChildStg and cChildStm.
//                  -Reinitialize these variables and go back to top of loop.
//--------------------------------------------------------------------------

HRESULT EnumerateInMemoryDocFile(
    VirtualCtrNode  *pvcn,
    ULONG           *pNumStg,
    ULONG           *pNumStm )
{
    HRESULT         hr              =   S_OK;
    ULONG           cChildStg       =   0;
    ULONG           cChildStm       =   0;
    VirtualCtrNode  *pvcnTrav       =   NULL;
    VirtualStmNode  *pvsnTrav       =   NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("EnumerateInMemoryDocFile"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;
    if(NULL != pNumStg)
    {
        DH_VDATEPTROUT(pNumStg, ULONG) ;
    }
    if(NULL != pNumStm)
    {
        DH_VDATEPTROUT(pNumStm, ULONG) ;
    }

    DH_ASSERT(NULL != pvcn);

    if(S_OK == hr)
    {
        if(NULL != pNumStg)
        {
            // Count the storage passed in.

            *pNumStg = 1;
        }

        if(NULL != pNumStm)
        {
            *pNumStm = 0;
        }

        pvsnTrav = pvcn->GetFirstChildVirtualStmNode();

        // Count number of VirtualStmNodes that this VirtualCtrNode has.

        while(NULL != pvsnTrav)
        {
            if(NULL != pNumStm)
            {
                (*pNumStm)++;
            }
            pvsnTrav = pvsnTrav->GetFirstSisterVirtualStmNode();
        }

        // Next recurse into the child VirtualCtrNodes of this VirtualCtrNode

        pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();
        while((NULL != pvcnTrav) && (S_OK == hr))
        {
            hr = EnumerateInMemoryDocFile(
                    pvcnTrav,
                    &cChildStg,
                    &cChildStm);

            pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();

            // Update number of nodes on basis of child nodes as found

            if((NULL != pNumStg) && (0 != cChildStg))
            {
                *pNumStg = *pNumStg + cChildStg;
            }

            if((NULL != pNumStm) && (0 != cChildStm))
            {
                *pNumStm = *pNumStm + cChildStm;
            }

            // Reinitialize variables
            cChildStg = 0;
            cChildStm = 0;
        }
    }

    // flatfile only: if we're at the root, increment stream counter to include 
    //                the default flatfile stream (CONTENTS)
    if(StorageIsFlat() && NULL == pvcn->GetParentVirtualCtrNode())
    {
        (*pNumStm)++;
    }

    return  hr;
}

//-------------------------------------------------------------------------
//  Function:   OpenRandomVirtualCtrNodeStg
//
//  Synopsis:   Opens a VirtualCtrNode's IStorage.  This traverses through all
//              the parents of the VirtualCtrNode and opens them and then
//              opens up the required storage. Please ensure that root IStorage
//              is open before this call.
//
//  Arguments:  [pvcn]   - Pointer to VirtualCtrNode whose IStorage has to
//                         opened.
//              [grfMode] - Mode to open the IStorage. (Note: all the parent
//                          IStorages would be opened in that mode too.)
//
//  Returns:    HRESULT
//
//  History:    6-June-96  NarindK    Created.
//
//  Notes:      This function doesn't reopen the root,  which is already
//              open since we need to have a valid function.  If VirtualCtrNode //              node whose storage has to be opened is same as Root, then
//              functions returns w/o any error.  Call CloseRandomVirtualCtr
//              NodeStg function to close the storages opened by this call.
//
//              -Initilize the counter to 1.
//              -Assign pvcn to pvcnTrav and loop till pvcnTrav->_pvcnParent
//               (obtained thru GetParentVirtualCtrNode() is non NULL)
//                  -Increment counter.
//                  -Assign pvcnTrav->_pvcnParent to pvcnTrav
//                  -Go back to top of loop and repeat.
//              -Check if counter is 1 or not.  If 1, then the node to be opened//               is the root itsef that was opened prior to this call. So just
//               return without any error.
//             -If counter>1, then allocate an array of VirtualCtrNode pointers
//              of size counter and continue.
//             -Assign passed in node ovcn to temp var pvcnTrav. And fill up
//              the above allocated arrays starting from the passed in node
//              way upto root.
//             -Increment the conter since root is already open, then in a
//              do-while loop, open up all the nodes till we reach the passed
//              in node. Pl. note that the nodes are opened as per grfMode that
//              was passed in to us.
//             -Delete the array of pointers.
//--------------------------------------------------------------------------

HRESULT OpenRandomVirtualCtrNodeStg(
    VirtualCtrNode  *pvcn,
    DWORD           grfMode)
{
    HRESULT         hr              =   S_OK;
    ULONG           counter         =   1;
    VirtualCtrNode  *pvcnTrav       =   NULL;
    PVCTRNODE       *pvcnArrayPtr   =   NULL;
    BOOL            fIsRoot         =   FALSE;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("OpenRandomVirtualCtrNodeStg"));

    DH_VDATEPTRIN(pvcn, PVCTRNODE) ;

    DH_ASSERT(NULL != pvcn);

    if(S_OK == hr)
    {
        // Count number of parents till the root.

        pvcnTrav = pvcn;
        while(NULL != pvcnTrav->GetParentVirtualCtrNode())
        {
            counter++;
            pvcnTrav = pvcnTrav->GetParentVirtualCtrNode();
        }

        if( 1 == counter)
        {
            fIsRoot = TRUE;
        }
        else
        {
            // Allocate an array of desired size
            pvcnArrayPtr = new PVCTRNODE [counter];
            if(NULL == pvcnArrayPtr)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if((S_OK == hr) && (FALSE == fIsRoot))
    {
        // Fill up the array starting from node itself, with parent chain
        // upto including root.

        pvcnTrav = pvcn;
        pvcnArrayPtr[--counter] = pvcn;

        while(NULL != pvcnTrav->GetParentVirtualCtrNode())
        {
            pvcnArrayPtr[--counter] = pvcnTrav->GetParentVirtualCtrNode();
            pvcnTrav = pvcnTrav->GetParentVirtualCtrNode();
        }

        // Root is already open, so open the other parent nodes down to random
        // test node.

        counter++;

        do
        {
            if(NULL != pvcnArrayPtr[counter]->GetIStoragePointer())
            {
                // If the storage is already open, then do an addref on it 
                // rather than trying to open it since all internal storages
                // are always opened with STGM_SHARE_EXCLUSIVE mode (OLE).

                hr = pvcnArrayPtr[counter]->AddRefCount();

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::AddRefCount")) ;
            }
            else
            {
                hr = pvcnArrayPtr[counter]->Open(
                        NULL,
                        grfMode,
                        NULL,
                        0);

                DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
            }

        } while(pvcnArrayPtr[counter++] != pvcn);
    }

    // Cleanup

    if(NULL != pvcnArrayPtr)
    {
        delete []pvcnArrayPtr;
        pvcnArrayPtr = NULL;
    }

    return  hr;
}

//-------------------------------------------------------------------------
//  Function:   CloseRandomVirtualCtrNodeStg
//
//  Synopsis:   Close a VirtualCtrNode's IStorage and all other IStorages that
//              were open in prior call to OpenRandomVirtualCtrNodeStg.
//              This traverses through all the parents of the VirtualCtrNode
//              and closes them excluding the root IStorage, which was not 
//              reopened during OpenRandomVirtualCtrNodeStg call.
//
//  Arguments:  [pvcn]   - Pointer to VirtualCtrNode whose IStorage has to
//                         closed.
//
//  Returns:    HRESULT
//
//  History:    18-June-96  NarindK    Created.
//
//  Notes:
//--------------------------------------------------------------------------

HRESULT CloseRandomVirtualCtrNodeStg(VirtualCtrNode  *pvcn)
{
    HRESULT         hr              =   S_OK;
    VirtualCtrNode  *pvcnTrav       =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CloseRandomVirtualCtrNodeStg"));

    DH_VDATEPTRIN(pvcn, PVCTRNODE) ;

    DH_ASSERT(NULL != pvcn);
    pvcnTrav = pvcn;

    if(S_OK == hr)
    {
        while((NULL != pvcnTrav->GetParentVirtualCtrNode()) && (S_OK == hr))
        {
            hr = pvcnTrav->Close();
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;

            pvcnTrav = pvcnTrav->GetParentVirtualCtrNode();
        }
    }

    return  hr;
}

//-------------------------------------------------------------------------
//  Function:   ParseVirtualDFAndCloseOpenStgsStms
//
//  Synopsis:   This function parses the VirtualDF tree and calls Close
//              release on all open IStorages/IStreams pointers under and/
//              or including the passed in VirtualCtrNode 
//
//  Arguments:  [pvcn]   - Pointer to VirtualCtrNode 
//              [eNodeOp]- May be NODE_INC_TOPSTG / NODE_EXC_TOPSTG 
//
//  Returns:    HRESULT
//
//  History:    16-July-96  NarindK    Created.
//
//  Notes:      If NODE_INC_TOPSTG is given, it calls a close/release on the
//              passed in VirtualCtrNode, if it is NODE_EXC_TOPSTG, it doesn't
//              call a close/release on the IStorage pointer of passed in
//              VirtualCtrNode.
//
//              Also note that if a Parent's IStorage ptr is Released and is
//              NULL, its child IStorage/IStream pointers will not be valid,
//              for use, but we still need to Release them if they exist.
//
//              - If eNodeOp is NODE_INC_TOPSTG, then see if pvcn's _pstg is not
//                NULL and call VirtualCtrNode::Close on it to release it. if
//                eNodeOp is NODE_EXC_TOPSTG, skip this step
//              - Assign pvcn's _pvcnChild to pvcnTrav and pvcn's _pvsnStream
//                to pvsnTrav 
//              - If pvsnTrav is not NULL (i.e pvcn has child VirtualStmNodes),
//                in a loop -
//                      -Check if pvsnTrav's _pstm is not NULL, if not Call 
//                       VirtualStmNode::Close in it to release, else skip it.
//                      -Advance pvsnTrav to bext VirtualStmNode _pvsnSister &
//                       go back to top of loop.
//              - If pvcnTrav is not NULL (ie pvcn has child VirtualCtrNodes),
//                in a loop -
//                      - Call ParseVirtualDFAndCloseOpenStgsStms recursively
//                        Pl. note it is called with NODE_INC_TOPSTG always.
//                      - Advance pvcnTrav to next sister VirtualCtrNode i.e.
//                        _pvcnSister and go back to top of loop.
//--------------------------------------------------------------------------

HRESULT ParseVirtualDFAndCloseOpenStgsStms(
    VirtualCtrNode  *pvcn,
    NODE_OP         eNodeOp)
{
    HRESULT         hr          =   S_OK;
    VirtualStmNode  *pvsnTrav   =   NULL;
    VirtualCtrNode  *pvcnTrav   =   NULL;

    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("ParseVirtualDFAndCloseOpenStgsStms"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT((NODE_INC_TOPSTG == eNodeOp) ||
              (NODE_EXC_TOPSTG == eNodeOp));

    if((S_OK == hr) && (NODE_INC_TOPSTG == eNodeOp))
    {
        if(NULL != pvcn->GetIStoragePointer())
        {
            hr = pvcn->Close();

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
        }
    }

    if(S_OK == hr)
    {
       pvsnTrav = pvcn->GetFirstChildVirtualStmNode();
       pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();

       // Release IStream pointers if any.

       while((NULL != pvsnTrav) && (S_OK == hr))
       {
           if(NULL != pvsnTrav->GetIStreamPointer())
           {
               hr = pvsnTrav->Close();

               DH_HRCHECK(hr, TEXT("VirtualStmNode::Close"));
           }

           pvsnTrav = pvsnTrav->GetFirstSisterVirtualStmNode();
       }

       // Next recurse into the child VirtualCtrNodes of this VirtualCtrNode

       while((NULL != pvcnTrav) && (S_OK == hr))
       {
           hr = ParseVirtualDFAndCloseOpenStgsStms(
                    pvcnTrav,
                    NODE_INC_TOPSTG);

           DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));

           pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();
       }
    }

    return hr;
}

//-------------------------------------------------------------------------
//  Function:   ParseVirtualDFAndCommitAllOpenStgs
//
//  Synopsis:   This function parses the VirtualDF tree and calls commit 
//              on all open IStorages pointers under passed in VirtualCtrNode 
//
//  Arguments:  [pvcn]   - Pointer to VirtualCtrNode 
//              [grfCommitFlags] - Commit flags.
//              [eNodeOp] - NODE_INC_TOPSTG / NODE_EXC_TOPSTG
//
//  Returns:    HRESULT
//
//  History:    23-July-96  NarindK    Created.
//
//  Notes:      - Assign pvcn's _pvcnChild, if not NULL, to local var pvcnTrav. 
//              - If pvcnTrav is not NULL (ie pvcn has child VirtualCtrNodes),
//                traverse the tree in loop to reach last child.
//                   - while pvcnTrav is not equal to pvcn and hr is S_OK, loop
//                         - If pvcnTrav has IStoragePointer, call Commit.
//                         - If pvcnTrav has sister nodes, call the function
//                           recursively with NODE_INC_TOPSTG always.
//                         - Assgin pvcnTrav's parent to pvcnTrav and go back 
//                           to top of loop.
//              - if eNodeOp is equal to NODE_INC_TOPSTG and hr is S_OK, then
//                commit the top storage pvcn, else skip commiting it.
//--------------------------------------------------------------------------

HRESULT ParseVirtualDFAndCommitAllOpenStgs(
    VirtualCtrNode  *pvcn,
    DWORD           grfCommitMode,
    NODE_OP         eNodeOp)
{
    HRESULT         hr          =   S_OK;
    VirtualCtrNode  *pvcnTrav   =   NULL;

    DH_FUNCENTRY(
        &hr, 
        DH_LVL_DFLIB, 
        _TEXT("ParseVirtualDFAndCommitAllOpenStgs"));

    DH_VDATEPTRIN(pvcn, VirtualCtrNode) ;

    DH_ASSERT(NULL != pvcn);
    DH_ASSERT((NODE_INC_TOPSTG == eNodeOp) ||
              (NODE_EXC_TOPSTG == eNodeOp));

    if(S_OK == hr)
    {
        pvcnTrav = pvcn;
        while(NULL != pvcnTrav->GetFirstChildVirtualCtrNode())
        {
            pvcnTrav = pvcnTrav->GetFirstChildVirtualCtrNode();
        }

        DH_ASSERT(NULL != pvcnTrav);
    }

    // Commit this storage, next commit any sister VirtualCtrNodes it might 
    // have  and commit those by recursing into them, then go to parent and 
    // repeat. if parent is equal to pvcnParent, quit the loop 

    while((pvcn != pvcnTrav) && (S_OK == hr))
    {
        if(NULL != pvcnTrav->GetIStoragePointer())
        {
            hr = pvcnTrav->Commit(grfCommitMode);

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit"));
        }

        while((NULL != pvcnTrav->GetFirstSisterVirtualCtrNode()) && 
              (S_OK == hr))
        {
            pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode();

            hr = ParseVirtualDFAndCommitAllOpenStgs(
                        pvcnTrav,
                        grfCommitMode,
                        NODE_INC_TOPSTG);

            DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs"));
        }

        // Go to Parent VirtualCtrNode and commit them
    
        pvcnTrav = pvcnTrav->GetParentVirtualCtrNode();
    }

    if((S_OK == hr)                     && 
       (NODE_INC_TOPSTG == eNodeOp)     &&
       (NULL != pvcn->GetIStoragePointer()))
    {
        hr = pvcn->Commit(grfCommitMode);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit"));
    }
 
    return hr;
}

//-------------------------------------------------------------------------
//
// The following utilitiy functions are to calculate the CRC for a docfile
// These are independent of VirtualDF tree or any other base code implement-
// ation.
//
//-------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Function:   CalculateCRCForDocFile
//
//  Synopsis:   Calulates CRC for the disk docfile.
//
//  Arguments:  [pIStorage]  - pointer to IStorage
//              [crcflags]   - what stuff to include in the crc
//              [pdwCRC]     - pointer to CRC
//
//  Returns:    HRESULT
//
//  History:    30-May-96  NarindK    Created.
//              24-Jul-97  MikeW      Include state bits
//              02-Apr-98  georgis    read in chunks
//
//  Notes:      For IStorages, only name is CRC'd.  For IStorages/IStreams,
//              both name and data are CRC'd.
//
//              Please not that this function will not indicate a failure if
//              and whenver the IEnumSTATSTG->Next returns fail, that just
//              indicates the completion of enumeration sequence.
//
//              If VERIFY_OP is equal to VERIFY_INC_TOPSTG_NAME, then the func
//              goes ahead and calculates CRC for toplevel storage name also
//              else if it is equal to VERIFY_EXC_TOPSTG_NAME, it doesn't
//              include the CRC for top level storage name.  Pl. note that
//              the recursive call to itself in function includes VERIFY_INC_
//              TOPSTG_NAME, so this parameter is used only for TOP level
//              storage that is passed in (pointed by pIStorage).
//
//              - if VERIFY_OP is VERIFY_INC_TOPSTG_NAME then,              
//                  -Call pIStorage->Stat to get STATSTG structure for passed
//                  IStorage.
//                  -Call CalculateCRCForName to get the CRC for name of this
//                  storage obtained from STATSTG structure.
//                  -Fold the CRC into grand CRC pdwCRC.
//              -Call pIStorage->Enumerate to get LPENUMSTATSTG for storage.
//              -Call lpEnumStatStg->Next to get next element in enumeration
//               sequence. If it returns S_FALSE, means no elements to enum
//               earte, so just return w/o any error.
//              -Else loop till hr is S_OK.
//                  -If node is of type STGSTY_STORAGE, then
//                      -Open the child IStorage.
//                      -Make a recursive call to calculate CRC for this
//                       child Istorage to self CalculateCRCForDocFile.
//                      -Fold the CRC from above call into grand CRC pdwCRC.
//                      -Release the child IStorage
//                  -If node is of type STGSTY_STREAM, then
//                      -Call CalculateCRCForDocFileStmData to calculate CRC
//                       for stream data.
//                      -Call CalculateCRCForName to calculate CRC for its
//                       name.
//                      -Fold the above two into grand CRC pdwCRC.
//                  -Get the next element in enumeration sequence. If it returns
//                   S_FALSE, then simply return w/o any error.
//                  -Else go back to top of loop and repeat.
//--------------------------------------------------------------------------

HRESULT CalculateCRCForDocFile(
    IStorage        *pIStorage,
    DWORD           crcflags, 
    DWORD           *pdwCRC,
    DWORD           dwChunkSize)

{
    HRESULT         hr              =   S_OK;
    LPENUMSTATSTG   lpEnumStatStg   =   NULL;
    ULONG           *pceltFetched   =   NULL;
    LPSTORAGE       pIStorageChild  =   NULL;
    DWORD           dwCurrStgCRC    =   0;
    DWORD           dwCurrStgNameCRC=   0;
    DWORD           dwCurrStmNameCRC=   0;
    DWORD           dwCurrStmDataCRC=   0;
    BOOL            fIEnumNextFail  =   FALSE;
    ULONG           i               =   0;
    LPTSTR          ptszName        =   NULL;
    LPTSTR          ptszNameStm     =   NULL;
    LPTSTR          ptszNameStg     =   NULL;
    LPOLESTR        poszNameStg     =   NULL;
    STATSTG         statStg;
    STATSTG         statStgEnum;
    DWORD           statflag        = STATFLAG_DEFAULT;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CalculateCRCForDocFile"));

    DH_VDATEPTRIN(pIStorage, IStorage) ;
    DH_VDATEPTROUT(pdwCRC, DWORD) ;

    DH_ASSERT(NULL != pIStorage);
    DH_ASSERT(NULL != pdwCRC);

    // Initialization
    statStg.pwcsName = NULL;
    statStgEnum.pwcsName = NULL;
 
    // Initialize out parameter

    *pdwCRC = CRC_PRECONDITION;

    // Call Stat on the passed IStorage to get its name and state bits

    if (! (CRC_INC_TOPSTG_NAME & crcflags))
    {
        statflag = STATFLAG_NONAME;
    }

    if(S_OK == hr)
    {
        hr = pIStorage->Stat(&statStg, statflag);

        DH_HRCHECK(hr, TEXT("IStorage::Stat")) ;
    }

    if (CRC_INC_STATEBITS & crcflags)
    {
        // Fold the CRC into grand CRC

        MUNGECRC(*pdwCRC, statStg.grfStateBits);

        DH_TRACE((
                DH_LVL_CRCDUMP, 
                TEXT("statebits=0x%08x, crc=0x%08x"),
                statStg.grfStateBits, 
                *pdwCRC));

    }

    // If crcflags includes CRC_INC_TOPSTG_NAME, then calculate and
    // include the top level storage name in calculating grand CRC.

    if(CRC_INC_TOPSTG_NAME & crcflags)
    {
        DH_ASSERT(NULL != statStg.pwcsName);

        // Find the CRC for the storage name

        if(S_OK == hr)
        {
            //Convert WCHAR to TCHAR

            hr = OleStringToTString(statStg.pwcsName, &ptszName);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
        }

        if(S_OK == hr)
        {
            hr = CalculateCRCForName(ptszName, &dwCurrStgNameCRC);

            DH_HRCHECK(hr, TEXT("CalculateCRCForDocFileNames")) ;
        }

        // Fold the CRC into grand CRC

        MUNGECRC(*pdwCRC, dwCurrStgNameCRC);

        DH_TRACE((
                DH_LVL_CRCDUMP,
                TEXT("storage=%s, crc=0x%08x"),
                ptszName, 
                *pdwCRC));

        // Clean up

        if(NULL != statStg.pwcsName)
        {
            CoTaskMemFree(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }

        if(NULL != ptszName)
        {
            delete ptszName;
            ptszName = NULL;
        }
    }

    // Get the enumerator so that we could enumerate this storage

    if(S_OK == hr)
    {
        hr = pIStorage->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("IStorage::EnumElements")) ;
    }

    // if successful to get enumerator, get the first element of the enumeration
    // sequence.

    if ( S_OK == hr )
    {
        hr = lpEnumStatStg->Next(1, &statStgEnum, pceltFetched);

        if(S_FALSE == hr)
        {
            fIEnumNextFail = TRUE;
        }
    }

    // Loop through till lpEnumStatStg->Next returns FALSE which is desired
    // sequene or some other error happens

    while(S_OK == hr)
    {
        // If the element is an IStorage, open this and make a recursive call
        // to CalculateCRCForDocFile function.

        if (STGTY_STORAGE == statStgEnum.type)
        {
            //Convert WCHAR to TCHAR

            hr = OleStringToTString(statStgEnum.pwcsName, &ptszNameStg);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;

            if(S_OK == hr)
            {
                // Convert TCHAR to OLECHAR

                hr = TStringToOleString(ptszNameStg, &poszNameStg);

                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            if(S_OK == hr)
            {
                hr = pIStorage->OpenStorage(
                       poszNameStg,
                       NULL,
                       STGM_READ | STGM_SHARE_EXCLUSIVE,
                       NULL,
                       0,
                       &pIStorageChild);

                DH_HRCHECK(hr, TEXT("IStorage::OpenStorage")) ;
            }

            if (S_OK == hr)
            {
                // Make recursive call including CRC_INC_TOPSTG_NAME

                hr = CalculateCRCForDocFile(
                        pIStorageChild, 
                        crcflags | CRC_INC_TOPSTG_NAME,
                        &dwCurrStgCRC);

                DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
            }

            // Fold the CRC for contained IStorage into grand CRC

            MUNGECRC(*pdwCRC, dwCurrStgCRC);

            // Release the storage pointer

            if(NULL != pIStorageChild)
            {
                pIStorageChild->Release();
                pIStorageChild = NULL;
            }
        }
        else

        // If the element is an IStream, calculate CRC for its name and Data.

        if (STGTY_STREAM == statStgEnum.type)
        {
            // Calulate CRC for IStream Data.
    
            if(S_OK == hr)
            {
                //Convert WCHAR to TCHAR

                hr = OleStringToTString(statStgEnum.pwcsName, &ptszNameStm);

                DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
            }

            if(S_OK == hr)
            {
                hr = CalculateCRCForDocFileStmData(
                        pIStorage,
                        ptszNameStm,
                        statStgEnum.cbSize.LowPart,
                        &dwCurrStmDataCRC,
                        dwChunkSize);
    
                DH_HRCHECK(hr, TEXT("CalculateCRCForDocFileStmData"));
            }

            // Calulate CRC for IStream Name.

            if(S_OK == hr)
            {
                hr = CalculateCRCForName(
                        ptszNameStm,
                        &dwCurrStmNameCRC);

                DH_HRCHECK(hr, TEXT("CalculateCRCForName"));

                DH_TRACE((
                        DH_LVL_CRCDUMP,
                        TEXT("stream %s, name crc=0x%08x, data crc=0x%08x"),
                        ptszNameStm,
                        dwCurrStmNameCRC,
                        dwCurrStmDataCRC));
            }

            // Fold the CRC's  for contained IStream into grand CRC

            MUNGECRC(*pdwCRC, dwCurrStmDataCRC);
            MUNGECRC(*pdwCRC, dwCurrStmNameCRC);
        }
        else

        // The element is neither IStorage nor IStream, report error.
        {
            hr = E_UNEXPECTED;
        }

        // Clean up

        if(NULL != statStgEnum.pwcsName)
        {
            CoTaskMemFree(statStgEnum.pwcsName);
            statStgEnum.pwcsName = NULL;
        }

        if(NULL != ptszNameStm)
        {
            delete ptszNameStm;
            ptszNameStm = NULL;
        }

        if(NULL != ptszNameStg)
        {
            delete ptszNameStg;
            ptszNameStg = NULL;
        }

        if(NULL != poszNameStg)
        {
            delete poszNameStg;
            poszNameStg = NULL;
        }

        // Get the next element in the enumeration sequence

        if(S_OK == hr)
        {
            hr = lpEnumStatStg->Next(1, &statStgEnum, pceltFetched);

            if(S_FALSE == hr)
            {
                fIEnumNextFail = TRUE;
            }
        }
    }

    // IEnumSTATSTG->Next would return S_FALSE if it can't enumerate the
    // next element because there might not be any elements to enumerate
    // hence it doesn't indicate an error for this function, but is just
    // a condition for looping through the total docfile structure, hence
    // don't reprot failure because of it.

    if(TRUE == fIEnumNextFail)
    {
        hr = S_OK;
    }

    // Clean up

    if (NULL != lpEnumStatStg)
    {
        lpEnumStatStg->Release();
        lpEnumStatStg = NULL;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   CalculateCRCForDocFileStmData
//
//  Synopsis:   Calulates CRC for the disk docfile's stream data.
//
//  Arguments:  [pIStorage]     - pointer to parent storage
//              [ptcsName]      - pointer to name string
//              [cbSize]        - size of the data to be read.
//              [pdwCurrStmDataCRC]- pointer to returned CRC
//
//  Returns:    HRESULT
//
//  History:    30-May-96  NarindK    Created.
//              02-Apr-98  georgis    Use CalculateStreamDataCRC
//
//--------------------------------------------------------------------------

HRESULT CalculateCRCForDocFileStmData(
    LPSTORAGE       pIStorage,
    LPTSTR          ptcsName,
    DWORD           cbSize,
    DWORD           *pdwCurrStmDataCRC,
    DWORD           dwChunkSize)

{
    HRESULT         hr              =   S_OK;
    LPSTREAM        pIStreamChild   =   NULL;
    LPOLESTR        pOleStrTemp     =   NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, TEXT("CalculateCRCForDocFileStmData"));

    DH_VDATEPTRIN(pIStorage, IStorage) ;
    DH_VDATESTRINGPTR(ptcsName) ;
    DH_VDATEPTROUT(pdwCurrStmDataCRC, DWORD) ;

    DH_ASSERT(NULL != pIStorage);
    DH_ASSERT(NULL != ptcsName);
    DH_ASSERT(NULL != pdwCurrStmDataCRC);

    // Open the stream
    hr = TStringToOleString(ptcsName, &pOleStrTemp);
    DH_HRCHECK(hr, TEXT("TStringToOleString")) ;

    if ( S_OK == hr )
    {
        hr = pIStorage->OpenStream(
                 pOleStrTemp,
                 NULL,
                 STGM_READ | STGM_SHARE_EXCLUSIVE,
                 0,
                 &pIStreamChild);

        DH_HRCHECK(hr, TEXT("IStorage::OpenStream")) ;
    }


    if ( S_OK == hr )
    {
		// Calculate the CRC for the stream data
		hr=CalculateStreamDataCRC(
			pIStreamChild,
			cbSize,
			pdwCurrStmDataCRC,
			dwChunkSize);
		DH_HRCHECK(hr, TEXT("CalculateStreamDataCRC"));
    }

    if (NULL!= pIStreamChild)
    {
        pIStreamChild->Release();
    }

    if (NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   CalculateCRCForDocFileStmData
//
//  Synopsis:   Calulates CRC for the disk docfile's stream data.
//
//  Arguments:  [ptcsName]  - ? not used
//              [pIChildStream] - pointer to the opened stream
//              [cbSize] - size of the data to be read.
//              [pdwCurrStmDataCRC]- pointer to returned CRC
//
//  Returns:    HRESULT
//
//  History:    15-Nov-96  JiminLi    Created.
//              02-Apr-98  georgis    Use CalculateStreamDataCRC
//
//  Notes:      CalculateStreamDataCRC actually obsoletes this function
//              It remains for compatibility with the old tests                               
//
//--------------------------------------------------------------------------

HRESULT CalculateCRCForDocFileStmData(
    LPTSTR          ptcsName,
    LPSTREAM        pIChildStream,
    DWORD           cbSize,
    DWORD           *pdwCurrStmDataCRC,
    DWORD           dwChunkSize)
{
    HRESULT         hr              =   S_OK;
 
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, TEXT("CalculateCRCForDocFileStmData"));

    DH_VDATEPTRIN(pIChildStream, IStream) ;
    DH_VDATEPTROUT(pdwCurrStmDataCRC, DWORD) ;
    DH_ASSERT(NULL != pdwCurrStmDataCRC);
    DH_ASSERT(0 != cbSize);

    // The stream is kept open before calling this function
    DH_ASSERT(NULL != pIChildStream);

    // Calculate the CRC for the stream data
    hr=CalculateStreamDataCRC(
        pIChildStream,
        cbSize,
        pdwCurrStmDataCRC,
        dwChunkSize);
    DH_HRCHECK(hr, TEXT("CalculateStreamDataCRC"));

    return  hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   EnumerateDiskDocFile
//
//  Synopsis:   Enumerates a disk docfile.
//
//  Arguments:  [pIStorage]  - pointer to IStorage
//              [eVerifyOp]  - VERIFY_SHORT or VERIFY_DETAIL
//              [pdwNumStg]  - pointer to number of Storages in doc hierarchy.
//              [pdwNumStm]  - pointer to number of streams in doc hierarchy
//
//  Returns:    HRESULT
//
//  History:    3-June-96  NarindK    Created.
//
//  Notes:      pdwNumStg, pdwNumStm may be NULL if user is not interested in
//              these values to be returned back.  eVerifyOp should normally
//              be specified as VERIFY_SHORT unless test requires it otherwise
//
//              -Count the passed in pIStorage as 1 in pNumStg count.
//              -Call pIStorage->EnumElements to get LPENUMSTATSTG lpEnumStatStg
//              -Call lpEnumStatStg->Next to get next node. If it returns
//               S_FALSE, that indicates no elements to enumerate, so return
//               without any error.
//              -Else loop till hr is S_OK
//                  -if node is of type STGTY_STORAGE, then
//                      -open that child storage and make a recursive call to
//                       EnumerateDiskDocFile passing it pointer to opened
//                       child storage, and cChildStg and cChildStm local
//                       variables for count.
//                      -close the child storage opened.
//                      -Update the pNumStg, pNumStm based on above recursive
//                       call's out parameters cChildStg and CChildStm.
//                  -if node is of type STGTY_STREAM, then update pNumStm count
//                      - if flag VERIFY_DETAIL is passed in, then open that
//                        stream and read its contents.  This verification
//                        is useful in cases like corruption tests where this
//                        verification ensures proper stability of OLE under
//                        such situations.   
//                  -Get the next element in enumeration sequence.
//                  -Reinitilize the local variables cChildStg, cChildStm.
//                  -Go back to top of loop and repeat.
//--------------------------------------------------------------------------

HRESULT EnumerateDiskDocFile(
    LPSTORAGE   pIStorage,
    VERIFY_OP   eVerifyOp, 
    ULONG       *pNumStg,
    ULONG       *pNumStm )
{
    HRESULT         hr              =   S_OK;
    LPMALLOC        pMalloc         =   NULL;
    LPENUMSTATSTG   lpEnumStatStg   =   NULL;
    ULONG           *pceltFetched   =   NULL;
    LPSTORAGE       pIStorageChild  =   NULL;
    BOOL            fIEnumNextFail  =   FALSE;
    ULONG           cChildStg       =   0;
    ULONG           cChildStm       =   0;
    LPSTREAM        pIStreamChild   =   NULL;
    LPOLESTR        pocsBuffer      =   NULL;
    LPTSTR          ptszNameStg     =   NULL;
    LPOLESTR        poszNameStg     =   NULL;
    LPTSTR          ptszNameStm     =   NULL;
    LPOLESTR        poszNameStm     =   NULL;
    ULONG           culRead         =   0;
    ULONG           culCurBufferLen =   0;
    STATSTG         statStgEnum;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("EnumerateDiskDocFile"));

    DH_VDATEPTRIN(pIStorage, IStorage) ;
    if(NULL != pNumStg)
    {
        DH_VDATEPTROUT(pNumStg, ULONG) ;
    }
    if(NULL != pNumStm)
    {
        DH_VDATEPTROUT(pNumStm, ULONG) ;
    }

    DH_ASSERT(NULL != pIStorage);

    // Initialization
    statStgEnum.pwcsName = NULL;

    // Get pMalloc which we shall later use to free pwcsName of STATSTG struct.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    // Call EnumElements on passed IStorage to enumerate it.

    if(S_OK == hr)
    {
        // Initialize out parameter

        if(NULL != pNumStg)
        {
            // Count the storage passed in.

            *pNumStg = 1;
        }

        if(NULL != pNumStm)
        {
            *pNumStm = 0;
        }

        hr = pIStorage->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("IStorage::EnumElements")) ;
    }

    // if successful to get enumerator, get the first element of the enumeration
    // sequence.

    if ( S_OK == hr )
    {
        hr = lpEnumStatStg->Next(1, &statStgEnum, pceltFetched);

        if(S_FALSE == hr)
        {
            fIEnumNextFail = TRUE;
        }
    }

    // Loop through till lpEnumStatStg->Next returns FALSE which is desired
    // sequence or some other error happens

    while(S_OK == hr)
    {
        // If the element is an IStorage, open this and make a recursive call
        // to EnumerateDocFile function.

        if (STGTY_STORAGE == statStgEnum.type)
        {
            //Convert WCHAR to TCHAR

            hr = OleStringToTString(statStgEnum.pwcsName, &ptszNameStg);

            DH_HRCHECK(hr, TEXT("OleStringToTString")) ;

            if(S_OK == hr)
            {
                // Convert TCHAR to OLECHAR

                hr = TStringToOleString(ptszNameStg, &poszNameStg);

                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            if(S_OK == hr)
            {
                hr = pIStorage->OpenStorage(
                       poszNameStg,
                       NULL,
                       STGM_READ | STGM_SHARE_EXCLUSIVE,
                       NULL,
                       0,
                       &pIStorageChild);

                DH_HRCHECK(hr, TEXT("IStorage::OpenStorage")) ;
            }

            if (S_OK == hr)
            {
                // Recursive call to EnumerateDiskDocFile

                hr = EnumerateDiskDocFile(
                        pIStorageChild,
                        eVerifyOp,
                        &cChildStg,
                        &cChildStm);

                DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
            }

            // Release the storage pointer

            if(NULL != pIStorageChild)
            {
                pIStorageChild->Release();
                pIStorageChild = NULL;
            }

            // Release string pointers.

            if(NULL != ptszNameStg)
            {
                delete ptszNameStg;
                ptszNameStg = NULL;
            }

            if(NULL != poszNameStg)
            {
                delete poszNameStg;
                poszNameStg = NULL;
            }

            // Update number of storage and stream objects, if required.

            if((NULL != pNumStg) && (0 != cChildStg))
            {
                *pNumStg = cChildStg + *pNumStg;
            }

            if((NULL != pNumStm) && (0 != cChildStm))
            {
                *pNumStm = cChildStm + *pNumStm;
            }
        }
        else
        if (STGTY_STREAM == statStgEnum.type)
        {
            if(NULL != pNumStm)
            {
                (*pNumStm)++;
            }
            if(VERIFY_DETAIL == eVerifyOp)
            {
                //Attempt to open and read the stream.  Useful for corruption
                // tests to see that OLE doesn't GPF under those conditions.

                //Convert WCHAR to TCHAR

                hr = OleStringToTString(statStgEnum.pwcsName, &ptszNameStm);

                DH_HRCHECK(hr, TEXT("OleStringToTString")) ;

                if(S_OK == hr)
                {
                    // Convert TCHAR to OLECHAR

                    hr = TStringToOleString(ptszNameStm, &poszNameStm);

                    DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
                }

                // Open the stream.

                if(S_OK == hr)
                {
                    hr = pIStorage->OpenStream(
                            poszNameStm,
                            NULL,
                            STGM_READ | STGM_SHARE_EXCLUSIVE,
                            0,
                            &pIStreamChild);

                    DH_HRCHECK(hr, TEXT("IStorage::OpenStream")) ;
                }

                // Read the stream in loop
                while(( culCurBufferLen < statStgEnum.cbSize.LowPart) &&
                      (S_OK == hr))
                {
                    if ( S_OK == hr )
                    {
                        pocsBuffer = new OLECHAR [STM_BUFLEN];

                        if (pocsBuffer == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    if ( S_OK == hr )
                    {
                        // Initialize the buffer

                        memset(pocsBuffer, '\0', STM_BUFLEN);

                        //  Read the stream.

                        hr = pIStreamChild->Read(
                                pocsBuffer,
                                STM_BUFLEN,
                                &culRead);

                        DH_HRCHECK(hr, TEXT("IStream::Read")) ;
                    }

                    // Release the buffer 
                    if(NULL != pocsBuffer)
                    {
                        delete [] pocsBuffer;
                        pocsBuffer = NULL;
                    }

                    // Increment culCurBufferLen
                    culCurBufferLen = culCurBufferLen + culRead;
                }

                // Release the stream
                if(NULL != pIStreamChild)
                {
                    pIStreamChild->Release();
                    pIStreamChild = NULL;
                }
                    
                // Release string pointers.

                if(NULL != ptszNameStm)
                {
                    delete ptszNameStm;
                    ptszNameStm = NULL;
                }

                if(NULL != poszNameStm)
                {
                    delete poszNameStm;
                    poszNameStm = NULL;
                }
            }
        }
        else
        // The element is neither IStorage nor IStream, report error.
        {
            hr = E_UNEXPECTED;
        }

        // Clean up

        if(NULL != statStgEnum.pwcsName)
        {
            pMalloc->Free(statStgEnum.pwcsName);
            statStgEnum.pwcsName = NULL;
        }

        // Get the next element in the enumeration sequence

        if(S_OK == hr)
        {
            hr = lpEnumStatStg->Next(1, &statStgEnum, pceltFetched);

            if(S_FALSE == hr)
            {
                fIEnumNextFail = TRUE;
            }
        }

        // Reinitialize the variables

        cChildStg = 0;
        cChildStm = 0;
    }

    // IEnumSTATSTG->Next returning S_FALSE indicates end of traversal in
    // docfile hierarchy, not an error.

    if(TRUE == fIEnumNextFail)
    {
        hr = S_OK;
    }

    // Clean up

    if (NULL != lpEnumStatStg)
    {
        lpEnumStatStg->Release();
        lpEnumStatStg = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    return  hr;
}


//+-------------------------------------------------------------------------
//  Function:   GenerateVirtualDFFromDiskDF
//
//  Synopsis:   Enumerates a disk docfile and creates an in memory virtual
//              DocFile tree for the docfile.
//
//  Arguments:  [pNewVirtualDF] - Pointer to new VirtualDF tree being made.
//              [ptszRootDFName]  - Pointer to name of root Disk file.
//              [grfMode]    - Mode to open the root storage 
//              [ppvcnRoot]  - pointer to pointer to root of VirtualDF.
//              [pIRootStg]  - Default value is NULL, when fDFOpened is TRUE,
//                             then pIRootStg must not be NULL, it is RootStg
//                             pointer
//              [fDFOpened] -  Default value is FALSE, i.e. the docfile is not
//                             opened, StgOpenStorage is called to open it.
//                             When it's TRUE, the pIRootStg is the stg pointer.
//
//  Returns:    HRESULT
//
//  History:    5-June-96  NarindK    Created.
//              3-Feb-97   JiminLi    Adapted
//
//  Notes:      -Call TStringToOleString to convert given DocFile name to
//               OLECHAR.
//              - Call StgOpenStorage to open Root storage.
//              -Call GenVirtualCtrNode to generate the root *ppvcnRoot of new
//               VirtualDocFile tree being made passing it name from above Stat
//               call.  If successful, assocaite disk root IStorage with the
//               root VirtualCtrNode's _pstg parameter.
//              -Call GenerateRemVirtualDFTree to generate rest of tree, passing//               it the new rootgenerated above and pIStorage.
//              -If successful, call VirtualDF::Associate to associate this
//               new root with the VirtualDF tree, else reassign *ppvcnRoot
//               to NULL in case of failure.
//
//              Please note that the Root storage opened during this call will
//              be released during VirtualDF tree deletion that deletes all 
//              the VirtualCtrNodes in the tree & Destructor of VirtualCtrNodes
//              does a final release on the storage pointers, if they are valid
//              Also note that as result of this function, all other storage/
//              streams are closed, except the Root storage. 
//--------------------------------------------------------------------------

HRESULT GenerateVirtualDFFromDiskDF(
    VirtualDF       *pNewVirtualDF,
    LPTSTR          ptszRootDFName,
    DWORD           grfMode,
    VirtualCtrNode  **ppvcnRoot,
    LPSTORAGE       pIRootStg,
    BOOL            fDFOpened,
    ULONG           ulSeed)
{
    HRESULT         hr              =   S_OK;
    LPSTORAGE       pIStorage       =   NULL;
    LPOLESTR        pOleStrTemp     =   NULL;
    ULONG           i               =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GenerateVirtualDFFromDiskDF"));

    DH_VDATESTRINGPTR(ptszRootDFName) ;
    DH_VDATEPTROUT(ppvcnRoot, PVCTRNODE) ;
    DH_VDATEPTROUT(pNewVirtualDF, VirtualDF) ;

    DH_ASSERT(NULL != ptszRootDFName);
    DH_ASSERT(NULL != ppvcnRoot);
    DH_ASSERT(NULL != pNewVirtualDF);

    if (fDFOpened)
    {
        DH_ASSERT(NULL != pIRootStg);
        pIStorage = pIRootStg;
    }
    else
    {
        DH_ASSERT(0 != grfMode);
    }

    if ( S_OK == hr )
    {
        // Initialize out parameter

        *ppvcnRoot = NULL;
    }

    if (!fDFOpened && (S_OK == hr))
    {
        // Convert TCHAR to OLECHAR

        hr = TStringToOleString(ptszRootDFName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if (!fDFOpened && (S_OK == hr))
    {
        // Try opening the docfile
        // StgOpenStorage returns STG_E_LOCKVIOLATION is concurrent API calls
        // are made, so this is the hack for workaround the problem.
        // BUGBUG : Remove this loop once the feature is implemented in OLE.
        // BUGBUG : ntbug#114779  Affects DCOM95 only. ntbug#41249 fixed

#if (WINVER<0x500)          //NT5 is lockviolation fixed
        for(i=0; i<NRETRIES; i++)  // NRETRIES has been defined as 5
        {
#endif
            hr = StgOpenStorage(
                    pOleStrTemp,  
                    NULL,
                    grfMode, 
                    NULL,
                    0,
                    &pIStorage);

#if (WINVER<0x500)          //NT5 is lockviolation fixed
            if ( (S_OK == hr) || (STG_E_LOCKVIOLATION != hr) )
            {
                break;
            }

            Sleep(NWAIT_TIME);            
        }
#endif
    }

    if ( S_OK == hr )
    {
        // Call to create the VirtualDF tree root.

        hr = GenVirtualCtrNode(ptszRootDFName, ppvcnRoot);

        DH_HRCHECK(hr, TEXT("GenerateVirtualDFRootFromDiskStg")) ;

    }

    if ( S_OK == hr )
    {
        // Create the remaining VirtualDF tree.

        hr = GenerateRemVirtualDFTree(*ppvcnRoot, pIStorage);

        DH_HRCHECK(hr, TEXT("CreateRemVirtualDFTree")) ;
    }

    if (S_OK != hr)
    {
        // The tree couldn't be successfully created, return NULL in out
        // parameter.

        *ppvcnRoot = NULL;
    }
    else
    {
        // Associate the root VirtualCtrNode with the VirtualDF tree.

        hr = pNewVirtualDF->Associate(*ppvcnRoot, pIStorage, ulSeed);

        DH_HRCHECK(hr, TEXT("VirtualDF::Associate")) ;
    }

    // Clean up

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp; 
        pOleStrTemp = NULL;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   GenerateVirtualDFFromDiskDF
//
//  Synopsis:   Enumerates a disk docfile and creates an in memory virtual
//              DocFile tree for the docfile.
//
//  Arguments:  [pNewVirtualDF]  - Pointer to new VirtualDF tree being made.
//              [ptszRootDFName] - Pointer to name of root Disk file.
//              [grfMode]        - Mode to open the root storage 
//              [ppvcnRoot]      - pointer to pointer to root of VirtualDF.
//              [ulSeed]         - pointer to pointer to root of VirtualDF.
//
//  Notes:      Call the above function with filled in params that are
//              normally defaulted with the defaults. Seed is at the
//              end, so we need them.
//              This is a convenience function.
//
//--------------------------------------------------------------------------

HRESULT GenerateVirtualDFFromDiskDF(
    VirtualDF       *pNewVirtualDF,
    LPTSTR          ptszRootDFName,
    DWORD           grfMode,
    VirtualCtrNode  **ppvcnRoot,
    ULONG           ulSeed)
{                                
    return GenerateVirtualDFFromDiskDF(
            pNewVirtualDF,
            ptszRootDFName,
            grfMode,
            ppvcnRoot,
            NULL,
            FALSE,
            ulSeed);
}

//+-------------------------------------------------------------------------
//  Function:   GenerateRemVirtualDFTree
//
//  Synopsis:   Creates rest of in memory virtual DocFile tree for a given
//              Disk Docfile. Internal function local to this file.
//
//  Arguments:  [pvcnParent]   - pointer to root VirtualCtrNode
//              [pIStgParent]  - pointer to Disk IStorage assoc. with above.
//
//  Returns:    HRESULT
//
//  History:    5-June-96  NarindK    Created.
//
//  Notes:      -Call pIStgParent->Enumerate to get LPENUMSTATSTG for storage.
//              -Call lpEnumStatStg->Next to get next element of enumeration.
//               if it returns S_FALSE, that means there is nothing to enum-
//               erate, so just return without nay error.
//              -Else loop till hr is S_OK
//                  -If node is of type STGTY_STORAGE then
//                      -open this child storage.
//                      -Call GenVirtualCtrNode to create a corresponding
//                       VirtualCtrNode for this storage.
//                      -Call AppendChildCtr or AppendSisterCtr as case is.
//                      -Call parent's IncreaseChildrenStgCount to indicate
//                       a new VirtualCtrNode is added.
//                      -Make a recursive call to GenVirtualCtrNode.
//                      -Release the child storage pointer and remember the old
//                       sibling.
//                  -If node is of type STGSTY_STREAM then
//                      -Call GenVirtualStmNode to create a corresponding
//                       VirtualStmNode for this stream.
//                      -Call AppendChildStm or AppendSisterStm as case is.
//                      -Call parent's IncreaseChildrenStmCount to indicate
//                       a new VirtualStmNode is added.
//                      -Remember the old sibling.
//                  -Reinitialize local variables and call Next on the enumera-
//                   or.  If it returns S_FALSE, then exist out of loop w/o
//                   any error.
//                  -Else go back to top of loop and repeat.
//--------------------------------------------------------------------------

HRESULT GenerateRemVirtualDFTree(
    VirtualCtrNode  *pvcnParent,
    LPSTORAGE       pIStgParent)
{
    HRESULT         hr              =   S_OK;
    LPMALLOC        pMalloc         =   NULL;
    ULONG           *pceltFetched   =   NULL;
    LPSTORAGE       pIStorageChild  =   NULL;
    VirtualCtrNode  *pvcnChild      =   NULL;
    VirtualStmNode  *pvsnChild      =   NULL;
    VirtualCtrNode  *pvcnOldSister  =   NULL;
    VirtualStmNode  *pvsnOldSister  =   NULL;
    LPENUMSTATSTG   lpEnumStatStg   =   NULL;
    BOOL            fFirstChild     =   TRUE;
    BOOL            fFirstStream    =   TRUE;
    BOOL            fIEnumNextFail  =   FALSE;
    LPTSTR          ptszNameStg     =   NULL;
    LPTSTR          ptszNameStm     =   NULL;
    LPOLESTR        pOleStrTemp     =   NULL;
    STATSTG         statStgEnum;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GenerateRemVirtualDFTree"));

    // Initialization
    statStgEnum.pwcsName = NULL;

    // Get pMalloc which we shall later use to free pwcsName of STATSTG struct.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    if ( S_OK == hr )
    {
        // Get an Enumerator for given IStorage

        hr = pIStgParent->EnumElements(0, NULL, 0, &lpEnumStatStg);

        DH_HRCHECK(hr, TEXT("IStorage::EnumElements")) ;
    }

    // if successful to get enumerator, get the first element of the enumeration
    // sequence.

    if ( S_OK == hr )
    {
        hr = lpEnumStatStg->Next(1, &statStgEnum, pceltFetched);

        if(S_FALSE == hr)
        {
            fIEnumNextFail = TRUE;
        }
    }

    while(S_OK == hr)
    {
        // If the element is an IStorage, open this and make a recursive call
        // to self.

        if (STGTY_STORAGE == statStgEnum.type)
        {
            if(S_OK == hr)
            {
                //Convert WCHAR to TCHAR

                hr = OleStringToTString(statStgEnum.pwcsName, &ptszNameStg);

                DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
            }

            if(S_OK == hr)
            {
                // Convert TCHAR to OLECHAR

                hr = TStringToOleString(ptszNameStg, &pOleStrTemp);

                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            hr = pIStgParent->OpenStorage(
                       pOleStrTemp,
                       NULL,
                       STGM_READ | STGM_SHARE_EXCLUSIVE,
                       NULL,
                       0,
                       &pIStorageChild);

            DH_HRCHECK(hr, TEXT("IStorage::OpenStorage")) ;

            // Add to tree

            if (S_OK == hr)
            {
                hr = GenVirtualCtrNode(
                        ptszNameStg,
                        &pvcnChild);
            }

            if (S_OK == hr)
            {
                if(fFirstChild == TRUE)
                {
                    hr = pvcnParent->AppendChildCtr(pvcnChild);
                    pvcnParent->IncreaseChildrenStgCount();

                    fFirstChild = FALSE;
                }
                else
                {
                    hr = pvcnOldSister->AppendSisterCtr(pvcnChild);
                    pvcnParent->IncreaseChildrenStgCount();
                }
            }

            if (S_OK == hr)
            {
                // Recursive call to self

                hr = GenerateRemVirtualDFTree(pvcnChild, pIStorageChild);

                DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile")) ;
            }

            // Release the storage pointer

            if(NULL != pIStorageChild)
            {
                pIStorageChild->Release();
                pIStorageChild = NULL;
            }

            // Remember the old sibling

            pvcnOldSister = pvcnChild;
        }
        else

        // The element is an IStream.

        if (STGTY_STREAM == statStgEnum.type)
        {
            // Add to tree

            if (S_OK == hr)
            {
                if(S_OK == hr)
                {
                    // Convert WCHAR to TCHAR

                    hr = OleStringToTString(statStgEnum.pwcsName, &ptszNameStm);

                    DH_HRCHECK(hr, TEXT("OleStringToTString")) ;
                }

                // BUGBUG:The cbSize used during creation is a DWORD. Assumption
                // cbSize.LowPart contains the size information hence.

                hr = GenVirtualStmNode(
                        ptszNameStm,
                        statStgEnum.cbSize.LowPart,
                        &pvsnChild);
            }

            if (S_OK == hr)
            {
                if(fFirstStream == TRUE)
                {
                    hr = pvcnParent->AppendFirstChildStm(pvsnChild);
                    pvcnParent->IncreaseChildrenStmCount();

                    fFirstStream = FALSE;
                }
                else
                {
                    hr = pvsnOldSister->AppendSisterStm(pvsnChild);
                    pvcnParent->IncreaseChildrenStmCount();
                }
            }

            // Remember the old sibling

            pvsnOldSister = pvsnChild;
        }
        else
        // The element is neither IStorage nor IStream, report error.
        {
            hr = E_UNEXPECTED;
        }

        // Cleanup

        if(NULL != statStgEnum.pwcsName)
        {
            pMalloc->Free(statStgEnum.pwcsName);
            statStgEnum.pwcsName = NULL;
        }

        if(NULL != pOleStrTemp)
        {
            delete pOleStrTemp; 
            pOleStrTemp = NULL;
        }

        if(NULL != ptszNameStg)
        {
            delete ptszNameStg; 
            ptszNameStg = NULL;
        }

        if(NULL != ptszNameStm)
        {
            delete ptszNameStm; 
            ptszNameStm = NULL;
        }

        // Reinitialize the variables

        pIStorageChild = NULL;
        pvcnChild = NULL;
        pvsnChild = NULL;

        // Get the next element in the enumeration sequence

        if(S_OK == hr)
        {
            hr = lpEnumStatStg->Next(1, &statStgEnum, pceltFetched);

            if(S_FALSE == hr)
            {
                fIEnumNextFail = TRUE;
            }
        }
    }

    // IEnumSTATSTG->Next returning S_FALSE indicates end of traversal in
    // docfile hierarchy, not an error.

    if(TRUE == fIEnumNextFail)
    {
        hr = S_OK;
    }

    // Clean up

    if (NULL != lpEnumStatStg)
    {
        lpEnumStatStg->Release();
        lpEnumStatStg = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   GenVirtualCtrNode
//
//  Synopsis:   Creates a VirtualCtrNode and initializes it
//
//  Arguments:  [ptcsName]   - pointer to name for VirtualCtrNode
//              [*ppvcnNew]  - Returned VirtualCtrNode.
//
//  Returns:    HRESULT
//
//  History:    5-June-96  NarindK    Created.
//
//  Notes:      Creates a VirtualCtrNode and initializes it will pName that
//              is passed in. _cChildren and _cStreams are initialized to
//              zero.
//--------------------------------------------------------------------------

HRESULT GenVirtualCtrNode(
    LPTSTR          ptcsName,
    VirtualCtrNode  **ppvcnNew)
{
    HRESULT         hr              =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GenVirtualCtrNodeFromDiskStg"));

    DH_VDATEPTRIN(ptcsName, TCHAR) ;
    DH_VDATEPTROUT(ppvcnNew, PVCTRNODE) ;

    DH_ASSERT(NULL != ptcsName);
    DH_ASSERT(NULL != ppvcnNew);

    // Generate VirtualCtrNode for the stg.

    if(S_OK == hr)
    {
        // Initialize out parameter

        *ppvcnNew = NULL;

        // Create new VirtualCtrNode

        *ppvcnNew = new VirtualCtrNode();

        if (NULL == *ppvcnNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Initialize VirtualCtrNode

        hr = (*ppvcnNew)->Init(ptcsName, 0, 0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Init")) ;
    }

    return  hr;
}

//+-------------------------------------------------------------------------
//  Function:   GenVirtualStmNode
//
//  Synopsis:   Creates a VirtualStmNode and initializes it
//
//  Arguments:  [ptcsName]   - pointer to name for VirtualStmNode
//              [*ppvcnNew]  - Returned VirtualStmNode.
//
//  Returns:    HRESULT
//
//  History:    5-June-96  NarindK    Created.
//
//  Notes:      -Creates a new VirtualStmNode and initializes it with name
//               and size passed in.
//--------------------------------------------------------------------------

HRESULT GenVirtualStmNode(
    LPTSTR          ptcsName,
    DWORD           cbSize,
    VirtualStmNode  **ppvsnNew)
{
    HRESULT         hr              =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GenVirtualStmNode"));

    DH_VDATEPTRIN(ptcsName, TCHAR) ;
    DH_VDATEPTROUT(ppvsnNew, PVSTMNODE) ;

    DH_ASSERT(NULL != ptcsName);
    DH_ASSERT(NULL != ppvsnNew);

    // Generate VirtualStmNode for the stream.

    if(S_OK == hr)
    {
        *ppvsnNew = new VirtualStmNode();

        if (NULL == *ppvsnNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        hr = (*ppvsnNew)->Init(ptcsName, cbSize);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Init")) ;
    }

    return  hr;
}

//+-------------------------------------------------------------------
//
//  Function:  PrivAtol
//
//  Synopsis:  Private "atol" function for better error control
//
//  Arguments: [pszNum] - The number string
//
//             [plResult] - A place to put the result
//
//  Returns:   S_OK if the function succeeds, another HRESULT otherwise
//
//  History:   28-Jul-1995   AlexE   Created
//             20-May-1996   Narindk Adapted for stgbase tests.
//
//--------------------------------------------------------------------

HRESULT PrivAtol(char *pszNum, LONG *plResult)
{
    LONG l = 0 ;

    *plResult = 0 ;

    while (0 != *pszNum)
    {
       if (*pszNum > '9' || *pszNum < '0')
       {
           return E_INVALIDARG ;
       }

       l = 10 * l + (LONG) ((*pszNum - '0')) ;

       pszNum++ ;

    }

    *plResult = l ;

    return S_OK ;
}

//+-------------------------------------------------------------------------
//
//  Function:   GenerateRandomString
//
//  Synopsis:   Generates a random string using datagen object.  This function
//              differs from the orginal GenerateRandomFunction in the fact
//              that it doesn't generate a random extenstion.
//
//  Arguments:  [pgdu] - Pointer to DG_UNICODE object.
//              [pptszName] - Pointer to pointer to returned string.
//              [ulMinLen] - Minimum length of string
//              [ulMaxLen] - Maximum length of string
//
//  Returns:    HRESULT.  S_OK if everything goes ok, error code otherwise.
//
//  History:    17-Apr-96  NarindK    Created.
//              31-July-96 Narindk    Adapted to stgbase tests.
//
//  Notes:      BUGBUG: This function need to be enhance to handle different
//              character sets.
//              Please note that in GenerateRandomName, name gen may have an
//              extension b/w 0 and FILEEXT_MAXLEN besides the length of name
//              b/w ulMinLen and ulMax Len.  But  with this function, it will
//              not have any extension, so the length would be b/w ulMinLen &
//              ulMaxLen.
//
//--------------------------------------------------------------------------

HRESULT GenerateRandomString(
    DG_STRING   *pgds,
    ULONG       ulMinLen,
    ULONG       ulMaxLen,
    LPTSTR      *pptszName)
{
    HRESULT     hr          =   S_OK;
    ULONG       cTemp       =   0;
    USHORT      usErr       =   0;
    ULONG       ulActMaxLen =   0;
    ULONG       ulActMinLen =   0;
    ULONG       ulNameLen   =   0;
    LPTSTR      ptszName    =   NULL;
    LPWSTR      pwszName    =   NULL;

    TCHAR       ptszFATCharSet[FAT_CHARSET_SIZE];
    LPWSTR      pwszFATCharSet = NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("GenerateRandomString"));

    DH_VDATEPTRIN(pgds, DG_STRING) ;
    DH_VDATEPTROUT(pptszName, LPTSTR) ;

    DH_ASSERT(NULL != pgds);
    DH_ASSERT(NULL != pptszName);
    if (S_OK == hr)
    {
        // Initialize out parameter.

        *pptszName = NULL;

        // Sanity check.  Min length for name must be <= maximum length, if it
        // isn't then make maximum length equal to minimum length.

        if (ulMaxLen < ulMinLen)
        {
            ulMaxLen =  ulMinLen;
        }

        // If Maximum length provided is 0, then default maximum length would
        // be used.  If Minimum length provided is zero, then 1 would be used
        // for it.

        // BUGBUG:  We are using default maximum length for FAT system.

        ulActMaxLen = (ulMaxLen == 0 ? DEF_FATNAME_MAXLEN : ulMaxLen);
        ulActMinLen = (ulMinLen == 0 ? 1 : ulMinLen);

        // '\0', '\', '/', and ':' are invalid for IStorage/IStream names
        //                         (For doc file)
        // '*', '"' '<' '>' '?' are invalid for IStorage/IStream names on OFS

        // Initialize valid character set for FAT file names

        _tcscpy(ptszFATCharSet, _TEXT("abcdefghijklmnopqrstuvwxyz"));
        _tcscat(ptszFATCharSet, _TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZ"));
        _tcscat(ptszFATCharSet, _TEXT("0123456789"));

        // Call DataGen to generate a random file name
        // BUGBUG:  We are using FAT character set to generate random names.

#ifdef _MAC

	usErr = pgds->Generate(
		    (UCHAR **)&ptszName,     // force compiler to chose the right
		    (UCHAR *)ptszFATCharSet, // version of Generate
		    ulActMinLen,
		    ulActMaxLen);

#else

        if(S_OK == hr)
        {
            // Convert TCHAR to WCHAR

            hr = TStrToWStr(ptszFATCharSet, &pwszFATCharSet);
            DH_HRCHECK(hr, TEXT("TStrToWStr")) ;
        }

        usErr = pgds->Generate(
                    &pwszName,
                    pwszFATCharSet,
                    ulActMinLen,
                    ulActMaxLen);

#endif //_MAC

        if (usErr != DG_RC_SUCCESS)    // DataGen error
        {
            hr = E_FAIL;
        }
    }


#ifndef _MAC

    if(S_OK == hr)
    {
       // Convert WCHAR to TCHAR

       hr = WStrToTStr(pwszName, &ptszName);

       DH_HRCHECK(hr, TEXT("WStrToTStr")) ;
    }

#endif //_MAC

    if (S_OK == hr)
    {
        ulNameLen = _tcslen(ptszName);

        // Construct the full name

        *pptszName = new TCHAR[ulNameLen + 1];

        if(NULL == *pptszName)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        _tcscpy(*pptszName, ptszName);
    }

    // Clean up

    if (NULL != ptszName)
    {
        delete ptszName;
        ptszName = NULL;
    }

    if (NULL != pwszName)
    {
        delete pwszName;
        pwszName = NULL;
    }

    if (NULL != pwszFATCharSet)
    {
        delete pwszFATCharSet;
        pwszFATCharSet = NULL;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//  Function:   GenerateRandomStreamData
//
//  Synopsis:   Generates a random data using datagen object.
//
//  Arguments:  [pgds] - Pointer to DG_STRING object.
//              [pptszName] - Pointer to pointer to returned string.
//              [ulMinLen] - Minimum length of string
//              [ulMaxLen] - Maximum length of string
//
//  Returns:    HRESULT.  S_OK if everything goes ok, error code otherwise.
//
//  History:    30-Mar-98  SCousens   Created from GenerateRandomName
//
//  Notes:      
//              -ulMaxLen is defaulted, so you dont need to specify 
//               both ulMinLen and ulMaxLen if you want a random buffer 
//               of a given length.
//              -If ulMaxLen is less than ulMinLen, buffer will be
//               ulMinLen bytes in length.
//              -Generate a buffer upto CB_STMDATA_DATABUFFER bytes in 
//               length. Copy this buffer multiple times into actual 
//               returned buffer.
//              -Alphabet currently ASCII 1-255
//--------------------------------------------------------------------------
HRESULT GenerateRandomStreamData(
    DG_STRING   *pgds,
    LPTSTR      *pptszData,
    ULONG       ulMinLen,
    ULONG       ulMaxLen)
{
    HRESULT     hr          =   S_OK;
    UINT        x;
    USHORT      usErr       =   0;
    ULONG       cbBuffer    =   0;
    ULONG       ulBufferLen =   0;
    ULONG       ulRndStart  =   0;
    ULONG       ulBufStart  =   0;
    LPBYTE      pbDataBuf   =   0;
    LPBYTE      pbRndBuffer =   0;
    DG_INTEGER  *dgi;  //we need to generate random numbers
#ifdef _MAC
    CHAR        szCharSet[CB_STMDATA_CHARSET];
#else
    WCHAR       szCharSet[CB_STMDATA_CHARSET];
#endif //_MAC

    DH_FUNCENTRY (NULL, DH_LVL_DFLIB, TEXT("GenerateRandomStreamData"));

    DH_VDATEPTRIN (pgds, DG_STRING) ;
    DH_VDATEPTROUT (pptszData, LPTSTR) ;

    DH_ASSERT (NULL != pgds);
    DH_ASSERT (NULL != pptszData);

    // use seed from given dgs, its the best we can do...
    dgi = new DG_INTEGER (pgds->GetSeed ());
    if (NULL == dgi)
    {
        hr = E_OUTOFMEMORY;
    }
    DH_HRCHECK (hr, TEXT("new DG_INTEGER"));

    if (S_OK == hr)
    {
        // Initialize out parameter.
        *pptszData = NULL;

        // Sanity check.  Min length for name must be <= maximum length.
        // if used default params, make max same as min (it will be 0)
        if (ulMaxLen < ulMinLen)
        {
            ulMaxLen =  ulMinLen;
        }

        // If Maximum length provided is 0, then default to 512 (BUGBUG: hardcoded) 
        // If Minimum length provided is 0, then use 1 
        ulMaxLen = (ulMaxLen == 0 ? 512 : ulMaxLen);
        ulMinLen = (ulMinLen == 0 ? 1 : ulMinLen);

        // Initialize character set (BUGBUG currenly only ASCII 01-255)
        for (x=0; x<CB_STMDATA_CHARSET-1; x++)
        {
            szCharSet[x] = x+1; //omit NULL to start
        }

        // this is how many chars we will be putting into the stream.
        // since dg_string::Generate chooses, and we are bypassin that,
        // we need to choose a number between ulminlen, ulmaxlen.
        dgi->Generate (&ulBufferLen, ulMinLen, ulMaxLen);

        // If needed buffer is smaller than our buffer, 
        // just generate that many bytes.
        cbBuffer = min (CB_STMDATA_DATABUFFER, ulBufferLen);

        // make our buffer
#ifdef _MAC
        usErr = pgds->Generate(
                (UCHAR **)&pbRndBuffer, // force compiler to chose the right
                (UCHAR *)szCharSet,     // version of Generate
                cbBuffer / sizeof (TCHAR),   // need chars
                cbBuffer / sizeof (TCHAR));  // cbBuffer is bytes
#else
        usErr = pgds->Generate(
                (LPWSTR*)&pbRndBuffer,
                szCharSet,
                cbBuffer+1 / sizeof (TCHAR),    // need chars
                cbBuffer+1 / sizeof (TCHAR));   // cbBuffer is bytes
#endif //_MAC

        if (usErr != DG_RC_SUCCESS)    // DataGen error
        {
            hr = E_FAIL;
        }
        DH_HRCHECK (hr, TEXT("pgds::Generate"));
    }

    // now allocate the data buffer
    if (S_OK == hr)
    {
        pbDataBuf = new BYTE[ulBufferLen];
        if (NULL == pbDataBuf)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new BYTE"));
        DH_TRACE ((DH_LVL_TRACE4, 
                TEXT("Data buffer (%#x) - allocated %x bytes, (%d bytes)"),
                pbDataBuf,
                ulBufferLen,
                ulBufferLen));
    }


    if (S_OK == hr)
    {
        for (ulBufStart=0; ulBufStart<ulBufferLen; ulBufStart+=cbBuffer)
        {
            //generate a random starting point
            dgi->Generate (&ulRndStart, 
                    0, 
                    min (CB_STMDATA_DATABUFFER, ulBufferLen));

            //  Copy from rnd spot to end of buffer (provided we need it all)
            cbBuffer = min (CB_STMDATA_DATABUFFER-ulRndStart, ulBufferLen-ulBufStart);
            MoveMemory (&pbDataBuf[ulBufStart], 
                    &pbRndBuffer[ulRndStart], 
                    cbBuffer);
            ulBufStart+=cbBuffer;

            //  Copy from begin of buffer to rnd spot (provided we need it)
            cbBuffer = min (ulRndStart, ulBufferLen-ulBufStart);
            if (0 != cbBuffer)
            {
                MoveMemory (&pbDataBuf[ulBufStart], 
                        pbRndBuffer, 
                        cbBuffer);
            }
        }
    }

    if (S_OK == hr)
    {
        *pptszData = (LPTSTR)pbDataBuf;
    }

    // Clean up
    delete []pbRndBuffer;

    return hr;
}

//-------------------------------------------------------------------------
//  Function:   ParseVirtualDFAndOpenAllSubStgsStms 
//
//  Synopsis:   Given a storage, this function will recurse down the
//              tree, opening all substorages and streams.
//
//  Arguments:  [pvcn]      - Pointer to VirtualCtrNode 
//              [dwStgMode] - Mode to open sub-storages
//              [dwStmMode] - Mode to open streams
//
//  Returns:    HRESULT
//
//  History:    27-January-97  SCousens    Created.
//
//  Notes:      - provided VirtualCtrNode must already be open.
//              - ALL substgs and stms must be closed before
//                calling this, else access violations may occur

HRESULT ParseVirtualDFAndOpenAllSubStgsStms (VirtualCtrNode * pvcn,
        DWORD dwStgMode, 
        DWORD dwStmMode)
{
    HRESULT          hr = S_OK;
    VirtualCtrNode * pvcnTrav = NULL;
    VirtualStmNode * pvsnTrav = NULL;

    DH_VDATEPTRIN (pvcn, VirtualCtrNode);
    DH_ASSERT (NULL != pvcn->GetIStoragePointer ()); //if not open _pstg will be null

    // enumerate and open all stms in current stg.
    pvsnTrav = pvcn->GetFirstChildVirtualStmNode ();
    while(NULL != pvsnTrav && S_OK == hr)
    {
        if (NULL == pvsnTrav->GetIStreamPointer ())
        {
            hr = pvsnTrav->Open(NULL, dwStmMode, NULL);
        }
        pvsnTrav = pvsnTrav->GetFirstSisterVirtualStmNode ();
    }

    // enumerate and open all stgs in current stg.
    pvcnTrav = pvcn->GetFirstChildVirtualCtrNode();
    while(NULL != pvcnTrav && S_OK == hr)
    {
        if (NULL == pvcnTrav->GetIStoragePointer ())
        {
            hr = pvcnTrav->Open(NULL, dwStgMode, NULL, 0);
        }
        //  then recursively open all elements in just opened stg.
        if (S_OK == hr)
        {
            hr = ParseVirtualDFAndOpenAllSubStgsStms (pvcnTrav, 
                    dwStgMode, 
                    dwStmMode);
        }
        pvcnTrav = pvcnTrav->GetFirstSisterVirtualCtrNode ();
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetDocFileName
//
//  Synopsis:   Figures out name of docfile given the seed
//
//  Arguments:   [in] ulSeed        - the seed value
//              [out] ptszDocName   - docfile name (needs to be deleted [])
//
//  Returns:    S_OK if all goes well, another HRESULT if not.
//
//  History:    19-Mar-97   SCousens   Created
//
//  Notes:      We can take advantage of the way VirtualDF gets the
//              docfile name. Its the first string generated.
//
//--------------------------------------------------------------------------

HRESULT GetDocFileName (ULONG ulSeed, LPTSTR *pptszDocName)
{
    HRESULT    hr       = E_FAIL;
    DG_STRING *pdgs     = NULL;

    DH_FUNCENTRY(NULL, DH_LVL_TRACE1, TEXT("GetDocFileName"));
    DH_VDATEPTROUT (pptszDocName, LPTSTR);
    DH_ASSERT (NULL != ulSeed);

    // init out stuff
    *pptszDocName = NULL;

    //get our datagen
    pdgs = new DG_STRING (ulSeed);

    if (NULL != pdgs)
    {
        // Generate random name for root 
        hr = GenerateRandomName(
                pdgs,
                MINLENGTH,
                MAXLENGTH,
                pptszDocName);
        DH_HRCHECK (hr, TEXT("GenerateRandomName")) ;
    }

    // cleanup
    delete pdgs;

    return hr;
}

//-------------------------------------------------------------------------
//  Function:   CommitRandomVirtualCtrNodeStg
//
//  Synopsis:   Commits a VirtualCtrNode's IStorage and all ascedant
//              IStorages. This traverses through all the parents
//              and commit them excluding the root IStorage
//
//  Arguments:  [pvcn]          - Pointer to VirtualCtrNode whose IStorage
//                                is to be commited
//              [grfCommitMode] - Commit mode
//
//  Returns:    HRESULT
//
//  History:    16-Apr-97  BogdanT    Created.
//
//  Notes:
//--------------------------------------------------------------------------

HRESULT CommitRandomVirtualCtrNodeStg(VirtualCtrNode  *pvcn, 
                                      DWORD           grfCommitMode)
{
    HRESULT         hr              =   S_OK;
    VirtualCtrNode  *pvcnTrav       =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CommitRandomVirtualCtrNodeStg"));

    DH_VDATEPTRIN(pvcn, PVCTRNODE) ;

    DH_ASSERT(NULL != pvcn);
    pvcnTrav = pvcn;

    if(S_OK == hr)
    {
        while((NULL != pvcnTrav->GetParentVirtualCtrNode()) && (S_OK == hr))
        {
            hr = pvcnTrav->Commit(grfCommitMode);
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;

            pvcnTrav = pvcnTrav->GetParentVirtualCtrNode();
        }
    }

    return  hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\dfhelp\utest\utest.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1993 - 1996.
//  All rights reserved.
//
//--------------------------------------------------------------------------
#include <dfheader.hxx>
#pragma hdrstop

#include <debdlg.h>

// global defines

#define LOG_FILE_NAME "/t:utest"

// Debug Object

DH_DEFINE;

// Usage:  If you would like to use CreateFromParams to create ChanceDocFile
//         tree, give arguments e.g
//         test /seed:2 /dfdepth:0-9 /dfstg:1-11 /dfstm:10-30 /dfstmlen:0-222 
//         /dfRootCrMode:dirReadWriteShEx
//
//         if want to use CreateFromSize but through CreateFromParams e.g.
//         test /seed:2 /dfsize:tiny
//          
//         If the seed value given is zero, the datagen objects computes the
//         seed value to be used based on current time and some other compu-
//         tations, so the resulting docfiles wouldn't be same in different
//         instants of time if seed is 0 even if all the other parameters are
//         same.  With seed value other than zero, the docfiles produced at 
//         different instances of time would be identical with other parameters //         remaining same.
// 

//
//-------------------------------------------------------------------
//
//  Function:   main 
//
//  Synopsis:   entry point for unit test program 
//
//  Parameters: [argc]          - Argument count
//              [argv]          - Arguments
//
//  Returns:    void 
//
//  History:    20-Apr-1996     Narindk     Created 
//
//--------------------------------------------------------------------

VOID __cdecl main(int argc, char *argv[])
{
    HRESULT     hr              = S_OK;
    ChanceDF    *pTestChanceDF  = NULL;
    VirtualDF   *pTestVirtualDF = NULL;
    VirtualCtrNode *pVirtualDFRoot = NULL;

    // Initialize our log object

    DH_CREATELOGCMDLINE( LOG_FILE_NAME ) ;
    DH_SETLOGLOC(DH_LOC_LOG) ;
   
    
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("::main"));
 
    //  Initialize the OLE server.
 
    hr = CoInitialize(NULL);

    if (S_OK != hr)
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("test: CoInitialize failed, hr=0x%08x\n"), hr));

        return;
    }

    // I:   Using CreateFromSize within program to generate DocFile

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }
   
    if (S_OK == hr)
    {
        // To check from CreateFromSize

        hr = pTestChanceDF->CreateFromSize(DF_HUGE, 2);
        
        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromSize")) ;
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.
 
    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);
        
        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("DocFile - CreateFromSize - successfully created.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("DocFile - CreateFromSize - failed.\n")));

    }

    // Cleanup

    if(NULL != pTestChanceDF)
    {
        hr = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());   
 
        DH_HRCHECK(hr, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    if(NULL != pTestVirtualDF)
    {    
        hr = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);    

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // II:   Using CreateFromParams to generate DocFile
    //       a.  Using CreateFromParams to call Create. e.g.
    //           test /seed:3 /dfdepth:0-9 /dfstg:1-11 /dfstm:10-30 
    //           /dfstmlen:0-222  /dfRootCrMode:4114 /dfStgCrMode:4114
    //           /dfStmCrMode:4114
    //       b.  Using CreateFromParams to call CreateFromSize. e.g.
    //           test /seed:2 /dfsize:tiny
    //       c.  Using CreateFromParams to call CreateFromFile (NYI). e.g.
    //           test /seed:4 /dftemp:myfile
    //      
    //       if you do not provide the parameters, but still call the function
    //       CreateFromParam, all default values would be used.

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }
   
    // Can pass the arguments after simulating command line arguments in
    // the test itself.
        
    if (S_OK == hr)
    {
        // To create it from Params.

         hr = pTestChanceDF->CreateFromParams(argc, argv);

         DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.
 
    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("DocFile - CreateFromParams - successfully created.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("DocFile - CreateFromParams - failed.\n")));
    }

    // Cleanup

    if(NULL != pTestChanceDF)
    {
        hr = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());    

        DH_HRCHECK(hr, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    if(NULL != pTestVirtualDF)
    {    
        hr = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);    

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // III:   Using CreateFromSize within program to generate DocFile. 
    //        Do the following operations:
 
    //   a.      Close the root node and open root node again. Check it succeeds

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        // To check from CreateFromSize

        hr = pTestChanceDF->CreateFromSize(DF_MEDIUM, 3);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromSize")) ;
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("DocFile - CreateFromSize - successfully created.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("DocFile - CreateFromSize - failed.\n")));
    }

    //   a.  Close the root node and open root node again. Check it succeeds

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("Root Storage closed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("Root Storage couldn't be closed successfully.\n")));
    }

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE  , 
                NULL, 
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::OpenRoot")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("Root Storage opened successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("Root Storage couldn't be opened successfully.\n")));
    }

    //   b.  Close the root node's stream and open it again. Check it succeeds

    VirtualStmNode  *pvsnTest = NULL;
    VirtualCtrNode  *pvcnTest = NULL;

    if (S_OK == hr)
    {
        // This call will return us the root of VirtualDocFileTree becoz'
        // we are passing NULL for second parameter.
 
        hr = GetVirtualStgNodeForTest(pTestVirtualDF, NULL, &pvcnTest, 0); 
        DH_HRCHECK(hr, TEXT("GetVirtualStgNodeForTest")) ;
    }

    if (S_OK == hr)
    {
        // This call will return us the first stream of pvcnTest VirtualCtrNode 
        // as we are passing zero for fourth parameter.

        hr = GetVirtualStmNodeForTest(pvcnTest, &pvsnTest, 0); 
        DH_HRCHECK(hr, TEXT("GetVirtualStgNodeForTest")) ;
    }

    if (S_OK == hr)
    {
        hr = pvsnTest->Close();
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("VirtualStmNode::Close completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("VirtualStmNode::Close couldn't complete successfully.\n")));
    }

    if (S_OK == hr)
    {
        hr = pvsnTest->Open(
                NULL, 
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE  , 
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("VirtualStmNode::Open completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("VirtualStmNode::Open couldn't complete successfully.\n")));
    }

    // c.1  Set the size of the stream

    DWORD       dwStreamSize   = 512;
    ULARGE_INTEGER   uli;

    ULISet32(uli, dwStreamSize);

    if (S_OK == hr)
    {
        hr =  pvsnTest->SetSize(uli);
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("IStream::SetSize function completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("IStream::SetSize function wasn't successful.\n")));
    }


    // c.2  Write into opened test stream. Check it succeeds

    DWORD       dwSize      = 0;
    DWORD       dwBufSize   = 512;
    DWORD       dwWritten   = 0;
    ULONG       *lpBuf      = NULL;
    const ULONG kulPattern  = 0xABCDABCD; // Arbitrary fill pattern for stream

    lpBuf = new ULONG [dwBufSize];

    if (lpBuf == NULL)
    {
       hr = E_OUTOFMEMORY;
    }

    for (dwSize = 0; dwSize < dwBufSize; dwSize++)
    {
       lpBuf[dwSize] = kulPattern;
    }

    if (S_OK == hr)
    {
        hr =  pvsnTest->Write(lpBuf, dwBufSize, &dwWritten);
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("IStream::Write function completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("IStream::Write function wasn't successful.\n")));
    }

    // Cleanup

    delete []lpBuf;

    //   d.  Seek test stream. Check it succeeds

    LARGE_INTEGER   lint;

    memset(&lint, 0, sizeof(LARGE_INTEGER));

    //  Position the stream header to the begining

    if (S_OK == hr)
    {
        hr = pvsnTest->Seek(lint, STREAM_SEEK_SET, NULL);
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("IStream::Seek function completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("IStream::Seek function wasn't successful.\n")));
    }
    
    //   e.  Read test stream. Check it succeeds

    DWORD   dwRead = 0;
    ULONG   *lpStr  = NULL;

    lpStr = new ULONG [dwBufSize];

    if (lpBuf == NULL)
    {
       hr = E_OUTOFMEMORY;
    }

    if ( S_OK == hr )
    {
        //  Read the stream.

        hr = pvsnTest->Read(lpStr, dwBufSize, &dwRead);
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("IStream::Read function completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("IStream::Read function wasn't successful.\n")));
    }

    // Cleanup

    delete []lpStr;

    //   f.  Close the root node's substorage and open it again. Check it 
    //        succeeds

    VirtualCtrNode  *pvcnTest1 = NULL;
    ULONG           cChildCnt = 0;

    if (S_OK == hr)
    {
        // This call will return us the first substorage root of 
        // VirtualDocFileTree if its exists.  We may use pvcnTest
        // which points to the root of virtual docfile tree. 

        cChildCnt = 
           pVirtualDFRoot->GetVirtualCtrNodeChildrenCount();
       
        /* 
        _ftprintf(stdout, 
                  TEXT("No of substorages in RootStorage are %lu"),
                  cChildCnt);
        */

        if(cChildCnt <= 0)
        {
            hr = S_FALSE;
        
            DH_LOG((
                LOG_INFO,
                TEXT("No substorages of this storage")));
        }
    }
 
    if (S_OK == hr)
    {
        // Get the first substorage of the root.

        hr = GetVirtualStgNodeForTest(
               pTestVirtualDF,pVirtualDFRoot,&pvcnTest1,1); 

        DH_HRCHECK(hr, TEXT("GetVirtualStgNodeForTest")) ;
    }

    if (S_OK == hr)
    {
        hr = pvcnTest1->Close();
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("VirtualCtrNode::Close completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("VirtualCtrNode::Close couldn't complete successfully.\n")));
    }

    if (S_OK == hr)
    {
        hr = pvcnTest1->Open(
                NULL, 
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                NULL, 
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("VirtualCtrNode::Open completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("VirtualCtrNode::Open couldn't complete successfully.\n")));
    }
  
    // f: Adds a new storage to an existing storage.  We would add another
    //    substorage to our root storage for the test.

    VirtualCtrNode *pvcnNewStorage = NULL;
    LPWSTR         pNewStgName     = L"NewTestStg";
    if(S_OK == hr)
    {
        hr = AddStorage(
                pVirtualDFRoot,
                &pvcnNewStorage, 
                pNewStgName,  
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_CREATE |
                STGM_DIRECT); 
 
        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    } 
    
    if(S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("VirtualCtrNode::AddStorage completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("VirtualCtrNode::AddStorage couldn't complete successfully.\n")));
    }
  
    // g: Deletes a storage in an existing storage.  We would delete first 
    //    child substorage of our root storage for the test.

    if(S_OK == hr)
    {
        hr = DestroyStorage(
                pTestVirtualDF, 
                pVirtualDFRoot->GetFirstChildVirtualCtrNode());
 
        DH_HRCHECK(hr, TEXT("DeleteStorage")) ;
    } 
    
    if(S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("VirtualCtrNode::DestroyStorage completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("VirtualCtrNode::DestroyStorage couldn't complete successfully.\n")));
    }

    // h: Adds a new stream to an existing storage.  We would add a stream to
    //    newly created substorage "NewTestStg" of our root storage for test.

    VirtualStmNode *pvsnNewStream = NULL;
    LPWSTR         pNewStmName     = L"NewTestStm";
    ULONG          cbNewSize       = 20;

    if(S_OK == hr)
    {
        hr = AddStream(
                pvcnNewStorage,
                &pvsnNewStream, 
                pNewStmName, 
                cbNewSize, 
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_CREATE |
                STGM_DIRECT); 
 
        DH_HRCHECK(hr, TEXT("AddStream")) ;
    } 
    
    if(S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("VirtualStmNode::AddStream completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("VirtualStmNode::AddStream couldn't complete successfully.\n")));
    }
 
    // i:  Renames the newly created storage from NewTestStg to NewRenStg

    LPCWSTR         pRenStgName     = L"RenStg";

    // First close the opened storage that we want to rename

    if (S_OK == hr)
    {
        hr = pvcnNewStorage->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if(S_OK == hr)
    {
        hr = pvcnNewStorage->Rename(pRenStgName); 
    }
 
    if(S_OK == hr)
    {
        DH_LOG((
            LOG_PASS, 
            TEXT("IStorage::RenameElement completed successfully.\n")));
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("IStorage::RenameElement couldn't complete successfully.\n")));
    }
 
    // Final Cleanup

    if(NULL != pTestChanceDF)
    {
        hr = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());    

        DH_HRCHECK(hr, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    if(NULL != pTestVirtualDF)
    {    
        hr = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);    

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Uninitialize OLE
        
    CoUninitialize();

    // Log test results and quit

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("Test program executed successfully.\n")));
        exit(0);
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("Test program execution failed.\n")));
        exit(1);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\filebyts\ilkbdf.cxx ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//  All rights reserved.
//
//  File:       ilkbdf.cxx
//
//  Contents:   Implementation for docfile based on ILockBytes class.
//
//  Classes:    ilkbdf.cxx 
//
//  Functions:  GenerateVirtualDF 
//              GenerateVirtualDFRoot 
//
//  History:    3-Aug-96    Narindk     Created 
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include "ilkbhdr.hxx"

//----------------------------------------------------------------------------
//  Member:     GenerateVirtualDF
//
//  Synopsis:   Creates a DocFile based on ILockBytes, size of which is
//              based on the ChanceDocFile created prior to this.
//
//  Arguments:  [pChanceDF] - Pointer to ChanceDocFile tree 
//              [ppDocRoot] - Returned root of DocFile tree
//
//  Returns:    HRESULT 
//
//  History:    Narindk   31-July-96   Created
//
//  Notes:      This function differs fro base class GenerateVirtualDF in
//              the way that it creates a ILockBytes instance and then call
//              GenerateVirtualDFRoot on that custom ILockBytes instance.
// 
//              This function calls GenerateVirtualDFRoot to generate docfile 
//              tree's root and GrowDFTree to generate rest of the
//              tree. If the function succeeds, it returns pointer to root
//              of DocFile generated in ppDocRoot parameter.
//              - Get seed from ChanceDocFile tree and construct DG_INTEGER &
//                DG_UNICODE objects.
//              - Get the modes for creating various storages/streams from thw
//                ChanceDocFile tree.
//              - Get name of rootdocfile, if given, from chancedocfile tree, 
//                else generate a random docfile name.
//              - Create an instance of custom ILockBytes and initialize the
//                same.
//              - Call GenerateDFRoot passing it also the custom ILOckBytes
//                generated above 
//              - Call GrowDFTree
//              - If successful, assign root of new DF in *ppDocRoot. 
//---------------------------------------------------------------------------

HRESULT ILockBytesDF::GenerateVirtualDF(
    ChanceDF        *pChanceDF, 
    VirtualCtrNode  **ppvcnRoot)
{
    HRESULT             hr                  =   S_OK;
    LPTSTR              ptszName            =   NULL;
    CFileBytes          *pCFileBytes        =   NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("GenerateILockBytesDF"));

    DH_VDATEPTRIN(pChanceDF, ChanceDF) ;

    DH_ASSERT(NULL != pChanceDF);
    DH_ASSERT(NULL != ppvcnRoot);

    if(S_OK == hr)
    {
        *ppvcnRoot = NULL;

        // Create a DataGen obj of type DG_INTEGER that will allow us to fill 
        // count parameters of DocFile tree components, excepting those 
        // which we got from already created ChanceDocFile tree.  Use the
        // same seed value as was used in creation of ChanceDocFile tree.
  
        // Get the value of seed used to create ChanceDocFile tree and store it.

        _ulSeed = pChanceDF->GetSeed();
 
        _pdgi = new(NullOnFail) DG_INTEGER(_ulSeed);

        if (NULL == _pdgi)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.

        _pgdu = new(NullOnFail) DG_STRING(_ulSeed);

        if (NULL == _pgdu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Get the value of different creation modes.

        _dwRootMode = pChanceDF->GetRootMode();
        _dwStgMode  = pChanceDF->GetStgMode();
        _dwStmMode  = pChanceDF->GetStmMode();

        // Get user provided name for DocFile, if any

        ptszName = pChanceDF->GetDocFileName();

        if(NULL != ptszName)
        {
            _ptszName = new TCHAR[_tcslen(ptszName)+1];

            if (_ptszName == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                _tcscpy(_ptszName, ptszName);
            }
        }
        else
        {
            // Create a random file name for this root. 

            hr = GenerateRandomName(_pgdu, MINLENGTH, MAXLENGTH, &_ptszName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }
    }
 
    // Make new custom ILockBytes

    if (S_OK == hr)
    {
        pCFileBytes = new CFileBytes();

        if(NULL == pCFileBytes)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Initialize new custom ILockBytes
    
    if (S_OK == hr)
    {
        hr = pCFileBytes->Init(_ptszName, OF_CREATE|OF_READWRITE);

        DH_HRCHECK(hr, TEXT("CFileBytes::Init")) ;
    }

    if (S_OK == hr)
    {
        // Generates the root DocFile tree.

        hr = GenerateVirtualDFRoot(pChanceDF->GetChanceDFRoot(), pCFileBytes);

        DH_HRCHECK(hr, TEXT("GenerateDFRoot")) ;
    }

    if (S_OK == hr)
    {
        // Generate DF tree based on the ChanceDF tree.

        hr = GrowVirtualDFTree(pChanceDF->GetChanceDFRoot(), _pvcnRoot);

        DH_HRCHECK(hr, TEXT("GrowDFTree")) ;
    }

    // Fill the out parameter

    if(S_OK == hr)
    {
        _pCFileBytes = pCFileBytes;

        *ppvcnRoot = _pvcnRoot;
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Member:     ILockBytesDF::GenerateRoot, protected
//
//  Synopsis:   Creates the root stg for the DocFile
//
//  Arguments:  [pcnRoot] - Pointer to root of ChanceDocFile tree 
//              [pCFileBytes] - Pointer to custom ILockBytes
//
//  Returns:    HRESULT 
//
//  History:    Narindk   31-July-96   Created
//
//  Notes:      This function differs from base class's GenerateVirtualDF in
//              the way that it calls VirtualCtrNode's CreateRootOnCustomILock
//              Bytes method to generate the docfile, rather than CreateRoot.
//              Thereby the root docfile is created upon custom ILockBytes
//              rather than default OLE provided ILockBytes.
//
//              - Create VirtualCtrNode and Initialize it based on ChanceNode
//                data. 
//              - Create real IStorage corresponding to this node 
//              - Creates VirtualStmNodes/IStreams corresponding to this stg 
//                node, if required.
//---------------------------------------------------------------------------

HRESULT ILockBytesDF::GenerateVirtualDFRoot(
    ChanceNode  *pcnRoot, 
    CFileBytes  *pCFileBytes)
{
    HRESULT hr      =   S_OK;

    DH_VDATEPTRIN(pcnRoot, ChanceNode) ; 
    DH_VDATEPTRIN(pCFileBytes, CFileBytes) ;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("::GenerateDFRoot"));

    DH_ASSERT(NULL != pcnRoot);
    DH_ASSERT(NULL != pCFileBytes);
   
    // Generate VirtualCtrNode for the root node.

    if(S_OK == hr)
    {
        _pvcnRoot = new VirtualCtrNode();

        if (NULL == _pvcnRoot)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        hr = _pvcnRoot->Init(
                _ptszName,
                pcnRoot->GetChanceNodeStgCount(),
                pcnRoot->GetChanceNodeStmCount());

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Init")) ;
    }
 
    // Call StgCreateDocfileOnILockBytes to create a corresponding Root Storage
    // on disk.

    if(S_OK == hr)
    {
        hr = _pvcnRoot->CreateRootOnCustomILockBytes(
                _dwRootMode | STGM_CREATE,
                pCFileBytes);

        DH_HRCHECK(hr, TEXT("StgCreateDocfileOnILockBytes")) ;
    }

 
    if ((S_OK == hr) && (0 != pcnRoot->GetChanceNodeStmCount()))
    {
       hr = AppendVirtualStmNodesToVirtualCtrNode(
                pcnRoot->GetChanceNodeStmCount(),
                _pvcnRoot,
                pcnRoot->GetChanceNodeStmMinSize(),
                pcnRoot->GetChanceNodeStmMaxSize());

       DH_HRCHECK(hr, TEXT("AppendStmToStg")) ;

    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\filebyts\ilkbytes.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      ilbfile.cxx
//
//  Contents:  Implementation of CFileBytes class methods - derived from
//             ILockBytes class. 
//
//  Derivation: ILockBytes
//
//  Functions:
//
//  History:    06-Nov-92       AlexT     Created
//              30-July-1996    NarindK   Modified for stgbase tests.
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include "ilkbhdr.hxx"


//-------------------------------------------------------------------------
//
//  Member:     CFileBytes::CFileBytes, public
//
//  Synopsis:   constructor
//
//  Arguments:  none
//
//  Returns:    none 
//
//  History:    30-July-96  Narindk    Modified 
//
//  Notes:      Returns a fully initialized CFileBytes (ref count == 1)
//
//--------------------------------------------------------------------------

CFileBytes::CFileBytes(void):
    _hf(HFILE_ERROR),
    _ulRef(1),
    _cFail0(0),
    _cWrite0(0),
    _pszFileName(NULL)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::CFileBytes"));
}

//-------------------------------------------------------------------------
//
//  Member:     CFileBytes::~CFileBytes, public
//
//  Synopsis:   Destructor
//
//  Arguments:  none
//
//  Returns:    none 
//
//  History:    30-July-96  Narindk    Modified 
//
//  Notes:     
//
//--------------------------------------------------------------------------

CFileBytes::~CFileBytes(void)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::~CFileBytes"));

    // Clean up

    if(NULL != _pszFileName)
    {
        delete _pszFileName;
        _pszFileName = NULL;
    }
}

//-------------------------------------------------------------------------
//
//  Member:     CFileBytes::Init, public
//
//  Synopsis:   Initialize function 
//
//  Arguments:  [ptcPath] - Pointer to file name
//              [dwMode]  - Mode to access/create file 
//
//  Returns:    HRESULT 
//
//  History:    30-July-96  Narindk    Modified 
//
//  Notes:      
//
//--------------------------------------------------------------------------

HRESULT CFileBytes::Init(TCHAR *ptcPath, DWORD dwMode)
{
    HRESULT     hr              =   S_OK;
    LPSTR       pszFileName     =   NULL;
    int         bufferSize      =   0;
    OFSTRUCT    of;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CFileBytes::Init"));

    if(S_OK == hr)
    {
        _pszFileName = (CHAR *) new TCHAR[_tcslen(ptcPath) + 1 * sizeof(TCHAR)];
        if(NULL == _pszFileName)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Copy ptcPath to _pszFileName.  If NT, will need tp convert it to single 
    // byte.

    if(S_OK == hr)
    {
#if defined(_NT1X_) && !defined(_MAC)
        bufferSize = (_tcslen(ptcPath) + 1) * sizeof(TCHAR);

        if (0 == WideCharToMultiByte(
                    CP_ACP,
                    0,
                    ptcPath,
                    -1,
                    _pszFileName,
                    bufferSize,
                    NULL,
                    NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DH_HRCHECK(hr, TEXT("WideCharToMultiByte")) ;

            delete [] _pszFileName;
            _pszFileName = NULL;
        }
#else
        _tcscpy(_pszFileName, ptcPath);
#endif
    }

    if(S_OK == hr)
    {
         _hf = OpenFile(_pszFileName, &of, dwMode);

        if (HFILE_ERROR == _hf)
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

//-------------------------------------------------------------------------
//
//  Member:     CFileBytes::FailWrite0, public
//
//  Synopsis:   Function to simulate Write failure 
//
//  Arguments:  [cFail0] - failure value 
//
//  Returns:    HRESULT 
//
//  History:    30-July-96  Narindk    Modified 
//
//  Notes:    
//
//-------------------------------------------------------------------------

void CFileBytes::FailWrite0(int cFail0)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::FailWrite0"));

    _cWrite0 = 0;
    _cFail0 = cFail0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::QueryInterface, public
//
//  Synopsis:   Given a riid, returns associated interface 
//
//  Arguments:	[riid] - interface id
//		        [ppvObj] - place holder for interface
//
//  Returns:    Always fails
//
//  History:    30-July-96  Narindk    Modified 
//
//  Notes:      Not used in tests
//
//--------------------------------------------------------------------------

STDMETHODIMP CFileBytes::QueryInterface(
    REFIID      /* UNREF riid */, 
    LPVOID FAR  *ppvObj)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::QueryInterface"));

    *ppvObj = NULL;

    return STG_E_INVALIDFUNCTION;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::AddRef, public
//
//  Synopsis:	add reference
//
//  Arguments:  none
//
//  Returns:    ULONG post reference count
//
//  History:    30-July-96  Narindk    Modified 
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CFileBytes::AddRef(void)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::AddRef"));

    _ulRef++;

    DH_TRACE(
        (DH_LVL_ADDREL,
        TEXT("AddRef  - Object %lx, refs: %ld \n"),
        this, _ulRef));

    return _ulRef;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::Release, public
//
//  Synopsis:	release reference
//              closes file when reference count reaches zero
//
//  Arguments:  void
//
//  Returns:	ULONG post reference count
//
//  History:    30-July-96  Narindk    Modified 
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CFileBytes::Release(void)
{
    ULONG   ulTmp   =   0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::Release"));

    if ( _ulRef > 0 )
    {
        ulTmp = --_ulRef ;

        DH_TRACE(
            (DH_LVL_ADDREL,
            TEXT("Release - Object %lx, refs: %ld \n"),
            this, _ulRef));

        if (0 == _ulRef)
        {
            if (HFILE_ERROR != _hf)
            {
                _lclose(_hf);
            }

            DH_TRACE(
                (DH_LVL_ADDREL,
                TEXT("Release - Deleting Object %lx"), this));

            delete this;
        }
    }
    else
    {
        DH_ASSERT(!"Release() called on pointer with 0 refs!") ;

        ulTmp = 0 ;
    }

    return ulTmp;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::ReadAt
//
//  Synopsis:   Reads bytes from file
//
//  Arguments:  [ulOffset] - byte offset
//		        [pv]       - input buffer
//		        [cb]       - count of bytes to read
//		        [pcbRead]  - count of bytes read
//
//  Returns:    HRESULT 
//
//  History:    30-July-96  Narindk    Modified 
//
//--------------------------------------------------------------------------

STDMETHODIMP CFileBytes::ReadAt(
    ULARGE_INTEGER  uliOffset,
    VOID HUGEP      *pv,
    ULONG           cb,
    ULONG           *pcbRead)
{
    HRESULT hr      =   S_OK;
    LONG    lOffset =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CFileBytes::ReadAt"));

    DH_ASSERT(0 == ULIGetHigh(uliOffset));
    DH_ASSERT(HFILE_ERROR != _hf);

    if(S_OK == hr)
    {
        lOffset = (LONG) ULIGetLow(uliOffset);

        _llseek(_hf, lOffset, 0);

        *pcbRead = _hread(_hf, pv, cb);

        if (HFILE_ERROR == *pcbRead)
        {
            *pcbRead = 0;
            hr = STG_E_READFAULT;
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::WriteAt, public
//
//  Synopsis:	Writes bytes to file
//
//  Arguments:	[uliOffset]  - byte offset
//		        [pv]         - output buffer
//		        [cb]         - count of bytes to write
//		        [pcbWritten] - count of bytes written
//
//  Returns:    HRESULT	
//
//  History:    30-July-96  Narindk    Modified 
//
//  Notes:	This implementation doesn't write partial buffers.
//
//--------------------------------------------------------------------------

STDMETHODIMP  CFileBytes::WriteAt(
    ULARGE_INTEGER      uliOffset,
    VOID const HUGEP    *pv,
	ULONG               cb,
	ULONG FAR           *pcbWritten)
{
    HRESULT hr      =   S_OK;
    LONG    lOffset =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CFileBytes::WriteAt"));

    DH_ASSERT(0 == ULIGetHigh(uliOffset));
    DH_ASSERT(HFILE_ERROR != _hf);

    if(S_OK == hr)
    {
        lOffset = (LONG) ULIGetLow(uliOffset);

        if (0 == lOffset)
        {
            //  Check for simulated write failures
        
            if (_cFail0 > 0)
            {
                _cWrite0++;

                if (_cWrite0 == _cFail0)
                {
                    hr = STG_E_WRITEFAULT;
                }
            }
        }
    }

    if(S_OK == hr)
    {
        _llseek(_hf, lOffset, 0);
    
        *pcbWritten = _hwrite(_hf, (char *) pv, cb);

        if (HFILE_ERROR == *pcbWritten)
        {
            *pcbWritten = 0;
            hr = STG_E_WRITEFAULT;
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::Flush, public
//
//  Synopsis:	flushes file;  not implemented, always return S_OK
//
//  Effects:	none
//
//  Returns:    S_OK 
//
//  History:    30-July-96  Narindk    Modified 
//
//--------------------------------------------------------------------------

STDMETHODIMP CFileBytes::Flush(void)
{
    HRESULT hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CFileBytes::Flush"));

    DH_ASSERT(HFILE_ERROR != _hf);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::SetSize, public
//
//  Synopsis:	sets memory buffer size. May change buffer size
//
//  Arguments:	[ulicb] - new memory size
//
//  Returns:    HRESULT	
//
//  Algorithm:  realloc the buffer
//
//  History:    30-July-96  Narindk    Modified 
//
//--------------------------------------------------------------------------

STDMETHODIMP CFileBytes::SetSize(ULARGE_INTEGER ulicb)
{
    HRESULT hr      =   S_OK;
    BYTE    ch      =   0;
    ULONG   cb      =   0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CFileBytes::SetSize"));

    DH_ASSERT(0 == ULIGetHigh(ulicb));
    DH_ASSERT(HFILE_ERROR != _hf);

    if(S_OK == hr)
    {
        cb = ULIGetLow(ulicb);

        _llseek(_hf, cb, 0);
    
        _hwrite(_hf, (char *) &ch, 0);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::LockRegion, public
//
//  Synopsis:	not supported (intentionally)
//
//  Arguments:	[libOffset]  - lock range offset
//		        [cb]         - lock range size
//		        [dwLockType] - lock type
//
//  Returns:	STG_E_INVALIDFUNCTION
//
//  History:    30-July-96  Narindk    Modified 
//
//--------------------------------------------------------------------------

STDMETHODIMP CFileBytes::LockRegion(
    ULARGE_INTEGER  /* UNREF libOffset */,
    ULARGE_INTEGER  /* UNREF cb */,
    DWORD           /* UNREF dwLockType */)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::LockRegion"));

    DH_ASSERT(0 && !TEXT("Can't lock CFileBytes"));
    DH_ASSERT(HFILE_ERROR != _hf);

    return STG_E_INVALIDFUNCTION;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::UnLockRegion, public
//
//  Synopsis:	not supported (intentionally)
//
//  Arguments:	[libOffset]  - lock range offset
//		        [cb]         - lock range size
//		        [dwLockType] - lock type
//
//  Returns:	STG_E_INVALIDFUNCTION
//
//  History:    30-July-96  Narindk    Modified 
//
//--------------------------------------------------------------------------

STDMETHODIMP CFileBytes::UnlockRegion(
    ULARGE_INTEGER  /* UNREF libOffset */,
    ULARGE_INTEGER  /* cb */,
    DWORD           /* dwLockType */)
{
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::UnlockRegion"));

    DH_ASSERT(0 && !TEXT("Can't Unlock CFileBytes"));
    DH_ASSERT(HFILE_ERROR != _hf);

    return STG_E_INVALIDFUNCTION;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileBytes::Stat, public
//
//  Synopsis:	Provide instance information
//
//  Arguments:	[pstatstg]    - status buffer
//		        [grfStatFlag] - status flags
//
//  Returns:    HRESULT
//
//  History:    30-July-96  Narindk    Modified 
//
//  Notes:	    No time stamps.  Modifies pstatstg.
//
//--------------------------------------------------------------------------

STDMETHODIMP CFileBytes::Stat(STATSTG FAR *pstatstg, DWORD grfStatFlag)
{
    HRESULT             hr      =   S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CFileBytes::Stat"));

    DH_ASSERT(HFILE_ERROR != _hf);

    if(S_OK == hr)
    {
        memset(pstatstg, 0, sizeof(STATSTG));

        if (0 == (grfStatFlag & STATFLAG_NONAME))
        {
            // MakeUnicode String doesn't do any parameter validation, so use
            // it correctly.

#ifdef _MAC
            _tcscpy(pstatstg->pwcsName, _pszFileName);
#else
            hr = MakeUnicodeString(_pszFileName, &(pstatstg->pwcsName));
#endif

            DH_HRCHECK(hr, TEXT("TStrToWstr")) ;

            if (NULL == pstatstg->pwcsName)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if(S_OK == hr)
    {
        pstatstg->type = STGTY_LOCKBYTES;

        ULISet32(pstatstg->cbSize, _llseek(_hf, 0, 2));

        pstatstg->grfMode = STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE;
    }


    return hr;
}

//-------------------------------------------------------------------------
//
//  Member:     CFileBytes::GetSize, public
//
//  Synopsis:   Function to return size 
//
//  Arguments:  none 
//
//  Returns:    ULARGE_INTEGER 
//
//  History:    30-July-96  Narindk    Created 
//
//  Notes:    
//
//-------------------------------------------------------------------------

ULARGE_INTEGER CFileBytes::GetSize()
{
    HRESULT          hr =   S_OK;
    ULARGE_INTEGER   ulSize;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("CFileBytes::GetSize"));

    DH_ASSERT(HFILE_ERROR != _hf);

    ulSize.LowPart = GetFileSize((HANDLE) _hf, &(ulSize.HighPart));

    if(0xFFFFFFFF == ulSize.LowPart)
    {
       hr = HRESULT_FROM_WIN32(GetLastError());
        
       DH_HRCHECK(hr, TEXT("GetFileSize")) ;
    }

    DH_ASSERT(0xFFFFFFFF != ulSize.LowPart);

    return ulSize; 
}

//+-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\inc\getcli.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       getcli.h
//
//  Contents:   Get clients for a test
//
//  Functions:  GetClients
//
//  History:    02-Jun-97   MikeW       Created
//
//---------------------------------------------------------------------------

#ifndef _GETCLI_H_
#define _GETCLI_H_

#pragma once



//+--------------------------------------------------------------------------
//
//  Class:      ClientData
//
//  Synopsis:   Encapsulate data about each client (or peer) the host is
//              working with.
//
//  History:    02-Jun-97   MikeW   Created
//
//  Notes:      To allocate, call "p = new(x) ClientData" where x is the 
//              maximum number of clients.  To deallocate call "delete p"
//
//---------------------------------------------------------------------------
              
struct ClientData
{
    int     client_count;           // Number of clients

    struct PerClientData            // Info for each client
    {
        DWORD   context;            //    context (local, remote, etc)
        LPWSTR  machine_name;       //    machine name for remote clients
    }
    client[ANYSIZE_ARRAY];

    //
    // a ClientData is a variable sized structure.  Define some routines
    // to make using them easier.
    //

    HRESULT SetMachineName(UINT client, LPCWSTR machine_name);
    inline void * operator new(size_t /* UNREF bytes */, UINT client_count);
    inline void operator delete(void *_this);
};



//+--------------------------------------------------------------------------
//
//  Method:     ClientData::operator new
//
//  Synopsis:   Allocate the variable sized ClientData structure
//
//  Parameters: [client_count]      -- The number of clients
//
//  Returns:    A pointer to the storage for the new object
//
//  History:    02-Jun-97   MikeW   Created
//
//---------------------------------------------------------------------------

inline void * ClientData::operator new(
                                        size_t /* UNREF bytes */, 
                                        UINT   client_count)
{
    return new BYTE[sizeof(ClientData)
                    + sizeof(PerClientData)
                        * (client_count - ANYSIZE_ARRAY)
                    + (MAX_COMPUTERNAME_LENGTH + 1)
                        * client_count * sizeof(WCHAR)];
}



//+--------------------------------------------------------------------------
//
//  Method:     ClientData::operator delete
//
//  Synopsis:   De-allocate the variable sized ClientData structure
//
//  Parameters: [_this]         -- "this" pointer
//
//  Returns:    void
//
//  History:    02-Jun-97   MikeW   Created
//
//---------------------------------------------------------------------------

inline void ClientData::operator delete(void *_this)
{
    delete [] (BYTE *) _this;
}



//
// Functions to discover clients
//

HRESULT GetClients(
                ClientData    **pp_client_data, 
                DWORD           contexts,
                int             client_count,
                const GUID     &test_id = GUID_NULL,
                LPWSTR          test_description = NULL);

HRESULT GetRemoteClients(
                ClientData     *client_data, 
                const GUID     &test_id,
                LPWSTR          test_description);


#endif // _GETCLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\inc\debdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       debdlg.h
//
//  Contents:   ID definitions for controls in dialog box
//
//  Classes:
//
//  Functions:
//
//  History:    4-10-95   kennethm   Created
//
//--------------------------------------------------------------------------
#ifndef __DEBDLG_H__
#define __DEBDLG_H__

#include <winuser.h>

//
//  Externs
//

#define IDD_DEBUGDIALOG                 5270
#define IDC_ADDREL                      1001
#define IDC_TRACEFILELOC                1002
#define IDC_LOGFILELOC                  1003
#define IDC_POPUP                       1004
#define IDC_DEBUGTERM                   1005
#define IDC_TLDEBUGTERM                 1005
#define IDC_SPYWIN                      1006
#define IDC_TLSPYWIN                    1006
#define IDC_TRACEFILEBROWSE             1007
#define IDC_CONSOLE                     1008
#define IDC_TLCONSOLE                   1008
#define IDC_LOGFILE                     1009
#define IDC_TLLOGFILE                   1009
#define IDC_TRACELEVEL                  1010
#define IDC_INTERF                      1011
#define IDC_QI                          1012
#define IDC_LEVEL1                      1013
#define IDC_LEVEL2                      1014
#define IDC_SAVE                        1015
#define IDC_LOGFILEBROWS                1016
#define IDC_LEVEL3                      1017
#define IDC_LLDEBUGTERM                 1018
#define IDC_LLSPYWIN                    1019
#define IDC_LLCONSOLE                   1020
#define IDC_LLLOGFILE                   1021
#define IDC_FUNCOUT                     1022
#define IDC_FUNCIN                      1023
#define IDC_BREAK                       1024
#define IDC_VERBOSE                     1025
#define IDC_SPYWINDOWLOC                1026
#define IDC_LEVEL4                      1027
#define IDC_WARNING                     1028
#define IDC_STATIC                      -1

#endif // __DEBDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\stgutil\dumpcmd.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       dumpcmd.cpp
//
//  Contents:   dump commandline intelligently
//              
//  Functions:  
//
//  History:    07/29/97  SCousens     Created
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug  Object declaration
DH_DECLARE;


struct _options
{
    LPTSTR name;
    LPTSTR value;
};

#define CHSLASH TEXT('/')
#define CHDASH  TEXT('-')
#define SAFESTRING(a) a ? a : TEXT("")
#define ABORTIF(a,b) if (a) {hr = b; goto EndOfFunction;}

#define FindNextToken(ptr, tok) \
while (TEXT('\0') != *(ptr) && tok != (*(ptr))) ++(ptr);

inline LPTSTR StringToken (LPTSTR ptr, TCHAR tok) 
{
    FindNextToken (ptr, tok);
    if (tok == *ptr) *ptr = NULL;
    else if (TEXT('\0') == *ptr) ptr = NULL;
    return ptr;
}


CONST TCHAR chNull      = TEXT('\0');

CONST TCHAR szCmdLine[] = TEXT("CommandLine:");     // Used DumpCmdLine
CONST TCHAR szCmdLineFail[] = TEXT("CommandLineFail:"); // Used DumpCmdLine


//+-------------------------------------------------------------------
//  Member:     DumpCmdLine, public
//
//  Synopsis:   Gets the commandline via GetCommandLine, appends the    
//              given string to it (additional options to reproduce 
//              particular test), and calls TraceMsg to output it.
//              Depending on fResult, the key word 'CommandLine' or
//              'CommandLineFail' will be prepended.
//
//  Arguments:  [fResult]- Pass or fail (to choose keyword).
//              [pszFmt] - Trace message format string.
//              [...]    - Arguments for format string.
//
//  Returns:    Nothing.
//
//  History:    09-Oct-97  SCousens   Created
//--------------------------------------------------------------------
void DumpCmdLine (DWORD fResult, LPTSTR pszFmt, ...)
{
    va_list varArgs;
    LPCTSTR ptKeyWord, ptCmdLine;
    TCHAR   szBuffer[CCH_MAX_DBG_CHARS];
    LPTSTR  pRepro = NULL;

    // figure out what key word to use
    ptKeyWord = (LOG_FAIL == fResult) ? szCmdLineFail : szCmdLine;

    // set our buffer...if we are given something format it nicely
    if (NULL != pszFmt && TCHAR('\0') != *pszFmt)
    {
        // format what we are given in the way of text.
        va_start(varArgs, pszFmt);
        _vsntprintf(szBuffer, CCH_MAX_DBG_CHARS, pszFmt, varArgs);
        szBuffer[CCH_MAX_DBG_CHARS-1] = chNull;
        va_end(varArgs);
    }
    else
    {
        szBuffer[0] = TCHAR('\0');
    }

    // Get the CommandLine
    ptCmdLine = GetCommandLine();
    if (NULL == ptCmdLine)
    {
        ptCmdLine = TEXT("GetCmdLine Error");
    }

    // now merge the two intelligently. parameters override cmdline
    // and dump the commandline and whatever we were given.
    if (S_OK == MergeParams (ptCmdLine, szBuffer, &pRepro))
    {
        DH_TRACE ((DH_LVL_ALWAYS, TEXT("%s:%s"), ptKeyWord, pRepro)); 
        delete []pRepro;
    }
    else
    {
        DH_TRACE ((DH_LVL_ALWAYS, TEXT("%s:%s %s"), 
                ptKeyWord, ptCmdLine, szBuffer));
    }
    return;
}

//+-------------------------------------------------------------------
//  Member:     MergeParams, private
//
//  Synopsis:   Given two sets of parameters, merge the two into one
//              set, without duplication. Last one wins.
//              given
//                 program /foo /bar /seed:0 /foo:bar
//                 /seed:1234 /ms:rules
//              returns
//                 program /foo:bar /bar /seed:1234 /ms:rules
//
//  Arguments:  [cmdline]    - contents of GetCommandLine call.
//              [additional] - additional options.
//              [repro]      - pointer for resulting string
//
//  Returns:    HRESULT - S_OK or failure
//
//  History:    10-Nov-97  SCousens   Created
//
//  Notes:       Caller must call delete [] on returned buffer
//--------------------------------------------------------------------

HRESULT MergeParams (LPCTSTR ptCmdLine, LPCTSTR ptAdditional, LPTSTR *ptRepro)
{
    struct _options *pOptions;
    int       x, y, n, l;
    int       nParams  = 1;
    HRESULT   hr       = S_OK;
    LPTSTR    pname, pvalue, pnext, ptr;
    LPTSTR    name, value;
    LPTSTR    ptCmd    = NULL;

    //validate our inputs/outputs
    DH_VDATESTRINGPTR (ptCmdLine);
    if (ptAdditional)
        DH_VDATESTRINGPTR (ptAdditional);
    DH_VDATEPTROUT (ptRepro, LPTSTR);
    
    // copy the strings into one buffer, coz we are going to stomp on them
    // how much space do we need?
    l = _tcslen (ptCmdLine);
    if (ptAdditional)
        l += _tcslen (ptAdditional);

    //allocate a buffer
    ptCmd = new TCHAR[l + 2];
    ABORTIF (NULL == ptCmd, E_OUTOFMEMORY);
    memset (ptCmd, 0xFA, l+2); //BUGBUG do this to find why we died in 
                               //FindNextToken at one point. Seem to have
                               //had a non-terminated string for some reason.

    //cat the two strings into the allocd buffer
    l = _stprintf (ptCmd, TEXT("%s"), ptCmdLine);
    if (ptAdditional)
        _stprintf (&ptCmd[l], TEXT(" %s"), ptAdditional);

    // count # parameters (ie spaces) in CmdLine
    ptr = ptCmd;
    while (NULL != *ptr)
    {
        if (TEXT(' ') == *ptr++)
            nParams++;
    }
    DH_TRACE ((DH_LVL_TRACE4, TEXT("Found %d params"), nParams));

    // allocate an _options for each possible parameter
    pOptions = new struct _options[nParams];
    ABORTIF (NULL == pOptions, E_OUTOFMEMORY);

    // go through and setup each of the _options (cmdline and given)
    for (pnext = ptCmd, nParams=0, x=0; NULL != pnext; x++)
    {
        pname = pnext;
        pnext = StringToken (pname, TEXT(' '));  //strtok/strchr equivalent
        if (pnext && NULL == *pnext)  //safety check
            pnext++;

        //ignore emptys caused by extra spaces
        if (NULL == *pname)
            continue;

        //change '-' to '/' so we are uniform in our comparison
        if (CHDASH == *pname)
            *pname = CHSLASH;
        pvalue = StringToken (pname, TEXT(':'));

        //deal with option
        name = new TCHAR[_tcslen (pname)+1];
        ABORTIF (NULL == name, E_OUTOFMEMORY);
        _tcscpy (name, pname);

        // if there is a value, deal with that
        value = 0; 
        if (NULL != pvalue)
        {
            pvalue++;  //move past ':'
            value = new TCHAR[_tcslen (pvalue)+1];
            ABORTIF (NULL == value, E_OUTOFMEMORY);
            _tcscpy (value, pvalue);
        }

        //name is pointing to a string for name
        //value is pointing to a string for val, else null
        DH_TRACE ((DH_LVL_TRACE4, TEXT("Item[%d]: name:'%s': value:'%s'"), 
                nParams, name, value ? value : TEXT("null")));
        pOptions[nParams].name = name;
        pOptions[nParams].value = value;
        nParams++;
    }

    // Now go thru and make a repro line without dups.
    // last one wins.
    for (x=0, l=0; x<nParams; x++)
    {
        // if its been used, skip it
        if  (0 == pOptions[x].name[0])
            continue;

        n = x;
        // look for dups, and if we have a dup, use the second one
        for (y=x+1; y<nParams; y++)
        {
            // if its been canned, skip it
            if  (0 == pOptions[y].name[0])
                continue;
            if (!_tcsicmp (pOptions[n].name, pOptions[y].name))
            {
                pOptions[n].name[0] = 0; //mark 'old' option as used
                n = y; // This is the one we will use
            }
        }

        //now n is the last option
        //add option[n] to end of line
        if (x) //prepend space all except 1st
            l+=_stprintf (&ptCmd[l], TEXT(" ")); 
        l+=_stprintf (&ptCmd[l], TEXT("%s"), pOptions[n].name);
        if (NULL != pOptions[n].value) //add value if there is one
            l+=_stprintf (&ptCmd[l], TEXT(":%s"), pOptions[n].value);
        pOptions[n].name[0] = 0; //mark this option as used
    }
    DH_TRACE ((DH_LVL_TRACE4, TEXT("cmd:%s"), ptCmd));

    //now delete the _options we allocated
    for (x=0; x<nParams; x++)
    {
        delete []pOptions[x].name;
        delete []pOptions[x].value;
    }
    delete []pOptions;

    //give them what they really want
    *ptRepro = ptCmd;

EndOfFunction:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\inc\killwarn.h ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      killwarn.hxx
//
//  Contents:  Pragma's to kill specific warnings at W4
//
//  History:   28-Nov-94        DeanE   Created
//--------------------------------------------------------------------------
#ifndef __KILLWARN_HXX__
#define __KILLWARN_HXX__

//
//  Quotes taken from vc user's manual
//


// Turn off: unreferenced inline function has been removed
#pragma warning(disable: 4514)

// nonstandard extension used : nameless struct/union
//
// Microsoft C/C++ allows structure declarations to be specified without a
// declarator when they are members of another structure or union.
// The following is an example of this error:
//
// struct S
// {
//      float y;
//      struct
//      {
//          int a, b, c;  // warning
//      };
// } *p_s;
//
//
// This extension can prevent your code from being portable to other
// compilers and will generate an error under the /Za command-line option.
#pragma warning(disable: 4201)

// 'identifier' : inconsistent DLL linkage. dllexport assumed
//
// The specified member function was declared in a class with dllexport
// linkage, and then was imported. This warning can also be caused by
// declaring a member function in a class with dllimport linkage as neither
// imported nor static nor inline.
//
// The function was compiled as dllexport.
#pragma warning(disable: 4273)

// 'class' : assignment operator could not be generated
//
// The compiler was unable to generate a default constructor for the given
// class. No constructor was created.
//
// This warning can be caused by having an assignment operator for the
// base class that is not accessible by the derived class.
//
// This warning can be avoided by specifying a user-defined assignment
// operator for the class.
#pragma warning(disable: 4512)

// 'function': function not expanded
//
// The given function was selected for inline expansion but the compiler did 
// not perform the inlining.
#pragma warning(disable:4710)

// trigraph not being substituted
#pragma warning (disable: 4110)

#ifdef _MAC
// alignment of a memeber was sensitive to packing
#pragma warning (disable: 4121)
#endif // _MAC

// access-declarations are deprecated; member using-declarations provide 
// a better alternative
#pragma warning (disable: 4516)

#endif  // __KILLWARN_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\stgutil\convert.cxx ===
//+-------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994-1995.
//
//  File:       convert.cxx
//
//  Contents:   Conversion functions for various things.
//
//  Classes:
//
//  Functions:  TStrToWStr
//              WStrToTStr
//              MakeUnicodeString
//              MakeSingleByteString
//
//  History:    20-Feb-95       AlexE   Created
//              29-Jan-98       FarzanaR Ported from ctoleui tree
//---------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug  Object declaration
DH_DECLARE;

//+-------------------------------------------------------------------------
//
//  Function:   TStrToWStr
//
//  Synopsis:   Converts a TCHAR string to a WCHAR string
//
//  Arguments:  [pszSource] -- The string to convert, NULL is valid
//              [ppszDest]  -- The location to store the new string
//
//  Returns:    S_OK if the conversion was successful, another HRESULT
//              if it was not.
//
//  History:    4-20-95   kennethm   Created
//
//  Notes:      If unicode is defined this function allocates memory for
//              the new string and does a simple 'strcpy'.
//
//              If unicode is NOT defined, a CHAR to WCHAR conversion is
//              performed.
//
//              If *ppszDest is non NULL when this function returns, the
//              caller is responsible for freeing the memory allocated at
//              [*ppszDest]
//
//--------------------------------------------------------------------------

HRESULT TStrToWStr(LPCTSTR pszSource, LPWSTR *ppszDest)
{
    //
    //  Make sure the destination is a valid address
    //

    if (IsBadWritePtr(ppszDest, sizeof(ppszDest)))
    {
        DH_ASSERT(!"TStrToWStr(): Bad destination pointer");
        return E_INVALIDARG;
    }

    if (IsBadReadPtr(pszSource, sizeof(TCHAR)))
    {
        DH_ASSERT(!"TStrToWStr(): Bad source pointer");
        return E_INVALIDARG;
    }

    if ('\0' == *pszSource)
    {
        *ppszDest = NULL;
        DH_ASSERT(!"TStrToWStr(): Source string is empty");
        return E_INVALIDARG ;
    }

#ifdef UNICODE

    //
    //  If we're in a unicode world then this whole thing was in vain
    //  but we allocate memory and copy the string anyhow
    //

    *ppszDest = new WCHAR[lstrlen(pszSource) + 1];

    if (NULL == *ppszDest)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpy(*ppszDest, pszSource);

    return S_OK;

#else

    //
    //  Otherwise we do the conversion
    //

    return MakeUnicodeString(pszSource, ppszDest);

#endif
}



//+-------------------------------------------------------------------------
//
//  Function:   WStrToTStr
//
//  Synopsis:   Converts a WCHAR string into a TCHAR string
//
//  Arguments:  [pszSource] -- The string to convert, NULL is valid
//              [ppszDest]  -- The location to store the new string
//
//  Returns:    S_OK if the conversion was successful, another HRESULT
//              if not.
//
//  History:    12-May-1995   alexe   Created
//
//  Notes:      If unicode is defined this function allocates memory for
//              the new string and does a simple 'strcpy'.
//
//              If unicode is NOT defined, a WCHAR to CHAR conversion is
//              performed.
//
//              If *ppszDest is non NULL when this function returns, the
//              caller is responsible for freeing the memory allocated at
//              [*ppszDest]
//
//--------------------------------------------------------------------------

HRESULT WStrToTStr(LPCWSTR pszSource, LPTSTR *ppszDest)
{
    //
    //  Make sure the destination is a valid address
    //

    if (IsBadWritePtr(ppszDest, sizeof(ppszDest)))
    {
        DH_ASSERT(!"WStrToTStr(): Bad destination pointer");
        return E_INVALIDARG;
    }

    if (IsBadReadPtr(pszSource, sizeof(WCHAR)))
    {
        DH_ASSERT(!"WStrToTStr(): Bad source pointer");
        return E_INVALIDARG;
    }

    if ('\0' == *pszSource)
    {
        *ppszDest = NULL;
        DH_ASSERT(!"WStrToTStr(): Source string is empty");
        return E_INVALIDARG ;
    }


#ifdef UNICODE

    //
    //  If we're in a unicode world then this whole thing was in vain
    //  but we allocate memory and copy the string anyhow
    //

    *ppszDest = new WCHAR[lstrlen(pszSource) + 1];

    if (NULL == *ppszDest)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpy(*ppszDest, pszSource);

    return S_OK;

#else

    //
    //  Otherwise we do the conversion
    //

    return MakeSingleByteString(pszSource, ppszDest);

#endif
}



//+-------------------------------------------------------------------
//  Member:    MakeUnicodeString
//
//  Synopsis:  Converts an LPCSTR into an LPWSTR.  This function is
//             intended to be a helper function for other functions,
//             TStrToWStr() in particular, so it does NOT do any
//             parameter validation.
//
//  Arguments: [pszSource] - The string to convert.
//
//             [ppszDest] - A place to put pointer to new string.
//
//  Returns:   S_OK if all goes well, another HRESULT if not.
//
//  Remarks:   The user of this function is responsible for freeing
//             the memory allocated by this function using the
//             current 'delete' operator implementation.
//
//  History:   07-Mar-95   AlexE   Created
//             28-Mar-95   AlexE   Moved from strhelp.cxx
//--------------------------------------------------------------------

HRESULT MakeUnicodeString(LPCSTR pszSource, LPWSTR *ppszDest)
{
    HRESULT hr = S_OK ;
    INT nLen = 0 ;
    LPWSTR pszTmp = NULL ;

    //
    // Find the length of the string in UNICODE
    //

    SetLastError(0) ;

    nLen = MultiByteToWideChar(
               CP_ACP,
               0,
               pszSource,
               -1,
               NULL,
               0) ;

    DH_ASSERT(0 != nLen) ;

    pszTmp = new WCHAR [ nLen + 1 ] ;

    if (NULL == pszTmp)
    {
        hr = E_OUTOFMEMORY ;
    }

    if (S_OK == hr)
    {
        SetLastError(0) ;

        if (nLen != MultiByteToWideChar(
                       CP_ACP,
                       0,
                       pszSource,
                       -1,
                       pszTmp,
                       nLen))
        {
            hr = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_ASSERT(S_OK == hr) ;
        }
    }

    if (S_OK == hr)
    {
        *ppszDest = pszTmp ;
    }
    else
    {
        if (NULL != pszTmp)
        {
            delete pszTmp ;
        }
    }

    return hr ;
}



//+-------------------------------------------------------------------
//  Member:    MakeSingleByteString
//
//  Synopsis:  Converts an LPCWSTR into an LPSTR.  This function is
//             intended to be a helper function for other functions,
//             WStrToTStr() in particular, so it does NOT do any
//             parameter validation.
//
//  Arguments: [pszSource] - The string to convert.
//
//             [ppszDest] - A place to put pointer to new string.
//
//  Returns:   S_OK if all goes well, another HRESULT if not.
//
//  Remarks:   The user of this function is responsible for freeing
//             the memory allocated by this function using the
//             current 'delete' operator implementation.
//
//  History:   07-Mar-95   AlexE   Created
//             28-Mar-95   AlexE   Moved from strhelp.cxx
//--------------------------------------------------------------------

HRESULT MakeSingleByteString(LPCWSTR pszSource, LPSTR *ppszDest)
{
    HRESULT hr = S_OK ;
    INT nLen ;
    LPSTR pszTmp ;

    SetLastError(0) ;

    nLen = WideCharToMultiByte(
                CP_ACP,
                0,
                pszSource,
                -1,
                NULL,
                0,
                NULL,
                NULL) ;

     hr = HRESULT_FROM_WIN32(GetLastError()) ;

     pszTmp = new CHAR[ nLen + 1 ] ;

     if (NULL == pszTmp)
     {
         hr = E_OUTOFMEMORY ;
     }

     if (S_OK == hr)
     {
         SetLastError(0) ;

         if (nLen != WideCharToMultiByte(
                         CP_ACP,
                         0,
                         pszSource,
                         -1,
                         pszTmp,
                         nLen,
                         NULL,
                         NULL))
         {
             hr = HRESULT_FROM_WIN32(GetLastError()) ;

             DH_ASSERT(S_OK == hr) ;
         }
     }

     if (S_OK == hr)
     {
         *ppszDest = pszTmp ;
     }
     else
     {
         if (NULL != pszTmp)
         {
             delete pszTmp ;
         }
     }

     return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\stgutil\ntutil.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       ntutil.cpp
//
//  Contents:   Utility functions for NTFS drives.
//              These functions will probably not be 
//              available for Mac, Win9x, so should be
//              stubbed out in the header file as such.
//
//  Functions:  
//              ConversionVerification
//              VerifyNssfile
//
//  History:    01/19/98  SCousens     Created
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug  Object declaration
DH_DECLARE;

// Must be at least NT5 (not mac, not win9x, not nt4 etc) 
#if defined(_WIN32_WINNT) && (_WIN32_WINNT>=0x0500)

/*******************************************************************/
/*                                                                 */
/*    WARNING:                                                     */
/*      ConversionVerification, VerifyNssfile                      */
/*      must be the LAST functions in this file.                   */
/*      We redefine stuff that must not affect the rest            */
/*      of the functions.                                          */
/*      of the functions.                                          */
/*                                                                 */
/*******************************************************************/

#ifdef _HOOK_STGAPI_
#undef StgCreateDocfile
#undef StgOpenStorage
#endif  /* _HOOK_STGAPI_ */

//+-------------------------------------------------------------------------
//  Function:   ConversionVerification
//
//  Synopsis:   Opens a nssfile as docfile and then as nssfile
//              and calculates CRC each time. If CRC is different
//              then there is a problem with the conversion driver
//
//  Arguments:  [pFileName]   - Name of Docfile
//              [dwCRCexp]    - Expected CRC (default=0)
//
//  Returns:    S_OK if all went well and CRCs match
//              or E_FAIL if something else went wrong
//                 (CRCs dont match, ulRef not 0 after Release)
//
//  History:    28-Jan-97  SCousens    Created.
//
//  Notes:      - NSSFile must previously be closed, or access violations
//                may occur calculating CRC.
//--------------------------------------------------------------------------
HRESULT ConversionVerification (LPTSTR pFileName, DWORD dwCRCexp)
{
    DWORD dwCRCdf = 0, dwCRCnss = 0;
    IStorage *pIStorage;
    HRESULT hr = S_OK;
    ULONG ul;
    LPOLESTR        pOleStrTemp     =   NULL;
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("ConversionVerification"));
    DH_VDATESTRINGPTR (pFileName);

    // Convert TCHAR to OLECHAR
    hr = TStringToOleString(pFileName, &pOleStrTemp);
    DH_HRCHECK(hr, TEXT("TStringToOleString")) ;

    // Open as docfile, calc CRC for file and close it.
    if(S_OK == hr)
    {
        hr = StgOpenStorageEx (pOleStrTemp, 
                STGM_READ | STGM_SHARE_EXCLUSIVE,
                STGFMT_DOCFILE, 
                0, 
                NULL, 
                NULL,
                IID_IStorage, 
                (void**)&pIStorage);  
        DH_HRCHECK (hr, TEXT("Cnv:StgOpenStorageEx"));
        if (S_OK == hr)
        {
            hr = CalculateCRCForDocFile(pIStorage, 
                    VERIFY_INC_TOPSTG_NAME, 
                    &dwCRCdf);
            DH_HRCHECK (hr, TEXT("CalculateCRCForDocFile"));
        }

        if (S_OK != hr || 0 == dwCRCdf)
        {
            DH_LOG((LOG_INFO, TEXT("Cnv:CalculateCRCForDocFile on docfile failed, hr=0x%lx.\n"), hr));
        }
        if (NULL != pIStorage)
        {
            ul = pIStorage->Release ();
            DH_ASSERT (0 == ul);
            pIStorage = NULL;
        }
    }

    // Open normally (as nssfile), calc CRC for the file close it.
    if (S_OK == hr)
    {
        hr = StgOpenStorage (pOleStrTemp, 
                NULL, 
                STGM_READ | STGM_SHARE_EXCLUSIVE,
                NULL, 
                0, 
                &pIStorage);
        DH_HRCHECK (hr, TEXT("Cnv:StgOpenStorage"));
        if (S_OK == hr)
        {
            hr = CalculateCRCForDocFile(pIStorage, 
                    VERIFY_INC_TOPSTG_NAME, 
                    &dwCRCnss);
            DH_HRCHECK (hr, TEXT("CalculateCRCForDocFile"));
        }

        if (S_OK != hr || 0 == dwCRCnss)
        {
            DH_LOG((LOG_INFO, TEXT("Cnv:CalculateCRCForDocFile on nssfile failed, hr=0x%lx.\n"), hr));
        }

        if (NULL != pIStorage)
        {
            ul = pIStorage->Release ();
            DH_ASSERT (0 == ul);
            pIStorage = NULL;
        }
    }

    // spew
    if (S_OK == hr && 
            dwCRCnss == dwCRCdf && 
            0 != dwCRCdf &&
            (0 == dwCRCexp || dwCRCexp == dwCRCdf))
    {
        DH_LOG((LOG_INFO, TEXT("Conversion verification passed.\n")) );
    }
    else
    {
        hr = (S_OK != hr) ? hr : E_FAIL;  //set it only if not already set.
        DH_LOG((LOG_INFO, 
                TEXT("Conversion verification failed, hr=0x%lx.\n"), 
                hr) );
    }

    if (NULL != pOleStrTemp)
    {
        delete pOleStrTemp; 
        pOleStrTemp = NULL;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//  Function:   VerifyNssfile
//
//  Synopsis:   Verify an nssfile is indeed an nssfile by checking:
//              1. reparse point is set (spew if not)
//              2. header is valid (spew if df or unknown, and set hr)
//              Verify the reparse point is set. 
//              Open the file directly with REPARSE flag (to prevent cnss from
//              converting it). Read the header and make sure it looks like a
//              real nssfile by checking the file signatures.
//
//  Arguments:  [pszPathname] - full path to the file to be checked
//
//  Returns:    S_OK, else some sort of error.
//              We set the following if file is df or unknown
//                  ERROR_INVALID_DATA - if file is a DOCFILE
//                   13L - The data is invalid
//                  ERROR_FILE_INVALID - if file is UNKNOWN (not df or nss)
//                   1006L - The volume for a file has been externally 
//                   altered so that the opened file is no longer valid
//                  ERROR_INVALID_EA_NAME - no reparse point (if others valid)
//                   254L - The specified extended attribute name was invalid.
//
//  History:    24-Jul-97  SCousens    Created.
//
//  Notes:      - NSSFile must previously be closed, or file share 
//                access violations may occur reading the header.
//--------------------------------------------------------------------------

#define  NSSFILE_SIGNATURE    0x444D4F30
#define  DOCFILE_SIGNATURE1   0xE011CFD0   //0xD0CF11E0 little endian
#define  DOCFILE_SIGNATURE2   0xE11AB1A1   //0xA1B11AE1 little endian

HRESULT VerifyNssfile (LPTSTR pszPathname)
{
    HRESULT hr  = S_OK;
    HANDLE  hnd;
    ULONG   culRead;
    ULONG   ulAttr;
    struct  _structFileHeader {
        ULONG ulSig1;
        ULONG ulSig2;
        } sFileHeader;
         
    DH_FUNCENTRY (&hr, DH_LVL_DFLIB, TEXT("VerifyNssfile"));

    /* check the file attributes and look for reparse attribute */
    ulAttr = GetFileAttributes (pszPathname);
    DH_TRACE ((DH_LVL_DFLIB, 
            TEXT("VerifyNssfile; Attributes retrieved:%#lx"), 
            ulAttr));
    if ((ULONG)-1 == ulAttr)
    {
        DH_TRACE ((DH_LVL_ERROR, 
                TEXT("VerifyNssfile; Unable to get attributes for %s"), 
                pszPathname));
        hr = HRESULT_FROM_WIN32(GetLastError());
        DH_HRCHECK (hr, TEXT("GetFileAttributes"));
        return hr;
    }
     
    /* attempt to open the file */
    hnd = CreateFile(pszPathname,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,           // security descriptor 
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OPEN_REPARSE_POINT,
            NULL);          //hTemplateFile
    if (INVALID_HANDLE_VALUE == hnd)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    DH_HRCHECK (hr, TEXT("CreateFile"));
    
    /* if we succeeded, read the header */
    if (S_OK == hr)
    {
        BOOL fErr;
        fErr = ReadFile (hnd, &sFileHeader, sizeof (sFileHeader), &culRead, NULL);
        if (FALSE == fErr)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        DH_HRCHECK (hr, TEXT("ReadFile"));
        DH_TRACE ((DH_LVL_DFLIB, TEXT("Read %ld bytes from file"), culRead));
    }

    /* check the header looks like an nss header */
    if (S_OK == hr)
    {
        if (sFileHeader.ulSig1 != NSSFILE_SIGNATURE)
        {
            if (sFileHeader.ulSig1 == DOCFILE_SIGNATURE1 && 
                    sFileHeader.ulSig2 == DOCFILE_SIGNATURE2)
            {
                hr =  ERROR_INVALID_DATA;
                DH_TRACE ((DH_LVL_TRACE1, TEXT("WARNING!!! VerifyNssfile; File appears to be a DOCFILE")));
            }
            else
            {
                hr = ERROR_FILE_INVALID;
                DH_TRACE ((DH_LVL_TRACE1, TEXT("WARNING!!! VerifyNssfile; File is INVALID nssfile or docfile!")));
            }
        }
        else
        {
            DH_TRACE ((DH_LVL_DFLIB, TEXT("VerifyNssfile; File appears to be valid nssfile")));
        }
    }

    // If nssfile, but no reparse point, its still not valid!
    // It is impossible to have an nssfile with a reparse
    // point on an NTFS4 volume. 
    // It is impossible to have an nssfile on a FAT volume.
    if (0 == (FILE_ATTRIBUTE_REPARSE_POINT & ulAttr))
    {
        DH_TRACE ((DH_LVL_TRACE1, 
                TEXT("WARNING!!! VerifyNssfile; File *NOT* have reparse point set!")));
        if (S_OK == hr)
        {
            hr = ERROR_INVALID_EA_NAME;
        }
    }

    // close the file
    if (INVALID_HANDLE_VALUE != hnd)
    {
        HRESULT hr2 = S_OK;
        if (FALSE == CloseHandle(hnd))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError());
        }
        DH_HRCHECK (hr2, TEXT("CloseHandle"));
    }

    // if there is a problem, say what file caused it.
    if (S_OK != hr)
    {
        DH_TRACE ((DH_LVL_TRACE1, 
                TEXT("WARNING!!! File causing problem: %s"), 
                pszPathname));
    }

    return hr;
}
        
/*******************************************************************/
/*                                                                 */
/*    WARNING:                                                     */
/*      ConversionVerification, VerifyNssfile                      */
/*      must be the LAST function in this file.                    */
/*      We redefine stuff that must not affect the rest            */
/*      of the functions.                                          */
/*                                                                 */
/*******************************************************************/

#endif // WINNT5+
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\stgutil\miscutil.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       miscutil.cpp
//
//  Contents:   General utility functions for storage
//              VerifyResult
//		RunningDebugOle
//		WaitForObjectsAndProcessMessages 	 
//              Hex
//              EnumLocalDrives
//
//  Functions:  
//
//  History:    07/29/97  SCousens     Created
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

// Debug  Object declaration
DH_DECLARE;

//+-------------------------------------------------------------------------
//
//  Function:   VerifyResult
//
//  Synopsis:   Check to see if a HRESULT has the expected value
//
//  Parameters: [hrCheck]       -- the HRESULT to check
//              [hrExpected]    -- the HRESULT expected
//
//  Returns:    S_OK if the HRESULT's match.  If they don't match and the
//              and the actual result was a failure, then that result is 
//              returned (preserving the original failure).  Otherwise 
//              E_FAIL is returned.
//
//  History:    28-Jun-95   MikeW   Created
//
//  Notes:      The main advantages of this routine over DH_HRCHECK is that
//              it puts out more diagnostic messages and that it's easier 
//              to verify values where hr != S_OK.
//
//--------------------------------------------------------------------------

HRESULT VerifyResult(HRESULT hrCheck, HRESULT hrExpected)
{
    HRESULT hr = S_OK;

    DH_FUNCENTRY(&hr, DH_LVL_TRACE2, TEXT("VerifyResult"));

    hrCheck = FixHr (hrCheck);

    if (hrCheck != hrExpected)
    {
        DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("HRESULT == 0x%08x, expected 0x%08x"),
                hrCheck,
                hrExpected));

        if (FAILED(hrCheck))
        {
            hr = hrCheck;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}


//---------------------------------------------------------------------------
//
//  Method:     Hex
//
//  Synopsis:   Converts a hex char to integer
//
//  Parameters: [ch] -- character to convert
//
//  History:    03-Nov-97       BogdanT     Created
//
//  Comments:   This function asserts if the character is passing chars
//              outside the hexadecimal range
//
//---------------------------------------------------------------------------
UINT Hex(CHAR ch)
{
    if('0'<=ch && ch<='9')
        return ch-'0';
    if('a'<=ch && ch<='f')
        return 10+ch-'a';
    if('A'<=ch && ch<='F')
        return 10+ch-'A';

    DH_ASSERT(!TEXT("Non hexadecimal char passed to Hex()"));
    return '\0';
}

//////////////////////////////////////////////////////////////
//
// Function: EnumLocalDrives
//
// Synopsis: Enumerates all local drives (except A:, B:)
//           and returns a 32bit drive mask to show 
//           availablity of FIXED, REMOVABLE, RAM disks.
//           
// Return  : ULONG bitmask
// NOTES:
//           return value: bit set drive present.
//           A:=bit 0, B:=bit 1, C:=bit 2 D:=bit 3.
//           bits 0,1 always off (ignore A:, B:)
//
// History:  10-Oct-97   scousens     created.
//
//////////////////////////////////////////////////////////////

ULONG EnumLocalDrives()
{
#ifdef _MAC
    return 0L;
#else  
    ULONG  ulMask, ulMap = 0L;    
    TCHAR  szDrive[3]    = {TEXT("C:")};

    ulMap = 0L;                // We don't have A:, B:
    ulMask = 0x04L ;
    do
    {
        switch (GetDriveType(szDrive))
        {
            case DRIVE_FIXED :      //The disk cannot be removed from the drive. 
            case DRIVE_RAMDISK :    //The drive is a RAM disk. 
            case DRIVE_REMOVABLE :  //The disk can be removed from the drive. 
                ulMap |= ulMask;
                break;
 
            //case DRIVE_UNKNOWN :        //The drive type cannot be determined. 
            //case DRIVE_NO_ROOT_DIR :    //The root directory does not exist. 
            //case DRIVE_REMOTE :         //The drive is a remote (network) drive. 
            //case DRIVE_CDROM :          //The drive is a CD-ROM drive. 
            default:
                break;
        }

        ulMask <<= 1;
        ++*szDrive;
    } while (*szDrive <= TCHAR('Z'));
    return (ulMap);
#endif //_MAC
}

//+-------------------------------------------------------------------
//
//  Function:   WaitForObjectsAndProcessMessages
//
//  Synopsis:   Processes windows messages for all windows on the
//              current thread and waits for provided events to be
//              signalled.
//
//  Arguments:  [pHandles] - A pointer to an array of handles to wait
//                           on.  These handles must be Windows thread
//                           synchronization objects.
//
//              [dwCount] - The count of handles in [pHandles]
//
//              [fWaitAll] - TRUE to wait for all objects in [pHandles];
//                           FALSE to wait for only one.
//
//              [dwMilliSeconds] - Milliseconds to wait;  can be INFINITE
//
//  Returns:    The return value from MsgWaitForMultipleObjects()
//
//  History:    18-Sept-1995   AlexE   Created
//
//--------------------------------------------------------------------

DWORD WaitForObjectsAndProcessMessages(
    LPHANDLE pHandles,
    DWORD dwCount,
    BOOL fWaitAll,
    DWORD dwMilliSeconds)
{
    MSG msg ;
    DWORD dwWaitResult ;
    BOOL  fGotQuitMessage = FALSE ;
    int   nQuitExitCode = 0;


    for (;;)
    {
        //
        // Wait on supplied events; only wake up if we need
        // to process a message - we force QS_ALLINPUT here
        // to make sure that ALL windows on this thread have
        // their messages processed.
        //

        dwWaitResult = MsgWaitForMultipleObjects(
                           dwCount,
                           pHandles,
                           fWaitAll,
                           dwMilliSeconds,
                           QS_ALLINPUT) ;

        //
        // If one or all of our objects has become signalled,
        // return the value to the caller
        //

        if ( (dwWaitResult < (WAIT_OBJECT_0 + dwCount)) &&
             (dwWaitResult >= WAIT_OBJECT_0) )
        {
            break ;
        }

        //
        // If a message is in the queue, wake up, process the
        // message, and call MsgWaitForMultipleObjects() again.
        //

        else if ( (WAIT_OBJECT_0 + dwCount) == dwWaitResult)
        {
            while (FALSE != PeekMessage(
                                &msg,
                                (HWND) 0,
                                0,
                                0,
                                PM_REMOVE))
            {
                if (WM_QUIT == msg.message)
                {
                    DH_ASSERT(FALSE == fGotQuitMessage) ;

                    fGotQuitMessage = TRUE ;
                    nQuitExitCode = (int) msg.wParam ;
                }
                else
                {
                    TranslateMessage(&msg) ;
                    DispatchMessage(&msg) ;
                }
            }
        }

        //
        // Else, some unusual situation has occurred; we
        // can just assert in this case and break out of
        // the loop
        //

        else
        {
            DH_ASSERT(!"MsgWaitForMultipleObjects() error") ;

            break ;
        }
    }

    //
    // If we got a WM_QUIT while waiting for the event re-post it now
    //

    if (fGotQuitMessage)
    {
        PostQuitMessage(nQuitExitCode);
    }

    return dwWaitResult ;
}

//+-------------------------------------------------------------------------
//
//  Function:   RunningDebugOle
//
//  Synopsis:   Determines if were running under debug Ole
//
//  Parameters: None
//
//  Returns:    S_OK                                    -- Debug Ole
//              S_FALSE                                 -- Retail Ole
//              HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND) -- Ole is not loaded
//
//  Algorithm:  Since there's no official way to tell if were running debug
//              Ole or not, we have to fall back to checking for debug-only
//              exports - we use "DumpATOM" here.
//
//  History:    13-Nov-95   MikeW   Created
//
//---------------------------------------------------------------------------

HRESULT RunningDebugOle()
{
    HMODULE     hModOle;

    hModOle = GetModuleHandle(TEXT("OLE32"));

    if (NULL == hModOle)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (NULL == GetProcAddress(hModOle, "DumpATOM"))
    {
        return S_FALSE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\testhelp\arghelp.cxx ===
//+-------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994-1995.
//
//  File:       arghelp.cxx
//
//  Contents:   Helper functions for manipulating & parsing command
//              line arguments (both Windows and Command Line styles).
//
//  Classes:    None
//
//  History:    22-Nov-94   DeanE   Created
//---------------------------------------------------------------------
#include <dfheader.hxx>
#pragma hdrstop

#ifdef _MAC
//
// On the mac, default to win95, since
// we're not going to do any tests that
// we don't do on win95
//
DWORD g_dwOperatingSystem = OS_WIN95 ;
#else //!_MAC
DWORD g_dwOperatingSystem = OS_NT ;
#endif //_MAC

#define CCH_MAX_MODULE_NAME     250

//+---------------------------------------------------------------------
//  Macro:      FindNextToken - looks for next non-space char and
//                              writes NILs over spaces it finds
//              FindNextSpace - looks for next space char
//              FindNextNil - looks for next NIl before tail, does a
//                            continue instead of a break at tail to
//                            allow loop to increment
//              FindNextNonNil - looks for next non-NIl before tail
//
//  Synopsis:   Helper macros for walking strings. Walks pointer to
//              desired point in string.
//
//  History:    28-Mar-94   DarrylA    Created.
//----------------------------------------------------------------------

#define FindNextToken(ptr) \
while('\0' != *(ptr)&&' '==(*(ptr))) { *(ptr) = '\0'; ++(ptr); } \
if('\0' == *(ptr)) break

#define FindNextSpace(ptr) \
while('\0' != *(ptr)&&' '!=(*(ptr))) ++(ptr); \
if('\0' == *(ptr)) break

#define FindNextNil(ptr, tail) \
while('\0' != *(ptr)&&(ptr)<(tail)) ++(ptr); \
if((tail) == (ptr)) continue

#define FindNextNonNil(ptr, tail) \
while('\0' == *(ptr)&&(ptr)<(tail)) ++(ptr); \
if((tail) == (ptr)) break


//+-------------------------------------------------------------------
//  Function:   CmdlineToArgs
//
//  Synopsis:   Turns the Windows-style Command Line passed into argc/
//              argv-style arguments.
//
//  Arguments:  [paszCmdline] - Windows-style ANSI command line.
//              [pargc]       - Pointer to resulting argc.
//              [pargv]       - Pointer to resulting argv.
//
//  Returns:    S_OK if no problems, error code otherwise.
//
//  History:    05-Apr-94   DarrylA     Created.
//              22-Nov-94   DeanE       Stolen from Marshal tests
//--------------------------------------------------------------------
HRESULT CmdlineToArgs(
        LPSTR     paszCmdline,
        PINT      pargc,
        CHAR   ***pargv)
{
//    DH_ASSERT(!IsBadWritePtr(pargc, sizeof(PINT)));
//    DH_ASSERT(!IsBadWritePtr(pargv, sizeof(CHAR ***)));

    int     cArgs      = 1;
    int     cchTemp    = 0;
    ULONG   cchCmdline = 0;
    CHAR  **ppArgs     = NULL;
    PCHAR   ptail      = NULL;
    LPSTR   aszCmdline = NULL;
    PCHAR   ptr        = NULL;

    // Copy command line string into an ANSI buffer
    cchCmdline = (ULONG) strlen(paszCmdline);
    aszCmdline = new(NullOnFail) CHAR[cchCmdline+1];
    if (aszCmdline == NULL)
    {
        return(E_OUTOFMEMORY);
    }
    strcpy(aszCmdline, paszCmdline);
    cchTemp = (int) cchCmdline;

    ptr = aszCmdline;

    // The command line is now in the ansi buffer.  Now we need to traverse
    // it and figure out the number of parameters.  While we walk over
    // spaces, we will replace them with '\0' so that afterwards, we just
    // dup each string into the new array.
    //
    while('\0' != *ptr)
    {
        FindNextToken(ptr);
        ++cArgs;
        FindNextSpace(ptr);
    }
    ptail = ptr;        // now points to NIL at end of string
    ptr   = aszCmdline;

    // Now we need to allocate space for the arguments
    ppArgs = new(NullOnFail) LPSTR[cArgs];
    if (NULL == ppArgs)
    {
        delete aszCmdline;
        return(E_OUTOFMEMORY);
    }

    BOOL fNewFail = FALSE;
    int  i = 0; // init to zero in case the strdup fails

    // Initialize ppArgs[0] with the module name
    ppArgs[0] = new(NullOnFail) CHAR[CCH_MAX_MODULE_NAME];
    if (NULL == ppArgs[0])
    {
        delete aszCmdline;
        delete ppArgs;
        return(E_OUTOFMEMORY);
    }
    
    char szTempModule[CCH_MAX_MODULE_NAME];
    short ret;

    cchTemp = (int) GetModuleFileNameA(NULL, szTempModule, CCH_MAX_MODULE_NAME);
    ret = GetFileTitleA(szTempModule, ppArgs[0], CCH_MAX_MODULE_NAME);
    if (ret != 0)
    {
        cchTemp = 0;
    }
    else
    {
        cchTemp = strlen(ppArgs[0]);
    }
    
    if ((cchTemp == 0) || (cchTemp == CCH_MAX_MODULE_NAME))
    {
        delete aszCmdline;
        delete ppArgs[0];
        delete ppArgs;
        return(E_FAIL);
    }

    // Now traverse the command line, plucking arguments and copying them
    // into the ppArgs array
    //
    for(i=1; i<cArgs; i++)
    {
        FindNextNonNil(ptr, ptail);
        ppArgs[i] = new(NullOnFail) CHAR[strlen(ptr)+1];
        if (NULL == ppArgs[i])
        {
            fNewFail = TRUE;
            break;
        }
        else
        {
            strcpy(ppArgs[i], ptr);
        }
        FindNextNil(ptr, ptail);
    }

    // Check for errors - clean up if we got one
    if (i != cArgs || TRUE == fNewFail)
    {
        for (int j=0; j<i; j++)
        {
            delete ppArgs[j];
        }

        delete aszCmdline;
        delete ppArgs;
        return(E_OUTOFMEMORY);
    }

    // Set up return parameters
    *pargc = cArgs;
    *pargv = ppArgs;

    // Clean up and exit
    delete aszCmdline;

    return(S_OK);
}



//+---------------------------------------------------------------------------
//
//  Function:   GetOSFromCmdline
//
//  Synopsis:   The operating system can be specified by putting /OS:<os> 
//              on the command line.  Check for it.
//
//  Parameters: [pCmdLine]              -- The command object for /OS
//
//  Returns:    OS_NT                   -- Running on NT
//              OS_WIN95                -- Running on Win95
//              OS_WIN95_DCOM           -- Running on Win95 + DCOM
//
//  History:    06-Jun-96   AlexE   Created
//
//----------------------------------------------------------------------------

DWORD GetOSFromCmdline(CBaseCmdlineObj *pCmdLine)
{
    //
    // If there is an OS specifier on the command line, set
    // the global variable g_dwOperatingSystem to the right
    // thing -- it is set to NT by default during compile time.
    //

    if (pCmdLine->IsFound())
    {
        if (0 == _olestricmp(pCmdLine->GetValue(), OS_STRING_WIN95))
        {
            g_dwOperatingSystem = OS_WIN95 ;
        }
        else if (0 == _olestricmp(pCmdLine->GetValue(), OS_STRING_WIN95DCOM))
        {
            g_dwOperatingSystem = OS_WIN95_DCOM ;
        }
    }

    return g_dwOperatingSystem ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\testhelp\cdbgdlg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       cdbgdlg.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-10-95   kennethm   Created
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop
#include <debdlg.h>

// BUGBUG:KILL this ARRAYSIZE DEF when its becomes globally available.
#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof (a)/sizeof (a[0]))
#endif

//+-------------------------------------------------------------------------
//
//  Function:   UpdateTraceLevels
//
//  Synopsis:
//
//  Arguments:  [hwndDlg]   --
//              [fTraceLvl] --
//
//  Returns:
//
//  History:    4-29-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CDebugHelp::UpdateTraceLevels(HWND hwndDlg, DWORD fTraceLvl)
{
    TCHAR     szTraceLvl[MAX_PATH];

    //
    //  Trace Level flags
    //

    CheckDlgButton(hwndDlg, IDC_ADDREL, (fTraceLvl & DH_LVL_ADDREL) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_QI,     (fTraceLvl & DH_LVL_QI) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_INTERF, (fTraceLvl & DH_LVL_INTERF) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_LEVEL1, (fTraceLvl & DH_LVL_TRACE1) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_LEVEL2, (fTraceLvl & DH_LVL_TRACE2) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_LEVEL3, (fTraceLvl & DH_LVL_TRACE3) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_LEVEL4, (fTraceLvl & DH_LVL_TRACE4) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_FUNCIN, (fTraceLvl & DH_LVL_ENTRY) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_FUNCOUT,(fTraceLvl & DH_LVL_EXIT) ? 1 : 0);

    //
    //  Set trace level text
    //

    wsprintf(szTraceLvl, TEXT("%#08lx"), fTraceLvl);

    SetDlgItemText(hwndDlg, IDC_TRACELEVEL, szTraceLvl);
}

//+-------------------------------------------------------------------------
//
//  Function:   UpdateLogLocations
//
//  Synopsis:
//
//  Arguments:  [hwndDlg] --
//              [fLogLoc] --
//
//  Returns:
//
//  History:    4-29-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CDebugHelp::UpdateLogLocations(HWND hwndDlg, DWORD fLogLoc)
{
    CheckDlgButton(hwndDlg, IDC_LLDEBUGTERM, (fLogLoc & DH_LOC_TERM) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_LLLOGFILE, (fLogLoc & DH_LOC_LOG) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_LLCONSOLE, (fLogLoc & DH_LOC_STDOUT) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_LLSPYWIN, (fLogLoc & DH_LOC_SPYWIN) ? 1 : 0);
}

//+-------------------------------------------------------------------------
//
//  Function:   UpdateTraceLocations
//
//  Synopsis:
//
//  Arguments:  [hwndDlg]   --
//              [fTraceLoc] --
//
//  Returns:
//
//  History:    4-29-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CDebugHelp::UpdateTraceLocations(HWND hwndDlg, DWORD fTraceLoc)
{
    CheckDlgButton(hwndDlg, IDC_TLDEBUGTERM, (fTraceLoc & DH_LOC_TERM) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_TLLOGFILE, (fTraceLoc & DH_LOC_LOG) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_TLCONSOLE, (fTraceLoc & DH_LOC_STDOUT) ? 1 : 0);
    CheckDlgButton(hwndDlg, IDC_TLSPYWIN, (fTraceLoc & DH_LOC_SPYWIN) ? 1 : 0);
}

//+-------------------------------------------------------------------------
//
//  Function:   UpdateTraceLevelFromText
//
//  Synopsis:
//
//  Arguments:  [hwndDlg]    --
//              [pfTraceLvl] --
//
//  Returns:
//
//  History:    4-29-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CDebugHelp::UpdateTraceLevelFromText(HWND hwndDlg, DWORD *pfTraceLvl)
{
    CHAR            szTraceLvl[MAX_PATH];

    GetDlgItemTextA(hwndDlg, IDC_TRACELEVEL, szTraceLvl, MAX_PATH);
    sscanf(szTraceLvl, "%lx", pfTraceLvl);
    *pfTraceLvl &= DH_LVL_OUTMASK;
    UpdateTraceLevels(hwndDlg, *pfTraceLvl);
}

//+-------------------------------------------------------------------------
//
//  Function:   DebugDialogProc
//
//  Synopsis:
//
//  Arguments:  [hwndDlg] --
//              [uMsg]    --
//              [wParam]  --
//              [lParam]  --
//
//  Returns:
//
//  History:    4-29-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CALLBACK CDebugHelp::OptionsDialogProc(
    HWND    hwndDlg,   // handle of dialog box
    UINT    uMsg,      // message
    WPARAM  wParam,    // first message parameter
    LPARAM  lParam)    // second message parameter
{
    static DWORD    fLabMode;
    static DWORD    fBreakMode;
    static DWORD    fVerbose;
    static DWORD    fTraceLoc;
    static DWORD    fTraceLvl;
    static DWORD    fLogLoc;
    DWORD           fLevelMask = 0;
    DWORD           fTraceLocMask = 0;
    DWORD           fLogLocMask = 0;
    CDebugHelp     *pdh = 0;

    // get or set the this pointer.
    if (WM_INITDIALOG == uMsg)
    {
        // this pointer comes in as lParam. Save it.
        SetWindowLong (hwndDlg, DWL_USER, lParam);
        pdh = (CDebugHelp*)lParam;
    }
    else
    {
        pdh = (CDebugHelp*)GetWindowLong (hwndDlg, DWL_USER);
    }

    // if we dont have one, bail.
    if (NULL == pdh)
    {
        return FALSE;
    }

    // message processor
    switch (uMsg)
    {
    case WM_INITDIALOG:

        //
        //  Initialize the controls
        //

        fLabMode  = pdh->_fMode&DH_LABMODE ? DH_LABMODE_ON : DH_LABMODE_OFF;
        fBreakMode= pdh->_fMode&DH_BREAKMODE ? DH_BREAKMODE_ON : DH_BREAKMODE_OFF;
        fVerbose  = pdh->_fMode&DH_VERBOSE ? DH_VERBOSE_ON : DH_VERBOSE_OFF;
        fTraceLoc = pdh->_fTraceLoc;
        fTraceLvl = pdh->_fTraceLvl;
        fLogLoc   = pdh->_fLogLoc;

        //
        //  modes
        //
        if (DH_LABMODE_OFF == fLabMode)
        {
            CheckDlgButton(hwndDlg, IDC_POPUP, TRUE);
        }
        if (DH_BREAKMODE_ON == fBreakMode)
        {
            CheckDlgButton(hwndDlg, IDC_BREAK, TRUE);
        }
        if (DH_VERBOSE_ON == fVerbose)
        {
            CheckDlgButton(hwndDlg, IDC_VERBOSE, TRUE);
        }

        //
        //  Trace location flags
        //

        pdh->UpdateTraceLocations(hwndDlg, fTraceLoc);

        //
        //  Log Location flags
        //

        pdh->UpdateLogLocations(hwndDlg, fLogLoc);

        //
        //  Trace level flags
        //

        pdh->UpdateTraceLevels(hwndDlg, fTraceLvl);

        // if no log object show the notification
        if (!pdh->_plog)
        {
            ShowWindow (GetDlgItem(hwndDlg, IDC_WARNING), SW_SHOW);
        }

        // display the spywindow class if there is one
        if (pdh->GetSpyWindowClass ())
        {
            SetDlgItemText (hwndDlg, IDC_SPYWINDOWLOC, pdh->GetSpyWindowClass ());
        }

        return TRUE;

    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDOK:
            // if log to file is set and we have a log file
            // create a log object
            if (fTraceLoc & DH_LOC_LOG || fLogLoc & DH_LOC_LOG)
            {
                CHAR    szLog[MAX_PATH] = {"/t:"};
                if (0 < GetDlgItemTextA (hwndDlg, 
                        IDC_LOGFILELOC, 
                        &szLog[3], 
                        sizeof (szLog) - 3))
                {
                    pdh->CreateLog (szLog);
                }
            }

            // if spywindow is set and we have a spy window class
            // set spy window class in debug object
            if (fTraceLoc & DH_LOC_SPYWIN || fLogLoc & DH_LOC_SPYWIN)
            {
                TCHAR    tszSpyWin[255] = {TEXT("")};
                if (0 < GetDlgItemText (hwndDlg, 
                        IDC_SPYWINDOWLOC, 
                        tszSpyWin, 
                        ARRAYSIZE (tszSpyWin)))
                {
                    pdh->SetSpyWindowClass (tszSpyWin);
                }
            }

            //
            //  The user pressed ok, save the settings
            //
            pdh->UpdateTraceLevelFromText(hwndDlg, &fTraceLvl);
            pdh->SetDebugInfo(
                            fLogLoc,
                            fTraceLoc,
                            fTraceLvl,
                            fLabMode | fBreakMode | fVerbose);

            if (IsDlgButtonChecked(hwndDlg, IDC_SAVE) == 1)
            {
                //
                //  Save the settings to the registry
                //
                pdh->WriteRegDbgInfo (DEFAULT_REG_LOC);
            }

            //
            //  Fall through
            //

        case IDCANCEL:
            EndDialog(hwndDlg, 0);
            return TRUE;

        // Popup and break are mutually exclusive. 
        // If one is turned on, turn other off.
        case IDC_POPUP:
            if (IsDlgButtonChecked(hwndDlg, wParam) == 1)
            {
                fLabMode = DH_LABMODE_OFF;
                fBreakMode = DH_BREAKMODE_OFF;
                CheckDlgButton (hwndDlg, IDC_BREAK, FALSE); //turn off Break.
            }
            else
            {
                fLabMode = DH_LABMODE_ON;
            }
            break;

        case IDC_BREAK:
            if (IsDlgButtonChecked(hwndDlg, wParam) == 1)
            {
                fBreakMode = DH_BREAKMODE_ON;
                fLabMode = DH_LABMODE_ON;
                CheckDlgButton (hwndDlg, IDC_POPUP, FALSE); //turn off Popup.
            }
            else
            {
                fBreakMode = DH_BREAKMODE_OFF;
            }
            break;

        case IDC_VERBOSE:
            if (IsDlgButtonChecked(hwndDlg, wParam) == 1)
            {
                fVerbose = DH_VERBOSE_ON;
            }
            else
            {
                fVerbose = DH_VERBOSE_OFF;
            }
            break;

        case IDC_TRACELEVEL:
            if (HIWORD(wParam) == EN_KILLFOCUS)
            {
                pdh->UpdateTraceLevelFromText(hwndDlg, &fTraceLvl);
            }
            break;

        case IDC_TLDEBUGTERM:
            fTraceLocMask = DH_LOC_TERM;
            break;
        case IDC_TLSPYWIN:
            fTraceLocMask = DH_LOC_SPYWIN;
            break;
        case IDC_TLCONSOLE:
            fTraceLocMask = DH_LOC_STDOUT;
            break;
        case IDC_TLLOGFILE:
            fTraceLocMask = DH_LOC_LOG;
            break;
        case IDC_LLDEBUGTERM:
            fLogLocMask = DH_LOC_TERM;
            break;
        case IDC_LLSPYWIN:
            fLogLocMask = DH_LOC_SPYWIN;
            break;
        case IDC_LLCONSOLE:
            fLogLocMask = DH_LOC_STDOUT;
            break;
        case IDC_LLLOGFILE:
            fLogLocMask = DH_LOC_LOG;
            break;
        case IDC_LEVEL1:
            fLevelMask = DH_LVL_TRACE1;
            break;
        case IDC_LEVEL2:
            fLevelMask = DH_LVL_TRACE2;
            break;
        case IDC_LEVEL3:
            fLevelMask = DH_LVL_TRACE3;
            break;
        case IDC_LEVEL4:
            fLevelMask = DH_LVL_TRACE4;
            break;
        case IDC_FUNCOUT:
            fLevelMask = DH_LVL_EXIT;
            break;
        case IDC_FUNCIN:
            fLevelMask = DH_LVL_ENTRY;
            break;
        case IDC_QI:
            fLevelMask = DH_LVL_QI;
            break;
        case IDC_ADDREL:
            fLevelMask = DH_LVL_ADDREL;
            break;
        case IDC_INTERF:
            fLevelMask = DH_LVL_INTERF;
            break;
        }

        //
        //  See if any of the mask have been changed.
        //  If one has been then update our local flag
        //

        if (fLevelMask != 0)
        {
            if (IsDlgButtonChecked(hwndDlg, LOWORD(wParam)) == 0)
            {
                fTraceLvl &= ~fLevelMask;
            }
            else
            {
                fTraceLvl |= fLevelMask;
            }
            pdh->UpdateTraceLevels(hwndDlg, fTraceLvl);
        }
        if (fLogLocMask != 0)
        {
            if (IsDlgButtonChecked(hwndDlg, LOWORD(wParam)) == 0)
            {
                fLogLoc &= ~fLogLocMask;
            }
            else
            {
                fLogLoc |= fLogLocMask;
            }
            pdh->UpdateTraceLevels(hwndDlg, fTraceLvl);
        }
        if (fTraceLocMask != 0)
        {
            if (IsDlgButtonChecked(hwndDlg, LOWORD(wParam)) == 0)
            {
                fTraceLoc &= ~fTraceLocMask;
            }
            else
            {
                fTraceLoc |= fTraceLocMask;
            }
            pdh->UpdateTraceLevels(hwndDlg, fTraceLvl);
        }

        break;
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   DebugOptionsDialog
//
//  Synopsis:
//
//  Arguments:  [hinstance] --
//              [hWnd]      --
//
//  Returns:
//
//  History:    4-29-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CDebugHelp::OptionsDialog(HINSTANCE hinstance, HWND hWnd)
{
    HRESULT hr = S_OK;
    int     iRet;

    iRet = DialogBoxParam(
                hinstance,
                MAKEINTRESOURCE(IDD_DEBUGDIALOG),
                hWnd,
                OptionsDialogProc,
                (long)this);

    if (iRet == -1)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\testhelp\creghelp.cxx ===
//+-------------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1993 - 1995.
//
//  File:       creghelp.cxx
//
//  Contents:   Implementaion of CRegistryHelp class object.
//
//  Classes:    CRegistryHelp
//
//  Functions:  CRegistryHelp::CRegistryHelp
//              CRegistryHelp::~CRegistryHelp
//              CRegistryHelp::GetValue
//              CRegistryHelp::GetValueDword
//              CRegistryHelp::GetValueString
//              CRegistryHelp::SetValue
//              CRegistryHelp::SetValueDword
//              CRegistryHelp::SetValueString
//              CRegistryHelp::DeleteValue
//              CRegistryHelp::DeleteSubKey
//
//  History:    03-Sep-93   XimingZ Created
//              23-Nov-94   DeanE   Modified for general use
//--------------------------------------------------------------------------
#include <dfheader.hxx>
#pragma hdrstop


//+-------------------------------------------------------------------------
//  Method:     CRegistryHelp::CRegistryHelp
//
//  Synopsis:   Constructor.
//
//  Arguments:  [hKey]      - Handle to the root key.
//              [pszSubKey] - Name of subkey.
//              [fOptions]  - Special options.
//              [samKey]    - Access desired.
//              [phr]       - Pointer to status code to be returned.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
CRegistryHelp::CRegistryHelp(
    HKEY     hKey,
    LPTSTR   pszSubKey,
    DWORD    fOptions,
    REGSAM   samKey,
    HRESULT *phr) :
        _hKey(NULL),
        _hSubKey(NULL),
        _pszSubKey(NULL),
        _fOptions(fOptions)
{
    DWORD dwDisposition;
    LONG  lRes;

    // Confirm subkey is valid and save it
    if (IsBadReadPtr(pszSubKey, sizeof(LPTSTR)))
    {
        *phr = E_POINTER;
        return;
    }
    _pszSubKey = new(NullOnFail) TCHAR[lstrlen(pszSubKey)+1];
    if (_pszSubKey == NULL)
    {
        *phr = E_OUTOFMEMORY;
        return;
    }
    lstrcpy(_pszSubKey, pszSubKey);

    // Save hKey
    if (hKey == NULL)
    {
        *phr = MAKE_TH_ERROR_CODE(E_HANDLE);
        return;
    }
    _hKey = hKey;

    // Open the subkey and save a handle to it
    lRes = RegCreateKeyEx(
            hKey,
            pszSubKey,
            0,
            NULL,
            fOptions,
            samKey,
            NULL,
            &_hSubKey,
            &dwDisposition);
    if (lRes != ERROR_SUCCESS)
    {
        *phr = MAKE_TH_ERROR_CODE(lRes);

        delete _pszSubKey;
        _hSubKey = NULL;
        _pszSubKey = NULL;
    }
    else
    {
        *phr = S_OK;
    }
}


//+-------------------------------------------------------------------------
//  Function:   CRegistryHelp::~CRegistryHelp
//
//  Synopsis:   Destructor.
//
//  Arguments:  None
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
CRegistryHelp::~CRegistryHelp()
{
    delete _pszSubKey;
    if (_hSubKey != NULL)
    {
        RegCloseKey(_hSubKey);
    }
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::GetValue
//
//  Synopsis:   Retrieves a value for some subkey and value name.
//
//  Arguments:  [pszSubKey] - Subkey the value is on.  NULL means _hSubKey.
//              [pszValue]  - Name of value to query.
//              [pbBuffer]  - Holds retrieved data.
//              [pcbBuffer] - Holds size of buffer on entry and actual size
//                            on exit (in bytes).
//              [pfType]    - Holds type of data retrieved.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::GetValue(
        LPTSTR  pszSubKey,
        LPTSTR  pszValue,
        LPBYTE  pbBuffer,
        LPDWORD pcbBuffer,
        LPDWORD pfType)
{
    HRESULT hr      = E_FAIL;
    HKEY    hSubKey = NULL;
    LONG    lRes;

    // Open the subkey, if necessary
    if (NULL == pszSubKey)
    {
        hSubKey = _hSubKey;
        hr = S_OK;
    }
    else
    {
        lRes = RegOpenKeyEx(_hSubKey, pszSubKey, NULL, KEY_READ, &hSubKey);
        hr = (lRes == ERROR_SUCCESS) ? S_OK : MAKE_TH_ERROR_CODE(lRes);
    }

    // Query for the data
    if (SUCCEEDED(hr))
    {
        lRes = RegQueryValueEx(
                  hSubKey,
                  pszValue,
                  NULL,
                  pfType,
                  pbBuffer,
                  pcbBuffer);
        hr = (lRes == ERROR_SUCCESS) ? S_OK : MAKE_TH_ERROR_CODE(lRes);
    }

    // Close the subkey handle, if we opened it
    if (hSubKey != _hSubKey)
    {
        RegCloseKey(hSubKey);
    }

    return(hr);
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::GetValueDword
//
//  Synopsis:   Retrieves a value for some subkey and value name that has
//              REG_DWORD, REG_DWORD_LITTLE_ENDIAN, or REG_DWORD_BIG_ENDIAN
//              data.  Other data types return an error.
//
//  Arguments:  [pszSubKey]      - Subkey the value is on.  NULL means
//                                 _hSubKey.
//              [pszValue]       - Name of value to query.
//              [pdwData]        - Holds retrieved data.
//              [fExpectedType]  - Holds expected type.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::GetValueDword(
        LPTSTR  pszSubKey,
        LPTSTR  pszValue,
        LPDWORD pdwData,
        DWORD   fExpectedType)
{
    HRESULT hr     = E_FAIL;
    DWORD   cbData = sizeof(DWORD);
    DWORD   fType;

    // Check fExpectedType is for a DWORD data type
    if ((fExpectedType != REG_DWORD) &&
        (fExpectedType != REG_DWORD_LITTLE_ENDIAN) &&
        (fExpectedType != REG_DWORD_BIG_ENDIAN))
    {
        return(MAKE_TH_ERROR_CODE(ERROR_INVALID_PARAMETER));
    }

    // Get the value
    hr = GetValue(pszSubKey, pszValue, (PBYTE)pdwData, &cbData, &fType);
    if (SUCCEEDED(hr))
    {
        if ((fType == fExpectedType) && (cbData == sizeof(DWORD)))
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::GetValueString
//
//  Synopsis:   Retrieves a value for some subkey and value name that has
//              REG_SZ, REG_EXPAND_SZ, and REG_MULTI_SZ type data.
//
//  Arguments:  [pszSubKey]      - Subkey the value is on.  NULL means
//                                 _hSubKey.
//              [pszValue]       - Name of value to query.
//              [pszData]        - Holds retrieved data.
//              [pcbData]        - Size of data buffer in bytes.
//              [fExpectedType]  - Holds expected type.
//
//  Returns:    S_OK for success or an error code.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::GetValueString(
        LPTSTR  pszSubKey,
        LPTSTR  pszValue,
        LPTSTR  pszData,
        LPDWORD pcbData,
        DWORD   fExpectedType)
{
    HRESULT hr     = E_FAIL;
    DWORD   fType;

    // Check fExpectedType is for a DWORD data type
    if ((fExpectedType != REG_SZ) &&
        (fExpectedType != REG_EXPAND_SZ) &&
        (fExpectedType != REG_MULTI_SZ))
    {
        return(MAKE_TH_ERROR_CODE(ERROR_INVALID_PARAMETER));
    }

    hr = GetValue(pszSubKey, pszValue, (PBYTE)pszData, pcbData, &fType);
    if (SUCCEEDED(hr))
    {
        if (fType == fExpectedType)
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::SetValue
//
//  Synopsis:   Stores a value for a given subkey and value name.  Subkey
//              is expected to exist.
//
//  Arguments:  [pszSubKey] - Subkey the value is on.  NULL means
//                            _hSubKey.
//              [pszValue]  - Name of value to set.
//              [pbData]    - Address of value data.
//              [cbData]    - Size of data.
//              [fType]     - Type of data.
//
//  Returns:    S_OK if value is set properly, error code if not.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::SetValue(
        LPTSTR   pszSubKey,
        LPTSTR   pszValue,
        LPBYTE   pbData,
        DWORD    cbData,
        DWORD    fType)
{
    HRESULT hr = E_FAIL;
    LONG    lRes;
    HKEY    hSubKey;

    // Open the subkey, if necessary
    if (pszSubKey == NULL)
    {
        hSubKey = _hSubKey;
        hr = S_OK;
    }
    else
    {
        lRes = RegOpenKeyEx(_hSubKey, pszSubKey, NULL, KEY_WRITE, &hSubKey);
        hr = (lRes == ERROR_SUCCESS) ? S_OK : MAKE_TH_ERROR_CODE(lRes);
    }

    // Set the data
    if (SUCCEEDED(hr))
    {
        lRes = RegSetValueEx(hSubKey, pszValue, 0, fType, pbData, cbData);
        hr = (lRes == ERROR_SUCCESS) ? S_OK : MAKE_TH_ERROR_CODE(lRes);
    }

    // Close the subkey handle, if we opened it
    if (hSubKey != _hSubKey)
    {
        RegCloseKey(hSubKey);
    }

    return(hr);
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::SetValueDword
//
//  Synopsis:   Stores a DWORD value for some subkey and value name under
//              this subkey.  Type flag passed must be REG_DWORD,
//              REG_DWORD_LITTLE_ENDIAN, or REG_DWORD_BIG_ENDIAN.
//
//  Arguments:  [pszSubKey] - Subkey the value is on.  NULL means _hSubKey.
//              [pszValue]  - Name of value to set.
//              [dwData]    - Data to set.
//              [fType]     - Type of data.
//
//  Returns:    S_OK if value is set properly, error code if not.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::SetValueDword(
        LPTSTR pszSubKey,
        LPTSTR pszValue,
        DWORD  dwData,
        DWORD  fType)
{
    HRESULT hr = E_FAIL;

    // Check fType is for a DWORD data type
    if ((fType != REG_DWORD) &&
        (fType != REG_DWORD_LITTLE_ENDIAN) &&
        (fType != REG_DWORD_BIG_ENDIAN))
    {
        return(MAKE_TH_ERROR_CODE(ERROR_INVALID_PARAMETER));
    }

    // Set the value
    hr = SetValue(
            pszSubKey,
            pszValue,
            (LPBYTE)&dwData,
            sizeof(DWORD),
            fType);

    return(hr);
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::SetValueString
//
//  Synopsis:   Stores a string value for some subkey and value name under
//              this subkey.  Type flag passed must be REG_SZ,
//              REG_EXPAND_SZ, or REG_MULTI_SZ.
//
//  Arguments:  [pszSubKey] - Subkey the value is on.  NULL means _hSubKey.
//              [pszValue]  - Name of value to set.
//              [pszData]   - Data to set.
//              [cbData]    - Size of data, in bytes.
//              [fType]     - Type of data.
//
//  Returns:    S_OK if value is set properly, error code if not.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::SetValueString(
        LPTSTR pszSubKey,
        LPTSTR pszValue,
        LPTSTR pszData,
        DWORD  cbData,
        DWORD  fType)
{
    HRESULT hr = E_FAIL;

    // Check fType is for a DWORD data type
    if ((fType != REG_SZ) &&
        (fType != REG_EXPAND_SZ) &&
        (fType != REG_MULTI_SZ))
    {
        return(MAKE_TH_ERROR_CODE(ERROR_INVALID_PARAMETER));
    }

    // Set the value
    hr = SetValue(
            pszSubKey,
            pszValue,
            (LPBYTE)pszData,
            cbData,
            fType);

    return(hr);
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::DeleteValue
//
//  Synopsis:   Delete a named value under a given subkey.
//
//  Arguments:  [pszSubKey] - Subkey the value is on.  NULL means _hSubKey.
//              [pszValue]   - Value to delete.
//
//  Returns:    S_OK if value deleted or is not there, error code if not
//              deleted.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::DeleteValue(LPTSTR pszSubKey, LPTSTR pszValue)
{
    HRESULT hr = E_FAIL;
    HKEY    hSubKey;
    LONG    lRes;

    // Open the subkey, if necessary
    if (pszSubKey == NULL)
    {
        hSubKey = _hSubKey;
    }
    else
    {
        lRes = RegOpenKeyEx(_hSubKey, pszSubKey, NULL, KEY_WRITE, &hSubKey);
        hr = (lRes == ERROR_SUCCESS) ? S_OK : MAKE_TH_ERROR_CODE(lRes);
    }

    // Delete the value
    if (SUCCEEDED(hr))
    {
        lRes = RegDeleteValue(hSubKey, pszValue);
        hr = (lRes == ERROR_SUCCESS) ? S_OK : MAKE_TH_ERROR_CODE(lRes);
    }

    // Close the subkey handle, if we opened it
    if (hSubKey != _hSubKey)
    {
        RegCloseKey(hSubKey);
    }

    return(hr);
}


//+-------------------------------------------------------------------------
//  Member:     CRegistryHelp::DeleteSubKey
//
//  Synopsis:   Delete the subkey passed under this subkey.
//
//  Arguments:  [pszSubKey] - Subkey to delete.  Must have no child
//                            subkeys.
//
//  Returns:    S_OK if value deleted or is not there, error code if not
//              deleted.
//
//  History:    20-Oct-93  XimingZ  Created
//--------------------------------------------------------------------------
HRESULT CRegistryHelp::DeleteSubKey(LPTSTR pszSubKey)
{
    LONG    lRes;
    HRESULT hr;

    if (IsBadReadPtr(pszSubKey, sizeof(LPTSTR)))
    {
        hr = MAKE_TH_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }
    else
    {
        lRes = RegDeleteKey(_hSubKey, pszSubKey);
        hr   = (lRes == ERROR_SUCCESS) ? S_OK : MAKE_TH_ERROR_CODE(lRes);
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\testhelp\cdbghelp.cxx ===
//+-------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994-1995.
//
//  File:       cdbghelp.cxx
//
//  Contents:   OLE Debug Helper Object
//
//  Classes:    CDebugHelper
//
//  History:    19-Nov-94   DeanE   Created
//---------------------------------------------------------------------
#include <dfheader.hxx>
#pragma hdrstop


// Global library character constants - note alphabetical order for
// easy reference
//
CONST TCHAR chBackSlash = TEXT('\\');
CONST TCHAR chEqual     = TEXT('=');
CONST TCHAR chNewLine   = TEXT('\n');
CONST TCHAR chNull      = TEXT('\0');
CONST TCHAR chPeriod    = TEXT('.');
CONST TCHAR chSpace     = TEXT(' ');
CONST TCHAR chTrace     = TEXT(' ');
CONST TCHAR chTraceErr  = TEXT('e');

// Global library string contants - note alphabetical order for
// easy reference
//
CONST TCHAR szCRLF[]    = TEXT("\r\n");
CONST TCHAR szError[]   = TEXT("ERROR "); // Used TraceMsg for ERRORs
CONST TCHAR szNewLine[] = TEXT("\n");
CONST TCHAR szNull[]    = TEXT("");
CONST TCHAR szPeriod[]  = TEXT(".");


// Test Result Description strings
//
LPCTSTR szPass    = TEXT("VAR_PASS");
LPCTSTR szFail    = TEXT("VAR_FAIL");
LPCTSTR szAbort   = TEXT("VAR_ABORT");
LPCTSTR szWarn    = TEXT("WARNING");
LPCTSTR szInfo    = TEXT("INFO");
LPCTSTR szInvalid = TEXT("INVALID!!");

// Debug Helper Usage String
//
LPTSTR gptszDebugHelperUsageString = {
TEXT("Debug Object Command line options:\r\n")
TEXT("   /logloc    - where log output goes (bitfield)\r\n")
TEXT("   /traceloc  - where trace output goes (bitfield)\r\n")
TEXT("   /tracelvl  - trace levels (bitfield)\r\n")
TEXT("   /spyclass  - spy window\r\n")
TEXT("   /labmode   - do not use PopUp for errors\r\n")
TEXT("   /breakmode - break on error\r\n")
TEXT("   /verbose   - trace hrchecks that are ok\r\n")
};

int giAlwaysNegativeOne = -1;

// Global variable, the THREAD_VALIDATE_FLAG_ON bit of which at present is 
// used to do or skip thread validation DH_VDATETHREAD macro.  Other bits 
// might be used in future. Initialize the variable to set its bit
// THREAD_VALIDATE_FLAG_ON. 

ULONG g_fThreadValidate = THREAD_VALIDATE_FLAG_ON ;

//+-------------------------------------------------------------------
//  Member:     CDebugHelp::CDebugHelp
//
//  Synopsis:   Initializes CDebugHelp object.  Makes object usable
//              in it's default state.
//
//  Arguments:  None.
//
//  Returns:    Nothing.  Constructor cannot fail.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
CDebugHelp::CDebugHelp() :
        _fLogLoc(DH_LOC_TERM),
        _fTraceLoc(DH_LOC_TERM),
        _fTraceLvl(DH_LVL_ALWAYS|DH_LVL_ERROR),
        _fMode(DH_LABMODE),
        _hrExpectedError(S_OK),
        _fCreatedLog(FALSE),
        _plog(NULL),
        _hwndAssert(NULL),
        _cPass(0),
        _cAbort(0),
        _cFail(0),
        _cIndentLevel(0),
        _fSpyWarning(0),  
        _pszSpyWindowClass((LPTSTR) SZ_DEFAULT_SPY_WINDOW_CLASS)
{
    DWORD cchModule;
    TCHAR szModule[CCH_MAX_MODULE];
    TCHAR szModule1[CCH_MAX_MODULE];
    short ret=0;

    lstrcpy(_szDbgPrefix, TEXT("NoName"));

    // Initialize the debug prefix string - it is the first
    // CCH_MAX_DBGPREFIX characters in the name of this
    // .exe, without the extension
    //
    
    cchModule = GetModuleFileName(NULL, szModule1, CCH_MAX_MODULE);

    if ((0 != cchModule) && (cchModule < CCH_MAX_MODULE))
    {
        ret = GetFileTitle(szModule1, szModule, sizeof(szModule));
    
        if (0 == ret)
        {
            //
            // Strip the .exe extension if it exists
            //

            cchModule = _tcslen(szModule);

            if (cchModule >= 4)     // if the name has at least 4 chars
            {
                if (0 == _tcsicmp(szModule + cchModule - 4, TEXT(".exe")))
                {
                    szModule[cchModule - 4] = TEXT('\0');
                }
            }

            //
            // Save the module name as the debug prefix
            //

            _tcscpy(_szDbgPrefix, szModule);
        }
    }
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::~CDebugHelp
//
//  Synopsis:   Releases resources associated with the CDebugHelp class.
//              Sets member variables so the basic functions can work.
//
//  Arguments:  None
//
//  Returns:    Nothing.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
CDebugHelp::~CDebugHelp()
{
    // Set all member variables to valid default values
    _fLogLoc   = DH_LOC_TERM;
    _fTraceLoc = DH_LOC_TERM;
    _fTraceLvl = DH_LVL_ALWAYS|DH_LVL_ERROR;
    _fMode     = DH_LABMODE;

    // Close the log by deleting the log object, if we created it
    if (_fCreatedLog)
    {
        delete _plog;
    }

    _plog = NULL;
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::GetRegDbgInfo
//
//  Synopsis:   Initializes CDebugHelp object from the registry.  Even
//              if errors occur, the object is left in the usable
//              default state.
//
//  Arguments:  [pszRegKey] - Registy key holding necessary values.
//
//  Returns:    S_OK if values read and settings are valid, an error
//              code if not.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
HRESULT CDebugHelp::GetRegDbgInfo(LPTSTR pszRegKey)
{
    CRegistryHelp *prhRegKey = NULL;
    HRESULT        hr        = E_FAIL;
    DWORD          fLabMode  = TRUE;
    DWORD          fBreakMode= FALSE;
    DWORD          fVerbose  = FALSE;

    // Open the registry key
    prhRegKey = new(NullOnFail) CRegistryHelp(
#ifndef _MAC
                                         HKEY_CURRENT_USER,
#else // _MAC
                                         HKEY_CLASSES_ROOT,
#endif // _MAC
                                         pszRegKey,
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_READ,
                                         &hr);
    if (prhRegKey == NULL)
    {
        hr = MAKE_TH_ERROR_CODE(E_OUTOFMEMORY);
    }

    if (FAILED(hr))
    {
        delete prhRegKey;
        return(hr);
    }


    // Note: From this point, error returns don't mean return an
    // error, but set the default and return
    //

    // Get Trace Location value
    hr = prhRegKey->GetValueDword(
                       NULL,
                       SZ_REG_TRACE_LOC,
                       &_fTraceLoc,
                       REG_DWORD);
    if (SUCCEEDED(hr))
    {
        _fTraceLoc = ValidateLoc(_fTraceLoc);
    }

    // Get Log Location value
    hr = prhRegKey->GetValueDword(
                       NULL,
                       SZ_REG_LOG_LOC,
                       &_fLogLoc,
                       REG_DWORD);
    if (SUCCEEDED(hr))
    {
        _fLogLoc = ValidateLoc(_fLogLoc);
    }

    // Get Trace Level
    hr = prhRegKey->GetValueDword(
                       NULL,
                       SZ_REG_TRACE_LVL,
                       &_fTraceLvl,
                       REG_DWORD);
    if (SUCCEEDED(hr))
    {
        _fTraceLvl = ValidateLvl(_fTraceLvl) | DH_LVL_ALWAYS | DH_LVL_ERROR;
    }

    // Get Mode
    hr = prhRegKey->GetValueDword(
                       NULL,
                       SZ_REG_LABMODE,
                       &fLabMode,
                       REG_DWORD);
    if (SUCCEEDED(hr) && fLabMode)
    {
        _fMode = DH_LABMODE;
    }

    hr = prhRegKey->GetValueDword(
                       NULL,
                       SZ_REG_BREAKMODE,
                       &fBreakMode,
                       REG_DWORD);
    if (SUCCEEDED(hr) && fBreakMode)
    {
        _fMode |= DH_BREAKMODE;
    }

    hr = prhRegKey->GetValueDword(
                       NULL,
                       SZ_REG_VERBOSE,
                       &fVerbose,
                       REG_DWORD);
    if (SUCCEEDED(hr) && fVerbose)
    {
        _fMode |= DH_VERBOSE;
    }

    _fMode = ValidateMode(_fMode);

    // Clean up and exit
    delete prhRegKey;

    hr = S_OK;

    return(hr);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::WriteRegDbgInfo
//
//  Synopsis:   Write the current state of the CDebugHelp object to
//              the registry.
//
//  Arguments:  [pszRegKey] - Registy key to write to.
//
//  Returns:    S_OK if values written, an error code if not.
//
//  History:    21-Apr-96   Kennethm   Created
//--------------------------------------------------------------------
HRESULT CDebugHelp::WriteRegDbgInfo(LPTSTR pszRegKey)
{
    CRegistryHelp *prhRegKey = NULL;
    HRESULT        hr        = E_FAIL;

    // Open the registry key
    prhRegKey = new(NullOnFail) CRegistryHelp(
#ifndef _MAC
                                         HKEY_CURRENT_USER,
#else // _MAC
                                         HKEY_CLASSES_ROOT,
#endif // _MAC
                                         pszRegKey,
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_WRITE,
                                         &hr);
    if (prhRegKey == NULL)
    {
        hr = MAKE_TH_ERROR_CODE(E_OUTOFMEMORY);
    }

    if (FAILED(hr))
    {
        delete prhRegKey;
        return(hr);
    }


    // Write Trace Location value
    hr = prhRegKey->SetValueDword(
                       NULL,
                       SZ_REG_TRACE_LOC,
                       _fTraceLoc,
                       REG_DWORD);
    if (SUCCEEDED(hr))
    {

    // Write Log Location value
    hr = prhRegKey->SetValueDword(
                       NULL,
                       SZ_REG_LOG_LOC,
                       _fLogLoc,
                       REG_DWORD);
    }
    if (SUCCEEDED(hr))
    {
    // Write Trace Level
    hr = prhRegKey->SetValueDword(
                       NULL,
                       SZ_REG_TRACE_LVL,
                       _fTraceLvl,
                       REG_DWORD);
    }
    if (SUCCEEDED(hr))
    {
    // Write Lab Mode
    hr = prhRegKey->SetValueDword(
                       NULL,
                       SZ_REG_LABMODE,
                       _fMode&DH_LABMODE ? TRUE : FALSE,
                       REG_DWORD);
    }
    if (SUCCEEDED(hr))
    {
    // Write Break Mode
    hr = prhRegKey->SetValueDword(
                       NULL,
                       SZ_REG_BREAKMODE,
                       _fMode&DH_BREAKMODE ? TRUE : FALSE,
                       REG_DWORD);
    }
    if (SUCCEEDED(hr))
    {
    // Write Verbose
    hr = prhRegKey->SetValueDword(
                       NULL,
                       SZ_REG_VERBOSE,
                       _fMode&DH_VERBOSE ? TRUE : FALSE,
                       REG_DWORD);
    }

    // Clean up and exit
    delete prhRegKey;

    return(hr);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::CreateLog, public
//
//  Synopsis:   Creates a new log based on the parameters passed.
//
//  Arguments:  [argc] - Number of command line args
//              [argv] - Command line args
//
//  Returns:    S_OK if log created successfully or none is specified,
//              E_FAIL if not.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
HRESULT CDebugHelp::CreateLog(int argc, char **argv)
{
    HRESULT hr = S_OK;

    // Check for existing log
    if ((_plog != NULL)  && (_fCreatedLog == TRUE))
    {
        delete _plog;
    }

    // Create the new log
    _plog = new(NullOnFail) Log(argc, argv, LOG_ANSI);
    if (NULL == _plog)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    if (NO_ERROR != _plog->ConfirmCreation())
    {
        delete _plog;
        hr = E_FAIL;
    }

    // Set _fCreatedLog flag to true so the log will get deleted during
    // cleanup (otherwise the calling process must delete it).
    //
    if (SUCCEEDED(hr))
    {
        _fCreatedLog = TRUE;
    }

    return(hr);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::CreateLog, public
//
//  Synopsis:   Creates a new log based on the parameters passed.
//
//  Arguments:  [paszCmdline] - Windows-style ANSI command line.
//
//  Returns:    S_OK if log created successfully or none is specified,
//              E_FAIL if not.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
HRESULT CDebugHelp::CreateLog(LPSTR paszCmdline)
{
    HRESULT   hr   = S_OK;
    int       argc = 0;
    CHAR    **argv = NULL;

    // Convert pszCmdline to argc/argv parameters
    hr = CmdlineToArgs(paszCmdline, &argc, &argv);
    if (FAILED(hr))
    {
        return(hr);
    }

    // Check for existing log
    if ((_plog != NULL)  && (_fCreatedLog == TRUE))
    {
        delete _plog;
    }

    // Create the new log
    _plog = new(NullOnFail) Log(argc, argv, LOG_ANSI);
    if (NULL == _plog)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    if (NO_ERROR != _plog->ConfirmCreation())
    {
        delete _plog;
        hr = E_FAIL;
    }

    // Set _fCreatedLog flag to true so the log will get deleted during
    // cleanup (otherwise the calling process must delete it).
    //
    if (SUCCEEDED(hr))
    {
        _fCreatedLog = TRUE;
    }

    //
    // Delete the argc/argv command line created by CmdlineToArgs
    //


    while (argc > 0)
    {
        --argc;
        delete argv[argc];
    }

    delete argv;

    return(hr);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::SetLog, public
//
//  Synopsis:   Sets the log pointer to the one passed.  This one should
//              not be deleted.  Deletes existing log is appropriate.  If
//              NULL is passed, the old log is deleted and the new log
//              is set to NULL (none).
//
//  Arguments:  [plog] - Pointer to new log.
//
//  Returns:    S_OK if log set successfully, E_FAIL if not.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
HRESULT CDebugHelp::SetLog(Log *plog)
{
    HRESULT hr = E_FAIL;

    // Make sure new log pointer is valid
    if ((NULL == plog) || (FALSE == IsBadReadPtr(plog, sizeof(Log *))))
    {
        // Free old log if we have one
        if ((_plog != NULL) && (_fCreatedLog == TRUE))
        {
            delete _plog;
        }

        // Set new log; we should not delete the pointer
        _plog        = plog;
        _fCreatedLog = FALSE;
        hr           = S_OK;
    }
    else
    {
        OutputDebugString(TEXT("Invalid log pointer"));
    }

    return(hr);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::SetDebugInfo, public
//
//  Synopsis:   Sets debug information.
//
//  Arguments:  [fLogLoc]   - New Log Location setting.
//              [fTraceLoc] - New Trace Location setting.
//              [fTraceLvl] - New Trace Level setting.
//              [fMode]     - New Mode setting.
//
//  Returns:    S_OK 
//
//  History:    21-Nov-94   DeanE    Created
//              10-Apr-97   SCousens revamp fMode
//--------------------------------------------------------------------
HRESULT CDebugHelp::SetDebugInfo(
        DWORD fLogLoc,
        DWORD fTraceLoc,
        DWORD fTraceLvl,
        DWORD fMode)
{
    // Validate New settings
    fLogLoc   = ValidateLoc(fLogLoc);
    fTraceLoc = ValidateLoc(fTraceLoc);
    fTraceLvl = ValidateLvl(fTraceLvl);
    fMode     = ValidateMode(fMode);
                                                                   
    // Assign new values                                           
    if (fLogLoc != DH_LOC_SAME)                                    
    {
        _fLogLoc = fLogLoc;                                        
    }
                                                                   
    if (fTraceLoc != DH_LOC_SAME)
    {                                                              
        _fTraceLoc = fTraceLoc;                                    
    }
                                                                   
    if (fTraceLvl != DH_LVL_SAME)                                    
    {
        _fTraceLvl = DH_LVL_ALWAYS|DH_LVL_ERROR|fTraceLvl;
    }
    
    // Set mode bits, one by one
    if ((fMode & DH_LABMODE_SET) || 
            (fMode & DH_BREAKMODE_SET) || 
            (fMode & DH_VERBOSE_SET))
    {
        DWORD   fNewMode;
        fNewMode = fMode & DH_LABMODE_SET ? 
                fMode & DH_LABMODE : 
                _fMode & DH_LABMODE;

        fNewMode |= fMode & DH_BREAKMODE_SET ? 
                fMode & DH_BREAKMODE : 
                _fMode & DH_BREAKMODE;

        fNewMode |= fMode & DH_VERBOSE_SET ? 
                fMode & DH_VERBOSE : 
                _fMode & DH_VERBOSE;

        // mask off the SET bits
        _fMode = fNewMode & 
                ~(DH_LABMODE_SET | 
                DH_BREAKMODE_SET | 
                DH_VERBOSE_SET) ;
    }
    
    // Reset the warning flag (in OutputMsg)
    _fSpyWarning = FALSE;  

    return(S_OK);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::SetPopupWindow, public
//
//  Synopsis:   Associates the window handle passed with the Assert
//              popups that can occur if Lab Mode is set FALSE.  Simply
//              replaces any existing window handle - does not close
//              it, etc.
//
//  Arguments:  [hwnd] - New window handle
//
//  Returns:    S_OK if set successfully, E_FAIL if not.
//
//  History:    1-Dec-94    DeanE   Created
//--------------------------------------------------------------------
HRESULT CDebugHelp::SetPopupWindow(HWND hwnd)
{
    _hwndAssert = hwnd;
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Member:     CDebughelp::SetSpyWindowClass, public
//
//
//  Synopsis:   Set the window class that all spy window output will
//              go to.
//
//  Arguments:  [pszSpyWindowClass]     -- pointer to class name
//
//  Returns:    S_OK
//  
//  Algorithm:  If the old spy class is not equal to the default one,
//              free up the buffer we allocated.  Then create a new
//              buffer and copy the new class string into it.
//
//  History:    09-Aug-95   MikeW   Created
//
//  Notes:      If an error is returned the old class is preserved.
//--------------------------------------------------------------------
HRESULT CDebugHelp::SetSpyWindowClass(const LPTSTR pszSpyWindowClass)
{
    HRESULT hr = S_OK;
    LPTSTR  pszTemp;

    if (_pszSpyWindowClass != SZ_DEFAULT_SPY_WINDOW_CLASS)
    {
        delete [] _pszSpyWindowClass;
    }

    pszTemp = new TCHAR[_tcslen(pszSpyWindowClass) + 1];

    if (NULL == pszTemp)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        _pszSpyWindowClass = pszTemp;
        _tcscpy(_pszSpyWindowClass, pszSpyWindowClass);
    }

    return S_OK;
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::TraceMsg, public
//
//  Synopsis:   Outputs the debug string to the current location setting
//              if any set bit in the level passed match set bits in the
//              global level.
//
//  Arguments:  [fLvl]   - Trace level.
//              [pszFmt] - Trace message format string.
//              [...]    - Arguments for format string.
//
//  Returns:    Nothing.
//
//  History:    20-Oct-93   DeanE    Created
//              10-Apr-97   SCousens Spiff up output string on error
//--------------------------------------------------------------------
void CDebugHelp::TraceMsg(DWORD fLvl, LPTSTR pszFmt, ...)
{
    TCHAR   szBuffer[CCH_MAX_DBG_CHARS];
    TCHAR   szDebug[CCH_MAX_DBG_CHARS +
                    CCH_MAX_DBGPREFIX +
                    CCH_MAX_INDENTPRINT + 6 ];
    TCHAR   szSpaces[CCH_MAX_INDENTPRINT];
    va_list varArgs;

    // If the level has DH_LVL_ENTRY in it indent by one
    //
    if (fLvl & DH_LVL_ENTRY)
    {
        _cIndentLevel++;
    }

    // If all of the bits match, then we will output the string to the
    // current location(s)
    //
    if ((fLvl & _fTraceLvl) == fLvl)
    {
        // Print the caller's string to a buffer
        va_start(varArgs, pszFmt);
        _vsntprintf(szBuffer, CCH_MAX_DBG_CHARS, pszFmt, varArgs);
        szBuffer[CCH_MAX_DBG_CHARS-1] = chNull;
        va_end(varArgs);

        // Add correct number of space for indentation
        lstrcpy(szSpaces, TEXT("              "));
        if (_cIndentLevel < CCH_MAX_INDENTPRINT)
        {
            szSpaces[_cIndentLevel]=TEXT('\0');
        }

        // Now prepend it with the debug prefix
        _sntprintf(szDebug,
                   CCH_MAX_DBG_CHARS,
                   TEXT("%s: %c %s%s%s"),
                   _szDbgPrefix,
                   DH_LVL_ERROR & fLvl ? chTraceErr : chTrace,
                   szSpaces,
                   DH_LVL_ERROR & fLvl ? szError : szNull,
                   szBuffer);
        szDebug[CCH_MAX_DBG_CHARS-1] = chNull;

        // Now, spit the thing out to the proper places
        OutputMsg(_fTraceLoc, szDebug);
    }

    // If the level has DH_LVL_EXIT in it unindent by one
    //
    if (fLvl & DH_LVL_EXIT)
    {
        _cIndentLevel--;
    }
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::ReportResult, public
//
//  Synopsis:   Outputs the test variation and result to the location(s)
//              currently specified.
//
//  Arguments:  [usResult] - Result of the test
//              [pszFmt]   - Format of the log message
//              [...]      - Parameters for message
//
//  Returns:    Nothing.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
void CDebugHelp::ReportResult(USHORT usResult, LPTSTR pszFmt, ...)
{
    HRESULT  hr     = E_FAIL;
    TCHAR    szFmtBuffer[CCH_MAX_LOG_CHARS];
    TCHAR    szLogBuffer[CCH_MAX_LOG_CHARS];
    va_list  varArgs;

    // format variable arg list into a buffer.
    va_start(varArgs, pszFmt);
    _vsntprintf(szFmtBuffer, CCH_MAX_LOG_CHARS, pszFmt, varArgs);
    szFmtBuffer[CCH_MAX_LOG_CHARS-1] = chNull;
    va_end(varArgs);


    // Set up log buffer. Truncate any extra chars.
    _sntprintf(szLogBuffer,
               CCH_MAX_LOG_CHARS,
               TEXT("%s: %s"),
               GetResultText(usResult),
               szFmtBuffer);
    szLogBuffer[CCH_MAX_LOG_CHARS-1] = chNull;

    SetStats(usResult);

    // Send it out
    OutputMsg(_fLogLoc, szLogBuffer);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::ReportStats, public
//
//  Synopsis:   Outputs statistics about test variations run so far,
//              such as #tests run, #passed, #failed, etc to the Log
//              Location (_fLogLoc).
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
void CDebugHelp::ReportStats()
{
    TCHAR szBuffer[CCH_MAX_LOG_CHARS];

    _sntprintf(szBuffer, CCH_MAX_LOG_CHARS,
               TEXT("Summary--> Passed: %lu ; Failed: %lu ; Aborted: %lu"),
               _cPass,
               _cFail,
               _cAbort);
    szBuffer[CCH_MAX_LOG_CHARS-1] = chNull;

    OutputMsg(_fLogLoc, szBuffer);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::LabAssertEx, public
//
//  Synopsis:   Produces an assert message to the current debug
//              location(s) or to a dialog box, if running in non-Lab
//              mode.
//
//  Arguments:  [szFile] - File assert occurred in.
//              [nLine]  - Line assert occurred.
//              [nszMsg] - Assert message.
//
//  Returns:    Nothing.
//
//  History:    20-Oct-93   DeanE   Created
//--------------------------------------------------------------------
void CDebugHelp::LabAssertEx(LPCTSTR szFile, int nLine, LPCTSTR szMsg)
{
    TCHAR szBuffer[CCH_MAX_ASSERT_CHARS];
    int   nAnswer;

    _sntprintf(szBuffer,
               CCH_MAX_ASSERT_CHARS,
               TEXT("Assert!!!  File: %s, Line: %d, %s\n"),
               szFile,
               nLine,
               szMsg);
    szBuffer[CCH_MAX_ASSERT_CHARS-1] = chNull;

    // always spew
    OutputMsg(_fTraceLoc, szBuffer);

    // if labmode, popup
    if (FALSE == (_fMode & DH_LABMODE))
    {
        nAnswer = MessageBox(
                         _hwndAssert,
                         szBuffer,
                         TEXT("CT OLE Assert"),
                         MB_ICONEXCLAMATION | MB_OKCANCEL);
        if (IDCANCEL==nAnswer)
        {
            DebugBreak();
        }
    }
    // if break, break
    else if (FALSE != (_fMode & DH_BREAKMODE))
    {
        DebugBreak();
    }
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::CheckResult, public
//
//  Synopsis:   Compares the hr passed in with expected hr passed in
//
//  Arguments:  [hrCheck]     - Result to check.
//              [hrExpected]  - Result expected.
//              [pszFuncName] - Name of the current function
//              [pszMsg]      - Debug message if result not in list passed.
//              [nLine]       - __LINE__ macro
//              [pszFile]     - __FILE__ macro
//
//  Returns:    Nothing.
//
//  History:    12-Aug-94   KennethM    Created
//               1-Dec-94   DeanE       Incorporated into CDebugHelp class
//              12-Apr-95   KennethM    Only checks against S_OK
//              10-Apr-97   SCousens    Check against errors also
//--------------------------------------------------------------------
HRESULT CDebugHelp::CheckResult (HRESULT hrCheck, 
        HRESULT hrExpected, 
        LPTSTR pszFuncName, 
        LPTSTR pszMsg, 
        int    nLine, 
        LPTSTR pszFile)
{
    TCHAR   szAssertBuf[CCH_MAX_ASSERT_CHARS];
    TCHAR   szAssertTitle[CCH_MAX_ASSERT_CHARS];
    TCHAR   szMsgBuffer[CCH_MAX_ASSERT_CHARS];
    DWORD   cchMsgBuffer = 0;
    int     nAnswer;
    HRESULT hr = S_OK;

    // If _dwExpectedError is set, then someone up the call chain
    // wants us to ignore that error code, even if our direct caller
    // does not.  If the incoming error code matches _dwExpectedError,
    // then ignore it and return.
    if ( ( _hrExpectedError != S_OK ) && ( hrCheck == _hrExpectedError ) )
    {
        return S_OK;
    }

    // figure out if we have a problem
    if (hrCheck != hrExpected)
    {
        if (FAILED(hrCheck))
        {
            hr = hrCheck;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    // No problem, prepare to bail
    if (S_OK == hr)
    {
        // if we are verbose, call tracemsg 
        if (FALSE != (DH_VERBOSE & _fMode))
        {
            TraceMsg(DH_LVL_ALWAYS,
                    S_OK == hrExpected ?  // different output if HRCHECK
                        TEXT("%s; %s; ok") :
                        TEXT("%s; %s; hr=%#lx; ok"),
                    pszFuncName,
                    pszMsg,
                    hrCheck);
        }
        return hr;
    }

    // Get the text for the HRESULT from the system
    cchMsgBuffer = FormatMessage(
                         FORMAT_MESSAGE_FROM_SYSTEM | 
                         FORMAT_MESSAGE_IGNORE_INSERTS,
                         NULL,
                         hrCheck,
                         GetSystemDefaultLangID(),
                         szMsgBuffer,
                         CCH_MAX_ASSERT_CHARS,
                         NULL);
    szMsgBuffer[CCH_MAX_ASSERT_CHARS-1] = chNull;

    if (0 == cchMsgBuffer)
    {
        _sntprintf(
                szMsgBuffer,   
                CCH_MAX_ASSERT_CHARS, 
                TEXT("Error 0x%08x"),
                hrCheck);
    }
    else  // zap any \r\n from the FormatMessage
    {
        while ('\r' == szMsgBuffer[cchMsgBuffer-1] || 
                '\n' == szMsgBuffer[cchMsgBuffer-1])
        {
            szMsgBuffer[--cchMsgBuffer] = chNull;
        }
    }

    // Output to Trace Location
    TraceMsg(DH_LVL_ERROR,
            S_OK == hrExpected ?  // different output if HRCHECK
                TEXT("%s; %s; hr=%lx; %s") :
                TEXT("%s; %s; hr=%lx;"),
            pszFuncName,
            pszMsg,
            hr,
            szMsgBuffer);
    // If we are comparing against failure, show what we expected and got.
    if (S_OK != hrExpected)
    {
        TraceMsg(DH_LVL_ALWAYS,
                TEXT("+  hr Expected:%#lx; Got:%#lx; %s"),
                hrExpected,
                hrCheck,
                szMsgBuffer);
    }
    TraceMsg(DH_LVL_ALWAYS,
             TEXT("+  File:%s; Line:%d"),
             pszFile,
             nLine);

    // labmode - display an error popup
    if (FALSE == (_fMode & DH_LABMODE))
    {
        _sntprintf(szAssertBuf,
                   CCH_MAX_ASSERT_CHARS,
                   TEXT("%s : hr=%#lx : Expected %#lx\n%s\n"),
                   pszMsg, 
                   hrCheck, 
                   hrExpected,
                   szMsgBuffer);
        szAssertBuf[CCH_MAX_ASSERT_CHARS-1] = chNull;

        _sntprintf(szAssertTitle,
                   CCH_MAX_ASSERT_CHARS,
                   TEXT("CT OLE - %s Error"),
                   _szDbgPrefix);
        szAssertTitle[CCH_MAX_ASSERT_CHARS-1] = chNull;

        // Do we want to debug this?
        nAnswer = MessageBox(
                         _hwndAssert,
                         szAssertBuf,
                         szAssertTitle,
                         MB_ICONSTOP | MB_OKCANCEL);
        // yes we do?
        if (IDCANCEL==nAnswer)
        {
            DebugBreak();
        }
    }
    // break mode, break into the debugger
    else if (FALSE != (_fMode & DH_BREAKMODE))
    {
        DebugBreak();
    }
    return hr;
}

//+-------------------------------------------------------------------
//  Member:     CDebugHelp::SetExpectedError, public
//
//  Synopsis:   Disables error logging for the specified error code.
//
//  Arguments:  [hrExpectedError] - Error code to disable.  Pass S_OK
//                                   for no expected errors.
//
//  Returns:    Nothing.
//
//  History:    16-Sep-97   BWill       Created
//
//  Notes:      -- Use this call to temporarily disable error logging
//                  in client code.
//              -- Call this function with S_OK to enable all checks.
//              -- See also DH_EXPECTEDERROR/DH_NOEXPECTEDERROR in
//                  cdbghelp.hxx.
//--------------------------------------------------------------------
void CDebugHelp::SetExpectedError( HRESULT hrExpectedError )
{
    _hrExpectedError = hrExpectedError;
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::ValidateLoc, private
//
//  Synopsis:   Checks the location flag passed to insure it is a legal
//              value.
//
//  Arguments:  [fLoc] - Location flag to check.
//
//  Returns:    Legal version of what we were to check.
//
//  History:    21-Nov-94   DeanE    Created
//              10-Apr-97   SCousens Return legal value
//--------------------------------------------------------------------
DWORD CDebugHelp::ValidateLoc(DWORD fLoc)
{
    // Get what we can out of supplied location
    return (DH_LOC_VALID & fLoc);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::ValidateLvl, private
//
//  Synopsis:   Checks the Trace Level flag passed to insure it is a
//              legal value.
//
//  Arguments:  [fLvl] - Trace Level to check.
//
//  Returns:    Legal version of what we were to check.
//
//  History:    21-Nov-94   DeanE    Created
//              10-Apr-97   SCousens Return legal value
//--------------------------------------------------------------------
DWORD CDebugHelp::ValidateLvl(DWORD fLvl)
{
    // Make sure a valid setting is passed
    return (~DH_LVL_INVMASK & fLvl);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::ValidateMode, private
//
//  Synopsis:   Checks the Lab Mode flag passed to insure it is a
//              legal value.
//
//  Arguments:  [fMode] - Flag to check.
//
//  Returns:    Legal version of what we were to check.
//
//  History:    21-Nov-94   DeanE    Created
//              10-Apr-97   SCousens Return legal value
//--------------------------------------------------------------------
DWORD CDebugHelp::ValidateMode(DWORD fMode)
{
    return (fMode & (~DH_INVMODE));
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::SetStats, private
//
//  Synopsis:   Sets stats based on result
//
//  Arguments:  [usResult] - Result to add.
//
//  Returns:    nothing.
//
//  History:    20-Oct-93   DeanE   Created
//--------------------------------------------------------------------
VOID CDebugHelp::SetStats(USHORT usResult)
{

    switch (usResult)
    {
    case LOG_PASS:
        _cPass++;
        break;

    case LOG_FAIL:
        _cFail++;
        break;

    case LOG_ABORT:
        _cAbort++;
        break;

    default:
        // do nothing.
        break;
    }
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::GetResultText, private
//
//  Synopsis:   Determines the correct text to printf for the result code
//              passed.  Result code corresponds to LogServer result codes.
//
//  Arguments:  [usResult] - Result to look up.
//
//  Returns:    Pointer to output string corresponding to the result
//              code passed (ie "PASSED" for LOG_PASS).
//
//  History:    21-Nov-94   DeanE   Created
//--------------------------------------------------------------------
LPCTSTR CDebugHelp::GetResultText(USHORT usResult)
{
    LPCTSTR szResult = NULL;
    TCHAR   szAssert[CCH_MAX_DBG_CHARS];

    switch (usResult)
    {
    case LOG_PASS:
        szResult = szPass;
        break;

    case LOG_FAIL:
        szResult = szFail;
        break;

    case LOG_ABORT:
        szResult = szAbort;
        break;

    case LOG_WARN:
        szResult = szWarn;
        break;

    case LOG_INFO:
        szResult = szInfo;
        break;

    default:
        szResult = szInvalid;
        _sntprintf(szAssert,
                   CCH_MAX_DBG_CHARS,
                   TEXT("Invalid Test Result=%ld"),
                   usResult);
        szAssert[CCH_MAX_DBG_CHARS-1] = chNull;
        LabAssertEx(TEXT(__FILE__), __LINE__, szAssert);
        break;
    }

    return(szResult);
}


//+-------------------------------------------------------------------
//  Member:     CDebugHelp::OutputMsg, private
//
//  Synopsis:   Outputs the buffer to the locations specified.
//              Location, log, and buffer are all assumed to be valid,
//              so no error checking is done.
//
//  Arguments:  [fLoc]      - Location(s) to output buffer to.
//              [pszBuffer] - Buffer to output.
//
//  Returns:    Nothing.
//
//  History:    21-Nov-94   DeanE   Created
//              08-Mar-95   MikeW   Added DH_LOC_SPYWIN stuff
//--------------------------------------------------------------------
void CDebugHelp::OutputMsg(DWORD fLoc, LPTSTR pszBuffer)
{
    CHAR szLogBuf[CCH_MAX_LOG_CHARS];

    if (fLoc & DH_LOC_TERM)
    {
        OutputDebugString(pszBuffer);
        OutputDebugString(szNewLine);
    }

    if (fLoc & DH_LOC_STDOUT)
    {
        _tprintf(TEXT("%s\n"), pszBuffer);
    }

    if (fLoc & DH_LOC_LOG)
    {
        if (FALSE == IsBadReadPtr(_plog, sizeof(Log *)))
        {
            // Buffer must be ANSI regardless of platform
#ifdef UNICODE
            _snprintf(szLogBuf, CCH_MAX_LOG_CHARS, "%ls", pszBuffer);
#else
            _snprintf(szLogBuf, CCH_MAX_LOG_CHARS, "%s", pszBuffer);
#endif
            szLogBuf[CCH_MAX_LOG_CHARS-1] = chNull;
            _plog->WriteData(szLogBuf);
        }
        else
        {
            // Trying to write to log that doesn't exist!
            OutputDebugString(TEXT("CDebugHelp: Unable to write to Log File!\n"));
        }
    }

    if (fLoc & DH_LOC_SPYWIN)
    {
        HWND    hWndSpy;

        hWndSpy = FindWindow(_pszSpyWindowClass, NULL);

        if (NULL != hWndSpy)
        {
            SendMessage(hWndSpy, LB_ADDSTRING, 0, (LPARAM) pszBuffer);
            SendMessage(hWndSpy, LB_ADDSTRING, 0, (LPARAM) szCRLF);
        }
        else if (FALSE == _fSpyWarning)
        {
            //only spew this once, till someone changes the settings.
            _fSpyWarning = TRUE;  
            // Unable to find SpyWindow
            OutputDebugString(TEXT("CDebugHelp: Spy Window not found!\n"));
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   InitializeDebugObject
//
//  Synopsis:   Initialize the debug helper (trace levels, etc.)
//
//  Arguments:  (none)
//
//  Returns:    S_OK if all went well
//              S_FALSE if we encountered /? and spewed and bailed.
//
//  History:    29-Apr-05   kennethm    Created
//              09-Aug-95   MikeW       Override defaults w/ command line
//              10-Apr-97   SCousens    move into CDebugHelp
//--------------------------------------------------------------------------

HRESULT CDebugHelp::Initialize()
{
    HRESULT hr = S_OK;
    int     nRet;

    LPTSTR  pszSpyClass = NULL;

    CUlongCmdlineObj cmdTraceLvl (OLESTR("tracelvl"),   OLESTR("Trace levels"));
    CUlongCmdlineObj cmdTraceLoc (OLESTR("traceloc"),   OLESTR("Trace output"));
    CUlongCmdlineObj cmdLogLoc   (OLESTR("logloc"),     OLESTR("Log output"));
    CBoolCmdlineObj  cmdDebugUI  (OLESTR("DebugUI"),    OLESTR("Popup debug dialog"), OLESTR("FALSE"));
    CBoolCmdlineObj  cmdLabMode  (OLESTR("labmode"),    OLESTR("Popup on error"), OLESTR("FALSE"));
    CBoolCmdlineObj  cmdBreak    (OLESTR("breakmode"),  OLESTR("Break on error"), OLESTR("FALSE"));
    CBoolCmdlineObj  cmdVerbose  (OLESTR("verbose"),    OLESTR("Trace HRCHECK for a noisy log"), OLESTR("FALSE"));
    CBaseCmdlineObj  cmdSpyClass (OLESTR("spyclass"),   OLESTR("Classname for Spy Window"));
    CCmdline         cmdlineArgs;

    CBaseCmdlineObj *aPossCmdline[] = {
                              &cmdTraceLvl,
                              &cmdTraceLoc,
                              &cmdLogLoc,
                              &cmdDebugUI,
                              &cmdLabMode,
                              &cmdVerbose,
                              &cmdBreak,
                              &cmdSpyClass };

    //
    //  Read the debug options from the registry
    //
    hr = GetRegDbgInfo (DEFAULT_REG_LOC);

    //
    //  Now that we have the defaults from the registry read the command
    //  line to over-ride them.
    //
    if (hr == S_OK)
    {
        //
        //  Make sure there were no errors starting up the cmd line objects
        //
        nRet = cmdlineArgs.QueryError();
        if (nRet != CMDLINE_NO_ERROR)
        {
            hr = E_FAIL;
            TraceMsg (DH_LVL_ERROR, TEXT("cmdlineArgs.QueryError"));
        }
    }

    if (hr == S_OK)
    {
        //
        //  Now parse the command line
        //

        nRet = cmdlineArgs.Parse(aPossCmdline,
                      sizeof(aPossCmdline)/sizeof(CBaseCmdlineObj *),
                      FALSE);
        if (nRet != CMDLINE_NO_ERROR)
        {
            hr = E_FAIL;
            TraceMsg (DH_LVL_ERROR, TEXT("cmdlineArgs.Parse"));
        }
    }

    if (hr == S_OK)
    {
        DWORD dwLogLoc   = DH_LOC_SAME;
        DWORD dwTraceLoc = DH_LOC_SAME;
        DWORD dwTraceLvl = DH_LVL_SAME;
        DWORD dwMode     = 0;

        if (cmdLabMode.IsFound())
        {
            dwMode = *cmdLabMode.GetValue () ? DH_LABMODE_ON : DH_LABMODE_OFF;
        }
        if (cmdVerbose.IsFound())
        {
            dwMode |= *cmdVerbose.GetValue () ? DH_VERBOSE_ON : DH_VERBOSE_OFF;
        }
        if (cmdBreak.IsFound())
        {
            dwMode |= *cmdBreak.GetValue () ? DH_BREAKMODE_ON : DH_BREAKMODE_OFF;
        }
        if (cmdTraceLvl.IsFound())
        {
            dwTraceLvl = *cmdTraceLvl.GetValue();
        }
        if (cmdTraceLoc.IsFound())
        {
            dwTraceLoc = *cmdTraceLoc.GetValue();
        }
        if (cmdLogLoc.IsFound())
        {
            dwLogLoc = *cmdLogLoc.GetValue();
        }
        SetDebugInfo(         \
                dwLogLoc,     \
                dwTraceLoc,   \
                dwTraceLvl,   \
                dwMode);

        if (cmdSpyClass.IsFound())
        {
            OleStringToTString(cmdSpyClass.GetValue(), &pszSpyClass);

            if (NULL != pszSpyClass)
            {
                SetSpyWindowClass (pszSpyClass);
                delete [] pszSpyClass;
            }
        }
        if (cmdDebugUI.IsFound())
        {
            HRESULT hr2 = OptionsDialog (GetModuleHandle (NULL), GetActiveWindow ());
            if (FAILED(hr2))
            {
                TraceMsg (DH_LVL_ERROR, 
                        TEXT("DialogBoxParam failed; hr=%#x. (Is dlg in res?)"),
                        hr2);
            }
        }
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CEntryExitTrace::CEntryExitTrace
//
//  Synopsis:   Displays a debug line saying the current function is being
//              entered.  Saves the information so it can be displayed
//              when the destructor is called.
//
//  Arguments:  [pDebugObject] -- The parent debug log object
//              [plExitOutput] -- The 32 value to display on exit (can be
//                                NULL)
//              [fLvl]         -- The trace level of this function
//              [pszFuncName]  -- The name of this function
//
//  Returns:
//
//  History:    4-10-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

CEntryExitTrace::CEntryExitTrace(
            CDebugHelp *pDebugObject,
            PLONG       plExitOutput,
            DWORD       fLvl,
            LPTSTR      pszFuncName)
{
    //  Save the paramters

    _pDebugObject = pDebugObject;
    _plExitOutput = plExitOutput;
    _pszFuncName  = pszFuncName;
    _fLvl         = fLvl;

    //  Display the trace information

    _pDebugObject->TraceMsg(
                (_fLvl | DH_LVL_ENTRY),
                TEXT("%s _IN"),
                _pszFuncName);
}

//+-------------------------------------------------------------------------
//
//  Member:     CEntryExitTrace::~CEntryExitTrace
//
//  Synopsis:   Destructor.  Display a trace output line
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-17-95   kennethm   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

CEntryExitTrace::~CEntryExitTrace(void)
{
    //  Display the trace information

    if (_plExitOutput != NULL)
    {
        _pDebugObject->TraceMsg(
                    (_fLvl | DH_LVL_EXIT),
                    TEXT("%s _OUT:%#08lx"),
                    _pszFuncName,
                    *_plExitOutput);
    }
    else
    {
        _pDebugObject->TraceMsg(
                    (_fLvl | DH_LVL_EXIT),
                    TEXT("%s _OUT"),
                    _pszFuncName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\common\testhelp\utest\cmdutest\cmdutest.cxx ===
//+-------------------------------------------------------------------
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994-1995.
//
//  File:       cmdutest.cxx
//
//  Contents:   Unit test for the CDebugHelp class implementation.
//              Utilizes functions in arghelp.cxx and the CRegistryHelp
//              class.
//
//  Classes:    None
//
//  History:    28-Nov-94   DeanE   Created
//---------------------------------------------------------------------
#include <oleworld.hxx>


// Declare the CDebugHelp object
DH_DECLARE;


// Local Functions
HRESULT SettingsTest(VOID);
HRESULT TraceTest(VOID);
HRESULT LogTest(VOID);
HRESULT AssertTest(VOID);


// Test TRACE level flags
#define DH_UTEST_LVL1   0x00001000
#define DH_UTEST_LVL2   0x08000000


// Results macros
#define TESTFAIL(msg)   \
        printf("FAIL: %s, %ul  - %s\n", __FILE__, __LINE__, msg)

#define TESTPASS(msg)    \
        printf("PASS: %s\n", msg)


// Define the CDebugHelp object
DH_DEFINE;


//+---------------------------------------------------------------------
//  Function:   main
//
//  Synopsis:   Command line test utilizing a CDebugHelp object.
//              Excercises Trace Location, Log Location, Trace Level,
//              Trace and Log output, and Assert functionality.  Uses
//              a log created via DH_CREATELOGARGS.
//
//  Arguments:  [argc] - Number of command line arguments.
//              [argv] - Command line arguments.
//
//  Returns:    Zero if no errors, otherwise non-zero
//
//  History:    28-Nov-94   DeanE   Created
//----------------------------------------------------------------------
int _cdecl main(int argc, char *argv[])
{
    HRESULT hr;

    // First, create a log
    hr = DH_CREATELOGARGS(argc, argv);
    if (FAILED(hr))
    {
        printf("Log creation failed - %lx\n", hr);
        return(1);
    }

    // Set & retrieve settings
    hr = SettingsTest();
    if (SUCCEEDED(hr))
    {
        TESTPASS("Debug settings");
    }
    else
    {
        TESTFAIL("Debug settings");
        return(1);
    }

    // Trace output macro tests
    hr = TraceTest();
    if (SUCCEEDED(hr))
    {
        TESTPASS("Trace Output");
    }
    else
    {
        TESTFAIL("Trace Output");
        return(1);
    }

    // Logging output macro tests
    hr = LogTest();
    if (SUCCEEDED(hr))
    {
        TESTPASS("Log Output");
    }
    else
    {
        TESTFAIL("Log Output");
        return(1);
    }

    // Assert tests
    hr = AssertTest();
    if (SUCCEEDED(hr))
    {
        TESTPASS("Assert Test");
    }
    else
    {
        TESTFAIL("Assert Test");
        return(1);
    }

    return(0);
}


//+---------------------------------------------------------------------
//  Function:   SettingsTest
//
//  Synopsis:   Sets and checks (by retrieving) values in the
//              global CDebugHelp object.  Assumes a log has been
//              created.
//
//  Arguments:  None.
//
//  Returns:    S_OK if test passes, error code if not.
//
//  History:    28-Nov-94   DeanE   Created
//----------------------------------------------------------------------
HRESULT SettingsTest()
{
    HRESULT hr;
    DWORD   fValues;

    // Set and check Trace Location
    //   Set a valid setting - should succeed
    //
    hr = DH_SETTRACELOC(DH_LOC_STDOUT);
    if (SUCCEEDED(hr))
    {
        fValues = DH_GETTRACELOC;
        hr = (fValues & DH_LOC_STDOUT) ? S_OK : E_FAIL;
    }

    if (FAILED(hr))
    {
        TESTFAIL("DH_SETTRACELOC test - valid setting");
    }


    //   Set an invalid setting - should fail
    if (SUCCEEDED(hr))
    {
        hr = DH_SETTRACELOC(DH_LOC_NONE);
        if (FAILED(hr))
        {
            hr = S_OK;
        }
    }

    if (FAILED(hr))
    {
        TESTFAIL("DH_SETTRACELOC test - invalid setting");
        return(hr);
    }

    // Set and check Log Location
    //   Set a valid setting - should succeed
    //
    hr = DH_SETLOGLOC(DH_LOC_STDOUT|DH_LOC_LOG);
    if (SUCCEEDED(hr))
    {
        fValues = DH_GETLOGLOC;
        hr = (fValues & DH_LOC_STDOUT) &&
             (fValues & DH_LOC_LOG) ? S_OK : E_FAIL;
    }

    if (FAILED(hr))
    {
        TESTFAIL("DH_SETLOGLOC test - valid setting");
    }

    //   Set an invalid setting - should fail
    if (SUCCEEDED(hr))
    {
        hr = DH_SETLOGLOC(DH_LOC_NONE);
        if (FAILED(hr))
        {
            hr = S_OK;
        }
    }

    if (FAILED(hr))
    {
        TESTFAIL("DH_SETLOGLOC test - invalid setting");
        return(hr);
    }


    // Set and check Trace Level
    //   Set a valid level - should succeed
    //
    hr = DH_SETLVL(DH_UTEST_LVL1|DH_LVL_TRACE1);
    if (SUCCEEDED(hr))
    {
        fValues = DH_GETTRACELVL;
        hr = (fValues & DH_UTEST_LVL1) &&
             (fValues & DH_LVL_TRACE1) ? S_OK : E_FAIL;
    }

    if (FAILED(hr))
    {
        TESTFAIL("DH_SETLVL test - valid setting");
    }

    //   Try to turn one of the reserved settings off - should fail
    if (SUCCEEDED(hr))
    {
        hr = DH_SETLVL(DH_GETTRACELVL&~DH_LVL_ERROR);
        if (SUCCEEDED(hr))
        {
            fValues = DH_GETTRACELVL;
            hr = (fValues & DH_LVL_ERROR) ? S_OK : E_FAIL;
        }
    }

    if (FAILED(hr))
    {
        TESTFAIL("DH_SETLVL - turn reserved off");
    }

    return(hr);
}


//+---------------------------------------------------------------------
//  Function:   TraceTest
//
//  Synopsis:   Tests TRACE macro outputs of the global CDebugHelp object.
//
//  Arguments:  None.
//
//  Returns:    S_OK if test passes, error code if not.
//
//  History:    28-Nov-94   DeanE   Created
//----------------------------------------------------------------------
HRESULT TraceTest()
{
    HRESULT hr;

    // Set the Trace Location to STDOUT and the debug terminal so we
    // can see messages
    //
    hr = DH_SETTRACELOC(DH_LOC_STDOUT|DH_LOC_TERM);
    if (FAILED(hr))
    {
        TESTFAIL("Cannot set test trace location");
        return(hr);
    }

    printf("Six messages should appear\n");

    // Set a level that should NOT produce a message...
    hr = DH_SETLVL(DH_UTEST_LVL2);
    if (FAILED(hr))
    {
        TESTFAIL("Failure setting test trace level");
        return(hr);
    }

    // Output a message at a level NOT set
    DH_TRACE((DH_UTEST_LVL1, TEXT("ERROR! Message should not appear!")));

    // Output simple messages that should appear
    DH_TRACE((DH_LVL_ALWAYS, TEXT("Sample ALWAYS message")));
    DH_TRACE((DH_LVL_ERROR, TEXT("Sample ERROR message")));
    DH_TRACE((DH_UTEST_LVL2, TEXT("Sample USER-DEFINED message")));

    // Output complex messages
    DH_TRACE((DH_LVL_ALWAYS,
              TEXT("ALWAYS - Expansion File: %s, Line: %lu"),
              TEXT(__FILE__),
              __LINE__));

    // Output messages with multiple levels set
    hr = DH_SETLVL(DH_UTEST_LVL2 | DH_UTEST_LVL1);
    if (FAILED(hr))
    {
        TESTFAIL("Failure setting multiple trace levels");
        return(hr);
    }
    DH_TRACE((DH_UTEST_LVL1,
              TEXT("Sample MULTI-USER-DEFINED message value: %lx"),
              DH_UTEST_LVL1));
    DH_TRACE((DH_UTEST_LVL2,
              TEXT("Sample MULTI-USER-DEFINED message value: %lx"),
              DH_UTEST_LVL2));
    DH_TRACE((DH_LVL_TRACE4,
              TEXT("ERROR! Message TRACE4 should not appear!")));

    return(hr);
}


//+---------------------------------------------------------------------
//  Function:   LogTest
//
//  Synopsis:   Tests LOG macro outputs of the global CDebugHelp object.
//
//  Arguments:  None.
//
//  Returns:    S_OK if test passes, error code if not.
//
//  History:    28-Nov-94   DeanE   Created
//----------------------------------------------------------------------
HRESULT LogTest()
{
    HRESULT hr;

    // Set the Log Location to STDOUT, the log, and the debug
    // terminal so we can see messages
    //
    hr = DH_SETLOGLOC(DH_LOC_STDOUT|DH_LOC_TERM|DH_LOC_LOG);
    if (FAILED(hr))
    {
        TESTFAIL("Cannot set test log location");
        return(hr);
    }

    // Report a simple PASS, complex FAIL, and statistics
    DH_LOG((LOG_PASS, TEXT("Simple sample PASS")));
    DH_LOG((LOG_FAIL,
            TEXT("Complex sample FAIL %s, %lu"),
            TEXT(__FILE__),
            __LINE__));

    printf("Correct totals: 1 PASS, 1 FAIL, 0 ABORT\n");

    DH_LOGSTATS;

    return(hr);
}


//+---------------------------------------------------------------------
//  Function:   AssertTest
//
//  Synopsis:   Tests ASSERT macro outputs of the global CDebugHelp object.
//
//  Arguments:  None.
//
//  Returns:    S_OK if test passes, error code if not.
//
//  History:    28-Nov-94   DeanE   Created
//----------------------------------------------------------------------
HRESULT AssertTest()
{
#pragma warning(disable: 4127)    // Examined and ignored

    // Set Lab Mode to ON - we should NOT get any popups
    DH_SETMODE(DH_LABMODE_ON);

    // Trigger an assert
    DH_ASSERT(!"LABMODE ON - NO POPUP SHOULD APPEAR");


    // Set Lab Mode to ON - we should get popups
    DH_SETMODE(DH_LABMODE_OFF);

    // This assert should NOT trigger
    DH_ASSERT(5 < 6);

    // Set Lab Mode to OFF - we should get a popup
    DH_ASSERT(!"LABMODE OFF - POPUP SHOULD APPEAR");

#pragma warning(default: 4127)    // Examined and ignored

    return(S_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\comtests.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       comtests.cxx
//
//  Contents:   storage base tests common to IStorage and IStream methoods
//
//  Functions:  
//
//  History:    29-May-1996     NarindK     Created.
//              27-Mar-97       SCousens    Conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

//----------------------------------------------------------------------------
//
// Test:    COMTEST_100 
//
// Synopsis:Create a root docfile with a child IStorage and a child IStream.
//          Commit the root docfile.
//
//          Add a random number of refcounts to IStorage via AddRef() method.
//          loop to release the refs, each release is followed by a Stat.  After
//          the last ref (that we added) is released, release the ref created
//          during the Create... call.  This frees the real object.  Repeat for
//          the child IStream.
//
//  Arguments:  [argc]
//              [argv]
//
//  Returns:    HRESULT
//
//  History:    29-May-1996     NarindK     Created.
//
// Notes:   This test runs in direct, transacted, and transacted deny write 
//          modes
//
// New Test Notes:
// 1.  Old File: ADDREF.CXX
// 2.  Old name of test : MiscAddRef 
//     New Name of test : COMTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-100
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-100
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// Conversion: COMTEST_100
//
//-----------------------------------------------------------------------------


HRESULT COMTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    ULONG           cb                      = 0;
    ULONG           cusIStorageRefs         = 0;
    ULONG           cusIStreamRefs          = 0;
    ULONG           i                       = 0;
    ULONG           cRandomMinSize          = 10;
    ULONG           cRandomMaxSize          = 100;
    ULONG           cRandomMinVar           = 2;
    ULONG           cRandomMaxVar           = 16;
    STATSTG         statStg;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("COMTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("AddRef/Release tests on IStorage/IStream")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for COMTEST_100, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get DG_UNICODE object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }

    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.  

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE |
                STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx."),
            hr));
    }

    // Commit the root storage.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

   
// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // add from 2 to 16 ref counts to child IStorage object and then
    // release each one followed by a Stat() call.  The ref count should
    // be decremented after each release.  There will already be one
    // ref count from the IStorage create call, so all Stat() calls in
    // the loop should be on a valid object.  Finally, release remaining
    // IStorage (this is the ref from the creation)
    
    if (S_OK == hr)
    {
        // Generate random number for ref counts to be done.

        usErr = pdgi->Generate(&cusIStorageRefs, cRandomMinVar, cRandomMaxVar);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    for (i=0; i < cusIStorageRefs; i++)
    {
        // AddRef the storage

        hr = pvcnRootNewChildStorage->AddRefCount();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::AddRefCount completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::AddRefCount unsuccessful, hr = 0x%lx."),
                hr));

            break;
        }
    }

    while ((cusIStorageRefs--) && (S_OK == hr))
    {
        // Close the storage

        hr = pvcnRootNewChildStorage->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            // Stat the storage

            hr = pvcnRootNewChildStorage->Stat(&statStg, STATFLAG_NONAME);

            if (S_OK == hr)
            {
                DH_TRACE((
                 DH_LVL_TRACE1,
                 TEXT("VirtualCtrNode::Stat completed successfully.")));
            }
            else 
            {
                DH_TRACE((
                 DH_LVL_ERROR,
                 TEXT("VirtualCtrNode::Stat unsuccessful, hr = 0x%lx."),
                 hr));
            }
        }

    }

    // Close the root storage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------
    // add from 2 to 16 ref counts to child IStream object and then
    // release each one followed by a Stat() call.  The ref count should
    // be decremented after each release.  There will already be one
    // ref count from the IStream create call, so all Stat() calls in
    // the loop should be on a valid object.  Finally, release remaining
    // IStream (this is the ref from the creation)
    
    if (S_OK == hr)
    {
        // Generate random number for ref counts to be done.

        usErr = pdgi->Generate(&cusIStreamRefs, cRandomMinVar, cRandomMaxVar);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    for (i=0; i < cusIStreamRefs; i++)
    {
        // Addref the stream 

        hr = pvsnRootNewChildStream->AddRefCount();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddRefCount completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualStmNode::AddRefCount unsuccessful, hr = 0x%lx."),
                hr));

            break;
        }
    }

    while ((cusIStreamRefs--) && (S_OK == hr))
    {
        // Clsoe the stream

        hr = pvsnRootNewChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualStmNode::Close unsuccessful, hr = 0x%lx."),
                hr));
        }

        if (S_OK == hr)
        {
            // Stat the stream

            hr = pvsnRootNewChildStream->Stat(&statStg, STATFLAG_NONAME);

            if (S_OK == hr)
            {
                DH_TRACE((
                 DH_LVL_TRACE1,
                 TEXT("VirtualStmNode::Stat completed successfully.")));
            }
            else 
            {
                DH_TRACE((
                 DH_LVL_ERROR,
                 TEXT("VirtualStmNode::Stat unsuccessful, hr = 0x%lx."),
                 hr));
            }
        }

    }

    // Close the stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation COMTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation COMTEST_100 failed, hr = 0x%lx."), 
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    COMTEST_101 
//
// Synopsis: Regression test for root docfile creation, IStorage creation,
//           embedded stream creation/read/write, and IStorage commit 
//           operations.
//
//  Arguments:  [argc]
//              [argv]
//
//  Returns:    HRESULT
//
//  History:    29-May-1996     NarindK     Created.
//
// Notes:   This test runs in direct, transacted, and transacted deny write 
//          modes
//
// New Test Notes:
// 1.  Old File: DFTEST.CXX
// 2.  Old name of test :
//     New Name of test : COMTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-101
//        /dfRootMode:dirReadWriteShEx  /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-101
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-101
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// Conversion: COMTEST_101
//
//-----------------------------------------------------------------------------


HRESULT COMTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    LPTSTR          pRootNewChildStgName    = NULL;    
    LPTSTR          pwcsBuffer              = NULL;    
    LPTSTR          pReadBuffer              = NULL;    
    ULONG           cb                      = 0;
    ULONG           culWritten              = 0;
    ULONG           culRead                 = 0;
    ULONG           cRandomMinSize          = 10;
    ULONG           cRandomMaxSize          = 100;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("COMTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1, 
        TEXT("Regression test for Docfile/IStorage/IStream creation.")) );
    DH_TRACE((DH_LVL_TRACE1, 
        TEXT("IStream Read/Write, IStorage Commit opertaions.")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for COMTEST_101, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }

    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    //    Adds a new storage to the root storage.  

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr ));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Generate a random name for child IStream

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    //  Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx."),
            hr));
    }

    // Call VirtualStmNode::Write to create random bytes in the stream.  For
    // our test purposes, we generate a random string of size cb using
    // GenerateRandomString function.

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cb, cb, &pwcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream->Write(
                pwcsBuffer,
                cb,
                &culWritten);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::Write function wasn't successful, hr = 0x%lx."),
            hr));
    }

    // Close the IStream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Close the IStorage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Commit the DocFile

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Close the Root DocFile 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Open the Root DocFile

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                STGM_READWRITE  | STGM_SHARE_EXCLUSIVE,
                NULL,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Open unsuccessful, hr = 0x%lx."),
            hr));
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Open the embedded IStorage 

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Open(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Open unsuccessful, hr = 0x%lx."),
            hr));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Open the IStream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Open(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Open unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Read the IStream.

    if (S_OK == hr)
    {
        pReadBuffer = new TCHAR [cb];

        if(NULL == pReadBuffer)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        memset(pReadBuffer, '\0', cb);
    
        hr =  pvsnRootNewChildStream->Read(
                pReadBuffer,
                cb,
                &culRead);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Read function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::Read function wasn't successful, hr = 0x%lx."),
            hr));
    }

    // Close the IStream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Close the IStorage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful.")));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Close the Root DocFile 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation COMTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation COMTEST_101 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    if(NULL != pwcsBuffer)
    {
        delete []pwcsBuffer;
        pwcsBuffer = NULL;
    }

    if(NULL != pReadBuffer)
    {
        delete []pReadBuffer;
        pReadBuffer = NULL;
    }

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:     COMTEST_102 
//
// Synopsis: Create a root docfile with random name. Create a child IStorage 
//           and a child IStream in this docfile.  Attempt to do iilegal op
//           erations on this docfile - creating/instantiating storages/streams
//           /root docfiles with existing names with STGM_FAILIFTHERE flag. Also
//           attempts various illegal grfmodes.    
//
//  Arguments:  [argc]
//              [argv]
//
//  Returns:    HRESULT
//
//  History:    29-May-1996     NarindK     Created.
//
// Notes:   This test runs in direct, transacted, and transacted deny write 
//          modes
//
// New Test Notes:
// 1.  Old File: IINORM.CXX
// 2.  Old name of test : IllegitInstEnumNormal Test
//     New Name of test : COMTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-102
//        /dfRootMode:dirReadWriteShEx  /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-102
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-102
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// Conversion: COMTEST_102
//
//  BUGBUG: Use Random Commit modes
//-----------------------------------------------------------------------------


HRESULT COMTEST_102(int argc, char *argv[])
{
    HRESULT         hr                          = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    VirtualDF       *pTestVirtualDF             = NULL;
    VirtualCtrNode  *pVirtualDFRoot             = NULL;
    DG_INTEGER      *pdgi                       = NULL;
    DG_STRING       *pdgu                       = NULL;
    USHORT          usErr                       = 0;
    VirtualStmNode  *pvsnRootNewChildStream     = NULL;
    LPTSTR          pRootNewChildStmName        = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage    = NULL;
    LPTSTR          pRootNewChildStgName        = NULL;    
    ULONG           cb                          = 0;
    VirtualCtrNode  *pvcnRootSecondChildStorage = NULL;
    VirtualCtrNode  *pvcnRootThirdChildStorage  = NULL;
    VirtualStmNode  *pvcnRootSecondChildStream  = NULL;
    VirtualStmNode  *pvcnRootThirdChildStream   = NULL;
    LPSTORAGE       pRootStg                    = NULL;
    LPSTORAGE       pNonExistingStg             = NULL;
    LPSTREAM        pNonExistingStm             = NULL;
    ULONG           cRandomMinSize              = 10;
    ULONG           cRandomMaxSize              = 100;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("COMTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1, 
        TEXT("Illegal operations on Docfile/IStorage/IStream.")) );
    DH_TRACE((DH_LVL_TRACE1, 
        TEXT("Instantiating with existing names, invalid grfmodes.")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for COMTEST_102, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT(NULL != pdgi);
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.  

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr));
    }

    // Commit the Storage 

    if(S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Commit(STGC_DEFAULT);
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Close the IStorage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Generate a random name for child IStream

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    //  Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx."),
            hr));
    }

    // Close the IStream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Commit the Root DocFile 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Attempt to create another Child IStorage with same name as existing
    // IStorage above and STGM_FAILIFTHERE flag.

    if(S_OK == hr)
    {
        // This call should fail with STG_E_FILEALREADYEXISTS error.

        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_FAILIFTHERE,
                &pvcnRootSecondChildStorage);

        if(STG_E_FILEALREADYEXISTS == hr) 
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));
            
            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
    }

    // Attempt to create another Child IStorage with same name as existing
    // IStream above and STGM_FAILIFTHERE flag.

    if(S_OK == hr)
    {
        // This call should fail with STG_E_FILEALREADYEXISTS error.

        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                pTestChanceDF->GetStgMode()|
                STGM_FAILIFTHERE,
                &pvcnRootSecondChildStorage);

        if(STG_E_FILEALREADYEXISTS == hr) 
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));

            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
    }

    // Attempt to create another Child IStorage with same name as existing
    // IStorage above and STGM_CREATE flag.

    if(S_OK == hr)
    {
        // This call should pass.

        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE,
                &pvcnRootSecondChildStorage);

        if(S_OK == hr) 
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));
        }
    }

    // Commit the above Storage 

    if(S_OK == hr)
    {
        hr = pvcnRootSecondChildStorage->Commit(STGC_DEFAULT);
       
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
                hr));
        }
    }

    // Now with the above IStorage created and instantiated, attempt to create 
    // another Child IStorage with same name as above which is both existing
    // and instantiated.  Should give STG_E_ACCESSDENIED error. 

    if(S_OK == hr)
    {
        // This call should give STG_E_ACCESSDENIED error.

        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_FAILIFTHERE,
                &pvcnRootThirdChildStorage);

        if(STG_E_ACCESSDENIED == hr) 
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("hr = 0x%lx received as expected."), hr));
            
            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
    }

    // Close the pvcnRootSecondChildStorage which is instantiated.

    if (S_OK == hr)
    {
        hr = pvcnRootSecondChildStorage->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::Close unsuccessful, hr =0x%lx."),
                hr));
        }
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Repeat the above with streams

    // Attempt to create another Child IStream with same name as existing
    // IStream above and STGM_FAILIFTHERE flag.

    if(S_OK == hr)
    {
        // This call should fail with STG_E_FILEALREADYEXISTS error.

        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE|
                STGM_FAILIFTHERE,
                &pvcnRootSecondChildStream);

        if(STG_E_FILEALREADYEXISTS == hr) 
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));
            
            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Attempt to create another Child IStorage with same name as existing
    // IStream above and STGM_FAILIFTHERE flag.

    if(S_OK == hr)
    {
        // This call should fail with STG_E_FILEALREADYEXISTS error.

        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE|
                STGM_FAILIFTHERE,
                &pvcnRootSecondChildStream);

        if(STG_E_FILEALREADYEXISTS == hr) 
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));

            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Attempt to create another Child IStorage with same name as existing
    // IStorage above and STGM_CREATE flag.

    if(S_OK == hr)
    {
        // This call should pass.

        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_CREATE,
                &pvcnRootSecondChildStream);

        if(S_OK == hr) 
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));
        }
    }

    // Now with the above IStream created and instantiated, attempt to create 
    // another Child IStream with same name as above which is both existing
    // and instantiated.  Should give STG_E_ACCESSDENIED error. 

    if(S_OK == hr)
    {
        // This call should give STG_E_ACCESSDENIED error.

        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                &pvcnRootThirdChildStream);

        if(STG_E_ACCESSDENIED == hr) 
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));
            
            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
    }

    // Close the pvcnRootSecondChildStream which is instantiated.

    if (S_OK == hr)
    {
        hr = pvcnRootSecondChildStream->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualStmNode::Close unsuccessful, hr =0x%lx."),
                hr));
        }
    }

    // Attempt to open a non existing IStorage/IStreams

    // Close the Root DocFile 

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::Close unsuccessful, hr =0x%lx."),
                hr));
        }
    }

    // Open the Root DocFile

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                pTestChanceDF->GetRootMode(),
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Open completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::Open unsuccessful, hr =0x%lx."),
                hr));
        }
    }

    if (S_OK == hr)
    {
        pRootStg = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pRootStg);
    }

    // Attempt to open a non existing IStorage.  This should give an error
    // STG_E_FILENOTFOUND

    if (S_OK == hr)
    {
        hr = pRootStg->OpenStorage(
                    OLESTR("Non-Existing"),
                    NULL,
                    pTestChanceDF->GetStgMode(),
                    NULL,
                    0,
                    &pNonExistingStg);

// ----------- flatfile change ---------------
        if(!StorageIsFlat())
        {
// ----------- flatfile change ---------------
        if(STG_E_FILENOTFOUND == hr) 
        {
            DH_TRACE(( DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));

            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
// ----------- flatfile change ---------------
        }
        else
        {
            if(E_NOTIMPL == hr)
            {
                DH_TRACE(( DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));

                hr  = S_OK;
            }
            else
            {
                DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

                if(S_OK == hr)
                {
                    hr = S_FALSE;
                }
            }
        }
// ----------- flatfile change ---------------
    }

    // Attempt to open a non existing IStream.  This should give an error
    // STG_E_FILENOTFOUND

    if (S_OK == hr)
    {
        hr = pRootStg->OpenStream(
                    OLESTR("Non-Existing"),
                    NULL,
                    STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                    0,
                    &pNonExistingStm);

        if(STG_E_FILENOTFOUND == hr) 
        {
            DH_TRACE(( DH_LVL_TRACE1, TEXT("hr = 0x%lx received as expected."), hr));

            hr  = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("Got unexpected hr = 0x%lx "), hr));

            if(S_OK == hr)
            {
                hr = S_FALSE;
            }
        }
    }

    // Close the Root DocFile Storage

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualCtrNode::Close completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::Close unsuccessful, hr =0x%lx."),
                hr));
        }
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation COMTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation COMTEST_102 failed, hr =0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:     COMTEST_103 
//
// Synopsis: Creates an IStream in the root docfile and writes a random number
//       of bytes then releases the IStream.  Creates an IStorage in the root
//       docfile and an IStream inside of the IStorage.  A random number of
//       bytes are written to the IStream, the IStream is released, and the
//       IStorage and root docfile are committed.  The IStream in the IStorage
//       is instantiated and the data is read and verified.  The IStorage and
//       contained IStream are released.  The IStream in the root docfile is
//       instantiated and the data is read and verified.  The IStream and
//       root docfile are then released.
//
//  Arguments:  [argc]
//              [argv]
//
//  Returns:    HRESULT
//
//  History:    29-May-1996     NarindK     Created.
//
// Notes:   This test runs in direct, transacted, and transacted deny write 
//          modes
//
// New Test Notes:
// 1.  Old File: LINORM.CXX
// 2.  Old name of test : LegitInstEnumNormal Test
//     New Name of test : COMTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-103
//        /dfRootMode:dirReadWriteShEx  /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-103
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-103
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// Conversion: COMTEST_103
//
//  BUGBUG: Use Random Commit modes
//-----------------------------------------------------------------------------

HRESULT COMTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pNewRootStmName         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    VirtualStmNode  *pvsnNewChildStream     = NULL;
    LPTSTR          pNewChildStmName        = NULL;
    LPTSTR          pwcsBuffer              = NULL;
    ULONG           culWritten              = 0;
    ULONG           cb                      = 0;
    ULONG           cRandomMinSize          = 10;
    ULONG           cRandomMaxSize          = 100;
    BOOL            fPass                   = TRUE;
    DWCRCSTM        dwCRC1;
    DWCRCSTM        dwMemCRC1;
    DWCRCSTM        dwCRC2;
    DWCRCSTM        dwMemCRC2;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("LINORM_1"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_103 started.")) );

    // Initialize CRC values to zero

    dwCRC1.dwCRCSum=dwCRC2.dwCRCSum=dwMemCRC1.dwCRCSum=dwMemCRC2.dwCRCSum=0;

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for COMTEST_103, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }

    //    Adds a new stream to a root storage.

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Generate a random name for Root's child IStream

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH, &pNewRootStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pNewRootStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx."),
            hr));
    }

    // Call VirtualStmNode::Write to create random bytes in the stream.  For
    // our test purposes, we generate a random string of size cb using
    // GenerateRandomString function.

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cb, cb, &pwcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }
    
    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream->Write(
                pwcsBuffer,
                cb, 
                &culWritten);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::Write function wasn't successful, hr =0x%lx."),
            hr));
    }


    // Calculate the CRC for stream name and data

    if(S_OK == hr)
    {
        hr = CalculateInMemoryCRCForStm(
                pvsnRootNewChildStream,
                pwcsBuffer,
                cb,
                &dwMemCRC1);

        DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStm")) ;
    }

    //   Close the stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr =0x%lx."),
            hr));
    }

    if(NULL != pwcsBuffer)
    {
        delete pwcsBuffer;
        pwcsBuffer = NULL;
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Generate a random name for Root's child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root.  

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode() |
                STGM_CREATE |
                STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::AddStorage not successful, hr =0x%lx."),
            hr));
    }


    // Adds a new stream to the new storage.  We would add a stream to
    // newly created substorage "NewTestStg" of our root storage for test.

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Generate a random name for Root's child IStorage's new child IStream

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH, &pNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pvcnRootNewChildStorage,
                pNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr =0x%lx."),
            hr));
    }


    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cb, cb, &pwcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    // Write into new stream

    if (S_OK == hr)
    {
        hr =  pvsnNewChildStream->Write(
                pwcsBuffer, 
                cb, 
                &culWritten);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::Write function wasn't successful, hr =0x%lx."),
            hr));
    }

    // Calculate the CRC for stream name and data

    if(S_OK == hr)
    {
        hr = CalculateInMemoryCRCForStm(
                pvsnNewChildStream,
                pwcsBuffer,
                cb,
                &dwMemCRC2);

        DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStm")) ;
    }

    //   Close the stream

    if (S_OK == hr)
    {
        hr = pvsnNewChildStream->Close();

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr =0x%lx."),
            hr));
    }


    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Commit(STGC_DEFAULT);
    }
    
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr =0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }
    
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr =0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
    }
    
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr =0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Open(
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Open unsuccessful, hr =0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = pvsnNewChildStream->Open(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE  ,
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Open unsuccessful, hr =0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ReadAndCalculateDiskCRCForStm(pvsnNewChildStream,&dwCRC2);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ReadAndCalculateDiskCRCForStm function successful.")));

        if(dwCRC2.dwCRCSum == dwMemCRC2.dwCRCSum)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's for pvsnNewChildStream match.")));

        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("CRC's for pvsnNewChildStream don't match.")));

            fPass = FALSE;
        }
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("ReadAndCalculateDiskCRCForStm unsuccessful, hr =0x%lx."),
            hr));
    }

    //   Close the stream

    if (S_OK == hr)
    {
        hr = pvsnNewChildStream->Close();

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr =0x%lx."),
            hr));
    }

    //   Close the storage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr =0x%lx."),
            hr));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Open(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE  ,
                0);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Open unsuccessful, hr =0x%lx."),
            hr));
    }

    // Read and verify
    
    if(S_OK == hr)
    {
        hr = ReadAndCalculateDiskCRCForStm(pvsnRootNewChildStream,&dwCRC1);
    }

    // Compare this CRC with in memory CRC

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ReadAndCalculateDiskCRCForStm function successful.")));

        if(dwCRC1.dwCRCSum == dwMemCRC1.dwCRCSum)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CRC's for pvsnRootNewChildStream match.")));

        }
        else
        {
            fPass = FALSE;

            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("CRC's for pvsnRootNewChildStream do not match.")));
        }
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("ReadAndCalculateDiskCRCForStm unsuccessful, hr =0x%lx."),
            hr));
    }
 
    //   Close the stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr =0x%lx."),
            hr));
    }

    //   Close the storage

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr =0x%lx."),
            hr));
    }

    // if all goes well till here, the test variation has passed successfully,
    // if not, then report failure.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation COMTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation COMTEST_103 failed, hr =0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    //Free buffer

    if(NULL != pwcsBuffer)
    {
        delete pwcsBuffer;
        pwcsBuffer = NULL;
    }

    // Delete strings

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if(NULL != pNewRootStmName)
    {
        delete pNewRootStmName;
        pNewRootStmName = NULL;
    }

    if(NULL != pNewChildStmName)
    {
        delete pNewChildStmName;
        pNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST-103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    COMTEST_104 
//
// Synopsis:Create a root docfile with a child IStorage and a child IStream.
//          Commit the root docfile.
//
//          Call QueryInterface on IID_IStorage created for IStorage and see if
//          succeeded to verify OLE COM Reflexive behaviour.  Then through
//          the interface obtained, query for IID_Imarshal from which query
//          for IUnknown and from that query for IID_IStorage.  This should 
//          pass verifying the Transitive behaiour of IStorage COM interface.  
//          Repeat for the child IStream.
//
//  Arguments:  [argc]
//              [argv]
//
//  Returns:    HRESULT
//
//  History:    8-Aug-1996     NarindK     Created.
//
//  Notes:   This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: STORAGE.CXX very briefly 
// 2.  Old name of test : ISTORAGE_TEST very briefly 
//     New Name of test : COMTEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-104
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-104
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-104
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// Conversion: COMTEST_104 NO. BUGBUG:IRootStg not supported by NSS yet. maybe later?
//
//-----------------------------------------------------------------------------


HRESULT COMTEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    ULONG           cb                      = 0;
    ULONG           cRandomMinSize          = 10;
    ULONG           cRandomMaxSize          = 100;
    ULONG           ulRef                   = 0;
    LPSTORAGE       pQueryChildStorage      = NULL;
    LPSTORAGE       pQueryMarshalStorage    = NULL;
    LPSTORAGE       pQueryUnknownStorage    = NULL;
    LPSTORAGE       pQueryRetChildStorage   = NULL;
    LPSTREAM        pQueryChildStream       = NULL;
    LPSTREAM        pQueryRetChildStream    = NULL;
    LPSTREAM        pQueryMarshalStream     = NULL;
    LPSTREAM        pQueryUnknownStream     = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("COMTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_104 started.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("QueryInterface tests on IStorage/IStream")) );

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for COMTEST_104, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.  

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE |
                STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    //    Adds a new stream to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStream);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx."),
            hr));
    }

    // Commit the root storage.

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Check Reflexive/Transitive behaviour for IStorage Interface

    // Do QueryInterface on child storage

    if(S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->QueryInterface(
                IID_IStorage,
                (LPVOID *) &pQueryChildStorage);     

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::QueryInterface")) ;
    }
   
    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pQueryChildStorage);

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::QueryInterface unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Query for IRootStorage from the above returned storage pointer, then
    // query through IRootStorage for IID_IUnknown.  From IUnknown, query for
    // IID_IStorage

    if(S_OK == hr) 
    {
        hr = pQueryChildStorage->QueryInterface( 
                IID_IMarshal,
                (LPVOID *) &pQueryMarshalStorage );
    }

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pQueryMarshalStorage);

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStorage::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStorage::QueryInterface unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Use the IMarshal interface to QueryInterface an IUnknown
    // interface.

    if(S_OK == hr)
    {
        hr = pQueryMarshalStorage->QueryInterface( 
                IID_IUnknown,
                (LPVOID *) &pQueryUnknownStorage );
    }

    // Use the IUnknown interface to QueryInterface an IStorage interface.

    if(S_OK == hr) 
    {
        DH_ASSERT(NULL != pQueryUnknownStorage);

        hr = pQueryUnknownStorage->QueryInterface(     
                IID_IStorage,
                (LPVOID *) &pQueryRetChildStorage );
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStorage:Reflexive/Transitive OLE COM behaviour passed.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStorage:Reflexive/Transitive COM behaviour fail,hr=0x%lx"),
            hr));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Check Reflexive/Transitive behaviour for IStream Interface

    // Do QueryInterface on child stream

    if(S_OK == hr)
    {
        hr = pvsnRootNewChildStream->QueryInterface(
                IID_IStream,
                (LPVOID *) &pQueryChildStream);     

        DH_HRCHECK(hr, TEXT("VirtualStmNode::QueryInterface")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::QueryInterface unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Query for IMarshal from the above returned storage pointer, then
    // query through IRootStream for IID_IUnknown.  From IUnknown, query for
    // IID_IStream
// --------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// --------- flatfile change ---------------

    if(S_OK == hr) 
    {
        hr = pQueryChildStream->QueryInterface( 
                IID_IMarshal,
                (LPVOID *) &pQueryMarshalStream );
    }

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pQueryMarshalStream);

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::QueryInterface unsuccessful, hr = 0x%lx."),
            hr));
    }
// --------- flatfile change ---------------
    }
    else
    if(S_OK == hr) 
    {
        hr = pQueryChildStream->QueryInterface( 
                IID_IStream,
                (LPVOID *) &pQueryMarshalStream );
    }

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pQueryMarshalStream);

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::QueryInterface completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::QueryInterface unsuccessful, hr = 0x%lx."),
            hr));
    }
// --------- flatfile change ---------------

    // Use the IRootStream interface to QueryInterface an IUnknown
    // interface.

    if(S_OK == hr)
    {
        hr = pQueryMarshalStream->QueryInterface( 
                IID_IUnknown,
                (LPVOID *) &pQueryUnknownStream );
    }

    // Use the IUnknown interface to QueryInterface an IStream interface.

    if(S_OK == hr) 
    {
        DH_ASSERT(NULL != pQueryUnknownStream);

        hr = pQueryUnknownStream->QueryInterface(     
                IID_IStream,
                (LPVOID *) &pQueryRetChildStream );
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream:Reflexive/Transitive OLE COM behaviour passed.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream:Reflexive/Transitive COM behaviour fail, hr=0x%lx"),
            hr));
    }

    // Clean up

    if(NULL != pQueryChildStorage)
    {
        ulRef = pQueryChildStorage->Release();
        DH_ASSERT(4 == ulRef);
        pQueryChildStorage = NULL;
    }

    if(NULL != pQueryMarshalStorage)
    {
        ulRef = pQueryMarshalStorage->Release();
        DH_ASSERT(3 == ulRef);
        pQueryMarshalStorage = NULL;
    }

    if(NULL != pQueryUnknownStorage)
    {
        ulRef = pQueryUnknownStorage->Release();
        DH_ASSERT(2 == ulRef);
        pQueryUnknownStorage = NULL;
    }

    if(NULL != pQueryRetChildStorage)
    {
        ulRef = pQueryRetChildStorage->Release();
        DH_ASSERT(1 == ulRef);
        pQueryRetChildStorage = NULL;
    }

    if(NULL != pQueryChildStream)
    {
        ulRef = pQueryChildStream->Release();
        DH_ASSERT(4 == ulRef);
        pQueryChildStream = NULL;
    }

    if(NULL != pQueryMarshalStream)
    {
        ulRef = pQueryMarshalStream->Release();
        DH_ASSERT(3 == ulRef);
        pQueryMarshalStream = NULL;
    }

    if(NULL != pQueryUnknownStream)
    {
        ulRef = pQueryUnknownStream->Release();
        DH_ASSERT(2 == ulRef);
        pQueryUnknownStream = NULL;
    }

    if(NULL != pQueryRetChildStream)
    {
        ulRef = pQueryRetChildStream->Release();
        DH_ASSERT(1 == ulRef);
        pQueryRetChildStream = NULL;
    }

// --------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// --------- flatfile change ---------------
    // Close the child storage

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }
// --------- flatfile change ---------------
    }
// --------- flatfile change ---------------

    // Close the child stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Close the root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation COMTEST_104 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation COMTEST_104 failed, hr = 0x%lx."), 
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootNewChildStgName)
    {
        delete pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    COMTEST-105
//
// Synopsis: A root docfile with a child storage and a child stream is created,
//           then check if Read/WriteClassStg and Read/WriteClassStm APIs work
//           correctly as expected. Also have some illegitmate tests by passing
//           invalid arguments to these APIs.           
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:  15-Aug-1996     JiminLi     Created.
//
// To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-105
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-105
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-105
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// Conversion: COMTEST_105
//
//-----------------------------------------------------------------------------

HRESULT COMTEST_105(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    VirtualStmNode  *pvsnRootNewChildStm    = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPSTORAGE       pRootStg                = NULL;
    LPSTORAGE       pChildStg               = NULL;
    LPSTREAM        pChildStm               = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          ptszStreamName          = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;
    ULONG           culWritten              = 0;
    ULONG           ulPosition              = 0;
    STATSTG         statStg;
    STATSTG         statStm;
    LARGE_INTEGER   liZero;
    LARGE_INTEGER   liStreamPos;
    ULARGE_INTEGER  uli;

    GUID TEST_CLSID = { 0x9c6e9ed0,
                        0xf701,
                        0x11cf,
                        {   0x98,
                            0x44,
                            0x00,
                            0xa0,
                            0xc9,
                            0x08,
                            0xe4,
                            0x6d }};
    CLSID           pclsid;


    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("COMTEST_105"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_105 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt legit and illegit tests on Read/WriteClassStg/Stm ")));

    pclsid = TEST_CLSID;

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        pRootStg = pVirtualDFRoot->GetIStoragePointer();

        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for COMTEST_105, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    // Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

// --------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// --------- flatfile change ---------------
    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                dwStgMode,
                &pvcnRootNewChildStg);

        pChildStg = pvcnRootNewChildStg->GetIStoragePointer();

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("AddStorage not successful, hr=0x%lx."),
            hr));
    }
// --------- flatfile change ---------------
    }
// --------- flatfile change ---------------

    // Add a child stream under root storage

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszStreamName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                ptszStreamName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnRootNewChildStm);
        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr && NULL != pvsnRootNewChildStm)
    {
        pChildStm = pvsnRootNewChildStm->GetIStreamPointer();
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    // Write a random stream to the stream, in order to test 
    // ReadClassStm later.

    if(S_OK == hr)
    {
        hr = pvsnRootNewChildStm->Write(
                ptszStreamName, 
                _tcslen(ptszStreamName), 
                &culWritten);

        DH_HRCHECK(hr, TEXT("IStream::Write")) ;
    }

    // Legit tests of Read/WriteClassStg on the root storage

    // First call Stat on root storage and check the CLSID of it.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    }

    if (S_OK != hr)
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
           hr));
    }

    if ((S_OK == hr) && (IsEqualCLSID(statStg.clsid, CLSID_NULL)))
    {
        DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("Root DocFile has CLSID_NULL as expected.")));

    }
    else
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("Root DocFile doesn't have CLSID_NULL unexpectedly.")));
    
        fPass = FALSE;
    }

    // Then call ReadClassStg to see if this API work correctly

    if (S_OK == hr)
    {
        hr = ReadClassStg(pRootStg, &pclsid);
    }

    if ((S_OK == hr) && (IsEqualCLSID(pclsid, CLSID_NULL)))
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("ReadClassStg returns CLSID_NULL as expected.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("ReadClassStg not return CLSID_NULL as expected. hr=0x%lx"),
            hr));

        fPass = FALSE;
    }

    // Now write the new CLSID into the root storage object

    if (S_OK == hr)
    {
        hr = WriteClassStg(pRootStg, TEST_CLSID);

        DH_HRCHECK(hr, TEXT("WriteClassStg"));
    }

    // Call Stat again to check if the above WriteClassStg and the next
    // ReadClassStg work correctly

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    }

    if (S_OK != hr)
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
           hr));
    }

    if ((S_OK == hr) && (IsEqualCLSID(statStg.clsid, TEST_CLSID)))
    {
        DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("Root DocFile has TEST_CLSID as expected.")));

    }
    else
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("Root DocFile doesn't have TEST_CLSID unexpectedly.")));
    
        fPass = FALSE;
    }

    if (S_OK == hr)
    {
        hr = ReadClassStg(pRootStg, &pclsid);
    }

    if ((S_OK == hr) && (IsEqualCLSID(pclsid, TEST_CLSID)))
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("ReadClassStg returns TEST_CLSID as expected.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("ReadClassStg not return TEST_CLSID as expected. hr=0x%lx"),
            hr));

        fPass = FALSE;
    }
 
// --------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// --------- flatfile change ---------------
    // Legit tests of Set/GetConvertStg on the child storage

    // First call Stat on root storage and check the CLSID of it.

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    }

    if (S_OK != hr)
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
           hr));
    }

    if ((S_OK == hr) && (IsEqualCLSID(statStg.clsid, CLSID_NULL)))
    {
        DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("Child Storage has CLSID_NULL as expected.")));

    }
    else
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("Child Storage doesn't have CLSID_NULL unexpectedly.")));
    
        fPass = FALSE;
    }

    // Then call ReadClassStg to see if this API work correctly

    if (S_OK == hr)
    {
        hr = ReadClassStg(pChildStg, &pclsid);
    }

    if ((S_OK == hr) && (IsEqualCLSID(pclsid, CLSID_NULL)))
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("ReadClassStg returns CLSID_NULL as expected.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("ReadClassStg not return CLSID_NULL as expected. hr=0x%lx"),
            hr));

        fPass = FALSE;
    }

    // Now write the new CLSID into the child storage object

    if (S_OK == hr)
    {
        hr = WriteClassStg(pChildStg, TEST_CLSID);

        DH_HRCHECK(hr, TEXT("WriteClassStg"));
    }

    // Call Stat again to check if the above WriteClassStg and the next
    // ReadClassStg work correctly

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    }

    if (S_OK != hr)
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("VirtualCtrNode::Stat unsuccessful, hr=0x%lx."),
           hr));
    }

    if ((S_OK == hr) && (IsEqualCLSID(statStg.clsid, TEST_CLSID)))
    {
        DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("Child Storage has TEST_CLSID as expected.")));

    }
    else
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("Child Storage doesn't have TEST_CLSID unexpectedly.")));
    
        fPass = FALSE;
    }

    if (S_OK == hr)
    {
        hr = ReadClassStg(pChildStg, &pclsid);
    }

    if ((S_OK == hr) && (IsEqualCLSID(pclsid, TEST_CLSID)))
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("ReadClassStg returns TEST_CLSID as expected.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("ReadClassStg not return TEST_CLSID as expected. hr=0x%lx"),
            hr));

        fPass = FALSE;
    }
// --------- flatfile change ---------------
    }
// --------- flatfile change ---------------
 
    // Illegit tests

    // Pass NULL as IStorage pointer, it should fail

#ifdef _MAC

        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("!!!!!!!!!!!!!!!!Invalid param testing skipped"),
            hr));

#else 
    
    if (S_OK == hr)
    {
        hr = WriteClassStg(NULL, TEST_CLSID);
    }

    if (E_INVALIDARG == hr)
    {       
        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("WriteClassStg did not return as expected, hr=0x%lx"),
            hr));

        fPass = FALSE;
    }

    if (S_OK == hr)
    {
        hr = ReadClassStg(NULL, &pclsid);

    }

    if (E_INVALIDARG == hr)
    {
        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("ReadClassStg did not return as expected, hr=0x%lx"),
            hr));

        fPass = FALSE;
    }
 
#endif //_MAC

    // Legit tests of Set/GetConvertStg on the child stream

    // First call Stat on child stream and check the CLSID of it.

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStm->Stat(&statStm, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Stat")) ;
    }

    if (S_OK != hr)
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("VirtualStmNode::Stat unsuccessful, hr=0x%lx."),
           hr));
    }

    if ((S_OK == hr) && (IsEqualCLSID(statStm.clsid, CLSID_NULL)))
    {
        DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("Child Stream has CLSID_NULL as expected.")));

    }
    else
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("Child Stream doesn't have CLSID_NULL unexpectedly.")));
    
        fPass = FALSE;
    }

    // Then call ReadClassStm to see if this API work correctly
    // Since ReadClassStm can only read the CLSID written previously by
    // WriteClassStm, it'll return STG_E_READFAULT in this case.

    if (S_OK == hr)
    {
        hr = ReadClassStm(pChildStm, &pclsid);
    }

    if (STG_E_READFAULT == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("ReadClassStm returns STG_E_READFAULT as expected.")));

        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("Err: ReadClassStm not return STG_E_READFAULT. hr=0x%lx"),
            hr));

        fPass = FALSE;
    }

    // Get the seek pointer before writing, then retore to this offset
    // when we want to ReadClassStm later.

    if (S_OK == hr)
    {
        LISet32(liZero, 0L);
        hr = pChildStm->Seek(liZero, STREAM_SEEK_CUR, &uli);

        ulPosition = ULIGetLow(uli);

        DH_HRCHECK(hr, TEXT("IStream::Seek"));
    }

    // Now write a new CLSID into stream

    if (S_OK == hr)
    {
        hr = WriteClassStm(pChildStm, TEST_CLSID);

        DH_HRCHECK(hr, TEXT("WriteClassStm"));
    }

    // Call Stat again to check if the above WriteClassStm and the next
    // ReadClassStm work correctly

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStm->Stat(&statStm, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::Stat")) ;
    }

    if (S_OK != hr)
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("VirtualStmNode::Stat unsuccessful, hr=0x%lx."),
           hr));
    }

    if ((S_OK == hr) && (IsEqualCLSID(statStg.clsid, TEST_CLSID)))
    {
        DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("Child Stream has TEST_CLSID as expected.")));

    }
    else
    {
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("Child Stream doesn't have TEST_CLSID unexpectedly.")));
    
        fPass = FALSE;
    }

    // Since ReadClassStm calls pstm->ReadAt(...) but not get CLSID from
    // pstm->Stat, basically it needs correct seek pointer, we need get it.
    
    if (S_OK == hr)
    {
        LISet32(liStreamPos, ulPosition);
        hr = pChildStm->Seek(liStreamPos, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek"));
    }

    if (S_OK == hr)
    {
        hr = ReadClassStm(pChildStm, &pclsid);
    }

    if ((S_OK == hr) && (IsEqualCLSID(pclsid, TEST_CLSID)))
    {
        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("ReadClassStm returns TEST_CLSID as expected.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("ReadClassStm not return TEST_CLSID as expected. hr=0x%lx"),
            hr));

        fPass = FALSE;
    }
 
    // Illegit tests

    // Pass NULL as IStream pointer, it should fail

#ifdef _MAC

        DH_TRACE((
            DH_LVL_ERROR, 
            TEXT("!!!!!!!!!!!!!!!!Invalid param testing skipped"),
            hr));

#else 
  
    if (S_OK == hr)
    {
        hr = WriteClassStm(NULL, TEST_CLSID);
    }

    if (E_INVALIDARG == hr)
    {       
        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("WriteClassStm did not return as expected, hr=0x%lx"),
            hr));

        fPass = FALSE;
    }

    if (S_OK == hr)
    {
        hr = ReadClassStm(NULL, &pclsid);
    }

    if (E_INVALIDARG == hr)
    {
        hr = S_OK;
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("ReadClassStm did not return as expected, hr = 0x%lx"),
            hr));

        fPass = FALSE;
    }

#endif //_MAC
    
    // Commit the root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release the child stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStm->Close();
        
        DH_HRCHECK(hr, TEXT("VirutalStmNode::Close"));
    }


// --------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// --------- flatfile change ---------------
    // Release child and root storages

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }
// --------- flatfile change ---------------
    }
// --------- flatfile change ---------------

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }
 
    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation COMTEST_105 passed.")) );
    }
    else if (4 == NTMAJVER()) //No fix bug in NT4.
    {
        DH_LOG((LOG_FAIL, TEXT("COMTEST_105 failed on NT4. Bug#54738")));
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation COMTEST_105 failed, hr = 0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings

    if (NULL != pRootNewChildStgName)
    {
        delete []pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if (NULL != ptszStreamName)
    {
        delete []ptszStreamName;
        ptszStreamName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_105 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    COMTEST-106
//
// Synopsis: Create a root docfile with a child storage and an IStream inside
//           of the child IStorage. Random data is written to the IStream and
//           the CRC is computed for the data. Then commit the child storage, 
//           verify the CRC of data, if it is correct, then commit the root 
//           storage, and again verify the CRC of data. First round passed in
//           STGC_DEFAULT, then change the IStream data, then repeat the above
//           commit process by passed in STGC_OVERWRITE. Finally, change the 
//           IStream data again, repeat the process for commit by passed in 
//           STGC_DANGEROUSLYCIMMITMERELYTODISKCACHE. 
//           
//           Since transacted tests contain more detail tests about Commit,
//           here just keep it simple in base tests. Also, STGC_ONLYIFCURRENT
//           is not test because it should be used in multiple users 
//           environment.
//
//           Only IStorage::Commit is tested, because IStream::Commit has no 
//           effect other than flushing internal memory buffers to the parent
//           storage object. It does not matter if commit changes to streams.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// History:  15-Aug-1996     JiminLi     Created.
//
// To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-106
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-106
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:0 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:COMTEST-106
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// Conversion: COMTEST_106
//
//-----------------------------------------------------------------------------

HRESULT COMTEST_106(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnRootNewChildStg    = NULL;
    VirtualCtrNode  *pstgCommitMe           = NULL;
    VirtualStmNode  *pvsnNewChildStm        = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    LPTSTR          ptcsBuffer              = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          ptszStreamName          = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    DWORD           dwOriginalCRC           = 0;
    DWORD           dwCommitCRC             = 0;
    BOOL            fRetry                  = TRUE;
    BOOL            fPass                   = TRUE;
    ULONG           culWritten              = 0;
    ULONG           ulPosition              = 0;
    ULONG           culRandIOBytes          = 0;
    ULONG           culRead                 = 0;
    LARGE_INTEGER   liZero;
    ULARGE_INTEGER  uliSize;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("COMTEST_106"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_106 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt legit and illegit tests on IStorage::Commit.")));


    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for COMTEST_106, Access mode: %lx"),
            dwRootMode));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        
        DH_ASSERT(NULL != pdgu) ;
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {


        pdgi = pTestVirtualDF->GetDataGenInteger();
        
        DH_ASSERT(NULL != pdgi) ;
    }

    // Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        // Generate random name for storage

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                dwStgMode,
                &pvcnRootNewChildStg);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("AddStorage not successful, hr=0x%lx."),
            hr));
    }

    // Add a child stream under the child storage

    if(S_OK == hr)
    {
        // Generate random name for stream

        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszStreamName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pvcnRootNewChildStg,
                ptszStreamName,
                0,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE |
                STGM_FAILIFTHERE,
                &pvsnNewChildStm);

        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream not successful, hr=0x%lx."),
            hr));
    }

    // Generate a random number culRandIOBytes

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu, 
                culRandIOBytes,
                culRandIOBytes, 
                &ptcsBuffer);
       
        DH_HRCHECK(hr, TEXT("GenerateRandomString"));
    }

    if (S_OK == hr)
    {
        hr =  pvsnNewChildStm->Write(
                ptcsBuffer,
                culRandIOBytes,
                &culWritten);
    }

    if(S_OK != hr) 
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
            hr));
    }

    // Calculate the CRC for stream data

    if (S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(
                ptcsBuffer,
                culRandIOBytes,
                &dwOriginalCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }

    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Test on STGC_DEFAULT

    pstgCommitMe = pvcnRootNewChildStg;

    while ((S_OK == hr) && (fRetry == TRUE))
    {
        hr = pstgCommitMe->Commit(STGC_DEFAULT);

        if (S_OK == hr)
        {   
            // verify IStream data after commit()

            // Allocate a buffer of required size
 
            ptcsBuffer = new TCHAR [culRandIOBytes];

            if (NULL == ptcsBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
            
            if (S_OK == hr)
            {
                LISet32(liZero, 0L);
                hr = pvsnNewChildStm->Seek(liZero, STREAM_SEEK_SET, NULL);

                DH_HRCHECK(hr, TEXT("IStream::Seek"));
            }

            if (S_OK == hr)
            {
                memset(ptcsBuffer, '\0', culRandIOBytes * sizeof(TCHAR));

                hr = pvsnNewChildStm->Read(
                       ptcsBuffer,
                       culRandIOBytes,
                       &culRead);
            }

            if ((S_OK != hr) || (culRead != culRandIOBytes))
            {
                DH_TRACE((
                    DH_LVL_ERROR,
                    TEXT("IStream::Read not successful, hr=0x%lx."),
                    hr));

                fPass = FALSE;
            }

            // Calculate the CRC for stream data

            if (S_OK == hr)
            {
                hr = CalculateCRCForDataBuffer(
                        ptcsBuffer,
                        culRandIOBytes,
                        &dwCommitCRC);

                DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
            }

            // Compare corresponding dwMemCRC and dwActCRC and verify

            if (S_OK == hr)
            {
                if (dwOriginalCRC != dwCommitCRC)
                {
                    DH_TRACE((
                        DH_LVL_ERROR,
                        TEXT("CRC's before/after commit unmatch.")));

                    fPass = FALSE;
                }
            }
            
            // Delete temp buffer

            if (NULL != ptcsBuffer)
            {
                delete []ptcsBuffer;
                ptcsBuffer = NULL;
            }

            // if child storage just commited ok, stay in loop and now 
            // commit root, otherwise set flag to terminate loop

            if ((fPass == TRUE) && (pstgCommitMe == pvcnRootNewChildStg))
            {
                pstgCommitMe = pVirtualDFRoot;
            }
            else
            {
                fRetry = FALSE;
            }
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("VirtualCtrNode::Commit failed. hr = 0x%lx"), 
                hr));

            break;
        }
    }

    // Now make some changes on IStream data, re-set the stream size to 
    // a new random size, then seek from beginning and rewrite the stream
    // data of the new size, and CRC it.

    // Generate a random number culRandIOBytes

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu, 
                culRandIOBytes,
                culRandIOBytes, 
                &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString"));
    }

    if (S_OK == hr)
    {
        ULISet32(uliSize, culRandIOBytes);
        hr = pvsnNewChildStm->SetSize(uliSize);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::SetSize"));
    }

    if (S_OK == hr)
    {
        LISet32(liZero, 0L);
        hr = pvsnNewChildStm->Seek(liZero, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek"));
    }

    if (S_OK == hr)
    {
        hr =  pvsnNewChildStm->Write(
                ptcsBuffer,
                culRandIOBytes,
                &culWritten);
    }

    if(S_OK != hr) 
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
            hr));
    }

    // Calculate the CRC for stream data

    if (S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(
                ptcsBuffer,
                culRandIOBytes,
                &dwOriginalCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }

    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Test on STGC_OVERWRITE

    pstgCommitMe = pvcnRootNewChildStg;

    while ((S_OK == hr) && (fRetry == TRUE))
    {
        hr = pstgCommitMe->Commit(STGC_OVERWRITE);

        if (S_OK == hr)
        {   
            // verify IStream data after commit()

            // Allocate a buffer of required size
 
            ptcsBuffer = new TCHAR [culRandIOBytes];

            if (NULL == ptcsBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
            
            if (S_OK == hr)
            {
                LISet32(liZero, 0L);
                hr = pvsnNewChildStm->Seek(liZero, STREAM_SEEK_SET, NULL);

                DH_HRCHECK(hr, TEXT("IStream::Seek"));
            }

            if (S_OK == hr)
            {
                memset(ptcsBuffer, '\0', culRandIOBytes * sizeof(TCHAR));

                hr = pvsnNewChildStm->Read(
                       ptcsBuffer,
                       culRandIOBytes,
                       &culRead);
            }

            if ((S_OK != hr) || (culRead != culRandIOBytes))
            {
                DH_TRACE((
                    DH_LVL_ERROR,
                    TEXT("IStream::Read not successful, hr=0x%lx."),
                    hr));

                fPass = FALSE;
            }

            // Calculate the CRC for stream data

            if (S_OK == hr)
            {
                hr = CalculateCRCForDataBuffer(
                        ptcsBuffer,
                        culRandIOBytes,
                        &dwCommitCRC);

                DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
            }

            // Compare corresponding dwMemCRC and dwActCRC and verify

            if (S_OK == hr)
            {
                if (dwOriginalCRC != dwCommitCRC)
                {
                    DH_TRACE((
                        DH_LVL_ERROR,
                        TEXT("CRC's before/after commit unmatch.")));

                    fPass = FALSE;
                }
            }
            
            // Delete temp buffer

            if (NULL != ptcsBuffer)
            {
                delete []ptcsBuffer;
                ptcsBuffer = NULL;
            }

            // if child storage just commited ok, stay in loop and now 
            // commit root, otherwise set flag to terminate loop

            if ((fPass == TRUE) && (pstgCommitMe == pvcnRootNewChildStg))
            {
                pstgCommitMe = pVirtualDFRoot;
            }
            else
            {
                fRetry = FALSE;
            }
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("VirtualCtrNode::Commit failed. hr = 0x%lx"), 
                hr));

            break;
        }
    }

    // Now again make some changes on IStream data, re-set the stream size 
    // to a new random size, then seek from beginning and rewrite the stream
    // data of the new size, and CRC it.

    // Generate a random number culRandIOBytes

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&culRandIOBytes, RAND_IO_MIN, RAND_IO_MAX);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = GenerateRandomString(
                pdgu, 
                culRandIOBytes,
                culRandIOBytes, 
                &ptcsBuffer);

        DH_HRCHECK(hr, TEXT("GenerateRandomString"));
    }

    if (S_OK == hr)
    {
        ULISet32(uliSize, culRandIOBytes);
        hr = pvsnNewChildStm->SetSize(uliSize);

        DH_HRCHECK(hr, TEXT("VirtualStmNode::SetSize"));
    }

    if (S_OK == hr)
    {
        LISet32(liZero, 0L);
        hr = pvsnNewChildStm->Seek(liZero, STREAM_SEEK_SET, NULL);

        DH_HRCHECK(hr, TEXT("IStream::Seek"));
    }

    if (S_OK == hr)
    {
        hr =  pvsnNewChildStm->Write(
                ptcsBuffer,
                culRandIOBytes,
                &culWritten);
    }

    if(S_OK != hr) 
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("IStream::Write function wasn't successful, hr=0x%lx."),
            hr));
    }

    // Calculate the CRC for stream data

    if (S_OK == hr)
    {
        hr = CalculateCRCForDataBuffer(
                ptcsBuffer,
                culRandIOBytes,
                &dwOriginalCRC);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
    }

    // Delete temp buffer

    if (NULL != ptcsBuffer)
    {
        delete []ptcsBuffer;
        ptcsBuffer = NULL;
    }

    // Test on STGC_OVERWRITE

    pstgCommitMe = pvcnRootNewChildStg;

    while ((S_OK == hr) && (fRetry == TRUE))
    {
        hr = pstgCommitMe->Commit(STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE);

        if (S_OK == hr)
        {   
            // verify IStream data after commit()

            // Allocate a buffer of required size
 
            ptcsBuffer = new TCHAR [culRandIOBytes];

            if (NULL == ptcsBuffer)
            {
                hr = E_OUTOFMEMORY;
            }
            
            if (S_OK == hr)
            {
                LISet32(liZero, 0L);
                hr = pvsnNewChildStm->Seek(liZero, STREAM_SEEK_SET, NULL);

                DH_HRCHECK(hr, TEXT("IStream::Seek"));
            }

            if (S_OK == hr)
            {
                memset(ptcsBuffer, '\0', culRandIOBytes * sizeof(TCHAR));

                hr = pvsnNewChildStm->Read(
                       ptcsBuffer,
                       culRandIOBytes,
                       &culRead);
            }

            if ((S_OK != hr) || (culRead != culRandIOBytes))
            {
                DH_TRACE((
                    DH_LVL_ERROR,
                    TEXT("IStream::Read not successful, hr=0x%lx."),
                    hr));

                fPass = FALSE;
            }

            // Calculate the CRC for stream data

            if (S_OK == hr)
            {
                hr = CalculateCRCForDataBuffer(
                        ptcsBuffer,
                        culRandIOBytes,
                        &dwCommitCRC);

                DH_HRCHECK(hr, TEXT("CalculateCRCForDataBuffer"));
            }

            // Compare corresponding dwMemCRC and dwActCRC and verify

            if (S_OK == hr)
            {
                if (dwOriginalCRC != dwCommitCRC)
                {
                    DH_TRACE((
                        DH_LVL_ERROR,
                        TEXT("CRC's before/after commit unmatch.")));

                    fPass = FALSE;
                }
            }
            
            // Delete temp buffer

            if (NULL != ptcsBuffer)
            {
                delete []ptcsBuffer;
                ptcsBuffer = NULL;
            }

            // if child storage just commited ok, stay in loop and now 
            // commit root, otherwise set flag to terminate loop

            if ((fPass == TRUE) && (pstgCommitMe == pvcnRootNewChildStg))
            {
                pstgCommitMe = pVirtualDFRoot;
            }
            else
            {
                fRetry = FALSE;
            }
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("VirtualCtrNode::Commit failed. hr = 0x%lx"), 
                hr));

            break;
        }
    }

    // Release the child stream

    if (S_OK == hr)
    {
        hr = pvsnNewChildStm->Close();

        DH_HRCHECK(hr, TEXT("VirutalStmNode::Close"));
    }

    // Release child and root storages

    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStg->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }
 
    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation COMTEST_106 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation COMTEST_106 failed, hr = 0x%lx."),
            hr) );
        // test failed. make sure it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings

    if (NULL != pRootNewChildStgName)
    {
        delete []pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    if (NULL != ptszStreamName)
    {
        delete []ptszStreamName;
        ptszStreamName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation COMTEST_106 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\apitests.cxx ===
/-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       apitests.cxx
//
//  Contents:  storage base tests basically pertaining to API tests in general. 
//
//  Functions:  
//
//  History:    18-June-1996    NarindK     Created.
//              27-Mar-97       SCousens    conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include <sys/stat.h>
#include <share.h>

#include  "init.hxx"

// undo the affects of the wrapper. We need to test the actual APIs here,
// not what we think we should be calling to test docfile/nssfiles.
#undef StgCreateDocfile
#undef StgOpenStorage

// CheckErrorTest macros. 
// These check the return value to an invalid api call. 
// These must remain as #defines as we change local variables.
#define CheckErrorTest(err, msg, pstg)     \
    DH_ASSERT (NULL == pstg);              \
    hr = DH_HRERRORCHECK (hr, err, msg);   \
    if ((S_OK != hr) || (NULL != pstg))    \
    {                                      \
        fPass = FALSE;                     \
        hr = S_OK;                         \
    }                                      \
    // release it if we accidentally got one \
    if (NULL != pstg)                      \
    {                                      \
        pstg->Release ();                  \
        pstg = NULL;                       \
    }

#define CheckErrorTest2(err, msg)          \
    hr = DH_HRERRORCHECK (hr, err, msg);   \
    if (S_OK != hr)                        \
    {                                      \
        fPass = FALSE;                     \
        hr = S_OK;                         \
    }


//----------------------------------------------------------------------------
//
// Test:    APITEST_100 
//
// Synopsis: This test attempts various operations on StgCreateDocFile, Stg
//           OpenStorage API's 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
//  History:    18-June-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: IAPISTG.CXX
// 2.  Old name of test : IllegitAPIStg test 
//     New Name of test : APITEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-100
//        /dfRootMode:dirReadWriteShEx /dfname:APITEST.100 /labmode
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-100
//        /dfRootMode:xactReadWriteShEx /dfname:APITEST.100 /labmode
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfname:APITEST.100 /labmode
//
// BUGNOTE: Conversion: APITEST-100 NO
// 
//-----------------------------------------------------------------------------


HRESULT APITEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode              = NULL;
    LPSTORAGE       pIStorage               = NULL;
    LPSTORAGE       pIStorageOpen           = NULL;
    LPOLESTR        pOleStrTemp             = NULL;
    TCHAR           tszTestName[10]         = TEXT("NonExist");
    LPOLESTR        pOleStrTest             = NULL;
    SNB             snbTest                 = NULL;
    SNB             snbTemp                 = NULL;
    ULONG           ulRef                   = 0;
    OLECHAR         *ocsSNBChar             = NULL;
    ULONG           i                       = 0;
    BOOL            fPass                   = TRUE;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
     TEXT("Attempt illegitimate ops on StgCreateDocFIle & StgOpenStorage.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new ChanceDF")) ;
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);
        DH_HRCHECK(hr, TEXT("ChanceDF::CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for APITEST_100, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get RootDocFile name

    if (S_OK == hr)
    {
        if(NULL != pTestChanceDF->GetDocFileName())
        {
            pRootDocFileName =
                new TCHAR[_tcslen(pTestChanceDF->GetDocFileName())+1];

            if (pRootDocFileName == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                _tcscpy(pRootDocFileName, pTestChanceDF->GetDocFileName());
            }
            DH_HRCHECK(hr, TEXT("new TCHAR"));
        }
        DH_HRCHECK(hr, TEXT("ChanceDF::GetDocFileName")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR
        hr = TStringToOleString(pRootDocFileName, &pOleStrTemp);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Try calling StgCreateDocFile with mode STGM_CREATE|STGM_CONVERT

    if (S_OK == hr)
    {
        pIStorage = NULL;
        hr = StgCreateDocfile(
                pOleStrTemp,
                STGM_CREATE | STGM_CONVERT,
                0,
                &pIStorage);
        CheckErrorTest(STG_E_INVALIDFLAG, 
                TEXT ("StgCreateDocfile inv Flags"),
                pIStorage);
    }

    // Try calling StgCreateDocFile with mode equal to -1 
    if (S_OK == hr)
    {
        pIStorage = NULL;
        hr = StgCreateDocfile(
                pOleStrTemp,
                (DWORD) -1, 
                0,
                &pIStorage);
        CheckErrorTest(STG_E_INVALIDFLAG, 
                TEXT ("StgCreateDocfile inv mode"),
                pIStorage);
    }

    // Try calling StgCreateDocFile with nonzero reserved parameter 
    if (S_OK == hr)
    {
        pIStorage = NULL;
        hr = StgCreateDocfile(
                pOleStrTemp,
                STGM_CREATE | dwRootMode,
                (DWORD)999, 
                &pIStorage);
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("StgCreateDocfile inv reserved"),
                pIStorage);
    }

    // Try calling StgCreateDocFile with NULL ppstgOpen parameter 4th 

    if (S_OK == hr)
    {
        hr = StgCreateDocfile(
                pOleStrTemp,
                dwRootMode, 
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER, 
                TEXT ("StgCreateDocfile inv ppstg bucket"));
    }

    // Now create a valid DocFile

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new VirtualDF")) ;
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::GenerateVirtualDF")) ;
    }

    // Now try commiting with grfCommitFlags = -1
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit((DWORD) -1);
        CheckErrorTest2(STG_E_INVALIDFLAG, 
                TEXT ("VirtualCtrNode::Commit inv flag"));
    }

    // Now do a valid commit
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // Instantiate DocFile with grfMode=-1 
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                (DWORD) -1,
                NULL,
                0,
                &pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDFLAG, 
                TEXT ("StgOpenStorage inv mode"),
                pIStorageOpen);
    }

    // Instantiate DocFile with name as " " 
    // NOTE: The old test checked the erro value to be STG_E_FILENOTFOUND in 
    // this case.  On NT, we get STG_E_PATHNOTFOUND and on Chicago, we get
    // STG_E_ACCESSDENIED, so let us check against S_OK itself.

    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                (OLECHAR *) " ",
                NULL,
                dwRootMode,
                NULL,
                0,
                &pIStorageOpen);

        if (RunningOnNT())
        {
            CheckErrorTest(STG_E_PATHNOTFOUND, 
                    TEXT("StgOpenStorage inv name"), 
                    pIStorageOpen);
        }
        else
        {
            CheckErrorTest(STG_E_ACCESSDENIED, 
                    TEXT("StgOpenStorage inv name"),
                    pIStorageOpen);
        }
    }

    // Instantiate DocFile with nonexisting file name
    if(S_OK == hr)
    {
        // Convert tszTestName  to OLECHAR
        hr = TStringToOleString(tszTestName, &pOleStrTest);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                pOleStrTest,
                NULL,
                dwRootMode,
                NULL,
                0,
                &pIStorageOpen);
        CheckErrorTest(STG_E_FILENOTFOUND, 
                TEXT ("StgOpenStorage inv name"),
                pIStorageOpen);
    }

    // Instantiate DocFile with NULL file name
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                NULL,
                NULL,
                dwRootMode,
                NULL,
                0,
                &pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDNAME, 
                TEXT ("StgOpenStorage NULL name"),
                pIStorageOpen);
    }

    // Instantiate DocFile with non zero dwReserved parameter
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                dwRootMode,
                NULL,
                999,
                &pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("StgOpenStorage inv reserved"),
                pIStorageOpen);
    }

    // Instantiate DocFile with NULL ppstgOpen parameter (6th)
    if (S_OK == hr)
    {
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                dwRootMode,
                NULL,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER, 
                TEXT ("StgOpenStorage NULL ppstg"));
    }

    // Instantiate DocFile with grfMode as dwRootMode|STGM_DELETEONRELEASE 
    // NOTE: The doc says, erro code in this case to be STG_E_INVALIDFUNCTION,
    // but error STG_E_INVALIDFLAG returned.

    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                dwRootMode | STGM_DELETEONRELEASE,
                NULL,
                0,
                &pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDFUNCTION, 
                TEXT ("StgOpenStorage DELETEONRELEASE in mode"),
                pIStorageOpen);
    }

    // Create snbTest with spcae for two names and set name list to NULL i.e.
    // a vaild SNB with no name in the block
    if(S_OK == hr)
    {
        snbTest = (OLECHAR **) new OLECHAR [sizeof(OLECHAR *) * 2];
        if(NULL == snbTest)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            *snbTest = NULL;
        }
        DH_HRCHECK (hr, TEXT("new OLECHAR"));
    }

    // Instantiate DocFile with above empty but valid SNB 
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                dwRootMode,
                snbTest,
                0,
                &pIStorageOpen);
       DH_HRCHECK(hr, TEXT("StgOpenStorage empty SNB")) ;

        // Release the pointer
        if(NULL != pIStorageOpen)
        {
            ulRef = pIStorageOpen->Release();
            DH_ASSERT (0 == ulRef);
            pIStorageOpen = NULL;
        }
    }

    // Allocate space for long name  and fill name with
    // X's, make next SNB elment NULL, and make a call to StgOpenStorage API
    // with too long a name in SNB

    if(S_OK == hr)
    {
        *snbTest = (OLECHAR *) new OLECHAR [MAX_STG_NAME_LEN*12];
        if (NULL == *snbTest)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new OLECHAR"));
    }

    if(S_OK == hr)
    {
        snbTemp = snbTest;
        ocsSNBChar = *snbTemp;

        for (i=0; i<( MAX_STG_NAME_LEN*12 -1); i++)
        {
            ocsSNBChar[i] = 'X';
        }
        ocsSNBChar[i] = '\0';
 
        // Assign second element as NULL
        snbTemp++; 
        *snbTemp = NULL;
    }
 
    // Instantiate DocFile with above SNB with too long a name in it. 
    // NOTE: In the old test, this was supposed to fail.  Doesn't fail
    // now... Confirmed with Philipla - No length verification of SNB 
    // names done in ValidateSNB in OLE 

    if (S_OK == hr)
    {
        pIStorageOpen = NULL;
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                dwRootMode,
                snbTest,
                0,
                &pIStorageOpen);
        DH_HRCHECK (hr, TEXT("StgOpenStorage long SNB"));

        //Release storage pointer
        if(NULL != pIStorageOpen)
        {
            ulRef = pIStorageOpen->Release();
            DH_ASSERT (0 == ulRef);
            pIStorageOpen = NULL;
        }
    }

    // if something did no pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }


    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_100 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation APITEST_100 failed; hr=%#lx; fPass=%d"),
            hr,
            fPass));
    }

    // Cleanup

    // Delete Chance docfile tree
    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());
        DH_HRCHECK(hr2, TEXT("ChanceDF::DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree
    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);
        DH_HRCHECK(hr2, TEXT("VirtualDF::DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the docfile on disk
    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;
            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings
    if(NULL != pOleStrTemp)
    {
        delete []pOleStrTemp;
        pOleStrTemp = NULL;
    }

    if(NULL != pOleStrTest)
    {
        delete []pOleStrTest;
        pOleStrTest = NULL;
    }

    if(NULL != pRootDocFileName)
    {
        delete []pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Free SNB 
    if(NULL != snbTest)
    {
        if(NULL != *snbTest)
        {
            delete [] *snbTest;
            *snbTest = NULL;
        }
        delete [] snbTest;
        snbTest = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    APITEST_101 
//
// Synopsis: The test attempts various illegitimate operations using names
//       greater than MAX_STG_NAME_LEN, it then attempts to create
//       several random named root docfiles.  If the create is succesful,
//       then a random named child IStorage or IStream is also created.
//       Whether or not the root create was successful, we attempt to
//       open the root docfile (this is expected to fail, the point is
//       to check for asserts/GP faults rather than return codes).  If
//       the instantiation is successful, the test also tries to
//       instantiate the child object.  All objects are then released.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IANAMES.CXX
// 2.  Old name of test : IllegitAPINames test 
//     New Name of test : APITEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-101
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-101
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-101
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: APITEST-101 NO
//
//-----------------------------------------------------------------------------

HRESULT APITEST_101(int argc, char *argv[])
{
#ifdef _MAC  // Simple mode not ported yet; check with the developers    
             // and remove this when ready

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!!!APITEST-101 crashes.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;
    LPOLESTR        poszBadName             = NULL;
    LPOLESTR        poszBadNameStg          = NULL;
    LPTSTR          ptszBadNameStg          = NULL;
    DWORD           dwRootMode              = 0;
    ULONG           i                       = 0;
    LPSTORAGE       pIStorage               = NULL;
    LPSTORAGE       pIStorageChild          = NULL;
    LPSTREAM        pIStreamChild           = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    BOOL            fPass                   = TRUE;
 
    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
            TEXT("Call StgCreateDocFile/CreateStorage/CreateStream with too long names")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.
    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new ChanceDF")) ;
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);
        DH_HRCHECK(hr, TEXT("ChanceDF::CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for APITEST_101, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Call StgCreateDocFile with too long a name for docfile.
    // NOTE: Old test to fail with MAX_STG_NAME_LEN*3, but not in new test,
    // fails with MAX_STG_NAME_LEN*4.
    // NOTE: Crashes in DfFromName in OLE if length is of MAX_STG_NAME_LEN*8
    // CHECK!!!

    if(S_OK == hr)
    {
        poszBadName = (OLECHAR *) new OLECHAR [MAX_STG_NAME_LEN*4];
        if (NULL == poszBadName)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new OLECHAR")) ;
    }

    if(S_OK == hr)
    {
        for (i=0; i<( MAX_STG_NAME_LEN*4 -1); i++)
        {
            poszBadName[i] = i%20 + OLECHAR('A');
        }
        poszBadName[i] = OLECHAR('\0');
    }

    // Try calling StgCreateDocFile with the above long name pszBadName 
    if (S_OK == hr)
    {
        pIStorage = NULL;
        DH_TRACE ((DH_LVL_TRACE4, TEXT("Filename:%s"), poszBadName)); //BUGBUG - work on chicago?
        hr = StgCreateDocfile(
                poszBadName,
                dwRootMode | STGM_CREATE, 
                0,
                &pIStorage);
        CheckErrorTest(STG_E_PATHNOTFOUND, 
                TEXT ("StgCreateDocfile long name"),
                pIStorage);
    }

    // Now create a valid DocFile

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  
    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new VirtualDF")) ;
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);
        DH_HRCHECK(hr, TEXT("VirtualDF::GenerateVirtualDF")) ;
    }

    // Get IStorage pointer
    if (S_OK == hr)
    {
        pIStorage = pVirtualDFRoot->GetIStoragePointer();
        DH_ASSERT (NULL != pIStorage);
        if (NULL == pIStorage)
        {
            hr = E_FAIL;
        }
    }

    // Call CreateStorage with too long a name for docfile.
    if(S_OK == hr)
    {
        ptszBadNameStg = (TCHAR *) new TCHAR [MAX_STG_NAME_LEN*3];
        if (NULL == ptszBadNameStg)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new TCHAR")) ;
    }

    if(S_OK == hr)
    {
        for (i=0; i<( MAX_STG_NAME_LEN*3 -1); i++)
        {
            ptszBadNameStg[i] = TEXT('Y');
        }
        ptszBadNameStg[i] = TEXT('\0');
    }

    if(S_OK == hr)
    {
        // Convert Bad storage name to OLECHAR
        hr = TStringToOleString(ptszBadNameStg, &poszBadNameStg);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // now call CreateStorage with too long a name...
    if (S_OK == hr)
    {
        hr = pIStorage->CreateStorage(
                poszBadNameStg,
                pTestChanceDF->GetStgMode(),
                0,
                0,
                &pIStorageChild);
        CheckErrorTest(STG_E_INVALIDNAME, 
                TEXT ("IStorage::CreateStorage long name"),
                pIStorageChild);
    }

    // Now call CreateStream with too long a name...
    if (S_OK == hr)
    {
        hr = pIStorage->CreateStream(
                poszBadNameStg,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &pIStreamChild);
        CheckErrorTest(STG_E_INVALIDNAME, 
                TEXT ("IStorage::CreateStream long name"),
                pIStreamChild);
    }

    // Now add a Valid storage to root.  Call AddStorage that in turns calls
    // CreateStorage
    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.
    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE | STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);
        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    // Now try to rename this storage element to a bad name.
    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDNAME);
        hr = pvcnRootNewChildStorage->Rename(ptszBadNameStg);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest2(STG_E_INVALIDNAME, 
                TEXT ("VirtualCtrNode::Rename long name"));
    }

    // Close the Storage pvcnRootNewChildStorage 
    if (NULL != pvcnRootNewChildStorage)
    {
        hr2 = pvcnRootNewChildStorage->Close();
        DH_HRCHECK(hr2, TEXT("VirtualCtrNode::Close")) ;
        hr = FirstError (hr, hr2);
    }

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK(hr2, TEXT("VirtualCtrNode::Close")) ;
        hr = FirstError (hr, hr2);
    }

    // Delete temp strings
    if(NULL != poszBadNameStg)
    {
        delete [] poszBadNameStg;
        poszBadNameStg = NULL;
    }

    if(NULL != poszBadName)
    {
        delete [] poszBadName;
        poszBadName = NULL;
    }

    if(NULL != ptszBadNameStg)
    {
        delete [] ptszBadNameStg;
        ptszBadNameStg = NULL;
    }

    if(NULL != pRootNewChildStgName)
    {
        delete [] pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // In the following section of test:
    //make a random number of random length, random character root
    //docfiles.  for this variation, we don't care if the operation
    //succeeds, looking for GP faults and asserts only.  if the
    //StgCreateDocfile fails, we'll still attempt the open.  of
    //course, the open in this case will be expected to fail, but
    //again, we won't be checking return codes... If the StgCreateDocfile
    //passes, we'll create a random name IStream or IStorage too.

    ULONG       count               =   0;    
    ULONG       cMinNum             =   16;    
    ULONG       cMaxNum             =   128;
    LPTSTR      ptszRandomRootName  =   NULL;  
    LPTSTR      ptszRandomChildName =   NULL;  
    ULONG       countFlag           =   0;    
    ULONG       cMinFlag            =   0;    
    ULONG       cMaxFlag            =   100;
    ULONG       nChildType          =   0;
    LPSTORAGE   pstgRoot            =   NULL; 
    LPSTORAGE   pstgChild           =   NULL; 
    LPSTREAM    pstmChild           =   NULL; 
    LPOLESTR    poszRandomRootName  =   NULL;
    LPOLESTR    poszRandomChildName =   NULL;
    ULONG       ulRef               =   0;

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&count, cMinNum, cMaxNum);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    while(count--)
    {
        if(S_OK == hr)
        {
            hr=GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszRandomRootName);
            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if(S_OK == hr)
        {
            // Convert name to OLECHAR
            hr = TStringToOleString(ptszRandomRootName, &poszRandomRootName);
            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        if (S_OK == hr)
        {
            pstgRoot = NULL;

            hr = StgCreateDocfile(
                    poszRandomRootName,
                    dwRootMode | STGM_CREATE,
                    0,
                    &pstgRoot);
            DH_HRCHECK(hr, TEXT("StgCreateDocfile")) ;
        }

        nChildType = NONE;

        if(S_OK == hr)
        {
            if(S_OK == hr)
            {
                hr=GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH, 
                    &ptszRandomChildName);
                DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
            }

            if(S_OK == hr)
            {
                // Convert name to OLECHAR
                hr = TStringToOleString(
                        ptszRandomChildName, 
                        &poszRandomChildName);
                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            if(S_OK == hr)
            {
                hr = pdgi->Generate(&countFlag, cMinFlag, cMaxFlag);
                DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
            }

            if(countFlag > (cMaxFlag/2))
            {
                hr = pstgRoot->CreateStorage(
                        poszRandomChildName,
                        pTestChanceDF->GetStgMode(),
                        0,
                        0,
                        &pstgChild);
                DH_HRCHECK(hr, TEXT("IStorage::CreateStorage")) ;

                if(S_OK == hr)
                {
                    nChildType = STORAGE;
                    hr = pstgRoot->Commit(STGC_DEFAULT);
                    DH_HRCHECK(hr, TEXT("IStorage::Commit")) ;
                    ulRef = pstgChild->Release();
                    DH_ASSERT (0 == ulRef);
                    pstgChild = NULL;
                }
            }
            else
            {
                hr = pstgRoot->CreateStream(
                        poszRandomChildName,
                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                        0,
                        0,
                        &pstmChild);   
                DH_HRCHECK(hr, TEXT("IStorage::CreateStream")) ;
 
                if(S_OK == hr)
                {
                    nChildType = STREAM;
                    hr = pstgRoot->Commit(STGC_DEFAULT);
                    DH_HRCHECK(hr, TEXT("IStorage::Commit")) ;
                    ulRef = pstmChild->Release();   
                    DH_ASSERT (0 == ulRef);
                    pstmChild = NULL;
                }
            }

            ulRef = pstgRoot->Release();   
            DH_ASSERT (0 == ulRef);     
            pstgRoot = NULL;
        }
        
        //Try to open Root Storage whetehr the creation was successful or not
        
        hr = StgOpenStorage(
                poszRandomRootName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pstgRoot);
        DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;

        if(S_OK == hr)
        {
            switch(nChildType)
            {
                case STORAGE:
                    {
                        hr = pstgRoot->OpenStorage(
                                poszRandomChildName,
                                NULL, 
                                pTestChanceDF->GetStgMode(),
                                NULL,
                                0,
                                &pstgChild);      
                        DH_HRCHECK(hr, TEXT("IStorage::OpenStorage")) ;
 
                        if(S_OK == hr)
                        {
                            ulRef = pstgChild->Release();
                            DH_ASSERT (0 == ulRef);
                            pstgChild = NULL;
                        }
                    
                        break; 
                    }
                case STREAM:
                    {
                        hr = pstgRoot->OpenStream(
                                poszRandomChildName,
                                NULL, 
                                STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                0,
                                &pstmChild);      
                        DH_HRCHECK(hr, TEXT("IStorage::OpenStream")) ;
 
                        if(S_OK == hr)
                        {
                            ulRef = pstmChild->Release();
                            DH_ASSERT (0 == ulRef);
                            pstmChild = NULL;
                        }
                    
                        break; 
                    }
            }
            ulRef = pstgRoot->Release();
            DH_ASSERT (0 == ulRef);
            pstgRoot = NULL;
        }    

        // Delete temp strings
        if(NULL != ptszRandomChildName)
        {
            delete [] ptszRandomChildName;
            ptszRandomChildName = NULL;
        }

        if(NULL != ptszRandomRootName)
        {
            if(FALSE == DeleteFile(ptszRandomRootName))
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;
                DH_HRCHECK(hr, TEXT("DeleteFile")) ;
            }

            delete [] ptszRandomRootName;
            ptszRandomRootName = NULL;
        }

        if(NULL != poszRandomChildName)
        {
            delete [] poszRandomChildName;
            poszRandomChildName = NULL;
        }

        if(NULL != poszRandomChildName)
        {
            delete [] poszRandomChildName;
            poszRandomChildName = NULL;
        }
    }

    // if something did no pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }


    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
                TEXT("Test variation APITEST_101 failed; hr=%#lx; fPass=%d"),
                hr,
                fPass));
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file
    if(NULL != pTestVirtualDF)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];
        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree
    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());
        DH_HRCHECK(hr2, TEXT("ChanceDF::DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree
    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);
        DH_HRCHECK(hr2, TEXT("VirtualDF::DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the docfile on disk
    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;
            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings

    if(NULL != pFileName)
    {
        delete []pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}


//----------------------------------------------------------------------------
//
// Test:    APITEST_102 
//
// Synopsis: Attempts various operations in obtaining enumerators, checking
//       for proper error return.  Then gets a valid enumerator, and
//       attempts various illegitimate method calls on it.  Verify
//       proper return codes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IAENUM.CXX
// 2.  Old name of test : IllegitAPIEnum test 
//     New Name of test : APITEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-102
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx /labmode
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-102
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /labmode
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-102
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /labmode
//
// BUGNOTE: Conversion: APITEST_102
//-----------------------------------------------------------------------------

HRESULT APITEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPENUMSTATSTG   penumWalk               = NULL;
    ULONG           cMinNum                 = 1;
    ULONG           cMaxNum                 = 999;
    DWORD           dwReserved1             = 0;
    DWORD           dwReserved3             = 0;
    LPTSTR          pReserved2              = NULL;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;
    STATSTG         statStg;
    ULONG           celtFetched             = 0;
    LPMALLOC        pMalloc                 = NULL;
 
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Attempt different illegitimate opeations on IEnumSTATSTG. ")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }


    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for APITEST_102, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    //    Adds a new storage to the root storage.

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE |
                STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);
        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

    // Close the Child storage
    if (NULL != pvcnRootNewChildStorage)
    {
        hr2 = pvcnRootNewChildStorage->Close();
        DH_HRCHECK(hr2, TEXT("VirtualCtrNode::Close")) ;
        hr = FirstError (hr, hr2);
    }

    // Get the random number generator
    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&dwReserved1, cMinNum, cMaxNum);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    //Call EnumElements with invalid parameters
    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPARAMETER);
        hr =  pVirtualDFRoot->EnumElements(
                dwReserved1,
                pReserved2,
                dwReserved3,
                &penumWalk);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("VirtualCtrNode::EnumElements inv dwReserved1"),
                penumWalk);
    }

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&dwReserved3, cMinNum, cMaxNum);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPARAMETER);
        hr =  pVirtualDFRoot->EnumElements(
                dwReserved1,
                pReserved2,
                dwReserved3,
                &penumWalk);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("VirtualCtrNode::EnumElements inv dwReserved3"),
                penumWalk);
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH, &pReserved2);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPARAMETER);
        hr =  pVirtualDFRoot->EnumElements(
                dwReserved1,
                pReserved2,
                dwReserved3,
                &penumWalk);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("VirtualCtrNode::EnumElements inv pvReserved1"),
                penumWalk);
   }

    // Now call EnumElements with NULL ppenm 4th parameter.
    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPOINTER);
        hr =  pVirtualDFRoot->EnumElements( 0, NULL, 0, NULL);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest2(STG_E_INVALIDPOINTER, 
                TEXT ("VirtualCtrNode::EnumElements NULL ppEnum"));
    }

    // Make a valid call to EnumElements now
    if(S_OK == hr)
    {
        hr =  pVirtualDFRoot->EnumElements( 0, NULL, 0, &penumWalk);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
        DH_ASSERT (NULL != penumWalk);
    }

    // Now try the following skip calls - Attempt to skip 0 elements and 
    // attempt to skip MAX_ULONG elements.

    // Attempt to Skip 0 elements.
    if(S_OK == hr)
    {
        hr = penumWalk->Skip(0L);
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG::Skip")) ;
    }

    // Attempt to Skip ULONG_MAX elements.

    // NOTE: In the old test, this was supposed to return S_OK, but it returns
    // S_FALSE
    if(S_OK == hr)
    {
        hr = penumWalk->Skip(ULONG_MAX);
        CheckErrorTest2(S_FALSE, 
                TEXT ("IEnumSTATSTG::Skip ULONG_MAX"));
    }

    // Call Clone with NULL ppenum parameter (ist)
    if(S_OK == hr)
    {
        hr = penumWalk->Clone(NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER, 
                TEXT ("IEnumSTATSTG::Clone NULL ppEnum"));
    }

    if(S_OK == hr)
    {
        statStg.pwcsName = NULL;

        // first get pmalloc that would be used to free up the name string from
        // STATSTG.

        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);
        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    // Reset the enumerator back to start and then test Next methods

    if(S_OK == hr)
    {
        hr = penumWalk->Reset();
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG:Reset")) ;
    }

    // Call Next with celt equal to zero, but pceltFetched as not NULL
    if(S_OK == hr)
    {
        hr = penumWalk->Next(0, &statStg, &celtFetched);
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG::Next celt 0")) ;
    }

    // Call Next with celt equal to 999 and celtFetched as NULL 
    if(S_OK == hr)
    {
        hr = penumWalk->Next(999, &statStg ,NULL);
        CheckErrorTest2(STG_E_INVALIDPARAMETER, 
                TEXT ("IEnumSTATSTG::Next celt 999 and pceltFetched NULL"));
    }

    // Call Next with rgelt as NULL (2nd parameter). celtFetched may be NULL 
    // when celt asked is 1
 
    if(S_OK == hr)
    {
        hr = penumWalk->Next(1, NULL, NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER, 
                TEXT ("IEnumSTATSTG::Next rgelt NULL"));
    }

    // Call Next with celt as 1 and pceltFetched as NULL.  Allowed as per spec 
    if(S_OK == hr)
    {
        hr = penumWalk->Next(1, &statStg, NULL);
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG::Next celt 1 and pceltFetched NULL"));
    }

    // Clean up

    if(NULL != statStg.pwcsName)
    {
        pMalloc->Free(statStg.pwcsName);
        statStg.pwcsName = NULL;
    }

    // Free LPENUMSTATSTG pointer
    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT (0 == ulRef);
        penumWalk = NULL;
    }

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // if something did no pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_102 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
                TEXT("Test variation APITEST_102 failed; hr=%#lx; fPass=%d"),
                hr,
                fPass));
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // free strings
    if(NULL != pReserved2)
    {
      delete [] pReserved2;
      pReserved2 = NULL;
    }

    if(NULL != pRootNewChildStgName)
    {
        delete [] pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }
 
   // Stop logging the test
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    APITEST_103 
//
// Synopsis: Attempts various illegit operations on the IStorage interface,
//           verifies proper return codes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IASTORAG.CXX
// 2.  Old name of test : IllegitAPIStorage test 
//     New Name of test : APITEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-103
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-103
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-103
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// BUGNOTE: Conversion: APITEST_103
//-----------------------------------------------------------------------------

HRESULT APITEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          ptszChildStgName        = NULL;
    LPOLESTR        poszChildStgName        = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTORAGE       pStgChild               = NULL;
    LPSTORAGE       pStgChild2              = NULL;
    LPSTREAM        pStmChild               = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    ULONG           cRandom                 = 0;
    ULONG           cMin                    = 1;
    ULONG           cMax                    = 999;
    SNB             snbTest                 = NULL;
    SNB             snbTemp                 = NULL;
    OLECHAR         *ocsSNBChar             = NULL;
    ULONG           ulRef                   = 0;
    ULONG           i                       = 0;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_103 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
      TEXT("Attempt various illegitimate operations on IStorage interface")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for APITEST_103, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get IStorage pointer
    if (S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();
        DH_ASSERT (NULL != pStgRoot);
        if (NULL == pStgRoot)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszChildStgName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert name to OLECHAR
        hr = TStringToOleString(ptszChildStgName, &poszChildStgName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Call CreateStorage with grfmode=-1
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                (DWORD) -1,
                0,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDFLAG, 
                TEXT ("IStorage::CreateStorage inv mode"),
                pStgChild);
    }

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = pdgi->Generate(&cRandom, cMin, cMax);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    // Call CreateStorage with random data in dwReserved1
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE,
                cRandom,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::CreateStorage inv dwReserved1"),
                pStgChild);
    }

    // Call CreateStorage with random data in dwReserved2
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE,
                0,
                cRandom,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::CreateStorage inv dwReserved2"),
                pStgChild);
    }

    // Call CreateStorage with NULL 5th ppstg parameter 
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE,
                0,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("IStorage::CreateStorage NULL ppstg"));
    }

    // Create a stream with poszChildName and later on try to instantiate the
    // child storage with that same name poszChildName
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStgName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &pStmChild);
        DH_HRCHECK (hr, TEXT("IStorage::CreateStream"));
    }

    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Close stream...
    if (NULL != pStmChild)
    {
         ulRef = pStmChild->Release();
         DH_ASSERT (0 == ulRef);
         pStmChild = NULL;
    }

    // Now try opening storage with name with which above stream was created
    // i.e.  poszChildName
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("IStorage::OpenStorage inv name"),
                pStgChild);
    }

    //Destroy the stream element of this root storage having name poszChildStg
    //Name
    if(S_OK == hr)
    {
        hr = pStgRoot->DestroyElement(poszChildStgName);
        DH_HRCHECK(hr, TEXT("IStorage::DestroyElement")) ;
    }

    // Create a valid storage with name poszChildStgName
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE | STGM_FAILIFTHERE,
                0,
                0,
                &pStgChild);
        DH_HRCHECK(hr, TEXT("IStorage::CreateStorage")) ;
    }

    // Commit with grfCommitFlags = -1
    if (S_OK == hr)
    {
        hr = pStgChild->Commit((DWORD) -1);
        CheckErrorTest2(STG_E_INVALIDFLAG,
                TEXT ("IStorage::Commit inv flag"));
    }

    // Commit the child.  BUGBUG: Use random commit modes
    if (S_OK == hr)
    {
        hr = pStgChild->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("IStorage::Commit"));
    }

    // Commit the root storage.  BUGBUG: Use random commit modes
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Attempt second instantiation of pStgChild which is already open.
    if (S_OK == hr)
    {
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pStgChild2);
        CheckErrorTest(STG_E_ACCESSDENIED,
                TEXT ("IStorage::OpenStorage 2nd time"),
                pStgChild2);
    }

    // Release the child
    if (NULL != pStgChild)
    {
        ulRef = pStgChild->Release();
        DH_ASSERT (0 == ulRef);
        pStgChild = NULL;
    }

    // Now try to open child IStorage, but with grfMode = -1
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                (DWORD) -1,
                NULL,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("IStorage::OpenStorage inv mode"),
                pStgChild);
    }

    // Attempt OpenStorage with name as "" of IStorage to be opened.
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                (OLECHAR *) " ",
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("IStorage::OpenStorage inv name"),
                pStgChild);
    }

    // Attempt OpenStorage with name as NULL of IStorage to be opened.
#ifdef _MAC
    DH_TRACE((DH_LVL_TRACE1, TEXT("OpenStorage with NULL name skipped.")) );
#else
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                NULL,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDNAME,
                TEXT ("IStorage::OpenStorage NULL name"),
                pStgChild);
    }

#endif //_MAC
    // Attempt OpenStorage with name as NULL ppstg, 6th parameter.
    if (S_OK == hr)
    {
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("IStorage::OpenStorage NULL ppstg"));
    }

    // Attempt OpenStorage with random data in dwReserved parameter
    if (S_OK == hr && NULL != pdgi)
    {
        hr = pdgi->Generate(&cRandom, cMin, cMax);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                cRandom,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStorage inv dwReserved"),
                pStgChild);
    }

    // Attempt OpenStorage with uninitialized SNB, should fail, but no GP
    // fault should occur.
    if(S_OK == hr)
    {
        snbTest = (OLECHAR **) new OLECHAR [sizeof(OLECHAR *) * 2];
        if(NULL == snbTest)
        {
            hr = E_OUTOFMEMORY;
        }
        else 
        {   // bad pointer so SNB is not initialized
            *snbTest = (OLECHAR*)0xBAADF00D;  
        }
        DH_HRCHECK (hr, TEXT("new OLECHAR"));
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                snbTest,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStorage uninitd SNB"),
                pStgChild);
    }

    // Attempt OpenStorage with SNB with no name in block, although it has 
    // space for two names, set name list to NULL
    if(S_OK == hr && NULL != snbTest)
    {
        *snbTest = NULL;
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                snbTest,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStorage empty SNB"),
                pStgChild);
    }

    // Allocate space for long name and fill name with X's, make next SNB 
    // element NULL, and make a call to IStorage::OpenStorage with too long a 
    // name in SNB
    if(S_OK == hr && NULL != snbTest)
    {
        *snbTest = (OLECHAR *) new OLECHAR [MAX_STG_NAME_LEN*4];
        if (NULL == *snbTest)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new OLECHAR"));
    }

    if(S_OK == hr && NULL != snbTest)
    {
        snbTemp = snbTest;
        ocsSNBChar = *snbTemp;

        for (i=0; i<( MAX_STG_NAME_LEN*4 -1); i++)
        {

            ocsSNBChar[i] = 'X';
        }

        ocsSNBChar[i] = '\0';

        // Assign second element as NULL
        snbTemp++;
        *snbTemp = NULL;
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                snbTest,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStorage too long SNB"),
                pStgChild);
    }

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // if something did no pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_103 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
                TEXT("Test variation APITEST_103 failed; hr=%#lx; fPass=%d"),
                hr,
                fPass));
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings

    if(NULL != ptszChildStgName)
    {
        delete ptszChildStgName;
        ptszChildStgName = NULL;
    }

    if(NULL != poszChildStgName)
    {
        delete poszChildStgName;
        poszChildStgName = NULL;
    }

    // Free SNB

    if(NULL != snbTest)
    {
        if(NULL != *snbTest)
        {
            delete [] *snbTest;
            *snbTest = NULL;
        }
        delete [] snbTest;
        snbTest = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
//----------------------------------------------------------------------------
//
// Test:    APITEST_104 
//
// Synopsis: Attempts various illegit operations on the IStream interface,
//           verifies proper return codes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IASTREAM.CXX
// 2.  Old name of test : IllegitAPIStream test 
//     New Name of test : APITEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-104
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-104
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-104
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: APITEST_104
//-----------------------------------------------------------------------------

HRESULT APITEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          ptszChildStmName        = NULL;
    LPOLESTR        poszChildStmName        = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTORAGE       pStgChild               = NULL;
    LPSTREAM        pStmChild               = NULL;
    LPSTREAM        pStmChild2              = NULL;
    ULONG           ulRef                   = 0;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    ULONG           cRandom                 = 0;
    ULONG           cMin                    = 1;
    ULONG           cMax                    = 999;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_104 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Attempt illegitimate operations on IStream interface. ")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for APITEST_104, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get IStorage pointer
    if (S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();
        DH_ASSERT (NULL != pStgRoot);
        if (NULL == pStgRoot)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_STRING pointer 
    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Generate random name for stream
    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH, &ptszChildStmName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert name to OLECHAR
        hr = TStringToOleString(ptszChildStmName, &poszChildStmName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Attempt CreateStream with grfmode=-1

    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                (DWORD) -1,
                0,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("IStorage::CreateStream inv grfMode"),
                pStmChild);
    }

    // Get DG_INTEGER pointer
    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = pdgi->Generate(&cRandom, cMin, cMax);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    // Call CreateStorage with random data in dwReserved1
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                cRandom,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::CreateStream inv dwReserved1"),
                pStmChild);
    }

    // Call CreateStream with random data in dwReserved2
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                cRandom,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::CreateStream inv dwReserved2"),
                pStmChild);
    }

    // Call CreateStorage with NULL 5th ppstm parameter 
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("IStorage::CreateStream NULL ppstm"));
    }

    // Create a storage with poszChildStmName and later on try to instantiate 
    // child stream with that same name poszChildStmName
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                0,
                &pStgChild);
        DH_HRCHECK (hr, TEXT ("IStorage::CreateStream"));
        DH_ASSERT (NULL != pStgChild);
    }

    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT ("VirtualCtrNode::Commit"));
    }

    // Close storage...
    if (NULL != pStgChild)
    {
         ulRef = pStgChild->Release();
         DH_ASSERT (0 == ulRef);
         pStgChild = NULL;
    }

    // Now try opening storage with name with which above stream was created
    // i.e.  poszChildStmName
    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("IStorage::CreateStream inv name"),
                pStmChild);
    }

    //Destroy the storage element of this root storage having name poszChildStm
    //Name
    if(S_OK == hr)
    {
        hr = pStgRoot->DestroyElement(poszChildStmName);
        DH_HRCHECK(hr, TEXT("IStorage::DestroyElement")) ;
    }

    // Create a valid stream with name poszChildStmName
    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_FAILIFTHERE,
                0,
                0,
                &pStmChild);
        DH_HRCHECK (hr, TEXT("IStorage::CreateStream"));
    }

    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Attempt second instance of IStream to be instantiated.
    if (S_OK == hr)
    {
        pStmChild2 = NULL;

        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild2);
        CheckErrorTest(STG_E_ACCESSDENIED,
                TEXT ("IStorage::OpenStream 2nd time"),
                pStmChild2);
    }

    // Release the stream
    if(NULL != pStmChild)
    {
        ulRef = pStmChild->Release();
        DH_ASSERT (0 == ulRef);
        pStmChild = NULL;
    }

    // Now attempt opening the stream with grfMode = -1
    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                (DWORD) -1,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("IStorage::OpenStream inv grfMode"),
                pStmChild);
    }

    // Now attempt opening the stream with name as ""

    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->OpenStream(
                (OLECHAR *) " ",
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("IStorage::OpenStream inv name"),
                pStmChild);
    }

    // Now attempt opening the stream with name as NULL 
#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("OpenStream with NULL name skipped.")) );

#else
    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->OpenStream(
                NULL,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDNAME,
                TEXT ("IStorage::OpenStream NULL name"),
                pStmChild);
    }
#endif // _MAC

    // Now attempt opening the stream with random data in pReserved1 . For test
    // we just put pStgRoot for pReserved1 variable.
    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->OpenStream(
                poszChildStmName,
                pStgRoot,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStream inv pReserved1"),
                pStmChild);
    }

    // Now attempt opening the stream with random data in dwReserved2 
    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                cRandom,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStream inv dwReserved2"),
                pStmChild);
    }

    // Now attempt opening the stream with NULL ppstm (5th parameter) 
    if (S_OK == hr)
    {
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("IStorage::OpenStream NULL ppstm"));
    }

    // Now attempt opening the stream normally 
    if (S_OK == hr)
    {
        pStmChild = NULL;

        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        DH_HRCHECK (hr, TEXT("IStorage::OpenStream"));

        // Release the stream
        if(S_OK == hr)
        {
            ulRef = pStmChild->Release();
            DH_ASSERT (0 == ulRef);
        }
    }

    // Release the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // if something did not pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_104 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
                TEXT("Test variation APITEST_104 failed; hr=%#lx; fPass=%d"),
                hr,
                fPass));
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp string

    if(NULL != ptszChildStmName)
    {
        delete []ptszChildStmName;
        ptszChildStmName = NULL;
    }

    if(NULL != poszChildStmName)
    {
        delete []poszChildStmName;
        poszChildStmName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation APITEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


// for non _OLE_NSS_, funcs are stubbed out below
#ifdef _OLE_NSS_

//----------------------------------------------------------------------------
//
// Test:    APITEST_200 
//
// Synopsis: This test attempts various operations on StgCreateStorageEx, 
//           StgOpenStorageEx API's 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
//  History:    18-June-1996     NarindK     Created.
//
// New Test Notes:
// 1.  Old File: IAPISTG.CXX
// 2.  Old name of test : IllegitAPIStg test 
//     New Name of test : APITEST_200 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-200
//        /dfRootMode:dirReadWriteShEx /dfname:APITEST.200 /labmode
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-200
//        /dfRootMode:xactReadWriteShEx /dfname:APITEST.200 /labmode
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-200
//        /dfRootMode:xactReadWriteShDenyW /dfname:APITEST.200 /labmode
//
// BUGNOTE: Conversion: APITEST-200 NO
// 
//-----------------------------------------------------------------------------


HRESULT APITEST_200(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode              = NULL;
    LPSTORAGE       pIStorage               = NULL;
    LPSTORAGE       pIStorageOpen           = NULL;
    LPOLESTR        pOleStrTemp             = NULL;
    TCHAR           tszTestName[10]         = TEXT("NonExist");
    LPOLESTR        pOleStrTest             = NULL;
    SNB             snbTest                 = NULL;
    SNB             snbTemp                 = NULL;
    ULONG           ulRef                   = 0;
    OLECHAR         *ocsSNBChar             = NULL;
    ULONG           i                       = 0;
    BOOL            fPass                   = TRUE;
    CLSID           clsidBogus              = {0xBAADF00D,
                                               0xBAAD,
                                               0xF00D,
                                               {0xA0, 0xA0, 0xA0, 0xA0, 
                                                0xA0, 0xA0, 0xA0, 0xA0}};
    DWORD           stgfmt                  = StorageIsFlat()?STGFMT_FILE:0;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_200"));

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_200 started.")) );
    DH_TRACE((DH_LVL_ALWAYS,
            TEXT("Attempt illegitimate ops on StgCreateStorageEx & ")
            TEXT("StgOpenStorageEx.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.
    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new ChanceDF"));
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);
        DH_HRCHECK(hr, TEXT("ChanceDF::CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Run Mode for APITEST_200, Access mode: %lx"),
                pTestChanceDF->GetRootMode()));
    }

    // Get RootDocFile name
    if (S_OK == hr)
    {
        if(NULL != pTestChanceDF->GetDocFileName())
        {
            pRootDocFileName =
                new TCHAR[_tcslen(pTestChanceDF->GetDocFileName())+1];

            if (pRootDocFileName == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                _tcscpy(pRootDocFileName, pTestChanceDF->GetDocFileName());
            }
            DH_HRCHECK (hr, TEXT("new TCHAR"));
        }
        DH_HRCHECK(hr, TEXT("ChanceDF::GetDocFileName()")) ;
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR
        hr = TStringToOleString(pRootDocFileName, &pOleStrTemp);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Try calling StgCreateStorageEx with mode STGM_CREATE|STGM_CONVERT
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT("Try calling StgCreateStorageEx with mode STGM_CREATE|STGM_CONVERT")));
    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                STGM_CREATE | STGM_CONVERT,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorage);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("StgCreateStorageEx inv grfMode"),
                pIStorage);
    }

    // Try calling StgCreateStorageEx with grfMode equal to -1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try calling StgCreateStorageEx with grfMode equal to -1")));
    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                (DWORD) -1, 
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorage);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("StgCreateStorageEx inv grfMode"),
                pIStorage);
    }

    // Try calling StgCreateStorageEx with stgfmt equal to -1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try calling StgCreateStorageEx with stgfmt equal to -1")));
    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                dwRootMode,
                (DWORD)-1, 
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorage);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("StgCreateStorageEx inv stgfmt"),
                pIStorage);
    }

    // Try calling StgCreateStorageEx with gfrAttr equal to -1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try calling StgCreateStorageEx with gfrAttr equal to -1")));
    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                (DWORD)-1, 
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorage);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("StgCreateStorageEx inv grfAttr"),
                pIStorage);
    }

    // Try calling StgCreateStorageEx with nonzero reserved1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try calling StgCreateStorageEx with nonzero reserved1")));

    // With 1795 changes to "dwReserved" Parameter to -> version number,
    // sector size (allowed is 512, 4096 only) and reserved parameter as
    // typedef struct tagSTGOPTIONS
    // {
    //  USHORT usVersion;            // Version 1
    //  USHORT reserved;             // must be 0 for padding
    //  ULONG ulSectorSize;          // docfile header sector size (512)
    // } STGOPTIONS;

    STGOPTIONS  stgOptions;
    stgOptions.usVersion = 1;
    stgOptions.reserved = 999; 
    stgOptions.ulSectorSize = 512;

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0, 
                &stgOptions,
                NULL,
                IID_IStorage,
                (void**)&pIStorage);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("StgCreateStorageEx inv STGOPTIONS dwreserved"),
                pIStorage);
    }

    if (S_OK == hr)
    {
        stgOptions.reserved = 0; 
        stgOptions.ulSectorSize = 999; // Allowed is 512 and 4096 only

        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0,
                &stgOptions,
                NULL,
                IID_IStorage,
                (void**)&pIStorage);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("StgCreateStorageEx inv STGOPTIONS ulSectorSize"),
                pIStorage);
    }

    // Try calling StgCreateStorageEx with nonzero reserved2
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try calling StgCreateStorageEx with nonzero reserved2")));
    if (S_OK == hr)
    {
        stgOptions.ulSectorSize = 512; // Allowed is 512 and 4096 only
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0, 
                &stgOptions,
                (void*)999,
                IID_IStorage,
                (void**)&pIStorage);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("StgCreateStorageEx inv reserved2"),
                pIStorage);
    }

    // Try calling StgCreateStorageEx with invalid IID
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try calling StgCreateStorageEx with invalid IID")));
    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0, 
                &stgOptions,
                NULL,
                clsidBogus,
                (void**)&pIStorage);
        CheckErrorTest(E_NOINTERFACE,
                TEXT ("StgCreateStorageEx inv riid"),
                pIStorage);
    }

    // Try calling StgCreateStorageEx with NULL ppstgOpen parameter
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try calling StgCreateStorageEx with NULL ppstgOpen parameter")));
    if (S_OK == hr)
    {
        hr = StgCreateStorageEx(
                pOleStrTemp,
                dwRootMode, 
                stgfmt,
                0,
                &stgOptions,
                NULL,
                IID_IStorage,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("StgCreateStorageEx NULL ppstg"));
    }

    // Now create a valid DocFile

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.
    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF(STGTYPE_NSSFILE);
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new VirtualDF"));
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);
        DH_HRCHECK(hr, TEXT("VirtualDF::GenerateVirtualDF")) ;
    }

    // Try commiting with grfCommitFlags = -1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Try commiting with grfCommitFlags = -1")));
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit((DWORD) -1);
        CheckErrorTest2(STG_E_INVALIDFLAG, 
                TEXT("VirtualCtrNode::Commit inv flags"));
    }

    // Now do a valid commit
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // Instantiate DocFile with name as "" 
    // NOTE: The old test checked the erro value to be STG_E_FILENOTFOUND in 
    // this case.  On NT, we get STG_E_PATHNOTFOUND and on Chicago, we get
    // STG_E_ACCESSDENIED, so let us check against S_OK itself.

    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile with name as ' '")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                (OLECHAR *) " ",
                dwRootMode,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        //BUGBUG: what exactly are we expecting failure code?

        if (RunningOnNT())
        {
            // HACKHACK: dont know exactly what the OS will return here.....
            if (STG_E_PATHNOTFOUND == hr ||
                STG_E_FILENOTFOUND == hr ||
                STG_E_INVALIDNAME == hr)
            {
                DH_TRACE ((DH_LVL_TRACE2, TEXT("Actual return value:hr=%#x"), hr));
                hr = STG_E_PATHNOTFOUND;
            }
            CheckErrorTest(STG_E_PATHNOTFOUND,
                    TEXT ("StgOpenStorageEx inv name"),
                    pIStorageOpen);
        }
        else
        {
            CheckErrorTest(STG_E_ACCESSDENIED,
                    TEXT ("StgOpenStorageEx inv name"),
                    pIStorageOpen);
        }
    }
            
    // Instantiate DocFile with nonexisting file name
    if(S_OK == hr)
    {
        // Convert tszTestName  to OLECHAR
        hr = TStringToOleString(tszTestName, &pOleStrTest);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile with nonexisting file name")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTest,
                dwRootMode,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("StgOpenStorageEx bad name"),
                pIStorageOpen);
    }

    // Instantiate DocFile with NULL file name
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile with NULL file name")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                NULL,
                dwRootMode,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDNAME,
                TEXT ("StgOpenStorageEx NULL name"),
                pIStorageOpen);
    }

    // Instantiate DocFile with grfMode=-1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile with grfMode=-1")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                (DWORD) -1,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("StgOpenStorageEx inv grfMode"),
                pIStorageOpen);
    }

    // Instantiate DocFile with grfMode as dwRootMode|STGM_DELETEONRELEASE 
    // NOTE: The doc says, erro code in this case to be STG_E_INVALIDFUNCTION,
    // but error STG_E_INVALIDFLAG returned.

    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile with grfMode as dwRootMode|STGM_DELETEONRELEASE")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                dwRootMode | STGM_DELETEONRELEASE,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDFUNCTION,
                TEXT ("StgOpenStorageEx inv grfMode"),
                pIStorageOpen);
    }

    // Instantiate DocFile with stgfmt=-1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile with stgfmt=-1")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                dwRootMode,
                (DWORD)-1,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("StgOpenStorageEx inv stgfmt"),
                pIStorageOpen);
    }

    // Instantiate docfile with grfAttr == -1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate docfile with grfAttr == -1")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                (DWORD)-1,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("StgOpenStorageEx inv grfAttr"),
                pIStorageOpen);
    }

    // Instantiate docfile with pTransaction == -1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate docfile with reserved1 (pTransaction) == -1")));
    if (S_OK == hr)
    {
        stgOptions.reserved = (USHORT)(-1);
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0,
                &stgOptions,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("StgOpenStorageEx inv reserved1"),
                pIStorageOpen);
    }

    // Instantiate docfile with pSecurity == -1
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate docfile with reserved2 (pSecurity) == -1")));
    if (S_OK == hr)
    {
        stgOptions.reserved = 0;
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0,
                NULL,
                (void*)-1,
                IID_IStorage,
                (void**)&pIStorageOpen);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("StgOpenStorageEx inv reserved2"),
                pIStorageOpen);
    }

    // Instantiate docfile with bogus refiid
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate docfile with bogus refiid")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0,
                NULL,
                NULL,
                clsidBogus,
                (void**)&pIStorageOpen);
        // ----------- flatfile change ---------------
        if(!StorageIsFlat())
        {
        // ----------- flatfile change ---------------
        CheckErrorTest(E_NOINTERFACE,
                TEXT ("StgOpenStorageEx inv riid"),
                pIStorageOpen);
        }
        else
        {
        CheckErrorTest(STG_E_INVALIDFUNCTION,
                TEXT ("StgOpenStorageEx of a docfile with inv riid"),
                pIStorageOpen);
        }   // ----------- flatfile change ---------------
    }

    // Instantiate DocFile with NULL ppstgOpen parameter (8th)
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile with NULL ppstgOpen parameter")));
    if (S_OK == hr)
    {
        hr = StgOpenStorageEx(
                pOleStrTest,
                dwRootMode,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("StgOpenStorageEx NULL ppstg"));
    }

    // Instatiate correctly.
    DH_TRACE ((DH_LVL_TRACE4, 
            TEXT ("Instantiate DocFile")));
    if (S_OK == hr)
    {
        pIStorageOpen = NULL;

        hr = StgOpenStorageEx(
                pOleStrTemp,
                dwRootMode,
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);
        // ----------- flatfile change ---------------
        if(StorageIsFlat())
        {
        CheckErrorTest(STG_E_INVALIDFUNCTION,
                TEXT ("StgOpenStorageEx -opening docfile as flatfile"),
                pIStorageOpen);
        }
        // ----------- flatfile change ---------------
        DH_HRCHECK (hr, TEXT("StgOpenStorageEx"));

        // close it.
        if (NULL != pIStorageOpen)
        {
            ulRef = pIStorageOpen->Release();
            DH_ASSERT (0 == ulRef);
            pIStorageOpen = NULL; 
        }
    }

    // if something did not pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_200 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
                TEXT("Test variation APITEST_200 failed; hr=%#lx; fPass=%d."),
                hr,
                fPass));
    }

    // Cleanup

    // Delete Chance docfile tree
    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());
        DH_HRCHECK(hr2, TEXT("ChanceDF::DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree
    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);
        DH_HRCHECK(hr2, TEXT("VirtualDF::DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the docfile on disk
    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;
            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings
    if(NULL != pOleStrTemp)
    {
        delete []pOleStrTemp;
        pOleStrTemp = NULL;
    }

    if(NULL != pOleStrTest)
    {
        delete []pOleStrTest;
        pOleStrTest = NULL;
    }

    if(NULL != pRootDocFileName)
    {
        delete []pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_200 finished")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    APITEST_201 
//
// Synopsis: The test attempts various illegitimate operations using names
//       greater than MAX_STG_NAME_LEN, it then attempts to create
//       several random named root docfiles.  If the create is succesful,
//       then a random named child IStorage or IStream is also created.
//       Whether or not the root create was successful, we attempt to
//       open the root docfile (this is expected to fail, the point is
//       to check for asserts/GP faults rather than return codes).  If
//       the instantiation is successful, the test also tries to
//       instantiate the child object.  All objects are then released.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IANAMES.CXX
// 2.  Old name of test : IllegitAPINames test 
//     New Name of test : APITEST_201 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-201
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-201
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-201
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: APITEST-201 NO
//
//-----------------------------------------------------------------------------

HRESULT APITEST_201(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;
    LPOLESTR        poszBadName             = NULL;
    LPOLESTR        poszBadNameStg          = NULL;
    LPTSTR          ptszBadNameStg          = NULL;
    DWORD           dwRootMode              = 0;
    ULONG           i                       = 0;
    LPSTORAGE       pIStorage               = NULL;
    LPSTORAGE       pIStorageChild          = NULL;
    LPSTREAM        pIStreamChild           = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    BOOL            fPass                   = TRUE;
    DWORD           stgfmt                  = StorageIsFlat()?STGFMT_FILE:0;
 
    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_201"));

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_201 started.")) );
    DH_TRACE((DH_LVL_ALWAYS, 
            TEXT("Call StgCreateDocFile/CreateStorage/CreateStream with ")
            TEXT("too long names.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.
    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new ChanceDF"));
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);
        DH_HRCHECK(hr, TEXT("ChanceDF::CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Run Mode for APITEST_201, Access mode: %lx"),
                pTestChanceDF->GetRootMode()));
    }

    // Call StgCreateDocFile with too long a name for docfile.
    // NOTE: Old test to fail with MAX_STG_NAME_LEN*3, but not in new test,
    // fails with MAX_STG_NAME_LEN*4.
    // NOTE: Crashes in DfFromName in OLE if length is of MAX_STG_NAME_LEN*8
    // CHECK!!!

    if(S_OK == hr)
    {
        poszBadName = (OLECHAR *) new OLECHAR [MAX_STG_NAME_LEN*4];
        if (NULL == poszBadName)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new OLECHAR"));
    }

    if(S_OK == hr)
    {
        for (i=0; i<( MAX_STG_NAME_LEN*4 -1); i++)
        {
            poszBadName[i] = 'X';
        }
        poszBadName[i] ='\0';
    }

    // Try calling StgCreateDocFile with the above long name pszBadName 

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateStorageEx(
                poszBadName,
                dwRootMode | STGM_CREATE, 
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pIStorage);

        // HACKHACK: dont know exactly what the OS will return here.....
        if (STG_E_PATHNOTFOUND == hr ||
            STG_E_FILENOTFOUND == hr ||
            STG_E_INVALIDNAME == hr)
        {
            DH_TRACE ((DH_LVL_TRACE2, TEXT("Actual return value:hr=%#x"), hr));
            hr = STG_E_PATHNOTFOUND;
        }
        CheckErrorTest(STG_E_PATHNOTFOUND,
                TEXT ("StgCreateStorageEx inv name"),
                pIStorage);
    }


    // Now create a valid DocFile

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  
    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF(STGTYPE_NSSFILE);
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new VirtualDF"));
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);
        DH_HRCHECK(hr, TEXT("VirtualDF::GenerateVirtualDF")) ;
    }


    // Get IStorage pointer
    if (S_OK == hr)
    {
        pIStorage = pVirtualDFRoot->GetIStoragePointer();
        DH_ASSERT (NULL != pIStorage);
        if (NULL == pIStorage)
        {
            hr = E_FAIL;
        }
    }

    // Call CreateStorage with too long a name for docfile.
    if(S_OK == hr)
    {
        ptszBadNameStg = (TCHAR *) new TCHAR [MAX_STG_NAME_LEN*3];
        if (NULL == ptszBadNameStg)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new TCHAR"));
    }

    if(S_OK == hr)
    {
        for (i=0; i<( MAX_STG_NAME_LEN*3 -1); i++)
        {
            ptszBadNameStg[i] = 'X';
        }
        ptszBadNameStg[i] ='\0';
    }

    if(S_OK == hr)
    {
        // Convert Bad storage name to OLECHAR
        hr = TStringToOleString(ptszBadNameStg, &poszBadNameStg);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------

    // now call CreateStorage with too long a name...
    if (S_OK == hr)
    {
        hr = pIStorage->CreateStorage(
                poszBadNameStg,
                pTestChanceDF->GetStgMode(),
                0,
                0,
                &pIStorageChild);
        CheckErrorTest(STG_E_INVALIDNAME, 
                TEXT ("IStorage::CreateStorage long name"),
                pIStorageChild);
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------


    // Now call CreateStream with too long a name...
    if (S_OK == hr)
    {
        hr = pIStorage->CreateStream(
                poszBadNameStg,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &pIStreamChild);
        CheckErrorTest(STG_E_INVALIDNAME, 
                TEXT ("IStorage::CreateStream long name"),
                pIStreamChild);
    }

    // Now add a Valid storage to root.  Call AddStorage that in turns calls
    // CreateStorage
    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.
    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE | STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);
        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    // Now try to rename this storage element to a bad name.
    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDNAME);
        hr = pvcnRootNewChildStorage->Rename(ptszBadNameStg);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest2(STG_E_INVALIDNAME, 
                TEXT ("VirtualCtrNode::Rename inv name"));
    }

    // Close the Storage pvcnRootNewChildStorage 
    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Close"));
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr = pVirtualDFRoot->Close();
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Close"));
    }

    // Delete temp strings
    if(NULL != poszBadNameStg)
    {
        delete [] poszBadNameStg;
        poszBadNameStg = NULL;
    }

    if(NULL != poszBadName)
    {
        delete [] poszBadName;
        poszBadName = NULL;
    }

    if(NULL != ptszBadNameStg)
    {
        delete [] ptszBadNameStg;
        ptszBadNameStg = NULL;
    }

    if(NULL != pRootNewChildStgName)
    {
        delete [] pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }

    // In the following section of test:
    //make a random number of random length, random character root
    //docfiles.  for this variation, we don't care if the operation
    //succeeds, looking for GP faults and asserts only.  if the
    //StgCreateDocfile fails, we'll still attempt the open.  of
    //course, the open in this case will be expected to fail, but
    //again, we won't be checking return codes... If the StgCreateDocfile
    //passes, we'll create a random name IStream or IStorage too.

    ULONG       count               =   0;    
    ULONG       cMinNum             =   16;    
    ULONG       cMaxNum             =   128;
    LPTSTR      ptszRandomRootName  =   NULL;  
    LPTSTR      ptszRandomChildName =   NULL;  
    ULONG       countFlag           =   0;    
    ULONG       cMinFlag            =   0;    
    ULONG       cMaxFlag            =   100;
    ULONG       nChildType          =   0;
    LPSTORAGE   pstgRoot            =   NULL; 
    LPSTORAGE   pstgChild           =   NULL; 
    LPSTREAM    pstmChild           =   NULL; 
    LPOLESTR    poszRandomRootName  =   NULL;
    LPOLESTR    poszRandomChildName =   NULL;
    ULONG       ulRef               =   0;

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&count, cMinNum, cMaxNum);
        DH_HRCHECK(hr, TEXT("pdgi::Generate")) ;
    }

    while(count--)
    {
        if(S_OK == hr)
        {
            hr=GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszRandomRootName);
            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if(S_OK == hr)
        {
            // Convert name to OLECHAR
            hr = TStringToOleString(ptszRandomRootName, &poszRandomRootName);
            DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        }

        if (S_OK == hr)
        {
            pstgRoot = NULL;

            hr = StgCreateStorageEx(
                    poszRandomRootName,
                    dwRootMode | STGM_CREATE,
                    stgfmt,
                    0,
                    NULL,
                    NULL,
                    IID_IStorage,
                    (void**)&pstgRoot);
            DH_HRCHECK (hr, TEXT("StgCreateStorageEx"));
        }

        nChildType = NONE;

        if(S_OK == hr)
        {
            if(S_OK == hr)
            {
                hr=GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH, 
                    &ptszRandomChildName);
                DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
            }

            if(S_OK == hr)
            {
                // Convert name to OLECHAR
                hr = TStringToOleString(
                        ptszRandomChildName, 
                        &poszRandomChildName);
                DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
            }

            if(S_OK == hr)
            {
                hr = pdgi->Generate(&countFlag, cMinFlag, cMaxFlag);
                DH_HRCHECK(hr, TEXT("pdgi::Generate")) ;
            }

            if(!StorageIsFlat() && countFlag > (cMaxFlag/2))
            {
                hr = pstgRoot->CreateStorage(
                        poszRandomChildName,
                        pTestChanceDF->GetStgMode(),
                        0,
                        0,
                        &pstgChild);
                DH_HRCHECK(hr, TEXT("IStorage::CreateStorage"));

                if(S_OK == hr)
                {
                    nChildType = STORAGE;
                    hr = pstgRoot->Commit(STGC_DEFAULT);
                    DH_HRCHECK(hr, TEXT("IStorage::Commit"));
                    ulRef = pstgChild->Release();
                    DH_ASSERT (0 == ulRef);
                    pstgChild = NULL;
                }
            }
            else
            {
                hr = pstgRoot->CreateStream(
                        poszRandomChildName,
                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                        0,
                        0,
                        &pstmChild);   
                DH_HRCHECK(hr, TEXT("IStorage::CreateStream"));
 
                if(S_OK == hr)
                {
                    nChildType = STREAM;
                    hr = pstgRoot->Commit(STGC_DEFAULT);
                    DH_HRCHECK(hr, TEXT("IStorage::Commit"));
                    ulRef = pstmChild->Release();   
                    DH_ASSERT (0 == ulRef);
                    pstmChild = NULL;
                }
            }

            ulRef = pstgRoot->Release();
            DH_ASSERT (0 == ulRef);     
            pstgRoot = NULL;
        }
        
        //Try to open Root Storage whetehr the creation was successful or not
        
        hr = StgOpenStorageEx(
                poszRandomRootName,
                pTestChanceDF->GetStgMode(),
                stgfmt,
                0,
                NULL,
                NULL,
                IID_IStorage,
                (void**)&pstgRoot);
        DH_HRCHECK (hr, TEXT("StgOpenStorageEx"));

        if(S_OK == hr)
        {
            switch(nChildType)
            {
                case STORAGE:
                    {
                        hr = pstgRoot->OpenStorage(
                                poszRandomChildName,
                                NULL, 
                                pTestChanceDF->GetStgMode(),
                                NULL, 
                                0,
                                &pstgChild);      
                        DH_HRCHECK(hr, TEXT("IStorage::OpenStorage"));
 
                        if(S_OK == hr)
                        {
                            ulRef = pstgChild->Release();
                            DH_ASSERT (0 == ulRef);
                            pstgChild = NULL;
                        }
                    }
                    break; 
                case STREAM:
                    {
                        hr = pstgRoot->OpenStream(
                                poszRandomChildName,
                                NULL, 
                                STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                0,
                                &pstmChild);      
                        DH_HRCHECK(hr, TEXT("IStorage::OpenStream"));
 
                        if(S_OK == hr)
                        {
                            ulRef = pstmChild->Release();
                            DH_ASSERT (0 == ulRef);
                            pstmChild = NULL;
                        }
                    }
                    break; 
            } /* switch */

            ulRef = pstgRoot->Release();
            DH_ASSERT (0 == ulRef);
            pstgRoot = NULL;
        }    

        // Delete temp strings
        if(NULL != ptszRandomChildName)
        {
            delete [] ptszRandomChildName;
            ptszRandomChildName = NULL;
        }

        if(NULL != ptszRandomRootName)
        {
            if(FALSE == DeleteFile(ptszRandomRootName))
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;
                DH_HRCHECK(hr, TEXT("DeleteFile")) ;
            }
            delete [] ptszRandomRootName;
            ptszRandomRootName = NULL;
        }

        if(NULL != poszRandomChildName)
        {
            delete [] poszRandomChildName;
            poszRandomChildName = NULL;
        }

        if(NULL != poszRandomChildName)
        {
            delete [] poszRandomChildName;
            poszRandomChildName = NULL;
        }
    }

    // if something did not pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_201 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation APITEST_201 failed; hr=%#lx; fPass=%d."),
            hr,
            fPass));
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file
    if(NULL != pTestVirtualDF)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];
        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete Chance docfile tree
    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());
        DH_HRCHECK(hr2, TEXT("ChanceDF::DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree
    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);
        DH_HRCHECK(hr2, TEXT("VirtualDF::DeleteVirtualFileDocTree")) ;
        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete the docfile on disk
    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr = HRESULT_FROM_WIN32(GetLastError()) ;
            DH_HRCHECK(hr, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp strings
    if(NULL != pFileName)
    {
        delete []pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_201 finished")) );

    return hr;

}

//----------------------------------------------------------------------------
//
// Test:    APITEST_202 
//
// Synopsis: Attempts various operations in obtaining enumerators, checking
//       for proper error return.  Then gets a valid enumerator, and
//       attempts various illegitimate method calls on it.  Verify
//       proper return codes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IAENUM.CXX
// 2.  Old name of test : IllegitAPIEnum test 
//     New Name of test : APITEST_202 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-202
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx /labmode
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-202
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx /labmode
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-202
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx /labmode
//
// BUGNOTE: Conversion: APITEST_202
//-----------------------------------------------------------------------------

HRESULT APITEST_202(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pRootNewChildStgName    = NULL;
    VirtualCtrNode  *pvcnRootNewChildStorage= NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    LPENUMSTATSTG   penumWalk               = NULL;
    ULONG           cMinNum                 = 1;
    ULONG           cMaxNum                 = 999;
    DWORD           dwReserved1             = 0;
    DWORD           dwReserved3             = 0;
    LPTSTR          pReserved2              = NULL;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;
    ULONG           celtFetched             = 0;
    STATSTG         statStg;
    LPMALLOC        pMalloc                 = NULL;
    STATSTG         *pStatStg               = NULL;
    INT             cAskMoreThanPresent     = 2; // Set to 2 since only 1 substg                                                 // added in test
 
 
    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_202"));

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_202 started")) );
    DH_TRACE((DH_LVL_ALWAYS, 
            TEXT("Attempt different illegitimate opeations on IEnumSTATSTG")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }


    if (S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, 
            TEXT("Run Mode for APITEST_202, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    //    Adds a new storage to the root storage.
    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStgName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }
// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE |
                STGM_FAILIFTHERE,
                &pvcnRootNewChildStorage);
        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------


    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Close the Child storage
    if (S_OK == hr)
    {
        hr = pvcnRootNewChildStorage->Close();
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Get the random number generator
    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&dwReserved1, cMinNum, cMaxNum);
        DH_HRCHECK(hr, TEXT("pdgi::Generate")) ;
    }

    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPARAMETER);
        hr = pVirtualDFRoot->EnumElements(
                dwReserved1,
                pReserved2,
                dwReserved3,
                &penumWalk);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("VirtualCtrNode::EnumElements inv dwReserved1"),
                penumWalk);
    }

    if(S_OK == hr)
    {
        hr = pdgi->Generate(&dwReserved3, cMinNum, cMaxNum);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPARAMETER);
        hr =  pVirtualDFRoot->EnumElements(
                dwReserved1,
                pReserved2,
                dwReserved3,
                &penumWalk);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("VirtualCtrNode::EnumElements inv dwReserved3"),
                penumWalk);
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH, &pReserved2);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPARAMETER);
        hr =  pVirtualDFRoot->EnumElements(
                dwReserved1,
                pReserved2,
                dwReserved3,
                &penumWalk);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("VirtualCtrNode::EnumElements inv pReserved2"),
                penumWalk);
    }

    // Now call EnumElements with NULL ppenm 4th parameter.
    if(S_OK == hr)
    {
        DH_EXPECTEDERROR (STG_E_INVALIDPOINTER);
        hr =  pVirtualDFRoot->EnumElements( 0, NULL, 0, NULL);
        DH_NOEXPECTEDERROR ();
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("VirtualCtrNode::EnumElements NULL penum"));
    }

    // Make a valid call to EnumElements now
    if(S_OK == hr)
    {
        hr =  pVirtualDFRoot->EnumElements( 0, NULL, 0, &penumWalk);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
    }

    // Now try the following skip calls - Attempt to skip 0 elements and 
    // attempt to skip MAX_ULONG elements.

    // Attempt to Skip 0 elements.

    if(S_OK == hr)
    {
        hr = penumWalk->Skip(0L);
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG::Skip")) ;
    }

    // Attempt to Skip ULONG_MAX elements.

    // NOTE: In the old test, this was supposed to return S_OK, but it returns
    // S_FALSE
    if(S_OK == hr)
    {
        hr = penumWalk->Skip(ULONG_MAX);
        CheckErrorTest2(S_FALSE, 
                TEXT ("IEnumSTATSTG::Skip ULONG_MAX"));
    }

    // Call Clone with NULL ppenum parameter (ist)
    if(S_OK == hr)
    {
        hr = penumWalk->Clone(NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER, 
                TEXT ("IEnumSTATSTG::Clone NULL ppEnum"));
    }

    if(S_OK == hr)
    {
        statStg.pwcsName = NULL;

        // first get pmalloc that would be used to free up the name string from
        // STATSTG.

        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);
        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }

    // Reset the enumerator back to start and then test Next methods

    if(S_OK == hr)
    {
        hr = penumWalk->Reset();
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG:Reset")) ;
    }

    // Call Next with celt equal to zero, but pceltFetched as not NULL.
    if(S_OK == hr)
    {
        hr = penumWalk->Next(0, &statStg ,&celtFetched);
        DH_TRACE((DH_LVL_TRACE4,
                 TEXT("celt given 0, celtFetched is %lu, hr is %lx\n"), 
                 celtFetched, hr));
        DH_HRCHECK (hr, TEXT("IEnumSTATSTG::Next celt 0"));
    }

    // Call Next with celt equal to 999, but celtFetched set to NULL

    if(S_OK == hr)
    {
        hr = penumWalk->Next(999, &statStg ,NULL);
        CheckErrorTest2(STG_E_INVALIDPARAMETER, 
                TEXT ("IEnumSTATSTG::Next celt 999 and pceltFetched NULL"));
    }

    // Call Next with rgelt as NULL (2nd parameter). celtFetched may be NULL 
    // when celt asked is 1

    if(S_OK == hr)
    {
        hr = penumWalk->Next(1, NULL, NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER, 
                TEXT ("IEnumSTATSTG::Next rgelt NULL"));
    }

    // Call Next with celt as 1 and pceltFetched as NULL.  Allowed as per spec
    // For docfile/nssfile, it will pass since it has a substorage added as 
    // above. For flatfile, it will pass since it has CONTENTS stream always

    if(S_OK == hr)
    {
        hr = penumWalk->Next(1, &statStg, NULL);
        DH_TRACE((DH_LVL_TRACE4,
                 TEXT("Name of element fetched is %s\n"), 
                 statStg.pwcsName));
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG::Next celt 1 and pceltFetched NULL"));
    }   

    // Clean up

    if(NULL != statStg.pwcsName)
    {
        pMalloc->Free(statStg.pwcsName);
        statStg.pwcsName = NULL;
    }

    // Call Next with celt more than elements in stg & celtFetched as not NULL
    if(S_OK == hr)
    {
        hr = penumWalk->Reset();
        DH_HRCHECK(hr, TEXT("IEnumSTATSTG:Reset")) ;
    }

    if(S_OK == hr)
    {
        pStatStg = new STATSTG[cAskMoreThanPresent];
        if(NULL == pStatStg)
        {
            hr = E_OUTOFMEMORY;
        }  
    }

    if(S_OK == hr)
    { 
        hr = penumWalk->Next(cAskMoreThanPresent, pStatStg ,&celtFetched);
        DH_TRACE((DH_LVL_TRACE4,
                 TEXT("IEnumSTATSTG celt more, hr %lx, celtFetched %lu\n"), 
                 hr, celtFetched));
        CheckErrorTest2(S_FALSE,
                TEXT ("IEnumSTATSTG::Next celt more number of elements"));
    }

    if(NULL != pStatStg)
    {
        delete [] pStatStg;
        pStatStg= NULL;
    }

    // Free LPENUMSTATSTG pointer
    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT (0 == ulRef);
        penumWalk = NULL;
    }

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // if something did not pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_202 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation APITEST_202 failed; hr=%#lx; fPass=%d."),
            hr,
            fPass));
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // free strings

    if(NULL != pReserved2)
    {
      delete [] pReserved2;
      pReserved2 = NULL;
    }

    if(NULL != pRootNewChildStgName)
    {
        delete [] pRootNewChildStgName;
        pRootNewChildStgName = NULL;
    }
 
   // Stop logging the test

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_202 finished")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    APITEST_203 
//
// Synopsis: Attempts various illegit operations on the IStorage interface,
//           verifies proper return codes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IASTORAG.CXX
// 2.  Old name of test : IllegitAPIStorage test 
//     New Name of test : APITEST_203 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-203
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-203
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-203
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx
//
// BUGNOTE: Conversion: APITEST_203
//-----------------------------------------------------------------------------

HRESULT APITEST_203(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hrExpected              = E_NOTIMPL; // Flatfile change
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          ptszChildStgName        = NULL;
    LPOLESTR        poszChildStgName        = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTORAGE       pStgChild               = NULL;
    LPSTORAGE       pStgChild2              = NULL;
    LPSTREAM        pStmChild               = NULL;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    ULONG           cRandom                 = 0;
    ULONG           cMin                    = 1;
    ULONG           cMax                    = 999;
    SNB             snbTest                 = NULL;
    SNB             snbTemp                 = NULL;
    OLECHAR         *ocsSNBChar             = NULL;
    ULONG           ulRef                   = 0;
    ULONG           i                       = 0;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_203"));

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_203 started.")) );
    DH_TRACE((DH_LVL_ALWAYS, 
      TEXT("Attempt various illegitimate operations on IStorage interface")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, 
            TEXT("Run Mode for APITEST_203, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get IStorage pointer
    if (S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();
        DH_ASSERT (NULL != pStgRoot);
        if (NULL == pStgRoot)
        {
            hr = E_FAIL;
        }
    }


    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&ptszChildStgName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert name to OLECHAR
        hr = TStringToOleString(ptszChildStgName, &poszChildStgName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Call CreateStorage with grfmode=-1
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                (DWORD) -1,
                0,
                0,
                &pStgChild);
   
        // ----------- flatfile change ---------------
        hrExpected = StorageIsFlat() ? E_NOTIMPL : STG_E_INVALIDFLAG; 
        // ----------- flatfile change ---------------

        CheckErrorTest(hrExpected, 
                TEXT ("IStorage::CreateStorage inv grfMode"),
                pStgChild);
    }

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = pdgi->Generate(&cRandom, cMin, cMax);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    // Call CreateStorage with random data in dwReserved1
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE,
                cRandom,
                0,
                &pStgChild);

        // ----------- flatfile change ---------------
        hrExpected = StorageIsFlat() ? E_NOTIMPL : STG_E_INVALIDPARAMETER; 
        // ----------- flatfile change ---------------

        CheckErrorTest(hrExpected, 
                TEXT ("IStorage::CreateStorage inv dwReserved1"),
                pStgChild);
    }

    // Call CreateStorage with random data in dwReserved2
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE,
                0,
                cRandom,
                &pStgChild);

        // ----------- flatfile change ---------------
        hrExpected = StorageIsFlat() ? E_NOTIMPL : STG_E_INVALIDPARAMETER; 
        // ----------- flatfile change ---------------

        CheckErrorTest(hrExpected, 
                TEXT ("IStorage::CreateStorage inv dwReserved2"),
                pStgChild);
    }

    // Call CreateStorage with NULL 5th ppstg parameter 
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE,
                0,
                0,
                NULL);
        // ----------- flatfile change ---------------
        hrExpected = StorageIsFlat() ? E_NOTIMPL : STG_E_INVALIDPOINTER; 
        // ----------- flatfile change ---------------

        CheckErrorTest2(hrExpected,
                TEXT ("IStorage::CreateStorage NULL ppstg"));
    }


    // Create a stream with poszChildName and later on try to instantiate the
    // child storage with that same name poszChildName
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStgName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &pStmChild);
        DH_HRCHECK (hr, TEXT("IStorage::CreateStream"));
    }

    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Close stream...
    if (NULL != pStmChild)
    {
         ulRef = pStmChild->Release();
         DH_ASSERT (0 == ulRef);
    }

    // Now try opening storage with name with which above stream was created
    // i.e.  poszChildName
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL, 
                0,
                &pStgChild);
        // ----------- flatfile change ---------------
        hrExpected = StorageIsFlat() ? E_NOTIMPL : STG_E_FILENOTFOUND; 
        // ----------- flatfile change ---------------

        CheckErrorTest(hrExpected,
                TEXT ("IStorage::OpenStorage inv name"),
                pStgChild);
    }

    //Destroy the stream element of this root storage having name poszChildStg
    //Name
    if(S_OK == hr)
    {
        hr = pStgRoot->DestroyElement(poszChildStgName);
        DH_HRCHECK(hr, TEXT("IStorage::DestroyElement")) ;
    }

// ----------- flatfile change ---------------
if(!StorageIsFlat()) 
// ----------- flatfile change ---------------
{
    // Create a valid storage with name poszChildStgName
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->CreateStorage(
                poszChildStgName,
                pTestChanceDF->GetStgMode() | STGM_CREATE | STGM_FAILIFTHERE,
                0,
                0,
                &pStgChild);
        DH_HRCHECK (hr, TEXT("IStorage::CreateStorage"));
    }

    // Commit with grfCommitFlags = -1
     if (S_OK == hr)
    {
        hr = pStgChild->Commit((DWORD) -1);
        CheckErrorTest2(STG_E_INVALIDFLAG, 
                TEXT("IStorage::Commit inv flag"));
    }

    // Commit the child.  BUGBUG: Use random commit modes
    if (S_OK == hr)
    {
        hr = pStgChild->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("IStorage::Commit"));
    }

    // Commit the root storage.  BUGBUG: Use random commit modes
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Attempt second instantiation of pStgChild which is already open.
    if (S_OK == hr)
    {
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pStgChild2);
        CheckErrorTest(STG_E_ACCESSDENIED, 
                TEXT ("IStorage::OpenStorage 2nd time"),
                pStgChild2);
    }

    if (S_OK == hr)
    {
        ulRef = pStgChild->Release();
        DH_ASSERT (0 == ulRef);
    }

    // Now try to open child IStorage, but with grfMode = -1
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                (DWORD) -1,
                NULL,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("IStorage::OpenStorage inv grfMode"),
                pStgChild);
    }

    // Attempt OpenStorage with name as " " of IStorage to be opened.
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                (OLECHAR *) " ",
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("IStorage::OpenStorage inv name"),
                pStgChild);
    }

    // Attempt OpenStorage with name as NULL of IStorage to be opened.
    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                NULL,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDNAME,
                TEXT ("IStorage::OpenStorage NULL name"),
                pStgChild);
    }

    // Attempt OpenStorage with name as NULL ppstg, 6th parameter.
    if (S_OK == hr)
    {
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("IStorage::OpenStorage NULL ppstg"));
    }

    // Attempt OpenStorage with random data in dwReserved parameter
    if (S_OK == hr)
    {
        hr = pdgi->Generate(&cRandom, cMin, cMax);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                cRandom,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("IStorage::OpenStorage inv dwReserved"),
                pStgChild);
    }

    // Attempt OpenStorage with uninitialized SNB, should fail, but no GP
    // fault should occur.
    if(S_OK == hr)
    {
        snbTest = (OLECHAR **) new OLECHAR [sizeof(OLECHAR *) * 2];
        if(NULL == snbTest)
        {
            hr = E_OUTOFMEMORY;
        }
        else 
        {
            *snbTest = (OLECHAR*)0xBAADF00D;
        }
        DH_HRCHECK (hr, TEXT("new OLECHAR"));
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                snbTest,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("IStorage::OpenStorage inv snb"),
                pStgChild);
    }

    // Attempt OpenStorage with SNB with no name in block, although it has 
    // space for two names, set name list to NULL

    if(S_OK == hr)
    {
        *snbTest = NULL;
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;
        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                snbTest,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("IStorage::OpenStorage empty snb"),
                pStgChild);
    }

    // Allocate space for long name and fill name with X's, make next SNB 
    // element NULL, and make a call to IStorage::OpenStorage with too long a 
    // name in SNB
    if(S_OK == hr && NULL != snbTest)
    {
        *snbTest = (OLECHAR *) new OLECHAR [MAX_STG_NAME_LEN*4];
        if (NULL == *snbTest)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK (hr, TEXT("new OLECHAR"));
    }

    if(S_OK == hr && NULL != snbTest)
    {
        snbTemp = snbTest;
        ocsSNBChar = *snbTemp;

        for (i=0; i<( MAX_STG_NAME_LEN*4 -1); i++)
        {
            ocsSNBChar[i] = 'X';
        }

        ocsSNBChar[i] = '\0';

        // Assign second element as NULL
        snbTemp++;
        *snbTemp = NULL;
    }

    if (S_OK == hr)
    {
        pStgChild = NULL;

        hr = pStgRoot->OpenStorage(
                poszChildStgName,
                NULL,
                pTestChanceDF->GetStgMode(),
                snbTest,
                0,
                &pStgChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER, 
                TEXT ("IStorage::OpenStorage long snb"),
                pStgChild);
    }

// ----------- flatfile change ---------------
}
// ----------- flatfile change ---------------

    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // if something did not pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_203 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation APITEST_203 failed; hr=%#lx; fPass=%d."),
            hr,
            fPass));
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp strings
    if(NULL != ptszChildStgName)
    {
        delete []ptszChildStgName;
        ptszChildStgName = NULL;
    }

    if(NULL != poszChildStgName)
    {
        delete []poszChildStgName;
        poszChildStgName = NULL;
    }

    // Free SNB

    if(NULL != snbTest)
    {
        if(NULL != *snbTest)
        {
            delete [] *snbTest;
            *snbTest = NULL;
        }
        delete [] snbTest;
        snbTest = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_203 finished")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    APITEST_204 
//
// Synopsis: Attempts various illegit operations on the IStream interface,
//           verifies proper return codes.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    18-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IASTREAM.CXX
// 2.  Old name of test : IllegitAPIStream test 
//     New Name of test : APITEST_204 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-204
//        /dfRootMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-204
//        /dfRootMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:APITEST-204
//        /dfRootMode:xactReadWriteShDenyW 
//
// BUGNOTE: Conversion: APITEST_204
//-----------------------------------------------------------------------------

HRESULT APITEST_204(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          ptszChildStmName        = NULL;
    LPOLESTR        poszChildStmName        = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTORAGE       pStgChild               = NULL;
    LPSTREAM        pStmChild               = NULL;
    LPSTREAM        pStmChild2              = NULL;
    ULONG           ulRef                   = 0;
    DG_STRING      *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    ULONG           cRandom                 = 0;
    ULONG           cMin                    = 1;
    ULONG           cMax                    = 999;
    BOOL            fPass                   = TRUE;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("APITEST_204"));

    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_204 started.")) );
    DH_TRACE((DH_LVL_ALWAYS, 
        TEXT("Attempt illegitimate operations on IStream interface.")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, 
            TEXT("Run Mode for APITEST_204, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get IStorage pointer
    if (S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();
        DH_ASSERT (NULL != pStgRoot);
        if (NULL == pStgRoot)
        {
            hr = E_FAIL;
        }
    }

    // Get DG_STRING pointer 
    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();
        DH_ASSERT (NULL != pdgu);
        if (NULL == pdgu)
        {
            hr = E_FAIL;
        }
    }

    // Generate random name for stream
    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH, &ptszChildStmName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert name to OLECHAR
        hr = TStringToOleString(ptszChildStmName, &poszChildStmName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Attempt CreateStream with grfmode=-1
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                (DWORD) -1,
                0,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("IStorage::CreateStream inv grfMode"),
                pStmChild);
    }

    // Get DG_INTEGER pointer
    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();
        DH_ASSERT (NULL != pdgi);
        if (NULL == pdgi)
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = pdgi->Generate(&cRandom, cMin, cMax);
        DH_HRCHECK(hr, TEXT("dgi::Generate")) ;
    }

    // Call CreateStorage with random data in dwReserved1

    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                cRandom,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::CreateStream inv dwReserved1"),
                pStmChild);
    }

    // Call CreateStream with random data in dwReserved2
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                cRandom,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::CreateStream inv dwReserved2"),
                pStmChild);
    }

    // Call CreateStorage with NULL 5th ppstm parameter 
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("IStorage::CreateStream NULL ppstm"));
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    // Create a storage with poszChildStmName and later on try to instantiate 
    // child stream with that same name poszChildStmName
    if (S_OK == hr)
    {
        hr = pStgRoot->CreateStorage(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                0,
                &pStgChild);
        DH_HRCHECK (hr, TEXT("IStorage::CreateStorage"));
        DH_ASSERT (NULL != pStgChild);
    }

    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("VirtualCtrNode::Commit"));
    }

    // Close storage...
    if (NULL != pStgChild)
    {
         ulRef = pStgChild->Release();
         DH_ASSERT (0 == ulRef);
    }

// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------
    // Now try opening storage with name with which above storage was created
    // i.e.  poszChildStmName
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("IStorage::CreateStream inv name"),
                pStmChild);
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    //Destroy the storage element of this root storage having name poszChildStm
    //Name
    if(S_OK == hr)
    {
        hr = pStgRoot->DestroyElement(poszChildStmName);
        DH_HRCHECK(hr, TEXT("IStorage::DestroyElement")) ;
    }

// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------
    // Create a valid stream with name poszChildStmName
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->CreateStream(
                poszChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_FAILIFTHERE,
                0,
                0,
                &pStmChild);
        DH_HRCHECK (hr, TEXT("IStorage::CreateStream"));
        DH_ASSERT (NULL != pStmChild);
    }

    // BUGBUG:  Use Random commit modes...
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK (hr, TEXT("IStorage::Commit"));
    }

    // Attempt second instance of IStream to be instantiated.
    if (S_OK == hr)
    {
        pStmChild2 = NULL;
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild2);
        CheckErrorTest(STG_E_ACCESSDENIED,
                TEXT ("IStorage::OpenStream 2nd time"),
                pStmChild2);
    }

    // Release the stream
    if(NULL != pStmChild)
    {
        ulRef = pStmChild->Release();
        DH_ASSERT (0 == ulRef);
    }

    // Now attempt opening the stream with grfMode = -1
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                (DWORD) -1,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDFLAG,
                TEXT ("IStorage::OpenStream inv grfMode"),
                pStmChild);
    }

    // Now attempt opening the stream with name as ""
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->OpenStream(
                (OLECHAR *) " ",
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_FILENOTFOUND,
                TEXT ("IStorage::OpenStream inv name"),
                pStmChild);
    }

    // Now attempt opening the stream with name as NULL 
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->OpenStream(
                NULL,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDNAME,
                TEXT ("IStorage::OpenStream NULL name"),
                pStmChild);
    }

    // Now attempt opening the stream with random data in pReserved1 . For test
    // we just put pStgRoot for pReserved1 variable.
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                pStgRoot,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStream inv dwReserved1"),
                pStmChild);
    }

    // Now attempt opening the stream with random data in dwReserved2 
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                cRandom,
                &pStmChild);
        CheckErrorTest(STG_E_INVALIDPARAMETER,
                TEXT ("IStorage::OpenStream inv dwReserved2"),
                pStmChild);
    }

    // Now attempt opening the stream with NULL ppstm (5th parameter) 
    if (S_OK == hr)
    {
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                NULL);
        CheckErrorTest2(STG_E_INVALIDPOINTER,
                TEXT ("IStorage::OpenStream NULL ppstm"));
    }

    // Now attempt opening the stream normally 
    if (S_OK == hr)
    {
        pStmChild = NULL;
        hr = pStgRoot->OpenStream(
                poszChildStmName,
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                &pStmChild);
        DH_HRCHECK (hr, TEXT("IStorage::OpenStream"));
        DH_ASSERT (NULL != pStmChild);
    }

    // Release the stream
    if(NULL != pStmChild)
    {
        ulRef = pStmChild->Release();
        DH_ASSERT (0 == ulRef);
        pStmChild = NULL;
    }

    // Release the root docfile
    // Close the root docfile
    if (NULL != pVirtualDFRoot)
    {
        hr2 = pVirtualDFRoot->Close();
        DH_HRCHECK (hr2, TEXT("VirtualCtrNode::Close"));
        hr = FirstError (hr, hr2);
    }

    // if something did not pass, mark test (hr) as E_FAIL
    if (FALSE == fPass)
    {
        hr = FirstError (hr, E_FAIL);
    }

    // if everything goes well, log test as passed else failed.
    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation APITEST_204 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
                TEXT("Test variation APITEST_204 failed; hr=%#lx; fPass=%d."),
                hr,
                fPass));
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete temp string
    if(NULL != ptszChildStmName)
    {
        delete []ptszChildStmName;
        ptszChildStmName = NULL;
    }

    if(NULL != poszChildStmName)
    {
        delete []poszChildStmName;
        poszChildStmName = NULL;
    }

    // Stop logging the test
    DH_TRACE((DH_LVL_ALWAYS, TEXT("Test variation APITEST_204 finished")) );

    return hr;
}

#else

// Stub out calls to these.
HRESULT APITEST_200(int argc, char *argv[]) {return E_NOTIMPL;} 
HRESULT APITEST_201(int argc, char *argv[]) {return E_NOTIMPL;} 
HRESULT APITEST_202(int argc, char *argv[]) {return E_NOTIMPL;} 
HRESULT APITEST_203(int argc, char *argv[]) {return E_NOTIMPL;} 
HRESULT APITEST_204(int argc, char *argv[]) {return E_NOTIMPL;} 

#endif  // _OLE_NSS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\enumtsts.cxx ===
-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      vcpytsts.cxx
//
//  Contents:  storage base tests basically pertaining to IStorage/IStream copy
//             ops 
//
//  Functions:  
//
//  History:    15-July-1996     NarindK     Created.
//              27-Mar-97        SCousens    conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

//----------------------------------------------------------------------------
//
// Test:   ENUMTEST_100 
//
// synopsis: A random root DF is created with random number of storages/streams
//       committed/close/reopened. An enumerator is obtained.  For each object 
//       found,attempt is made to convert object to an IStorage.  If it already 
//       was an IStorage, the conversion fails and the test continues.  If an 
//       IStream was converted to an IStorage, the new IStorage is committed 
//       and enumerated to ensure that only a single IStream named "CONTENTS" 
//       (STG_CONVERTED_NAME) exists. The CONTENTS IStream is instantiated, 
//       read, verified, and released. When all IStreams in the top level of 
//       the docfile have been converted ,root docfile is committed & released.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  22-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: LICONV.CXX
// 2.  Old name of test : LegitInstEnumConvert Test 
//     New Name of test : ENUMTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-100
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-100
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ENUMTEST-100
//
//-----------------------------------------------------------------------------

HRESULT ENUMTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualCtrNode  *pvcnTemp               = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;
    LPENUMSTATSTG   penumWalk               = NULL;
    LPENUMSTATSTG   penumWalkConv           = NULL;
    VirtualStmNode  *pvsnTrav               = NULL;
    VirtualStmNode  *pvsnTempConv           = NULL;
    LPMALLOC        pMalloc                 = NULL;
    ULONG           ulRef                   = 0;
    ULONG           cElementsInConvStg      = 0;
    LPTSTR          ptszStatStgName         = NULL;
    LPTSTR          ptszStatStgConvName     = NULL;
    STATSTG         statStg;
    STATSTG         statStgConv;
    DWCRCSTM        dwMemCRC;
    DWCRCSTM        dwActCRC;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ENUMTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_100 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Enumerate RootDF, do CreateStorage STGM_CONVERT on elements")));

// BUGBUG: Bug in testcode. TO BE fixed by scousens soon.
if (DoingDistrib ())
{
    DH_LOG((
            LOG_ABORT, 
            TEXT("Enumtest-100: Test bug. CRC not calcd for streams on open.")));
    return E_FAIL;
}

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    // Initialize CRC values to zero

    dwMemCRC.dwCRCData = dwActCRC.dwCRCData = 0;

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ENUMTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Commit root. BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Reopen the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get an enumerator for the root.

    if(S_OK == hr)
    {
        hr =  pVirtualDFRoot->EnumElements(0, NULL, 0, &penumWalk);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::EnumElements")) ;
    }
 
    // First get pMalloc that would be used to free up the name string from
    // STATSTG.

    if ( S_OK == hr )
    {
        hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

        DH_HRCHECK(hr, TEXT("CoGetMalloc")) ;
    }
 
    // In a loop, enumerate the DocFile at root level and call CreateStorage 
    // with STGM_CONVERT on the found element.  As a result, if the element
    // is a storage, it should return error STG_E_FILEALREADYEXISTS.  If it
    // is a stream, it is replaced with a new storage object containing a
    // single stream called CONTENTS and hr returned is STG_S_CONVERTED.

    while(S_OK == hr && S_OK == penumWalk->Next(1, &statStg, NULL))
    {
        // Convert statStg.pwcsName to TCHAR

        hr = OleStringToTString(statStg.pwcsName, &ptszStatStgName); 

        // Record CRC for this element before conversion if it is a stream

        if((STGTY_STREAM == statStg.type) && (S_OK == hr))
        {
            pvsnTrav = pVirtualDFRoot->GetFirstChildVirtualStmNode(); 
   
            while((NULL != pvsnTrav) &&
                  (0 != _tcscmp(
                            ptszStatStgName,
                            pvsnTrav->GetVirtualStmNodeName()))) 
            {
                pvsnTrav = pvsnTrav->GetFirstSisterVirtualStmNode();
            }
            
            DH_ASSERT(NULL != pvsnTrav);
            dwMemCRC.dwCRCData = pvsnTrav->GetVirtualStmNodeCRCData();
        }

        // Call to CreateStorage with STGM_CONVERTED flag

        if(S_OK == hr)
        {
            hr = AddStorage(     
                    pTestVirtualDF,     
                    pVirtualDFRoot,      
                    ptszStatStgName,
                    dwStgMode | STGM_CONVERT,
                    &pvcnTemp);

            if((STGTY_STREAM == statStg.type)           &&
               ((NULL == pvcnTemp)|| (STG_S_CONVERTED != hr)))
            {
                fPass = FALSE;
        
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("Enumerated stream element not converted")));

                break;
            }
            else
            {
                if(STGTY_STORAGE == statStg.type)
                {
                    if((NULL == pvcnTemp) && (STG_E_FILEALREADYEXISTS == hr))
                    {
                        // Expected result/condition, reset hr to S_OK

                        hr = S_OK;

                        // Delete the temp string

                        if(NULL != ptszStatStgName)
                        {
                            delete ptszStatStgName;
                            ptszStatStgName = NULL;
                        }

                        if ( NULL != statStg.pwcsName)
                        {
                            pMalloc->Free(statStg.pwcsName);
                            statStg.pwcsName = NULL;
                        }

                        continue;
                    }
                    else
                    {
                        fPass = FALSE;
        
                        DH_TRACE((
                            DH_LVL_TRACE1,
                            TEXT("Enum storage didn't return exp error")));

                        break;
                    }
                }
            }
        }
  
        // Delete the temp string

        if(NULL != ptszStatStgName)
        {
            delete ptszStatStgName;
            ptszStatStgName = NULL;
        }

        if(STG_S_CONVERTED == hr)
        {
            // If it comes here and hr is STG_S_CONVERTED, rest hr to S_OK.

            hr = S_OK;
        }
 
        // Commit the newly converted storage

        if(S_OK == hr)
        {
            hr = pvcnTemp->Commit(STGC_DEFAULT);

            if(S_OK != hr)
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("IStg::Commit failed, hr=0x%lx"), hr));
                break;
            }
        }

        // Enumerate this converted storage

        if(S_OK == hr)
        {
            hr = pvcnTemp->EnumElements(0, NULL, 0, &penumWalkConv);

            if(S_OK != hr)
            {
                DH_TRACE((DH_LVL_TRACE1, TEXT("IStg::EnumElem fail, hr=0x%lx"), hr));
                break;
            }
        }
        
        // Check the elements in conv storage.  There should be only one 
        // stream with name CONTENTS in this converted storage. If otherwise,
        // it is an error.

        cElementsInConvStg = 0;
        while(S_OK == hr && S_OK == penumWalkConv->Next(1, &statStgConv, NULL))
        {
            cElementsInConvStg++;

            // Convert statStg.pwcsName to TCHAR

            hr = OleStringToTString(statStgConv.pwcsName, &ptszStatStgConvName); 

            if(S_OK == hr)
            {
                if((STGTY_STREAM != statStgConv.type) ||
                    (0 != _tcscmp(STG_CONVERTED_NAME, ptszStatStgConvName)))
                {
                    DH_TRACE((
                        DH_LVL_TRACE1,
                        TEXT("Conv stg contains other than CONTENTS stm.")));
            
                    fPass = FALSE;
                    break;
                }


                pvsnTempConv = pvcnTemp->GetFirstChildVirtualStmNode();

                while((NULL != pvsnTempConv) &&
                      (0 != _tcscmp(
                                ptszStatStgConvName, 
                                pvsnTempConv->GetVirtualStmNodeName())))
                {
                    pvsnTempConv = pvsnTempConv->GetFirstSisterVirtualStmNode();
                }

                DH_ASSERT(NULL != pvsnTempConv);
            }
 
            // Open the stream and Read its contents

            if(S_OK == hr)
            {
                hr = pvsnTempConv->Open(NULL, STGM_SHARE_EXCLUSIVE|STGM_READ,0);
            }
 
            if(S_OK == hr)
            {
                hr = ReadAndCalculateDiskCRCForStm(pvsnTempConv,&dwActCRC);
            }

            // Delete the temp string

            if(NULL != ptszStatStgConvName)
            {
                delete ptszStatStgConvName;
                ptszStatStgConvName = NULL;
            }

            // Release name

            if ( NULL != statStg.pwcsName)
            {
                pMalloc->Free(statStgConv.pwcsName);
                statStgConv.pwcsName = NULL;
            }
        }

        // Release penumWalkConv

        if(NULL != penumWalkConv)
        {
            ulRef = penumWalkConv->Release();
            DH_ASSERT(0 == ulRef);
            penumWalkConv = NULL;
        }

        // Close child

        if(S_OK == hr)
        {
            hr = pvcnTemp->Close();

            if(S_OK != hr)
            {
                DH_TRACE((
                    DH_LVL_TRACE1,
                    TEXT("VCN::Close failed unexp, hr=0x%lx"),
                    hr));
                break;
            }
        }

        // Verify that converted storage has only one CONTENTS stream in it

        if(1 != cElementsInConvStg)
        {
            DH_TRACE((
              DH_LVL_TRACE1,
              TEXT("Convert stg has other elements besides CONTENTS stm")));
            
            fPass = FALSE;
            break;
        }
        
        // Verify that CRC's match of original stream and CONTENTS stream in
        // this converted storage

        if(dwMemCRC.dwCRCData == dwActCRC.dwCRCData)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC of org stm and CONTENTS stm in conv stg match")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CRC org stm and CONTENTS stm in convstg don't match")));
            fPass = FALSE;
            break;
        }

        // Release name

        if ( NULL != statStg.pwcsName)
        {
            pMalloc->Free(statStg.pwcsName);
            statStg.pwcsName = NULL;
        }
    }

    // Release penumWalk

    if(NULL != penumWalk)
    {
        ulRef = penumWalk->Release();
        DH_ASSERT(0 == ulRef);
        penumWalk = NULL;
    }

    if(NULL != pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ENUMTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation ENUMTEST_100 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:   ENUMTEST_101 
//
// synopsis: A random root DF is created with random number of storages/streams
//       committed/close/reopened. An enumerator is obtained in random chunks 
//       and the child objects found are counted.  The hierarchy is recursed 
//       into so that all objects in the docfile are counted.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  23-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LINEXT.CXX
// 2.  Old name of test : LegitInstEnumNext Test 
//     New Name of test : ENUMTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-101
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-101
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-101
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ENUMTEST-101
//
//-----------------------------------------------------------------------------

HRESULT ENUMTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;
    ULONG           cTotalStg               = 0;
    ULONG           cTotalStm               = 0;
    ULONG           cEnumStg                = 0;
    ULONG           cEnumStm                = 0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ENUMTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_101 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("IEnumSTATSTG::Next in Random chunks and verify ")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ENUMTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Find the total number of elements in the DocFile

    if(S_OK == hr)
    {
        hr = EnumerateInMemoryDocFile(pVirtualDFRoot, &cTotalStg, &cTotalStm);

        DH_HRCHECK(hr, TEXT("EnumerateInMemoryDocFile")) ;
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Reopen the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    //  The named docfile/IStorage is instantiated and an enumerator
    //  is obtained.  The docfile is walked in random chunks and each
    //  contained IStorage/IStream is counted.  If the object returned
    //  by ->Next() is an IStorage, it is recursed into and processed.

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }
 
    // Enumerate the DocFile in Random chunks

    if(S_OK == hr)
    {
        hr = EnumerateDocFileInRandomChunks(
                pVirtualDFRoot,
                pdgi,
                dwStgMode,
                cTotalStg+cTotalStm,
                &cEnumStg,
                &cEnumStm);

        DH_HRCHECK(hr, TEXT("EnumerateDocFileInRandomChunks")) ;
    }

    // Verify results

    if(S_OK == hr)
    {
        if(cEnumStg == cTotalStg)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Storages enum by IEnum::Next in rand chunks as exp")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Storages enum by IEnum::Next in rand chunks not exp")));
           
            fPass = FALSE;
        } 

        if(cEnumStm == cTotalStm)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Streams enum by IEnum::Next in rand chunks as exp")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Streams enum by IEnum::Next in rand chunks not exp")));
           
            fPass = FALSE;
        } 
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ENUMTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation ENUMTEST_101 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:   ENUMTEST_102 
//
// synopsis: A random root DF is created with random number of storages/streams
//       committed/close/reopened. An enumerator is obtained and docfile enum-
//       erated.  A clone is made of enumerator. The clone uses Reset/Skip/Next
//       methods of enumerator to verify each of the objects found through the
//       original enumerator to see that it is the same.  All child objects 
//       found are counted and the hierarchy is recursed into so that all 
//       objects in the docfile are counted. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  24-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LISKIP.CXX
// 2.  Old name of test : LegitInstEnumSkip Test 
//     New Name of test : ENUMTEST_102 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-102
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-102
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-102
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ENUMTEST-102
//
//-----------------------------------------------------------------------------

HRESULT ENUMTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    BOOL            fPass                   = TRUE;
    ULONG           cTotalStg               = 0;
    ULONG           cTotalStm               = 0;
    ULONG           cEnumStg                = 0;
    ULONG           cEnumStm                = 0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ENUMTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_102 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("IEnumSTATSTG::Clone/Reset/Skip/Next ops verify ")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ENUMTEST_102, Access mode: %lx"),
            dwRootMode));
    }

    //BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Find the total number of elements in the DocFile

    if(S_OK == hr)
    {
        hr = EnumerateInMemoryDocFile(pVirtualDFRoot, &cTotalStg, &cTotalStm);

        DH_HRCHECK(hr, TEXT("EnumerateInMemoryDocFile")) ;
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Reopen the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->OpenRoot(
                NULL,
                dwRootMode, 
                NULL,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr=0x%lx."),
            hr));
    }

    //  The named docfile/IStorage is instantiated and an enumerator
    //  is obtained. The docfile is enumerated all objects at one level.
    //  A clone is made of the enumerator, and it uses reset/skip/next
    //  methods of enumerator to verify each of the child objects found.  
    //  Each contained IStorage/IStream is counted.  If the object returned
    //  by ->Next() is an IStorage, it is recursed into and processed.

    if(S_OK == hr)
    {
        hr = EnumerateDocFileAndVerifyEnumCloneResetSkipNext(
                pVirtualDFRoot,
                dwStgMode,
                cTotalStg+cTotalStm,
                &cEnumStg,
                &cEnumStm);

        DH_HRCHECK(hr, TEXT("EnumerateDocFileInRandomChunks")) ;
    }

    // Verify results

    if(S_OK == hr)
    {
        if(cEnumStg == cTotalStg)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Stg enum by org and clone/reset/skip/next as exp")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Stg enum by org and clone/reset/skip/next notas exp")));
           
            fPass = FALSE;
        } 

        if(cEnumStm == cTotalStm)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Stm enum by org and clone/reset/skip/next as exp")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Stm enum by org and clone/reset/skip/next notas exp")));
           
            fPass = FALSE;
        } 
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ENUMTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation ENUMTEST_102 failed, hr=0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:   ENUMTEST_103 
//
// synopsis: A random root DF is created with random number of storages/streams
//          committed/close/reopened. 
//          From 4 to 8 times, the root IStorage (docfile) is instantiated and
//          an enumerator is obtained.  A Stat call is made on the the IStorage
//          and then the IStorage is enumerated.  About 10% of the time
//          the current object is either destroyed, renamed, or modified.
//          Once every 1 to 64 objects is enumerated, a new IStorage (33%)
//          or IStream (66%) is created in the parent IStorage.  If an object
//          was destroyed, renamed, changed, or added, the parent IStorage is
//          committed 50% of time. If the current object returned by the 
//          enumerator is an IStorage (that wasn't deleted), the test recurses 
//          and repeats the above for that IStorage.  Then 33% of time, the
//          storage is reverted, 66% committed.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  30-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LITERMOD.CXX
// 2.  Old name of test : LegitInstEnumIterMod Test 
//     New Name of test : ENUMTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:0-3 /t:ENUMTEST-103
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:0-3 /t:ENUMTEST-103
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-2 /dfstg:1-3 /dfstm:0-3 /t:ENUMTEST-103
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ENUMTEST-103
//
//-----------------------------------------------------------------------------

HRESULT ENUMTEST_103(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPSTORAGE       pIStorage               = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    UINT            cRandomMinVars          = 4;
    UINT            cRandomMaxVars          = 8;
    UINT            cRandomVars             = 0;
    UINT            cRandomAction           = 0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ENUMTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_103 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("IEnumSTATSTG::Next docfile,Create/Change/Commit/Revert elem")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ENUMTEST_105, Access mode: %lx"),
            dwRootMode));
    }

    // BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }

    // Generate random number of variations that would be performed.

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cRandomVars, cRandomMinVars, cRandomMaxVars);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    } 

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        DH_ASSERT(NULL != pdgu);
    }

    while((0 != cRandomVars--) && (S_OK == hr))
    {
        // Generate Random number to see whether changes would be reverted/
        // committed at end of lop.  If need to be reverted, then make a 
        // copy of VirtualDF which can be used later on

        usErr = pdgi->Generate(&cRandomAction, 0, 3);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }

        // Reopen the Root Docfile.

        if (S_OK == hr)
        {
            hr = pVirtualDFRoot->OpenRoot(
                    NULL,
                    dwRootMode, 
                    NULL,
                    0);
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
        }

        if (S_OK == hr)
        {
            pIStorage = pVirtualDFRoot->GetIStoragePointer();
        
            DH_ASSERT(NULL != pIStorage);
        }

        //  The named docfile/IStorage is instantiated and an enumerator
        //  is obtained.  The docfile is walked by getting or skipping 
        //  random number of elements.  If the child object got is a storage,
        // it is recursed into

        // Enumerate and walk DocFile by randomly getting/skipping random elem
        // -ents. 

        if(S_OK == hr)
        {
            hr = EnumerateAndProcessIStorage(
                    pIStorage,
                    dwStgMode,
                    pdgi,
                    pdgu);

            DH_HRCHECK(hr, TEXT("EnumerateAndProcessIStorage")) ;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("EnumerateAndProcessIStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("EnumerateAndProcessIStorage unsuccessful, hr=0x%lx."),
                hr));
        }

        // Close the root docfile

        if (S_OK == hr)
        {
            hr = pVirtualDFRoot->Close();

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        }
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ENUMTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation ENUMTEST_103 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:   ENUMTEST_104 
//
// synopsis: A random root DF is created with random number of storages/streams
//          committed/close/reopened. From 4 - 8 times, the root DocFile is
//          instantiated and an enumerator is obtained. The root docfile is
//          walked by getting or skipping a random number of elements and if
//          child element got is a child storage, recursing into it.  There is
//          33% chance of skipping elements and 67% chance of getting them. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  29-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, transacted deny write modes
//
// New Test Notes:
// 1.  Old File: LIWALK.CXX
// 2.  Old name of test : LegitInstEnumWalk Test 
//     New Name of test : ENUMTEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-104
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-104
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:1-1 /dfstg:1-3 /dfstm:1-3 /t:ENUMTEST-104
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ENUMTEST-104
//
//-----------------------------------------------------------------------------

HRESULT ENUMTEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    ULONG           cTotalStg               = 0;
    ULONG           cTotalStm               = 0;
    UINT            cRandomMinVars          = 4;
    UINT            cRandomMaxVars          = 8;
    UINT            cRandomVars             = 0;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ENUMTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_104 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("IEnumSTATSTG::Next/Skip randomly to walk DocFile ")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ENUMTEST_104, Access mode: %lx"),
            dwRootMode));
    }

    //BUGBUG df already commited

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
    }

    // Commit root. 

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }
   
    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot, 
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Find the total number of elements in the DocFile

    if(S_OK == hr)
    {
        hr = EnumerateInMemoryDocFile(pVirtualDFRoot, &cTotalStg, &cTotalStm);

        DH_HRCHECK(hr, TEXT("EnumerateInMemoryDocFile")) ;
    }

    // Close the Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }

    // Get DG_INTEGER object pointer

    if (S_OK == hr)
    {
        pdgi = pTestVirtualDF->GetDataGenInteger();

        DH_ASSERT(NULL != pdgi);
    }

    // Generate random number of variations that would be performed.

    if (S_OK == hr)
    {
        // Generate random size for stream.

        usErr = pdgi->Generate(&cRandomVars, cRandomMinVars, cRandomMaxVars);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    } 

    while(0 != cRandomVars--)
    {
        // Reopen the Root Docfile.

        if (S_OK == hr)
        {
            hr = pVirtualDFRoot->OpenRoot(
                    NULL,
                    dwRootMode, 
                    NULL,
                    0);
            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
        }

        //  The named docfile/IStorage is instantiated and an enumerator
        //  is obtained.  The docfile is walked by getting or skipping 
        //  random number of elements.  If the child object got is a storage,
        // it is recursed into

        // Enumerate and walk DocFile by randomly getting/skipping random elem
        // -ents. 

        if(S_OK == hr)
        {
            hr = EnumerateAndWalkDocFile(
                    pVirtualDFRoot,
                    pdgi,
                    dwStgMode,
                    cTotalStg+cTotalStm);

            DH_HRCHECK(hr, TEXT("EnumerateAndWalkDocFile")) ;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("EnumerateAndWalkDocFile completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("EnumerateAndWalkDocFile unsuccessful, hr=0x%lx."),
                hr));
        }

        // Close the root docfile

        if (S_OK == hr)
        {
            hr = pVirtualDFRoot->Close();

            DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
        }
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation ENUMTEST_104 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation ENUMTEST_104 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ENUMTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\flattsts.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:      flattsts.cxx
//
//  Contents:  miscellaneous tests for flatfile storage
//
//  Functions:  
//
//  History:    22-Jan-1998    BogdanT created
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"

// for non _OLE_NSS_, funcs are stubbed out below
#ifdef _OLE_NSS_

//----------------------------------------------------------------------------
//
// Test:    FLATTEST_100 
//
// Synopsis: Check if STGM_CREATE flag is NOT returned by IStorage::Stat
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
//  History:    22-Jan-1998    BogdanT created
//
// Notes:    To run the test, do the following at command prompt:
//           stgbase /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:MISCTEST-100
//           /dfRootMode:dirReadWriteShEx /createas:flatfile
//
//-----------------------------------------------------------------------------

HRESULT FLATTEST_100(int argc, char *argv[])
{
    HRESULT         hr                          = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    VirtualDF       *pTestVirtualDF             = NULL;
    VirtualCtrNode  *pVirtualDFRoot             = NULL;
    DWORD           dwRootMode                  = 0;
    STATSTG         statStg;    

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("FLATTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation FLATTEST_100 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Check if IStorage::Stat does NOT return STGM_CREATE flag")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for FLATTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Stat(&statStg, STATFLAG_NONAME);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    }

    if(statStg.grfMode & STGM_CREATE)
    {
        hr = E_FAIL;
        DH_TRACE((
           DH_LVL_ERROR,
           TEXT("Stat returned STGM_CREATE"),
           hr));
    }

    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }
 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation FLATTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation FLATTEST_100 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation FLATTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

#else
HRESULT FLATTEST_100(int argc, char *argv[]) { return E_NOTIMPL; }
#endif //_OLE_NSS_

// for non _OLE_NSS_, funcs are stubbed out below
#ifdef _OLE_NSS_

//----------------------------------------------------------------------------
//
// Test:    FLATTEST_101 
//
// Synopsis: Check that a real docfile (created with STGFMT_DOCFILE can't be 
//           opened as a flatfile with STGFMT_FILE). 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  19/3/98    Narindk     created
//
// Notes:    To run the test, do the following at command prompt:
//           stgbase /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:FLATTEST-101
//           /dfRootMode:dirReadWriteShEx  /dfname:FLATTEST101
//
//          This test tries to open a docfile as a flatfile.  In test DFTEST106
//          vice versa of this is tested already.  It is allowed to open a
//          flatfile as a docfile, but not vice versa.
//
//-----------------------------------------------------------------------------

HRESULT FLATTEST_101(int argc, char *argv[])
{
    HRESULT         hr                          = S_OK;
    HRESULT         hr2                         = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode                  = 0;
    LPSTORAGE       pIStorageOpen               = NULL;
    LPOLESTR        poszFileName                = NULL;
    DWORD           reserved                    = 0; 

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("FLATTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation FLATTEST_101 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Check a docfile (STGFMT_DOCFILE) cant be opened as flatfile")));

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    // GetRootDocFile mode

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_106, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get RootDocFile name

    if (S_OK == hr)
    {
        if(NULL != pTestChanceDF->GetDocFileName())
        {
            pRootDocFileName = 
                new TCHAR[_tcslen(pTestChanceDF->GetDocFileName())+1];

            if (pRootDocFileName == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                _tcscpy(pRootDocFileName, pTestChanceDF->GetDocFileName());
            }
        }
        else
        {
            DH_ASSERT(!"No DocFile name passed from cmd line!") ;
        }

        DH_HRCHECK(hr, TEXT("pTestChanceDF->GetDocFileName()")) ;
    }

    if(S_OK == hr)
    {
        // Convert DocFile name to OLECHAR

        hr = TStringToOleString(pRootDocFileName,&poszFileName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Root docfile name %s."), poszFileName));
    }

    if(S_OK == hr)
    {
        hr = StgCreateStorageEx (
                poszFileName,
                dwRootMode | STGM_CREATE,
                STGFMT_DOCFILE,  //force it to be a docfile
                0,
                NULL, 
                NULL,
                IID_IStorage,
                (void**)&pIStorageOpen);

        DH_TRACE((DH_LVL_TRACE1, 
            TEXT("StgCreateStorageEx (df); mode=%#lx; hr=%#lx"), dwRootMode,hr));

        if(NULL != pIStorageOpen)
        {
            pIStorageOpen->Release();
            pIStorageOpen = NULL;
        }
    }

    // Open the above doc file as docfile, should succeed

    if(S_OK == hr)
    {
        hr = StgOpenStorageEx (
                poszFileName,
                dwRootMode,
                STGFMT_DOCFILE,  //open as docfile
                0,
                NULL,
                NULL,                
                IID_IStorage,
                (void**)&pIStorageOpen);

        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgOpenStorageEx on docfile as docfile;mode=%#lx; hr=%#lx"), 
            dwRootMode, hr)); 

        if(S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorageEx failed unexp, hr=0x%lx ."),
                hr));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorageEx passed  as exp, hr=0x%lx ."),
                hr));
        }

        if(NULL != pIStorageOpen)
        {
            pIStorageOpen->Release();
            pIStorageOpen = NULL;
        }
    }

    // Now open above docfile as a flatfile

    if(S_OK == hr)
    {
        hr = StgOpenStorageEx (
                poszFileName,
                dwRootMode,
                STGFMT_FILE,  //force it to be a flatfile
                0,
                NULL,
                NULL,                
                IID_IStorage,
                (void**)&pIStorageOpen);

        DH_TRACE((
            DH_LVL_TRACE1, 
            TEXT("StgOpenStorageEx as flatfile on docfile;mode=%#lx; hr=%#lx"), 
            dwRootMode, hr)); 

        // BUGBUG: Check what expected error code from this?  We are getting
        // invalid argument as of present.  Have raided bug to come with a
        // uniform error for handling of mismatched format rejection -
        // e.g a docfile being opened as NSS file returns file already exists
        // error and a docfile being opene as flatfile returns invalid arg 
        // Change this with what the outcome of the bug is
 
        if(S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorageEx as NFF on DF failed as exp, hr=0x%lx ."),
                hr));
            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorageEx as NFF on DF passed unexp, hr=0x%lx ."),
                hr));
            hr = E_FAIL;
        }

        if(NULL != pIStorageOpen)
        {
            pIStorageOpen->Release();
            pIStorageOpen = NULL;
        }
    }
 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation FLATTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation FLATTEST_101 failed, hr = 0x%lx."),
            hr) );
    }


    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation FLATTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    // Delete temp string

    if(NULL != poszFileName)
    {
        delete poszFileName;
        poszFileName = NULL;
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete temp string

    if(NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    return hr;
}

#else
HRESULT FLATTEST_101(int argc, char *argv[]) { return E_NOTIMPL; }
#endif //_OLE_NSS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\dftests.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       dftests.cxx
//
//  Contents:   storage base tests basically pertaining to DocFile in general. 
//
//  Functions:  
//
//  History:    3-June-1996     NarindK     Created.
//              27-Mar-97       SCousens    conversionified
//
//--------------------------------------------------------------------------

//BUGBUG: BUGNOTE: All not for conversion need a second look. -scousens

#include <dfheader.hxx>
#pragma hdrstop

#include <sys/stat.h>
#include <share.h>
#include <errno.h> //get errors for our runtime calls

#include  "init.hxx"

//----------------------------------------------------------------------------
//
// Test:    DFTEST_100 
//
// Synopsis: Regression test to create a root docfile. Commit the root docfile.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    3-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: DFCOMMIT.CXX
// 2.  Old name of test : LegitRootNormal 
//     New Name of test : DFTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-100
//        /dfRootMode:dirReadWriteShEx /dfname:DFCOMMIT.DFL
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-100
//        /dfRootMode:xactReadWriteShEx /dfname:DFCOMMIT.DFL 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-100
//        /dfRootMode:xactReadWriteShDenyW /dfname:DFCOMMIT.DFL
//
// BUGNOTE: Conversion: DFTEST-100 NO
//
//-----------------------------------------------------------------------------


HRESULT DFTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_100 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Regression test for Root DocFile creation/commit. ")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {                   
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_100, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }


    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr = 0x%lx."),
            hr));

    }

    // BUGBUG:  Use Random commit modes...

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Call Release on root docfile

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_100 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_100 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    DFTEST_101 
//
// Synopsis: Regression test to create a root docfile, commit the root docfile,
//           release the toot docfile and remove the docfile.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    3-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: DFREMOVE.CXX
// 2.  Old name of test :  
//     New Name of test : DFTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-101
//        /dfRootMode:dirReadWriteShEx /dfname:DFREMOVE.DFL 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-101
//        /dfRootMode:xactReadWriteShEx /dfname:DFREMOVE.DFL 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-101
//        /dfRootMode:xactReadWriteShDenyW /dfname:DFREMOVE.DFL 
//
// BUGNOTE: Conversion: DFTEST-101 NO
// 
//-----------------------------------------------------------------------------


HRESULT DFTEST_101(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_101 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Regression for RootDocFile creation/commit/release/removal.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_101, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr = 0x%lx."),
            hr));

    }

    // Commit the root docfile with STGC_ONLYIFCURRENT mode.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_ONLYIFCURRENT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Call Release on root docfile

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_101 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_101 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_101 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    DFTEST_102 
//
// Synopsis: Regression test to create a root docfile, commit the root docfile,
//           release the root docfile.  Verify using StgIsStorageFile API.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    3-June-1996     NarindK     Created.
//
// Notes:    This test runs in transacted mode. 
//
// New Test Notes:
// 1.  Old File: DFROOT.CXX
// 2.  Old name of test : TransactedCommitTest  
//     New Name of test : DFTEST_102 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-102
//        /dfRootMode:xactReadWriteShEx /dfname:DFROOT.DFL 
//
// BUGNOTE: Conversion: DFTEST-102 NO
//
//  StgIsOpenStorage returns S_OK in transacted mode before Commit is done.
//-----------------------------------------------------------------------------


HRESULT DFTEST_102(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pFileName               = NULL;
    LPOLESTR        pOleStrTemp             = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_102"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_102 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Regression test for RootDocFile creation/commit/release")));
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("in transacted mode.  Use StgIsStorageFile to verify.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_102, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr = 0x%lx."),
            hr));

    }

    if(S_OK == hr)
    {
        // Convert DocFile name to OLECHAR

        hr = TStringToOleString(pTestVirtualDF->GetDocFileName(), &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Use StgIsStorageFile now.  This should return S_OK since even if 
    // commit is not done till this point, signature is written into it.
    // This is different frol old base tests since this enhancement is
    // checked in by Storage team (confirmed by PhilipLa)

    if (S_OK == hr)
    {
        hr = StgIsStorageFile(pOleStrTemp);

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgIsStorage returned hr = 0x%lx as expected."), hr));

        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgIsStorage returned hr = 0x%lx unexpectedly."), hr));
        }
    } 

    // Commit the root docfile with STGC_ONLYIFCURRENT mode.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_ONLYIFCURRENT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Use StgIsStorageFile now.  This should again return S_OK since commit is
    // done by now.

    if (S_OK == hr)
    {
        hr = StgIsStorageFile(pOleStrTemp);

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgIsStorage returned hr = 0x%lx as expected."), hr));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("StgIsStorage returned hr = 0x%lx unexpectedly."), hr));
        }
    } 

    // Call Release on root docfile

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_102 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_102 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestVirtualDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestVirtualDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_102 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    DFTEST_103 
//
// Synopsis: Regression test to create and instantiate a root docfile with path 
//           as part of the name.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    3-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: DFTESTN.CXX
// 2.  Old name of test :  
//     New Name of test : DFTEST_103 
// 3.  To run the test, do the following at command prompt. 
//     stgbase /seed:0  /t:DFTEST-103
//
// BUGNOTE: Conversion: DFTEST-103 NO
//
//-----------------------------------------------------------------------------


HRESULT DFTEST_103(ULONG ulSeed)
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    LPSTORAGE       pIRootStorage           = NULL;
    DWORD           dwLen                   = 0;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    LPTSTR          pFileName               = NULL;
    LPOLESTR        poszFileName            = NULL;
    TCHAR           tszFileName[MAX_PATH+1]; 
    ULONG           ulRef                   = 0;
    DWORD           dwDirectMode            = STGM_DIRECT |
                                              STGM_READWRITE |
                                              STGM_SHARE_EXCLUSIVE;
    DWORD           dwTransactedMode        = STGM_TRANSACTED |
                                              STGM_READWRITE |
                                              STGM_SHARE_EXCLUSIVE;
    DWORD           dwTransactedDWMode      = STGM_TRANSACTED |
                                              STGM_READWRITE |
                                              STGM_SHARE_DENY_WRITE;
    DWORD           dwRootMode[3]           = {dwDirectMode,    
                                               dwTransactedMode,
                                               dwTransactedDWMode};
    INT             count                   = 0;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_103"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_103 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Regression for RootDF creation with path as part of name.")));

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random strings.

        pdgu = new(NullOnFail) DG_STRING(ulSeed);

        if (NULL == pdgu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Generate random name for root 

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pFileName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    // Determine current directory path (so that a MAX_PATH long
    // filename can be constructed).

    if (S_OK == hr) 
    {
        dwLen = GetCurrentDirectory(MAX_PATH, tszFileName);

        if (0 == dwLen) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GetCurrentDirectory"));
        }
    }

    if (S_OK == hr) 
    {
        _tcscat(tszFileName, SZ_SEP);
        _tcscat(tszFileName, pFileName);

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Name of root docfile %ws for DFTEST_103 "),
            tszFileName));
    }

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR

        hr = TStringToOleString(tszFileName, &poszFileName);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // First attempt test with Direct mode.

    while((count<3) && (S_OK == hr))
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_103, Access mode: %lx"),
            dwRootMode[count]));

        // Only direct mode is supported for flatfiles, so do accordingly
       
        // ----------- flatfile change ---------------
        if(StorageIsFlat() && ( dwDirectMode != dwRootMode[count]))
        {
            break;
        }
        // ----------- flatfile change ---------------
 
        // Call StgCreateDocFile with path in file name.  

        if (S_OK == hr)
        {
            hr = StgCreateDocfile(
                    poszFileName,
                    STGM_CREATE | dwRootMode[count],
                    0,
                    &pIRootStorage);
        }
    
        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgCreateDocfile completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgCreateDocfile unsuccessful, hr = 0x%lx."),
                hr));
        }

        // Commit

        if (S_OK == hr)
        {
            hr = pIRootStorage->Commit(STGC_DEFAULT);
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Commit unsuccessful, hr = 0x%lx."),
                hr));
        }

        // Call Release on root docfile

        if (S_OK == hr)
        {
            ulRef = pIRootStorage->Release();
            DH_ASSERT(0 == ulRef);
            pIRootStorage = NULL;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Release completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Release unsuccessfull, hr = 0x%lx."),
                hr));
        }

        // Instantiate the RootDocFile again

        if (S_OK == hr)
        {
            hr = StgOpenStorage(
                    poszFileName,
                    NULL,
                    dwRootMode[count],
                    NULL,
                    0,
                    &pIRootStorage);

            DH_HRCHECK(hr, TEXT("StgOpenStorage")) ;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorage completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("StgOpenStorage unsuccessful, hr = 0x%lx."),
                hr));
        }

        // Call Release on root docfile

        if (S_OK == hr)
        {
            ulRef = pIRootStorage->Release();
            DH_ASSERT(0 == ulRef);
            pIRootStorage = NULL;
        }

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Release completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("IStorage::Release unsuccessful, hr = 0x%lx."),
                hr));
        }
        
        count++;
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_103 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_103 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete temp string

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    if(NULL != poszFileName)
    {
        delete poszFileName;
        poszFileName = NULL;
    }

    // Delete data gen object 

    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_103 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    DFTEST_104 
//
// Synopsis: Regression test to create, instantiate and enumerate a root 
//           docfile hierarchy and count objects.   
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    3-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct mode. 
//
// New Test Notes:
// 1.  Old File: DFVERIFY.CXX
// 2.  Old name of test : MiscDfVerify  
//     New Name of test : DFTEST_104 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-5 /dfstg:0-5 /dfstm:0-10 /t:DFTEST-104
//        /dfRootMode:dirReadWriteShEx 
//
// BUGNOTE: Conversion: DFTEST_104
// 
//-----------------------------------------------------------------------------


HRESULT DFTEST_104(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPSTORAGE       pStgRoot                = NULL;
    ULONG           cStg                    = 0;
    ULONG           cStm                    = 0;
    ULONG           cMemStg                 = 0;
    ULONG           cMemStm                 = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_104"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_104 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Regression for RootDF creation/instantiation/enumeration.")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_104, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Enumerate the DocFile in memory and get the number of VirtualCtrNodes
    // and VirtualStmNodes.  Later on we could compare these statistics with
    // real IStorages / IStreams enumerated from the disk docfile. 

    if (S_OK == hr)
    {
        hr = EnumerateInMemoryDocFile(pVirtualDFRoot, &cMemStg, &cMemStm);

        DH_HRCHECK(hr, TEXT("EnumerateInMemoryDocFile"));
    }

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Clsoe all the substorages/streams

    if(S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

       DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Call Release on root docfile

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Instantiate the RootDocFile again

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(
                NULL,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr = 0x%lx."),
            hr));
    }

    if (S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();
        
        if(NULL == pStgRoot)
        {
          DH_LOG((LOG_INFO, 
            TEXT("pVirtualDFRoot->GetIStoragePointer failed to return IStorage")) );

          hr = E_FAIL;
        }
    }

    // Enumerate the Docfile on the disk

    if (S_OK == hr)
    {
        hr = EnumerateDiskDocFile(pStgRoot, VERIFY_SHORT, &cStg, &cStm);

        DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile"));
    }

    // Check the disk docfile enumeration with in memory docfile enumeration.

    if (S_OK == hr)
    {
        if((cMemStg == cStg) && (cMemStm == cStm))
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("DocFile correctly written & enumerated.")) );
        }
        else
        {
            hr = S_FALSE;

            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("DocFile not correctly written or enumerated.")) );
        }
    }

    // Call Release on root docfile

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_104 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_104 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_104 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}


//----------------------------------------------------------------------------
//
// Test:    DFTEST_105 
//
// Synopsis: Regression test to create and instantiate a root docfile with a
//           random name, a child IStorage within the root, and an additional
//           child storage within the first child IStorage. The first child is 
//           released before its child is released, verify no error.  The first 
//           child is reinstantiated.  The root IStorage is now released before 
//           the child IStorage, verify no error. 
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    3-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IIREL.CXX
// 2.  Old name of test : IllegitInstEnumRelease Test 
//     New Name of test : DFTEST_105 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-105
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-105
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-105
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: DFTEST-105
// 
//-----------------------------------------------------------------------------


HRESULT DFTEST_105(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DG_STRING       *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    VirtualCtrNode  *pvcnRootChildStorage   = NULL;
    LPTSTR          pRootChildStgName       = NULL;
    VirtualCtrNode  *pvcnChildChildStorage  = NULL;
    LPTSTR          pChildChildStgName      = NULL;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_105"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_105 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Create Root DF with Child IStg which has its Child IStg.")));
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Release first child IStg w/o releasing its child IStg.")));
    DH_TRACE((DH_LVL_TRACE1,
        TEXT("Reinstantiate 1st child IStg. Release root w/o releasing")));
    DH_TRACE((DH_LVL_TRACE1, TEXT("this IStg.  Verify no errors.")));

    // Create our ChanceDF and VirtualDF
    hr = CreateTestDocfile (argc, 
            argv, 
            &pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF);

    // if creating the docfile - bail here
    if (NULL != pTestChanceDF && DoingCreate ())
    {
        UINT ulSeed = pTestChanceDF->GetSeed ();
        CleanupTestDocfile (&pVirtualDFRoot, 
                &pTestVirtualDF, 
                &pTestChanceDF, 
                FALSE);
        return (HRESULT)ulSeed;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_105, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get DG_STRING object pointer

    if (S_OK == hr)
    {
        pdgu = pTestVirtualDF->GetDataGenUnicode();

        if(NULL == pdgu)
        {
          DH_LOG((LOG_INFO, 
            TEXT("pTestVirtualDF->GetDataGenUnicode failed")) );

          hr = E_FAIL;
        }
    }

    // Create a child IStorage in the root.

    // Generate a random name for child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE                |
                STGM_FAILIFTHERE,
                &pvcnRootChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr));
    }

    // Create a child IStorage inside the child IStorage.

    // Generate a random name for the new child IStorage

    if(S_OK == hr)
    {
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH, &pChildChildStgName);

        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    //    Adds a new storage to the root storage.

    if(S_OK == hr)
    {
        hr = AddStorage(
                pTestVirtualDF,
                pvcnRootChildStorage,
                pChildChildStgName,
                pTestChanceDF->GetStgMode()|
                STGM_CREATE                |
                STGM_FAILIFTHERE,
                &pvcnChildChildStorage);

        DH_HRCHECK(hr, TEXT("AddStorage")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::AddStorage not successful, hr = 0x%lx."),
            hr));
    }

    // Commit the storages

    // BUGBUG:  Use Random commit modes...

    if (S_OK == hr)
    {
        hr = pvcnChildChildStorage->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // BUGBUG:  Use Random commit modes...

    if (S_OK == hr)
    {
        hr = pvcnRootChildStorage->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // BUGBUG:  Use Random commit modes...

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Release child IStorage before its child is released, should
    // cause no error

    if (S_OK == hr)
    {
        hr = pvcnRootChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Release child's child IStorage 

    if (S_OK == hr)
    {
        hr = pvcnChildChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Reinstantiate the Root's child IStorage again

    if (S_OK == hr)
    {
        hr = pvcnRootChildStorage->Open(
                NULL,
                pTestChanceDF->GetStgMode(),
                NULL,
                0);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Open unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Call Release on root docfile before calling Release on its child.
    // Verify no error.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // Release Root's child IStorage now.

    if (S_OK == hr)
    {
        hr = pvcnRootChildStorage->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr = 0x%lx."),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_105 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_105 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup
    CleanupTestDocfile (&pVirtualDFRoot, 
            &pTestVirtualDF, 
            &pTestChanceDF, 
            S_OK == hr);

    // Delete strings

    if(NULL != pRootChildStgName)
    {
        delete pRootChildStgName;
        pRootChildStgName = NULL;
    }

    if(NULL != pChildChildStgName)
    {
        delete pChildChildStgName;
        pChildChildStgName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_105 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    DFTEST_106
 
//
// Synopsis: Attempts several illegitimate operations during creation of
//           root docfile.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:    3-June-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: IRCREATE.CXX
// 2.  Old name of test : IllegitRootCreate Test 
//     New Name of test : DFTEST_106 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-106
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//        /dfname:DFTEST.106 
//     b. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-106
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//        /dfname:DFTEST.106 
//     c. stgbase /seed:2 /dfdepth:0-0 /dfstg:0-0 /dfstm:0-0 /t:DFTEST-106
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//        /dfname:DFTEST.106 
//     
// BUGNOTE: Conversion: DFTEST-106 NO
// 
//-----------------------------------------------------------------------------

HRESULT DFTEST_106(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    DWORD           dwRootMode              = NULL;
    LPSTORAGE       pIStorage               = NULL;
    LPSTORAGE       pIStorageOpen           = NULL;
    LPOLESTR        pOleStrTemp             = NULL;
    FILE            *hFile                  = NULL;
    ULONG           ulRef                   = 0;
    BOOL            fPass                   = TRUE;
    int             iErr                    = 0;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("DFTEST_106"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_106 started.")) );
    DH_TRACE((DH_LVL_TRACE1,
       TEXT("Attempt illegitimate operations in creation of root docfile.")));

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    // GetRootDocFile mode

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for DFTEST_106, Access mode: %lx"),
            pTestChanceDF->GetRootMode()));
    }

    // Get RootDocFile name

    if (S_OK == hr)
    {
        if(NULL != pTestChanceDF->GetDocFileName())
        {
            pRootDocFileName = 
                new TCHAR[_tcslen(pTestChanceDF->GetDocFileName())+1];

            if (pRootDocFileName == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                _tcscpy(pRootDocFileName, pTestChanceDF->GetDocFileName());
            }
        }
        else
        {
            DH_ASSERT(!"No DocFile name passed from cmd line!") ;
        }

        DH_HRCHECK(hr, TEXT("pTestChanceDF->GetDocFileName()")) ;
    }

    // Make a directory with the same name DFTEST.106 that we would use to
    // create the directory.  Check that call to StgCreateDocFile succeeds

    if (S_OK == hr)
    {
        iErr = _tmkdir(pRootDocFileName);
        if (0 != iErr)
        {
            // if file already exists, try deleting it and try mkdir again
            if (ENOENT != errno)
            {
                iErr = DeleteFile (pRootDocFileName);
                if (FALSE == iErr)
                {
                    DH_TRACE ((DH_LVL_ERROR, 
                            TEXT("DeleteFile(%s) Failed. Error:%#lx"), 
                            pRootDocFileName, 
                            GetLastError ()));
                }
                iErr = _tmkdir(pRootDocFileName);
            }
        }
        if (0 != iErr)
        {
            hr = (EACCES == errno) ? ERROR_FILE_EXISTS : ERROR_FILE_NOT_FOUND;
            DH_HRCHECK (hr, TEXT("mkdir"));
        }
    }
    
    // Create the VirtualDocFile tree from the ChanceDocFile tree created in
    // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
    // and VirtualStmNodes.

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // This call to generate VirtualDF will call StgCreateDocFile API.  This
    // call is expected to fail since dir of same name exists.

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(pTestChanceDF, &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;

        if (STG_E_ACCESSDENIED != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Should fail when dir of same name exists,hr = 0x%lx "),hr));
        }
        else
        {
            DH_TRACE((
              DH_LVL_TRACE1,
              TEXT("Failed as exp when dir of same name exists,hr = 0x%lx"), hr));

            hr = S_OK;
        }
    }

    // Case 2: Try STGM_CONVERT as mode now.  This is also expected to fail, as
    // a dir of same name pre exists.

    if(S_OK == hr)
    {
        // Convert RootDocFile name to OLECHAR

        hr = TStringToOleString(pRootDocFileName, &pOleStrTemp);

        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Try creating with STGM_CONVERT mode.

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CONVERT | dwRootMode,
                0,
                &pIStorage);

        if (STG_E_ACCESSDENIED != hr)
        {
            DH_TRACE((
              DH_LVL_TRACE1,
              TEXT("Err:Pass(STGM_CONVERT) with existing same name dir,hr=0x%lx"),
              hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
              DH_LVL_TRACE1,
              TEXT("Exp:Fail(STGM_CONVERT)with existing same name dir,hr=0x%lx"),
              hr));

            hr = S_OK;
        }
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Remove the direcory DFTEST.106

    if (S_OK == hr)
    {
        iErr = _trmdir(pRootDocFileName);
        if (0 != iErr)
        {
            hr = (ENOENT == errno) ? ERROR_FILE_NOT_FOUND : ERROR_FILE_EXISTS;
            DH_HRCHECK (hr, TEXT("rmdir"));
        }
    }
    
    // Case 3:  Create DocFile when file exists and is being accessed in deny
    // write mode.

    if (S_OK == hr)
    {
        hFile = _tfsopen(pRootDocFileName, TEXT("w+"), _SH_DENYWR);
        DH_ASSERT(NULL != hFile);
    }

    // Try STGM_CREATE mode to create DocFile.  This call is expected to fail
    // as file exists and is being accessed in deny write mode. 

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CREATE | dwRootMode,
                0,
                &pIStorage);

        if (STG_E_SHAREVIOLATION != hr)
        {
            DH_TRACE((
              DH_LVL_TRACE1,
              TEXT("Err:Pass,same name file access in deny write mode, hr=0x%lx"),
              hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
              DH_LVL_TRACE1,
              TEXT("Exp;Fail,same name file access in deny write mode, hr=0x%lx"),
              hr));

            hr = S_OK;
        }
    }

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------

    // Try STGM_CONVERT mode to create DocFile.  This call is expected to fail
    // as file exists and is being accessed in deny write mode. 

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CONVERT | dwRootMode,
                0,
                &pIStorage);

        if (STG_E_SHAREVIOLATION != hr)
        {
            DH_TRACE((
             DH_LVL_TRACE1,
             TEXT("Err:Pass(STGM_CONVERT),same name file access in deny write mode")
             TEXT(", hr = 0x%lx "),
              hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
              DH_LVL_TRACE1,
              TEXT("Exp:Fail(STGM_CONVERT), same name file access in deny write \
              mode, hr = 0x%lx "), 
              hr));

            hr = S_OK;
        }
    }

// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Close handle

    if(NULL != hFile)
    {
        fclose(hFile);
    }

    // Change the mode to READ_ONLY and then try.

    if(S_OK ==  hr)
    {
        iErr = _tchmod(pRootDocFileName, _S_IREAD);
        DH_ASSERT (0 == iErr);
    }

    // Try STGM_CREATE mode to create DocFile.  This call is expected to fail
    // as file exists and is read only. 

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CREATE | dwRootMode,
                0,
                &pIStorage);

        if (STG_E_ACCESSDENIED != hr)
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Err:Pass,same name file exists and is read only,hr=0x%lx "),
                hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("Exp:Fail,same name file exists and is read only,hr = 0x%lx"),
               hr));

            hr = S_OK;
        }
    }

    // Try STGM_CONVERT mode to create DocFile.  This call is expected to fail
    // as file exists and is read only. 

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CONVERT | dwRootMode,
                0,
                &pIStorage);

        if (STG_E_ACCESSDENIED != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Err:Pass(STGM_CONVERT), same name file exists RO,hr=0x%lx"),
                hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Exp:Fail(STGM_CONVERT),same name file exists RO,hr=0x%lx"),
                hr));

            hr = S_OK;
        }
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    // Change mode to readwrite

    iErr = _tchmod(pRootDocFileName, _S_IREAD|_S_IWRITE);
    DH_ASSERT (0 == iErr);

    // Try to instantiate the pRootDocFileName which isn't a storage object 

    if (S_OK == hr)
    {
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                dwRootMode,
                NULL,
                0,
                &pIStorageOpen);

        // ----------- flatfile change ---------------
        if(!StorageIsFlat())
        {
        // ----------- flatfile change ---------------
        if(STG_E_FILEALREADYEXISTS == hr)
        {
           DH_TRACE((
             DH_LVL_TRACE1,
             TEXT("DocFile instantiated failed as exp with non stg obj hr=0x%lx"),
             hr));

           hr = S_OK;
        }
        else
        {
           DH_TRACE((
             DH_LVL_TRACE1,
             TEXT("DocFile instantiation passed unexp with non stg obj,hr=0x%lx"),
             hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorageOpen->Release ();
                pIStorageOpen = NULL;
            }
           fPass = FALSE;
        }
        }  
        else //  ----------- flatfile change ---------------
        {  
        if(S_OK == hr)
        {
           DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("Exp:Flatfile instantiation passed with non stg obj,hr=0x%lx"),
           hr));

           if (NULL != pIStorageOpen)
           {
                pIStorageOpen->Release ();
                pIStorageOpen = NULL;
           }
        }
        else
        {
           DH_TRACE((
           DH_LVL_TRACE1,
           TEXT("UnExp:Flatfile instantiation fail with nonstg obj,hr=0x%lx"),
           hr));
           fPass = FALSE;
           hr = S_OK; // Set hr to S_OK for further conditions test
        }
        // ----------- flatfile change ---------------
        }
        // ----------- flatfile change ---------------
    }

    // Remove the file

    iErr = _tremove(pRootDocFileName);
    DH_ASSERT (0 == iErr);

    // Call StgCreateDocFile with non zero data in dwReserved parameter.  This
    // call is expected to fail

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CREATE | dwRootMode,
                999,
                &pIStorage);

        if (STG_E_INVALIDPARAMETER != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Err:Pass with nonzero dwReserverd para, hr = 0x%lx "), 
                hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Exp: Fail with nonzero dwReserved parameter, hr=0x%lx "), 
                hr));

            hr = S_OK;
        }
    }

    // Call StgCreateDocFile with NULL 4th parameter.  This call is expected
    // to fail.

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CREATE | dwRootMode,
                0,
                NULL);

        if (STG_E_INVALIDPOINTER != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Should fail with NULL 4th parameter, hr = 0x%lx "), hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Failed as exp with NULL 4th parameter, hr = 0x%lx "), 
                hr));

            hr = S_OK;
        }
    }

    //  Call StgCreateDocFile with mode STGM_CREATE|STGM_CONVERT.  This call 
    // is expected to fail.

// ----------- flatfile change ---------------
    if(!StorageIsFlat())
    {
// ----------- flatfile change ---------------
    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CREATE | STGM_CONVERT,
                0,
                &pIStorage);

        if (STG_E_INVALIDFLAG != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Should fail with invalid mode, hr = 0x%lx "), hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorage->Release ();
                pIStorage = 0;
            }
            fPass = FALSE;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("Failed as expected with invalid mode., hr = 0x%lx "), hr));

            hr = S_OK;
        }
    }
// ----------- flatfile change ---------------
    }
// ----------- flatfile change ---------------

    //  Call StgCreateDocFile with all valid parameters.  This call is 
    //  expected to pass.

    if (S_OK == hr)
    {
        pIStorage = NULL;

        hr = StgCreateDocfile(
                pOleStrTemp, 
                STGM_CREATE | dwRootMode,
                0,
                &pIStorage);
 
       DH_HRCHECK(hr, TEXT("StgCreateDocFile")) ;

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("DocFile created successfully as expected hr = 0x%lx "),hr));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("DocFile creation failed unexpectedly, hr = 0x%lx "),hr));

            fPass = FALSE;
        }
    }

    // Instantiate DocFile again

    if (S_OK == hr)
    {
        hr = StgOpenStorage(
                pOleStrTemp,
                NULL,
                dwRootMode,
                NULL,
                0,
                &pIStorageOpen);

   
        if(STG_E_LOCKVIOLATION == hr)
        {
           DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("DocFile reinstantiated failed as expected hr = 0x%lx "),hr));
           hr = S_OK;
        }
        else
        {
           DH_TRACE((
               DH_LVL_TRACE1,
               TEXT("DocFile reinstantiation didn't fail unexp, hr = 0x%lx "),
               hr));

            // if it accidentally opened, close it
            if (S_OK == hr)
            {
                pIStorageOpen->Release ();
                pIStorageOpen = 0;
            }
           fPass = FALSE;
        }
    }

    // If everything goes okay, report test as passed, else failure

    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_106 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_106 failed, hr = 0x%lx."),
            hr) );
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Release storage pointer(s) 
 
    if (NULL != pIStorage)
    {
        ulRef = pIStorage->Release(); 
        DH_ASSERT(0 == ulRef);
    }

    if (NULL != pIStorageOpen)
    {
        ulRef = pIStorageOpen->Release(); 
        DH_ASSERT(0 == ulRef);
    }

    // Delete temp string

    if(NULL != pOleStrTemp)
    {
        delete pOleStrTemp;
        pOleStrTemp = NULL;
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        if(NULL != pVirtualDFRoot)
        {
            hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

            DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;
        }

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete temp string

    if(NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_106 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:    DFTEST_107 
//
// Synopsis: A random root DF is created with STGM_SIMPLE flag and tests done
//          on it.  STGM_SIMPLE mode can only be specified with STGM_CREATE,
//          STGM_READWRITE, STGM_SHARE_EXCLUSIVE flags.  There is no support
//          for substorages.  Each stream is atleast 4096 bytes in length, and
//          access to streams follow a linear pattern, i.e. once a stream is
//          released, it can't be opened or read/written again.  The following
//          IStorage methods: QueryInterface, AddRef, Release, CreateStream,
//          SetClass, Commit are supported.  SetElementTimes is supported with
//          NULL name, allowing applications to set time on root storage in
//          simple mode.  Supported IStream methods are QueryInterface, AddRef,
//          Release, SetSize, Read, Write, Seek. All the other methods return
//          STG_E_INVALIDFUNCTION.  
//                The test verifies the above restrictions on DocFile if STGM_
//          SIMPLE is specified in creation of a docfile.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  9-Aug-1996     NarindK     Created.
//           4-Nov-1996     BogdanT     Mac porting
//
// Notes:    This test runs in direct mode
//
// THIS TEST HAS A MEMORY LEAK IN OLE CODE: BUG 52975
//
// New Test Notes:
// 1.  Old File: STDDOC.CXX
// 2.  Old name of test : TestStdDocFile Test 
//     New Name of test : DFTEST_107 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:DFTEST-107
//
// BUGNOTE: Conversion: DFTEST-107
//
//-----------------------------------------------------------------------------

HRESULT DFTEST_107(ULONG ulSeed)
{

#ifdef _MAC  // Simple mode not ported yet; check with the developers
             // and remove this when ready

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!Simple mode DFTEST_107 crashes.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                      = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    VirtualStmNode  *pvsnRootMoreStream     = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    LPTSTR          pRootMoreStmName        = NULL;
    DG_STRING       *pdgu                   = NULL;
    DG_INTEGER      *pdgi                   = NULL;
    USHORT          usErr                   = 0;
    LPSTORAGE       pStgRoot                = NULL;
    DWORD           dwChildMode             = STGM_READWRITE |
                                              STGM_SHARE_EXCLUSIVE;
    LPSTORAGE       pStgChild               = NULL;
    LPSTREAM        pStmChild               = NULL;
    LPSTREAM        pStmChildTest           = NULL;
    OLECHAR         ocName[]                = {'f', 'o', 'o'}; 
    LPENUMSTATSTG   penumWalk               = NULL;
    ULONG           cb                      = 0;    
    ULONG           culWritten              = 0;
    ULONG           culRead                 = 0;    
    ULONG           cRandomMinSize          = 256;
    ULONG           cRandomMaxSize          = 2048;
    ULONG           cNum                    = 0;
    ULONG           cRandomMinNumStms       = 3;
    ULONG           cRandomMaxNumStms       = 6;
    LPTSTR          ptcsBuffer              = NULL;
    LPTSTR          ptcsSimpReadBuffer      = NULL;
    LPTSTR          ptcsReadBuffer          = NULL;
    BOOL            fRet                    = FALSE;
    FILETIME        cNewFileTime            = {dwDefLowDateTime,
                                              dwDefHighDateTime};
    BOOL            fPass                   = TRUE;
    ULONG           ulSizeOfStream          = 0;
    ULONG           cMemStg                 = 0;
    ULONG           cMemStm                 = 0;
    ULONG           cActStg                 = 0;
    ULONG           cActStm                 = 0;
    DWCRCSTM        dwMemCRC; 
    DWCRCSTM        dwActCRC; 
    SYSTEMTIME      cCurrentSystemTime;
    ULARGE_INTEGER  uliTest;
    STATSTG         statStg;
    FILETIME        cFileTime;
    CDFD            cdfd;
    LARGE_INTEGER   liStreamPos;
    ULARGE_INTEGER  uli;

    // Not for 2phase. Bail. 
    // Test needs STGM_CREATE bit which invalidates 2 phase test
    if (DoingDistrib () || DoingConversion ())
    {
        return S_OK;
    }

    dwMemCRC.dwCRCSum = dwActCRC.dwCRCSum = 0;

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_107"));
   
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_107 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Root created /w STGM_SIMPLE, chk IStorage/IStream restrict")));

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.
        pdgu = new(NullOnFail) DG_STRING (ulSeed);
        if (NULL == pdgu)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            //want to create only one seed. Once that has been done, 
            //use what we created from now on.
            ulSeed = pdgu->GetSeed(); 
        }
    }

    if (S_OK == hr)
    {
        // Generate random name for root 
        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pRootDocFileName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        cdfd.cDepthMin    = 0;
        cdfd.cDepthMax    = 0;
        cdfd.cStgMin      = 0;
        cdfd.cStgMax      = 0;
        cdfd.cStmMin      = 0;
        cdfd.cStmMax      = 0;
        cdfd.cbStmMin     = 0;
        cdfd.cbStmMax     = 0;
        cdfd.ulSeed       = ulSeed;
        cdfd.dwRootMode   = STGM_CREATE             |
                            STGM_DIRECT             |
                            STGM_READWRITE          |
                            STGM_SHARE_EXCLUSIVE    |
                            STGM_SIMPLE;

        hr = CreateTestDocfile (&cdfd, 
                pRootDocFileName,
                &pVirtualDFRoot,
                &pTestVirtualDF,
                &pTestChanceDF);
        DH_HRCHECK (hr, TEXT("CreateTestDocfile"));
    }

    if(S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();

        if(NULL == pStgRoot)
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::GetIStoragePointer() failed to return IStorage"),
                hr));
            hr = E_FAIL;
        }
    }        
    
    // These interfaces must fail for IStorage interface if the root docfile
    // is opened with STGM_SIMPLE flag.

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::CreateStorage"), 
           CreateStorage(ocName, dwChildMode|STGM_CREATE, 0, 0, &pStgChild),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::OpenStream"), 
           OpenStream(ocName, NULL, dwChildMode, 0, &pStmChild),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::OpenStorage"), 
           OpenStorage(ocName, NULL, dwChildMode, NULL, 0, &pStgChild),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::MoveElementTo"), 
           MoveElementTo(ocName, pStgChild, ocName, STGMOVE_MOVE),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::EnumElements"), 
           EnumElements(0, NULL, 0, &penumWalk),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::DestroyElement"), 
           DestroyElement(ocName),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::RenameElement"), 
           RenameElement(ocName, ocName),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::SetStateBits"), 
           SetStateBits(0, 0),
           hr);
    }

#ifndef WINNT
    // NT5 spec change. This is now supported on NT5.
    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::Stat"), 
           Stat(&statStg,STATFLAG_NONAME),
           hr);
    }
#endif

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::Revert"), 
           Revert(),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::SetElementTimes with Non-NULL name"), 
           SetElementTimes(ocName, &cFileTime, &cFileTime, &cFileTime),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStgRoot, 
           TEXT("IStorage::CopyTo"), 
           CopyTo(NULL, NULL, NULL, pStgChild),
           hr);
    }

    // Set Element time with NULL name which should pass for STGM_SIMPLE mode.
 
    if(S_OK == hr)
    {
        GetSystemTime(&cCurrentSystemTime);

        fRet = SystemTimeToFileTime(&cCurrentSystemTime, &cNewFileTime);

        DH_ASSERT(TRUE == fRet);
        DH_ASSERT(dwDefLowDateTime != cNewFileTime.dwLowDateTime);
        DH_ASSERT(dwDefHighDateTime != cNewFileTime.dwHighDateTime);
       
        hr = pStgRoot->SetElementTimes(
                NULL,
                &cNewFileTime,
                &cNewFileTime,
                &cNewFileTime); 
        DH_HRCHECK(hr, TEXT("IStorage::SetElementTimes with NULL name")) ;
    }

    // Now create a stream in it with size less than 4096 bytes.  If fewer
    // than 4096 bytes are written into the stream, by the time stream is
    // released, it would have extended to 4096 bytes.  

    if(S_OK == hr)
    {
        // Generate random name for stream
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random integers.
        pdgi = new(NullOnFail) DG_INTEGER(ulSeed);
        if (NULL == pdgi)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new")) ;
    }

    if (S_OK == hr)
    {
        // Generate random size for stream.
        usErr = pdgi->Generate(&cb, cRandomMinSize, cRandomMaxSize);
        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
        DH_HRCHECK(hr, TEXT("pdgi->Generate")) ;
    }

    if(S_OK == hr)
    {
        hr = AddStream(
                pTestVirtualDF,
                pVirtualDFRoot,
                pRootNewChildStmName,
                cb,
                STGM_READWRITE  |
                STGM_SHARE_EXCLUSIVE,
                &pvsnRootNewChildStream);
        DH_HRCHECK(hr, TEXT("AddStream")) ;
    }

    // With above stream size is set to less than 4096.  But as per STGM_SIMPLE,
    // the size would extend to 4096 by them time stream is released.

    if(S_OK == hr)
    {
        hr = GenerateRandomString(pdgu, cb, cb, &ptcsBuffer);
        DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
    }

    if (S_OK == hr)
    {
        hr =  pvsnRootNewChildStream->Write(
                ptcsBuffer,
                cb,
                &culWritten);
        DH_HRCHECK(hr, TEXT("VSN::Write in STGM_SIMPLE")) ;
    }

    // Calculate the CRC for stream data 

    if(S_OK == hr)
    {
        hr = CalculateInMemoryCRCForStm(
                pvsnRootNewChildStream,
                ptcsBuffer,
                cb,
                &dwMemCRC);
        DH_HRCHECK(hr, TEXT("CalculateInMemoryCRCForStm")) ;
    }

    // Check the read in STGM_SIMPLE mode.

    // Allocate a buffer of required size

    if (S_OK == hr)
    {
        ptcsSimpReadBuffer = new TCHAR [cb];
        if (NULL == ptcsSimpReadBuffer)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new")) ;
    }

    if(S_OK == hr)
    {
        // First seek to beginning of stream in STGM_SIMPLE mode.
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_SET, NULL);
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek in STGM_SIMPLE")) ;
    }

    if (S_OK == hr)
    {
        memset(ptcsSimpReadBuffer, '\0',  cb*sizeof(TCHAR));
        hr =  pvsnRootNewChildStream->Read(
                 ptcsSimpReadBuffer,
                 cb,
                 &culRead);
        DH_ASSERT(culRead == cb);
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Read in STGM_SIMPLE")) ;
    }


    // Test unsupported interfaces for IStream interface.  

    if(S_OK == hr)
    {
        pStmChild = pvsnRootNewChildStream->GetIStreamPointer();
        if(NULL == pStmChild)
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualStmNode->GetIStreamPointer() failed to return IStream"),
                hr));
            hr = E_FAIL;
        }
    }        
    
    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStmChild, 
           TEXT("IStream::CopyTo"), 
           CopyTo(pStmChildTest, uliTest, NULL, NULL),
           hr);
    }

    // Don't test IStream::Commit, since that returns STG_E_NOTIMPLEMENTED,
    // rather than STG_E_INVALIDFUNCTION

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStmChild, 
           TEXT("IStream::Revert"), 
           Revert(),
           hr);
    }

#ifndef WINNT
    // NT5 spec change. This is now supported on NT5.
    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStmChild, 
           TEXT("IStream::Stat"), 
           Stat(&statStg, STATFLAG_NONAME),
           hr);
    }
#endif

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStmChild, 
           TEXT("IStream::Clone"), 
           Clone(&pStmChildTest),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStmChild, 
           TEXT("IStream::LockRegion"), 
           LockRegion(uliTest, uliTest, 0),
           hr);
    }

    if(S_OK == hr)
    {
        TestUnsupportedInterface(
           pStmChild, 
           TEXT("IStream::UnlockRegion"), 
           UnlockRegion(uliTest, uliTest, 0),
           hr);
    }

    // Close child stream.

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }


    // Check the linear pattern of stream.  Make sure that the stream can't be
    // opened or be read , written again now.

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Open(NULL, dwChildMode, 0);
        hr = DH_HRERRORCHECK (hr, STG_E_INVALIDFUNCTION, TEXT("VirtualStmNode::Open"));
    }

    // Create a few more streams in root storage.  This being done to test
    // additonal OLE code which occurs for more number of streams

    if (S_OK == hr)
    {
        //calulate random number of streams to be created
        usErr = pdgi->Generate(&cNum, cRandomMinNumStms, cRandomMaxNumStms);
        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
        DH_HRCHECK (hr, TEXT("pdgi::Generate"));
    }

    while((cNum > 0) && (S_OK == hr))
    {
        cNum--;

        if(S_OK == hr)
        {
            // Generate random name for stream
            hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootMoreStmName);
            DH_HRCHECK (hr, TEXT("GenerateRandomName"));
        }

        if(S_OK == hr)
        {
            hr = AddStream(
                    pTestVirtualDF,
                    pVirtualDFRoot,
                    pRootMoreStmName,
                    0,
                    STGM_READWRITE  |
                    STGM_SHARE_EXCLUSIVE, 
                    &pvsnRootMoreStream);
            DH_HRCHECK (hr, TEXT("AddStream"));
        }

        if (S_OK == hr)
        {
            hr = pvsnRootMoreStream->Close();
            DH_HRCHECK (hr, TEXT("IStream::Close"));
        }

        if(NULL != pRootMoreStmName)
        {
            delete pRootMoreStmName;
            pRootMoreStmName = NULL;
        }
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualStmNode::AddStream (s) completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_ERROR,
            TEXT("VirtualStmNode::AddStream (s) not successful, hr=0x%lx."),
            hr));
    }

    // Commit Root Docfile.
    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit")) ;
    }


    // Enumerate In Memory DocFile to count no of stgs/stms for verification
    // later

    if (S_OK == hr)
    {
        hr = EnumerateInMemoryDocFile(pVirtualDFRoot, &cMemStg, &cMemStm);
        DH_HRCHECK(hr, TEXT("EnumerateInMemoryDocFile"));
    }

    // Close Root Docfile.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    // Open the root docfile without STGM_SIMPLE mode, i.e open in STGM_DIRECT|
    // STGM_READWRITE | STGM_SHARE_EXCLUSIVE mode.

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Open(
                NULL, 
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                NULL,
                0);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Open")) ;
    }

    // Open the stream and Verify the CRC of the stream 1 that was calculated 
    // before.

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Open(NULL, dwChildMode, 0);
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Open")) ;
    }

    // Calculate CRC on stream for the number of bytes that were written during
    // the time the root was opened in STGM_SIMPLE mode.  Since the stream size
    // has got extended, the CRC on total stream would be different, since the
    // fill bytes would be present in extended size.  Garbage tests verify to
    // see that fill bytes are all zero's not checked here.

    // Allocate a buffer of required size

    if (S_OK == hr)
    {
        ptcsReadBuffer = new TCHAR [cb];
        if (NULL == ptcsReadBuffer)
        {
            hr = E_OUTOFMEMORY;
        }
        DH_HRCHECK(hr, TEXT("new")) ;
    }

    if (S_OK == hr)
    {
        memset(ptcsReadBuffer, '\0',  cb*sizeof(TCHAR));
        culRead = 0;
        hr =  pvsnRootNewChildStream->Read(
                 ptcsReadBuffer,
                 cb,
                 &culRead);
        DH_ASSERT(culRead == cb);
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Read")) ;
    }

    if(S_OK == hr)
    {
        hr = CalculateInMemoryCRCForStm(
                pvsnRootNewChildStream,
                ptcsReadBuffer,
                cb,
                &dwActCRC);
        DH_HRCHECK(hr, TEXT("CalculateInMmeoryCRCForStm")) ;
    }

    // Compare CRC's
 
    if(S_OK == hr)
    {
        if(dwMemCRC.dwCRCSum == dwActCRC.dwCRCSum)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's of stream match as exp.")));
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("CRC's of stream don't match as exp.")));
            fPass = FALSE;
        }
    }

    // Verify the size of stream is 4096 bytes.

    // Now seek to the current stream to end of stream

    if(S_OK == hr)
    {
        memset(&liStreamPos, 0, sizeof(LARGE_INTEGER));
        hr = pvsnRootNewChildStream->Seek(liStreamPos, STREAM_SEEK_END, &uli);
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Seek")) ;
        ulSizeOfStream = ULIGetLow(uli);
    }

    if(S_OK == hr)
    {
       if(4096 == ulSizeOfStream)
       {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("Size of stream extended to 4096 bytes as exp")));
       }
       else
       {
            DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("Size of stream not extended to 4096 bytes as exp")));
            fPass = FALSE;
       }
    }

    // Close the stream

    if (S_OK == hr)
    {
        hr = pvsnRootNewChildStream->Close();
        DH_HRCHECK(hr, TEXT("VirtualStmNode::Close")) ;
    }

    // Check times set from SetElementTimes.  BUGBUG: On FAT, the timestamp
    // resolution is not fine enough to make dwLowDateTimeStamp meaningful,
    // so verify with dwHighDataTimeStamp only.

    // Stat on Root Storage

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Stat(&statStg, STATFLAG_NONAME);
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Stat")) ;
    }

    if(S_OK == hr)
    {
        if(cNewFileTime.dwHighDateTime == statStg.mtime.dwHighDateTime)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("SetElementTime and STATSTG.mtime match as exp")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_ERROR, 
                TEXT("SetElementTime and STATSTG.mtime don't match as exp")));
            fPass = FALSE;
        }
    }

    // Enumerate Actual DocFile to count no of stgs/stms for verification
    // with in memory enumerated stgs and stms 

    if (S_OK == hr)
    {
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();
        DH_ASSERT(NULL != pStgRoot);
        if (NULL == pStgRoot)
        {
            DH_TRACE((
                DH_LVL_ERROR,
                TEXT("VirtualCtrNode::GetIStoragePointer() failed to return IStorage"),
                hr));
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = EnumerateDiskDocFile(pStgRoot, VERIFY_SHORT, &cActStg, &cActStm);
        DH_HRCHECK(hr, TEXT("EnumerateDiskDocFile"));
    }

    // Verify structure of DocFile

    if(S_OK == hr)
    {
        if((cActStg == cMemStg) && (cActStm == cMemStm))
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("DocFile enumeration passed as exp")));
        }
        else
        {
            DH_TRACE((DH_LVL_ERROR, TEXT("DocFile enumeration failed unexp")));
            fPass = FALSE;
        }
    }

    // Close the root.    

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;
    }

    // if everything goes well, log test as passed else failed.

    if ((S_OK == hr) && (TRUE == fPass))
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_107 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_107 failed, hr=0x%lx, fPass=%d."),
            hr,
            fPass));
        // test failed. make it look like it failed.
        hr = FirstError (hr, E_FAIL);
    }

    // Cleanup

    CleanupTestDocfile (&pVirtualDFRoot, &pTestVirtualDF, &pTestChanceDF, S_OK==hr);

    // Delete strings

    if(NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    if(NULL != ptcsBuffer)
    {
        delete [] ptcsBuffer;
        ptcsBuffer = NULL;
    }

    if(NULL != ptcsSimpReadBuffer)
    {
        delete [] ptcsSimpReadBuffer;
        ptcsSimpReadBuffer = NULL;
    }

    if(NULL != ptcsReadBuffer)
    {
        delete [] ptcsReadBuffer;
        ptcsReadBuffer = NULL;
    }

    // Delete data generators

    if(NULL != pdgi)
    {
        delete pdgi;
        pdgi = NULL;
    }

    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_107 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}

//----------------------------------------------------------------------------
//
// Test:    DFTEST_108 
//
// Synopsis: A random root DF is created with STGM_SIMPLE flag.  Illegal
//           operations are done on that DocFile permitted methods.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  12-Aug-1996     NarindK     Created.
//           04-Nov-1996     BogdanT     Mac porting
//
// Notes:    This test runs in direct mode
//
// THIS TEST GPF's IN OLE CODE: BUG 53142, BUG 53615 - fixed 6/97
//
// New Test Notes:
// 1.  Old File: -none- 
// 2.  Old name of test : -none- 
//     New Name of test : DFTEST_108 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:DFTEST-108
//
// BUGNOTE: Conversion: DFTEST-108 NO
//
//-----------------------------------------------------------------------------

HRESULT DFTEST_108(ULONG ulSeed)
{

#ifdef _MAC  // Simple mode not ported yet; check with the developers
             // and remove this when ready
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!Simple mode DFTEST_108 crashes.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#elif defined (_CHICAGO_) || (_WIN32_WINNT < 0x500)
    DH_TRACE ((DH_LVL_ALWAYS, 
            TEXT("DCOM has not picked up the new bits yet. Failure hardcoded in test")));
    DH_LOG ((LOG_FAIL,
            TEXT("DFTEST-108 Failed. DCOM not updated in chicago. Bugs# 53142,53615")));
    return E_FAIL;
#else

    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    VirtualDF       *pTestVirtualDF         = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    VirtualStmNode  *pvsnRootNewChildStream = NULL;
    LPTSTR          pRootDocFileName        = NULL;
    LPTSTR          pRootNewChildStmName    = NULL;
    LPOLESTR        poszRootNewChildStmName = NULL;
    DG_STRING      *pdgu                   = NULL;
    USHORT          usErr                   = 0;
    LPSTORAGE       pStgRoot                = NULL;
    LPSTREAM        pStmChild               = NULL;
    ULONG           ulRef                   = 0;
    CDFD            cdfd;


    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_108"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_108 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Attempt illegal tests on STGM_SIMPLE docfile")));

    if(S_OK == hr)
    {
        // Create a new DataGen object to create random strings.

        pdgu = new(NullOnFail) DG_STRING(ulSeed);

        if (NULL == pdgu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Generate random name for root 

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pRootDocFileName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        cdfd.cDepthMin    = 0;
        cdfd.cDepthMax    = 0;
        cdfd.cStgMin      = 0;
        cdfd.cStgMax      = 0;
        cdfd.cStmMin      = 0;
        cdfd.cStmMax      = 0;
        cdfd.cbStmMin     = 0;
        cdfd.cbStmMax     = 0;
        cdfd.ulSeed       = ulSeed;
        cdfd.dwRootMode   = STGM_CREATE             |
                            STGM_DIRECT             |
                            STGM_READWRITE          |
                            STGM_SHARE_EXCLUSIVE    |
                            STGM_SIMPLE;

        hr = pTestChanceDF->Create(&cdfd, pRootDocFileName);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->Create"));
    }

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(
                pTestChanceDF,
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - Create - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - Create - failed, hr=0x%lx."),
            hr));
    }

    if(S_OK == hr)
    {
        // Get Root Storage pointer
        pStgRoot = pVirtualDFRoot->GetIStoragePointer();

        if(NULL == pStgRoot)
        {
          DH_LOG((LOG_INFO, 
            TEXT("pVirtualDFRoot->GetIStoragePointer failed to return IStorage")) );

          hr = E_FAIL;
        }

    }

    if(S_OK == hr)
    {
        // Generate random name for stream
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert stream name to OLECHAR
        hr = TStringToOleString(pRootNewChildStmName, &poszRootNewChildStmName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Call CSimpStorage::CreateStream with valid paramter .
    if(S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszRootNewChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &pStmChild);
        DH_HRCHECK(hr, TEXT("CSimpStorage::CreateStream"));

        if (S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream passed as exp")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream failed unexp,hr=0x%lx"),
                hr));
        }
    }

    // Call QueryInterface on IStream with invalid out parameter.
    if(S_OK == hr)
    {
        hr = pStmChild->QueryInterface(IID_IStream, NULL);

        if (STG_E_INVALIDPOINTER == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStream:QueryInterface failed as exp, hr =0x%lx."),
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStream::QueryInterface didn't fail exp,hr=0x%lx"),
                hr));

            hr = E_FAIL;
        }
    }

    // Release ptr, if reqd
    if(NULL != pStmChild)
    {
        ulRef = pStmChild->Release();
        DH_ASSERT(0 == ulRef);
        pStmChild = NULL;
    }

    // delete these strings and create new ones so we get different
    // names when trying to create things in the df (avoid name collisions)
    delete pRootNewChildStmName;
    pRootNewChildStmName = NULL;
    delete poszRootNewChildStmName;
    poszRootNewChildStmName = NULL;

    if(S_OK == hr)
    {
        // Generate random name for stream
        hr = GenerateRandomName(pdgu,MINLENGTH,MAXLENGTH,&pRootNewChildStmName);
        DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    if(S_OK == hr)
    {
        // Convert stream name to OLECHAR
        hr = TStringToOleString(pRootNewChildStmName, &poszRootNewChildStmName);
        DH_HRCHECK(hr, TEXT("TStringToOleString")) ;
    }

    // Call QueryInterface on CSimpStorage with invalid out parameter.
    if(S_OK == hr)
    {
        hr = pStgRoot->QueryInterface(IID_IStorage, NULL);

        if (STG_E_INVALIDPOINTER == hr)
        {
            DH_TRACE((DH_LVL_TRACE1,
                TEXT("CSimpStorage:QueryInterface failed as exp, hr =0x%lx."),
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((DH_LVL_TRACE1,
                TEXT("CSimpStorage::QueryInterface didn't fail exp,hr=0x%lx"),
                hr));

            hr = E_FAIL;
        }
    }

    // Call CSimpStorage::CreateStream with invalid out &pStmChild paramter .
    if(S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszRootNewChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                NULL);

        DH_HRCHECK(hr, TEXT("CSimpStorage::CreateStream"));

        if (STG_E_INVALIDPOINTER == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream failed as exp, hr =0x%lx."),
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream didn't fail as exp,hr=0x%lx"),
                hr));

            hr = E_FAIL;
        }
    }

    // Call CSimpStorage::CreateStream with NULL name .
    if(S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                NULL,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &pStmChild);

        DH_HRCHECK(hr, TEXT("CSimpStorage::CreateStream"));

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream failed as exp, hr =0x%lx."),
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream didn't fail as exp,hr=0x%lx"),
                hr));

            hr = E_FAIL;
        }   
    }

    // Release ptr, if reqd
    if(NULL != pStmChild)
    {
        ulRef = pStmChild->Release();
        DH_ASSERT(0 == ulRef);
        pStmChild = NULL;
    }

    // Call CSimpStorage::CreateStream with invalid reserved paramter .
    if(S_OK == hr)
    {
        hr = pStgRoot->CreateStream(
                poszRootNewChildStmName,
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                999,
                999,
                &pStmChild);

        DH_HRCHECK(hr, TEXT("CSimpStorage::CreateStream"));

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream failed as exp, hr =0x%lx."),
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("CSimpStorage:CreateStream didn't fail as exp,hr=0x%lx"),
                hr));

            hr = E_FAIL;
        }
    }

    // Release ptr, if reqd
    if(NULL != pStmChild)
    {
        ulRef = pStmChild->Release();
        DH_ASSERT(0 == ulRef);
        pStmChild = NULL;
    }

    // if everything goes well, log test as passed else failed.
    if(S_OK == hr)
    {
          DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_108 passed.")) );
    }
    else
    {
          DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_108 failed, hr=0x%lx."),
            hr) );
    }

    // Cleanup

    // Delete  docfile on disk

    if((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;
            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree for first DocFile

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree for first docfile

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);
        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete strings

    if(NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    if(NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    if(NULL != poszRootNewChildStmName)
    {
        delete poszRootNewChildStmName;
        poszRootNewChildStmName = NULL;
    }

    // Delete data generators

    if(NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_108 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}


//----------------------------------------------------------------------------
//
// Test:    DFTEST_109
//
// Synopsis: A simple mode root docfile is created, then add a random number
//           of streams under the root storage, make sure the last stream's size
//           is less than 4K(ministream), then commit and release the docfile.
//
// Arguments:[ulSeed] 
//
// Returns:  HRESULT
//
// Notes:    This test runs in direct mode only
//
// History:  29-Oct-1996     JiminLi     Created.
//
// Notes:
//   To run the test, do the following at command prompt. 
//   stgbase /seed:0 /t:DFTEST-109
//
// BUGNOTE: Conversion: DFTEST-109 NO
//
//-----------------------------------------------------------------------------

HRESULT DFTEST_109(ULONG ulSeed)
{

#ifdef _MAC  // Simple mode not ported yet; check with the developers
             // and remove this when ready

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!Simple mode DFTEST_109 crashes.")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!To be investigated")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                          = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF              = NULL;
    VirtualDF       *pTestVirtualDF             = NULL;
    VirtualCtrNode  *pVirtualDFRoot             = NULL;
    VirtualStmNode  **pvsnRootNewChildStream    = NULL;
    LPTSTR          *pRootNewChildStmName       = NULL;
    ULONG           culBytesWrite               = 0;
    DG_INTEGER      *pdgi                       = NULL;
    LPTSTR          pRootDocFileName            = NULL;
    LPTSTR          ptcsBuffer                  = NULL;
    DG_STRING       *pdgu                       = NULL;
    DWORD           dwRootMode                  = 0;
    ULONG           ulIndex                     = 0;
    ULONG           ulStmNum                    = 0;
    ULONG           ulMinStm                    = 2;
    ULONG           ulMaxStm                    = 5;
    ULONG           culWritten                  = 0;
    USHORT          usErr                       = 0;
    CDFD            cdfd;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(NULL, DH_LVL_DFLIB, _TEXT("DFTEST_109"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_109 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("Test on adding a ministream into the simple root storage")));

    if (S_OK == hr)
    {
        // Create a new DataGen object to create random UNICODE strings.

        pdgu = new(NullOnFail) DG_STRING(ulSeed);

        if (NULL == pdgu)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        // Create a new DataGen object to create random integers.

        pdgi = new(NullOnFail) DG_INTEGER(ulSeed);

        if (NULL == pdgi)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        // Generate random name for root 

        hr = GenerateRandomName(
                pdgu,
                MINLENGTH,
                MAXLENGTH,
                &pRootDocFileName);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
    }

    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(S_OK == hr)
    {
        cdfd.cDepthMin    = 0;
        cdfd.cDepthMax    = 0;
        cdfd.cStgMin      = 0;
        cdfd.cStgMax      = 0;
        cdfd.cStmMin      = 0;
        cdfd.cStmMax      = 0;
        cdfd.cbStmMin     = 0;
        cdfd.cbStmMax     = 0;
        cdfd.ulSeed       = ulSeed;
        cdfd.dwRootMode   = STGM_CREATE             |
                            STGM_DIRECT             |
                            STGM_READWRITE          |
                            STGM_SHARE_EXCLUSIVE    |
                            STGM_SIMPLE;

        hr = pTestChanceDF->Create(&cdfd, pRootDocFileName);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->Create"));
    }

    if (S_OK == hr)
    {
        pTestVirtualDF = new VirtualDF();
        if(NULL == pTestVirtualDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestVirtualDF->GenerateVirtualDF(
                pTestChanceDF,
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - Create - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - Create - failed, hr=0x%lx."),
            hr));
    }

    // Generate the number of streams to create

    if (S_OK == hr)
    {
        usErr = pdgi->Generate(&ulStmNum, ulMinStm, ulMaxStm);

        if (DG_RC_SUCCESS != usErr)
        {
            hr = E_FAIL;
        }
    }

    // Initialization

    if (S_OK == hr)
    {
        pvsnRootNewChildStream = new VirtualStmNode*[ulStmNum];
        pRootNewChildStmName = new LPTSTR[ulStmNum];
 
        if ((NULL == pvsnRootNewChildStream) || (NULL == pRootNewChildStmName))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        for (ulIndex = 0; ulIndex < ulStmNum; ulIndex++)
        {
            pvsnRootNewChildStream[ulIndex] = NULL;
            pRootNewChildStmName[ulIndex] = NULL;
        }
    }

    // Create ulStmNum streams under the root storage

    for (ulIndex = 0; ulIndex < ulStmNum; ulIndex++)
    {
        if (S_OK == hr)
        {
            // Generate random name for stream

            hr = GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH,
                    &pRootNewChildStmName[ulIndex]);

            DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }

        if (S_OK == hr)
        {
            hr = AddStream(
                    pTestVirtualDF,
                    pVirtualDFRoot,
                    pRootNewChildStmName[ulIndex],
                    0,
                    STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                    &pvsnRootNewChildStream[ulIndex]);

            DH_HRCHECK(hr, TEXT("AddStream")) ;
        }

        if(S_OK == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream completed successfully.")));
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::AddStream not successful, hr = 0x%lx"),
                hr));
        }

        if (S_OK == hr)
        {
            // Generate random size for stream between MIN_STMSIZE and
            // MAX_STMSIZE if it's not the last stream, otherwise generate a 
            // size between 0 and MAXSIZEOFMINISTM(4096L).
 
            if (ulStmNum-1 == ulIndex)
            {
                usErr = pdgi->Generate(&culBytesWrite, 0L, MAXSIZEOFMINISTM);
            }
            else
            {
                usErr = pdgi->Generate(&culBytesWrite,MIN_STMSIZE,MAX_STMSIZE);
            }

            if (DG_RC_SUCCESS != usErr)
            {
                hr = E_FAIL;
            }
        }

        if (S_OK == hr)
        {
            // Generate a random string of size culBytesWrite

            hr = GenerateRandomString(
                    pdgu,
                    culBytesWrite,
                    culBytesWrite,
                    &ptcsBuffer);

            DH_HRCHECK(hr, TEXT("GenerateRandomString")) ;
        }

        if (S_OK == hr)
        {
            hr = pvsnRootNewChildStream[ulIndex]->Write(
                    ptcsBuffer,
                    culBytesWrite,
                    &culWritten);
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Write not successful, hr=0x%lx."),
                hr));
        }

        // Release the stream

        if (S_OK == hr)
        {
            hr = pvsnRootNewChildStream[ulIndex]->Close();
        }

        if (S_OK != hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1,
                TEXT("VirtualStmNode::Close unsuccessful, hr=0x%lx."),
                hr));
        }

        // Delete the temp buffer

        if (NULL != ptcsBuffer)
        {
            delete ptcsBuffer;
            ptcsBuffer = NULL;
        }
    }

    // Commit the root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Commit(STGC_DEFAULT);

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Commit"));
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Commit unsuccessful, hr=0x%lx."),
            hr));
    }

    // Release root

    if (S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close completed successfully.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close unsuccessful, hr=0x%lx."),
            hr));
    }
 
    // if everything goes well, log test as passed else failed.

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("Test variation DFTEST_109 passed.")) );
    }
    else
    {
        DH_LOG((
            LOG_FAIL, 
            TEXT("Test variation DFTEST_109 failed, hr = 0x%lx."),
            hr) );
    }

    // Cleanup

    // Delete the docfile on disk

    if ((S_OK == hr) && (NULL != pRootDocFileName))
    {
        if(FALSE == DeleteFile(pRootDocFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if(NULL != pTestVirtualDF)
    {
        hr2 = pTestVirtualDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pTestVirtualDF;
        pTestVirtualDF = NULL;
    }

    // Delete temp space

    if (NULL != pRootDocFileName)
    {
        delete pRootDocFileName;
        pRootDocFileName = NULL;
    }

    if (NULL != pvsnRootNewChildStream)
    {
        delete []pvsnRootNewChildStream;
        pvsnRootNewChildStream = NULL;
    }

    for (ulIndex = 0; ulIndex < ulStmNum; ulIndex++)
    {
        if (NULL != pRootNewChildStmName[ulIndex])
        {
            delete pRootNewChildStmName[ulIndex];
            pRootNewChildStmName[ulIndex] = NULL;
        }
    }

    if (NULL != pRootNewChildStmName)
    {
        delete pRootNewChildStmName;
        pRootNewChildStmName = NULL;
    }

    if (NULL != pdgi)
    {
        delete pdgi;
        pdgi = NULL;
    }

    if (NULL != pdgu)
    {
        delete pdgu;
        pdgu = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation DFTEST_109 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;

#endif //_MAC
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\hglbtst.cxx ===
/********************************************************************/
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       hglbtest.cxx
//
//  Contents:   HGlobal Test Cases
//
//  Functions:  HGLOBALTEST_100
//              HGLOBALTEST_110
//              HGLOBALTEST_120
//              HGLOBALTEST_130
//              HGLOBALTEST_140
//              HGLOBALTEST_150
//
//  Classes:    None
//
//  History:    31-JULY-1996        T-ScottG        Created
//              27-Mar-97           SCousens        Conversionified
//
/********************************************************************/


#include <dfheader.hxx>
#pragma hdrstop 

#include <debdlg.h>
#include "init.hxx"


/********************************************************************/
//
//  Function:  HGLOBALTEST_100
//
//  Synopsis:  Test which creates an HGLOBAL memory block, then creates
//             an ILockByte Interface on top of the HGlobal (set so 
//             that the ILockBytes will not delete the HGlobal on Release).
//             Next, the test writes and reads a specified number of data
//             bytes to the ILockBytes interface, and then releases it.
//
//             The Test repeats the above sequence (always using the same 
//             HGlobal) a random number of times.  Finally, the HGlobal is 
//             deleted and the test exits.
//
//  Arguments: [ulSeed]     -       Randomizer Seed  
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
// BUGNOTE: Conversion: HGLOBALTEST-100 NO - not supported in nss
//
/********************************************************************/

HRESULT HGLOBALTEST_100 (ULONG ulSeed)
{
    HRESULT                     hr                  =           S_OK;
    HANDLE                      hGlobMem            =           NULL;
    OleHandle                   hOleGlobMem         =           NULL;
    OleHandle                   hOleTempMem         =           NULL;
    ILockBytes *                pILockBytes         =           NULL;
    ULONG                       uRet                =           0;
    DWORD                       dwSize              =           0;
    DWORD                       dwNumIterations     =           0; 
    USHORT                      usErr               =           0;
    ULARGE_INTEGER              li;
   
    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_100"));
    

    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_100 Seed: %d"), ulSeed));


    // Randomly calculate ILockBytes length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate(&dwSize, MIN_HGLOBAL_PACKETS, MAX_HGLOBAL_PACKETS))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Randomly calculate the number of ILockBytes iterations on HGLOBAL

    if (S_OK == hr)
    {
        if (0 != dgi.Generate( &dwNumIterations, 
                               MIN_HGLOBAL_ITERATIONS, 
                               MAX_HGLOBAL_ITERATIONS ))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
    }


    // Allocate HGLOBAL memory

    if (S_OK == hr)
    {
        hGlobMem = GlobalAlloc ( GMEM_NODISCARD | 
                                 GMEM_MOVEABLE, 
                                 dwSize );

        if (NULL == hGlobMem)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
        }
    }


    // Repeat the specified number of times 

    if (S_OK == hr)
    {
        for (DWORD dwIndex = 0; dwIndex < dwNumIterations; dwIndex++)
        {

            // Create ILockBytes on HGLOBAL. (Note: HGLOBAL will not be 
            // deleted when ILockBytes is released)

            // Mac porting: CreateILockBytesOnHGlobal does not accept HGLOBAL,
            //              only OleHandle
            if (S_OK == hr)
            {
                hr = ConvertHGLOBALToOleHandle(hGlobMem, &hOleGlobMem);
                DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
            }
            
            if (S_OK == hr)
            {
                hr = CreateILockBytesOnHGlobal( hOleGlobMem,
                                                FALSE,
                                                &pILockBytes );

                DH_HRCHECK(hr, TEXT("CreateILockBytesOnHGlobal Failed"));
            }


            // Obtain HGlobal pointer from ILockBytes

            if (S_OK == hr)
            {
                hr = GetHGlobalFromILockBytes( pILockBytes, 
                                               &hOleTempMem );

                DH_HRCHECK(hr, TEXT("GetHGlobalFromILockBytes Failed"));
            }

            // Verify that the memory location that GetHGlobalFromILockBytes
            // returned is the same as the memory location passed to 
            // CreateILockBytesOnHGlobal.

            if ((S_OK == hr) && (hOleTempMem != hOleGlobMem))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
            }

            
            // Set the size of the ILockBytes Interface

            if (S_OK == hr)
            {
                DH_ASSERT(NULL != pILockBytes);
                

                // Assign 1/2 of the ILockBytes final size to Large Integer 
                // Structure.  (Note: this is so that the ILockBytes will still
                // have to automatically increase its size during WriteAt 
                // operations in which its size is overflowed)

                ULISet32(li, (dwSize/2));

                hr = pILockBytes->SetSize(li);
                DH_HRCHECK(hr, TEXT("pILockBytes->SetSize Failed"));
            }


            // Call the ILockBytesWriteTest Test

            if (S_OK == hr)
            {
                hr = ILockBytesWriteTest(pILockBytes, ulSeed, dwSize);
                DH_HRCHECK(hr, TEXT("ILockBytesWriteTest Failed"));
            }


            // Call the ILockBytesReadTest Test

            if (S_OK == hr)
            {
                hr = ILockBytesReadTest(pILockBytes, dwSize);
                DH_HRCHECK(hr, TEXT("ILockBytesReadTest Failed"));
            }


            // Release ILockBytes

            if (NULL != pILockBytes)
            {
                uRet = pILockBytes->Release();
                DH_ASSERT(0 == uRet);
        
                pILockBytes = NULL;
            }


            // If error occurs, break out of loop

            if (S_OK != hr)
            {
                break;
            }
        }
    }


    // Free HGLOBAL From memory

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != hGlobMem);

        if (NULL != GlobalFree(hGlobMem))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalFree Failed"));
        }
        else
        {
            hGlobMem = NULL;
        }
    }


    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("HGLOBALTEST_100 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("HGLOBALTEST_100 Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}


/********************************************************************/
//
//  Function:  HGLOBALTEST_110
//
//  Synopsis:  Test which creates an HGLOBAL memory block, then creates
//             an ILockBytes Interface on top of the HGlobal (set so 
//             that the IStream will delete the HGlobal on Release).
//             Next, the test writes and reads a specified number of data
//             bytes to the ILockBytes interface, and then releases it.
//
//             The Test repeats the above sequence a random number of 
//             times.  
//
//             Note: This test differs from HGLOBAL_100 in that the
//             HGLOBAL is freed by the ILockBytes Interface when it is 
//             released.  It does not re-use the same HGLOBAL when 
//             multiple ILockBytes are created.
//
//  Arguments: [dwSize]           - Num of Bytes to Write to ILockBytes
//             [dwNumIterations]  - Num of ILockBytes Interfaces to 
//                                  be created on the same HGlobal
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
// BUGNOTE: Conversion: HGLOBALTEST-110 NO - not supported in nss
//
/********************************************************************/


HRESULT HGLOBALTEST_110 (ULONG ulSeed)
{
    HRESULT                     hr                  =           S_OK;
    HGLOBAL                     hGlobMem            =           NULL;
    OleHandle                   hOleGlobMem         =           NULL;
    OleHandle                   hOleTempMem         =           NULL;
    ILockBytes *                pILockBytes         =           NULL;
    ULONG                       uRet                =           0;
    DWORD                       dwSize              =           0;
    DWORD                       dwNumIterations     =           0;
    ULARGE_INTEGER              li;
    USHORT                      usErr               =           0;
    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_110"));


    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_110 Seed: %d"), ulSeed));


    // Randomly calculate ILockBytes length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate(&dwSize, MIN_HGLOBAL_PACKETS, MAX_HGLOBAL_PACKETS))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Randomly calculate the number of ILockBytes iterations on HGLOBAL

    if (S_OK == hr)
    {
        if (0 != dgi.Generate( &dwNumIterations, 
                               MIN_HGLOBAL_ITERATIONS, 
                               MAX_HGLOBAL_ITERATIONS ))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
    }


    // Repeat the specified number of times 

    if (S_OK == hr)
    {
        for (DWORD dwIndex = 0; dwIndex < dwNumIterations; dwIndex++)
        {

            // Allocate HGLOBAL memory

            if (S_OK == hr)
            {
                hGlobMem = GlobalAlloc ( GMEM_NODISCARD | 
                                         GMEM_MOVEABLE, 
                                         dwSize );

                if (NULL == hGlobMem)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
                }
            }


            // Create ILockBytes on HGLOBAL. (Note: HGLOBAL will not be 
            // deleted when ILockBytes is released)

            // Mac porting: CreateILockBytesOnHGlobal does not accept HGLOBAL,
            //              only OleHandle, so first convert the handle
            if (S_OK == hr)
            {
                hr = ConvertHGLOBALToOleHandle(hGlobMem, &hOleGlobMem);
                DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
            }

            if (S_OK == hr)
            {
                hr = CreateILockBytesOnHGlobal( hOleGlobMem,
                                                TRUE,
                                                &pILockBytes );

                DH_HRCHECK(hr, TEXT("CreateILockBytesOnHGlobal Failed"));
            }


            // Obtain HGlobal pointer from ILockBytes

            if (S_OK == hr)
            {
                hr = GetHGlobalFromILockBytes( pILockBytes, 
                                               &hOleTempMem );

                DH_HRCHECK(hr, TEXT("GetHGlobalFromILockBytes Failed"));
            }

            // Verify that the memory location that GetHGlobalFromILockBytes
            // returned is the same as the memory location passed to 
            // CreateILockBytesOnHGlobal.

            if ((S_OK == hr) && (hOleTempMem != hOleGlobMem))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
            }


            // Set the size of the ILockBytes Interface

            if (S_OK == hr)
            {
                DH_ASSERT(NULL != pILockBytes);
                

                // Assign 1/2 of the ILockBytes final size to Large Integer 
                // Structure.  (Note: this is so that the ILockBytes will still
                // have to automatically increase its size during WriteAt 
                // operations in which its size is overflowed)

                ULISet32(li, (dwSize/2));

                hr = pILockBytes->SetSize(li);
                DH_HRCHECK(hr, TEXT("pILockBytes->SetSize Failed"));
            }


            // Call the ILockBytesWriteTest Test

            if (S_OK == hr)
            {
                hr = ILockBytesWriteTest(pILockBytes, ulSeed, dwSize);
                DH_HRCHECK(hr, TEXT("ILockBytesWriteTest Failed"));
            }


            // Call the ILockBytesReadTest Test

            if (S_OK == hr)
            {
                hr = ILockBytesReadTest(pILockBytes, dwSize);
                DH_HRCHECK(hr, TEXT("ILockBytesReadTest Failed"));
            }


            // Release ILockBytes

            if (NULL != pILockBytes)
            {
                uRet = pILockBytes->Release();
                DH_ASSERT(0 == uRet);
        
                pILockBytes = NULL;
            }


            // Set hGlobMem to NULL (Note: the memory was freed when ILockBytes
            // was released

            hGlobMem = NULL;

      
            // If error occurs, break out of loop

            if (S_OK != hr)
            {
                break;
            }
        }
    }


    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("HGLOBALTEST_110 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("HGLOBALTEST_110 Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}


/********************************************************************/
//
//  Function:  HGLOBALTEST_120
//
//  Synopsis:  Test which creates an HGLOBAL memory block, then creates
//             an IStream Interface on top of the HGlobal (set so 
//             that the IStream will not delete the HGlobal on Release).
//             Next, the test writes and reads a specified number of data
//             bytes to the IStream interface, and then releases it.
//
//             The test repeats the above sequence (always using the same 
//             HGlobal) a random number of times.  Finally, the HGlobal 
//             is deleted and the test exits.
//
//  Arguments: [dwSize]           - Num of Bytes to Write to IStream
//             [dwNumIterations]  - Num of IStream Interfaces to 
//                                  be created on the same HGlobal
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
// BUGNOTE: Conversion: HGLOBALTEST-120 NO - not supported in nss
//
/********************************************************************/


HRESULT HGLOBALTEST_120 (ULONG ulSeed)
{
    HRESULT                     hr                  =           S_OK;
    HGLOBAL                     hGlobMem            =           NULL;
    OleHandle                   hOleGlobMem         =           NULL;
    OleHandle                   hOleTempMem         =           NULL;
    IStream *                   pIStream            =           NULL;
    ULONG                       uRet                =           0;
    DWORD                       dwSize              =           0;
    DWORD                       dwNumIterations     =           0;
    ULARGE_INTEGER              li;
    USHORT                      usErr               =           0;
    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_120"));


    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_120 Seed: %d"), ulSeed));


    // Randomly calculate IStream length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate( &dwSize, 
                               MIN_HGLOBAL_PACKETS, 
                               MAX_HGLOBAL_PACKETS))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Randomly calculate the number of IStream iterations on HGLOBAL

    if (S_OK == hr)
    {
        if (0 != dgi.Generate( &dwNumIterations, 
                               MIN_HGLOBAL_ITERATIONS, 
                               MAX_HGLOBAL_ITERATIONS ))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
    }


    // Allocate HGLOBAL memory

    if (S_OK == hr)
    {
        hGlobMem = GlobalAlloc ( GMEM_NODISCARD | 
                                 GMEM_MOVEABLE, 
                                 dwSize );

        if (NULL == hGlobMem)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
        }
    }


    // Repeat the specified number of times 

    if (S_OK == hr)
    {
        for (DWORD dwIndex = 0; dwIndex < dwNumIterations; dwIndex++)
        {

            // Create IStream on HGLOBAL. (Note: HGLOBAL will not be 
            // deleted when IStream is released)

            // Mac porting: CreateStreamOnHGlobal does not accept HGLOBAL,
            //              only OleHandle, so first convert the handle
            if (S_OK == hr)
            {
                hr = ConvertHGLOBALToOleHandle(hGlobMem, &hOleGlobMem);
                DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
            }

            if (S_OK == hr)
            {
                hr = CreateStreamOnHGlobal( hOleGlobMem,
                                            FALSE,
                                            &pIStream );

                DH_HRCHECK(hr, TEXT("CreateStreamOnHGlobal Failed"));
            }

            // Obtain HGlobal pointer from IStream

            if (S_OK == hr)
            {
                hr = GetHGlobalFromStream( pIStream, 
                                           &hOleTempMem );

                DH_HRCHECK(hr, TEXT("GetHGlobalFromStream Failed"));
            }

            // Verify that the memory location that GetHGlobalFromStream
            // returned is the same as the memory location passed to 
            // CreateStreamOnHGlobal.

            if ((S_OK == hr) && (hOleTempMem != hOleGlobMem))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
            }


            // Set the size of the IStream Interface

            if (S_OK == hr)
            {
                DH_ASSERT(NULL != pIStream);
                

                // Assign 1/2 of the IStream final size to Large Integer 
                // Structure.  (Note: this is so that the IStream will still
                // have to automatically increase its size during Write 
                // operations in which its size is overflowed)

                ULISet32(li, (dwSize/2));

                hr = pIStream->SetSize(li);
                DH_HRCHECK(hr, TEXT("pIStream->SetSize Failed"));
            }


            // Call IStreamWriteTest

            if (S_OK == hr)
            {
                hr = IStreamWriteTest(pIStream, ulSeed, dwSize);
                DH_HRCHECK(hr, TEXT("IStreamWriteTest Failed"));
            }


            // Call the  Test

            if (S_OK == hr)
            {
                hr = IStreamReadTest(pIStream, dwSize);
                DH_HRCHECK(hr, TEXT("IStreamReadTest Failed"));
            }


            // Release IStream

            if (NULL != pIStream)
            {
                uRet = pIStream->Release();
                DH_ASSERT(0 == uRet);
        
                pIStream = NULL;
            }


            // If error occurs, break out of loop

            if (S_OK != hr)
            {
                break;
            }
        }
    }


    // Free HGLOBAL From memory

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != hGlobMem);

        if (NULL != GlobalFree(hGlobMem))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalFree Failed"));
        }
        else
        {
            hGlobMem = NULL;
        }
    }


    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("HGLOBALTEST_120 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("HGLOBALTEST_120 Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}


/********************************************************************/
//
//  Function:  HGLOBALTEST_130
//
//  Synopsis:  Test which creates an HGLOBAL memory block, then creates
//             an IStream Interface on top of the HGlobal (set so 
//             that the IStream will delete the HGlobal on Release).
//             Next, the test writes and reads a specified number of data
//             bytes to the IStream interface, and then releases it.
//
//             The Test repeats the above sequence a random number of
//             times.  
//
//             Note: This test differs from HGLOBAL_120 in that the
//             HGLOBAL is freed by the IStream Interface when it is 
//             released.  It does not re-use the same HGLOBAL when 
//             multiple IStreams are created.
//
//  Arguments: [dwSize]             - Num of Bytes to Write to IStream
//             [dwNumIterations]    - Num of IStream Interfaces to 
//                                    be created on the same HGlobal
//
//  Returns:   HRESULT
//
//  History:   Heavily Modified     T-Scottg                7/30/96
//             Created              Venkatesan Viswanathan
//
// BUGNOTE: Conversion: HGLOBALTEST-130 NO - not supported in nss
//
/********************************************************************/


HRESULT HGLOBALTEST_130 (ULONG ulSeed)
{
    HRESULT                     hr                  =           S_OK;
    HGLOBAL                     hGlobMem            =           NULL;
    OleHandle                   hOleGlobMem         =           NULL;
    OleHandle                   hOleTempMem         =           NULL;
    IStream *                   pIStream            =           NULL;
    ULONG                       uRet                =           0;
    DWORD                       dwSize              =           0;
    DWORD                       dwNumIterations     =           0;
    ULARGE_INTEGER              li;
    USHORT                      usErr               =           0;
    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_130"));


    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_130 Seed: %d"), ulSeed));


    // Randomly calculate ILockBytes length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate(&dwSize, MIN_HGLOBAL_PACKETS, MAX_HGLOBAL_PACKETS))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Randomly calculate the number of IStream iterations on HGLOBAL

    if (S_OK == hr)
    {
        if (0 != dgi.Generate( &dwNumIterations, 
                               MIN_HGLOBAL_ITERATIONS, 
                               MAX_HGLOBAL_ITERATIONS ))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
    }


    // Repeat the specified number of times 

    if (S_OK == hr)
    {
        for (DWORD dwIndex = 0; dwIndex < dwNumIterations; dwIndex++)
        {
            // Allocate HGLOBAL memory

            if (S_OK == hr)
            {
                hGlobMem = GlobalAlloc ( GMEM_NODISCARD | 
                                         GMEM_MOVEABLE, 
                                         dwSize );

                if (NULL == hGlobMem)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
                }
            }


            // Create IStream on HGLOBAL. (Note: HGLOBAL will be 
            // deleted when IStream is released)

            // Mac porting: CreateStreamOnHGlobal does not accept HGLOBAL,
            //              only OleHandle, so first convert the handle
            if (S_OK == hr)
            {
                hr = ConvertHGLOBALToOleHandle(hGlobMem, &hOleGlobMem);
                DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
            }

            if (S_OK == hr)
            {
                hr = CreateStreamOnHGlobal( hOleGlobMem,
                                            TRUE,
                                            &pIStream );

                DH_HRCHECK(hr, TEXT("CreateStreamOnHGlobal Failed"));
            }


            // Obtain HGlobal pointer from IStream

            if (S_OK == hr)
            {
                hr = GetHGlobalFromStream( pIStream, 
                                           &hOleTempMem );

                DH_HRCHECK(hr, TEXT("GetHGlobalFromStream Failed"));
            }

            // Verify that the memory location that GetHGlobalFromStream
            // returned is the same as the memory location passed to 
            // CreateStreamOnHGlobal.

            if ((S_OK == hr) && (hOleTempMem != hOleGlobMem))
            {
                hr = S_FALSE;
                DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
            }


            // Set the size of the IStream Interface

            if (S_OK == hr)
            {
                DH_ASSERT(NULL != pIStream);
                

                // Assign 1/2 of the IStream final size to Large Integer 
                // Structure.  (Note: this is so that the IStream will still
                // have to automatically increase its size during Write 
                // operations in which its size is overflowed)

                ULISet32(li, (dwSize/2));

                hr = pIStream->SetSize(li);
                DH_HRCHECK(hr, TEXT("pIStream->SetSize Failed"));
            }


            // Call IStreamWriteTest

            if (S_OK == hr)
            {
                hr = IStreamWriteTest(pIStream, ulSeed, dwSize);
                DH_HRCHECK(hr, TEXT("IStreamWriteTest Failed"));
            }


            // Call IStreamReadTest

            if (S_OK == hr)
            {
                hr = IStreamReadTest(pIStream, dwSize);
                DH_HRCHECK(hr, TEXT("IStreamReadTest Failed"));
            }


            // Release IStream.  (Note: HGlobal will be deleted with 
            // this call)

            if (NULL != pIStream)
            {
                uRet = pIStream->Release();
                DH_ASSERT(0 == uRet);
        
                pIStream = NULL;
            }


            // If error occurs, break out of loop

            if (S_OK != hr)
            {
                break;
            }
        }
    }


    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, 
            TEXT("HGLOBALTEST_130 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("HGLOBALTEST_130 Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}


/********************************************************************/
//
//  Function:  HGLOBALTEST_140
//
//  Synopsis:  Test which creates an HGLOBAL memory block, then creates
//             an IStream Interface on top of the HGlobal (set so 
//             that the IStream will delete the HGlobal on Release).
//             Next, the test writes a specified number of data
//             bytes to the IStream interface, and then clones it --
//             verifying that the new IStream interface contains the
//             same data as the origional.
//
//  Arguments: [dwSize]     -       Num of Bytes to Write to IStream
//
//  Returns:   HRESULT
//
//  History:   Created              T-ScottG                7/30/96
//
// BUGNOTE: Conversion: HGLOBALTEST-140 NO - not supported in nss
//
/********************************************************************/


HRESULT HGLOBALTEST_140 (ULONG ulSeed)
{
    HRESULT                     hr              =           S_OK;
    HGLOBAL                     hGlobMem        =           NULL;
    OleHandle                   hOleGlobMem     =           NULL;
    OleHandle                   hOleTempMem     =           NULL;
    IStream *                   pIStream        =           NULL;
    IStream *                   pIClone         =           NULL;
    ULONG                       uRet            =           0;
    DWORD                       dwSize          =           0;
    ULARGE_INTEGER              ulSize;
    LARGE_INTEGER               liSeek;
    USHORT                      usErr           =           0;
    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_140"));


    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_140 Seed: %d"), ulSeed));


    // Randomly calculate IStream length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate( &dwSize, 
                               MIN_HGLOBAL_PACKETS, 
                               MAX_HGLOBAL_PACKETS ))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Allocate HGLOBAL memory

    if (S_OK == hr)
    {
        hGlobMem = GlobalAlloc ( GMEM_NODISCARD | 
                                 GMEM_MOVEABLE, 
                                 dwSize );

        if (NULL == hGlobMem)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
        }
    }


    // Create IStream on HGLOBAL. (Note: HGLOBAL will be 
    // deleted when IStream is released)

    // Mac porting: CreateStreamOnHGlobal does not accept HGLOBAL,
    //              only OleHandle, so first convert the handle
    if (S_OK == hr)
    {
        hr = ConvertHGLOBALToOleHandle(hGlobMem, &hOleGlobMem);
        DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
    }

    if (S_OK == hr)
    {
        hr = CreateStreamOnHGlobal( hOleGlobMem,
                                    TRUE,
                                    &pIStream );

        DH_HRCHECK(hr, TEXT("CreateStreamOnHGlobal Failed"));
    }


    // Obtain HGlobal pointer from IStream

    if (S_OK == hr)
    {
        hr = GetHGlobalFromStream( pIStream, 
                                   &hOleTempMem );

        DH_HRCHECK(hr, TEXT("GetHGlobalFromStream Failed"));
    }

    // Verify that the memory location that GetHGlobalFromStream
    // returned is the same as the memory location passed to 
    // CreateStreamOnHGlobal.

    if ((S_OK == hr) && (hOleTempMem != hOleGlobMem))
    {
        hr = S_FALSE;
        DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
    }


    // Set the size of the IStream Interface

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pIStream);
                

        // Assign 1/2 of the IStream final size to Large Integer 
        // Structure.  (Note: this is so that the IStream will still
        // have to automatically increase its size during Write 
        // operations in which its size is overflowed)

        ULISet32(ulSize, (dwSize/2));


        hr = pIStream->SetSize(ulSize);
        DH_HRCHECK(hr, TEXT("pIStream->SetSize Failed"));
    }


    // Call IStreamWriteTest to fill Stream with data

    if (S_OK == hr)
    {
        hr = IStreamWriteTest(pIStream, ulSeed, dwSize);
        DH_HRCHECK(hr, TEXT("IStreamWriteTest Failed"));
    }


    // Set Seek pointer back to beginning of stream

    if (S_OK == hr)
    {
        ULISet32(liSeek, 0);

        hr = pIStream->Seek(liSeek, STREAM_SEEK_SET, NULL);
        DH_HRCHECK(hr, TEXT("IStream::Seek Failed"));
    }


    // Obtain clone of pIStream

    if (S_OK == hr)
    {
        hr = pIStream->Clone(&pIClone);
        DH_HRCHECK(hr, TEXT("IStream::Clone Failed"));
    }


    // Verify that the clone and the origional contain the same data

    if (S_OK == hr)
    {
        hr = IsEqualStream(pIStream, pIClone);
        DH_HRCHECK(hr, TEXT("IsEqualStream Failed"));
    }


    // Release IStream.  (Note: HGlobal will be deleted with 
    // this call)

    if (NULL != pIStream)
    {
        uRet = pIStream->Release();
        DH_ASSERT(0 == uRet);
        
        pIStream = NULL;
    }


    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, 
            TEXT("HGLOBALTEST_140 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("HGLOBALTEST_140 Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}


/********************************************************************/
//
//  Function:  HGLOBALTEST_150
//
//  Synopsis:  Test which creates an HGLOBAL memory block, then creates
//             an IStream Interface on top of the HGlobal (set so 
//             that the IStream will delete the HGlobal on Release).
//             Next, the test writes a specified number of data
//             bytes to the IStream interface, and then Copies it 
//             to a new IStream (also created using an HGLOBAL),
//             and verified that the new IStream interface contains 
//             the same data as the origional.
//
//  Arguments: [dwSize]     -   Num of Bytes to Write to IStream
//
//  Returns:   HRESULT
//
//  History:   Created          T-ScottG                7/30/96
//
// BUGNOTE: Conversion: HGLOBALTEST-150 NO - not supported in nss
//
/********************************************************************/


HRESULT HGLOBALTEST_150 (ULONG ulSeed)
{
    HRESULT                     hr                  =       S_OK;
    HGLOBAL                     hGlobOrigionalMem   =       NULL;
    HGLOBAL                     hGlobCopyMem        =       NULL;
    OleHandle                   hOleGlobOrigionalMem=       NULL;
    OleHandle                   hOleGlobCopyMem     =       NULL;
    OleHandle                   hOleTempMem         =       NULL;
    IStream *                   pIStream            =       NULL;
    IStream *                   pICopy              =       NULL;
    ULONG                       uRet                =       0;
    DWORD                       dwSize              =       0;
    ULARGE_INTEGER              ulSize;
    LARGE_INTEGER               liSeek;
    USHORT                      usErr               =       0;
    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_150"));


    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_150 Seed: %d"), ulSeed));


    // Randomly calculate IStream length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate(&dwSize, MIN_HGLOBAL_PACKETS, MAX_HGLOBAL_PACKETS))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Allocate HGLOBAL memory for Origional Stream

    if (S_OK == hr)
    {
        hGlobOrigionalMem = GlobalAlloc ( GMEM_NODISCARD | 
                                          GMEM_MOVEABLE, 
                                          dwSize );

        if (NULL == hGlobOrigionalMem)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
        }
    }


    // Allocate HGLOBAL memory for the Copy of the Origional Stream

    if (S_OK == hr)
    {
        hGlobCopyMem = GlobalAlloc ( GMEM_NODISCARD | 
                                     GMEM_MOVEABLE, 
                                     dwSize );

        if (NULL == hGlobCopyMem)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
        }
    }

    // Mac porting: CreateStreamOnHGlobal does not accept HGLOBAL,
    //              only OleHandle, so first convert the handle
    if (S_OK == hr)
    {
        hr = ConvertHGLOBALToOleHandle(hGlobOrigionalMem, &hOleGlobOrigionalMem);
        DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
    }

    // Create Origional IStream on HGLOBAL. (Note: HGLOBAL will be 
    // deleted when IStream is released)

    if (S_OK == hr)
    {
        hr = CreateStreamOnHGlobal( hOleGlobOrigionalMem,
                                    TRUE,
                                    &pIStream );

        DH_HRCHECK(hr, TEXT("CreateStreamOnHGlobal Failed"));
    }


    // Mac porting: CreateStreamOnHGlobal does not accept HGLOBAL,
    //              only OleHandle, so first convert the handle
    if (S_OK == hr)
    {
        hr = ConvertHGLOBALToOleHandle(hGlobCopyMem, &hOleGlobCopyMem);
        DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
    }

    // Create Copied IStream on HGLOBAL. (Note: HGLOBAL will be 
    // deleted when IStream is released)

    if (S_OK == hr)
    {
        hr = CreateStreamOnHGlobal( hOleGlobCopyMem,
                                    TRUE,
                                    &pICopy );

        DH_HRCHECK(hr, TEXT("CreateStreamOnHGlobal Failed"));
    }


    // Obtain HGlobal pointer from Origional IStream

    if (S_OK == hr)
    {
        hr = GetHGlobalFromStream( pIStream, 
                                   &hOleTempMem );

        DH_HRCHECK(hr, TEXT("GetHGlobalFromStream Failed"));
    }

    // Verify that the memory location that GetHGlobalFromStream
    // returned is the same as the memory location passed to 
    // CreateStreamOnHGlobal.

    if ((S_OK == hr) && (hOleTempMem != hOleGlobOrigionalMem))
    {
        hr = S_FALSE;
        DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
    }


    // Obtain HGlobal pointer from Copied IStream

    if (S_OK == hr)
    {
        hr = GetHGlobalFromStream( pICopy, 
                                   &hOleTempMem );

        DH_HRCHECK(hr, TEXT("GetHGlobalFromStream Failed"));
    }

    // Verify that the memory location that GetHGlobalFromStream
    // returned is the same as the memory location passed to 
    // CreateStreamOnHGlobal.

    if ((S_OK == hr) && (hOleTempMem != hOleGlobCopyMem))
    {
        hr = S_FALSE;
        DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
    }


    // Set the size of the Origional IStream Interface

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pIStream);
                
        // Assign 1/2 of the IStream final size to Large Integer 
        // Structure.  (Note: this is so that the IStream will still
        // have to automatically increase its size during Write 
        // operations in which its size is overflowed)

        ULISet32(ulSize, (dwSize/2));


        hr = pIStream->SetSize(ulSize);
        DH_HRCHECK(hr, TEXT("pIStream->SetSize Failed"));
    }


    // Call IStreamWriteTest to fill Stream with data

    if (S_OK == hr)
    {
        hr = IStreamWriteTest(pIStream, ulSeed, dwSize);
        DH_HRCHECK(hr, TEXT("IStreamWriteTest Failed"));
    }


    // Set Seek pointer back to beginning of stream

    if (S_OK == hr)
    {
        ULISet32(liSeek, 0);

        hr = pIStream->Seek(liSeek, STREAM_SEEK_SET, NULL);
        DH_HRCHECK(hr, TEXT("IStream::Seek Failed"));
    }


    // Copy Origional Stream to Copied Stream

    if (S_OK == hr)
    {

        ULISet32(ulSize, dwSize);

        hr = pIStream->CopyTo(pICopy, ulSize, NULL, NULL);
        DH_HRCHECK(hr, TEXT("IStream::Clone Failed"));
    }


    // Verify that the clone and the origional contain the same data

    if (S_OK == hr)
    {
        hr = IsEqualStream(pIStream, pICopy);
        DH_HRCHECK(hr, TEXT("IsEqualStream Failed"));
    }


    // Release IStream.  (Note: HGLOBAL will be deleted with 
    // this call)

    if (NULL != pIStream)
    {
        uRet = pIStream->Release();
        DH_ASSERT(0 == uRet);
        
        pIStream = NULL;
    }


    // Release pICopy.  (Note: HGLOBAL will be deleted with this call)

    if (NULL != pICopy)
    {
        uRet = pICopy->Release();
        DH_ASSERT(0 == uRet);

        pICopy = NULL;
    }


    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, 
            TEXT("HGLOBALTEST_150 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, 
            TEXT("HGLOBALTEST_150 Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}

/********************************************************************/
//
//  Function:  HGLOBALTEST_101
//
//  Synopsis:  Test which tries illegit tests on API's - CreateILockBytesOn
//             HGlobal and GetHGlobalFromILockBytes. 
// 
//  Arguments: [ulSeed]     -       Randomizer Seed  
//
//  Returns:   HRESULT
//
//  History:   Created     Narindk                8/21/96
//
//  Notes:     OLE BUGS: 54009, 54024.  Not in Automated run yet.
//
// BUGNOTE: Conversion: HGLOBALTEST-101 NO - not supported in nss
//
/********************************************************************/


HRESULT HGLOBALTEST_101 (ULONG ulSeed)
{
    HRESULT                     hr                  =           S_OK;
    HGLOBAL                     hGlobMem            =           NULL;
    OleHandle                   hOleGlobMem         =           NULL;
    OleHandle                   hOleTempMem         =           NULL;
    ILockBytes *                pILockBytes         =           NULL;
    ULONG                       uRet                =           0;
    DWORD                       dwSize              =           0;
    USHORT                      usErr               =           0;
    ULARGE_INTEGER              li;

    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_101"));
    

    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_101 Seed: %d"), ulSeed));


    // Randomly calculate ILockBytes length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate(&dwSize, MIN_HGLOBAL_PACKETS,MAX_HGLOBAL_PACKETS))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Allocate HGLOBAL memory

    if (S_OK == hr)
    {
        hGlobMem = GlobalAlloc ( GMEM_NODISCARD | 
                                 GMEM_MOVEABLE, 
                                 dwSize );

        if (NULL == hGlobMem)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
        }
    }

    // Mac porting: the next functions do not accept HGLOBAL,
    //              only OleHandle, so first convert the handle
    if (S_OK == hr)
    {
        hr = ConvertHGLOBALToOleHandle(hGlobMem, &hOleGlobMem);
        DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
    }

    if (S_OK == hr)
    {
        // Create ILockBytes on HGLOBAL. (Note: HGLOBAL will be 
        // deleted when ILockBytes is released)

        // Attempt illehgal out parameter for pILockBytes out param.

        hr = CreateILockBytesOnHGlobal( hOleGlobMem,
                                        TRUE,
                                        NULL );

        if(E_INVALIDARG == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CreateILockBytesOnHGlobal failed as exp, hr=0x%lx"), 
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
               DH_LVL_TRACE1, 
               TEXT("CreateILockBytesOnHGlobal didn't fail as exp,hr=0x%lx"), 
               hr));

            hr = E_FAIL;
        }
    }

    // attempt valid operation

    if (S_OK == hr)
    {
        // Create ILockBytes on HGLOBAL. (Note: HGLOBAL will be 
        // deleted when ILockBytes is released)

        hr = CreateILockBytesOnHGlobal( hOleGlobMem,
                                        TRUE,
                                        &pILockBytes );
    }

    // Obtain HGlobal pointer from ILockBytes

    if (S_OK == hr)
    {
        // Attempt illegal value for out Hglobal.

        hr = GetHGlobalFromILockBytes( pILockBytes, 
                                       NULL );

        if(E_INVALIDARG == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetHGlobalFromILockBytes failed as exp, hr=0x%lx"), 
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetHGlobalFromILockBytes didn't fail exp, hr=0x%lx"), 
                hr));

            hr = E_FAIL;
        }
    }

    // attempt valid operation

    if (S_OK == hr)
    {
        hr = GetHGlobalFromILockBytes( pILockBytes, 
                                       &hOleTempMem );

        DH_HRCHECK(hr, TEXT("GetHGlobalFromILockBytes Failed"));
    }

    // Verify that the memory location that GetHGlobalFromILockBytes
    // returned is the same as the memory location passed to 
    // CreateILockBytesOnHGlobal.

    if ((S_OK == hr) && (hOleTempMem != hOleGlobMem))
    {
        hr = S_FALSE;
        DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
    }

            
    // Set the size of the ILockBytes Interface

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pILockBytes);
                
        // Assign 1/2 of the ILockBytes final size to Large Integer 
        // Structure.  (Note: this is so that the ILockBytes will still
        // have to automatically increase its size during WriteAt 
        // operations in which its size is overflowed)

        ULISet32(li, (dwSize/2));

        hr = pILockBytes->SetSize(li);
        DH_HRCHECK(hr, TEXT("pILockBytes->SetSize Failed"));
    }


    // Release ILockBytes

    if (NULL != pILockBytes)
    {
        uRet = pILockBytes->Release();
        DH_ASSERT(0 == uRet);

        pILockBytes = NULL;
    }

    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("HGLOBALTEST_101 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("HGLOBALTEST_101 Failed, hr = 0x%Lx"), hr));
    }


    return hr;
}

/********************************************************************/
//
//  Function:  HGLOBALTEST_121
//
//  Synopsis:  Test which tries illegit tests on API's - CreateStreamOn
//             HGlobal and GetHGlobalFromStream. 
// 
//  Arguments: [ulSeed]     -       Randomizer Seed  
//
//  Returns:   HRESULT
//
//  History:   Created     Narindk                8/21/96
//
//  Notes:     OLE BUGS: 54053, 54051.  Not in Automated run yet.
//
// BUGNOTE: Conversion: HGLOBALTEST-121 NO - not supported in nss
//
/********************************************************************/


HRESULT HGLOBALTEST_121 (ULONG ulSeed)
{
    HRESULT                     hr                  =           S_OK;
    HGLOBAL                     hGlobMem            =           NULL;
    OleHandle                   hOleGlobMem         =           NULL;
    OleHandle                   hOleTempMem         =           NULL;
    IStream *                   pIStream            =           NULL;
    ULONG                       uRet                =           0;
    DWORD                       dwSize              =           0;
    USHORT                      usErr               =           0;
    ULARGE_INTEGER              uliSize;

    DG_INTEGER                  dgi(ulSeed);

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_TRACE1, TEXT("HGLOBALTEST_121"));
    

    // Print Seed to Log

    usErr = dgi.GetSeed(&ulSeed);
    DH_ASSERT(DG_RC_BAD_NUMBER_PTR != usErr);
    DH_TRACE((DH_LVL_TRACE1, TEXT("HGLOBALTEST_121 Seed: %d"), ulSeed));


    // Randomly calculate Stream length

    if (S_OK == hr)
    {
        if (0 != dgi.Generate(&dwSize, MIN_HGLOBAL_PACKETS,MAX_HGLOBAL_PACKETS))
        {
            hr = S_FALSE;
            DH_HRCHECK(hr, TEXT("dgi.Generate Failed"));
        }
        else
        {
            dwSize = dwSize * HGLOBAL_PACKET_SIZE;
        }
    }


    // Allocate HGLOBAL memory

    if (S_OK == hr)
    {
        hGlobMem = GlobalAlloc ( GMEM_NODISCARD | 
                                 GMEM_MOVEABLE, 
                                 dwSize );

        if (NULL == hGlobMem)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DH_HRCHECK(hr, TEXT("GlobalAlloc Failed"));
        }
    }
  
    // Mac porting: CreateStreamOnHGlobal does not accept HGLOBAL,
    //              only OleHandle, so first convert the handle
    if (S_OK == hr)
    {
        hr = ConvertHGLOBALToOleHandle(hGlobMem, &hOleGlobMem);
        DH_HRCHECK(hr, TEXT("ConvertHGLOBALToOleHandle failed"));
    }

    if (S_OK == hr)
    {
        // Create Stream on HGLOBAL. 

        // Attempt illegal out parameter for pIStream out param.

        hr = CreateStreamOnHGlobal( hOleGlobMem,
                                    TRUE,
                                    NULL );

        if(E_INVALIDARG == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CreateStreamOnHGlobal failed as exp, hr=0x%lx"), 
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("CreateStreamOnHGlobal didn't fail exp, hr=0x%lx"), 
                hr));

            hr = E_FAIL;
        }
    }

    // attempt valid operation

    if (S_OK == hr)
    {
        // Create ILockBytes on HGLOBAL. (Note: HGLOBAL will be 
        // deleted when IStream is released)

        hr = CreateStreamOnHGlobal( hOleGlobMem,
                                    TRUE,
                                    &pIStream );
    }

    // Obtain HGlobal pointer from IStream

    if (S_OK == hr)
    {
        // Attempt illegal value for out Hglobal.

        hr = GetHGlobalFromStream(pIStream,  NULL );

        if(E_INVALIDARG == hr)
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetHGlobalFromStream failed as exp, hr=0x%lx"), 
                hr));

            hr = S_OK;
        }
        else
        {
            DH_TRACE((
                DH_LVL_TRACE1, 
                TEXT("GetHGlobalFromStream didn't fail exp, hr=0x%lx"), 
                hr));

            hr = E_FAIL;
        }
    }

    // attempt valid operation

    if (S_OK == hr)
    {
        hr = GetHGlobalFromStream( pIStream, &hOleTempMem );

        DH_HRCHECK(hr, TEXT("GetHGlobalFromStream Failed"));
    }

    // Verify that the memory location that GetHGlobalFromILockBytes
    // returned is the same as the memory location passed to 
    // CreateILockBytesOnHGlobal.

    if ((S_OK == hr) && (hOleTempMem != hOleGlobMem))
    {
        hr = S_FALSE;
        DH_HRCHECK(hr, TEXT("HGlobal addresses are not the same"));
    }

    // Set the size of the IStream Interface

    if (S_OK == hr)
    {
        DH_ASSERT(NULL != pIStream);
                
        // Assign 1/2 of the IStream final size to Large Integer 
        // Structure.  (Note: this is so that the IStream will still
        // have to automatically increase its size during Write 
        // operations in which its size is overflowed)

        ULISet32(uliSize, (dwSize/2));

        hr = pIStream->SetSize(uliSize);
        DH_HRCHECK(hr, TEXT("pIStream->SetSize Failed"));
    }

    // Release Stream 

    if (NULL != pIStream)
    {
        uRet = pIStream->Release();
        DH_ASSERT(0 == uRet);

        pIStream = NULL;
    }

    // Write result to log

    if (S_OK == hr)
    {
        DH_LOG((LOG_PASS, TEXT("HGLOBALTEST_121 Succeeded")));
    }
    else
    {
        DH_LOG((LOG_FAIL, TEXT("HGLOBALTEST_121 Failed, hr = 0x%Lx"), hr));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\createdf.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       init.cxx
//
//  Contents:   OLE storage base tests
//
//  Functions:  main 
//
//  History:    26-Feb-1997     SCousens    Created.
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include <init.hxx>

HRESULT MakeVirtualDF (UINT uOp, ChanceDF *pTestChanceDF, VirtualCtrNode **ppvcnRoot, VirtualDF **ppTestVirtualDF);

// Global:
// For stress debug purposes. So we can get to the seed from 
// within the debugger
// do not use gulSeed for anything else!
ULONG gulSeed=0;


//----------------------------------------------------------------------------
//    FUNCTION: CreateTestDocfile [multiple]
//
//    PARAMS:   argc            - # params on commandline
//              argv            - array of pointers to commandline
//              ppVirtualDFRoot - bucket for RootCtrNode  
//              ppTestVirtualDF - bucket for pVirtualDF  
//              ppTestChanceDF  - bucket for pChanceDF  
//
//    SYNOPSIS: Determine whether we are creating a DF, or
//              opening and existing one.
//              Creating
//                Create a ChanceDF of random nodes,
//                Create the VirtualDF from this (GenerateVirtualDF)
//                Commit and close the resulting docfile
//              Opening
//                Figure the name, open it (GenerateVirtualDFFromDiskDF)
//                Also need to set _pgdu, _pgdi
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    NOTES:    All stms and Stgs of the docfile will have been commited
//              and and saved, but all will be open before returning
//              The name of the file will be the first string generated
//              after creating the DataGen for strings. Its the way it 
//              works, we can use this knowledge to our advantage (until
//              someone changes that behaviour and breaks us)
//
//    HISTORY:  28-Feb-1997     SCousens     Created.
//
//----------------------------------------------------------------------------
HRESULT CreateTestDocfile (
        int               argc, 
        char            **argv, 
        VirtualCtrNode  **ppvcnRoot,
        VirtualDF       **ppTestVirtualDF,
        ChanceDF        **ppTestChanceDF)
{
    HRESULT     hr           = S_OK;
    ChanceDF   *pChanceDF    = NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CreateTestDocfile"));
    DH_VDATEPTROUT (ppvcnRoot, VirtualCtrNode *);
    DH_VDATEPTROUT (ppTestVirtualDF, VirtualDF *);

    *ppvcnRoot = NULL;
    *ppTestVirtualDF = NULL;
    if (NULL != ppTestChanceDF)
    {
        DH_VDATEPTROUT (ppTestChanceDF, ChanceDF *);
        *ppTestChanceDF = NULL;
    }

    // Always create this. There is lots of juicy info that 
    // we will need either way.
    // Create the new ChanceDocFile tree that would consist of chance nodes.
    if (S_OK == hr)
    {
        pChanceDF = new ChanceDF();
        if(NULL == pChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pChanceDF->CreateFromParams (argc, argv);
        DH_HRCHECK(hr, TEXT("pChanceDF->CreateFromParams")) ;
    }

    // Make VirtualDF
    if (S_OK == hr)
    {
        hr = MakeVirtualDF (pChanceDF->GetOpenCreateDF (),
                    pChanceDF,
                    ppvcnRoot,
                    ppTestVirtualDF);
    }

    // If the caller wants ChanceDF give it to them, otherwise delete it
    if (NULL == ppTestChanceDF)
    {
        delete pChanceDF;
    }
    else
    {
        *ppTestChanceDF = pChanceDF;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//    FUNCTION: CreateTestDocfile [multiple]
//
//    PARAMS:   pcdfd           - CDFD for chancedf
//              pFileName       - name of docfile
//              ulSeed          - seed (to get name)
//              ppVirtualDFRoot - bucket for RootCtrNode  
//              ppTestVirtualDF - bucket for pVirtualDF  
//              ppTestChanceDF  - bucket for pChanceDF  
//
//    SYNOPSIS: See above 
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    NOTES:    See description above 
//
//    HISTORY:  19-Mar-1997     SCousens     Created.
//
//----------------------------------------------------------------------------

HRESULT CreateTestDocfile (
        CDFD             *pcdfd,
        LPTSTR            pFileName,
        VirtualCtrNode  **ppvcnRoot,
        VirtualDF       **ppTestVirtualDF,
        ChanceDF        **ppTestChanceDF)
{

    HRESULT     hr           = S_OK;
    ChanceDF   *pChanceDF    = NULL;
    LPTSTR      pDocFileName = NULL;

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("CreateTestDocfile"));
    DH_VDATEPTRIN  (pcdfd, CDFD);
    DH_VDATEPTROUT (ppvcnRoot, VirtualCtrNode *);
    DH_VDATEPTROUT (ppTestVirtualDF, VirtualDF *);

    *ppvcnRoot = NULL;
    *ppTestVirtualDF = NULL;
    if (NULL != ppTestChanceDF)
    {
        DH_VDATEPTROUT (ppTestChanceDF, ChanceDF *);
        *ppTestChanceDF = NULL;
    }

    // If dont have a filename, make one
    if (NULL == pFileName)
    {
        DG_STRING *pdgu = NULL;
        if (S_OK == hr)
        {
            // Create a new DataGen object to create random UNICODE strings.
            pdgu = new DG_STRING (pcdfd->ulSeed);
            if (NULL == pdgu)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (S_OK == hr)
        {
            // Generate random name for root 
            hr = GenerateRandomName(
                    pdgu,
                    MINLENGTH,
                    MAXLENGTH,
                    &pDocFileName);
                DH_HRCHECK(hr, TEXT("GenerateRandomName")) ;
        }
        delete pdgu;
    }
    
    // Always create this. 
    // Create the new ChanceDocFile tree that would consist of chance nodes.
    if (S_OK == hr)
    {
        pChanceDF = new ChanceDF();
        if(NULL == pChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pChanceDF->Create (
                pcdfd, 
                NULL == pFileName ? pFileName : pDocFileName);
        DH_HRCHECK(hr, TEXT("pChanceDF->Create")) ;
    }

    // Make VirtualDF
    if (S_OK == hr)
    {
        hr = MakeVirtualDF (g_uOpenCreateDF,  //Global set in ProcessCmdLine()
                    pChanceDF,
                    ppvcnRoot,
                    ppTestVirtualDF);
    }

    // cleanup 
    if (NULL != pDocFileName)
    {
        delete []pDocFileName;
    }

    // If the caller wants ChanceDF give it to them, otherwise delete it
    if (NULL == ppTestChanceDF)
    {
        delete pChanceDF;
    }
    else
    {
        *ppTestChanceDF = pChanceDF;
    }

    return hr;
}

//----------------------------------------------------------------------------
//    FUNCTION: MakeVirtualDF
//
//    PARAMS:   uOp             - Create|Open flag (FL_DISTRIB_xxx)
//              pTestChanceDF   - ptr to pChanceDF  
//              ppVirtualDFRoot - bucket for RootCtrNode  
//              ppTestVirtualDF - bucket for pVirtualDF  
//
//    SYNOPSIS: This function should be called by
//              CreateTestDocfile
//              If FL_OPEN is set, and cannot open docfile, 
//              return ERROR.
//              Otherwise we need to create a storage file
//              as we are either as 1st phase, or single phase.
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    HISTORY:  28-Feb-1997     SCousens     Created.
// BUGBUG: GenerateVirtualDFFromDiskDF does not fill in the CRC for vsn.
//         we need to write a rtn that will do this for enumtest 100.
//----------------------------------------------------------------------------
HRESULT MakeVirtualDF (
        UINT uOp,
        ChanceDF         *pTestChanceDF,
        VirtualCtrNode  **ppvcnRoot,
        VirtualDF       **ppTestVirtualDF)
{
    HRESULT   hr                = S_OK;

    // This is internal func. Shouldnt have to do this.
    DH_ASSERT (NULL != pTestChanceDF); 
    DH_ASSERT (NULL != ppvcnRoot); 
    DH_ASSERT (NULL != ppTestVirtualDF); 

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("MakeVirtualDF"));

    //for stress debug purposes. So we can get to the seed.
    //do not use gulSeed for anything!
    gulSeed = pTestChanceDF->GetSeed ();

    // If its OPEN, try to open existing.
    if (FL_DISTRIB_OPEN == uOp)
    {
        ULONG      ulSeed         = 0;
        DG_STRING *pgdu           = NULL;
        LPTSTR     tszDocfileName = NULL;

        // Get the seed. We need this to generate the filename.
        ulSeed = pTestChanceDF->GetSeed();
 
        // Create a new DataGen object to create the filename
        pgdu = new DG_STRING(ulSeed);
        if (NULL == pgdu)
        {
            hr = E_OUTOFMEMORY;
        }

        // if filename was specified, get it from chanceDF
        if (hr == S_OK)
        {
            tszDocfileName = pTestChanceDF->GetDocFileName();
            if (NULL != tszDocfileName)
            {
                LPTSTR pTmpName = tszDocfileName;
                tszDocfileName = new TCHAR[_tcslen (pTmpName)+1];
                if (NULL == tszDocfileName)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    _tcscpy(tszDocfileName, pTmpName);
                }
            }
            else
            {
                // this will generate the name of the file that was created
                hr = GenerateRandomName (pgdu, MINLENGTH, MAXLENGTH, &tszDocfileName);
                DH_HRCHECK (hr, TEXT("GenerateRandomName"));
            }
        }

        if (S_OK == hr)
        {
            *ppTestVirtualDF = new VirtualDF();
            if (NULL == *ppTestVirtualDF)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (hr == S_OK)
        {
            // Remove create bit - open does not like it.
            hr = GenerateVirtualDFFromDiskDF(
                    *ppTestVirtualDF,
                    tszDocfileName,
                    pTestChanceDF->GetRootMode() & ~STGM_CREATE,
                    ppvcnRoot,
                    ulSeed);
            DH_HRCHECK (hr, TEXT("GenerateVirtualDFFromDiskDF"));
        }

        // make sure ALL sub stg/stm are open and have valid _pstg
        if (hr == S_OK)
        {
            hr = ParseVirtualDFAndOpenAllSubStgsStms (
                    *ppvcnRoot,
                    pTestChanceDF->GetStgMode (),
                    pTestChanceDF->GetStmMode ());
            DH_HRCHECK (hr, TEXT("ParseVirtualDFAndOpenAllSubStgsStms"));
        }

        if (NULL != tszDocfileName)
        {
            delete tszDocfileName;
        }

        if (NULL != pgdu)
        {
            delete pgdu;
        }
    }
    // else !open, so create one.
    else
    {
        // Create the VirtualDocFile tree from the ChanceDocFile tree created in
        // the previous step.  The VirtualDocFile tree consists of VirtualCtrNodes
        // and VirtualStmNodes.
        if (S_OK == hr)
        {
            *ppTestVirtualDF = new VirtualDF(); 
            if (NULL == *ppTestVirtualDF)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (S_OK == hr)
        {
            hr = (*ppTestVirtualDF)->GenerateVirtualDF (pTestChanceDF, ppvcnRoot);
            DH_HRCHECK(hr, TEXT("pTestVirtualDF->GenerateVirtualDF")) ;
        }

        // Commit all stms and stgs in newly created storage file
        if (S_OK == hr)
        {
            hr = ParseVirtualDFAndCommitAllOpenStgs (*ppvcnRoot, STGC_DEFAULT, NODE_INC_TOPSTG);
            DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCommitAllOpenStgs")) ;
        }

        // If we are testing conversion, close and reopen the file.
        // BUGBUG: If we are distributed and happen to have the 
        //  cmdline for conversion, you will do an extra open and
        //  close. DIF files may get an unacceptible time penalty.
        if (DoingConversion())
        {
            // close the file
            if (S_OK == hr)
            {
                hr = ParseVirtualDFAndCloseOpenStgsStms (*ppvcnRoot, NODE_INC_TOPSTG);
                DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
            }
            // just for fun, verify that we indeed have an nssfile
            // Assume there is a file name, else we failed somewhere
            // creating it and hr should != S_OK
            if (S_OK == hr)
            {
                hr = VerifyNssfile ((*ppTestVirtualDF)->GetDocFileName());
                DH_HRCHECK(hr, TEXT("VerifyNssfile")) ;
            }
            // open root storage
            if (S_OK == hr)
            {
                // if in SIMPLEMODE, get rid of Create.
                ULONG mode = pTestChanceDF->GetRootMode ();
                if (mode & STGM_SIMPLE)
                {
                    mode &= ~STGM_CREATE;
                }

                hr = (*ppvcnRoot)->OpenRoot (NULL,
                        mode,
                        NULL,
                        0);
                DH_HRCHECK(hr, TEXT("StgOpenStorage"));
            }
            // open up the rest of storages and streams
            if (S_OK == hr)
            {
                hr = ParseVirtualDFAndOpenAllSubStgsStms (*ppvcnRoot, 
                        pTestChanceDF->GetStgMode (),
                        pTestChanceDF->GetStmMode ());
                DH_HRCHECK(hr, TEXT("ParseVirtualDFAndOpenAllSubStgsStms")) ;
            }
            DH_TRACE ((DH_LVL_TRACE2, TEXT("Docfile closed and reopened for conversion")));
        }
    }
    return hr;
}

//----------------------------------------------------------------------------
//
//    FUNCTION: CleanupTestDocfile 
//
//    PARAMS:   ppVirtualDFRoot - bucket for RootCtrNode  
//              ppTestVirtualDF - bucket for pVirtualDF  
//              ppTestChanceDF  - bucket for pChanceDF  
//              fDeleteFile     - If was an error, dont delete docfile
//
//    SYNOPSIS: Cleanup all items that were setup in CreateTestDocfile
//               - chancedf
//               - virtualdf
//               - delete docfile on disk (if there were no errors)
//
//    RETURN:   hr. S_OK or whatever failure was encountered.
//
//    HISTORY:  28-Feb-1997     SCousens     Created.
//
//----------------------------------------------------------------------------
HRESULT CleanupTestDocfile (
        VirtualCtrNode **ppVirtualDFRoot,
        VirtualDF      **ppTestVirtualDF,
        ChanceDF       **ppTestChanceDF,
        BOOL             fDeleteFile)
{                       
    LPTSTR          pFileName   =  NULL;
    HRESULT         hr          =  S_OK;
    VirtualCtrNode *pvcnRootNode= *ppVirtualDFRoot;
    VirtualDF      *pVirtualDF  = *ppTestVirtualDF;
    ChanceDF       *pChanceDF   = *ppTestChanceDF;

    DH_FUNCENTRY (NULL, DH_LVL_DFLIB, TEXT("CleanupTestDocfile"));

    // Make sure everything in the docfile is closed
    if (NULL != pvcnRootNode)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms (pvcnRootNode, NODE_INC_TOPSTG);
        DH_HRCHECK (hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms")) ;
    }

    // Get file name
    if (TRUE == fDeleteFile && DeleteTestDF ())
    {
        if (NULL != pvcnRootNode)
        {
            pFileName= new TCHAR[_tcslen (pVirtualDF->GetDocFileName ())+1];
            if (pFileName != NULL)
            {
                _tcscpy (pFileName, pVirtualDF->GetDocFileName ());
            }
        }
    }

    // Delete Virtual docfile tree
    if (NULL != pVirtualDF)
    {
        hr = pVirtualDF->DeleteVirtualDocFileTree (pvcnRootNode);
        DH_HRCHECK (hr, TEXT("pVirtualDF->DeleteVirtualFileDocTree")) ;

        delete pVirtualDF;
        pVirtualDF = NULL;
    }

    // Delete Chance docfile tree
    if (NULL != pChanceDF)
    {
        hr = pChanceDF->DeleteChanceDocFileTree (pChanceDF->GetChanceDFRoot());
        DH_HRCHECK (hr, TEXT("pChanceDF->DeleteChanceFileDocTree")) ;

        delete pChanceDF;
        pChanceDF = NULL;
    }

    // Delete the docfile on disk
    if ((S_OK == hr) && (NULL != pFileName))
    { 
        if (FALSE == DeleteFile(pFileName))
        {
            hr = HRESULT_FROM_WIN32 (GetLastError()) ;
            DH_HRCHECK (hr, TEXT("DeleteFile")) ;
        }
    }

    // Delete the docfile name
    if (NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\stgbvt\ctolestg\tests\stgbase\ilkbtsts.cxx ===
-------------------------------------------------------------------------
//
//  Microsoft OLE
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:      ilkbtsts.cxx
//
//  Contents:  storage base tests basically pertaining to ILockBytes 
//
//  Functions:  
//
//  History:    31-July-1996     NarindK     Created.
//              27-Mar-97        SCousens    Conversionified
//
//--------------------------------------------------------------------------

#include <dfheader.hxx>
#pragma hdrstop

#include  "init.hxx"
#include  "ilkbhdr.hxx"

//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_100 
//
// synopsis: The test first creates an ILockBytes instance and then uses this
//           ILockBytes instead of OLE provided ILockBytes file in the under
//           lying file system.  Thus the root DocFile is created upon a
//           ILockBytes instead of a file system file, therby exercising the
//           ILockBytes functionality.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  31-July-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: DFLIB.CXX
// 2.  Old name of test : DfSetUpOnILockBytes Test 
//     New Name of test : ILKBTEST_100 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-100 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-100 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /t:ILKBTEST-100 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-100 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_100(int argc, char *argv[])
{
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    ILockBytesDF    *pTestILockBytesDF      = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    LPSTORAGE       pStgRoot1               = NULL;
    LPSTORAGE       pStgRootOnILockBytes    =   NULL;
    CFileBytes      *pCFileBytes            = NULL;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_100"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_100 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes test - Creating DocFile on ILockBytes")));


    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_100, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestILockBytesDF = new ILockBytesDF();
        if(NULL == pTestILockBytesDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestILockBytesDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgCreateDocFileOnILockBytes passed as exp.")));

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgCreateDocFileOnILockBytes failed unexp, hr = 0x%lx."),
            hr));

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Release all substorages/streams too

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Get the original CRC of docfile 

    if(S_OK == hr)
    {
        pStgRoot1 = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRoot1);

        hr = CalculateCRCForDocFile(pStgRoot1,VERIFY_INC_TOPSTG_NAME,&dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Close the Root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;

        pStgRoot1 = NULL;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // ReOpen the root using StgOpenStorageOnILockBytes call.

    if(S_OK == hr)
    {
        pCFileBytes = pTestILockBytesDF->_pCFileBytes;

        hr = pVirtualDFRoot->OpenRootOnCustomILockBytes(
                NULL,
                dwRootMode,
                NULL,
                0,
                pCFileBytes);

        DH_HRCHECK(hr, TEXT("StgOpenStorageOnILockBytes"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorageOnILockBytes passed as exp.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("StgOpenStorageOnILockBytes failed unexp, hr = 0x%lx."),
            hr));
    } 

    // Get the CRC of docfile now after opening on custom ILockBytes

    if(S_OK == hr)
    {
        pStgRootOnILockBytes = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRootOnILockBytes);

        hr = CalculateCRCForDocFile(
                pStgRootOnILockBytes,
                VERIFY_INC_TOPSTG_NAME,
                &dwCRC2);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Release the pointer

    // Close the Root

    if(S_OK == hr)
    {
        hr = pVirtualDFRoot->Close();

        DH_HRCHECK(hr, TEXT("VirtualCtrNode::Close")) ;

        pStgRootOnILockBytes = NULL;
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("VirtualCtrNode::Close passed as exp. ")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("VirtualCtrNode::Close failed unexp, hr=0x%lx "),
            hr));
    }

    // if everything goes well, log test as passed else failed.

    if (S_OK == hr) 
    {
        if(dwCRC1 == dwCRC2)
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's match")));

            DH_LOG((LOG_PASS, TEXT("Test variation ILKBTEST_100 passed.")) );
        }
        else
        {
            DH_TRACE((DH_LVL_TRACE1, TEXT("CRC's don't match")));

            DH_LOG((LOG_FAIL, TEXT("Test variation ILKBTEST_100 failed.")) );

            hr = E_FAIL;
        }
    }
    else
    {
          DH_LOG((LOG_FAIL, 
            TEXT("Test variation ILKBTEST_100 failed, hr=0x%lx."),
            hr) );
    }

    //BUGBUG: This may cause a leak. We may want to be releasing pTestILockBytesDF->_pCFileBytes
    if(NULL != pCFileBytes)
    {
        // Release would destroy pCFileBytes object when RefCount reaches zero.
        ulRef = pCFileBytes->Release();
        DH_ASSERT(0 == ulRef);
    }
        
    // Cleanup

    // Get the name of file, will be used later to delete the file

    if(NULL != pVirtualDFRoot)
    {
        pFileName= new TCHAR[_tcslen(pTestILockBytesDF->GetDocFileName())+1];

        if (pFileName != NULL)
        {
            _tcscpy(pFileName, pTestILockBytesDF->GetDocFileName());
        }
    }

    // Delete the docfile on disk

    if((S_OK == hr) && (NULL != pFileName))
    {
        if(FALSE == DeleteFile(pFileName))
        {
            hr2 = HRESULT_FROM_WIN32(GetLastError()) ;

            DH_HRCHECK(hr2, TEXT("DeleteFile")) ;
        }
    }

    // Delete Chance docfile tree

    if(NULL != pTestChanceDF)
    {
        hr2 = pTestChanceDF->DeleteChanceDocFileTree(
                pTestChanceDF->GetChanceDFRoot());

        DH_HRCHECK(hr2, TEXT("pTestChanceDF->DeleteChanceFileDocTree")) ;

        delete pTestChanceDF;
        pTestChanceDF = NULL;
    }

    // Delete Virtual docfile tree

    if (NULL != pTestILockBytesDF)
    {
        hr2 = pTestILockBytesDF->DeleteVirtualDocFileTree(pVirtualDFRoot);

        DH_HRCHECK(hr2, TEXT("pTestILockBytesDF->DeleteVirtualFileDocTree")) ;

        delete pTestILockBytesDF;
        pTestILockBytesDF = NULL;
    }

    if(NULL != pFileName)
    {
        delete pFileName;
        pFileName = NULL;
    }

    // Stop logging the test

    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_100 finished")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );

    return hr;
}

//----------------------------------------------------------------------------
//
// Test:   ILKBTEST_101
//
// synopsis: The test first creates an ILockBytes instance and then uses this
//           ILockBytes instead of OLE provided ILockBytes file in the under
//           lying file system.  Thus the root DocFile is created upon a
//           ILockBytes instead of a file system file, therby exercising the
//           ILockBytes functionality.  This test opens the Asynchronous
//           docfile on ILockBytes
//
//           This test uses ASYNCHRONOUS API's to open the custom ILockBytes
//           by getting the IFillLockBytes based on custom ILockBytes and
//           then using appropraiet API calls.
//
// Arguments:[argc]
//           [argv]
//
// Returns:  HRESULT
//
// History:  5-Aug-1996     NarindK     Created.
//
// Notes:    This test runs in direct, transacted, and transacted deny write 
//           modes
//
// New Test Notes:
// 1.  Old File: ADFLIB.CXX
// 2.  Old name of test : DfSetUpOnILockBytes Test 
//     New Name of test : ILKBTEST_101 
// 3.  To run the test, do the following at command prompt. 
//     a. stgbase /seed:0 /t:ILKBTEST-101 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:dirReadWriteShEx /dfStgMode:dirReadWriteShEx 
//     b. stgbase /seed:0 /t:ILKBTEST-101 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShEx /dfStgMode:xactReadWriteShEx 
//     c. stgbase /seed:0 /t:ILKBTEST-101 /dfdepth:1-2 /dfstg:1-3 /dfstm:1-3
//        /dfRootMode:xactReadWriteShDenyW /dfStgMode:xactReadWriteShEx 
//
// BUGNOTE: Conversion: ILKBTEST-101 NO - not supported in nss
//
//-----------------------------------------------------------------------------

HRESULT ILKBTEST_101(int argc, char *argv[])
{
#ifdef _MAC

    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!!!!!!ILKBTEST_101 crashes")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("!!!!!!!!!!!!!!!!!!To be investigateds")) );
    return E_NOTIMPL;

#else
    
    HRESULT         hr                      = S_OK;
    HRESULT         hr2                     = S_OK;
    ChanceDF        *pTestChanceDF          = NULL;
    ILockBytesDF    *pTestILockBytesDF      = NULL;
    VirtualCtrNode  *pVirtualDFRoot         = NULL;
    DWORD           dwRootMode              = 0;
    DWORD           dwStgMode               = 0;
    LPTSTR          pFileName               = NULL;
    ULONG           ulRef                   = 0;
    CFileBytes      *pCFileBytes            = NULL;
    LPSTORAGE       pStgRoot1               = NULL;
    LPSTORAGE       pStgAsyncDocFile        = NULL;
    DWORD           dwCRC1                  = 0;
    DWORD           dwCRC2                  = 0;
    IFillLockBytes  *pIFillLockBytes        = NULL;
    CFileBytes      *pCFileBytesEmpty       = NULL;
    LPBYTE          pBuffer                 = NULL;
    ULONG           cbRead                  = 0;
    ULONG           cbWritten               = 0;
    ULARGE_INTEGER  uli;
    ULARGE_INTEGER  uliOffset;

    // Not for 2phase. Bail. 
    if (DoingDistrib ())
    {
        return S_OK;
    }

    DH_FUNCENTRY(&hr, DH_LVL_DFLIB, _TEXT("ILKBTEST_101"));

    DH_TRACE((DH_LVL_TRACE1, TEXT("--------------------------------------------")) );
    DH_TRACE((DH_LVL_TRACE1, TEXT("Test variation ILKBTEST_101 started.")) );
    DH_TRACE((
        DH_LVL_TRACE1,
        TEXT("ILockBytes test - Opening Async DocFile on ILockBytes")));


    // Create the new ChanceDocFile tree that would consist of chance nodes.

    if (S_OK == hr)
    {
        pTestChanceDF = new ChanceDF();
        if(NULL == pTestChanceDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestChanceDF->CreateFromParams(argc, argv);

        DH_HRCHECK(hr, TEXT("pTestChanceDF->CreateFromParams")) ;
    }

    if (S_OK == hr)
    {
        dwRootMode = pTestChanceDF->GetRootMode();
        dwStgMode = pTestChanceDF->GetStgMode();

        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("Run Mode for ILKBTEST_101, Access mode: %lx"),
            dwRootMode));
    }

    // Create the DocFile tree  based on ChanceDocFile tree created in
    // previous step

    if (S_OK == hr)
    {
        pTestILockBytesDF = new ILockBytesDF();
        if(NULL == pTestILockBytesDF)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        hr = pTestILockBytesDF->GenerateVirtualDF(
                pTestChanceDF, 
                &pVirtualDFRoot);

        DH_HRCHECK(hr, TEXT("pTestILockBytesDF->GenerateVirtualDF")) ;
    }

    if (S_OK == hr)
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - successfully created.")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("DocFile - CreateFromParams - failed, hr=0x%lx."),
            hr));
    }

    // Commit all storages/streams

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCommitAllOpenStgs(
                pVirtualDFRoot,
                STGC_DEFAULT,
                NODE_INC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCommitAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCommitAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Release all substorages/streams too

    if (S_OK == hr)
    {
        hr = ParseVirtualDFAndCloseOpenStgsStms(
                pVirtualDFRoot,
                NODE_EXC_TOPSTG);

        DH_HRCHECK(hr, TEXT("ParseVirtualDFAndCloseOpenStgsStms"));
    }

    if(S_OK == hr)
    {
        DH_TRACE((DH_LVL_TRACE1, TEXT("ParseVirtualDFAndCloseAllOpenStgs passed")));
    }
    else
    {
        DH_TRACE((
            DH_LVL_TRACE1,
            TEXT("ParseVirtualDFAndCloseAllOpenStgs failed unexp,hr=0x%lx "),
            hr));
    }

    // Get the original CRC of docfile

    if(S_OK == hr)
    {
        pStgRoot1 = pVirtualDFRoot->GetIStoragePointer();

        DH_ASSERT(NULL != pStgRoot1);

        hr = CalculateCRCForDocFile(pStgRoot1,VERIFY_INC_TOPSTG_NAME,&dwCRC1);

        DH_HRCHECK(hr, TEXT("CalculateCRCForDocFile")) ;
    }

    // Close the Root

    if(S_OK == hr)
    {
        h