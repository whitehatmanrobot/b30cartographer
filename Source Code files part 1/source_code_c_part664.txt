-------------
//
// Function:  CStatusDlg::OnOK
//
// Synopsis:  Virtual function. Process WM_COMMAND IDOK
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::OnOK()
{
    if (m_fDisplayStatus)  
    {
        ShowWindow(m_hWnd, SW_HIDE);
        EnableWindow(m_hWnd, FALSE);
    }
    else  // in count-down state
    {
        m_pConnection->OnStayOnLine();
   		// 
		// If window is was up previously and a countdown is being
		// terminated leave the window active. Otherwise restore
		// window to previous hidden state.
		//

        if (!m_fStatusWindowVisible)
        {
            ShowWindow(m_hWnd,SW_HIDE);
			EnableWindow(m_hWnd, FALSE);
        }
    }

    if (!IsWindowVisible(m_hWnd))
    {
        //
        // Minimize the working set after hide the window.
        //
        CMonitor::MinimizeWorkingSet();
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::ChangeToCountDown
//
// Synopsis:  Change the status dialog to count-down dialog
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::ChangeToCountDown()
{
    MYDBGASSERT(m_fDisplayStatus); // is status;

    m_fDisplayStatus = FALSE;
    //
    // After user clicked "Stay Online", we need to restore the visible state
    // Convert is to real boolean
    //
    m_fStatusWindowVisible = IsWindowVisible(m_hWnd) != FALSE;

    KillRasMonitorWindow();

	//
    // Change OK to Stay Online
    //
    LPTSTR pszTmp = CmLoadString(CMonitor::GetInstance(),IDMSG_CONNDISC_STAYONLINE);
	SetDlgItemTextU(m_hWnd,IDOK,pszTmp);
	CmFree(pszTmp);
	
    //
    // Change Disconnect to Disconnect Now
    //
    pszTmp = CmLoadString(CMonitor::GetInstance(),IDMSG_CONNDISC_DISCNOW);
	SetDlgItemTextU(m_hWnd,IDC_DISCONNECT,pszTmp);
	CmFree(pszTmp); 
	
	// Hide/Show the windows for countdown mode
	
    if (!OS_NT4)
    {
        //
        // Hide 9X statistics control
        //
        ShowWindow(GetDlgItem(m_hWnd,IDC_CONNSTAT_SPEED_DISPLAY),SW_HIDE);
	    ShowWindow(GetDlgItem(m_hWnd,IDC_CONNSTAT_RECEIVED_DISPLAY),SW_HIDE);
	    ShowWindow(GetDlgItem(m_hWnd,IDC_CONNSTAT_SENT_DISPLAY),SW_HIDE);
    }

	ShowWindow(GetDlgItem(m_hWnd,IDC_AUTODISC),SW_SHOW);
    SetForegroundWindow(m_hWnd);

    //
    // Make sure we're flashing and topmost for countdown
    //

    SetWindowPos(m_hWnd, HWND_TOPMOST, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE);

    Flash();
}
 
//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::ChangeToStatus
//
// Synopsis:  Change the count-down dialog to status dialog
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::ChangeToStatus()
{
    MYDBGASSERT(!m_fDisplayStatus); // is count down

    m_fDisplayStatus = TRUE;

	// Set text for buttons and static to standard mode
    SetDlgItemTextU(m_hWnd,IDC_CONNSTAT_DISCONNECT_DISPLAY,TEXT(""));

    //
    // Change back to OK
    //
    LPTSTR pszTmp = CmLoadString(CMonitor::GetInstance(),IDMSG_CONNDISC_OK);
	SetDlgItemTextU(m_hWnd,IDOK,pszTmp);
	CmFree(pszTmp);

    //
    // Change back to Disconnect
    //
	pszTmp = CmLoadString(CMonitor::GetInstance(),IDMSG_CONNDISC_DISCONNECT);
	SetDlgItemTextU(m_hWnd,IDC_DISCONNECT,pszTmp);
	CmFree(pszTmp);

	// Hide/Show the windows for standard mode

	ShowWindow(GetDlgItem(m_hWnd,IDC_AUTODISC),SW_HIDE);
    if (!OS_NT4)
    {
	    ShowWindow(GetDlgItem(m_hWnd,IDC_CONNSTAT_SPEED_DISPLAY),SW_SHOW);
	    ShowWindow(GetDlgItem(m_hWnd,IDC_CONNSTAT_RECEIVED_DISPLAY),SW_SHOW);
	    ShowWindow(GetDlgItem(m_hWnd,IDC_CONNSTAT_SENT_DISPLAY),SW_SHOW);
    }

    //
    // Make sure we're not top-most, just on top, when we switch to status
    //

    SetWindowPos(m_hWnd, HWND_TOP, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE);
}

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::UpdateCountDown
//
// Synopsis:  Update the "xx seconds until disconnect" of the count-down dialog
//
// Arguments: DWORD dwDuration: connection duration
//            DWORD dwSeconds - seconds remain to disconnect
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::UpdateCountDown(DWORD dwDuration, DWORD dwSeconds)
{
    MYDBGASSERT(!m_fDisplayStatus);
    MYDBGASSERT(dwSeconds < 0xFFFF);

    UpdateDuration(dwDuration);

    LPTSTR pszTmp = CmFmtMsg(CMonitor::GetInstance(), IDMSG_CONNDISCONNECT, dwSeconds);
	SetDlgItemTextU(m_hWnd,IDC_CONNSTAT_DISCONNECT_DISPLAY,pszTmp);
	CmFree(pszTmp);
}

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::UpdateDuration
//
// Synopsis:  Update the connection duration
//
// Arguments: DWORD dwSeconds - connected duration
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::UpdateDuration(DWORD dwSeconds)
{
    if (!IsWindowVisible(m_hWnd))
    {
        return;
    }

	LPTSTR pszMsg;

	// Connect Duration

	pszMsg = CmFmtMsg(CMonitor::GetInstance(),
					  IDMSG_CONNDUR,
					  (WORD)((dwSeconds/60)/60),
					  (WORD)((dwSeconds/60)%60),
					  (WORD)(dwSeconds%60));
	SetDlgItemTextU(m_hWnd,IDC_CONNSTAT_DURATION_DISPLAY,pszMsg);
	CmFree(pszMsg);
}

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::UpdateStats
//
// Synopsis:  Update the status dialog for Win9X
//
// Arguments: DWORD dwBaudRate - Baud rate
//            DWORD dwBytesRead - Total Bytes read
//            DWORD dwBytesWrite - Total bytes written
//            DWORD dwBytesReadPerSec - Byte read last second
//            DWORD dwBytesWritePerSec - Byte written last second
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::UpdateStats(DWORD dwBaudRate, DWORD dwBytesRead, DWORD dwBytesWrite,
                 DWORD dwBytesReadPerSec, DWORD dwBytesWritePerSec)
{
	//
	// Received
	//

	CHAR szFmtNum1[MAX_PATH];
	CHAR szFmtNum2[MAX_PATH];
    LPSTR pszMsg;

    FmtNum(dwBytesRead, szFmtNum1, sizeof(szFmtNum1));


	if (dwBytesReadPerSec) 
	{
		FmtNum(dwBytesReadPerSec, szFmtNum2, sizeof(szFmtNum2));
		pszMsg = CmFmtMsgA(CMonitor::GetInstance(), IDMSG_CONNCNTRATE, szFmtNum1, szFmtNum2);
	} 
	else 
	{
		pszMsg = CmFmtMsgA(CMonitor::GetInstance(), IDMSG_CONNCNT, szFmtNum1);
	}

	SetDlgItemTextA(m_hWnd, IDC_CONNSTAT_RECEIVED_DISPLAY, pszMsg);
	CmFree(pszMsg);

	//
	// Sent 
	//

	FmtNum(dwBytesWrite, szFmtNum1, sizeof(szFmtNum1));

	if (dwBytesWritePerSec) 
	{
		FmtNum(dwBytesWritePerSec, szFmtNum2, sizeof(szFmtNum2));
		pszMsg = CmFmtMsgA(CMonitor::GetInstance(), IDMSG_CONNCNTRATE, szFmtNum1, szFmtNum2);
	} 
	else 
	{
		pszMsg = CmFmtMsgA(CMonitor::GetInstance(), IDMSG_CONNCNT, szFmtNum1);
	}

	SetDlgItemTextA(m_hWnd, IDC_CONNSTAT_SENT_DISPLAY, pszMsg);

	CmFree(pszMsg);

	if (dwBaudRate) 
	{
		FmtNum(dwBaudRate, szFmtNum1, sizeof(szFmtNum1));
		pszMsg = CmFmtMsgA(CMonitor::GetInstance(), IDMSG_CONNSPEED, szFmtNum1);
		SetDlgItemTextA(m_hWnd, IDC_CONNSTAT_SPEED_DISPLAY, pszMsg);
		CmFree(pszMsg);
	}
}

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::GetRasMonitorWindow
//
// Synopsis:  Find the RasMonitor window on NT, if present
//            The Status window is the owner of the RasMonitor
//
// Arguments: none
//
// Returns:   HWND - The RasMonitor window handle or NULL
//
// History:   fengsun Created Header    2/12/98
//
//+----------------------------------------------------------------------------
HWND CStatusDlg::GetRasMonitorWindow()
{
    //
    // RasMonitor window only exists on NT
    //
    if (!OS_NT4)
    {
        return NULL;
    }

    //
    // The RasMonitor window is the child window of desktop
    // however, the owner window is the status window
    //
    HWND hwnd = NULL;
    
    while (hwnd = FindWindowExU(NULL, hwnd, WC_DIALOG, NULL))
    {
        if (GetParent(hwnd) == m_hWnd)
        {
            return hwnd;
        }
    }

    return NULL;
}



//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::KillRasMonitorWindow
//
// Synopsis:  Close the RasMonitorDlg and any child dialog it might have
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    4/28/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::KillRasMonitorWindow()
{

    HWND hwndRasMonitor = GetRasMonitorWindow();

    if (hwndRasMonitor)
    {
        //
        // The current thread is the connection thread
        //
        MYDBGASSERT(GetWindowThreadProcessId(m_hWnd, NULL) == GetCurrentThreadId());

        //
        // The RasMonitorDlg can pop up aother dialog, such as details.
        // Kill all the dialog in the RasMonitor thread
        //

        DWORD dwRasMonitorThread = GetWindowThreadProcessId(hwndRasMonitor, NULL);
        MYDBGASSERT(dwRasMonitorThread);
        MYDBGASSERT(dwRasMonitorThread != GetCurrentThreadId());

        EnumThreadWindows(dwRasMonitorThread, KillRasMonitorWndProc, (LPARAM)this);
    }
}



//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::KillRasMonitorWndProc
//
// Synopsis:  Kill all the window in the RasMonitorThread
//
// Arguments: HWND hwnd - Window handle belong to the RasMonitorThread
//            LPARAM lParam - pointer to CStatusDlg
//
// Returns:   BOOL - TRUE to continue enumeration
//
// History:   fengsun Created Header    4/28/98
//
//+----------------------------------------------------------------------------
BOOL CALLBACK CStatusDlg::KillRasMonitorWndProc(HWND hwnd,  LPARAM lParam)
{
    //
    // SendMessage will block until the message returns, because we do not
    // want to exit the connection thread before RasMinotor thread ended.
    // CM sends a message from Connection thread to RasMonitor thread.
    // Be careful about possible deadlock situation
    // Cause Bug 166787
    //

    SendMessageA(hwnd, WM_CLOSE, (WPARAM)0, (LPARAM)0);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::DismissStatusDlg
//
// Synopsis:  Dismisses the status dialog.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    4/28/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::DismissStatusDlg()
{
    //
    //  Since OnOK is protected and virtual we will just add a member function
    //  to call it.  We really just want to dismiss the dialog so it will be
    //  hidden again.
    //
    OnOK();
}

#ifdef DEBUG
//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::AssertValid
//
// Synopsis:  For debug purpose only, assert the object is valid
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::AssertValid() const
{
    MYDBGASSERT(m_fDisplayStatus == TRUE || m_fDisplayStatus == FALSE);
    MYDBGASSERT(m_fStatusWindowVisible == TRUE || m_fStatusWindowVisible == FALSE);
    MYDBGASSERT(m_pConnection != NULL);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\smplring.h ===
//+----------------------------------------------------------------------------
//
// File:	 SimpRing.h
//
// Module:	 CMMON32.EXE
//
// Synopsis: Define a template for a round ring class
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 ?????  Created    10/27/97
//
//+----------------------------------------------------------------------------

#ifndef SMPLRING_H
#define SMPLRING_H

//+---------------------------------------------------------------------------
//
//	class :	CSimpleRing template
//
//	Synopsis:	A simple round ring class.  It does not check the full
//              or empty situation.  That is the new item will overwrite the 
//              old one, when the ring is full
//
//	Template Arguments:	class TYPE, the type of element in the ring
//                      DWORD dwSize, the size of the ring
//
//	History:	fengsun created		10/97
//
//----------------------------------------------------------------------------

template <class TYTE, DWORD dwSize> class CSimpleRing
{
public:
    CSimpleRing() {m_dwIndex = 0;}
    void Reset();                     // Reset all data to 0, will not call destructor
    void Add(const TYTE& dwElement);  // Add one elements, it will over write the last one in the ring
    const TYTE& GetLatest() const;     // Get the one just put in
    const TYTE& GetOldest() const;      // Get the last element in the ring,

protected:
    DWORD m_dwIndex;              // The index of next item to be added
    TYTE  m_Elements[dwSize];     // The elements array

public:
#ifdef DEBUG
    void AssertValid() const;
#endif
};

template <class TYPE, DWORD dwSize> 
inline void CSimpleRing<TYPE, dwSize>::Reset()
{
    ZeroMemory(m_Elements, sizeof(m_Elements));
    m_dwIndex = 0;
}

template <class TYPE, DWORD dwSize> 
inline void CSimpleRing<TYPE, dwSize>::Add(const TYPE& dwElement)
{
    m_Elements[m_dwIndex] = dwElement;
    m_dwIndex = (m_dwIndex + 1) % dwSize;
}

template <class TYPE, DWORD dwSize> 
inline const TYPE& CSimpleRing<TYPE, dwSize>::GetLatest() const
{
    return m_Elements[(m_dwIndex-1)%dwSize];
}

//+----------------------------------------------------------------------------
//
// Function:  DWORD CIdleStatistics::CDwordRing<dwSize>::GetOldest
//
// Synopsis:  Get the oldest element in the ring,
//
// Arguments: None
//
// Returns:   DWORD
//
// History:   Created Header    10/15/97
//
//+----------------------------------------------------------------------------

template <class TYPE, DWORD dwSize> 
inline const TYPE& CSimpleRing<TYPE, dwSize>::GetOldest() const
{
    return m_Elements[m_dwIndex];
}

#ifdef DEBUG
//+----------------------------------------------------------------------------
//
// Function:  CSimpleRing::AssertValid
//
// Synopsis:  For debug purpose only, assert the object is valid
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/12/98
//
//+----------------------------------------------------------------------------
template <class TYPE, DWORD dwSize> 
inline void CSimpleRing<TYPE, dwSize>::AssertValid() const
{
    MYDBGASSERT(m_dwIndex < dwSize); 
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\trayicon.h ===
//+----------------------------------------------------------------------------
//
// File:     TrayIcon.h  
//
// Module:   CMMON32.EXE
//
// Synopsis: CTrayIcon class definition, which manages the connection tray icon 
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun Created    02/17/98
//
//+----------------------------------------------------------------------------

#ifndef TRAYICON_H
#define TRAYICON_H

#include "ArrayPtr.h"


class CIni;

//+---------------------------------------------------------------------------
//
//  class CTrayIcon
//
//  Description: A class to manage tray icon
//
//  History:    fengsun Created     2/17/98
//
//----------------------------------------------------------------------------
class CTrayIcon
{
public:
    CTrayIcon();
    ~CTrayIcon();

    void SetIcon(HICON hIcon, HWND hwnd, UINT uMsg, UINT uID, const TCHAR* lpMsg = NULL);
//    void SetTip(const TCHAR* lpMsg);
    void RemoveIcon();
    void CreateMenu(const CIni* pIniFile, DWORD dwMsgBase);

    void PopupMenu(int x, int y, HWND hWnd);
    const TCHAR* GetMenuCommand(int i) const;
    int GetAdditionalMenuNum() const;

protected:

    HMENU m_hMenu;  // the IDM_TARY menu in the resource
    HMENU m_hSubMenu;   // the first sub menu of IDM_TRAY
    HWND  m_hwnd;       // the window handle for the tray icon
    UINT  m_uID;        // the ID of the tray icon
    HICON m_hIcon;      // the tray icon handle
    CPtrArray m_CommandArray;  // array of LPTSTR menu item command line
};

inline void CTrayIcon::PopupMenu(int x, int y, HWND hWnd)
{
    SetMenuDefaultItem(m_hSubMenu, IDMC_TRAY_STATUS, FALSE); 
    MYVERIFY(TrackPopupMenu(m_hSubMenu,TPM_LEFTALIGN|TPM_RIGHTBUTTON,x,y,0,hWnd,NULL));
}

inline const TCHAR* CTrayIcon::GetMenuCommand(int i) const
{
    return (const TCHAR*) m_CommandArray[i];
}
    
inline int CTrayIcon::GetAdditionalMenuNum() const
{
    return m_CommandArray.GetSize();

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\trayicon.cpp ===
//+----------------------------------------------------------------------------
//
// File:     trayicon.cpp
//
// Module:   CMMON32.EXE
//
// Synopsis: Implementation for the CTrayIcon class.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "resource.h"
#include "TrayIcon.h"
#include "Monitor.h"
#include "cm_misc.h"
#include "ShellDll.h"

//+----------------------------------------------------------------------------
//
// Function:  CTrayIcon::CTrayIcon
//
// Synopsis:  Constructor
//
// Arguments: Nothing
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
CTrayIcon::CTrayIcon()
{
    m_hwnd = NULL;
    m_hMenu = m_hSubMenu = NULL;
    m_uID = 0;
    m_hIcon = NULL;
}



//+----------------------------------------------------------------------------
//
// Function:  CTrayIcon::~CTrayIcon
//
// Synopsis:  Destructor
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    4/7/98
//
//+----------------------------------------------------------------------------
CTrayIcon::~CTrayIcon()
{
    if (m_hMenu)
    {
        DestroyMenu(m_hMenu);
    }

    if (m_hIcon)
    {
        DeleteObject(m_hIcon);
    }

    for (int i=0; i< m_CommandArray.GetSize();i++)
    {
        CmFree((TCHAR*) m_CommandArray[i]);
    }

}



#if 0 // this function is not used

/*
//+----------------------------------------------------------------------------
//
// Function:  CTrayIcon::SetTip
//
// Synopsis:  Change the tip of the tray icon
//
// Arguments: const TCHAR* lpMsg - message to set
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CTrayIcon::SetTip(const TCHAR* lpMsg)
{
    MYDBGASSERT(IsWindow(m_hwnd));
    MYDBGASSERT(lpMsg);

    NOTIFYICONDATA nidData;
    ZeroMemory(&nidData,sizeof(nidData));
    nidData.cbSize = sizeof(nidData);
    nidData.hWnd = m_hwnd;
    nidData.uID = m_uID;
    nidData.uFlags = NIF_TIP;

    lstrcpyn(nidData.szTip,lpMsg,sizeof(nidData.szTip)/sizeof(TCHAR));

    //
    // Load Shell32.dll and call Shell_NotifyIcon
    //
    CShellDll ShellDll;
    BOOL bRes = ShellDll.NotifyIcon(NIM_MODIFY,&nidData);
    MYDBGASSERT(bRes);
}
*/
#endif

//+----------------------------------------------------------------------------
//
// Function:  CTrayIcon::SetIcon
//
// Synopsis:  Set the icon for the tray icon
//
// Arguments: HICON hIcon - icon to set.  Use NULL to use existing icon.
//            HWND hwnd - window to receive tray icon message
//            UINT uMsg - tray icon message
//            UINT uID - The id for the tray icon
//            const TCHAR* lpMsg - The initial tip for the icon
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CTrayIcon::SetIcon(HICON hIcon, HWND hwnd, UINT uMsg, UINT uID, const TCHAR* lpMsg)
{
    MYDBGASSERT(IsWindow(hwnd));
    //MYDBGASSERT(m_hIcon == NULL);
    //MYDBGASSERT(hIcon);
    MYDBGASSERT(m_hIcon == NULL && hIcon ||
                m_hIcon && hIcon == NULL);

    m_hwnd = hwnd;
    m_uID = uID;

    NOTIFYICONDATA nidData;

    ZeroMemory(&nidData,sizeof(nidData));
    nidData.cbSize = sizeof(nidData);
    nidData.hWnd = m_hwnd;
    nidData.uID = uID;
    nidData.uFlags = NIF_ICON | NIF_MESSAGE;
    //
    // we'll reuse the icon if we already have one.
    //
    if (!m_hIcon)
    {
        m_hIcon = hIcon;
    }
    nidData.hIcon = m_hIcon;

    nidData.uCallbackMessage = uMsg;

    if (lpMsg)
    {
        nidData.uFlags |= NIF_TIP;
        lstrcpynU(nidData.szTip,lpMsg,sizeof(nidData.szTip)/sizeof(TCHAR));
    }

    //
    // Load Shell32.dll and call Shell_NotifyIcon
    //
    CShellDll ShellDll;
    DWORD   cRetries = 0;
    
    BOOL bRes = ShellDll.NotifyIcon(NIM_ADD,&nidData);
    //
    // Check if Icon is already added
    //
    if (bRes == FALSE)
    {
        bRes = ShellDll.NotifyIcon(NIM_MODIFY,&nidData);
    }
    //
    // If this fails its very likely that the tray is not started yet. Retry few times
    // with a max wait time of 5 mins & then abort
    //
    while (bRes == FALSE && cRetries < 300)
    {
        Sleep(1000);
        cRetries ++;
//        CMTRACE1(TEXT("Shell_NotifyIcon = %d"), bRes);
        bRes = ShellDll.NotifyIcon(NIM_ADD,&nidData);
        //
        // Check if Icon is already added
        //
        if (bRes == FALSE)
        {
            bRes = ShellDll.NotifyIcon(NIM_MODIFY,&nidData);
        }
    }
    MYDBGASSERT(bRes);
}

//+----------------------------------------------------------------------------
//
// Function:  CTrayIcon::RemoveIcon
//
// Synopsis:  remove icon from the tray
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CTrayIcon::RemoveIcon() 
{
    if (m_hIcon)
    {
        NOTIFYICONDATA nidData;

        ZeroMemory(&nidData,sizeof(nidData));
        nidData.cbSize = sizeof(nidData);
        nidData.hWnd = m_hwnd;
        nidData.uID = m_uID;

        //
        // Load Shell32.dll and call Shell_NotifyIcon
        //
        CShellDll ShellDll;
        BOOL bRes = ShellDll.NotifyIcon(NIM_DELETE,&nidData);
        MYDBGASSERT(bRes);

        DeleteObject(m_hIcon);
        m_hIcon = NULL;
    }
}


//+---------------------------------------------------------------------------
//
//  class CMultipleString
//
//  Description: A string taht have multiple sub strings.
//      The format is "stringA\0stringB\0...\0\0"
//
//  History:    fengsun Created     2/17/98
//
//----------------------------------------------------------------------------

class CMultipleString
{
public:
    CMultipleString(const TCHAR* lpStrings) {m_lpStrings = lpStrings;}
    const TCHAR* GetNextString();

protected:
    const TCHAR * m_lpStrings; // pointer to the string to be distracted
};

//+----------------------------------------------------------------------------
//
// Function:  CMultipleString::GetNextString
//
// Synopsis:  Get the next substring 
//
// Arguments: None
//
// Returns:   const TCHAR* - The next sub string or NULL
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
const TCHAR* CMultipleString::GetNextString()
{
    MYDBGASSERT(m_lpStrings);

    if (m_lpStrings[0] == TEXT('\0'))
    {
        //
        // Reach the end og the string
        //
        return NULL;
    }

    const TCHAR* lpReturn = m_lpStrings;

    //
    // Advance the pointer to the next string
    //
    m_lpStrings += lstrlenU(lpReturn)+1;

    return (lpReturn);
}

//+----------------------------------------------------------------------------
//
// Function:  CTrayIcon::CreateMenu
//
// Synopsis:  Create the menu for the tray icon
//
// Arguments: const CIni* pIniFile - The ini file which have a tray menu section
//            DWORD dwMsgBase - The starting message id for the additional 
//                          command in the tray menu
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CTrayIcon::CreateMenu(const CIni* pIniFile, DWORD dwMsgBase)
{
    MYDBGASSERT(pIniFile);

    //
    // The default tray menu is the sub-menu of IDM_TRAY in the resource
    //
    m_hMenu = LoadMenuU(CMonitor::GetInstance(), MAKEINTRESOURCE(IDM_TRAY));
    MYDBGASSERT(m_hMenu != NULL);

    m_hSubMenu = GetSubMenu(m_hMenu, 0);
    MYDBGASSERT(m_hSubMenu != NULL);

    //
    // lpMenuNames contains all the entry names under c_pszCmSectionMenuOptions
    //
    LPTSTR lpMenuNames = pIniFile->GPPS(c_pszCmSectionMenuOptions, (LPTSTR)NULL);

    if (lpMenuNames[0] == 0)
    {
        //
        // No additional menu item
        //
        CmFree(lpMenuNames);
        return;
    }

    int nMenuPos; // the position to insert menu;

    nMenuPos = GetMenuItemCount(m_hSubMenu);
    MYDBGASSERT(nMenuPos >= 0);

    //
    // Add seperator
    //
    MYVERIFY(FALSE != InsertMenuU(m_hSubMenu, nMenuPos, MF_BYPOSITION|MF_SEPARATOR, 0, 0));
    nMenuPos++;


    //
    // append menus
    //

    CMultipleString MultipleStr(lpMenuNames);

    while(TRUE)
    {
        const TCHAR* lpMenuName = MultipleStr.GetNextString();

        if (lpMenuName == NULL)
        {
            //
            // No more string
            //
            break;
        }

        LPTSTR lpCmdLine = pIniFile->GPPS(c_pszCmSectionMenuOptions,lpMenuName);

        MYDBGASSERT(lpCmdLine && lpCmdLine[0]);

        if (lpCmdLine[0] == 0)
        {
            //
            // Ignore menu without command line
            //
            CmFree(lpCmdLine);
            continue;
        }

        //
        // Add the command to the menu
        //
        MYVERIFY(FALSE != InsertMenuU(m_hSubMenu, nMenuPos, MF_BYPOSITION|MF_STRING, 
            dwMsgBase + m_CommandArray.GetSize(), lpMenuName));

        nMenuPos++;

        //
        // Add the command to the command array
        //
        m_CommandArray.Add(lpCmdLine);
    }

    CmFree(lpMenuNames);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\utility.cpp ===
//+----------------------------------------------------------------------------
//
// File:     utility.cpp
//
// Module:   CMMON32.EXE
//
// Synopsis: Utility functions for cmmon32.exe.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "cm_misc.h"
#include <stdio.h>
#include "resource.h" 
#include <stdlib.h>

//+----------------------------------------------------------------------------
//
// Function:  FmtNum
//
// Synopsis:  Formats a number according to current locale
//
// Arguments: DWORD dwNum - Number to be formatted
//            LPTSTR pszNum - Buffer to receive formatted output
//            DWORD dwNumSize - Size of buffer
//
// Returns:   Nothing
//
// History:   nickball    Created Header    3/30/98
//
//+----------------------------------------------------------------------------
void FmtNum(DWORD dwNum, LPSTR pszNum, DWORD dwNumSize) 
{
	static BOOL bLocaleInit = FALSE;
	static UINT nDecimalDigits;
	DWORD dwNumLen;
	CHAR szRawNum[MAX_PATH];

	if (!bLocaleInit) 
	{
		int iRes;

		bLocaleInit = TRUE;
		iRes = GetLocaleInfoA(LOCALE_USER_DEFAULT,
							  LOCALE_IDIGITS,
							  szRawNum,
							  (sizeof(szRawNum) / sizeof(CHAR)) - 1);
#ifdef DEBUG
        if (!iRes)
        {
            CMTRACE1(TEXT("FmtNum() GetLocaleInfo() failed, GLE=%u."), GetLastError());
        }
#endif

		nDecimalDigits = (UINT)CmAtolA(szRawNum);
	}
    
    wsprintfA(szRawNum, "%u", dwNum);
	
	GetNumberFormatA(LOCALE_USER_DEFAULT,
					 0,
					 szRawNum,
					 NULL,
					 pszNum,
					 (dwNumSize / sizeof(CHAR)) - 1);

	dwNumLen = lstrlenA(pszNum);
	
    if (nDecimalDigits && (dwNumLen > nDecimalDigits) && !CmIsDigitA(pszNum+dwNumLen - nDecimalDigits - 1)) 
	{
		pszNum[dwNumLen - nDecimalDigits - 1] = 0;
	} 
	else 
	{
        CMTRACE(TEXT("FmtNum() unexpected decimal output."));
		bLocaleInit = FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmpbk\ccsv.h ===
//+----------------------------------------------------------------------------
//
// File:     ccsv.h
//
// Module:   CMPBK32.DLL
//
// Synopsis: Definition of the CCSVFile class.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------
#ifndef _CCSV_INC_
#define _CCSV_INC_

#define CCSVFILE_BUFFER_SIZE 2*512

// simple file i/o for phone books
class CCSVFile 
{
	
	public:

		CCSVFile();
		~CCSVFile();
		BOOLEAN Open(LPCSTR pszFileName);
		BOOLEAN ReadToken(char *pszDest, DWORD cbMax);	// reads up to comma or newline, returns fFalse on EOF
		BOOL ClearNewLines(void); // reads through newlines, returns FALSE on EOF
		BOOL ReadError(void);	  // true if last read failed
		void Close(void);

	private:
		BOOL	m_fReadFail;
		BOOL    m_fUseLastRead;
		BOOL 	FReadInBuffer(void);
		inline WORD	ChNext(void);
		char 	m_rgchBuf[CCSVFILE_BUFFER_SIZE]; //buffer
		char 	*m_pchBuf;			//pointer to the next item in the buffer to read
		char	*m_pchLast;			//pointer to the last item in the buffer
		char  	m_chLastRead;		//the character last read.  HIBYTE=err code, LOBYTE=char
		DWORD 	m_cchAvail;
		HANDLE 	m_hFile;

}; // ccsv
#endif //_CCSV_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmmon\watchprocess.h ===
//+----------------------------------------------------------------------------
//
// File:     watchprocess.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Header and Implementation for the CWatchProcessList class.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------

#include "ArrayPtr.h"

//+---------------------------------------------------------------------------
//
//	class CWatchProcessList
//
//	Description: Manage to list of process handle. 
//               Tell whether all the processes are terminated
//
//	History:	fengsun	Created		10/30/97
//
//----------------------------------------------------------------------------

class CWatchProcessList
{
public:
    CWatchProcessList();
    ~CWatchProcessList();

    BOOL IsIdle();
    void Add(HANDLE hProcess);
    void SetNotIdle() {m_fProcessAdded = FALSE;};
    DWORD GetSize() const {return m_ProcessArray.GetSize();} 
    HANDLE GetProcess(int i) {return m_ProcessArray[i];}

protected:

    // an array of process handle
    CPtrArray m_ProcessArray;
    BOOL m_fProcessAdded;
};

inline CWatchProcessList::CWatchProcessList()
{
    m_fProcessAdded = FALSE;
}

inline CWatchProcessList::~CWatchProcessList()
{
    for (int i=m_ProcessArray.GetSize()-1; i>=0; i--)
    {
	    CloseHandle((HANDLE)m_ProcessArray[i]);
    }
}

inline BOOL CWatchProcessList::IsIdle()
{
    if (!m_fProcessAdded)
    {
        return FALSE;
    }
    
    for (int i=m_ProcessArray.GetSize()-1; i>=0; i--)
    {
        DWORD dwExitCode;

		BOOL bRes = GetExitCodeProcess((HANDLE)m_ProcessArray[i],&dwExitCode);

		if (!bRes || (dwExitCode != STILL_ACTIVE)) 
		{
			CloseHandle((HANDLE)m_ProcessArray[i]);
            m_ProcessArray.RemoveAt(i);
		}
    }

    return m_ProcessArray.GetSize() == 0;
}
    
inline void CWatchProcessList::Add(HANDLE hProcess)
{
    //
    // CMDIAL calls DuplicateHandle to get the hProcess
    // CmMon is responsible to close the handle
    //

    MYDBGASSERT(hProcess);

    //
    // It is possible the auto application exited before this function is called
    //
    m_fProcessAdded = TRUE;
    
	if (hProcess) 
    {
		m_ProcessArray.Add(hProcess);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmpbk\ccsv.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ccsv.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Implementation of the class CCSVFile.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

// ############################################################################
// INCLUDES
#include "cmmaster.h"

// ############################################################################
// DEFINES
#define chComma ','
#define chNewline '\n'
#define chReturn '\r'
#define chSpace ' '

// ############################################################################
//
// CCSVFile - simple file i/o for CSV files
//
CCSVFile::CCSVFile()
{
	m_hFile = INVALID_HANDLE_VALUE;
	m_chLastRead = 0;
	m_pchLast = m_pchBuf = NULL;
	m_fReadFail = FALSE;
	m_fUseLastRead = FALSE;
}

// ############################################################################
CCSVFile::~CCSVFile()
{
	CMASSERTMSG(m_hFile==INVALID_HANDLE_VALUE,"CCSV file is still open");
}

// ############################################################################
BOOLEAN CCSVFile::Open(LPCSTR pszFileName)
{
	CMASSERTMSG(m_hFile==INVALID_HANDLE_VALUE, "a file is already open.");
	
	m_hFile = CreateFile((LPCTSTR) pszFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
	if (INVALID_HANDLE_VALUE == m_hFile)
	{
		return FALSE;
	}
	m_pchLast = m_pchBuf = NULL;
	return TRUE;
}

// ############################################################################
BOOL CCSVFile::ClearNewLines(void)
{
	//
	// This routine is designed to eat characters until a non-newline char or 
	// the end-of-file is encountered. If a non-newline char is encountered, 
	// the fUseLast flag is set to ensure that the next call to ChNext will 
	// return the correct current character.
	//

	char ch = chNewline;
    WORD wRet;
    BYTE bErr;

	//
	// eat leading newlines
	//

	while (chNewline == ch)
	{
        //
        // eat the leading space first
        //
        do 
        {
            wRet = ChNext();
        } while ((wRet == chSpace) || (wRet == TEXT('\t')));

        bErr = HIBYTE(wRet);
        ch = LOBYTE(wRet);

		// if EOF return false
		
		if (0xff == bErr)
		{
	    	return FALSE;
		}
	}

	//
	// we hit a character other than newline, use current char as next.
	//

	m_fUseLastRead = TRUE;

	return TRUE;
}

// ############################################################################
BOOLEAN CCSVFile::ReadToken(char *psz, DWORD cbMax)
{
	char 	*pszOrig = psz;
	DWORD 	dwLen = 0;
	char	ch;
    BYTE    bErr = 0xff;
    WORD    wRet;

	wRet = ChNext();
    bErr = HIBYTE(wRet);
    ch = LOBYTE(wRet);

	if (0xff == bErr)
	{
		return FALSE;
	}

	// read chars until we hit a comma, newline, or run out of file

	while (dwLen < cbMax - 1 && chComma != ch && chNewline != ch && 0xff != bErr)
	{
		*psz++ = ch;

		wRet = ChNext(); //Read in the next character
        bErr = HIBYTE(wRet);
        ch = LOBYTE(wRet);

		dwLen++;
	}

	*psz++ = '\0';
	
	// eat leading spaces

	while (*pszOrig == chSpace) 
	{
		lstrcpy(pszOrig,pszOrig+1);
	}

	psz = pszOrig + lstrlen(pszOrig);

	// eat trailing spaces

	while ((psz != pszOrig) && (*(psz-1) == chSpace)) 
	{
		psz--;
		*psz = 0;
	}

	return TRUE;
}

// ############################################################################
void CCSVFile::Close(void)
{
	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hFile);
	}

#ifdef DEBUG
	
	if (m_hFile==INVALID_HANDLE_VALUE) 
	{
		CMTRACE("CCSVFile::Close was called, but m_hFile was already INVALID_HANDLE_VALUE\n");
	}

#endif

	m_hFile = INVALID_HANDLE_VALUE;
}

// ############################################################################
BOOL CCSVFile::ReadError(void)
{
	return (m_fReadFail);
}

// ############################################################################
BOOL CCSVFile::FReadInBuffer(void)
{
	//Read another buffer
	if (!ReadFile(m_hFile, m_rgchBuf, CCSVFILE_BUFFER_SIZE, &m_cchAvail, NULL) || !m_cchAvail)
	{
		m_fReadFail = TRUE;
		return FALSE;	 //nothing more to read
	}

	m_pchBuf = m_rgchBuf;
	m_pchLast = m_pchBuf + m_cchAvail;
	
	return TRUE; //success
}

// ############################################################################
inline WORD CCSVFile::ChNext(void)
{
	//
	// If the fUseLastRead flag is set, clear the 
	// flag and use the existing m_chLastRead 
	//
	
	if (m_fUseLastRead)
	{
		m_fUseLastRead = FALSE;	
	}
	else
	{
		//
		// Get the next char in the buffer. Load new buffer if necessary.
		//

LNextChar:

		if (m_pchBuf >= m_pchLast && !FReadInBuffer())  //implies that we finished reading the buffer. Read in some more.
		{
			return MAKEWORD(0, 0xff);	 //nothing more to read
		}

		m_chLastRead = *m_pchBuf++;
		
		//
		// If its a carriage return, read another char
		//

		if (chReturn == m_chLastRead)
		{
			goto LNextChar;		//faster to NOT make extra function call
		}
	}

	return MAKEWORD(m_chLastRead, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmpbk\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h
//
// Module:   CMPBK32.DLL
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include <windows.h>
#include <windowsx.h>
#include <tapi.h>
#include <ras.h>
#include <raserror.h>
#include <tchar.h>

#include "cmutil.h"
#include "cm_phbk.h"
#include "ccsv.h"
#include "phbk.h"
#include "misc.h"
#include "cm_misc.h"
#include "pbk_str.h"
#include "cmdebug.h"

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmpbk\bsearch.cpp ===
//+----------------------------------------------------------------------------
//
// File:     bsearch.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Binary search implementation
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

/***
*char *bsearch() - do a binary search on an array
*
*Purpose:
*       Does a binary search of a sorted array for a key.
*
*Entry:
*       const char *key    - key to search for
*       const char *base   - base of sorted array to search
*       unsigned int num   - number of elements in array
*       unsigned int width - number of bytes per element
*       int (*compare)()   - pointer to function that compares two array
*               elements, returning neg when #1 < #2, pos when #1 > #2, and
*               0 when they are equal. Function is passed pointers to two
*               array elements.
*
*Exit:
*       if key is found:
*               returns pointer to occurrence of key in array
*       if key is not found:
*               returns NULL
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl CmBSearch (
        REG4 const void *key,
        const void *base,
        size_t num,
        size_t width,
        int (__cdecl *compare)(const void *, const void *)
        )
{
        REG1 char *lo = (char *)base;
        REG2 char *hi = (char *)base + (num - 1) * width;
        REG3 char *mid;
        unsigned int half;
        int result;

        while (lo <= hi)
                if (half = num / 2)
                {
                        mid = lo + (num & 1 ? half : (half - 1)) * width;
                        if (!(result = (*compare)(key,mid)))
                                return(mid);
                        else if (result < 0)
                        {
                                hi = mid - width;
                                num = num & 1 ? half : half-1;
                        }
                        else    {
                                lo = mid + width;
                                num = half;
                        }
                }
                else if (num)
                        return((*compare)(key,lo) ? NULL : lo);
                else
                        break;

        return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmpbk\cm_misc.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cm_misc.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Miscellaneous functions.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

// ############################################################################
// INCLUDES

#include "cmmaster.h"

HINSTANCE g_hInst;

#if 0
/*
int MyStrICmpWithRes(HINSTANCE hInst, LPCTSTR psz1, UINT n2) {
	LPTSTR psz2;
	int iRes;

	if (!psz1) {
		return (-1);
	}
	if (!2) {
		return (1);
	}
	psz2 = CmLoadString(hInst,n2);
	iRes = lstrcmpi(psz1,psz2);
	CmFree(psz2);
	return (iRes);
}
*/
#endif

//+----------------------------------------------------------------------------
//
// Function:  GetBaseDirFromCms
//
// Synopsis:  Strips the filename part and sub-directiory from the specified 
//            src path which is expected to be a fully qualified path to a .CMS
//
// Arguments: LPCSTR pszSrc - The src path and filename
//
// Returns:   LPTSTR - Ptr to allocated Base Directory name including trailing "\"
//
// History:   nickball    Created    3/8/98
//
//+----------------------------------------------------------------------------
LPTSTR GetBaseDirFromCms(LPCSTR pszSrc)
{
    LPTSTR pszBase = NULL;

    MYDBGASSERT(pszSrc);

    if (NULL == pszSrc || 0 == pszSrc[0])
    {
        return NULL;
    }

    //
    // The source filename should exist 
    //

    HANDLE hFile = CreateFile(pszSrc, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
	                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    

    if (INVALID_HANDLE_VALUE == hFile)
    {
        MYDBGASSERT(FALSE); 
        return NULL;    
    }

    CloseHandle(hFile);

    //
    // File name is good allocate a buffer to work with
    //
    LPTSTR pszSlash = NULL;
    pszBase = (LPTSTR) CmMalloc((_tcslen(pszSrc) +1)*sizeof(TCHAR));

    if (pszBase)
    {
        _tcscpy(pszBase, pszSrc);

        pszSlash = CmStrrchr(pszBase,TEXT('\\'));

        if (!pszSlash)
        {
            MYDBGASSERT(FALSE); // should be a full path
            CmFree(pszBase);
            return NULL;
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("GetBaseDirFromCms -- Unable to allocate pszBase."));
        return NULL;	
    }

    //
    // Null terminate at slash and find next
    //

    *pszSlash = TEXT('\0');                                    
    pszSlash = CmStrrchr(pszBase,TEXT('\\'));

    if (!pszSlash)
    {
        MYDBGASSERT(FALSE); // should be a full path
        CmFree(pszBase);
        return NULL;
    }

    //
    // Null terminate at slash again and we're done
    //

//    pszSlash = _tcsinc(pszSlash);
    *pszSlash = TEXT('\0');                         

    return pszBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmpbk\cm_misc.h ===
//+----------------------------------------------------------------------------
//
// File:     cm_misc.h
//
// Module:   CMPBK32.DLL
//
// Synopsis: Miscellaneous function definitions.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------
#ifndef _CM_MISC_INC
#define _CM_MISC_INC


//+----------------------------------------------------------------------------
// defines
//+----------------------------------------------------------------------------

//
// the register stuff is from libc(cruntime.h)
//
#ifdef _M_IX86
/*
 * x86
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4

#else
/*
 * ALPHA
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4    register
#endif

int MyStrCmp(LPCTSTR psz1, LPCTSTR psz2);

//int MyStrICmpWithRes(HINSTANCE hInst, LPCTSTR psz1, UINT n2);

LPTSTR GetBaseDirFromCms(LPCSTR pszSrc);

void * __cdecl CmBSearch (
    REG4 const void *key,
    const void *base,
    size_t num,
    size_t width,
    int (__cdecl *compare)(const void *, const void *)
);

void __cdecl CmQSort (
    void *base,
    unsigned num,
    unsigned width,
    int (__cdecl *comp)(const void *, const void *)
);

//+----------------------------------------------------------------------------
// externs
//+----------------------------------------------------------------------------
extern HINSTANCE g_hInst;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmpbk\cm_phbk.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cm_phbk.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Implementation of the Private CM Phone book API.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

// ############################################################################
// INCLUDES

#include "cmmaster.h"

#include <stddef.h>
#include <limits.h>

//#define DllImport extern "C" __declspec(dllimport)

#define MIN_TAPI_VERSION        0x10004
#define MAX_TAPI_VERSION        0x10004

const TCHAR* const c_pszCmEntryIspFilterMask    = TEXT("Mask&");
const TCHAR* const c_pszCmEntryIspFilterMatch   = TEXT("Match&");
const TCHAR* const c_pszCmSectionServiceTypes   = TEXT("Service Types");
const TCHAR* const c_pszBps                     = TEXT("bps");

#ifndef UNICODE
    
CM_PHBK_DllExportP PhoneBookCopyFilter(PPBFS pFilterIn)
{
    PPBFS pRes;
    DWORD dwSize;

    if (!pFilterIn)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }
    // Undocumented feature (used internally):  always allocates room for one additional pair.
    dwSize = offsetof(PhoneBookFilterStruct,aData) + sizeof(pRes->aData) * (pFilterIn->dwCnt + 1);
    pRes = (PPBFS) CmMalloc((size_t) dwSize);

    if (pRes)
    {
        CopyMemory(pRes,pFilterIn,(size_t) dwSize - sizeof(pRes->aData));
    }

    return pRes;
}


CM_PHBK_DllExportV PhoneBookFreeFilter(PPBFS pFilter)
{
    CmFree(pFilter);
}


CM_PHBK_DllExportB PhoneBookMatchFilter(PPBFS pFilter, DWORD dwValue)
{
    DWORD dwIdx;

    if (!pFilter)
    {
        return FALSE;
    }
    for (dwIdx = 0; dwIdx < pFilter->dwCnt; dwIdx++)
    {
        if ((dwValue & pFilter->aData[dwIdx].dwMask) == pFilter->aData[dwIdx].dwMatch)
        {
            return TRUE;
        }
    }
    return FALSE;
}

static PPBFS GetFilterFromFile(LPCTSTR pszFile, LPCTSTR pszFilter)
{
    LPTSTR pszFilterTmp;
    LPTSTR pszTmp;
    static PhoneBookFilterStruct sInit = {0,{{0,0}}};
    PPBFS pRes;
    CIni iniTmp(g_hInst,pszFile);

    pRes = PhoneBookCopyFilter(&sInit);
    if (!pRes)
    {
        return NULL;
    }
    pszFilterTmp = CmStrCpyAlloc(pszFilter);
    pszTmp = CmStrtok(pszFilterTmp,TEXT(" \t,"));
    while (pszTmp)
    {
        iniTmp.SetEntry(pszTmp);
        pRes->aData[pRes->dwCnt].dwMask = iniTmp.GPPI(c_pszCmSectionIsp,c_pszCmEntryIspFilterMask,0x00000000);
        pRes->aData[pRes->dwCnt].dwMatch = iniTmp.GPPI(c_pszCmSectionIsp,c_pszCmEntryIspFilterMatch,0xffffffff);
        pRes->dwCnt++;
        pszTmp = CmStrtok(NULL,TEXT(" \t,"));
        if (pszTmp)
        {
            PPBFS pResTmp;

            pResTmp = PhoneBookCopyFilter(pRes);
            PhoneBookFreeFilter(pRes);
            pRes = pResTmp;
            if (!pRes)
            {
                CmFree(pszFilterTmp);
                return NULL;
            }
        }
    }

    CmFree(pszFilterTmp);
    return pRes;
}


CM_PHBK_DllExportB PhoneBookParseInfoA(LPCSTR pszFile, PhoneBookParseInfoStructA *pInfo)
{
    CIni iniFile(g_hInst,(LPCTSTR) pszFile);
    LPTSTR pszTmp;

    if (!pszFile || !pInfo || pInfo->dwSize != sizeof(*pInfo)) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    pszTmp = iniFile.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspUrl);
    if (pInfo->pszURL && ((DWORD) lstrlen(pszTmp) >= pInfo->dwURL)) 
    {
        pInfo->dwURL = lstrlen(pszTmp) + 1;
        CmFree(pszTmp);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    
    pInfo->dwURL = lstrlen(pszTmp) + 1;
    if (pInfo->pszURL) 
    {
        lstrcpy(pInfo->pszURL,pszTmp);
    }
    CmFree(pszTmp);
    pszTmp = iniFile.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspFilterA);

    pInfo->pFilterA = GetFilterFromFile((LPCTSTR) pszFile,pszTmp);
    CmFree(pszTmp);
    pszTmp = iniFile.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspFilterB);
    pInfo->pFilterB = GetFilterFromFile((LPCTSTR) pszFile,pszTmp);

    CmFree(pszTmp);
    if (pInfo->pfnSvc) 
    {
        LPTSTR pszSvc;

        pszTmp = iniFile.GPPS(c_pszCmSectionServiceTypes,(LPTSTR) NULL);
        pszSvc = pszTmp;
        while (*pszSvc) 
        {
            LPTSTR pszFilter;
            PPBFS pFilter;

            pszFilter = iniFile.GPPS(c_pszCmSectionServiceTypes,pszSvc);

            pFilter = GetFilterFromFile((LPCTSTR) pszFile,pszFilter);
            CmFree(pszFilter);
            if (!pInfo->pfnSvc(pszSvc,pFilter,pInfo->dwSvcParam)) 
            {
                break;
            }
            pszSvc += lstrlen(pszSvc) + 1;
        }
        CmFree(pszTmp);
    }
    
    if (pInfo->pfnRef) 
    {
        LPTSTR pszRef,pszNext;
        CIni iniRef(g_hInst);

        pszTmp = iniFile.GPPS(c_pszCmSectionIsp, c_pszCmEntryIspReferences);
        pszRef = NULL;
        pszNext = pszTmp;

        while (1) 
        {
            LPTSTR pszURL;
            LPTSTR pszRefTmp;
            PPBFS pFilterA;
            PPBFS pFilterB;

            //
            // Parse out reference list
            //

            pszRef = CmStrtok(pszNext,TEXT(" \t,"));
            if (pszRef)
            {
                pszNext = pszRef + lstrlen(pszRef)+1; // CHECK FOR MBCS COMPATIBLITY
            }

            if (!pszRef) 
            {
                break;
            }
            
            //
            // Setup ini file and paths for this reference
            //

            iniFile.SetEntry(pszRef);

            LPTSTR pszRefFile = (LPTSTR) CmMalloc(MAX_PATH+1);
            LPTSTR pszBasePath = GetBaseDirFromCms(pszFile);
            LPTSTR pszPhoneFile = (LPTSTR) CmMalloc(MAX_PATH+1);
                       
            pszRefTmp = iniFile.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspCmsFile);
                
            //
            //  Make sure we have a full path to the .CMS
            //

            if (pszRefTmp && *pszRefTmp && pszRefFile && pszPhoneFile && pszBasePath)
            {
                LPTSTR pszTemp = NULL;               

                if (SearchPath(pszBasePath, pszRefTmp, NULL, MAX_PATH, pszRefFile, &pszTemp))
                {
                    iniRef.SetFile(pszRefFile);
                }

                CmFree(pszRefTmp);

                //
                // Verify that phone books for this reference exists.
                //
                
                pszRefTmp = iniRef.GPPS(c_pszCmSectionIsp, c_pszCmEntryIspPbFile);                         

                //
                // If there is a phonebook file name in the .CMS, use 
                // it to construct a full path to the PhoneBook file.
                //

                if (*pszRefTmp)
                {                                       
                    lstrcpy(pszPhoneFile, pszBasePath);
                    lstrcat(pszPhoneFile, TEXT("\\"));
                    lstrcat(pszPhoneFile, pszRefTmp);                   
                }
                else
                {
                    *pszPhoneFile = 0; 
                }

                CmFree(pszRefTmp);

                //
                // If we have a name, see if the file exists
                //

                if (*pszPhoneFile) 
                {
                    HANDLE hFile = CreateFile(pszPhoneFile, 0,  
                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        NULL, OPEN_EXISTING, 
                                        FILE_ATTRIBUTE_NORMAL, NULL);                    
                    //
                    // If the file does not exist, we create an empty one
                    //

                    if (INVALID_HANDLE_VALUE == hFile)
                    {                
                        hFile = CreateFile(pszPhoneFile,
                                    GENERIC_READ|GENERIC_WRITE, 0,
                                    (LPSECURITY_ATTRIBUTES)NULL,
                                    CREATE_NEW, FILE_ATTRIBUTE_NORMAL,
                                    NULL);

                        if (INVALID_HANDLE_VALUE == hFile)
                        {
                            //
                            // If for some reason we failed to create the file,
                            // we skip this reference pbk.
                            //

                            CmFree(pszBasePath);
                            CmFree(pszPhoneFile);
                            CmFree(pszRefFile);
                            continue;
                        }

                        CloseHandle(hFile);
                    }
                    else
                    {
                        CloseHandle(hFile);
                    }
                }

                //
                // We have a file, get the URL and the filters
                //

                pszRefTmp = iniFile.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspUrl);
                pszURL = iniRef.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspUrl,pszRefTmp);
                CmFree(pszRefTmp);

                pszRefTmp = iniFile.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspFilterA);
                pFilterA = GetFilterFromFile(iniFile.GetFile(),pszRefTmp);
                CmFree(pszRefTmp);

                pszRefTmp = iniFile.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspFilterB);
                pFilterB = GetFilterFromFile(iniFile.GetFile(),pszRefTmp);
                CmFree(pszRefTmp);
                pszRefTmp = NULL;

                pInfo->pfnRef(pszRefFile,pszURL,pFilterA,pFilterB,pInfo->dwRefParam);
                
                PhoneBookFreeFilter(pFilterA);
                PhoneBookFreeFilter(pFilterB);
                CmFree(pszURL);
            } 
            
            //
            // Cleanup
            //
            CmFree(pszRefTmp);
            CmFree(pszRefFile);
            CmFree(pszPhoneFile);
            CmFree(pszBasePath);
        }
        CmFree(pszTmp);
    }
    return TRUE;
}

CM_PHBK_DllExportV PhoneBookEnumCountries(DWORD_PTR dwPB,
                                          PhoneBookCallBack pfnCountry,
                                          PPBFS pFilter,
                                          DWORD_PTR dwParam)
{
    ((CPhoneBook *) dwPB)->EnumCountries(pFilter,pfnCountry,dwParam);
}


//
//  Note: this function and its mirror function PhoneBookGetStringW must stay in sync
//
static BOOL PhoneBookGetStringA(LPCSTR pszSrc, LPSTR pszDest, DWORD *pdwDest)
{
    DWORD dwTmp = lstrlen(pszSrc);

    if (dwTmp > *pdwDest)
    {
        *pdwDest = dwTmp;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    lstrcpy(pszDest,pszSrc);
    *pdwDest = dwTmp;
    return TRUE;
}

//
//  Note: this function and its mirror function PhoneBookGetStringA must stay in sync
//
static BOOL PhoneBookGetStringW(LPCWSTR pszSrc, LPWSTR pszDest, DWORD *pdwDest)
{
    DWORD dwTmp = lstrlenW(pszSrc);

    if (dwTmp > *pdwDest)
    {
        *pdwDest = dwTmp;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    lstrcpyW(pszDest,pszSrc);
    *pdwDest = dwTmp;
    return TRUE;
}



CM_PHBK_DllExportB PhoneBookGetCountryNameA(DWORD_PTR dwPB, unsigned int nIdx, LPSTR pszCountryName, DWORD *pdwCountryName)
{
    return (PhoneBookGetStringA(((CPhoneBook *) dwPB)->GetCountryNameByIdx(nIdx),pszCountryName,pdwCountryName));
}

CM_PHBK_DllExportB PhoneBookGetCountryNameW(DWORD_PTR dwPB, unsigned int nIdx, LPWSTR pszCountryName, DWORD *pdwCountryName)
{
    return (PhoneBookGetStringW(((CPhoneBook *) dwPB)->GetCountryNameByIdxW(nIdx),pszCountryName,pdwCountryName));
}

CM_PHBK_DllExportD PhoneBookGetCountryId(DWORD_PTR dwPB, unsigned int nIdx)
{
    return (((CPhoneBook *) dwPB)->GetCountryIDByIdx(nIdx));
}

CM_PHBK_DllExportB PhoneBookHasPhoneType(DWORD_PTR dwPB, PPBFS pFilter)
{
    return ((CPhoneBook *) dwPB)->FHasPhoneType(pFilter);
}

CM_PHBK_DllExportV PhoneBookEnumRegions(DWORD_PTR dwPB,
                                        PhoneBookCallBack pfnRegion,
                                        DWORD dwCountryID,
                                        PPBFS pFilter,
                                        DWORD_PTR dwParam)
{
    ((CPhoneBook *) dwPB)->EnumRegions(dwCountryID,pFilter,pfnRegion,dwParam);
}


CM_PHBK_DllExportB PhoneBookGetRegionNameA(DWORD_PTR dwPB,
                                           unsigned int nIdx,
                                           LPSTR pszRegionName,
                                           DWORD *pdwRegionName)
{
    return (PhoneBookGetStringA(((CPhoneBook *) dwPB)->GetRegionNameByIdx(nIdx),pszRegionName,pdwRegionName));
}


CM_PHBK_DllExportB PhoneBookGetPhoneCanonicalA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszPhoneNumber, DWORD *pdwPhoneNumber)
{
    char szTmp[64] = {0};

    ((CPhoneBook *) dwPB)->GetCanonical(dwIdx,szTmp);
    return (PhoneBookGetStringA(szTmp,pszPhoneNumber,pdwPhoneNumber));
}

CM_PHBK_DllExportB PhoneBookGetPhoneNonCanonicalA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszPhoneNumber, DWORD *pdwPhoneNumber)
{
    char szTmp[64] = {0};

    ((CPhoneBook *) dwPB)->GetNonCanonical(dwIdx,szTmp);
    return (PhoneBookGetStringA(szTmp,pszPhoneNumber,pdwPhoneNumber));
}

CM_PHBK_DllExportD PhoneBookGetPhoneType(DWORD_PTR dwPB, unsigned int nIdx)
{
    return (((CPhoneBook *) dwPB)->GetPhoneTypeByIdx(nIdx));
}


CM_PHBK_DllExportV PhoneBookEnumNumbers(DWORD_PTR dwPB,
                                        PhoneBookCallBack pfnNumber,
                                        DWORD dwCountryID,
                                        unsigned int nRegion,
                                        PPBFS pFilter,
                                        DWORD_PTR dwParam)
{
    if (nRegion != UINT_MAX)
    {
        ((CPhoneBook *) dwPB)->EnumNumbersByRegion(nRegion,dwCountryID,pFilter,pfnNumber,dwParam);
    }
    else
    {
        ((CPhoneBook *) dwPB)->EnumNumbersByCountry(dwCountryID,pFilter,pfnNumber,dwParam);
    }
}


CM_PHBK_DllExportV PhoneBookEnumNumbersWithRegionsZero(DWORD_PTR dwPB,
                                                       PhoneBookCallBack pfnNumber,
                                                       DWORD dwCountryID,
                                                       PPBFS pFilter,
                                                       DWORD_PTR dwParam) 
{
    ((CPhoneBook *) dwPB)->EnumNumbersByRegion(UINT_MAX, 
                                               dwCountryID, 
                                               pFilter,
                                               pfnNumber,
                                               dwParam);
}


//+---------------------------------------------------------------------------
//
// Function  static GetPhoneBaudDesc()
//
// Description:
//      Get the phone baudrate discription in " (BaudMin - BaudMax bps)" format
//
// Arguments:
//      IN CPhoneBook* pPB:  Pointer to phone book
//      DWORD dwIdx: Index for PhoneBook.m_rgPhoneBookEntry[] 
//      OUT LPTSTR pszBaudDisp: Hold output text, should have enough space to hold the output
//
//+---------------------------------------------------------------------------

static void GetPhoneBaudDesc(IN CPhoneBook* pPB, DWORD dwIdx, OUT LPTSTR pszBaudDisp)
{
    MYDBGASSERT(pPB != NULL);
    MYDBGASSERT(pszBaudDisp != NULL);

    DWORD dwMinBaud = pPB->GetMinBaudByIdx(dwIdx);
    DWORD dwMaxBaud = pPB->GetMaxBaudByIdx(dwIdx);

    if (dwMinBaud == 0 && dwMaxBaud == 0)
    {
        //
        // If both dwMinBaud and dwMaxBaud are 0, we are done
        //
        pszBaudDisp[0] = 0;
    }
    else
    {
        //
        // If the min/max baud are identical
        // don't bother displaying as a range, just display the number 400: (400 bps)
        //

        if (dwMinBaud == dwMaxBaud)
            wsprintf(pszBaudDisp, " (%lu %s)", dwMaxBaud, c_pszBps); //  " (Baud bps)"
        else if (dwMinBaud == 0)
            wsprintf(pszBaudDisp, " (1-%lu %s)", dwMaxBaud, c_pszBps); //  " (1-dwMaxBaud bps)"
        else if (dwMaxBaud == 0)
            wsprintf(pszBaudDisp, " (%lu+  %s)", dwMinBaud, c_pszBps);  //  " (dwMinBaud+  bps)"
        else
            wsprintf(pszBaudDisp, " (%lu-%lu %s)", dwMinBaud, dwMaxBaud, c_pszBps);  //  " (dwMinBaud-dwMaxBaud bps)"
    }
}


//+---------------------------------------------------------------------------
//
// Function PhoneBookGetPhoneDispA()
//
// Description:
//      Format the phone discription text form phonebook dwPB and index dwIndx
//          "City (AreaCode) AccessNumber (MinBaud-MaxBaud bps)"
//
// Arguments:
//      DWORD_PTR dwPB:  Pointer to phone book
//      DWORD dwIdx: Index for PhoneBook.m_rgPhoneBookEntry[] 
//      LPTSTR pszDisp: ???
//      DWORD *pdwDisp: ???
//
// Return: ???
//
//+---------------------------------------------------------------------------

CM_PHBK_DllExportB PhoneBookGetPhoneDispA(DWORD_PTR dwPB, DWORD dwIdx, LPTSTR pszDisp, DWORD *pdwDisp) 
{
    CPhoneBook *pPB = (CPhoneBook *) dwPB;
    TCHAR szTmp[256];

    MYDBGASSERT(pPB != NULL);

    //
    // If AreaCode is not empty then format is "City (AreaCode) AccessNumber" ...
    //
    if (pPB->GetAreaCodeByIdx(dwIdx)[0] != '\0')
    {
        wsprintf(szTmp,
                 "%s (%s) %s",
                 pPB->GetCityNameByIdx(dwIdx),
                 pPB->GetAreaCodeByIdx(dwIdx),
                 pPB->GetAccessNumberByIdx(dwIdx));
    }
    else 
    {
        //
        // Otherwise, AreaCode is empty, format is "City AccessNumber" ...
        //
        wsprintf(szTmp,
                 "%s %s",
                 pPB->GetCityNameByIdx(dwIdx),
                 pPB->GetAccessNumberByIdx(dwIdx));
    }

    //
    // Get the "(BaudMin-BaudMax bps)" text
    //
    TCHAR szBaudStr[64];
    GetPhoneBaudDesc(pPB, dwIdx, szBaudStr);

    lstrcat(szTmp, szBaudStr);

    return (PhoneBookGetStringA(szTmp,pszDisp,pdwDisp));
}


//+---------------------------------------------------------------------------
//
// PhoneBookGetPhoneDescA()
//
// Description:
//      Format part of the phone discription text form phonebook dwPB and index dwIndx
//          "City (MinBaud-MaxBaud bps)"
//
// Arguments:
//      DWORD_PTR dwPB:  Pointer to phone book
//      DWORD dwIdx: Index for PhoneBook.m_rgPhoneBookEntry[] 
//      LPTSTR pszDisp: ???
//      DWORD *pdwDisp: ???
//
// Return: ???
//
//+---------------------------------------------------------------------------

CM_PHBK_DllExportB PhoneBookGetPhoneDescA(DWORD_PTR dwPB, DWORD dwIdx, LPTSTR pszDesc, DWORD *pdwDesc) 
{
    CPhoneBook *pPB = (CPhoneBook *) dwPB;
    TCHAR szTmp[256];

    lstrcpy(szTmp, pPB->GetCityNameByIdx(dwIdx));

    //
    // Get the "(BaudMin-BaudMax bps)" text
    //
    TCHAR szBaudStr[64];
    GetPhoneBaudDesc(pPB, dwIdx, szBaudStr);

    lstrcat(szTmp, szBaudStr);

    return (PhoneBookGetStringA(szTmp,pszDesc,pdwDesc));
}


VOID FAR PASCAL CMPB_LineCallback(DWORD hDevice,
                                  DWORD dwMsg,
                                  DWORD dwCallbackInstance,
                                  DWORD dwParam1,
                                  DWORD dwParam2,
                                  DWORD dwParam3)
{

    // nothing
}


static LPVOID GetTapiPfn(HINSTANCE *phInst, LPCTSTR pszFn)
{
    LPVOID pvRes = NULL;

    *phInst = LoadLibrary(TEXT("tapi32"));

    if (*phInst)
    {
        pvRes = GetProcAddress(*phInst,pszFn);
        if (pvRes)
        {
            return pvRes;
        }
        FreeLibrary(*phInst);
    }
    return NULL;
}


static LONG PBlineInitialize(LPHLINEAPP lphLineApp,
                             HINSTANCE hInstance,
                             LINECALLBACK lpfnCallback,
                             LPCSTR lpszAppName,
                             LPDWORD lpdwNumDevs)
{
    HINSTANCE hInst;
    LONG (WINAPI *pfn)(LPHLINEAPP,HINSTANCE,LINECALLBACK,LPCSTR,LPDWORD);
    LONG lRes;

    pfn = (LONG (WINAPI *)(LPHLINEAPP,HINSTANCE,LINECALLBACK,LPCSTR,LPDWORD)) GetTapiPfn(&hInst,"lineInitialize");
    if (!pfn)
    {
        return LINEERR_NOMEM;
    }
    lRes = pfn(lphLineApp,hInstance,lpfnCallback,lpszAppName,lpdwNumDevs);
    FreeLibrary(hInst);
    return lRes;
}


static LONG PBlineNegotiateAPIVersion(HLINEAPP hLineApp,
                                      DWORD dwDeviceID,
                                      DWORD dwAPILowVersion,
                                      DWORD dwAPIHighVersion,
                                      LPDWORD lpdwAPIVersion,
                                      LPLINEEXTENSIONID lpExtensionID)
{
    HINSTANCE hInst;
    LONG (WINAPI *pfn)(HLINEAPP,DWORD,DWORD,DWORD,LPDWORD,LPLINEEXTENSIONID);
    LONG lRes;

    pfn = (LONG (WINAPI *)(HLINEAPP,DWORD,DWORD,DWORD,LPDWORD,LPLINEEXTENSIONID)) GetTapiPfn(&hInst,"lineNegotiateAPIVersion");
    if (!pfn)
    {
        return LINEERR_NOMEM;
    }
    lRes = pfn(hLineApp,dwDeviceID,dwAPILowVersion,dwAPIHighVersion,lpdwAPIVersion,lpExtensionID);
    FreeLibrary(hInst);
    return lRes;
}


static LONG PBlineGetTranslateCaps(HLINEAPP hLineApp, DWORD dwAPIVersion, LPLINETRANSLATECAPS lpTranslateCaps)
{
    HINSTANCE hInst;
    LONG (WINAPI *pfn)(HLINEAPP,DWORD,LPLINETRANSLATECAPS);
    LONG lRes;

    pfn = (LONG (WINAPI *)(HLINEAPP,DWORD,LPLINETRANSLATECAPS)) GetTapiPfn(&hInst,"lineGetTranslateCaps");
    if (!pfn)
    {
        return LINEERR_NOMEM;
    }
    lRes = pfn(hLineApp,dwAPIVersion,lpTranslateCaps);
    FreeLibrary(hInst);
    return lRes;
}


static LONG PBlineShutdown(HLINEAPP hLineApp)
{
    HINSTANCE hInst;
    LONG (WINAPI *pfn)(HLINEAPP);
    LONG lRes;

    pfn = (LONG (WINAPI *)(HLINEAPP)) GetTapiPfn(&hInst,"lineShutdown");
    if (!pfn)
    {
        return LINEERR_NOMEM;
    }
    lRes = pfn(hLineApp);
    FreeLibrary(hInst);
    return lRes;
}


static DWORD PhoneBookGetCurrentCountryIdAndCode(LPDWORD pdwCountryCode)
{
    HLINEAPP hLine = NULL;
    DWORD dwCountry = 1;
    DWORD dwCountryCode = 1;
    DWORD dwDevices;
    LPLINETRANSLATECAPS pTC = NULL;
    LPLINELOCATIONENTRY plle;
    DWORD dwAPI;

    PBlineInitialize(&hLine,g_hInst,CMPB_LineCallback,NULL,&dwDevices);
    if (!hLine)
    {
        goto done;
    }
    while (dwDevices)
    {
        LINEEXTENSIONID leid;

        if (PBlineNegotiateAPIVersion(hLine,dwDevices-1,0x00010004,0x00010004,&dwAPI,&leid) == ERROR_SUCCESS)
        {
            break;
        }
        dwDevices--;
    }
    if (!dwDevices)
    {
        goto done;
    }
    dwDevices--;
    pTC = (LPLINETRANSLATECAPS) CmMalloc(sizeof(LINETRANSLATECAPS));

    if (NULL == pTC)
    {
        goto done;
    }

    pTC->dwTotalSize = sizeof(LINETRANSLATECAPS);
    if (PBlineGetTranslateCaps(hLine,dwAPI,pTC) != ERROR_SUCCESS)
    {
        goto done;
    }
    dwCountry = pTC->dwNeededSize;
    CmFree(pTC);
    pTC = (LPLINETRANSLATECAPS) CmMalloc((size_t) dwCountry);

    if (NULL == pTC)
    {
        goto done;
    }

    pTC->dwTotalSize = dwCountry;
    dwCountry = 1;
    if (PBlineGetTranslateCaps(hLine,dwAPI,pTC) != ERROR_SUCCESS)
    {
        goto done;
    }
    plle = (LPLINELOCATIONENTRY) (((LPBYTE) pTC) + pTC->dwLocationListOffset);
    for (dwDevices=0;dwDevices<pTC->dwNumLocations;dwDevices++,plle++)
    {
        if (pTC->dwCurrentLocationID == plle->dwPermanentLocationID)
        {
            dwCountry = plle->dwCountryID;
            dwCountryCode = plle->dwCountryCode;
            break;
        }
    }
done:
    if (hLine)
    {
        PBlineShutdown(hLine);
    }
    CmFree(pTC);
    if (pdwCountryCode)
    {
        *pdwCountryCode = dwCountryCode;
    }
    return dwCountry;
}


CM_PHBK_DllExportD PhoneBookGetCurrentCountryId()
{
    return (PhoneBookGetCurrentCountryIdAndCode(NULL));
}


CM_PHBK_DllExportB PhoneBookGetPhoneDUNA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszDUN, DWORD *pdwDUN)
{
    return (PhoneBookGetStringA(((CPhoneBook *) dwPB)->GetDataCenterByIdx(dwIdx),pszDUN,pdwDUN));
}


#else  // The following routines only exist for UNICODE versions. 

// UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE 
// UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE 
// UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE 

// Helpers

static LPSTR wc2mb(UINT nCP, LPCWSTR pszStr)
{
    int iLen;
    LPSTR pszTmp;

    iLen = WideCharToMultiByte(nCP,0,pszStr,-1,NULL,0,NULL,NULL);
    pszTmp = (LPSTR) CmMalloc(iLen*sizeof(*pszTmp));

    if (pszTmp)
    {
        iLen = WideCharToMultiByte(nCP,0,pszStr,-1,pszTmp,iLen,NULL,NULL);
        if (!iLen)
        {
            CmFree(pszTmp);
            return NULL;
        }
    }
    return pszTmp;
}


static LPWSTR mb2wc(UINT nCP, LPCSTR pszStr)
{
    int iLen;
    LPWSTR pszTmp;

    iLen = MultiByteToWideChar(nCP,0,pszStr,-1,NULL,0);
    pszTmp = (LPWSTR) CmMalloc(iLen*sizeof(*pszTmp));

    if (pszTmp)
    {
        iLen = MultiByteToWideChar(nCP,0,pszStr,-1,pszTmp,iLen);
        if (!iLen)
        {
            CmFree(pszTmp);
            return NULL;
        }
    }
    return pszTmp;
}


static void strcpy_wc2mb(UINT nCP, LPSTR pszDest, LPCWSTR pszSrc)
{
    LPSTR pszTmp;

    pszTmp = wc2mb(nCP,pszSrc);
    _mbscpy((unsigned char *) pszDest,(unsigned char *) pszTmp);
    CmFree(pszTmp);
}


static void strcpy_mb2wc(UINT nCP, LPWSTR pszDest, LPCSTR pszSrc)
{
    LPWSTR pszTmp;

    pszTmp = mb2wc(nCP,pszSrc);
    wcscpy(pszDest,pszTmp);
    CmFree(pszTmp);
}

static void reW2A(const RASENTRYW *pIn, RASENTRYA *pOut)
{

    pOut->dwSize = sizeof(*pOut);
    pOut->dwfOptions = pIn->dwfOptions;
    pOut->dwCountryID = pIn->dwCountryID;
    pOut->dwCountryCode = pIn->dwCountryCode;
    strcpy_wc2mb(CP_OEMCP,pOut->szAreaCode,pIn->szAreaCode);
    strcpy_wc2mb(CP_OEMCP,pOut->szLocalPhoneNumber,pIn->szLocalPhoneNumber);

    pOut->dwAlternateOffset = pIn->dwAlternateOffset + sizeof(*pOut) - sizeof(*pIn);

    CopyMemory(&pOut->ipaddr,&pIn->ipaddr,sizeof(pIn->ipaddr));
    CopyMemory(&pOut->ipaddrDns,&pIn->ipaddrDns,sizeof(pIn->ipaddrDns));
    CopyMemory(&pOut->ipaddrDnsAlt,&pIn->ipaddrDnsAlt,sizeof(pIn->ipaddrDnsAlt));
    CopyMemory(&pOut->ipaddrWins,&pIn->ipaddrWins,sizeof(pIn->ipaddrWins));
    CopyMemory(&pOut->ipaddrWinsAlt,&pIn->ipaddrWinsAlt,sizeof(pIn->ipaddrWinsAlt));
    pOut->dwFrameSize = pIn->dwFrameSize;
    pOut->dwfNetProtocols = pIn->dwfNetProtocols;
    pOut->dwFramingProtocol = pIn->dwFramingProtocol;
    strcpy_wc2mb(CP_OEMCP,pOut->szScript,pIn->szScript);
    strcpy_wc2mb(CP_OEMCP,pOut->szAutodialDll,pIn->szAutodialDll);
    strcpy_wc2mb(CP_OEMCP,pOut->szAutodialFunc,pIn->szAutodialFunc);
    strcpy_wc2mb(CP_OEMCP,pOut->szDeviceType,pIn->szDeviceType);
    strcpy_wc2mb(CP_OEMCP,pOut->szDeviceName,pIn->szDeviceName);
    strcpy_wc2mb(CP_OEMCP,pOut->szX25PadType,pIn->szX25PadType);
    strcpy_wc2mb(CP_OEMCP,pOut->szX25Address,pIn->szX25Address);
    strcpy_wc2mb(CP_OEMCP,pOut->szX25Facilities,pIn->szX25Facilities);
    strcpy_wc2mb(CP_OEMCP,pOut->szX25UserData,pIn->szX25UserData);
    pOut->dwChannels = pIn->dwChannels;

    if (pIn->dwAlternateOffset)
    {
        LPWSTR pszIn = (LPWSTR) (((LPBYTE) pIn) + pIn->dwAlternateOffset);
        LPSTR pszOut = (LPSTR) (((LPBYTE) pOut) + pOut->dwAlternateOffset);

        while (*pszIn)
        {
            strcpy_wc2mb(CP_OEMCP,pszOut,pszIn);
            pszIn += wcslen(pszIn) + 1;
            pszOut += _mbslen((unsigned char *) pszOut) + 1;
        }
    }
}


static void reA2W(const RASENTRYA *pIn, RASENTRYW *pOut)
{
    pOut->dwSize = sizeof(*pOut);
    pOut->dwfOptions = pIn->dwfOptions;
    pOut->dwCountryID = pIn->dwCountryID;
    pOut->dwCountryCode = pIn->dwCountryCode;
    strcpy_mb2wc(CP_OEMCP,pOut->szAreaCode,pIn->szAreaCode);
    strcpy_mb2wc(CP_OEMCP,pOut->szLocalPhoneNumber,pIn->szLocalPhoneNumber);

    pOut->dwAlternateOffset = pIn->dwAlternateOffset + sizeof(*pOut) - sizeof(*pIn);
    
    CopyMemory(&pOut->ipaddr,&pIn->ipaddr,sizeof(pIn->ipaddr));
    CopyMemory(&pOut->ipaddrDns,&pIn->ipaddrDns,sizeof(pIn->ipaddrDns));
    CopyMemory(&pOut->ipaddrDnsAlt,&pIn->ipaddrDnsAlt,sizeof(pIn->ipaddrDnsAlt));
    CopyMemory(&pOut->ipaddrWins,&pIn->ipaddrWins,sizeof(pIn->ipaddrWins));
    CopyMemory(&pOut->ipaddrWinsAlt,&pIn->ipaddrWinsAlt,sizeof(pIn->ipaddrWinsAlt));
    pOut->dwFrameSize = pIn->dwFrameSize;
    pOut->dwfNetProtocols = pIn->dwfNetProtocols;
    pOut->dwFramingProtocol = pIn->dwFramingProtocol;
    strcpy_mb2wc(CP_OEMCP,pOut->szScript,pIn->szScript);
    strcpy_mb2wc(CP_OEMCP,pOut->szAutodialDll,pIn->szAutodialDll);
    strcpy_mb2wc(CP_OEMCP,pOut->szAutodialFunc,pIn->szAutodialFunc);
    strcpy_mb2wc(CP_OEMCP,pOut->szDeviceType,pIn->szDeviceType);
    strcpy_mb2wc(CP_OEMCP,pOut->szDeviceName,pIn->szDeviceName);
    strcpy_mb2wc(CP_OEMCP,pOut->szX25PadType,pIn->szX25PadType);
    strcpy_mb2wc(CP_OEMCP,pOut->szX25Address,pIn->szX25Address);
    strcpy_mb2wc(CP_OEMCP,pOut->szX25Facilities,pIn->szX25Facilities);
    strcpy_mb2wc(CP_OEMCP,pOut->szX25UserData,pIn->szX25UserData);
    pOut->dwChannels = pIn->dwChannels;

    if (pIn->dwAlternateOffset)
    {
        LPSTR pszIn = (LPSTR) (((LPBYTE) pIn) + pIn->dwAlternateOffset);
        LPWSTR pszOut = (LPWSTR) (((LPBYTE) pOut) + pOut->dwAlternateOffset);

        while (*pszIn)
        {
            strcpy_mb2wc(CP_OEMCP,pszOut,pszIn);
            pszIn += _mbslen((unsigned char *) pszIn) + 1;
            pszOut += wcslen(pszOut) + 1;
        }
    }
}

// Wide versions of current APIs

static BOOL PhoneBookGetStringW(LPCSTR pszSrc, LPWSTR pszDest, DWORD *pdwDest)
{
    DWORD dwTmp;

    dwTmp = MultiByteToWideChar(GetACP(),0,pszSrc,-1,NULL,0);
    if (dwTmp > *pdwDest)
    {
        *pdwDest = dwTmp;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    dwTmp = MultiByteToWideChar(GetACP(),0,pszSrc,-1,pszDest,*pdwDest);
    *pdwDest = dwTmp;
    return TRUE;
}

static BOOL WINAPI PhoneBookParseInfoWSvcThunk(LPCSTR pszSvc,
                                               PPBFS pFilter, 
                                               DWORD_PTR dwParam)
{
    PhoneBookParseInfoStructW *pParam = (PhoneBookParseInfoStructW *) dwParam;
    LPWSTR pszTmpSvc;
    BOOL bRes;
    DWORD dwErr;

    pszTmpSvc = mb2wc(GetACP(),pszSvc);
    if (!pszTmpSvc) {
        return FALSE;
    }
    bRes = pParam->pfnSvc(pszTmpSvc,pFilter,pParam->dwSvcParam);
    if (!bRes) {
        dwErr = GetLastError();
    }
    CmFree(pszTmpSvc);
    if (!bRes) {
        SetLastError(dwErr);
    }
    return (bRes);
}


static BOOL WINAPI PhoneBookParseInfoWRefThunk(LPCSTR pszFile,
                                               LPCSTR pszURL,
                                               PPBFS pFilterA,
                                               PPBFS pFilterB,
                                               DWORD_PTR dwParam)
{
    PhoneBookParseInfoStructW *pParam = (PhoneBookParseInfoStructW *) dwParam;
    LPWSTR pszTmpFile;
    LPWSTR pszTmpURL;
    DWORD dwErr;
    BOOL bRes;

    pszTmpFile = mb2wc(CP_OEMCP,pszFile);
    if (!pszTmpFile)
    {
        return FALSE;
    }
    pszTmpURL = mb2wc(CP_OEMCP,pszURL);
    if (!pszTmpURL)
    {
        dwErr = GetLastError();
        CmFree(pszTmpFile);
        SetLastError(dwErr);
        return FALSE;
    }
    bRes = pParam->pfnRef(pszTmpFile,pszTmpURL,pFilterA,pFilterB,pParam->dwRefParam);
    if (!bRes)
    {
        dwErr = GetLastError();
    }
    CmFree(pszTmpFile);
    CmFree(pszTmpURL);
    if (!bRes)
    {
        SetLastError(dwErr);
    }
    return bRes;
}

CM_PHBK_DllExportB PhoneBookGetCountryNameW(DWORD_PTR dwPB, unsigned int nIdx, LPWSTR pszCountryName, DWORD *pdwCountryName)
{
    return (PhoneBookGetStringW(((CPhoneBook *) dwPB)->GetCountryNameByIdx(nIdx),pszCountryName,pdwCountryName));
}

CM_PHBK_DllExportB PhoneBookGetRegionNameW(DWORD_PTR dwPB, unsigned int nIdx, LPWSTR pszRegionName, DWORD *pdwRegionName)
{
    return (PhoneBookGetStringW(((CPhoneBook *) dwPB)->GetRegionNameByIdx(nIdx),pszRegionName,pdwRegionName));
}


CM_PHBK_DllExportB PhoneBookGetPhoneCanonicalW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszPhoneNumber, DWORD *pdwPhoneNumber)
{
    char szTmp[64];

    ((CPhoneBook *) dwPB)->GetCanonical(dwIdx,szTmp);
    return (PhoneBookGetStringW(szTmp,pszPhoneNumber,pdwPhoneNumber));
}

CM_PHBK_DllExportB PhoneBookGetPhoneNonCanonicalW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszPhoneNumber, DWORD *pdwPhoneNumber)
{
    char szTmp[64];

    ((CPhoneBook *) dwPB)->GetNonCanonical(dwIdx,szTmp);
    return (PhoneBookGetStringW(szTmp,pszPhoneNumber,pdwPhoneNumber));
}

CM_PHBK_DllExportB PhoneBookParseInfoW(LPCWSTR pszFile, PhoneBookParseInfoStructW *pInfo)
{
    LPSTR pszTmpFile;
    PhoneBookParseInfoStructA iInfo;
    BOOL bRes;
    DWORD dwErr;
    LPWSTR pszTmpURL;

    if (!pszFile || !pInfo || pInfo->dwSize != sizeof(*pInfo))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pszTmpFile = wc2mb(CP_OEMCP,pszFile);
    if (!pszTmpFile)
    {
        return FALSE;
    }
    ZeroMemory(&iInfo,sizeof(iInfo));
    iInfo.dwSize = sizeof(iInfo);
    iInfo.dwURL = MAX_PATH * 3 / 2;
    while (1)
    {
        iInfo.pszURL = (LPSTR) CmMalloc(iInfo.dwURL * sizeof(*iInfo.pszURL));

        if (NULL == iInfo.pszURL)
        {
            CmFree(pszTmpFile);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;		
        }

        bRes = PhoneBookParseInfoA(pszTmpFile,&iInfo);
        if (bRes)
        {
            break;
        }
        dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER)
        {
            CmFree(iInfo.pszURL);
            CmFree(pszTmpFile);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }
        CmFree(iInfo.pszURL);
    }
    pszTmpURL = mb2wc(CP_OEMCP,iInfo.pszURL);
    if (!pszTmpURL)
    {
        dwErr = GetLastError();
        CmFree(pszTmpFile);
        CmFree(iInfo.pszURL);
        SetLastError(dwErr);
        return FALSE;
    }
    if (pInfo->pszURL && (wcslen(pszTmpURL) >= pInfo->dwURL))
    {
        pInfo->dwURL = wcslen(pszTmpURL) + 1;
        CmFree(pszTmpFile);
        CmFree(iInfo.pszURL);
        CmFree(pszTmpURL);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    pInfo->dwURL = wcslen(pszTmpURL) + 1;
    if (pInfo->pszURL)
    {
        wcscpy(pInfo->pszURL,pszTmpURL);
    }
    CmFree(iInfo.pszURL);
    CmFree(pszTmpURL);
    pInfo->pFilterA = iInfo.pFilterA;
    pInfo->pFilterB = iInfo.pFilterB;
    if (!pInfo->pfnSvc && !pInfo->pfnRef)
    {
        CmFree(pszTmpFile);
        return TRUE;
    }
    iInfo.pszURL = NULL;
    if (pInfo->pfnSvc)
    {
        iInfo.pfnSvc = PhoneBookParseInfoWSvcThunk;
        iInfo.dwSvcParam = (DWORD_PTR) pInfo;
    }
    if (pInfo->pfnRef)
    {
        iInfo.pfnRef = PhoneBookParseInfoWRefThunk;
        iInfo.dwRefParam = (DWORD_PTR) pInfo;
    }
    bRes = PhoneBookParseInfoA(pszTmpFile,&iInfo);
    if (!bRes)
    {
        dwErr = GetLastError();
    }
    CmFree(pszTmpFile);
    if (!bRes)
    {
        SetLastError(dwErr);
    }
    return bRes;
}

CM_PHBK_DllExportB PhoneBookGetPhoneDispW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszDisp, DWORD *pdwDisp)
{
    CPhoneBook *pPB = (CPhoneBook *) dwPB;
    char szTmp[256];
    wsprintf(szTmp,
             "%s (%s) %s (%u-%u %s)",
             pPB->GetCityNameByIdx(dwIdx),
             pPB->GetAreaCodeByIdx(dwIdx),
             pPB->GetAccessNumberByIdx(dwIdx),
             pPB->GetMinBaudByIdx(dwIdx),
             pPB->GetMaxBaudByIdx(dwIdx),
             c_pszBps);
    return (PhoneBookGetStringW(szTmp,pszDisp,pdwDisp));
}


CM_PHBK_DllExportB PhoneBookGetPhoneDescW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszDesc, DWORD *pdwDesc)
{
    CPhoneBook *pPB = (CPhoneBook *) dwPB;
    char szTmp[256];

    wsprintf(szTmp,
             "%s (%u-%u %s)",
             pPB->GetCityNameByIdx(dwIdx),
             pPB->GetMinBaudByIdx(dwIdx),
             pPB->GetMaxBaudByIdx(dwIdx),
             c_pszBps);
    return (PhoneBookGetStringW(szTmp,pszDesc,pdwDesc));
}


CM_PHBK_DllExportB PhoneBookGetPhoneDUNW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszDUN, DWORD *pdwDUN)
{
    return (PhoneBookGetStringW(((CPhoneBook *) dwPB)->GetDataCenterByIdx(dwIdx),pszDUN,pdwDUN));
}

#endif // ndef UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmpbk\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     main.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Implementation of DllMain for cmpbk32.dll.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

extern HINSTANCE g_hInst;

extern "C" BOOL WINAPI DllMain(
    HINSTANCE  hinstDLL,	// handle to DLL module 
    DWORD  fdwReason,		// reason for calling function 
    LPVOID  lpvReserved 	// reserved 
   )
{
	if (fdwReason == DLL_PROCESS_ATTACH)
    {
        MYDBGASSERT(hinstDLL);
		g_hInst = hinstDLL;
        MYVERIFY(DisableThreadLibraryCalls(hinstDLL));
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmpbk\misc.cpp ===
//+----------------------------------------------------------------------------
//
// File:     misc.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Miscellaneous phone book utility functions.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

// ############################################################################
// Miscellaneous support routines

#include "cmmaster.h"

/*  Not used anywhere, take out
#define irgMaxSzs 5
char szStrTable[irgMaxSzs][256];

// ############################################################################
PSTR GetSz(WORD wszID)
{
    static int iSzTable=0;
    
    PSTR psz = (PSTR) szStrTable[iSzTable];

    iSzTable++;
    if (iSzTable >= irgMaxSzs)
        iSzTable = 0;
        
    if (!LoadString(g_hInst, wszID, psz, 256))
    {
        CMTRACE1("LoadString failed %d\n", (DWORD) wszID);
        *psz = 0;
    }
        
    return (psz);
}
*/
// ############################################################################
void SzCanonicalFromAE (char *psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE)
{
    if (NO_AREA_CODE == pAE->dwAreaCode)
    {
        wsprintf(psz, "+%lu %s", pLCE->dwCountryCode, pAE->szAccessNumber);
    }
    else
    {
        wsprintf(psz, "+%lu (%s) %s", pLCE->dwCountryCode, pAE->szAreaCode, pAE->szAccessNumber);
    }
    
    return;
}

// ############################################################################
void SzNonCanonicalFromAE (char *psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE)
{
    if (NO_AREA_CODE == pAE->dwAreaCode)
    {
        wsprintf(psz, "%lu %s", pLCE->dwCountryCode, pAE->szAccessNumber);
    }
    else
    {
        wsprintf(psz, "%lu %s %s", pLCE->dwCountryCode, pAE->szAreaCode, pAE->szAccessNumber);
    }
    
    return;
}

// ############################################################################

int MyStrcmp(PVOID pv1, PVOID pv2)
{
    char *pc1 = (char*) pv1;
    char *pc2 = (char*) pv2;
    int iRC = 0;
    // loop while not pointed at the ending NULL character and no difference has been found
    while (*pc1 && *pc2 && !iRC)
    {
        iRC = (int)(*pc1 - *pc2);
        pc1++;
        pc2++;
    }

    // if we exited because we got to the end of one string before we found a difference
    // return -1 if pv1 is longer, else return the character pointed at by pv2.  If pv2
    // is longer than pv1 then the value at pv2 will be greater than 0.  If both strings
    // ended at the same time, then pv2 will point to 0.
    if (!iRC)
    {
        iRC = (*pc1) ? -1 : (*pc2);
    }
    return iRC;
}

// ############################################################################
int __cdecl CompareIDLookUpElements(const void*e1, const void*e2)
{
    if (((PIDLOOKUPELEMENT)e1)->dwID > ((PIDLOOKUPELEMENT)e2)->dwID)
        return 1;
    if (((PIDLOOKUPELEMENT)e1)->dwID < ((PIDLOOKUPELEMENT)e2)->dwID)
        return -1;
    return 0;
}

// ############################################################################
int __cdecl CompareCntryNameLookUpElementsA(const void*e1, const void*e2)
{
    PCNTRYNAMELOOKUPELEMENT pCUE1 = (PCNTRYNAMELOOKUPELEMENT)e1;
    PCNTRYNAMELOOKUPELEMENT pCUE2 = (PCNTRYNAMELOOKUPELEMENT)e2;

    return CompareStringA(LOCALE_USER_DEFAULT,0,pCUE1->psCountryName,
        pCUE1->dwNameSize,pCUE2->psCountryName,
        pCUE2->dwNameSize) - 2;
}

// ############################################################################
int __cdecl CompareCntryNameLookUpElementsW(const void*e1, const void*e2)
{
    PCNTRYNAMELOOKUPELEMENTW pCUE1 = (PCNTRYNAMELOOKUPELEMENTW)e1;
    PCNTRYNAMELOOKUPELEMENTW pCUE2 = (PCNTRYNAMELOOKUPELEMENTW)e2;

    return CompareStringW(LOCALE_USER_DEFAULT,0,pCUE1->psCountryName,
        pCUE1->dwNameSize,pCUE2->psCountryName,
        pCUE2->dwNameSize) - 2;
}

// ############################################################################
int __cdecl CompareIdxLookUpElements(const void*e1, const void*e2)
{
    PIDXLOOKUPELEMENT pidx1 = (PIDXLOOKUPELEMENT) e1;
    PIDXLOOKUPELEMENT pidx2 = (PIDXLOOKUPELEMENT) e2;

    if (pidx1->dwIndex > pidx2->dwIndex)    
    {
        return 1;
    }

    if (pidx1->dwIndex < pidx2->dwIndex)    
    {
        return -1;
    }           
        
    return 0;
}

// ############################################################################
int __cdecl CompareIdxLookUpElementsFileOrder(const void *pv1, const void *pv2)
{
    PACCESSENTRY pae1, pae2;
    int iSort;

    pae1 = (PACCESSENTRY) (((PIDXLOOKUPELEMENT)pv1)->iAE);
    pae2 = (PACCESSENTRY) (((PIDXLOOKUPELEMENT)pv2)->iAE);

    // sort empty enteries to the end of the list
    if (!(pae1 && pae2))
    {
        // return ((int)pae1) ? -1 : ((int)pae2);
        return (pae1 ? -1 : (pae2 ? 1 : 0));
    }

    // country ASC, state ASC, city ASC, toll free DESC, flip DESC, con spd max DESC
    if (pae1->dwCountryID != pae2->dwCountryID)
    {
        return (int) (pae1->dwCountryID - pae2->dwCountryID);
    }
    
    if (pae1->wStateID != pae2->wStateID)
    {
        return (pae1->wStateID - pae2->wStateID);
    }

    iSort  = MyStrcmp((PVOID)pae1->szCity, (PVOID)pae2->szCity);
    if (iSort)
    {
        return (iSort);
    }

    if (pae1->fType != pae2->fType)
    {
        return (int) (pae2->fType - pae1->fType);
    }

    if (pae1->bFlipFactor != pae2->bFlipFactor)
    {
        return (pae2->bFlipFactor - pae1->bFlipFactor);
    }

    if (pae1->dwConnectSpeedMax != pae2->dwConnectSpeedMax)
    {
        return (int) (pae2->dwConnectSpeedMax - pae1->dwConnectSpeedMax);
    }

    return 0;
}

// ############################################################################
//inline BOOL FSz2Dw(PCSTR pSz,DWORD *dw)
BOOL FSz2Dw(PCSTR pSz,DWORD *dw)
{
    DWORD val = 0;
    while (*pSz)
    {
        if (*pSz >= '0' && *pSz <= '9')
        {
            val *= 10;
            val += *pSz++ - '0';
        }
        else
        {
            return FALSE;  //bad number
        }
    }
    *dw = val;
    return (TRUE);
}

// ############################################################################
//inline BOOL FSz2W(PCSTR pSz,WORD *w)
BOOL FSz2W(PCSTR pSz,WORD *w)
{
    DWORD dw;
    if (FSz2Dw(pSz,&dw))
    {
        *w = (WORD)dw;
        return TRUE;
    }
    return FALSE;
}

// ############################################################################
//inline BOOL FSz2B(PCSTR pSz,BYTE *pb)
BOOL FSz2B(PCSTR pSz,BYTE *pb)
{
    DWORD dw;
    if (FSz2Dw(pSz,&dw))
    {
        *pb = (BYTE)dw;
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmpbk\pch.hpp ===
extern "C" {
#include "pch.h"
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmpbk\phbk.cpp ===
//+----------------------------------------------------------------------------
//
// File:     phbk.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Implementation of CPhoneBook
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

// ############################################################################
// Phone book APIs

#include "cmmaster.h"

const TCHAR* const c_pszInfDefault = TEXT("INF_DEFAULT");
const TCHAR* const c_pszInfSuffix = TEXT(".CMS");

//#define ReadVerifyPhoneBookDW(x)  CMASSERTMSG(ReadPhoneBookDW(&(x),pcCSVFile),"Invalid DWORD in phone book");
#define ReadVerifyPhoneBookDW(x)    if (!ReadPhoneBookDW(&(x),pcCSVFile))               \
                                        {   CMASSERTMSG(0,"Invalid DWORD in phone book");   \
                                            goto DataError; }
#define ReadVerifyPhoneBookW(x)     if (!ReadPhoneBookW(&(x),pcCSVFile))                \
                                        {   CMASSERTMSG(0,"Invalid WORD in phone book");    \
                                            goto DataError; }
#define ReadVerifyPhoneBookB(x)     if (!ReadPhoneBookB(&(x),pcCSVFile))                \
                                        {   CMASSERTMSG(0,"Invalid BYTE in phone book");    \
                                            goto DataError; }
#define ReadVerifyPhoneBookSZ(x,y)  if (!ReadPhoneBookSZ(&x[0],y+sizeof('\0'),pcCSVFile))   \
                                        {   CMASSERTMSG(0,"Invalid STRING in phone book");      \
                                            goto DataError; }
#define CHANGE_BUFFER_SIZE 50

#define ERROR_USERBACK 32766
#define ERROR_USERCANCEL 32767
                                        
// ############################################################################
void CPhoneBook::EnumNumbersByCountry(DWORD dwCountryID, PPBFS pFilter, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam)
{
    MYDBG(("CPhoneBook::EnumNumbersByCountry"));

    PACCESSENTRY pAELast, pAE = NULL;
    PIDLOOKUPELEMENT pIDLookUp;
    IDLOOKUPELEMENT LookUpTarget;
    
    LookUpTarget.dwID = dwCountryID;
    pIDLookUp = NULL;
    pIDLookUp = (PIDLOOKUPELEMENT)CmBSearch(&LookUpTarget,m_rgIDLookUp,
        (size_t) m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIDLookUpElements);
    if (pIDLookUp)
        pAE = IdxToPAE(pIDLookUp->iFirstAE);

    // Fill the list for whatever AE's we found
    //
    
    if (pAE)
    {
        pAELast = &(m_rgPhoneBookEntry[m_cPhoneBookEntries - 1]);
        while (pAELast >= pAE)
        {
            if (pAE->dwCountryID == dwCountryID && pAE->wStateID == 0) {
                if (PhoneBookMatchFilter(pFilter,pAE->fType))
                {
                    pfnNumber((unsigned int) (pAE - m_rgPhoneBookEntry),dwParam);
                }
            }
            pAE++;
        }

        // Select the first item
        //

    }
}
// ############################################################################
void CPhoneBook::EnumNumbersByCountry(DWORD dwCountryID, DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam)
{
    MYDBG(("CPhoneBook::EnumNumbersByCountry"));

    PhoneBookFilterStruct sFilter = {1,{{dwMask,fType}}};

    EnumNumbersByCountry(dwCountryID,&sFilter,pfnNumber,dwParam);
}

// ############################################################################
BOOL CPhoneBook::FHasPhoneType(PPBFS pFilter)
{
    MYDBG(("CPhoneBook::FHasPhoneType"));

    PACCESSENTRY pAELast, pAE = NULL;

    pAE = &(m_rgPhoneBookEntry[0]); // pAE points to the first phone  book entry

    // 
    // Examine each entry until we find a match or exhaust the entries
    //

    if (pAE)
    {
        pAELast = &(m_rgPhoneBookEntry[m_cPhoneBookEntries - 1]);

        while (pAELast >= pAE)
        {
            //
            // See if this pop passes the specified filter
            //

            if (PhoneBookMatchFilter(pFilter, pAE->fType))
            {
                return TRUE;
            }

            pAE++;
        }
    }

    return FALSE;
}

// ############################################################################
void CPhoneBook::EnumNumbersByRegion(unsigned int nRegion, DWORD dwCountryID, PPBFS pFilter, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam)
{
    MYDBG(("CPhoneBook::EnumNumbersByRegion"));

    PACCESSENTRY pAELast, pAE = NULL;
    
    pAE = &m_rgPhoneBookEntry[0]; // pAE points to the first phone  book entry

    // Fill the list for whatever AE's we found
    if (pAE)
    {
        pAELast = &(m_rgPhoneBookEntry[m_cPhoneBookEntries - 1]);
        while (pAELast >= pAE)
        {
            // choose phone number of the same region OR with region ID = 0(which means ALL regions)
            if (pAE->dwCountryID == dwCountryID && 
                ((pAE->wStateID == nRegion+1) || (pAE->wStateID == 0)))
            {
                    
                if (PhoneBookMatchFilter(pFilter,pAE->fType))
                    pfnNumber((unsigned int) (pAE - m_rgPhoneBookEntry), dwParam); 
            }
            pAE++;
        }
        // Select the first item
        //
    }
}
// ############################################################################
void CPhoneBook::EnumNumbersByRegion(unsigned int nRegion, DWORD dwCountryID, DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam)
{
    MYDBG(("CPhoneBook::EnumNumbersByRegion"));
    
    PhoneBookFilterStruct sFilter = {1,{{dwMask,fType}}};

    EnumNumbersByRegion(nRegion,dwCountryID,&sFilter,pfnNumber,dwParam);
}
// ############################################################################
void CPhoneBook::EnumRegions(DWORD dwCountryID, PPBFS pFilter, CB_PHONEBOOK pfnRegion, DWORD_PTR dwParam)
{
    unsigned int idx;

    MYDBG(("CPhoneBook::EnumRegions"));

    for (idx=0;idx<m_cStates;idx++)
    {
        PACCESSENTRY pAE = NULL, pAELast = NULL;

        pAE = &m_rgPhoneBookEntry[0]; 
        MYDBGASSERT(pAE);
        pAELast = &(m_rgPhoneBookEntry[m_cPhoneBookEntries - 1]);
        while (pAELast >= pAE) 
        {
            if (pAE->dwCountryID == dwCountryID &&
                pAE->wStateID == idx+1)
            {
                if (PhoneBookMatchFilter(pFilter,pAE->fType))
                    goto AddRegion;
            }
            pAE++;
        } // while

        continue; // start the next 'for' loop

AddRegion:
        pfnRegion(idx,dwParam);
    }
}


// ############################################################################
void CPhoneBook::EnumRegions(DWORD dwCountryID, DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnRegion, DWORD_PTR dwParam)
{
    MYDBG(("CPhoneBook::EnumRegions"));

    PhoneBookFilterStruct sFilter = {1,{{dwMask,fType}}};

    EnumRegions(dwCountryID,&sFilter,pfnRegion,dwParam);
}
// ############################################################################
void CPhoneBook::EnumCountries(PPBFS pFilter, CB_PHONEBOOK pfnCountry, DWORD_PTR dwParam)
{
    unsigned int idx;

    MYDBG(("CPhoneBook::EnumCountries"));

    for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
    {
        if (FHasPhoneNumbers(m_rgNameLookUp[idx].pLCE->dwCountryID,pFilter))
        {
            pfnCountry(idx,dwParam);
        }
    }
}
// ############################################################################
void CPhoneBook::EnumCountries(DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnCountry, DWORD_PTR dwParam)
{
    MYDBG(("CPhoneBook::EnumCountries"));

    PhoneBookFilterStruct sFilter = {1,{{dwMask,fType}}};

    EnumCountries(&sFilter,pfnCountry,dwParam);
}
// ############################################################################
BOOL CPhoneBook::FHasPhoneNumbers(DWORD dwCountryID, PPBFS pFilter)
{
    PIDLOOKUPELEMENT pIDLookUp;
    IDLOOKUPELEMENT LookUpTarget;
    PACCESSENTRY pAE = NULL, pAELast = NULL;
    DWORD dwTmpCountryID;

    LookUpTarget.dwID = dwCountryID;

    pIDLookUp = NULL;
    pIDLookUp = (PIDLOOKUPELEMENT)CmBSearch(&LookUpTarget,m_rgIDLookUp,
        (size_t) m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIDLookUpElements);

    if (!pIDLookUp) return FALSE; // no such country

    pAE = IdxToPAE(pIDLookUp->iFirstAE);
    if (!pAE) return FALSE; // no phone numbers at all

    dwTmpCountryID = pAE->dwCountryID;

    pAELast = &(m_rgPhoneBookEntry[m_cPhoneBookEntries - 1]);
    while (pAELast >= pAE) {
        if (pAE->dwCountryID == dwTmpCountryID)
        {
            if (PhoneBookMatchFilter(pFilter,pAE->fType)) return TRUE;
        }
        pAE++;
    }
    return FALSE; // no phone numbers of the right type

//  return ((BOOL)(pIDLookUp->pFirstAE));
}
// ############################################################################
BOOL CPhoneBook::FHasPhoneNumbers(DWORD dwCountryID, DWORD dwMask, DWORD fType)
{
    MYDBG(("CPhoneBook::FHasPhoneNumbers"));
    
    PhoneBookFilterStruct sFilter = {1,{{dwMask,fType}}};

    return FHasPhoneNumbers(dwCountryID,&sFilter);
}

// ############################################################################
CPhoneBook::CPhoneBook()
{
    m_rgPhoneBookEntry = NULL;
    m_cPhoneBookEntries =0;
    m_rgLineCountryEntry=NULL;
    m_rgState=NULL;
    m_cStates=0;
    m_rgIDLookUp = NULL;
    m_rgNameLookUp = NULL;
    m_pLineCountryList = NULL;

    MYDBG(("CPhoneBook::CPhoneBook"));

    ZeroMemory(&m_szINFFile[0],MAX_PATH);
    ZeroMemory(&m_szPhoneBook[0],MAX_PATH);
}

// ############################################################################
CPhoneBook::~CPhoneBook()
{
    MYDBG(("CPhoneBook::~CPhoneBook"));

    CmFree(m_rgPhoneBookEntry);
    m_rgPhoneBookEntry = NULL;

    CmFree(m_pLineCountryList);
    m_pLineCountryList = NULL;

    CmFree(m_rgIDLookUp);
    m_rgIDLookUp = NULL;
    
    CmFree(m_rgNameLookUp);
    m_rgNameLookUp = NULL;
    
    CmFree(m_rgState);
    m_rgState = NULL;
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookDW(DWORD *pdw, CCSVFile *pcCSVFile)
{
    char szTempBuffer[TEMP_BUFFER_LENGTH];
    
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2Dw(szTempBuffer,pdw));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookW(WORD *pw, CCSVFile *pcCSVFile)
{
    char szTempBuffer[TEMP_BUFFER_LENGTH];

    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2W(szTempBuffer,pw));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookB(BYTE *pb, CCSVFile *pcCSVFile)
{
    char szTempBuffer[TEMP_BUFFER_LENGTH];

    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2B(szTempBuffer,pb));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookSZ(LPSTR psz, DWORD dwSize, CCSVFile *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(psz,dwSize))
            return FALSE;
    return TRUE;
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookNL(CCSVFile *pcCSVFile)
{
    if (!pcCSVFile->ClearNewLines())
            return FALSE;
    return TRUE;
}

//
//  Note: the new fUnicode parameter has been added so that Whistler and newer releases
//        take advantage of the Unicode TAPI functions where available, so that MUI works.
//
static LONG PBlineGetCountry(DWORD dwCountryID, DWORD dwAPIVersion, LPLINECOUNTRYLIST lpLineCountryList, BOOL fUnicode)
{
    HINSTANCE hInst;
    LONG lRes;

    // Try to load the TAPI DLL
    
    hInst = LoadLibrary("tapi32"); 
    
    if (!hInst) 
    {
        return (LINEERR_NOMEM);
    }
    
    // Get the proc address for GetCountry
    
    LONG (WINAPI *pfn)(DWORD,DWORD,LPLINECOUNTRYLIST);
    //
    // In case of non-Unicode we don't want lineGetCountryA because on Win95 the tapi32.dll 
    // doesn't export any A functions.
    //
    pfn = (LONG (WINAPI *)(DWORD,DWORD,LPLINECOUNTRYLIST)) GetProcAddress(hInst, fUnicode ? "lineGetCountryW" : "lineGetCountry");
    
    if (!pfn) 
    {
        FreeLibrary(hInst);
        return (LINEERR_NOMEM);
    }
    
    // Get the country list
    
    lRes = pfn(dwCountryID,dwAPIVersion,lpLineCountryList);

    FreeLibrary(hInst);
    return (lRes);
}


// ############################################################################
HRESULT CPhoneBook::Init(LPCSTR pszISPCode)
{
    char szTempBuffer[TEMP_BUFFER_LENGTH];
    LPLINECOUNTRYLIST pLineCountryTemp = NULL;
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    DWORD dwLastState = 0;
    DWORD dwLastCountry = 0;
    DWORD dwNumAllocated;
    PACCESSENTRY pCurAccessEntry = NULL;
    LPLINECOUNTRYENTRY pLCETemp;
    DWORD idx;
    LPTSTR pszTemp;
    LPTSTR pszCmpDir = NULL;
    CCSVFile *pcCSVFile=NULL;
    PSTATE  ps,psLast; //faster to use pointers.
    DWORD dwAlloc = 0;
    PACCESSENTRY pTempAccessEntry = NULL;

    MYDBG(("CPhoneBook::Init"));
    
    // Get TAPI country list
    m_pLineCountryList = (LPLINECOUNTRYLIST)CmMalloc(sizeof(LINECOUNTRYLIST));
    if (!m_pLineCountryList) 
    {
        goto InitExit;
    }
    
    m_pLineCountryList->dwTotalSize = sizeof(LINECOUNTRYLIST);

    //
    //  Note: For Whistler and newer releases, we take advantage of the Unicode TAPI
    //        functions where available, so that MUI works.  Hence the final parameter
    //        to PBlineGetCountry, and the two different QSorts below.
    //
    
    // get ALL country information 
    idx = PBlineGetCountry(0,0x10003, m_pLineCountryList, OS_NT51);
    if (idx && idx != LINEERR_STRUCTURETOOSMALL)
    {
        goto InitExit;
    }
    
    MYDBGASSERT(m_pLineCountryList->dwNeededSize);

    // reallocate memory for country list
    pLineCountryTemp = (LPLINECOUNTRYLIST)CmMalloc(m_pLineCountryList->dwNeededSize);
    if (!pLineCountryTemp)
    {
        goto InitExit;
    }
    
    pLineCountryTemp->dwTotalSize = m_pLineCountryList->dwNeededSize;

    CmFree(m_pLineCountryList);

    m_pLineCountryList = pLineCountryTemp;
    pLineCountryTemp = NULL;

    if (PBlineGetCountry(0,0x10003, m_pLineCountryList, OS_NT51))
    {
        goto InitExit;
    }

    // Load Look Up arrays
    // keyword:  country ID, 
    // keyvalue: pointer to the country entry in m_pLineCountryList
    //
#ifdef DEBUG
    m_rgIDLookUp = (IDLOOKUPELEMENT*)CmMalloc(sizeof(IDLOOKUPELEMENT)*m_pLineCountryList->dwNumCountries+5);
#else
    m_rgIDLookUp = (IDLOOKUPELEMENT*)CmMalloc(sizeof(IDLOOKUPELEMENT)*m_pLineCountryList->dwNumCountries);
#endif
    if (!m_rgIDLookUp) 
    {
        goto InitExit;
    }
    
    // pLCETemp points to the first country information entry
    pLCETemp = (LPLINECOUNTRYENTRY)((DWORD_PTR) m_pLineCountryList + 
               m_pLineCountryList->dwCountryListOffset);

    for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
    {
        m_rgIDLookUp[idx].dwID = pLCETemp[idx].dwCountryID;
        m_rgIDLookUp[idx].pLCE = &pLCETemp[idx];
    }
    
    // sort the country lines
    
    CmQSort(m_rgIDLookUp, (size_t) m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
          CompareIDLookUpElements);

    
    // m_rgNameLookUp: look-up list for country name
    // keyword:  country name
    // keyvalue: pointer to the country entry in m_pLineCountryList

    m_rgNameLookUp = (CNTRYNAMELOOKUPELEMENT*)CmMalloc(sizeof(CNTRYNAMELOOKUPELEMENT) * m_pLineCountryList->dwNumCountries);
    
    if (!m_rgNameLookUp) 
    {
        goto InitExit;
    }
    
    for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
    {
        m_rgNameLookUp[idx].psCountryName = (LPSTR)((DWORD_PTR)m_pLineCountryList + (DWORD)pLCETemp[idx].dwCountryNameOffset);
        m_rgNameLookUp[idx].dwNameSize = pLCETemp[idx].dwCountryNameSize;
        m_rgNameLookUp[idx].pLCE = &pLCETemp[idx];
    }

    // sort the country names

    if (OS_NT51)
    {
        CmQSort(m_rgNameLookUp,(size_t) m_pLineCountryList->dwNumCountries,sizeof(CNTRYNAMELOOKUPELEMENTW),
            CompareCntryNameLookUpElementsW);
    }
    else
    {
        CmQSort(m_rgNameLookUp,(size_t) m_pLineCountryList->dwNumCountries,sizeof(CNTRYNAMELOOKUPELEMENT),
            CompareCntryNameLookUpElementsA);
        
    }

    //
    // Locate ISP's INF file (aka .CMS)
    //
    
    if (!SearchPath(NULL, (LPCTSTR) pszISPCode, c_pszInfSuffix, MAX_PATH, m_szINFFile, &pszTemp))
    {
        wsprintf(szTempBuffer,"Can not find:%s%s (%d)",pszISPCode,c_pszInfSuffix,GetLastError());
        CMASSERTMSG(0,szTempBuffer);
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }

    // Load Region file, get region file name

    char szStateFile[sizeof(szTempBuffer)/sizeof(szTempBuffer[0])];

    GetPrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspRegionFile, NULL, szStateFile, sizeof(szStateFile)-1, m_szINFFile);

    //
    // Can't assume current directory, construct path to PBK directory
    //

    pszCmpDir = GetBaseDirFromCms(m_szINFFile);

    //
    // Look for the .PBR file, using CMP dir as base path for search
    //  

    if (!SearchPath(pszCmpDir, szStateFile, NULL, TEMP_BUFFER_LENGTH, szTempBuffer, &pszTemp))
    {
        // CMASSERTMSG(0,"STATE.ICW not found");
        CMASSERTMSG(0,"region file not found");
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }

    // open region file

    pcCSVFile = new CCSVFile;
    if (!pcCSVFile)
    {
        goto InitExit;
    }

    if (!pcCSVFile->Open(szTempBuffer))
    {
        // CMASSERTMSG(0,"Can not open STATE.ICW");
        CMASSERTMSG(0,"Can not open region file");
        delete pcCSVFile;
        pcCSVFile = NULL;
        goto InitExit;
    }

    // first token in region file is the number of regions

    if (!pcCSVFile->ClearNewLines() || !pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
    {
        goto InitExit;
    }
    
    if (!FSz2Dw(szTempBuffer,&m_cStates))
    {
        // CMASSERTMSG(0,"STATE.ICW count is invalid");
        CMASSERTMSG(0,"region count is invalid");
        goto InitExit;
    }

    // Now read in all the regions if there are any

    if (0 != m_cStates)
    {
        m_rgState = (PSTATE)CmMalloc(sizeof(STATE)*m_cStates);

        if (!m_rgState)
        {
            goto InitExit;
        }
    
        for (ps = m_rgState, psLast = &m_rgState[m_cStates - 1]; ps <= psLast;++ps)
        {
            if (pcCSVFile->ClearNewLines())
            {
                pcCSVFile->ReadToken(ps->szStateName,cbStateName);  
            }
        }
    }
    
    pcCSVFile->Close();

    // load Phone Book Name
    
    if (!GetPrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspPbFile,c_pszInfDefault,
        szTempBuffer,TEMP_BUFFER_LENGTH,m_szINFFile))
    {
        CMASSERTMSG(0,"PhoneBookFile not specified in INF file");
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }
    
#ifdef DEBUG
    if (!lstrcmp(szTempBuffer,c_pszInfDefault))
    {
        wsprintf(szTempBuffer, "%s value not found in ISP file", c_pszCmEntryIspPbFile);
        CMASSERTMSG(0,szTempBuffer);
    }
#endif

    //
    // Look for the .PBK file, using CMP dir as base path for search
    //

    if (!SearchPath(pszCmpDir,szTempBuffer,NULL,MAX_PATH,m_szPhoneBook,&pszTemp))
    {
        CMASSERTMSG(0,"ISP phone book not found");
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }

    // read in phone book entries
    
    if (!pcCSVFile->Open(m_szPhoneBook))
    {
        CMASSERTMSG(0,"Can not open phone book");
        hr = GetLastError();
        goto InitExit;
    }
    
    dwNumAllocated = 0;
    do {

        MYDBGASSERT (dwNumAllocated >= m_cPhoneBookEntries);
    
        if (m_rgPhoneBookEntry)
        {
            // If we already have an array, make sure its big enough
            
            if (dwNumAllocated == m_cPhoneBookEntries)
            {
                // We're maxed out, allocate some more memory

                dwNumAllocated += PHONE_ENTRY_ALLOC_SIZE;
                dwAlloc = (DWORD) dwNumAllocated * sizeof(ACCESSENTRY);
                MYDBG(("PhoneBook::Init - Grow ReAlloc = %lu",dwAlloc));

                // Realloc

                pTempAccessEntry = (PACCESSENTRY)CmRealloc(m_rgPhoneBookEntry, dwAlloc);

                if (!pTempAccessEntry) 
                {
                    MYDBG(("PhoneBook::Init - Grow ReAlloc of %lu failed", dwAlloc));
                    goto InitExit;
                }

                m_rgPhoneBookEntry = pTempAccessEntry;
                pTempAccessEntry = NULL;

                MYDBG(("Grow phone book to %d entries",dwNumAllocated));
                pCurAccessEntry = m_rgPhoneBookEntry + m_cPhoneBookEntries;
            }
        }
        else
        {   
            // Initialization for the first time through

            DWORD dwSize = (DWORD) sizeof(ACCESSENTRY);
            dwAlloc =  (DWORD) dwSize * PHONE_ENTRY_ALLOC_SIZE; 

            MYDBG(("PhoneBook::Init - sizeof(ACCESSENTRY) = %lu",dwSize));
            MYDBG(("PhoneBook::Init - PHONE_ENTRY_ALLOC_SIZE = %d",PHONE_ENTRY_ALLOC_SIZE));
            MYDBG(("PhoneBook::Init - Initial Alloc = %lu",dwAlloc));
            
            // Allocate intial array of PHONE_ENTRY_ALLOC_SIZE items
            
            m_rgPhoneBookEntry = (PACCESSENTRY)CmMalloc(dwAlloc);

            if (!m_rgPhoneBookEntry) 
            {
                MYDBG(("PhoneBook::Init - Initial Alloc of %lu failed",dwAlloc));
                goto InitExit;
            }
            
            dwNumAllocated = PHONE_ENTRY_ALLOC_SIZE;
            pCurAccessEntry = m_rgPhoneBookEntry;
        }

        //
        //  Make sure that we have a valid pCurAccessEntry, otherwise bail out.
        //
        if (NULL == pCurAccessEntry)
        {
            CMASSERTMSG(FALSE, TEXT("PhoneBook::Init - pCurAccessEntry is NULL"));
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto InitExit;
        }

        // Read a line from the phonebook

        hr = ReadOneLine(pCurAccessEntry,pcCSVFile);
        
        if (hr == ERROR_NO_MORE_ITEMS)
        {
            break;
        }
        else if (hr != ERROR_SUCCESS)
        {
            MYDBG(("PhoneBook::Init - ReadOneLine failed"));
            goto InitExit;
        }

        hr = ERROR_NOT_ENOUGH_MEMORY;
    
        // check the first index pointer to prevent it from being overwritten
        // by the second appearance that's scattered around somewhere else -- added by byao

        if (pCurAccessEntry->dwCountryID != dwLastCountry)
        {
            PIDLOOKUPELEMENT pIDLookUpElement;
            // NOTE: Not sure about the first parameter here.
            pIDLookUpElement = (PIDLOOKUPELEMENT)CmBSearch(&pCurAccessEntry->dwCountryID,
                m_rgIDLookUp,(size_t) m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
                CompareIDLookUpElements);

            if (!pIDLookUpElement)
            {
                // bad country ID, but we can't assert here
                MYDBG(("Bad country ID in phone book %d\n",pCurAccessEntry->dwCountryID));
                continue;
            }
            else
            {
                // for a given country ID this is the first phone number
                // don't overwrite existing index
                
                if (!pIDLookUpElement->iFirstAE) 
                {  
                    pIDLookUpElement->iFirstAE = PAEToIdx(pCurAccessEntry);
                    dwLastCountry = pCurAccessEntry->dwCountryID;
                }
            }
        }

        // Check to see if this is the first phone number for a given state
        // the code has been changed accordingly
        
        if (pCurAccessEntry->wStateID && (pCurAccessEntry->wStateID != dwLastState))
        {
            idx = pCurAccessEntry->wStateID - 1;
            //
            // don't overwrite existing index
            //
            if ((idx < m_cStates) && !m_rgState[idx].iFirst) 
            { 
                m_rgState[idx].dwCountryID = pCurAccessEntry->dwCountryID;
                m_rgState[idx].iFirst = PAEToIdx(pCurAccessEntry);
            }
            dwLastState = pCurAccessEntry->wStateID;
        }

        pCurAccessEntry++;
        m_cPhoneBookEntries++;
    
    } while (TRUE);

    MYDBG(("PhoneBook::Init - %lu Entries read",m_cPhoneBookEntries));

    if (m_cPhoneBookEntries == 0)
    {
        //
        // Phone book is empty
        //
        goto InitExit;
    }
    
    // Trim the phone book for unused memory
    
    dwAlloc = m_cPhoneBookEntries * sizeof(ACCESSENTRY);
    
    MYDBG(("PhoneBook::Init - Trim ReAlloc = %lu",dwAlloc));

    MYDBGASSERT(m_cPhoneBookEntries);

    // Realloc
    
    pTempAccessEntry = (PACCESSENTRY)CmRealloc(m_rgPhoneBookEntry, dwAlloc);

    MYDBGASSERT(pTempAccessEntry);
    
    if (!pTempAccessEntry) 
    {
        MYDBG(("PhoneBook::Init - Trim ReAlloc of %lu failed",dwAlloc));
        goto InitExit;
    }

    m_rgPhoneBookEntry = pTempAccessEntry;
    pTempAccessEntry = NULL;

    hr = ERROR_SUCCESS;

    // Exit
    
InitExit:

    // If something failed release everything

    if (hr != ERROR_SUCCESS)
    {
        CmFree(m_pLineCountryList);
        m_pLineCountryList = NULL;

        CmFree(m_rgPhoneBookEntry);

        m_rgPhoneBookEntry = NULL;
        m_cPhoneBookEntries = 0 ;
        
        CmFree(m_rgIDLookUp);
        m_rgIDLookUp=NULL;
        
        CmFree(m_rgNameLookUp);
        m_rgNameLookUp=NULL;
        
        CmFree(m_rgState);
        m_rgState = NULL;
        
        m_cStates = 0;
    }

    if (pcCSVFile) 
    {
        pcCSVFile->Close();
        delete pcCSVFile;
    }

    if (pszCmpDir)
    {
        CmFree(pszCmpDir);
    }

    return hr;
}

// ############################################################################
HRESULT CPhoneBook::Merge(LPCSTR pszChangeFile)
{
    char szTempBuffer[TEMP_BUFFER_LENGTH];
    char szTempFileName[MAX_PATH];
    CCSVFile *pcCSVFile = NULL;
    ACCESSENTRY aeChange;
    PIDXLOOKUPELEMENT rgIdxLookUp = NULL;
    PIDXLOOKUPELEMENT pCurIdxLookUp;
    DWORD dwAllocated;
    DWORD dwOriginalSize;
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    DWORD   dwIdx;
    DWORD cch, cchWritten;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    MYDBG(("CPhoneBook::Merge"));

    // We'll grow the phone book on the first add record (this minimizes the number
    // of places in the code where we have to grow the phone book) - so, for now,
    // just stay with the current size.
    dwAllocated = m_cPhoneBookEntries;

    // Create index to loaded phone book, sorted by index
    rgIdxLookUp = (PIDXLOOKUPELEMENT)CmMalloc(sizeof(IDXLOOKUPELEMENT) * dwAllocated);

    MYDBGASSERT(rgIdxLookUp);
    
    if (!rgIdxLookUp)
    {
        goto MergeExit;
    }

    for (dwIdx = 0; dwIdx < m_cPhoneBookEntries; dwIdx++)
    {
        rgIdxLookUp[dwIdx].iAE = PAEToIdx(&m_rgPhoneBookEntry[dwIdx]);
        rgIdxLookUp[dwIdx].dwIndex = IdxToPAE(rgIdxLookUp[dwIdx].iAE)->dwIndex;
    }
    dwOriginalSize = m_cPhoneBookEntries;

    CmQSort(rgIdxLookUp,(size_t) dwOriginalSize,sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElements);

    // Load changes to phone book
    pcCSVFile = new CCSVFile;
    MYDBGASSERT(pcCSVFile);
    
    if (!pcCSVFile)
    {
        goto MergeExit;
    }

    if (!pcCSVFile->Open(pszChangeFile))
    {
        delete pcCSVFile;
        pcCSVFile = NULL;
        goto MergeExit;
    }
    
    do {

        // Read a change record
        ZeroMemory(&aeChange,sizeof(ACCESSENTRY));
        hr = ReadOneLine(&aeChange, pcCSVFile);

        if (hr == ERROR_NO_MORE_ITEMS)
        {
            break; // no more enteries
        }
        else if (hr != ERROR_SUCCESS)
        {
            goto MergeExit;
        }

        hr = ERROR_NOT_ENOUGH_MEMORY;

/*      if (!ReadPhoneBookDW(&aeChange.dwIndex,pcCSVFile))
            break; // no more enteries
        ReadVerifyPhoneBookDW(aeChange.dwCountryID);
        ReadVerifyPhoneBookW(aeChange.wStateID);
        ReadVerifyPhoneBookSZ(aeChange.szCity,cbCity);
        ReadVerifyPhoneBookSZ(aeChange.szAreaCode,cbAreaCode);
        // NOTE: 0 is a valid area code and ,, is a valid entry for an area code
        if (!FSz2Dw(aeChange.szAreaCode,&aeChange.dwAreaCode))
            aeChange.dwAreaCode = NO_AREA_CODE;
        ReadVerifyPhoneBookSZ(aeChange.szAccessNumber,cbAccessNumber);
        ReadVerifyPhoneBookDW(aeChange.dwConnectSpeedMin);
        ReadVerifyPhoneBookDW(aeChange.dwConnectSpeedMax);
        ReadVerifyPhoneBookB(aeChange.bFlipFactor);
        ReadVerifyPhoneBookDW(aeChange.fType);
        ReadVerifyPhoneBookSZ(aeChange.szDataCenter,cbDataCenter);
        */

        pCurIdxLookUp = (PIDXLOOKUPELEMENT) CmBSearch(&aeChange,
                                                    rgIdxLookUp,
                                                    (size_t) dwOriginalSize,
                                                    sizeof(IDXLOOKUPELEMENT),
                                                    CompareIdxLookUpElements);
        // Determine if this is a delete, add, or merge  record
        if (aeChange.szAccessNumber[0] == '0' && aeChange.szAccessNumber[1] == '\0')
        {
            // This is a delete record
            CMASSERTMSG(pCurIdxLookUp,"Attempting to delete a record that does not exist.  The change file and phone book versions do not match.");
            if (pCurIdxLookUp)
            {
                CMASSERTMSG(IdxToPAE(pCurIdxLookUp->iAE),"Attempting to delete a record that has already been deleted.");
                pCurIdxLookUp->iAE = PAEToIdx(NULL);  //Create a dead entry in the look up table
            }
        }
        else if (pCurIdxLookUp)
        {
            // This is a change record
            CMASSERTMSG(IdxToPAE(pCurIdxLookUp->iAE),"Attempting to change a record which has been deleted.");
            if (IdxToPAE(pCurIdxLookUp->iAE))
            {
                CopyMemory(IdxToPAE(pCurIdxLookUp->iAE),&aeChange,sizeof(ACCESSENTRY));
            }
        }
        else
        {
            // This is an add entry
            // Make sure we have enough room
            if (m_cPhoneBookEntries >= dwAllocated)
            {
                // Grow phone book    
                
                dwAllocated += CHANGE_BUFFER_SIZE;
                DWORD dwNewAlloc = (DWORD) sizeof(ACCESSENTRY) * dwAllocated;
                
                PACCESSENTRY pTempAccessEntry = (PACCESSENTRY)CmRealloc(m_rgPhoneBookEntry, dwNewAlloc);
                MYDBGASSERT(pTempAccessEntry);
                
                if (!pTempAccessEntry)
                {            
                    MYDBG(("PhoneBook::Merge - Grow ReAlloc of %lu failed",dwNewAlloc));
                    goto MergeExit;
                }

                m_rgPhoneBookEntry = pTempAccessEntry;
                
                pTempAccessEntry = NULL;

                MYDBG(("Grow phone book to %lu entries",dwAllocated));

                // Grow look up index
                MYDBGASSERT(rgIdxLookUp);

                PIDXLOOKUPELEMENT pTempLookupElement = (PIDXLOOKUPELEMENT)CmRealloc(rgIdxLookUp, sizeof(IDXLOOKUPELEMENT)*dwAllocated);             
                
                MYDBGASSERT(pTempLookupElement);
                if (!pTempLookupElement)
                {
                    goto MergeExit;
                }

                rgIdxLookUp = pTempLookupElement;
            }

            //Add entry to the end of the phonebook and to end of look up index
            CopyMemory(&m_rgPhoneBookEntry[m_cPhoneBookEntries],&aeChange,sizeof(ACCESSENTRY));
            rgIdxLookUp[m_cPhoneBookEntries].iAE = PAEToIdx(&m_rgPhoneBookEntry[m_cPhoneBookEntries]);
            rgIdxLookUp[m_cPhoneBookEntries].dwIndex = IdxToPAE(rgIdxLookUp[m_cPhoneBookEntries].iAE)->dwIndex;
            m_cPhoneBookEntries++;
            // NOTE: because the entry is added to the end of the list, we can't add
            // and delete entries in the same change file.
        }
    } while (TRUE);

    // The CompareIdxLookupElementFileOrder() function needs the iAE member to be
    // a PACCESSENTRY, and not an index.  So we convert 'em here, and then we'll
    // convert 'em back later.
    for (dwIdx=0;dwIdx<m_cPhoneBookEntries;dwIdx++) {
        rgIdxLookUp[dwIdx].iAE = (LONG_PTR)IdxToPAE(rgIdxLookUp[dwIdx].iAE);
    }

    // resort the IDXLookUp index to reflect the correct order of entries
    // for the phonebook file, including all of the entries to be deleted.
    CmQSort(rgIdxLookUp,(size_t) m_cPhoneBookEntries,sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElementsFileOrder);

    // Now we convert 'em back.
    for (dwIdx=0;dwIdx<m_cPhoneBookEntries;dwIdx++) {
        rgIdxLookUp[dwIdx].iAE = PAEToIdx((PACCESSENTRY) rgIdxLookUp[dwIdx].iAE);
    }

    // Build a new phonebook file
#if 0
/*
    #define TEMP_PHONE_BOOK_PREFIX "PBH"

    if (!GetTempPath(TEMP_BUFFER_LENGTH,szTempBuffer))
        goto MergeExit;
    if (!GetTempFileName(szTempBuffer,TEMP_PHONE_BOOK_PREFIX,0,szTempFileName))
        goto MergeExit;
    hFile = CreateFile(szTempFileName,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,
        FILE_FLAG_WRITE_THROUGH,0);
*/
#else
    for (dwIdx=0;;dwIdx++)
    {
        lstrcpy(szTempFileName,m_szPhoneBook);

        wsprintf(szTempFileName+lstrlen(szTempFileName),".%03u",dwIdx);
        hFile = CreateFile(szTempFileName,GENERIC_WRITE,0,NULL,CREATE_NEW,0,0);
        if ((hFile != INVALID_HANDLE_VALUE) || (GetLastError() != ERROR_FILE_EXISTS)) {
            break;
        }
    }
#endif
    if (hFile == INVALID_HANDLE_VALUE)
    {
        goto MergeExit;
    }

    for (dwIdx = 0; dwIdx < m_cPhoneBookEntries; dwIdx++)
    {
        PACCESSENTRY pAE = IdxToPAE(rgIdxLookUp[dwIdx].iAE);

        if (pAE) {
            cch = wsprintf(szTempBuffer, "%lu,%lu,%lu,%s,%s,%s,%lu,%lu,%lu,%lu,%s\r\n",
                pAE->dwIndex,
                pAE->dwCountryID,
                (DWORD) pAE->wStateID,
                pAE->szCity,
                pAE->szAreaCode,
                pAE->szAccessNumber,
                pAE->dwConnectSpeedMin,
                pAE->dwConnectSpeedMax,
                (DWORD) pAE->bFlipFactor,
                (DWORD) pAE->fType,
                pAE->szDataCenter);

            if (!WriteFile(hFile,szTempBuffer,cch,&cchWritten,NULL))
            {
                // something went wrong, get rid of the temporary file
                hr = GetLastError();
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;
                DeleteFile(szTempFileName);
                goto MergeExit;
            }

            MYDBGASSERT(cch == cchWritten);
        }
    }

    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    // Move new phone book over old
    if (!DeleteFile(m_szPhoneBook))
    {
        hr = GetLastError();
        goto MergeExit;
    }
    if (!MoveFile(szTempFileName,m_szPhoneBook))
    {
        hr = GetLastError();
        goto MergeExit;
    }

    // discard the phonebook in memory

    CmFree(m_rgPhoneBookEntry);
    m_rgPhoneBookEntry = NULL;
    m_cPhoneBookEntries = 0;

    CmFree(m_pLineCountryList);
    CmFree(m_rgIDLookUp);
    CmFree(m_rgNameLookUp);
    CmFree(m_rgState);

    m_pLineCountryList = NULL;
    m_rgIDLookUp = NULL;
    m_rgNameLookUp = NULL;
    m_rgState = NULL;   
    m_cStates = 0;

    lstrcpy(szTempBuffer,m_szINFFile);
    m_szINFFile[0] = '\0';
    m_szPhoneBook[0] = '\0';

    //  Reload it (and rebuild look up arrays)
    hr = Init(szTempBuffer);

MergeExit:
    if (pcCSVFile)
    {
        pcCSVFile->Close();
        delete pcCSVFile;
    }
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    CmFree(rgIdxLookUp);
    
    return hr;
}

// ############################################################################
HRESULT CPhoneBook::ReadOneLine(PACCESSENTRY pAccessEntry, CCSVFile *pcCSVFile)
{
    HRESULT hr = ERROR_SUCCESS;

    //
    // Skip newlines (trailing or leading) and read first DW token
    // If either fail, then consider this the end of the file
    //

    if (!ReadPhoneBookNL(pcCSVFile) || !ReadPhoneBookDW(&pAccessEntry->dwIndex,pcCSVFile))
    {
        hr = ERROR_NO_MORE_ITEMS; // no more enteries
        MYDBG(("CPhoneBook::ReadOneLine - No More items"));
        goto ReadExit;
    }
    
    ReadVerifyPhoneBookDW(pAccessEntry->dwCountryID);
    ReadVerifyPhoneBookW(pAccessEntry->wStateID);
    ReadVerifyPhoneBookSZ(pAccessEntry->szCity,cbCity);
    ReadVerifyPhoneBookSZ(pAccessEntry->szAreaCode,cbAreaCode);
    // NOTE: 0 is a valid area code and ,, is a valid entry for an area code
    if (!FSz2Dw(pAccessEntry->szAreaCode,&pAccessEntry->dwAreaCode))
        pAccessEntry->dwAreaCode = NO_AREA_CODE;
    ReadVerifyPhoneBookSZ(pAccessEntry->szAccessNumber,cbAccessNumber);
    ReadVerifyPhoneBookDW(pAccessEntry->dwConnectSpeedMin);
    ReadVerifyPhoneBookDW(pAccessEntry->dwConnectSpeedMax);
    ReadVerifyPhoneBookB(pAccessEntry->bFlipFactor);
    ReadVerifyPhoneBookDW(pAccessEntry->fType);
    
    //
    // Attempt to read datacenter, if read fails, find out why before reacting
    //

    if (!ReadPhoneBookSZ(pAccessEntry->szDataCenter, cbDataCenter + 1, pcCSVFile))
    {
        //
        // If the last read was successful, then we must have some bad sz data
        //

        if (!pcCSVFile->ReadError())
        {
            CMASSERTMSG(0,"Invalid STRING in phone book");
            goto DataError;
        }
    }
    
ReadExit:
    return hr;
DataError:
    hr = ERROR_INVALID_DATA;
    goto ReadExit;
}

// ############################################################################
HRESULT CPhoneBook::GetCanonical (PACCESSENTRY pAE, char *psOut)
{
    HRESULT hr = ERROR_SUCCESS;
    PIDLOOKUPELEMENT pIDLookUp;

    pIDLookUp = (PIDLOOKUPELEMENT)CmBSearch(&pAE->dwCountryID,m_rgIDLookUp,
        (size_t) m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);

    if (!pIDLookUp)
    {
        hr = ERROR_INVALID_PARAMETER;
    } 
    else 
    {
        if (!psOut)
        {
            hr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            *psOut = 0;
            SzCanonicalFromAE (psOut, pAE, pIDLookUp->pLCE);
        }
    }

    return hr;
}

// ############################################################################
HRESULT CPhoneBook::GetNonCanonical (PACCESSENTRY pAE, char *psOut)
{
    HRESULT hr = ERROR_SUCCESS;
    PIDLOOKUPELEMENT pIDLookUp;

    pIDLookUp = (PIDLOOKUPELEMENT)CmBSearch(&pAE->dwCountryID,m_rgIDLookUp,
        (size_t) m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);

    if (!pIDLookUp)
    {
        hr = ERROR_INVALID_PARAMETER;
    } 
    else 
    {
        if (!psOut)
        {
            hr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            *psOut = 0;
            SzNonCanonicalFromAE (psOut, pAE, pIDLookUp->pLCE);
        }
    }

    return hr;
}

// ############################################################################
DllExportH PhoneBookLoad(LPCSTR pszISPCode, DWORD_PTR *pdwPhoneID)
{
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    CPhoneBook *pcPhoneBook;

    MYDBG(("CM_PHBK_DllExport - PhoneBookLoad"));

    if (!g_hInst) g_hInst = GetModuleHandleA(NULL);

    // validate parameters
    MYDBGASSERT(pszISPCode && *pszISPCode && pdwPhoneID);
    *pdwPhoneID = NULL;

    // allocate phone book
    pcPhoneBook = new CPhoneBook;

    // initialize phone book
    if (pcPhoneBook)
        hr = pcPhoneBook->Init(pszISPCode);

    // in case of failure
    if (hr && pcPhoneBook)
    {
        delete pcPhoneBook;
        MYDBG(("PhoneBookLoad() - init failed"));
    } else {
        *pdwPhoneID = (DWORD_PTR)pcPhoneBook;
    }

    return hr;
}

// ############################################################################
DllExportH PhoneBookUnload(DWORD_PTR dwPhoneID)
{
    MYDBG(("CM_PHBK_DllExport - PhoneBookUnload"));

    MYDBGASSERT(dwPhoneID);

    // Release contents
    delete (CPhoneBook*)dwPhoneID;

    return ERROR_SUCCESS;
}

// ############################################################################
DllExportH PhoneBookMergeChanges(DWORD_PTR dwPhoneID, LPCSTR pszChangeFile)
{
    MYDBG(("CM_PHBK_DllExport - PhoneBookMergeChanges"));

    return ((CPhoneBook*)dwPhoneID)->Merge(pszChangeFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmpbk\phbk.h ===
//+----------------------------------------------------------------------------
//
// File:     phbk.h
//
// Module:   CMPBK32.DLL
//
// Synopsis: Definitions for the CPhoneBook class
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------
#ifndef _PHBK
#define _PHBK

#define DllExportH extern "C" HRESULT WINAPI __stdcall 


//#define DllExport extern "C" __stdcall __declspec(dllexport)
//#define DllExport extern "C" __declspec(dllexport)

#define cbAreaCode	11			// maximum number of characters in an area code, not including \0
#define cbCity 31				// maximum number of chars in city name, not including \0
#define cbAccessNumber 41		// maximum number of chars in phone number, not including \0
#define cbStateName 31 			// maximum number of chars in state name, not including \0
#define cbBaudRate 6			// maximum number of chars in a baud rate, not including \0
#define cbDataCenter (MAX_PATH+1)	// max length of data center string

// Our initial allocation of memory when loading the phone book

#define PHONE_ENTRY_ALLOC_SIZE	500 	

#define NO_AREA_CODE (-1)

#define TEMP_BUFFER_LENGTH 1024

typedef struct
{
	DWORD	dwIndex;								// index number
	BYTE	bFlipFactor;							// for auto-pick
	DWORD	fType;									// phone number type
	WORD	wStateID;								// state ID
	DWORD	dwCountryID;							// TAPI country ID
	DWORD	dwAreaCode;								// area code or NO_AREA_CODE if none
	DWORD	dwConnectSpeedMin;						// minimum baud rate
	DWORD	dwConnectSpeedMax;						// maximum baud rate
	char	szCity[cbCity + sizeof('\0')];			// city name
	char	szAccessNumber[cbAccessNumber + sizeof('\0')];	// access number
	char	szDataCenter[cbDataCenter + sizeof('\0')];				// data center access string
	char	szAreaCode[cbAreaCode + sizeof('\0')];					//Keep the actual area code string around.
} ACCESSENTRY, *PACCESSENTRY; 	// ae

typedef struct {
	DWORD dwCountryID;								// country ID that this state occurred in
	LONG_PTR iFirst;									// index of first access entry for this state
	char szStateName[cbStateName + sizeof('\0')];	// state name
} STATE, *PSTATE;

typedef struct tagIDLOOKUPELEMENT {
	DWORD dwID;
	LPLINECOUNTRYENTRY pLCE;
	LONG_PTR iFirstAE;
} IDLOOKUPELEMENT, *PIDLOOKUPELEMENT;

typedef struct tagCNTRYNAMELOOKUPELEMENT {
	LPSTR psCountryName;
	DWORD dwNameSize;
	LPLINECOUNTRYENTRY pLCE;
} CNTRYNAMELOOKUPELEMENT, *PCNTRYNAMELOOKUPELEMENT;

typedef struct tagCNTRYNAMELOOKUPELEMENTW {
	LPWSTR psCountryName;
	DWORD dwNameSize;
	LPLINECOUNTRYENTRY pLCE;
} CNTRYNAMELOOKUPELEMENTW, *PCNTRYNAMELOOKUPELEMENTW;

typedef struct tagIDXLOOKUPELEMENT {
	DWORD dwIndex;
  	LONG_PTR iAE;
} IDXLOOKUPELEMENT,*PIDXLOOKUPELEMENT;

typedef void (WINAPI *CB_PHONEBOOK)(unsigned int, DWORD_PTR);

//
// CPhoneBook
//

class CPhoneBook
{

public:

	CPhoneBook();
	~CPhoneBook();

	HRESULT Init(LPCSTR pszISPCode);
	HRESULT Merge(LPCSTR pszChangeFilename);
	HRESULT GetCanonical(PACCESSENTRY pAE, char *psOut);
	HRESULT GetNonCanonical(PACCESSENTRY pAE, char *psOut);
	HRESULT GetCanonical(DWORD dwIdx, char *psOut) { return (GetCanonical(&m_rgPhoneBookEntry[dwIdx],psOut)); };
	HRESULT GetNonCanonical(DWORD dwIdx, char *psOut) { return (GetNonCanonical(&m_rgPhoneBookEntry[dwIdx],psOut)); };
	void EnumCountries(DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnCountry, DWORD_PTR dwParam);
	void EnumCountries(PPBFS pFilter, CB_PHONEBOOK pfnCountry, DWORD_PTR dwParam);
	void EnumRegions(DWORD dwCountryID, DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnCountry, DWORD_PTR dwParam);
	void EnumRegions(DWORD dwCountryID, PPBFS pFilter, CB_PHONEBOOK pfnCountry, DWORD_PTR dwParam);
	void EnumNumbersByCountry(DWORD dwCountryId, DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam);
	void EnumNumbersByCountry(DWORD dwCountryId, PPBFS pFilter, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam);
	void EnumNumbersByRegion(unsigned int nRegion, DWORD dwCountryId, DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam);
	void EnumNumbersByRegion(unsigned int nRegion, DWORD dwCountryId, PPBFS pFilter, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam);
    BOOL FHasPhoneType(PPBFS pFilter);
	BOOL FHasPhoneNumbers(DWORD dwCountryID, DWORD dwMask, DWORD fType);
	BOOL FHasPhoneNumbers(DWORD dwCountryID, PPBFS pFilter);
	LPCSTR GetCountryNameByIdx(DWORD dwIdx) { return (m_rgNameLookUp[dwIdx].psCountryName); };
	LPCWSTR GetCountryNameByIdxW(DWORD dwIdx) { return (((CNTRYNAMELOOKUPELEMENTW *)(&m_rgNameLookUp[dwIdx]))->psCountryName); };
	DWORD GetCountryIDByIdx(DWORD dwIdx) { return (m_rgNameLookUp[dwIdx].pLCE->dwCountryID); };
	LPCTSTR GetRegionNameByIdx(DWORD dwIdx) { return (m_rgState[dwIdx].szStateName); };
	LPCTSTR GetCityNameByIdx(DWORD dwIdx) { return (m_rgPhoneBookEntry[dwIdx].szCity); };
	LPCTSTR GetAreaCodeByIdx(DWORD dwIdx) { return (m_rgPhoneBookEntry[dwIdx].szAreaCode); };
	LPCTSTR GetAccessNumberByIdx(DWORD dwIdx) { return (m_rgPhoneBookEntry[dwIdx].szAccessNumber); };
	LPCTSTR GetDataCenterByIdx(DWORD dwIdx) { return (m_rgPhoneBookEntry[dwIdx].szDataCenter); };
	DWORD GetPhoneTypeByIdx(DWORD dwIdx) { return (m_rgPhoneBookEntry[dwIdx].fType); };
	DWORD GetMinBaudByIdx(DWORD dwIdx) { return (m_rgPhoneBookEntry[dwIdx].dwConnectSpeedMin); };
	DWORD GetMaxBaudByIdx(DWORD dwIdx) { return (m_rgPhoneBookEntry[dwIdx].dwConnectSpeedMax); };

private:
	ACCESSENTRY				*m_rgPhoneBookEntry;
	DWORD					m_cPhoneBookEntries;
	LINECOUNTRYENTRY		*m_rgLineCountryEntry;
	LINECOUNTRYLIST			*m_pLineCountryList;
	IDLOOKUPELEMENT			*m_rgIDLookUp;
	CNTRYNAMELOOKUPELEMENT	*m_rgNameLookUp;
	PSTATE					m_rgState;
	DWORD					m_cStates;

	char					m_szINFFile[MAX_PATH];
	char					m_szPhoneBook[MAX_PATH];

	BOOL ReadPhoneBookDW(DWORD *pdw, CCSVFile *pcCSVFile);
	BOOL ReadPhoneBookW(WORD *pw, CCSVFile *pcCSVFile);
	BOOL ReadPhoneBookSZ(LPSTR psz, DWORD dwSize, CCSVFile *pcCSVFile);
	BOOL ReadPhoneBookB(BYTE *pb, CCSVFile *pcCSVFile);
	BOOL ReadPhoneBookNL(CCSVFile *pcCSVFile);
	HRESULT ReadOneLine(PACCESSENTRY pAccessEntry, CCSVFile *pcCSVFile);

	PACCESSENTRY IdxToPAE(LONG_PTR iIdx) { return ((iIdx==0)?NULL:(m_rgPhoneBookEntry+(iIdx-1))); };
	LONG_PTR PAEToIdx(PACCESSENTRY pAE) { return ((pAE==NULL)?0:((pAE-m_rgPhoneBookEntry)+1)); };

};

extern HINSTANCE g_hInst;	// instance for this DLL

#endif // _PHBK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmpbk\misc.h ===
//+----------------------------------------------------------------------------
//
// File:     misc.h
//
// Module:   CMPBK32.DLL
//
// Synopsis: Miscellaneous phone book utility functions.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

// ############################################################################
// PROTOTYPES
void SzCanonicalFromAE (char *psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE);
void SzNonCanonicalFromAE (char *psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE);
int __cdecl CompareIDLookUpElements(const void*e1, const void*e2);
int __cdecl CompareCntryNameLookUpElementsA(const void*e1, const void*e2);
int __cdecl CompareCntryNameLookUpElementsW(const void*e1, const void*e2);
int __cdecl CompareIdxLookUpElements(const void*e1, const void*e2);
int __cdecl CompareIdxLookUpElementsFileOrder(const void *pv1, const void *pv2);
BOOL FSz2Dw(PCSTR pSz,DWORD *dw);
BOOL FSz2W(PCSTR pSz,WORD *w);
BOOL FSz2B(PCSTR pSz,BYTE *pb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmpbk\qsort.cpp ===
//+----------------------------------------------------------------------------
//
// File:     qsort.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Quick Sort Implementation (taken from libc)
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

/* prototypes for local routines */
static void __cdecl shortsort(char *lo, char *hi, unsigned width,
                int (__cdecl *comp)(const void *, const void *));
static void __cdecl swap(char *p, char *q, unsigned int width);

/* this parameter defines the cutoff between using quick sort and
   insertion sort for arrays; arrays with lengths shorter or equal to the
   below value use insertion sort */

#define CUTOFF 8            /* testing shows that this is good value */


/***
*qsort(base, num, wid, comp) - quicksort function for sorting arrays
*
*Purpose:
*       quicksort the array of elements
*       side effects:  sorts in place
*
*Entry:
*       char *base = pointer to base of array
*       unsigned num  = number of elements in the array
*       unsigned width = width in bytes of each array element
*       int (*comp)() = pointer to function returning analog of strcmp for
*               strings, but supplied by user for comparing the array elements.
*               it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*               1=2, pos if 1>2.
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

/* sort the array between lo and hi (inclusive) */

void __cdecl CmQSort (
    void *base,
    unsigned num,
    unsigned width,
    int (__cdecl *comp)(const void *, const void *)
    )
{
    char *lo, *hi;              /* ends of sub-array currently sorting */
    char *mid;                  /* points to middle of subarray */
    char *loguy, *higuy;        /* traveling pointers for partition step */
    unsigned size;              /* size of the sub-array */
    char *lostk[30], *histk[30];
    int stkptr;                 /* stack for saving sub-array to be processed */

    /* Note: the number of stack entries required is no more than
       1 + log2(size), so 30 is sufficient for any array */

    if (num < 2 || width == 0)
        return;                 /* nothing to do */

    stkptr = 0;                 /* initialize stack */

    lo = (char *)base;
    hi = (char *)base + width * (num-1);        /* initialize limits */

    /* this entry point is for pseudo-recursion calling: setting
       lo and hi and jumping to here is like recursion, but stkptr is
       prserved, locals aren't, so we preserve stuff on the stack */
recurse:

    size = PtrToUlong((PVOID)(hi - lo)) / width + 1;        /* number of el's to sort */

    /* below a certain size, it is faster to use a O(n^2) sorting method */
    if (size <= CUTOFF) {
         shortsort(lo, hi, width, comp);
    }
    else {
        /* First we pick a partititioning element.  The efficiency of the
           algorithm demands that we find one that is approximately the
           median of the values, but also that we select one fast.  Using
           the first one produces bad performace if the array is already
           sorted, so we use the middle one, which would require a very
           wierdly arranged array for worst case performance.  Testing shows
           that a median-of-three algorithm does not, in general, increase
           performance. */

        mid = lo + (size / 2) * width;      /* find middle element */
        swap(mid, lo, width);               /* swap it to beginning of array */

        /* We now wish to partition the array into three pieces, one
           consisiting of elements <= partition element, one of elements
           equal to the parition element, and one of element >= to it.  This
           is done below; comments indicate conditions established at every
           step. */

        loguy = lo;
        higuy = hi + width;

        /* Note that higuy decreases and loguy increases on every iteration,
           so loop must terminate. */
        for (;;) {
            /* lo <= loguy < hi, lo < higuy <= hi + 1,
               A[i] <= A[lo] for lo <= i <= loguy,
               A[i] >= A[lo] for higuy <= i <= hi */

            do  {
                loguy += width;
            } while (loguy <= hi && comp(loguy, lo) <= 0);

            /* lo < loguy <= hi+1, A[i] <= A[lo] for lo <= i < loguy,
               either loguy > hi or A[loguy] > A[lo] */

            do  {
                higuy -= width;
            } while (higuy > lo && comp(higuy, lo) >= 0);

            /* lo-1 <= higuy <= hi, A[i] >= A[lo] for higuy < i <= hi,
               either higuy <= lo or A[higuy] < A[lo] */

            if (higuy < loguy)
                break;

            /* if loguy > hi or higuy <= lo, then we would have exited, so
               A[loguy] > A[lo], A[higuy] < A[lo],
               loguy < hi, highy > lo */

            swap(loguy, higuy, width);

            /* A[loguy] < A[lo], A[higuy] > A[lo]; so condition at top
               of loop is re-established */
        }

        /*     A[i] >= A[lo] for higuy < i <= hi,
               A[i] <= A[lo] for lo <= i < loguy,
               higuy < loguy, lo <= higuy <= hi
           implying:
               A[i] >= A[lo] for loguy <= i <= hi,
               A[i] <= A[lo] for lo <= i <= higuy,
               A[i] = A[lo] for higuy < i < loguy */

        swap(lo, higuy, width);     /* put partition element in place */

        /* OK, now we have the following:
              A[i] >= A[higuy] for loguy <= i <= hi,
              A[i] <= A[higuy] for lo <= i < higuy
              A[i] = A[lo] for higuy <= i < loguy    */

        /* We've finished the partition, now we want to sort the subarrays
           [lo, higuy-1] and [loguy, hi].
           We do the smaller one first to minimize stack usage.
           We only sort arrays of length 2 or more.*/

        if ( higuy - 1 - lo >= hi - loguy ) {
            if (lo + width < higuy) {
                lostk[stkptr] = lo;
                histk[stkptr] = higuy - width;
                ++stkptr;
            }                           /* save big recursion for later */

            if (loguy < hi) {
                lo = loguy;
                goto recurse;           /* do small recursion */
            }
        }
        else {
            if (loguy < hi) {
                lostk[stkptr] = loguy;
                histk[stkptr] = hi;
                ++stkptr;               /* save big recursion for later */
            }

            if (lo + width < higuy) {
                hi = higuy - width;
                goto recurse;           /* do small recursion */
            }
        }
    }

    /* We have sorted the array, except for any pending sorts on the stack.
       Check if there are any, and do them. */

    --stkptr;
    if (stkptr >= 0) {
        lo = lostk[stkptr];
        hi = histk[stkptr];
        goto recurse;           /* pop subarray from stack */
    }
    else
        return;                 /* all subarrays done */
}


/***
*shortsort(hi, lo, width, comp) - insertion sort for sorting short arrays
*
*Purpose:
*       sorts the sub-array of elements between lo and hi (inclusive)
*       side effects:  sorts in place
*       assumes that lo < hi
*
*Entry:
*       char *lo = pointer to low element to sort
*       char *hi = pointer to high element to sort
*       unsigned width = width in bytes of each array element
*       int (*comp)() = pointer to function returning analog of strcmp for
*               strings, but supplied by user for comparing the array elements.
*               it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*               1=2, pos if 1>2.
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl shortsort (
    char *lo,
    char *hi,
    unsigned width,
    int (__cdecl *comp)(const void *, const void *)
    )
{
    char *p, *max;

    /* Note: in assertions below, i and j are alway inside original bound of
       array to sort. */

    while (hi > lo) {
        /* A[i] <= A[j] for i <= j, j > hi */
        max = lo;
        for (p = lo+width; p <= hi; p += width) {
            /* A[i] <= A[max] for lo <= i < p */
            if (comp(p, max) > 0) {
                max = p;
            }
            /* A[i] <= A[max] for lo <= i <= p */
        }

        /* A[i] <= A[max] for lo <= i <= hi */

        swap(max, hi, width);

        /* A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi */

        hi -= width;

        /* A[i] <= A[j] for i <= j, j > hi, loop top condition established */
    }
    /* A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
       so array is sorted */
}


/***
*swap(a, b, width) - swap two elements
*
*Purpose:
*       swaps the two array elements of size width
*
*Entry:
*       char *a, *b = pointer to two elements to swap
*       unsigned width = width in bytes of each array element
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl swap (
    char *a,
    char *b,
    unsigned width
    )
{
    char tmp;

    if ( a != b )
        /* Do the swap one character at a time to avoid potential alignment
           problems. */
        while ( width-- ) {
            tmp = *a;
            *a++ = *b;
            *b++ = tmp;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsecure\uufuncs.cpp ===
//+----------------------------------------------------------------------------
//
// File:     uufuncs.cpp
//
// Module:   CMSECURE.LIB
//
// Synopsis: uuencode and uudecode support
//
// Copyright (c) 1994-1998 Microsoft Corporation
//
// Author:	 quintinb       created header      08/18/99
//
//+----------------------------------------------------------------------------

#include <windows.h>
#include "cmuufns.h"
#include "cmdebug.h"

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

static const int pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

static const char six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL uudecode(
              const char   * bufcoded,
              CHAR   * pbuffdecoded,
              LPDWORD  pcbDecoded )
{
    DWORD nbytesdecoded;
    const char *bufin = bufcoded;
    unsigned char *bufout;
    INT32 nprbytes;

    MYDBGASSERT(pcbDecoded);

    if (!pcbDecoded)
        return FALSE;

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(pr2six[*(bufin++)] <= 63);
    nprbytes = (INT32)(bufin - bufcoded - 1);
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if (*pcbDecoded < (nbytesdecoded + 4 ))
        return FALSE;

    bufout = (unsigned char *) pbuffdecoded;

    bufin = bufcoded;

    while (nprbytes > 0) 
    {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if (nprbytes & 03) 
    {
        if (pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }
    
    *pcbDecoded = nbytesdecoded;

    pbuffdecoded[nbytesdecoded] = '\0';

    return TRUE;
}

BOOL uuencode( const BYTE*   bufin,
               DWORD    nbytes,
               CHAR * pbuffEncoded,
               DWORD    outbufmax)
{
   MYDBGASSERT(!IsBadReadPtr(bufin, nbytes));
   MYDBGASSERT(!IsBadWritePtr(pbuffEncoded, outbufmax));

   unsigned char *outptr;
   unsigned int i;

   //
   //  Resize the buffer to 133% of the incoming data
   //

   if (outbufmax < (nbytes + ((nbytes + 3) / 3) + 4))
   {
       CMASSERTMSG(FALSE, "The outputbuf for uuencode is not large enough");
       return FALSE;
   }

   outptr = (unsigned char *) pbuffEncoded;

   //
   // Encode 3 byte at a time
   //
   for (i=0; i<(nbytes/3)*3; i += 3) 
   {
      *(outptr++) = six2pr[bufin[i] >> 2];            /* c1 */
      *(outptr++) = six2pr[((bufin[i] << 4) & 060) | ((bufin[i+1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[i+1] << 2) & 074) | ((bufin[i+2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[i+2] & 077];         /* c4 */
   }

   /* If nbytes was not a multiple of 3, then we have encoded too
    * many characters.  Adjust appropriately.
    */
   if (i+2 == nbytes) 
   {
      /* There were only 2 bytes in that last group */
      *(outptr++) = six2pr[bufin[i] >> 2];            /* c1 */
      *(outptr++) = six2pr[((bufin[i] << 4) & 060) | ((bufin[i+1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[(bufin[i+1] << 2) & 074];/*c3*/
      *(outptr++) = '=';         /* c4 */
   } 
   else 
   {
       if (i+1 == nbytes) 
       {

          /* There was only 1 byte in that last group */
          *(outptr++) = six2pr[bufin[i] >> 2];            /* c1 */
          *(outptr++) = six2pr[(bufin[i] << 4) & 060]; /*c2*/
          *(outptr++) = '=';                             /*c3*/
          *(outptr++) = '=';                             /*c4*/
       }
       else
       {
           MYDBGASSERT(i == nbytes);
       }
   }

   *outptr = '\0';

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsetup\cfilename.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cfilename.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the CFileNameParts Class
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header    08/19/99
//
//+----------------------------------------------------------------------------
#include "cfilename.h"

CFileNameParts::CFileNameParts(LPCTSTR szFullPath)
{

	if (NULL == szFullPath)
	{
		CMASSERTMSG(FALSE, TEXT("NULL Input to CFileNameParts"));
		return;
	}

    MYDBGASSERT(MAX_PATH >= lstrlen(szFullPath));


    ZeroMemory(m_szFullPath, sizeof(m_szFullPath));
    ZeroMemory(m_Drive, sizeof(m_Drive));
    ZeroMemory(m_Dir, sizeof(m_Dir));
    ZeroMemory(m_FileName, sizeof(m_FileName));
    ZeroMemory(m_Extension, sizeof(m_Extension));

	TCHAR* pszStart = m_szFullPath;
	const TCHAR* pszCurrentSource = szFullPath;
	TCHAR* pszLastSlash = NULL;
	TCHAR* pszColon = NULL;
	TCHAR* pszLastDot = NULL;
	TCHAR* pszCurrentDest = m_szFullPath;


    //
    //  Copy szFullPath to m_szFullPath
    //
    lstrcpy(m_szFullPath, szFullPath);


	while ((TEXT('\0') != *pszCurrentSource) && (MAX_PATH >= (pszCurrentSource - szFullPath)))
	{
		switch(*pszCurrentSource)
		{
		case TEXT(':'):
			//
			//	Found a colon, take the drive letter.
			//
			if ((NULL == pszColon) && (pszCurrentDest != m_szFullPath) &&
				(m_szFullPath == CharPrev(m_szFullPath, pszCurrentDest)))
			{
				pszColon = pszCurrentDest;
				lstrcpyn(m_Drive, pszStart, (size_t)((pszCurrentDest - pszStart) + 2));
				pszStart = CharNext(pszColon);
			}
			else
			{
				CMASSERTMSG(FALSE, TEXT("CFileNameParts -- Error, we only allow one colon in a path."));
				return;
			}
			break;

		case TEXT('\\'):
		case TEXT('/'):
			pszLastSlash = pszCurrentDest;
			break;

		case TEXT('.'):
			pszLastDot = pszCurrentDest;
			break;

		}
		
        pszCurrentSource = CharNext(pszCurrentSource);
        pszCurrentDest = CharNext(pszCurrentDest);
	}

	if (pszLastSlash)
	{
		lstrcpyn(m_Dir, pszStart, (size_t)((pszLastSlash - pszStart) + 2));
		pszStart = CharNext(pszLastSlash) ;
	}

	if (pszLastDot && (pszLastDot > pszLastSlash))
	{
		lstrcpyn(m_FileName, pszStart, (size_t)((pszLastDot - pszStart) + 1));
		lstrcpyn(m_Extension, pszLastDot, _MAX_EXT+1);
	}
	else
	{
		//
		//	No extension
		//
		lstrcpyn(m_FileName, pszStart, _MAX_FNAME+1);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsecure\cmsecure.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmsecure.cpp
//
// Module:   CMSECURE.LIB
//
// Synopsis: CM Crypto APIs
//           Three methods are support for decryption:
//              CBCEncryption         CMSECURE_ET_CBC_CIPHER
//              Simple xor encryption CMSECURE_ET_STREAM_CIPHER
//              CryptoApi             CMSECURE_ET_RC2
//           Two methods are supported for encryption
//              CBCEncryption
//              CryptoApi
//
//           CBCEncryption algorithm: Cipher Block Chaining Mode with initializing variable
//                EnCipher: C[i] = E[k](p[i] XOR C[i-1])
//                DeCipher: P[i] = C[i-1] XOR D[k](C[i])
//                   P: Plain text
//                   C: Cipher text
//                   E[k]: Encryption function with key
//                   D[k]: Decryption function with key
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   henryt     created                         05/21/97
//           fengsun    changed encryption algorithm    08/21/97
//
//+----------------------------------------------------------------------------
#include "cryptfnc.h"
#include "userinfo_str.h"

//////////////////////////////////////////////////////////////////////////
// defines
//////////////////////////////////////////////////////////////////////////

// we want 40-bit encryption exactly for pre-shared key
const DWORD c_dwEncryptKeyLength = 40;

//
// the max len for the const string for session key generation
//
#define MAX_KEY_STRING_LEN                      40
#define EXTRA_UUDECODE_BUF_LEN                  10

//////////////////////////////////////////////////////////////////////////
// Globals
//////////////////////////////////////////////////////////////////////////

static CCryptFunctions*  g_pCryptFnc = NULL;
static long g_nRefCount=0;   // the reference count, CryptoApi is unloaded when the count is 0
static BOOL g_fFastEncryption;

//
// the const string for session key generation
//
static const TCHAR gc_szKeyStr[] = TEXT("Please enter your password");

//////////////////////////////////////////////////////////////////////////
// Func prototypes
//////////////////////////////////////////////////////////////////////////

static int CBCEncipherData(const char* pszKey, const BYTE* pbData, int dwDataLength, 
                       BYTE* pbOut, int dwOutBufferLength);
static int CBCDecipherData(const char* pszKey, const BYTE* pbData, int dwDataLength, 
                       BYTE* pbOut, int dwOutBufferLength);
inline int CBCDecipherBufferSize(int dataSize);
inline int CBCEncipherBufferSize(int dataSize);


static BOOL 
StreamCipherEncryptData(
    LPTSTR          pszKey,              // password    
    LPBYTE          pbData,              // Data to be encrypted
    DWORD           dwDataLength,        // Length of data in bytes
    LPBYTE          *ppbEncryptedData,     // Encrypted secret key will be stored here
    DWORD           *pdwEncryptedBufferLen, // Length of this buffer
    PFN_CMSECUREALLOC  pfnAlloc,
    PFN_CMSECUREFREE   pfnFree
);

static BOOL 
StreamCipherDecryptData(
    LPTSTR          pszKey,              // password    
    LPBYTE          pbEncryptedData,     // Encrypted data
    DWORD           dwEncrytedDataLen,   // Length of encrypted data
    LPBYTE          *ppbData,            // Decrypted Data will be stored here
    DWORD           *pdwDataBufferLength,// Length of the above buffer in bytes
    PFN_CMSECUREALLOC  pfnAlloc,
    PFN_CMSECUREFREE   pfnFree,
    DWORD           dwEncryptionType
);

static LPTSTR 
reverse(
    LPTSTR  s
);

static void
GenerateKeyString(
    IN OUT  LPTSTR  pszBuf,
    IN      DWORD   dwBufLen
);

static BOOL SetKeyString(IN OUT  LPTSTR  pszBuf, IN DWORD dwBufLen, IN DWORD dwEncryptionType,
                         IN  PFN_CMSECUREALLOC  pfnAlloc,
                         IN  PFN_CMSECUREFREE   pfnFree,
                         IN LPSTR pszUserKey,
                         OUT BOOL *pfMoreSecure);

static BOOL GetKeyString(IN OUT  LPTSTR  pszBuf, IN DWORD * pdwBufLen, IN DWORD dwEncryptionType, 
                         IN  PFN_CMSECUREALLOC  pfnAlloc,
                         IN  PFN_CMSECUREFREE   pfnFree,
                         IN LPSTR pszUserKey,
                         OUT BOOL *pfMoreSecure);

static BOOL GetCurrentKey(PTCHAR szTempKeyStr, DWORD dwTempKeyStrMaxLen, 
                   IN  PFN_CMSECUREALLOC  pfnAlloc,
                   IN  PFN_CMSECUREFREE   pfnFree);

//////////////////////////////////////////////////////////////////////////
// Implementations
//////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Function:   InitCryptoApi
//
//  Synopsis:   Initialize the CryptoApi.
//
//  Arguments:  
//
//  Returns:    Pointer to  CCryptFunctions, if success
//              NULL if failure
//
//  History:    fengsun Created     8/22/97
//
//----------------------------------------------------------------------------

static CCryptFunctions* InitCryptoApi()
{
    CCryptFunctions* pCryptFnc = new CCryptFunctions();

    if (pCryptFnc == NULL)
        return NULL;

    if (pCryptFnc->InitCrypt()) 
    {
        return pCryptFnc;
    }
    else
    {
        delete pCryptFnc;
        return NULL;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   InitSecure
//
//  Synopsis:   Initialize the security/encryption routines.
//
//  Arguments:  fFastEncryption : TRUE will use a faster algorithm vs a more secure one
//
//  Returns:    TRUE if success, always return TRUE
//              FALSE if failure
//
//  History:    henryt  Created     5/20/97
//              fengsun modified 
//
//----------------------------------------------------------------------------

BOOL
InitSecure(
    BOOL fFastEncryption
)
{
    MYDBGASSERT(g_nRefCount>=0);
    InterlockedIncrement(&g_nRefCount);

    //
    // If already initialized, increase the RefCount and return
    //
    if (g_nRefCount>1)
    {
        return TRUE;
    }

    MYDBGASSERT(g_pCryptFnc == NULL); // not initialized yet

    g_fFastEncryption = fFastEncryption;

    if (!fFastEncryption)
    {
        //
        // CryptoApi is slow on Win95
        // If more secure is desired, try the CryptoApi
        // Ignore return value of InitCrypt()
        //
        g_pCryptFnc = InitCryptoApi();
    }

    //
    // CryptoApi is not available for Win95 Gold
    // we'll use stream cipher.
    //

    return TRUE; 
}



//+---------------------------------------------------------------------------
//
//  Function:   DeInitSecure
//
//  Synopsis:   Clean up function for the security/encryption routines.
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    henryt  Created     5/20/97
//
//----------------------------------------------------------------------------

void
DeInitSecure(
    void
)
{
    MYDBGASSERT(g_nRefCount>=1);

    //
    // DeInit the CryptoApi if RefCount is down to 0
    //
    if (InterlockedDecrement(&g_nRefCount) <=0)    // if ( (--g_nRefCount) <=0 )
    {
        if (g_pCryptFnc)
        {
            delete g_pCryptFnc;
            g_pCryptFnc = NULL;
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   StreamCipherEncryptData
//
//  Synopsis:   data encryption using stream cipher algorithm.
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    henryt  Created     6/9/97
//              fengsun modified    8/21/97 
//                                  to use Cipher Block Chaning Mode Algorithm
//
//----------------------------------------------------------------------------

static BOOL 
StreamCipherEncryptData(
    LPTSTR          pszKey,              // password    
    LPBYTE          pbData,              // Data to be encrypted
    DWORD           dwDataLength,        // Length of data in bytes
    LPBYTE          *ppbEncryptedData,     // Encrypted secret key will be stored here
    DWORD           *pdwEncryptedBufferLen, // Length of this buffer
    PFN_CMSECUREALLOC  pfnAlloc,
    PFN_CMSECUREFREE   pfnFree
)
{

    LPBYTE  pbTmpBuf = NULL;
    BOOL    fOk = FALSE;
    BOOL    fRet;

    if (!pszKey || !pbData || !dwDataLength || !ppbEncryptedData || !pdwEncryptedBufferLen)
    {
        CMASSERTMSG(FALSE, TEXT("StreamCipherEncryptData - invalid input params"));
        return FALSE;
    }

    //
    // Alloc a buffer to hold enciphered data
    //
    DWORD dwEncipherBufferLen = CBCEncipherBufferSize(dwDataLength);

    if (pfnAlloc)
    {
        pbTmpBuf = (LPBYTE)pfnAlloc(dwEncipherBufferLen);
    }
    else
    {
        pbTmpBuf = (LPBYTE)HeapAlloc(GetProcessHeap(), 
                                     HEAP_ZERO_MEMORY,
                                     dwEncipherBufferLen);
    }
    if (!pbTmpBuf)
    {
        goto cleanup;
    }


    //
    // encipher the data
    //

    dwEncipherBufferLen = CBCEncipherData(pszKey, pbData, dwDataLength, pbTmpBuf, dwEncipherBufferLen);

    //
    // we now have the data encrypted.  we need to uuencode it.
    //
    DWORD   cbBuf;
    cbBuf = 2*dwEncipherBufferLen + EXTRA_UUDECODE_BUF_LEN;     // enough for uuencode

    if (pfnAlloc)
    {
        *ppbEncryptedData = (LPBYTE)pfnAlloc(cbBuf);
    }
    else
    {
        *ppbEncryptedData = (LPBYTE)HeapAlloc(GetProcessHeap(), 
                                              HEAP_ZERO_MEMORY,
                                              cbBuf);
    }
    if (!*ppbEncryptedData)
    {
        goto cleanup;
    }

    
    fRet = uuencode(pbTmpBuf, dwEncipherBufferLen, (CHAR*)*ppbEncryptedData, cbBuf);

    MYDBGASSERT(fRet);

    if (!fRet)
    {
        if (pfnFree)
        {
            pfnFree(*ppbEncryptedData);
        }
        else
        {
            HeapFree(GetProcessHeap(), 0, *ppbEncryptedData);
        }
        *ppbEncryptedData = NULL;

        goto cleanup;
    }

    //
    // set the encrypted buffer len
    //
    *pdwEncryptedBufferLen = lstrlen((LPSTR)*ppbEncryptedData);

    fOk = TRUE;

cleanup:
    if (pbTmpBuf)
    {
        if (pfnFree)
        {
            pfnFree(pbTmpBuf);
        }
        else
        {
            HeapFree(GetProcessHeap(), 0, pbTmpBuf);
        }
    }

    return fOk;
}



//+---------------------------------------------------------------------------
//
//  Function:   StreamCipherDecryptData
//
//  Synopsis:   data decryption using stream cipher algorithm.
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    henryt  Created     6/9/97
//              fengsun modified    8/21/97 
//                                  to use Cipher Block Chaning Modem Algorithm
//
//----------------------------------------------------------------------------

static BOOL 
StreamCipherDecryptData(
    LPTSTR          pszKey,              // password    
    LPBYTE          pbEncryptedData,     // Encrypted data
    DWORD           dwEncryptedDataLen,   // Length of encrypted data
    LPBYTE          *ppbData,            // Decrypted Data will be stored here
    DWORD           *pdwDataBufferLength,// Length of the above buffer in bytes
    PFN_CMSECUREALLOC  pfnAlloc,
    PFN_CMSECUREFREE   pfnFree,
    DWORD           dwEncryptionType
)
{
    BOOL    fRet = FALSE;
    DWORD   dwUUDecodeBufLen;

    if (!pszKey || !pbEncryptedData || !dwEncryptedDataLen || !pdwDataBufferLength)
    {
        CMASSERTMSG(FALSE, TEXT("StreamCipherDecryptData - invalid input params"));
        return FALSE;
    }

    //
    // set uudecode output buf size
    //
    dwUUDecodeBufLen = dwEncryptedDataLen + EXTRA_UUDECODE_BUF_LEN;

    //
    // alloc memory for output buffer
    //
    if (pfnAlloc)
    {
        *ppbData = (LPBYTE)pfnAlloc(dwUUDecodeBufLen);
    }
    else
    {
        *ppbData = (LPBYTE)HeapAlloc(GetProcessHeap(),
                                     HEAP_ZERO_MEMORY,
                                     dwUUDecodeBufLen);
    }
    if (!*ppbData)
    {
        goto cleanup;
    }

    //
    // uudecode it first
    //

    fRet = uudecode((char*)pbEncryptedData, (CHAR*)*ppbData, &dwUUDecodeBufLen);

    MYDBGASSERT(fRet);

    if (!fRet)
    {
        if (pfnFree)
        {
            pfnFree(*ppbData);
        }
        else
        {
            HeapFree(GetProcessHeap(), 0, *ppbData);
        }
        *ppbData = NULL;

        goto cleanup;
    }

    switch(dwEncryptionType)
    {
    case CMSECURE_ET_STREAM_CIPHER:
        {
            //
            //  Simple decipher algorithm used in old version
            //

            DWORD   dwLen = lstrlen(pszKey);

            if (dwLen)
            {
                for (DWORD dwIdx = 0; dwIdx < dwUUDecodeBufLen; dwIdx++)
                {
                    *(*ppbData + dwIdx) ^= pszKey[dwIdx % dwLen];
                }

                *pdwDataBufferLength = dwUUDecodeBufLen;

                fRet = TRUE;
            }
        }
        break;

    case CMSECURE_ET_CBC_CIPHER:
        //
        // Inplace decipher  
        //
        *pdwDataBufferLength = CBCDecipherData(pszKey, *ppbData, dwUUDecodeBufLen, 
                                            *ppbData, dwUUDecodeBufLen);
        fRet = TRUE;

        break;
    default:
        MYDBGASSERT(FALSE);
    }

cleanup:
    return fRet;
}



//+---------------------------------------------------------------------------
//
//  Function:   EncryptData
//
//  Synopsis:   Encrypt the data buffer.
//
//  Arguments:  IN  PBYTE   pbData,                 // Data to be encrypted                    
//              IN  DWORD   dwDataLength,           // Length of data in bytes                 
//              OUT PBYTE   pbEncryptedData,        // Encrypted secret key will be stored here
//              OUT DWORD   *pdwEncrytedBufferLen   // Length of this buffer                   
//              IN  PCMSECUREALLOC  pfnAlloc        // memory allocator(if NULL, then the default is used.   
//                                                  //      Win32 - HeapAlloc(GetProcessHeap(), ...)         
//              IN  PCMSECUREFREE   pfnFree         // memory deallocator(if NULL, then the default is used. 
//                                                  //      Win32 - HeapFree(GetProcessHeap(), ...)          
//              IN  LPTSTR  pszUserKey              // Reg key where to store encrypted key
//
//  Returns:    TRUE if success
//              FALSE if failure
//
//  History:    henryt  Created     5/20/97
//
//----------------------------------------------------------------------------

BOOL
EncryptData(
    IN  LPBYTE  pbData,                 // Data to be encrypted
    IN  DWORD   dwDataLength,           // Length of data in bytes
    OUT LPBYTE  *ppbEncryptedData,      // Encrypted secret key will be stored here
    OUT LPDWORD pdwEncrytedBufferLen,  // Length of this buffer
    OUT LPDWORD pEncryptionType,        // type of the encryption used
    IN  PFN_CMSECUREALLOC  pfnAlloc,
    IN  PFN_CMSECUREFREE   pfnFree,
    IN  LPSTR   pszUserKey
)
{
    BOOL    fOk = FALSE;
    TCHAR   szKeyStr[MAX_KEY_STRING_LEN + 1]={0};
    BOOL    fMoreSecure = FALSE;

    DWORD dwUseKey = *pEncryptionType;

    //
    // get a key string for session key generation
    //
    SetKeyString(szKeyStr, MAX_KEY_STRING_LEN, dwUseKey, pfnAlloc, pfnFree, pszUserKey, &fMoreSecure);

    *pEncryptionType = CMSECURE_ET_NOT_ENCRYPTED;
   
    //
    // If user want use CryptoApi and it is available
    //
    if (!g_fFastEncryption && g_pCryptFnc)
    {
        //
        // encrypt the data with the key string
        //
        if (fOk = g_pCryptFnc->EncryptDataWithKey(
            szKeyStr,                       // Key
            pbData,                         // Secret key
            dwDataLength,                   // Length of secret key
            ppbEncryptedData,               // Encrypted data will be stored here
            pdwEncrytedBufferLen,           // Length of this buffer
            pfnAlloc,                       // mem allocator
            pfnFree,                        // mem deallocator
            0))                             // not specifying keylength
        {
            *pEncryptionType = CMSECURE_ET_RC2;

            //
            // If the key is randomly generated then we want to make sure we 
            // set the random key mask
            //
            if (fMoreSecure)
            {
                *pEncryptionType |= CMSECURE_ET_RANDOM_KEY_MASK;
            }
        }
    }

    if (!fOk)
    {
        if (fOk = StreamCipherEncryptData(
            szKeyStr,                       // Key
            pbData,                         // Secret key
            dwDataLength,                   // Length of secret key
            ppbEncryptedData,               // Encrypted data will be stored here
            pdwEncrytedBufferLen,           // Length of this buffer
            pfnAlloc,                       // mem allocator
            pfnFree))                       // mem deallocator
        {
            *pEncryptionType = CMSECURE_ET_CBC_CIPHER;
            
            //
            // If the key is randomly generated then we want to make sure we 
            // set the random key mask
            //
            if (fMoreSecure)
            {
                *pEncryptionType |= CMSECURE_ET_RANDOM_KEY_MASK;
            }
        }
    }

    ZeroMemory((LPVOID)szKeyStr, sizeof(szKeyStr));

    return fOk;
}


//+---------------------------------------------------------------------------
//
//  Function:   DecryptData
//
//  Synopsis:   Decrypt the data buffer.
//
//  Arguments:  IN  PBYTE   pbEncryptedData,        // Encrypted data                      
//              IN  DWORD   dwEncrytedDataLen       // Length of encrypted data            
//              OUT PBYTE   *ppbData,               // Decrypted Data will be stored here  
//              OUT DWORD   *pdwDataBufferLength,   // Length of the above buffer in bytes 
//              IN  PCMSECUREALLOC  pfnAlloc        // memory allocator(if NULL, then the default is used.   
//                                                  //      Win32 - HeapAlloc(GetProcessHeap(), ...)         
//              IN  PCMSECUREFREE   pfnFree         // memory deallocator(if NULL, then the default is used. 
//                                                  //      Win32 - HeapFree(GetProcessHeap(), ...)          
//              IN  LPTSTR  pszUserKey              // Reg key where to store encrypted key
//
//  Returns:    TRUE if success
//              FALSE if failure
//
//  History:    henryt  Created     5/20/97
//
//----------------------------------------------------------------------------

BOOL
DecryptData(
    IN  LPBYTE          pbEncryptedData,        // Encrypted data
    IN  DWORD           dwEncrytedDataLen,      // Length of encrypted data
    OUT LPBYTE          *ppbData,               // Decrypted Data will be stored here
    OUT LPDWORD         pdwDataBufferLength,    // Length of the above buffer in bytes
    IN  DWORD           dwEncryptionType,       // encryption type for decryption
    IN  PFN_CMSECUREALLOC  pfnAlloc,
    IN  PFN_CMSECUREFREE   pfnFree,
    IN  LPSTR           pszUserKey
)
{
    TCHAR   szKeyStr[MAX_KEY_STRING_LEN + 1]={0}; // Plus NULL
    DWORD   dwRet = 0xf;        // some non-zero value
    BOOL fMoreSecure = FALSE;

    //
    // To speed things up we only want to generate a key
    // in case the data is encrypted
    //
    if (CMSECURE_ET_NOT_ENCRYPTED != dwEncryptionType)
    {
        //
        // get a key string for session key generation
        //

        //
        // Here we don't care if the pszUserKey is NULL, the called function will determine
        // this and set fMoreSecure appropriately. Right now we don't check for the random key mask 
        // in dwEncryptionType, but if it isn't set the blob (encrypted key) will not be in the registry 
        // thus it will try to default to using the hardcoded key. This should probably be made more explicit
        // in the code at a later time.
        //
        DWORD dwMaxSize = MAX_KEY_STRING_LEN;
        GetKeyString(szKeyStr, &dwMaxSize, dwEncryptionType, pfnAlloc, pfnFree, pszUserKey, &fMoreSecure);
    
        //
        // If the random key bit mask is set, we better have have fMoreSecure flag set to true.
        // This has to be always true in order for decryption to work
        // 
        CMASSERTMSG(((dwEncryptionType & CMSECURE_ET_RANDOM_KEY_MASK) && fMoreSecure), TEXT("DecryptData - Trying to use mismatched keys"));
    }

    // 
    // Clear the random key mask 
    //
    dwEncryptionType &= ~CMSECURE_ET_RANDOM_KEY_MASK;
    dwEncryptionType &= ~CMSECURE_ET_USE_SECOND_RND_KEY;

    switch (dwEncryptionType)
    {
        case CMSECURE_ET_RC2:
            if (g_fFastEncryption && !g_pCryptFnc)
            {
                //
                // if we want fast encryption initially,
                // We have to initialize the CryptoApi now
                //
                g_pCryptFnc = InitCryptoApi();
            }

            if (g_pCryptFnc)
            {
                dwRet = g_pCryptFnc->DecryptDataWithKey(
                            szKeyStr,                // Key
                            pbEncryptedData,         // Encrypted data
                            dwEncrytedDataLen,       // Length of encrypted data
                            ppbData,                 // decrypted data
                            pdwDataBufferLength,     // Length of decrypted data
                            pfnAlloc,                // mem allocator
                            pfnFree,                 // mem deallocator
                            0);                      // not specifying keylength
                            
            }
            break;

        case CMSECURE_ET_STREAM_CIPHER:
        case CMSECURE_ET_CBC_CIPHER:
            //
            // Use our own encryption algorithm
            //
            dwRet = (DWORD)!StreamCipherDecryptData(
                        szKeyStr,                // Key
                        pbEncryptedData,         // Encrypted data
                        dwEncrytedDataLen,       // Length of encrypted data
                        ppbData,                 // decrypted data
                        pdwDataBufferLength,     // Length of decrypted data
                        pfnAlloc,                // mem allocator
                        pfnFree,                 // mem deallocator
                        dwEncryptionType         // Encryption type used
                        );
            break;

        case CMSECURE_ET_NOT_ENCRYPTED:
            // 
            // Just copy the exact contents into the OUT buffer
            //
            if (pbEncryptedData && dwEncrytedDataLen && 
                ppbData && pdwDataBufferLength)
            {
                if (pfnAlloc)
                {
                    *ppbData = (LPBYTE)pfnAlloc(dwEncrytedDataLen);
                }
                else
                {
                    *ppbData = (LPBYTE)HeapAlloc(GetProcessHeap(), 
                                                 HEAP_ZERO_MEMORY,
                                                 dwEncrytedDataLen);
                }
                
                if (*ppbData)
                {
                    CopyMemory(*ppbData, pbEncryptedData, dwEncrytedDataLen);
                    *pdwDataBufferLength = dwEncrytedDataLen;
                    dwRet = 0; // the return statement correctly returns TRUE 
                }
            }

            break;

        default:
            MYDBGASSERT(FALSE);
            break;
    }
    
    ZeroMemory((LPVOID)szKeyStr, sizeof(szKeyStr));

    return (!dwRet);
}


//+----------------------------------------------------------------------------
//
// Func:    EncryptString
//
// Desc:    encrypt a given (Ansi) string using RC2 encryption
//
// Args:    pszToEncrypt         -- Ansi string to be encrypted
//          pszUserKey           -- Key to use for Encryption
//          ppbEncryptedData     -- Encrypted secret key will be stored here(memory will be allocated)
//          pdwEncrytedBufferLen -- Length of this buffer
//
// Return:  BOOL (FALSE if a fatal error occurred, else TRUE)
//
// Notes:   The encryption type must be at least RC2, and exactly 40-bit
//
//-----------------------------------------------------------------------------
BOOL
EncryptString(
    IN  LPSTR           pszToEncrypt,           // Ansi string to be encrypted
    IN  LPSTR           pszUserKey,             // Key to use for Encryption
    OUT LPBYTE *        ppbEncryptedData,       // Encrypted secret key will be stored here(memory will be allocated)
    OUT LPDWORD         pdwEncrytedBufferLen,   // Length of this buffer
    IN  PFN_CMSECUREALLOC  pfnAlloc,
    IN  PFN_CMSECUREFREE   pfnFree
)
{
    BOOL fOk = FALSE;

    CMASSERTMSG(pszToEncrypt, TEXT("EncryptData - first arg must be a valid string"));
    CMASSERTMSG(pszUserKey,  TEXT("EncryptData - second arg must be a valid user key"));

    DWORD dwDataLength = lstrlen(pszToEncrypt) + 1; // get the NULL in as well.

    if (!g_fFastEncryption && g_pCryptFnc)
    {
        if (fOk = g_pCryptFnc->EncryptDataWithKey(
            pszUserKey,                     // Key
            (LPBYTE)pszToEncrypt,           // Secret key
            dwDataLength,                   // Length of secret key
            ppbEncryptedData,               // Encrypted data will be stored here
            pdwEncrytedBufferLen,           // Length of this buffer
            pfnAlloc,
            pfnFree,
            c_dwEncryptKeyLength))
        {
            CMTRACE(TEXT("EncryptString - succeeded."));
        }
    }

    return fOk;
}


//+----------------------------------------------------------------------------
//
// Func:    DecryptString
//
// Desc:    encrypt a given (Ansi) string using RC2 encryption
//
// Args:    pszToEncrypt         -- Ansi string to be encrypted
//          pszUserKey           -- Key to use for Encryption
//          ppbEncryptedData     -- Encrypted secret key will be stored here(memory will be allocated)
//          pdwEncrytedBufferLen -- Length of this buffer
//
// Return:  BOOL (FALSE if a fatal error occurred, else TRUE)
//
// Notes:   The encryption type must be at least RC2, and exactly 40-bit
//
//-----------------------------------------------------------------------------
BOOL
DecryptString(
    IN  LPBYTE          pbEncryptedData,        // Encrypted data
    IN  DWORD           dwEncrytedDataLen,      // Length of encrypted data
    IN  LPSTR           pszUserKey,             // Registry key to store encrypted key for passwords
    OUT LPBYTE *        ppbData,                // Decrypted Data will be stored here
    OUT LPDWORD         pdwDataBufferLength,    // Length of the above buffer in bytes
    IN  PFN_CMSECUREALLOC  pfnAlloc,
    IN  PFN_CMSECUREFREE   pfnFree

)
{
    DWORD   dwRet = 0xf;        // some non-zero value

    if (!g_fFastEncryption && g_pCryptFnc)
    {
        dwRet = g_pCryptFnc->DecryptDataWithKey(
                    pszUserKey,              // Key
                    pbEncryptedData,         // Encrypted data
                    dwEncrytedDataLen,       // Length of encrypted data
                    ppbData,                 // decrypted data
                    pdwDataBufferLength,     // Length of decrypted data
                    pfnAlloc,
                    pfnFree,
                    c_dwEncryptKeyLength);   // 40-bit
    }

    return (!dwRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   CBCEncipherBufferSize
//
//  Synopsis:   Get the buffer size needed for Enciphering
//
//  Arguments:  dataSize sizeof data to be enciphered
//
//  Returns:    Encipher buffer size needed
//
//  History:    fengsun Created     8/21/97
//
//----------------------------------------------------------------------------

inline int CBCEncipherBufferSize(int dataSize)
{
    MYDBGASSERT(dataSize > 0);    

    //
    // We need one byte to hold the initializing variable
    //

    return dataSize + 1;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBCDecipherBufferSize
//
//  Synopsis:   Get the buffer size needed for Deciphering
//
//  Arguments:  dataSize sizeof data to be Deciphered
//
//  Returns:    Decipher buffer size needed
//
//  History:    fengsun Created     8/21/97
//
//----------------------------------------------------------------------------
inline int CBCDecipherBufferSize(int dataSize)
{
    MYDBGASSERT(dataSize > 1);    
    return dataSize - 1;
}

//+---------------------------------------------------------------------------
//
//  Function:   EncryptByte
//
//  Synopsis:   Encrypt a single byte
//
//  Arguments:  pszKey  key string
//              byteSource byte to be encrypted
//              param   aditional parameter for encryption
//
//  Returns:    byte encrypted
//
//  History:    fengsun Created     8/21/97
//
//----------------------------------------------------------------------------

inline BYTE EncryptByte(LPCTSTR pszKey, BYTE byteSource, BYTE Param)
{
    if (NULL == pszKey)
    {
        return NULL;
    }

    DWORD   dwLen = lstrlen(pszKey);

    if (0 == dwLen)
    {
        return NULL;
    }

    return ((byteSource ^ (BYTE)pszKey[Param % dwLen]) + Param);
}

//+---------------------------------------------------------------------------
//
//  Function:   DecryptByte
//
//  Synopsis:   Decrypt a single byte
//
//  Arguments:  pszKey  key string
//              byteSource byte to be Decrypted
//              param   aditional parameter for encryption
//
//  Returns:    byte decrypted
//
//  History:    fengsun Created     8/21/97
//
//----------------------------------------------------------------------------

inline BYTE DecryptByte(LPCTSTR pszKey, BYTE byteSource, BYTE Param)
{
    if (NULL == pszKey)
    {
        return NULL;
    }

    DWORD   dwLen = lstrlen(pszKey);

    if (0 == dwLen)
    {
        return NULL;
    }

    return ((byteSource - Param) ^ (BYTE)pszKey[Param % dwLen]);
}

//+---------------------------------------------------------------------------
//
//  Function:   CBCEncipherData
//
//  Synopsis:   Encipher a block of data
//
//  Arguments:  pszKey  key string
//              pbData  Data to be enciphered
//              dwDataLength size of pbData
//              pbOut   Buffer for encipher result
//              dwOutBufferLength size of pbOut, must be >= CBCEncipherBufferSize(dwDataLength)
//
//  Returns:    size of encipher byte in pbOut, 0 means failed
//
//  History:    fengsun Created     8/21/97
//
//----------------------------------------------------------------------------
static int CBCEncipherData(const char* pszKey, const BYTE* pbData, int dwDataLength, 
                       BYTE* pbOut, int dwOutBufferLength)
{
    MYDBGASSERT(pszKey != NULL);    
    MYDBGASSERT(pbData != NULL);    
    MYDBGASSERT(pbOut != NULL);    
    MYDBGASSERT(dwDataLength > 0);    
    MYDBGASSERT(pbData != pbOut);

    if (dwDataLength <= 0)
        return 0;

    if (dwOutBufferLength < CBCEncipherBufferSize(dwDataLength))
        return 0;

    dwOutBufferLength = CBCEncipherBufferSize(dwDataLength);

    //
    // Add a random number as the initializing variable (first byte)
    //
    pbOut[0] = (BYTE)((GetTickCount() >> 4 ) % 256);


    //
    // encipher it
    //
    // EnCipher: C[i] = E[k](p[i] XOR C[i-1])
    //

    BYTE lastPlainText = pbOut[0];   //first initilizing byte
    pbOut[0] = EncryptByte(pszKey, pbOut[0], 0);
    for (int dwIdx=1; dwIdx<dwOutBufferLength; dwIdx++)
    {
        pbOut[dwIdx] = EncryptByte(pszKey, pbData[dwIdx-1]^pbOut[dwIdx-1], lastPlainText);
        lastPlainText = pbData[dwIdx-1];
    }

    return dwOutBufferLength;

}

//+---------------------------------------------------------------------------
//
//  Function:   CBCDecipherData
//
//  Synopsis:   Decipher a block of data,  inplace deciper is supported
//
//  Arguments:  pszKey  key string
//              pbData  Data to be Deciphered
//              dwDataLength size of pbData
//              pbOut   Buffer for decipher result
//              dwOutBufferLength size of pbOut, must be >= CBCDecipherBufferSize(dwDataLength)
//
//  Returns:    size of decipher byte in pbOut, 0 means failed
//
//  History:    fengsun Created     8/21/97
//
//----------------------------------------------------------------------------
static int CBCDecipherData(const char* pszKey, const BYTE* pbData, int dwDataLength, 
                       BYTE* pbOut, int dwOutBufferLength)
{
    MYDBGASSERT(pszKey != NULL);    
    MYDBGASSERT(pbData != NULL);    
    MYDBGASSERT(pbOut != NULL);    
    MYDBGASSERT(dwDataLength > 1);    

    if (dwDataLength <= 1)
        return 0;

    if (dwOutBufferLength < CBCDecipherBufferSize(dwDataLength))
        return 0;

    dwOutBufferLength = CBCDecipherBufferSize(dwDataLength);

    //
    // decipher data
    //
    // DeCipher: P[i] = C[i-1] XOR D[k](C[i]), 
    //
    
    BYTE lastPlainText = DecryptByte(pszKey, pbData[0], 0);   //first initilizing byte
    for (int dwIdx=0; dwIdx<dwOutBufferLength; dwIdx++)
    {
        pbOut[dwIdx] = pbData[dwIdx] ^ DecryptByte(pszKey, pbData[dwIdx+1], lastPlainText);
        lastPlainText = pbOut[dwIdx];
    }

    return dwOutBufferLength; 
}

////////////////////////////////////////////////////////////////////////////////
// Helper functions
////////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Function:   reverse
//
//  Synopsis:   reverse the given strings.
//
//  Arguments:  s   the string.
//
//  Returns:    the reversed string
//
//  History:    henryt  Created     5/20/97
//
//----------------------------------------------------------------------------
static LPTSTR 
reverse(
    LPTSTR  s
)
{
    int     i = 0;
    int     j = lstrlen(s) - 1;
    TCHAR   ch;

    while (i < j)
    {
        ch = s[i];
        s[i++] = s[j];
        s[j--] = ch;
    }
    return s;
}


//+---------------------------------------------------------------------------
//
//  Function:   GenerateKeyString
//
//  Synopsis:   reverse the key str and use it as a password to generate a session key.
//
//  Arguments:  OUT LPTSTR  pszBuf,   The buffer
//              IN  DWORD   dwBufLen     size of the buffer in # of chars.
//              
//              
//
//  Returns:    TRUE if success
//              FALSE if failure
//
//  History:    henryt  Created     5/20/97
//
//----------------------------------------------------------------------------
static void
GenerateKeyString(
    IN OUT  LPTSTR  pszBuf,
    IN      DWORD   dwBufLen
)
{
    lstrcpyn(pszBuf, gc_szKeyStr, dwBufLen);
    pszBuf[dwBufLen - 1] = 0;
    reverse(pszBuf);
}


//+---------------------------------------------------------------------------
//
//  Function:   SetKeyString
//
//  Synopsis:   Generates a random key that will be used to create the
//              session key that is used to encrypt the password. Once the key
//              created it is encrypted and stored in the registry so that we
//              can use the key to decrypt the password again. The key used to 
//              encrypt and decrypt is generated in GetCurrentKey(). If 
//              anything fails we default to using a hardcoded key by calling
//              GenerateKeyString.
//
//  Arguments:  pszBuf      The buffer
//              dwBufLen    size of the buffer in # of chars.
//              dwEncryptionType - selects which reg key to use
//              pfnAlloc    memory allocator(if NULL, then the default is used.   
//                           Win32 - HeapAlloc(GetProcessHeap(), ...)         
//              pfnFree     memory deallocator(if NULL, then the default is used. 
//                           Win32 - HeapFree(GetProcessHeap(), ...)          
//              pszUserKey  reg key used to store the encrypted key, if not 
//                          provided (NULL), it will default to GenerateKeyString
//              pfMoreSecure TRUE if we are using the randomly generated key
//                           FALSE if using the hardcoded key  
//
//  Returns:    TRUE if success
//              FALSE if failure
//
//  History:    03/14/2001  tomkel      Created
//
//----------------------------------------------------------------------------
static BOOL SetKeyString(IN OUT LPTSTR  pszBuf,
                         IN     DWORD dwBufLen,
                         IN     DWORD dwEncryptionType,
                         IN     PFN_CMSECUREALLOC  pfnAlloc,
                         IN     PFN_CMSECUREFREE   pfnFree,
                         IN     LPSTR pszUserKey,
                         OUT    BOOL *pfMoreSecure)
{
    BOOL fReturn = FALSE;
    BOOL fFuncRet = FALSE;
    BOOL fOk = FALSE;
    TCHAR szTempKeyStr[MAX_KEY_STRING_LEN]={0};
    DWORD cbEncryptedData = 0; 
    PBYTE pbEncryptedData = NULL;

    //
    // Don't check for pszUserKey here
    //
    if (NULL == pszBuf || NULL == pfMoreSecure)
    {
        return fReturn;
    }
    
    *pfMoreSecure = FALSE;

    //
    // Check to see if we should try to generate a random key and then store it 
    // into the reg key supplied by the caller. If not, then use the hardcoded key.
    //
    if (pszUserKey)
    {
        //
        // Try to generate random key otherwise use the hardcoded string. GenerateRandomKey
        // takes a PBYTE pointer and a count in bytes, thus we have to convert the character count
        // to bytes by multiplying it by sizeof(TCHAR)
        //
        if (g_pCryptFnc->GenerateRandomKey((PBYTE)pszBuf, dwBufLen*sizeof(TCHAR)))
        {
            // Now that we have the randomkey, we need to store it in the registry so 
            // we can use it when decrypting. In order to store it, we have 
            // to encrypt it first. 
        
            //
            // Generate a machine specific key that's used to encrypt the random number 
            // used for the session key
            //
            fFuncRet = GetCurrentKey(szTempKeyStr, MAX_KEY_STRING_LEN, pfnAlloc, pfnFree);
            if (fFuncRet)
            {
                //
                // If user want use CryptoApi and it is available
                //
                if (!g_pCryptFnc)
                {
                    g_pCryptFnc = InitCryptoApi();
                }

                if (g_pCryptFnc)
                {
                    //
                    // encrypt the data with the key string
                    //
                    fOk = g_pCryptFnc->EncryptDataWithKey(
                        szTempKeyStr,                // Key
                        (PBYTE)pszBuf,               // Secret key to encrypt
                        dwBufLen,                    // Length of secret key
                        &pbEncryptedData,            // Encrypted data will be stored here
                        &cbEncryptedData,            // Length of this buffer
                        pfnAlloc,                    // mem allocator
                        pfnFree,                     // mem deallocator
                        0);                          // not specifying keylength
                }

                if (fOk)
                {
                    //
                    // Store the encrypted key in the registry so we can use it later
                    // for decryption
                    // 
                    HKEY hKeyCm;
    
                    //
                    // Try to open the key for writing
                    //

                    LONG lRes = RegOpenKeyEx(HKEY_CURRENT_USER,
                                              pszUserKey,
                                              0,
                                              KEY_SET_VALUE ,
                                              &hKeyCm);

                    //
                    // If we can't open it the key may not be there, try to create it.
                    //

                    if (ERROR_SUCCESS != lRes)
                    {
                        DWORD dwDisposition;
                        lRes = RegCreateKeyEx(HKEY_CURRENT_USER,
                                               pszUserKey,
                                               0,
                                               TEXT(""),
                                               REG_OPTION_NON_VOLATILE,
                                               KEY_SET_VALUE,
                                               NULL,
                                               &hKeyCm,
                                               &dwDisposition);     
                    }

                    //
                    // On success, update the value, then close
                    //

                    if (ERROR_SUCCESS == lRes)
                    {
                        if (dwEncryptionType & CMSECURE_ET_USE_SECOND_RND_KEY)
                        {
                            lRes = RegSetValueEx(hKeyCm, c_pszCmRegKeyEncryptedInternetPasswordKey, NULL, REG_BINARY,
                                          pbEncryptedData, cbEncryptedData);
                        }
                        else
                        {
                            lRes = RegSetValueEx(hKeyCm, c_pszCmRegKeyEncryptedPasswordKey, NULL, REG_BINARY,
                                          pbEncryptedData, cbEncryptedData);
                        }
                        
                        RegCloseKey(hKeyCm);
                    
                        if (ERROR_SUCCESS == lRes)
                        {
                            fReturn = TRUE;
                            *pfMoreSecure = TRUE;
                        }
                    }
                }
            }
        }
    }

    //
    // Check if we need to default to the old key
    //
    if (FALSE == fReturn)
    {
        GenerateKeyString(pszBuf, dwBufLen);
        fReturn = TRUE;
    }

    if (pfnFree)
    {
        pfnFree(pbEncryptedData);
    }
    else
    {
        HeapFree(GetProcessHeap(), 0, pbEncryptedData);
    }
    
    ZeroMemory((LPVOID)szTempKeyStr, sizeof(szTempKeyStr));
    
    return fReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetKeyString
//
//  Synopsis:   Gets the key that is used to create a session key for
//              decrypting the password. Reads the encrypted key from the 
//              registry. Get the key used for decrypting by calling GetCurrentKey.
//              Decrypts the data and returns the key. If anything fails we 
//              default to using a hardcoded key by calling GenerateKeyString.
//
//  Arguments:  pszBuf      The buffer
//              pdwBufLen   pointer to the size of the buffer in # of chars.
//              dwEncryptionType - selects which reg key to use
//              pfnAlloc    memory allocator(if NULL, then the default is used.   
//                           Win32 - HeapAlloc(GetProcessHeap(), ...)         
//              pfnFree     memory deallocator(if NULL, then the default is used. 
//                           Win32 - HeapFree(GetProcessHeap(), ...)          
//              pszUserKey  reg key used to store the encrypted key, if not 
//                          provided (NULL), it will default to GenerateKeyString
//              pfMoreSecure TRUE if we are using the randomly generated key
//                           FALSE if using the hardcoded key  
//
//  Returns:    TRUE if success
//              FALSE if failure
//
//  History:    03/14/2001  tomkel      Created
//
//----------------------------------------------------------------------------
static BOOL GetKeyString(IN OUT  LPTSTR  pszBuf, IN DWORD *pdwBufLen, IN DWORD dwEncryptionType,
                         IN PFN_CMSECUREALLOC  pfnAlloc,
                         IN PFN_CMSECUREFREE   pfnFree,
                         IN LPSTR pszUserKey,
                         OUT BOOL *pfMoreSecure)
{
    BOOL fReturn = FALSE;
    BOOL fFuncRet = FALSE;
    HKEY hKeyCm;
    TCHAR szTempKeyStr[MAX_KEY_STRING_LEN]={0};
    DWORD dwRet = 0;
    DWORD cbEncryptedData = 0;
    PBYTE pbEncryptedData = NULL; 
    PBYTE pbData = NULL;
    DWORD dwDataBufferLength = 0;

    //
    // Don't Check for pszUserKey here
    //
    if (NULL == pszBuf || NULL == pdwBufLen || NULL == pfMoreSecure)
    {
        return fReturn;
    }

    *pfMoreSecure = FALSE;
    
    //
    // If we have the user key then we are using the randomly generated key. 
    // Try to get it from the reg.
    //
    if (pszUserKey)
    {
        //
        // Try to open the key for writing
        //

        LONG lRes = RegOpenKeyEx(HKEY_CURRENT_USER,
                                  pszUserKey,
                                  0,
                                  KEY_READ ,
                                  &hKeyCm);

        //
        // On success, read the value, then close
        //
        if (ERROR_SUCCESS == lRes)
        {
            DWORD dwType = REG_BINARY;
            //
            // Get the size first
            //
            if (dwEncryptionType & CMSECURE_ET_USE_SECOND_RND_KEY)
            {
                lRes = RegQueryValueEx(hKeyCm, c_pszCmRegKeyEncryptedInternetPasswordKey, NULL, &dwType,
                              NULL, &cbEncryptedData); 
            }
            else
            {
                lRes = RegQueryValueEx(hKeyCm, c_pszCmRegKeyEncryptedPasswordKey, NULL, &dwType,
                              NULL, &cbEncryptedData); 
            }

            //
            // Alloc the appropriate sized buffer. Need to add a space for null,
            // otherwise decrypt doesn't work.
            //
            if (pfnAlloc)
            {
                pbEncryptedData = (PBYTE)pfnAlloc(cbEncryptedData + sizeof(TCHAR));
            }
            else
            {
                pbEncryptedData = (PBYTE)HeapAlloc(GetProcessHeap(), 
                                         HEAP_ZERO_MEMORY,
                                         cbEncryptedData + sizeof(TCHAR));
            }
            
            if (pbEncryptedData)
            {
                if (dwEncryptionType & CMSECURE_ET_USE_SECOND_RND_KEY)
                {
                    lRes = RegQueryValueEx(hKeyCm, c_pszCmRegKeyEncryptedInternetPasswordKey, NULL, &dwType,
                                  pbEncryptedData, &cbEncryptedData); 
                }
                else
                {
                    lRes = RegQueryValueEx(hKeyCm, c_pszCmRegKeyEncryptedPasswordKey, NULL, &dwType,
                                  pbEncryptedData, &cbEncryptedData); 
                }
            }
            RegCloseKey(hKeyCm);
    
            // 
            // If we find the value decrypt it, otherwise we fall through and use the default key
            //
            if (ERROR_SUCCESS == lRes && pbEncryptedData)
            {
                //
                // Decrypt it using the machine specific key
                //
                fFuncRet = GetCurrentKey(szTempKeyStr, MAX_KEY_STRING_LEN, pfnAlloc, pfnFree);
                if (fFuncRet)
                {
                    if (!g_pCryptFnc)
                    {
                        g_pCryptFnc = InitCryptoApi();
                    }

                    if (g_pCryptFnc)
                    {
                        dwRet = g_pCryptFnc->DecryptDataWithKey(
                                    szTempKeyStr,            // Key
                                    pbEncryptedData,         // Encrypted data
                                    cbEncryptedData,         // Length of encrypted data
                                    &pbData,                 // decrypted data
                                    &dwDataBufferLength,     // Length of decrypted data
                                    pfnAlloc,                // mem allocator
                                    pfnFree,                 // mem deallocator
                                    0);                      // not specifying keylength

                        if (ERROR_SUCCESS == dwRet)
                        {
                            fReturn = TRUE;
                            *pfMoreSecure = TRUE;           // Using the random key
                        }
                    }
                }
            }
        }
    }

    if (fReturn)
    {
        DWORD dwLen = *pdwBufLen;
        if (dwDataBufferLength < *pdwBufLen)
        {
            dwLen = dwDataBufferLength;
        }

        //
        // Copy into out param
        //
        CopyMemory((LPVOID)pszBuf, pbData, dwLen);
    }
    else
    {
        GenerateKeyString(pszBuf, *pdwBufLen);
        fReturn = TRUE;
    }

    if (pfnFree)
    {
        pfnFree(pbEncryptedData);
        pfnFree(pbData);
    }
    else
    {
        HeapFree(GetProcessHeap(), 0, pbEncryptedData);
        HeapFree(GetProcessHeap(), 0, pbData);
    }

    ZeroMemory((LPVOID)szTempKeyStr, sizeof(szTempKeyStr));

    return fReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCurrentKey
//
//  Synopsis:   Creates a machine dependent key by using the Hard Drive's 
//              serial number. This serial number is then used to fil lup the
//              output buffer. If the hard drive is replaced then this of course
//              will not generate the same serial number. 
//
//  Arguments:  szTempKeyStr        The buffer
//              dwTempKeyStrMaxLen  max length of the buffer in # of chars.
//              pfnAlloc  memory allocator(if NULL, then the default is used.   
//                        Win32 - HeapAlloc(GetProcessHeap(), ...)         
//              pfnFree   memory deallocator(if NULL, then the default is used. 
//                        Win32 - HeapFree(GetProcessHeap(), ...)          
//
//  Returns:    TRUE if success
//              FALSE if failure
//
//  History:    03/14/2001  tomkel      Created
//
//----------------------------------------------------------------------------
static BOOL GetCurrentKey(PTCHAR szTempKeyStr, DWORD dwTempKeyStrMaxLen, 
                   IN  PFN_CMSECUREALLOC  pfnAlloc,
                   IN  PFN_CMSECUREFREE   pfnFree)
{
    BOOL fFuncRet = FALSE;
    DWORD dwVolumeSerialNumber = 0;
    DWORD dwMaxComponentLen = 0;
    DWORD dwFileSysFlags = 0;
    LPTSTR pszSerialNum = NULL;
    
    if (NULL == szTempKeyStr)
    {
        return fFuncRet;
    }

    //
    // Lets generate the key from the HD serial number. This means that encrypted
    // passwords and keys will only be valid on this machine. If the user replaces
    // the drive, then the decryption will fail.
    //
    fFuncRet = GetVolumeInformation(NULL, NULL, 0, &dwVolumeSerialNumber, 
                                    &dwMaxComponentLen, &dwFileSysFlags, NULL, 0);
    if (fFuncRet)
    {
        DWORD dwLen = 0;
        
        //
        // Make sure we have a buffer large enough to hold the value. 
        // Allocate a string based on the number of bits, thus a decimal number
        // will always fit. Maybe an exaggeration, but the length isn't hardcoded.
        //
        if (pfnAlloc)
        {
            pszSerialNum = (LPTSTR)pfnAlloc(sizeof(dwVolumeSerialNumber)*8*sizeof(TCHAR));
        }
        else
        {
            pszSerialNum = (LPTSTR)HeapAlloc(GetProcessHeap(), 
                                     HEAP_ZERO_MEMORY,
                                     sizeof(dwVolumeSerialNumber)*8*sizeof(TCHAR));
        }
        
        if (pszSerialNum)
        {
            DWORD dwSNLen = 0;

            wsprintf(pszSerialNum, TEXT("%u"), dwVolumeSerialNumber);

            //
            // See how many times the serial number string will fit into our buffer
            // Need to check the length due to PREFIX. If the length is 0, just return. 
            //
            dwSNLen = lstrlen(pszSerialNum);

            if (dwSNLen)
            {
                dwLen = (dwTempKeyStrMaxLen - 1) / dwSNLen;
            }
            else
            {
                fFuncRet = FALSE;
                goto done;
            }

            if (0 < dwLen)
            {
                DWORD i = 0;
            
                lstrcpy(szTempKeyStr, pszSerialNum);
                //
                // Fill up the buffer. Start at 1 because we already copied the first 
                // serial number into the buffer
                //
                for (i = 1; i<dwLen; i++)
                {
                    lstrcat(szTempKeyStr, pszSerialNum);
                }
            }
            else
            {
                //
                // the length is larger than the buffer so just copy what fits into the buffer
                //
                lstrcpyn(szTempKeyStr, pszSerialNum, dwTempKeyStrMaxLen-1);
            }
        }
        else
        {
            fFuncRet = FALSE;
        }
    }

done:
    if (pfnFree)
    {
        pfnFree(pszSerialNum);
    }
    else
    {
        HeapFree(GetProcessHeap(), 0, (LPVOID)pszSerialNum);
    }

    return fFuncRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsecure\cryptfnc.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cryptfnc.cpp
//
// Module:   CMSECURE.LIB
//
// Synopsis: This file implements the cryptfnc class that provides
//           easy to use interfaces on the CryptoAPI.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   AshishS    Created             12/03/96
//           henryt     modified for CM     5/21/97
//
//+----------------------------------------------------------------------------

#include "cryptfnc.h"

#ifdef UNICODE
#define LoadLibraryExU LoadLibraryExW
#else
#define LoadLibraryExU LoadLibraryExA
#endif
#include "linkdll.h" // LinkToDll and BindLinkage

CCryptFunctions::~CCryptFunctions()
{
     // Release provider handle.    
    if (m_hProv != 0)
    {
        m_fnCryptReleaseContext(m_hProv, 0);
    }

    if (m_AdvApiLink.hInstAdvApi32)
    {
        FreeLibrary(m_AdvApiLink.hInstAdvApi32);
        ZeroMemory(&m_AdvApiLink, sizeof(m_AdvApiLink));
    }
}


CCryptFunctions::CCryptFunctions()
{
    m_hProv = 0;
    ZeroMemory(&m_AdvApiLink, sizeof(m_AdvApiLink));
}

BOOL CCryptFunctions::m_fnCryptAcquireContext(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, 
                             DWORD dwProvType, DWORD dwFlags)
{
    BOOL bReturn = FALSE;
    
    MYDBGASSERT(m_AdvApiLink.pfnCryptAcquireContext);
    if (m_AdvApiLink.pfnCryptAcquireContext)
    {
        bReturn = m_AdvApiLink.pfnCryptAcquireContext(phProv, pszContainer, pszProvider, 
                                                      dwProvType, dwFlags);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, 
                         DWORD dwFlags, HCRYPTHASH *phHash)
{
    BOOL bReturn = FALSE;

    MYDBGASSERT(m_AdvApiLink.pfnCryptCreateHash);
   
    if (m_AdvApiLink.pfnCryptCreateHash)
    {
        bReturn = m_AdvApiLink.pfnCryptCreateHash(hProv, Algid, hKey, dwFlags, phHash);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptDecrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, 
                      BYTE *pbData, DWORD *pdwDataLen)
{
    BOOL bReturn = FALSE;

    MYDBGASSERT(m_AdvApiLink.pfnCryptDecrypt);
    
    if (m_AdvApiLink.pfnCryptDecrypt)
    {
        bReturn = m_AdvApiLink.pfnCryptDecrypt(hKey, hHash, Final, dwFlags, pbData, pdwDataLen);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptDeriveKey(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, 
                        DWORD dwFlags, HCRYPTKEY *phKey)
{
    BOOL bReturn = FALSE;
    
    MYDBGASSERT(m_AdvApiLink.pfnCryptDeriveKey);

    if (m_AdvApiLink.pfnCryptDeriveKey)
    {
        bReturn = m_AdvApiLink.pfnCryptDeriveKey(hProv, Algid, hBaseData, dwFlags, phKey);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptDestroyHash(HCRYPTHASH hHash)
{
    BOOL bReturn = FALSE;
    
    MYDBGASSERT(m_AdvApiLink.pfnCryptDestroyHash);

    if (m_AdvApiLink.pfnCryptDestroyHash)
    {
        bReturn = m_AdvApiLink.pfnCryptDestroyHash(hHash);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptDestroyKey(HCRYPTKEY hKey)
{
    BOOL bReturn = FALSE;
    
    MYDBGASSERT(m_AdvApiLink.pfnCryptDestroyKey);

    if (m_AdvApiLink.pfnCryptDestroyKey)
    {
        bReturn = m_AdvApiLink.pfnCryptDestroyKey(hKey);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptEncrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags,
                      BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen)
{
    BOOL bReturn = FALSE;
    
    MYDBGASSERT(m_AdvApiLink.pfnCryptEncrypt);

    if (m_AdvApiLink.pfnCryptEncrypt)
    {
        bReturn = m_AdvApiLink.pfnCryptEncrypt(hKey, hHash, Final, dwFlags, pbData, pdwDataLen, dwBufLen);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptHashData(HCRYPTHASH hHash, CONST BYTE *pbData, DWORD dwDataLen, DWORD dwFlags)
{
    BOOL bReturn = FALSE;
    
    MYDBGASSERT(m_AdvApiLink.pfnCryptHashData);

    if (m_AdvApiLink.pfnCryptHashData)
    {
        bReturn = m_AdvApiLink.pfnCryptHashData(hHash, pbData, dwDataLen, dwFlags);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptReleaseContext(HCRYPTPROV hProv, ULONG_PTR dwFlags)
{
    BOOL bReturn = FALSE;
    
    MYDBGASSERT(m_AdvApiLink.pfnCryptReleaseContext);

    if (m_AdvApiLink.pfnCryptReleaseContext)
    {
        bReturn = m_AdvApiLink.pfnCryptReleaseContext(hProv, dwFlags);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_pfnCryptGenRandom(HCRYPTPROV hProv, DWORD dwLen, BYTE* pbBuffer)
{
    BOOL bReturn = FALSE;

    MYDBGASSERT(m_AdvApiLink.pfnCryptGenRandom);

    if (m_AdvApiLink.pfnCryptGenRandom)
    {
        bReturn = m_AdvApiLink.pfnCryptGenRandom(hProv, dwLen, pbBuffer);
    }

    return bReturn;
}

//
// Calls m_pfnCryptGenRandom to create a random key
//
BOOL CCryptFunctions::GenerateRandomKey(PBYTE pbData, DWORD cbData)
{
    BOOL fReturn = FALSE;
    if (pbData)
    {
        fReturn = m_pfnCryptGenRandom(m_hProv, cbData, pbData);
    }
    return fReturn;
}

//+----------------------------------------------------------------------------
//
// Func:    CCryptFunctions::GenerateSessionKeyFromPassword
//
// Desc:    this function Generates a SessionKey using the pszPassword parameter
//
// Args:    [phKey]       - location to store the session key
//          [pszPassword] - password to generate the session key from
//          [dwEncKeyLen] - how many bits of encryption
//
// Return:  BOOL (FALSE if a fatal error occurred, else TRUE)
//
// Notes:   
//
//-----------------------------------------------------------------------------
BOOL CCryptFunctions::GenerateSessionKeyFromPassword(    
        HCRYPTKEY * phKey,
        LPTSTR      pszPassword,
        DWORD       dwEncKeyLen)
{
    DWORD dwLength; 
    HCRYPTHASH hHash = 0;

    // Create hash object.
    //
    if (!m_fnCryptCreateHash(m_hProv, // handle to CSP
                             CALG_SHA, // use SHA hash algorithm
                             0, // not keyed hash
                             0, // flags - always 0
                             &hHash)) // address where hash object should be created
    {
        MYDBG(("Error 0x%x during CryptCreateHash", GetLastError()));
        goto cleanup;
    }

    // Hash password string.
    //
    dwLength = lstrlen(pszPassword) * sizeof(TCHAR);
    if (!m_fnCryptHashData(hHash, // handle to hash object
                           (BYTE *)pszPassword, // address of data to be hashed
                           dwLength, // length of data 
                           0)) // flags
    {
        MYDBG(("Error 0x%x during CryptHashData", GetLastError()));
        goto cleanup;
    }

    // Create block cipher session key based on hash of the password.
    //
    if (!m_fnCryptDeriveKey(m_hProv, //CSP provider
                            CALG_RC2, // use RC2 block cipher algorithm
                            hHash, //handle to hash object 
                            (dwEncKeyLen << 16), // just the key length, no flags - we do not need the key to be exportable
                            phKey)) //address the newly created key should be copied
    {
        MYDBG(("Error 0x%x during CryptDeriveKey", GetLastError()));
        goto cleanup;
    }
    
     // Destroy hash object.
    m_fnCryptDestroyHash(hHash);
    return TRUE;
    
cleanup:

    // Destroy hash object.
    if (hHash != 0)
    {
        m_fnCryptDestroyHash(hHash);
    }
    return FALSE;
}

// This function must be called before any member functions of the
// class are used.
// Returns FALSE if a Fatal error occured, TRUE otherwise
BOOL CCryptFunctions::InitCrypt()
{
    LPCSTR ArrayOfCryptFuncs [] = 
    {
#ifdef UNICODE
        "CryptAcquireContextW", // this has never been tested
#else
        "CryptAcquireContextA",        
#endif
        "CryptCreateHash",
        "CryptDecrypt",
        "CryptDeriveKey",
        "CryptDestroyHash",
        "CryptDestroyKey",
        "CryptEncrypt",
        "CryptHashData",
        "CryptReleaseContext",
        "CryptGenRandom",       // to create a random session key
        NULL
    };

    BOOL bRet = LinkToDll(&(m_AdvApiLink.hInstAdvApi32), TEXT("Advapi32.dll"), ArrayOfCryptFuncs, 
                          m_AdvApiLink.apvPfn);

    if (!bRet)
    {
        goto cleanup;
    }

    // Get handle to user default provider.
    if (! m_fnCryptAcquireContext(&m_hProv, //  address to get the handle to CSP
                                  CM_CRYPTO_CONTAINER, // contianer name
                                  MS_DEF_PROV, //  provider
                                  PROV_RSA_FULL, // type of provider
                                  0)) // no flags
    {
        DWORD dwError = GetLastError();
        MYDBGTST(dwError, ("Error 0x%x during CryptAcquireContext", dwError));

        MYDBG(("Calling CryptAcquireContext again to create keyset"));

        if (! m_fnCryptAcquireContext(&m_hProv,// handle to CSP
                                      CM_CRYPTO_CONTAINER,// contianer name
                                      MS_DEF_PROV, // provider
                                      PROV_RSA_FULL, // type of provider
                                      CRYPT_NEWKEYSET) ) // create the keyset
        {
            MYDBG(("Fatal Error 0x%x during second call to CryptAcquireContext", GetLastError()));
            goto cleanup;               
        }
    }

    return TRUE;
    
cleanup:
     // Release provider handle.
    if (m_hProv != 0)
    {
        m_fnCryptReleaseContext(m_hProv, 0);
    }
    return FALSE;   
}



// Given a key string, and data to encrypt this function generates a
// session key from the key string. This session key is then used to
// encrypt the data.

// Returns FALSE if a Fatal error occured, TRUE otherwise
BOOL CCryptFunctions::EncryptDataWithKey(
    LPTSTR          pszKey,              // password    
    PBYTE           pbData,              // Data to be encrypted
    DWORD           dwDataLength,        // Length of data in bytes
    PBYTE           *ppbEncryptedData,     // Encrypted secret key will be stored here
    DWORD           *pdwEncryptedBufferLen, // Length of this buffer
    PFN_CMSECUREALLOC  pfnAlloc,
    PFN_CMSECUREFREE   pfnFree,
    DWORD           dwEncKeySize         // how many bits of encryption do we want?  (0 implies "don't care")
    )
{
    HCRYPTKEY   hKey = 0;   
    DWORD       dwErr;
    DWORD       dwBufferLen;
    BOOL        fOk = FALSE;
    PBYTE       pbBuf = NULL;
    
    //
    // Init should have been successfully called before
    // if no data to be encrypted, don't do anything
    //
    if (m_hProv == 0 || !dwDataLength)
    {
        return FALSE;
    }
    
    if (!GenerateSessionKeyFromPassword(&hKey, pszKey, dwEncKeySize))
        goto cleanup;

     // copy the data into another buffer to encrypt it
    *pdwEncryptedBufferLen = dwDataLength;
    dwBufferLen = dwDataLength + DEFAULT_CRYPTO_EXTRA_BUFFER_SIZE; 

    while (1)
    {
        //
        // alloc memory for output buffer
        //
        if (pfnAlloc)
        {
            *ppbEncryptedData = (PBYTE)pfnAlloc(dwBufferLen);
        }
        else
        {
            *ppbEncryptedData = (PBYTE)HeapAlloc(GetProcessHeap(), 
                                                 HEAP_ZERO_MEMORY,
                                                 dwBufferLen);
        }
        if (!*ppbEncryptedData)
        {
            MYDBG(("EncryptDataWithKey: out of memory error"));
            goto cleanup;
        }
    
         // copy the data into another buffer to encrypt it
        memcpy (*ppbEncryptedData, pbData, dwDataLength);
    
    
         // now encrypt the secret key using the key generated
        if ( ! m_fnCryptEncrypt(hKey,
                                0, // no hash required
                                TRUE, // Final packet
                                0, // Flags - always 0
                                *ppbEncryptedData, // data buffer
                                pdwEncryptedBufferLen, // length of data
                                dwBufferLen ) ) // size of buffer
        {
            MYDBG(("Error 0x%x during CryptEncrypt", GetLastError()));

            if (pfnFree)
            {
                pfnFree(*ppbEncryptedData);
            }
            else
            {
                HeapFree(GetProcessHeap(), 0, *ppbEncryptedData);
            }
            *ppbEncryptedData = NULL;
            
            dwErr = GetLastError();
            //
            // if the output is too small, realloc it.
            //
            if (dwErr == ERROR_MORE_DATA  || dwErr == NTE_BAD_LEN)
            {
                dwBufferLen += DEFAULT_CRYPTO_EXTRA_BUFFER_SIZE;
                continue;
            }

            goto cleanup;
        }

        //
        // we now have the data encrypted.  we need to uuencode it.
        //
        if (pfnAlloc)
        {
            pbBuf = (PBYTE)pfnAlloc(*pdwEncryptedBufferLen);
        }
        else
        {
            pbBuf = (PBYTE)HeapAlloc(GetProcessHeap(), 
                                     HEAP_ZERO_MEMORY,
                                     *pdwEncryptedBufferLen);
        }
        if (!pbBuf)
        {
            MYDBG(("EncryptDataWithKey: out of memory error"));
            if (pfnFree)
            {
                pfnFree(*ppbEncryptedData);
            }
            else
            {
                HeapFree(GetProcessHeap(), 0, *ppbEncryptedData);
            }
            *ppbEncryptedData = NULL;
            goto cleanup;
        }

        memcpy(pbBuf, *ppbEncryptedData, *pdwEncryptedBufferLen);
        uuencode(pbBuf, *pdwEncryptedBufferLen, (CHAR*)*ppbEncryptedData, dwBufferLen);
        //
        // set the encrypted buffer len
        //
        *pdwEncryptedBufferLen = lstrlen((LPTSTR)*ppbEncryptedData);

        if (pfnFree)
        {
            pfnFree(pbBuf);
        }
        else
        {
            HeapFree(GetProcessHeap(), 0, pbBuf);
        }
        pbBuf = NULL;

        break;
    }

    fOk = TRUE;
    
cleanup:
         // destroy session key
    if (hKey != 0)
        m_fnCryptDestroyKey(hKey);
    
    return fOk;
}

// Given a key string, and encrypted data using EncryptDataWithPassword,
// this function generates a session key from the key string. This
// session key is then used to decrypt the data.

//  returns
//   CRYPT_FNC_NO_ERROR   no error
//   CRYPT_FNC_BAD_PASSWORD password bad try again
//   CRYPT_FNC_INSUFFICIENT_BUFFER larger buffer is required
//   *pdwEncrytedBufferLen is set to required length
//   CRYPT_FNC_INIT_NOT_CALLED InitCrypt not successfully called
//   CRYPT_FNC_INTERNAL_ERROR 
DWORD CCryptFunctions::DecryptDataWithKey(
    LPTSTR          pszKey,              // password    
    PBYTE           pbEncryptedData,     // Encrypted data
    DWORD           dwEncrytedDataLen,   // Length of encrypted data
    PBYTE           *ppbData,            // Decrypted Data will be stored here
    DWORD           *pdwDataBufferLength,// Length of the above buffer in bytes
    PFN_CMSECUREALLOC  pfnAlloc,
    PFN_CMSECUREFREE   pfnFree,
    DWORD           dwEncKeySize         // how many bits of encryption do we want?  (0 implies "don't care")
    )
{
    DWORD dwBufferLen;
    DWORD dwUUDecodeBufLen;
    HCRYPTKEY hKey = 0; 
    DWORD dwError;
    DWORD dwMaxBufSize = 1024 * 10;     // Just some max buffer size (10K) in order to exit the while loop

    //
    // Init should have been successfully called before
    // if no data to be decrypted, then don't do anything
    //
    if (m_hProv == 0 || !dwEncrytedDataLen)
    {
        dwError = CRYPT_FNC_INIT_NOT_CALLED;
        goto cleanup;
    }
    
    if (!GenerateSessionKeyFromPassword(&hKey, pszKey, dwEncKeySize))
    {
        dwError = CRYPT_FNC_INTERNAL_ERROR;     
        goto cleanup;
    }

     // copy the data into another buffer to encrypt it
    dwBufferLen = dwEncrytedDataLen + DEFAULT_CRYPTO_EXTRA_BUFFER_SIZE;
    // *pdwDataBufferLength = dwEncrytedDataLen;

    //
    // Loop until we get to dwMaxBufSize. This is a safeguard to get out
    // of the infinite loop problem. DBCS passwords used to loop continuously.
    //

    while(dwBufferLen < dwMaxBufSize)  
    {
        //
        // alloc memory for output buffer
        //
        if (pfnAlloc)
        {
            *ppbData = (PBYTE)pfnAlloc(dwBufferLen);
        }
        else
        {
            *ppbData = (PBYTE)HeapAlloc(GetProcessHeap(),
                                        HEAP_ZERO_MEMORY,
                                        dwBufferLen);
        }
        if (!*ppbData)
        {
            dwError = CRYPT_FNC_OUT_OF_MEMORY;
            goto cleanup;
        }

        //
        // set uudecode output buf size
        //
        dwUUDecodeBufLen = dwBufferLen;

        uudecode((char*)pbEncryptedData, (CHAR*)*ppbData, &dwUUDecodeBufLen);
        
        *pdwDataBufferLength = dwUUDecodeBufLen;

         // now decrypt the secret key using the key generated
        if ( ! m_fnCryptDecrypt(hKey,
                                0, // no hash required
                                TRUE, // Final packet
                                0, // Flags - always 0
                                *ppbData, // data buffer
                                pdwDataBufferLength )) // length of data
        {
            DWORD dwCryptError = GetLastError();
            MYDBGTST(dwCryptError, ("Error 0x%x during CryptDecrypt", dwCryptError));
    
            if (pfnFree)
            {
                pfnFree(*ppbData);
            }
            else
            {
                HeapFree(GetProcessHeap(), 0, *ppbData);
            }
            *ppbData = NULL;
            
            //
            // if the output is too small, realloc it.
            //
            if (dwCryptError == NTE_BAD_LEN)
            {
                dwBufferLen *= 2;  // to speed up memory alloc double the size
                continue;
            }

             // CryptDecrypt fails with error NTE_BAD_DATA if the password
             // is incorrect. Hence we should check for this error and prompt the
             // user again for the password.  If the data is garbled in transit, then the secret key
             // will still be  decrypted into a wrong value and the user will not
             // know about it.
            if (dwCryptError == NTE_BAD_DATA)
            {
                dwError = CRYPT_FNC_BAD_KEY;
            }
            else
            {
                dwError = CRYPT_FNC_INTERNAL_ERROR;         
            }

            goto cleanup;
        }

        break;
    }
    if (dwBufferLen < dwMaxBufSize)
    {
        dwError = CRYPT_FNC_NO_ERROR;
    }
    else
    {
        CMTRACE1(TEXT("DecryptDataWithKey: not enough buffer = %d bytes"), dwBufferLen);
        MYDBGASSERT(FALSE);
        dwError = NTE_BAD_LEN;
    }
    
    
cleanup:
         // destroy session key
    if (hKey != 0)
    {
        m_fnCryptDestroyKey(hKey);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsetup\cmakver.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmakver.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of CmakVersion, a utility class that is used to 
//           detect the version of the Connection Mananger Administration Kit
//           that is installed.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created    09/14/98
//
//+----------------------------------------------------------------------------
#include "cmsetup.h"
#include "cmakreg.h"
#include "reg_str.h"

CmakVersion::CmakVersion()
{
    HKEY hKey;
    LONG lResult;

    m_szCmakPath[0] = TEXT('\0');

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszCmakAppPath, 0, KEY_READ, &hKey);

    if (ERROR_SUCCESS == lResult)
    {        
        //
        //  Check to see if we have a path to work from.
        //

        DWORD dwSize = MAX_PATH;
        DWORD dwType = REG_SZ;

        if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegPath, NULL, &dwType, 
            (LPBYTE)m_szCmakPath, &dwSize))
        {
            //
            //	Now construct the base object
            //
            MYVERIFY(CELEMS(m_szPath) > (UINT)wsprintf(m_szPath, TEXT("%s\\cmak.exe"), m_szCmakPath));

            Init();
        }

        (VOID)RegCloseKey(hKey);
    }
}

CmakVersion::~CmakVersion()
{
    //	nothing to do really
}

BOOL CmakVersion::GetInstallLocation(LPTSTR szStr)
{
    if ((m_bIsPresent) && (TEXT('\0') != m_szCmakPath[0]) && (NULL != szStr))
    {
        lstrcpy(szStr, m_szCmakPath);
    }

    return m_bIsPresent;
}

BOOL CmakVersion::Is10Cmak()
{		
    if (m_bIsPresent)
    {
        if ((c_dwVersionSix == m_dwVersion) && (c_dwCmak10BuildNumber == m_dwBuild))
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CmakVersion::Is11or12Cmak()
{
//
//  1.1 and 1.2 CMAK had the 1.1 file format (cm32\enu to get to the support files).  This
//  version never shipped in production but was beta-ed
//
    if (m_bIsPresent)
    {
        if ((c_dwVersionSix == m_dwVersion) && (c_dwCmak10BuildNumber < m_dwBuild)
            && (c_dwFirst121BuildNumber > m_dwBuild))
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CmakVersion::Is121Cmak()
{
//
//  CMAK 1.21 was the version that shipped in IEAK5 and in NT5 Beta3.  This was the CMAK 1.2 with
//  the updated directory structure (since cm16 was never shipped, the cm16/cm32 directory structure
//  of CMAK was unnecessary).  Thus we have the current support directory structure.
//
    if (m_bIsPresent) 
    {
	    if (((c_dwVersionSeven == m_dwVersion) || (c_dwVersionSix == m_dwVersion)) 
              && (c_dwFirst121BuildNumber < m_dwBuild))
        {
            return TRUE;
        }
    }
    return FALSE;
}

//
//  Cmak 1.22 was the same as CMAK 1.21 except that by this time CM was Unicode enabled and required
//  CMUTOA.DLL to run on Win9x.  Versions of CMAK prior to this one knew nothing of CMUTOA.DLL and
//  thus would not bundle it.  Cmak 1.22 shipped in Win2k.
//
BOOL CmakVersion::Is122Cmak()
{
    if (m_bIsPresent) 
    {	
        if ((c_dwVersionSevenPointOne == m_dwVersion) && 
            (c_dwFirstUnicodeBuildNumber <= m_dwBuild) && 
            (c_dwWin2kRTMBuildNumber >= m_dwBuild))
        {
	        return TRUE;
        }
    }
    return FALSE;
}

//
//  Cmak 1.3 was the version we shipped in Whistler.  This version of CMAK bundled the CM
//  bins from a cab instead of scooping them from the system dir and used the CM exception
//  inf to install CM bins on Win2k.
//
BOOL CmakVersion::Is13Cmak()
{
    if (m_bIsPresent) 
    {	
        if (((c_dwCurrentCmakVersionNumber == m_dwVersion)) && (c_dwWin2kRTMBuildNumber <= m_dwBuild))
        {
	        return TRUE;
        }
    }
    return FALSE;
}

DWORD CmakVersion::GetNativeCmakLCID()
{
    return m_dwLCID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsecure\cryptfnc.h ===
//+----------------------------------------------------------------------------
//
// File:     cryptfnc.h
//
// Module:   CMSECURE.LIB
//
// Synopsis: Definition for the cryptfnc class that provides
//           an easy to use interface to the CryptoAPI.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:       AshishS    Created             12/03/96
//           henryt     modified for CM     5/21/97
//
//+----------------------------------------------------------------------------

#ifndef _CRYPTFNC_INC_
#define _CRYPTFNC_INC_

#include <stdio.h>
#include <stdarg.h>
#include <windows.h>
#include <wincrypt.h>
#include "cmuufns.h"
#include "cmsecure.h"
#include "cmdebug.h"
//#include "cmutil.h"

//************************************************************************
// define's
//************************************************************************

#define CRYPT_FNC_NO_ERROR              0
#define CRYPT_FNC_INIT_NOT_CALLED       1
#define CRYPT_FNC_INTERNAL_ERROR        2
#define CRYPT_FNC_BAD_KEY               3
#define CRYPT_FNC_INSUFFICIENT_BUFFER   4
#define CRYPT_FNC_OUT_OF_MEMORY         5

#define DEFAULT_CRYPTO_EXTRA_BUFFER_SIZE     256

#define CM_CRYPTO_CONTAINER             TEXT("CM Crypto Container")

//************************************************************************
// Typedefs for Advapi Linkage
//************************************************************************

typedef BOOL (WINAPI* pfnCryptAcquireContextSpec)(HCRYPTPROV *, LPCTSTR, LPCTSTR, DWORD, DWORD);
typedef BOOL (WINAPI* pfnCryptCreateHashSpec)(HCRYPTPROV, ALG_ID, HCRYPTKEY, DWORD, HCRYPTHASH *);
typedef BOOL (WINAPI* pfnCryptDecryptSpec)(HCRYPTKEY, HCRYPTHASH, BOOL, DWORD, BYTE *, DWORD *);
typedef BOOL (WINAPI* pfnCryptDeriveKeySpec)(HCRYPTPROV, ALG_ID, HCRYPTHASH, DWORD, HCRYPTKEY *);
typedef BOOL (WINAPI* pfnCryptDestroyHashSpec)(HCRYPTHASH);
typedef BOOL (WINAPI* pfnCryptDestroyKeySpec)(HCRYPTKEY);
typedef BOOL (WINAPI* pfnCryptEncryptSpec)(HCRYPTKEY, HCRYPTHASH, BOOL, DWORD, BYTE *, DWORD *, DWORD);
typedef BOOL (WINAPI* pfnCryptHashDataSpec)(HCRYPTHASH, CONST BYTE *, DWORD, DWORD);
typedef BOOL (WINAPI* pfnCryptReleaseContextSpec)(HCRYPTPROV , ULONG_PTR);
typedef BOOL (WINAPI* pfnCryptGenRandomSpec)(HCRYPTPROV, DWORD, BYTE*);

typedef struct _Advapi32LinkageStruct {
        HINSTANCE hInstAdvApi32;
        union {
                struct {
                pfnCryptAcquireContextSpec pfnCryptAcquireContext;
                pfnCryptCreateHashSpec pfnCryptCreateHash;
                pfnCryptDecryptSpec pfnCryptDecrypt;
                pfnCryptDeriveKeySpec pfnCryptDeriveKey;
                pfnCryptDestroyHashSpec pfnCryptDestroyHash;
                pfnCryptDestroyKeySpec pfnCryptDestroyKey;
                pfnCryptEncryptSpec pfnCryptEncrypt;
                pfnCryptHashDataSpec pfnCryptHashData;
                pfnCryptReleaseContextSpec pfnCryptReleaseContext;
                pfnCryptGenRandomSpec pfnCryptGenRandom;
                };
                void *apvPfn[11];   // The size of apvPfn[] should always be 1 size bigger than
                                                   // the number of functions. 
        };
} Advapi32LinkageStruct;


//************************************************************************
// function prototypes
//************************************************************************

class CCryptFunctions
{

protected:
    HCRYPTPROV  m_hProv;
    Advapi32LinkageStruct m_AdvApiLink;

    BOOL m_fnCryptAcquireContext(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, 
                                 DWORD dwProvType, DWORD dwFlags);
    
    BOOL m_fnCryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, 
                             DWORD dwFlags, HCRYPTHASH *phHash);
    
    BOOL m_fnCryptDecrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, 
                          BYTE *pbData, DWORD *pdwDataLen);

    BOOL m_fnCryptDeriveKey(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, 
                            DWORD dwFlags, HCRYPTKEY *phKey);

    BOOL m_fnCryptDestroyHash(HCRYPTHASH hHash);

    BOOL m_fnCryptDestroyKey(HCRYPTKEY hKey);

    BOOL m_fnCryptEncrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags,
                          BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen);

    BOOL m_fnCryptHashData(HCRYPTHASH hHash, CONST BYTE *pbData, DWORD dwDataLen, DWORD dwFlags);

    BOOL m_fnCryptReleaseContext(HCRYPTPROV hProv, ULONG_PTR dwFlags);

    BOOL m_pfnCryptGenRandom(HCRYPTPROV hProv, DWORD dwLen, BYTE* pbBuffer);

public:
    CCryptFunctions();

    ~CCryptFunctions();


    BOOL GenerateSessionKeyFromPassword(
            HCRYPTKEY   *phKey,         // location to store the session key
            LPTSTR      pszPassword,    // password to generate the session key from
            DWORD       dwEncKeyLen);   // how many bits of encryption
    
    BOOL InitCrypt();

    BOOL EncryptDataWithKey(
        LPTSTR              pszKey,
        PBYTE               pbData, 
        DWORD               dwDataLength, 
        PBYTE               *ppbEncryptedData,
        DWORD               *pdwEncryptedBufferLen,
        PFN_CMSECUREALLOC   pfnAlloc,
        PFN_CMSECUREFREE    pfnFree,
        DWORD               dwEncKeyLen);


    DWORD DecryptDataWithKey(
        LPTSTR              pszKey,
        PBYTE               pbEncryptedData,
        DWORD               dwEncrytedDataLen, 
        PBYTE               *ppbData, 
        DWORD               *pdwDataBufferLength,
        PFN_CMSECUREALLOC   pfnAlloc,
        PFN_CMSECUREFREE    pfnFree,
        DWORD               dwEncKeyLen);

    BOOL GenerateRandomKey(PBYTE pbData, DWORD cbData);
};

#endif // _CRYPTFNC_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsetup\cmver.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmver.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of CmVersion class, a utility class that 
//           helps in detecting the version of Connection Mananger that 
//           is installed.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   a-anasj    Created                             02/11/98
//           quintinb   Cleaned Up and removed CRegValue    07/14/98
//           quintinb   Rewrote                             09/14/98
//
//+----------------------------------------------------------------------------

#include "cmsetup.h"
#include "reg_str.h"

CmVersion::CmVersion()
{
    HKEY hKey;
    LONG lResult;

    m_szCmmgrPath[0] = TEXT('\0');

	//
	//	We always want to look in the system directory for cmmgr32.exe first.  This is
	//  its new install location and the app paths key may be corrupted by a 1.0 profile
	//  install.
	//

	MYVERIFY(0 != GetSystemDirectory(m_szCmmgrPath, CELEMS(m_szCmmgrPath)));
	MYVERIFY(CELEMS(m_szPath) > (UINT)wsprintf(m_szPath, TEXT("%s\\cmdial32.dll"), 
		m_szCmmgrPath));

	if (!FileExists(m_szPath))
	{
		//
		//	The file wasn't in the system directory, now try the app paths key
		//
		m_szCmmgrPath[0] = TEXT('\0');
		m_szPath[0] = TEXT('\0');
	
		lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmAppPaths, 0, KEY_READ, &hKey);
    
		if (ERROR_SUCCESS == lResult)
		{        
			//
			//  Check to see if we have a path to work from.
			//
        
			DWORD dwSize = MAX_PATH;
			DWORD dwType = REG_SZ;
        
			if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegPath, NULL, &dwType, 
				(LPBYTE)m_szCmmgrPath, &dwSize))
			{
				//
				//	Now construct the base object
				//
				MYVERIFY(CELEMS(m_szPath) > (UINT)wsprintf(m_szPath, TEXT("%s\\cmdial32.dll"), 
					m_szCmmgrPath));

				Init();
			}
            RegCloseKey(hKey);
		}
	}
	else
	{
		Init();
	}
}

CmVersion::~CmVersion()
{
	//	nothing to do really
}

BOOL CmVersion::GetInstallLocation(LPTSTR szStr)
{
    if ((m_bIsPresent) && (TEXT('\0') != m_szCmmgrPath[0]) && (NULL != szStr))
    {
        lstrcpy(szStr, m_szCmmgrPath);
    }

    return m_bIsPresent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsetup\cmplat.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmplat.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of CPlatform class
//				use it to query the system for all kinds of platform info
//				OSVersion, machine architecture, etc....
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header   08/19/99
//
//+----------------------------------------------------------------------------

#include "cmplat.h"

//
//	Constants
//
 
const TCHAR* const c_pszSrvOrWksPath = TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions");
const TCHAR* const c_pszProductType = TEXT("ProductType");
const TCHAR* const c_pszSrvString = TEXT("ServerNT");
const TCHAR* const c_pszEntString = TEXT("LanManNT");
const TCHAR* const c_pszWksString = TEXT("WinNT");

//________________________________________________________________________________
//
// Function:  CPlatform constructor
//
// Synopsis:  .initializes the class, all the functions are ready to be used
//
// Arguments: None
//
// Returns:   NONE
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________

CPlatform::CPlatform()
{
    ZeroMemory(&m_SysInfo, sizeof(m_SysInfo));
    GetSystemInfo(&m_SysInfo);	// Does not fail!

    m_OSVer.dwOSVersionInfoSize = sizeof(m_OSVer); 
    if (!GetVersionEx(&m_OSVer)) 
    { 
        m_ClassState = bad; //Something went wrong 
    }
    else
    {
        m_ClassState = good;
    }
}

//________________________________________________________________________________
//
// Function:  IsOS
//
// Synopsis:  
//
// Arguments: DWORD OS, DWORD buildNum
//
// Returns:   BOOL - TRUE means running on OS specified
//
// History:   Created Header    1/30/98
//
//________________________________________________________________________________

BOOL CPlatform::IsOS(DWORD OS, DWORD buildNum)
{

    if (m_OSVer.dwPlatformId != OS)
    {
        return FALSE;
    }

    if ( (m_OSVer.dwBuildNumber & 0xffff) > buildNum) //Check for higher than developer release 
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//________________________________________________________________________________
//
// Function:  IsOSExact
//
// Synopsis:  
//
// Arguments: DWORD OS, DWORD buildNum
//
// Returns:   BOOL - TRUE means running on OS specified
//
// History:   Created Header    1/30/98
//
//________________________________________________________________________________

BOOL CPlatform::IsOSExact(DWORD OS, DWORD buildNum)
{

    if (m_OSVer.dwPlatformId != OS)
    {
        return FALSE;
    }

    if ((m_OSVer.dwBuildNumber & 0xffff) == buildNum) //Check for exact match
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//________________________________________________________________________________
//
// Function:  IsX86
//
// Synopsis:  Determines if the current platform IsX86.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsX86
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________


BOOL	
CPlatform::IsX86()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }
    return (m_SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL);
}
//________________________________________________________________________________
//
// Function:  IsAlpha
//
// Synopsis:  Determines if the current platform IsAlpha.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsAlpha
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________
BOOL	
CPlatform::IsAlpha()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }
    return (m_SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA);
}

//________________________________________________________________________________
//
// Function:  IsIA64
//
// Synopsis:  Determines if the current platform is an IA64 machine.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform is an itanium.
//
// History:   quintinb Created    07/20/2000
//
//________________________________________________________________________________
BOOL	
CPlatform::IsIA64()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    return ((m_SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64) ||
            (m_SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64));
}

//________________________________________________________________________________
//
// Function:  IsWin95Gold
//
// Synopsis:  Determines if the current platform IsWin95.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsWin95
//
// History:   quintinb Created 2/20/1998
//
//________________________________________________________________________________


BOOL	
CPlatform::IsWin95Gold()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    if (IsOSExact(VER_PLATFORM_WIN32_WINDOWS, 950))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//________________________________________________________________________________
//
// Function:  IsWin95
//
// Synopsis:  Determines if the current platform IsWin95Gold.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsWin95Gold
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________

BOOL	
CPlatform::IsWin95()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    if ( (IsOS(VER_PLATFORM_WIN32_WINDOWS, 950)) && (!IsOS(VER_PLATFORM_WIN32_WINDOWS, 1352)) )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//________________________________________________________________________________
//
// Function:  IsWin98
//
// Synopsis:  Determines if the current platform IsWin98.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsWin98
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________


BOOL	
CPlatform::IsWin98()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }
    return IsOS(VER_PLATFORM_WIN32_WINDOWS, 1353);
}

//________________________________________________________________________________
//
// Function:  IsWin98Sr
//
// Synopsis:  Determines if the current platform is a Service Release of Win98 (not
//            win98 gold).
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform is a Sr of win98
//
// History:   quintinb created 1-8-99
//
//________________________________________________________________________________

BOOL	
CPlatform::IsWin98Sr()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }
    
    //
    //  Win98 gold had 1998 for the build number
    //
    return IsOS(VER_PLATFORM_WIN32_WINDOWS, 1998);
}

//________________________________________________________________________________
//
// Function:  IsWin98Gold
//
// Synopsis:  Determines if the current platform is Win98 Gold (build Num 1998)
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform is Gold win98
//
// History:   quintinb created 1-8-99
//
//________________________________________________________________________________
BOOL	
CPlatform::IsWin98Gold()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    if ((IsOS(VER_PLATFORM_WIN32_WINDOWS, 1353)) && (!IsOS(VER_PLATFORM_WIN32_WINDOWS, 1998)))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//________________________________________________________________________________
//
// Function:  IsWin9x
//
// Synopsis:  Determines if the current platform IsWin9x.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsWin9x
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________


BOOL	
CPlatform::IsWin9x()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    return IsOS(VER_PLATFORM_WIN32_WINDOWS, 950-1);
}
//________________________________________________________________________________
//
// Function:  IsNT31
//
// Synopsis:  Determines if the current platform IsNT31.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsNT31
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________


BOOL	
CPlatform::IsNT31()
{
    if (bad == m_ClassState)
    {
        return false;
    }

    if ( (IsOS(VER_PLATFORM_WIN32_NT , 0)) && (!IsOS(VER_PLATFORM_WIN32_NT , 1057)) )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}
//________________________________________________________________________________
//
// Function:  IsNT351
//
// Synopsis:  Determines if the current platform IsNT351.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsNT351
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________


BOOL	
CPlatform::IsNT351()
{
    if (bad == m_ClassState)
    {
        return false;
    }

    if ( (IsOS(VER_PLATFORM_WIN32_NT , 1056)) && (!IsOS(VER_PLATFORM_WIN32_NT , 1382)) )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
//________________________________________________________________________________
//
// Function:  IsNT4
//
// Synopsis:  Determines if the current platform IsNT4.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsNT4
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________


BOOL	
CPlatform::IsNT4()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    if ( (IsOS(VER_PLATFORM_WIN32_NT , 1380)) && (!IsOS(VER_PLATFORM_WIN32_NT , 1500)) )	//1500 not sure
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//________________________________________________________________________________
//
// Function:  IsAtLeastNT5
//
// Synopsis:  Determines if the current platform at least NT5.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform is NT5 or newer
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________
BOOL	
CPlatform::IsAtLeastNT5()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }
    return IsOS(VER_PLATFORM_WIN32_NT, 1500);
}

//________________________________________________________________________________
//
// Function:  IsAtLeastNT51
//
// Synopsis:  Determines if the current platform at least NT51.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform is NT5 or newer
//
// History:   quintinb Created    02/09/2001
//
//________________________________________________________________________________
BOOL
CPlatform::IsAtLeastNT51()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    return IsOS(VER_PLATFORM_WIN32_NT, 2200);
}

//________________________________________________________________________________
//
// Function:  IsNT5
//
// Synopsis:  Determines if the current platform is NT5.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform is NT5
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________
BOOL	
CPlatform::IsNT5()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    if ( (IsOS(VER_PLATFORM_WIN32_NT , 1500)) && (!IsOS(VER_PLATFORM_WIN32_NT , 2195)))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//________________________________________________________________________________
//
// Function:  IsNT51
//
// Synopsis:  Determines if the current platform at least NT51.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform is NT51
//
// History:   quintinb Created    02/09/2001
//
//________________________________________________________________________________
BOOL	
CPlatform::IsNT51()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    if ((IsOS(VER_PLATFORM_WIN32_NT , 2195)) && (!IsOS(VER_PLATFORM_WIN32_NT , 2600))) // ISSUE quintinb 3/22/01: Update this if we need it.
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//________________________________________________________________________________
//
// Function:  IsNT
//
// Synopsis:  Determines if the current platform IsNT.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsNT
//
// History:   quintinb Created    9/22/1998
//
//________________________________________________________________________________
BOOL	
CPlatform::IsNT()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }
    return IsOS(VER_PLATFORM_WIN32_NT, 0);
}

//________________________________________________________________________________
//
// Function:  IsNTSrv
//
// Synopsis:  Determines if the current platform IsNT.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsNT
//
// History:   quintinb Created    9/22/1998
//
//________________________________________________________________________________
BOOL CPlatform::IsNTSrv()
{
    HKEY hKey;
    TCHAR szTemp[MAX_PATH+1];
    BOOL bReturn = FALSE;

    if ((good == m_ClassState)  && (IsOS(VER_PLATFORM_WIN32_NT, 0)))
    {
        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, c_pszSrvOrWksPath, &hKey))
        {
            DWORD dwSize = MAX_PATH;
            DWORD dwType = REG_SZ;

            if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszProductType, NULL, &dwType, 
                (LPBYTE)szTemp, &dwSize))
            {
                bReturn = ((0 == lstrcmpi(szTemp, c_pszSrvString)) || 
                    (0 == lstrcmpi(szTemp, c_pszEntString)));
            }

            RegCloseKey(hKey);
        }
    }
    return bReturn;
}

BOOL CPlatform::IsNTWks()
{
    HKEY hKey;
    TCHAR szTemp[MAX_PATH+1];
    BOOL bReturn = FALSE;

    if ((good == m_ClassState)  && (IsOS(VER_PLATFORM_WIN32_NT, 0)))
    {
        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, c_pszSrvOrWksPath, &hKey))
        {
            DWORD dwSize = MAX_PATH;
            DWORD dwType = REG_SZ;

            if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszProductType, NULL, &dwType, 
                (LPBYTE)szTemp, &dwSize))
            {
                bReturn = (0 == lstrcmpi(szTemp, c_pszWksString));
            }

            RegCloseKey(hKey);
        }
    }
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsetup\fileexists.cpp ===
//+----------------------------------------------------------------------------
//
// File:     fileexists.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the FileExists function.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/19/99
//
//+----------------------------------------------------------------------------
#include "cmsetup.h"

//+----------------------------------------------------------------------------
//
// Function:  FileExists
//
// Synopsis:  Helper function to encapsulate determining if a file exists. 
//
// Arguments: LPCTSTR pszFullNameAndPath - The FULL Name and Path of the file.
//
// Returns:   BOOL - TRUE if the file is located
//
// History:   nickball    Created    3/9/98
//
//+----------------------------------------------------------------------------
BOOL FileExists(LPCTSTR pszFullNameAndPath)
{
    MYDBGASSERT(pszFullNameAndPath);

    if (pszFullNameAndPath && pszFullNameAndPath[0])
    {
        HANDLE hFile = CreateFile(pszFullNameAndPath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
            return TRUE;
        }
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsetup\createld.cpp ===
//+----------------------------------------------------------------------------
//
// File:     createld.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the CreateLayerDirectory function.
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/19/99
//
//+----------------------------------------------------------------------------
#include <windows.h>
#include <tchar.h>
#include <cmsetup.h>

//+----------------------------------------------------------------------------
//
// Function:  CreateLayerDirectory
//
// Synopsis:  Given a path to a directory, this function creates the path (if necessary)
//			  layer by layer.
//
// Arguments: LPCTSTR str - path to be created
//
// Returns:   TRUE if the directory was created (or exists), FALSE otherwise.
//
// Note:	This function was taken from cmocm.cpp.
//
// History:   quintinb   Created Header		12/15/97
//			  
//
//+----------------------------------------------------------------------------

BOOL CreateLayerDirectory( LPCTSTR str )
{
    BOOL fReturn = TRUE;

    do
    {
        INT index=0;
        INT iLength = _tcslen(str);

        // first find the index for the first directory
        if ( iLength > 2 )
        {
            if ( str[1] == _T(':'))
            {
                // assume the first character is driver letter
                if ( str[2] == _T('\\'))
                {
                    index = 2;
                } else
                {
                    index = 1;
                }
            } else if ( str[0] == _T('\\'))
            {
                if ( str[1] == _T('\\'))
                {
                    BOOL fFound = FALSE;
                    INT i;
                    INT nNum = 0;
                    // unc name
                    for (i = 2; i < iLength; i++ )
                    {
                        if ( str[i]==_T('\\'))
                        {
                            // find it
                            nNum ++;
                            if ( nNum == 2 )
                            {
                                fFound = TRUE;
                                break;
                            }
                        }
                    }
                    if ( fFound )
                    {
                        index = i;
                    } else
                    {
                        // bad name
                        break;
                    }
                } else
                {
                    index = 1;
                }
            }
        } else if ( str[0] == _T('\\'))
        {
            index = 0;
        }

        // okay ... build directory
        do
        {
            // find next one
            do
            {
                if ( index < ( iLength - 1))
                {
                    index ++;
                } else
                {
                    break;
                }
            } while ( str[index] != _T('\\'));


            TCHAR szCurrentDir[MAX_PATH+1];

            if (GetCurrentDirectory(MAX_PATH+1, szCurrentDir))
            {

                TCHAR szNewDir[MAX_PATH+1];
                _tcscpy(szNewDir, str);
                szNewDir[index+1]=0;

                if ( !SetCurrentDirectory(szNewDir))
                {
                    if (( fReturn = CreateDirectory(szNewDir, NULL )) != TRUE )
                    {
                        break;
                    }
                }

                SetCurrentDirectory( szCurrentDir );

                if ( index >= ( iLength - 1 ))
                {
                    fReturn = TRUE;
                    break;
                }
            }
            else
            {
                fReturn = FALSE;
                break;
            }
        } while ( TRUE );
    } while (FALSE);

    return(fReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsetup\processcmdln.cpp ===
//+----------------------------------------------------------------------------
//
// File:     processcmdln.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the CProcessCmdLn class.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------
#include "cmsetup.h"
#include "setupmem.h"

//+----------------------------------------------------------------------------
//
// Function:  CProcessCmdLn::CProcessCmdLn
//
// Synopsis:  Inits the class by copying the valid command line switches to the
//            command line switch array.
//
// Arguments: UINT NumSwitches - Number of switches in the array
//            UINT NumCharsInSwitch - Number of chars in each switch, counting the terminating NULL
//            TCHAR pszCommandLineSwitches[][] - Array of command line switches.
//
// Returns:   Nothing
//
// History:   quintinb  Created     7/24/98
//
//+----------------------------------------------------------------------------
CProcessCmdLn::CProcessCmdLn(UINT NumSwitches, ArgStruct* pArrayOfArgStructs, 
							 BOOL bSkipFirstToken, BOOL bBlankCmdLnOkay)
{
    m_NumSwitches = NumSwitches;
    m_bSkipFirstToken = bSkipFirstToken;
    m_bBlankCmdLnOkay = bBlankCmdLnOkay;
    m_CommandLineSwitches = NULL;

    m_CommandLineSwitches = (ArgStruct*)CmMalloc(m_NumSwitches*sizeof(ArgStruct));

    if (m_CommandLineSwitches)
    {
        for(UINT i =0; i < NumSwitches; i++)
        {
            m_CommandLineSwitches[i].pszArgString = 
                (TCHAR*)CmMalloc(sizeof(TCHAR)*(lstrlen(pArrayOfArgStructs[i].pszArgString) + 1));

            if (m_CommandLineSwitches[i].pszArgString)
            {
                lstrcpyn(m_CommandLineSwitches[i].pszArgString, 
                    pArrayOfArgStructs[i].pszArgString, 
                    (lstrlen(pArrayOfArgStructs[i].pszArgString) + 1));

                m_CommandLineSwitches[i].dwFlagModifier = pArrayOfArgStructs[i].dwFlagModifier;
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CProcessCmdLn::~CProcessCmdLn
//
// Synopsis:  Cleans up after the class by deleting the dynamically allocated
//            string.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    7/24/98
//
//+----------------------------------------------------------------------------
CProcessCmdLn::~CProcessCmdLn()
{
    if (m_CommandLineSwitches)
    {
        for(UINT i =0; i < m_NumSwitches; i++)
        {
            CmFree(m_CommandLineSwitches[i].pszArgString);			
        }
        CmFree(m_CommandLineSwitches);
    }
}


//+----------------------------------------------------------------------------
//
// Function:  CProcessCmdLn::IsValidSwitch
//
// Synopsis:  This function tells whether the inputed switch is a recognized
//            command line switch.
//
// Arguments: LPCTSTR pszSwitch - Input switch string to be tested
//
// Returns:   BOOL - Returns TRUE if the switch passed in is recognized as valid
//
// History:   quintinb Created    7/13/98
//
//+----------------------------------------------------------------------------
BOOL CProcessCmdLn::IsValidSwitch(LPCTSTR pszSwitch, LPDWORD pdwFlags)
{
    for (UINT i = 0; i < m_NumSwitches; i++)
    {
        if (m_CommandLineSwitches[i].pszArgString && (0 == lstrcmpi(m_CommandLineSwitches[i].pszArgString, pszSwitch)))
        {
            //
            //  Then we have a match
            //
            *pdwFlags |= m_CommandLineSwitches[i].dwFlagModifier;
            return TRUE;
        }
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CProcessCmdLn::IsValidFilePath
//
// Synopsis:  This file checks to see if the inputted file path is a valid filepath.
//            This function depends on setfileattributes.
//
// Arguments: LPCTSTR pszFile - File to check to see if it exists.
//
// Returns:   BOOL - Returns TRUE if we can set the attributes of the file inputed.
//
// History:   quintinb Created   7/13/98
//
//+----------------------------------------------------------------------------
BOOL CProcessCmdLn::IsValidFilePath(LPCTSTR pszFile)
{
     return SetFileAttributes(pszFile, FILE_ATTRIBUTE_NORMAL);
}



//+----------------------------------------------------------------------------
//
// Function:  CProcessCmdLn::EnsureFullFilePath
//
// Synopsis:  This file checks to see if a file path passed in is a full path.
//            If it is not a full path then it adds the current directory path
//            to the beginning (assuming that we have a filename and extension).
//
// Arguments: LPTSTR pszFile - File to check
//            UINT uNumChars - Number of chars in the buffer holding pszFile
//
// Returns:   BOOL - TRUE if a full file path
//
// History:   quintinb  Created    7/24/98
//
//+----------------------------------------------------------------------------
BOOL CProcessCmdLn::EnsureFullFilePath(LPTSTR pszFile, UINT uNumChars)
{
    BOOL bReturn = FALSE;

    if (SetFileAttributes(pszFile, FILE_ATTRIBUTE_NORMAL))
    {
        CFileNameParts InstallFileParts(pszFile);

        if ((TEXT('\0') == InstallFileParts.m_Drive[0]) && 
            (TEXT('\0') == InstallFileParts.m_Dir[0]) &&
            (TEXT('\0') != InstallFileParts.m_FileName[0]) &&
            (TEXT('\0') != InstallFileParts.m_Extension[0]))
        {
            //
            //  Then we have a filename and extension but we don't
            //  have a full path.  Thus we want to add the current
            //  directory onto the filename and extension.
            //
            TCHAR szTemp[MAX_PATH+1];

            if (GetCurrentDirectory(MAX_PATH, szTemp))
            {
                if (uNumChars > (UINT)(lstrlen(szTemp) + lstrlen(InstallFileParts.m_FileName) + lstrlen(InstallFileParts.m_Extension) + 2))
                {
                    wsprintf(pszFile, TEXT("%s\\%s%s"), szTemp, InstallFileParts.m_FileName, InstallFileParts.m_Extension);
                    bReturn = TRUE;
                }
            }
        }
        else
        {
            //
            //  Could be a UNC path, a path with a drive letter and filename, or
            //  a full path with a drive and a dir
            //
            bReturn = TRUE;
        }
    }

    return bReturn;
}




//+----------------------------------------------------------------------------
//
// Function:  CProcessCmdLn::CheckIfValidSwitchOrPath
//
// Synopsis:  Bundles code to determine if a token is a valid switch or path.
//
// Arguments: LPCTSTR pszToken - current token
//            BOOL* pbFoundSwitch - pointer to the BOOL which tells if a switch has been found yet
//            BOOL* pbFoundPath - pointer to the BOOL which tells if a path has been found yet
//            LPTSTR pszSwitch - string to hold the switch
//            LPTSTR pszPath - string to hold the path
//
// Returns:   BOOL - returns TRUE if successful
//
// History:   quintinb Created    8/25/98
//
//+----------------------------------------------------------------------------
BOOL CProcessCmdLn::CheckIfValidSwitchOrPath(LPCTSTR pszToken, LPDWORD pdwFlags, 
                              BOOL* pbFoundPath, LPTSTR pszPath)
{
    if (IsValidSwitch(pszToken, pdwFlags))
    {
        CMTRACE1(TEXT("ProcessCmdLn - ValidSwitch is %s"), pszToken);
    }
    else if (!(*pbFoundPath))
    {
        if (IsValidFilePath(pszToken))
        {
            *pbFoundPath = TRUE;
            lstrcpy(pszPath, pszToken);

            CMTRACE1(TEXT("ProcessCmdLn - ValidFilePath is %s"), pszToken);
        }
        else
        {
            //
            //  Maybe the path contains environment variables, try to expand them.
            //
            TCHAR szExpandedPath[MAX_PATH+1] = TEXT("");

            CMTRACE1(TEXT("ProcessCmdLn - %s is not a valid path, expanding environment strings"), pszToken);
            
            ExpandEnvironmentStrings(pszToken, szExpandedPath, MAX_PATH);

            CMTRACE1(TEXT("ProcessCmdLn - expanded path is %s"), szExpandedPath);
                        
            if (IsValidFilePath(szExpandedPath))
            {
                *pbFoundPath = TRUE;
                lstrcpy(pszPath, szExpandedPath);
            }
            else
            {
                //
                //  Still no luck, return an error
                //
                CMTRACE1(TEXT("ProcessCmdLn - %s is not a valid path"), szExpandedPath);

                return FALSE;
            }
        }
    }
    else
    {
        //
        //  We don't know what this is, send back an error
        //
        CMTRACE1(TEXT("ProcessCmdLn - Invalid token is %s"), pszToken);
        
        return FALSE;                    
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Function:  CProcessCmdLn::GetCmdLineArgs
//
// Synopsis:  This function looks for any combination of just a command line 
//            switch, just a path, or both.  Handles long paths if quoted. 
//              
//
// Arguments: IN LPTSTR pszCmdln - the command line to parse 
//            OUT LPTSTR pszSwitch - Out parameter for the command line switch
//            OUT LPTSTR pszPath -  Out parameter for the path
//
// Returns:   BOOL - Returns TRUE if it was able to parse the args
//
//  History:    quintinb    rewrote InitArgs from cmmgr.cpp to make it
//                          simpler and more taylored to cmstp.     7-13-98
//              
//----------------------------------------------------------------------------
BOOL CProcessCmdLn::GetCmdLineArgs(IN LPTSTR pszCmdln, OUT LPDWORD pdwFlags, OUT LPTSTR pszPath, 
					UINT uPathStrLimit)
{
    LPTSTR  pszCurr;
    LPTSTR  pszToken;
    CMDLN_STATE state;
    BOOL bFoundSwitch = FALSE;
    BOOL bFoundPath = FALSE;

	if ((NULL == pdwFlags) || (NULL == pszPath))
	{
		return FALSE;
	}

	//
	//	Init pdwFlags to Zero
	//
	*pdwFlags = 0;

	//
	//	If m_bSkipFirstToken is TRUE, the we will skip the first Token.  Otherwise,
	//  we won't.
	//
    BOOL bFirstToken = m_bSkipFirstToken;
	
    state = CS_CHAR;
    pszCurr = pszToken = pszCmdln;

    CMTRACE1(TEXT("CProcessCmdLn::GetCmdLineArgs - Command line is %s"), pszCmdln);

    do
    {
        switch (*pszCurr)
        {
            case TEXT(' '):
                if (state == CS_CHAR)
                {
                    //
                    // we found a token
                    //

                    *pszCurr = TEXT('\0');
                    if (bFirstToken)
                    {
                        //
                        //  The first token is the name of the exe, thus throw it away
                        //
                        bFirstToken = FALSE;
                        CMTRACE1(TEXT("Throwing away, first token: %s"), pszToken);
                    }
                    else if(!CheckIfValidSwitchOrPath(pszToken, pdwFlags, &bFoundPath, 
                             pszPath))
                    {
                        //
                        //  return an error
                        //
                        return FALSE;
                    }
                 
                    *pszCurr = TEXT(' ');
                    pszCurr = pszToken = CharNext(pszCurr);
                    state = CS_END_SPACE;
                    continue;
                }
                else if (state == CS_END_SPACE || state == CS_END_QUOTE)
                {
                    pszToken = CharNext(pszToken);
                }
                break;

            case TEXT('\"'):
                if (state == CS_BEGIN_QUOTE)
                {
                    //
                    // we found a token
                    //
                    *pszCurr = TEXT('\0');

                    //
                    // skip the opening quote
                    //
                    pszToken = CharNext(pszToken);
                    if (bFirstToken)
                    {
                        //
                        //  The first token is the name of the exe, thus throw it away
                        //
                        bFirstToken = FALSE;
                        CMTRACE1(TEXT("Throwing away, first token: %s"), pszToken);
                    }
                    else if(!CheckIfValidSwitchOrPath(pszToken, pdwFlags, &bFoundPath, 
                             pszPath))
                    {
                        //
                        //  return an error
                        //
                        return FALSE;
                    }
                    
                    *pszCurr = TEXT('\"');
                    pszCurr = pszToken = CharNext(pszCurr);
                    state = CS_END_QUOTE;
                    continue;
                }
                else
                {
                    state = CS_BEGIN_QUOTE;
                }
                break;

            case TEXT('\0'):
                if (state != CS_END_QUOTE)
                {
                    if (bFirstToken)
                    {
                        //
                        //  The first token is the name of the exe, thus throw it away
                        //
                        bFirstToken = FALSE;
                        CMTRACE1(TEXT("Throwing away, first token: %s"), pszToken);
                    }
                    else if(!CheckIfValidSwitchOrPath(pszToken, pdwFlags, &bFoundPath, 
                             pszPath))
                    {
                        //
                        //  return an error
                        //
                        return FALSE;
                    }
                }
                state = CS_DONE;
                break;

            default:
                if (state == CS_END_SPACE || state == CS_END_QUOTE)
                {
                    state = CS_CHAR;
                }
                break;
        }
        
        pszCurr = CharNext(pszCurr);
    } while (state != CS_DONE);


    if (bFoundPath)
    {
        //
        //  Then at least we found a path (and maybe switches, maybe not)
        //
        return EnsureFullFilePath(pszPath, uPathStrLimit);
    }
    else if (0 != *pdwFlags)
    {
        //
        //  Then at least we found a switch
        //
        return TRUE;
    }
    else
    {
		//
		//	If it is okay to have a blank command line, then this is okay, otherwise it isn't.
		//  Note that if m_bSkipFirstToken == TRUE, then the command line might not be completely
		//  blank, it could contain the name of the executable for instance.
		//
		return m_bBlankCmdLnOkay;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsetup\cversion.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cversion.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the CVersion class, a utility class that 
//           wraps up the functionality for detecting the version of a 
//           given module filename.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/19/99
//
//+----------------------------------------------------------------------------
#include "cmsetup.h"
#include "getmodulever.cpp"

CVersion::CVersion(LPTSTR szFile)
{
    m_bIsPresent = FALSE;
    m_szPath[0] = TEXT('\0');
    DWORD dwVersion = 0;
    DWORD dwBuild = 0;

    if ((NULL != szFile) && (TEXT('\0') != szFile[0]))
    {
        lstrcpy(m_szPath, szFile);
        Init();
    }
}

CVersion::CVersion()
{
    m_bIsPresent = FALSE;
    m_szPath[0] = TEXT('\0');
    DWORD dwVersion = 0;
    DWORD dwBuild = 0;
}

CVersion::~CVersion()
{
    //  nothing to do really
}

void CVersion::Init()
{
    MYDBGASSERT(TEXT('\0') != m_szPath[0]);

    //
    //  Check to see if we have version information
    //

    HRESULT hr = GetModuleVersionAndLCID(m_szPath, &m_dwVersion, &m_dwBuild, &m_dwLCID);
    
    if (SUCCEEDED(hr))
    {
        m_bIsPresent = TRUE;
        CMTRACE3(TEXT("%s has Version = %u.%u"), m_szPath, (DWORD)HIWORD(m_dwVersion), (DWORD)LOWORD(m_dwVersion));
        CMTRACE3(TEXT("%s has Build Number = %u.%u"), m_szPath, (DWORD)HIWORD(m_dwBuild), (DWORD)LOWORD(m_dwBuild));
        CMTRACE2(TEXT("%s has LCID = %u"), m_szPath, m_dwLCID);
    }
}

BOOL CVersion::IsPresent()
{
    return m_bIsPresent;
}

BOOL CVersion::GetVersionString(LPTSTR szStr)
{
    if ((NULL != szStr) && (0 != m_dwVersion))
    {
        MYVERIFY(0 != (UINT)wsprintf(szStr, TEXT("%u.%u"), (DWORD)HIWORD(m_dwVersion), 
            (DWORD)LOWORD(m_dwVersion)));
        return TRUE;
    }

    return FALSE;
}

BOOL CVersion::GetBuildNumberString(LPTSTR szStr)
{
    if ((NULL != szStr) && (0 != m_dwBuild))
    {
        MYVERIFY(0 != (UINT)wsprintf(szStr, TEXT("%u.%u"), (DWORD)HIWORD(m_dwBuild), 
            (DWORD)LOWORD(m_dwBuild)));
        return TRUE;
    }

    return FALSE;
}


BOOL CVersion::GetFilePath(LPTSTR szStr)
{
    if ((m_bIsPresent) && (TEXT('\0') != m_szPath[0]) && (NULL != szStr))
    {
        lstrcpy(szStr, m_szPath);
    }

    return m_bIsPresent;
}


DWORD CVersion::GetVersionNumber()
{
    return m_dwVersion;
}

DWORD CVersion::GetBuildAndQfeNumber()
{
    return m_dwBuild;
}

DWORD CVersion::GetMajorVersionNumber()
{
    return (DWORD)HIWORD(m_dwVersion);
}

DWORD CVersion::GetMinorVersionNumber()
{
    return (DWORD)LOWORD(m_dwVersion);
}

DWORD CVersion::GetBuildNumber()
{
    return (DWORD)HIWORD(m_dwBuild);
}

DWORD CVersion::GetQfeNumber()
{
    return (DWORD)LOWORD(m_dwBuild);
}

DWORD CVersion::GetLCID()
{
    return m_dwLCID;
}

// Note the following is a non-class function:

//+----------------------------------------------------------------------------
//
// Function:  ArePrimaryLangIDsEqual
//
// Synopsis:  Helper routine to compare the Primary Language IDs of two given
//            LCIDs.
//
// Arguments: DWORD dwLCID1 - first LCID
//            DWORD dwLCID2 - second LCID
//
// Returns:   BOOL - TRUE if the LCIDs have the same Primary Language ID
//
// History:   quintinb Created     7/8/99
//
//+----------------------------------------------------------------------------
BOOL ArePrimaryLangIDsEqual(DWORD dwLCID1, DWORD dwLCID2)
{
    WORD wLangId1 = LANGIDFROMLCID(dwLCID1);
    WORD wLangId2 = LANGIDFROMLCID(dwLCID2);

    //
    //  Now Convert the LANG IDs into their respective Primary Lang IDs and compare
    //
    return (PRIMARYLANGID(wLangId1) == PRIMARYLANGID(wLangId2));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsetup\extractcm.cpp ===
#include <windows.h>
#include <shellapi.h>
//+----------------------------------------------------------------------------
//
// Function:  ExtractCmBinsFromExe
//
// Synopsis:  Launches cmbins.exe to extract the cm binaries from the executable
//            cab file.
//
// Arguments: LPTSTR pszPathToExtractFrom -- path where cmbins.exe lives
//            LPTSTR pszPathToExtractTo -- path to where cm binaries are extracted to
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created      03/14/2001
//
//+----------------------------------------------------------------------------
HRESULT ExtractCmBinsFromExe(LPTSTR pszPathToExtractFrom, LPTSTR pszPathToExtractTo)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPathToExtractTo && (TEXT('\0') != pszPathToExtractTo[0]) &&
        pszPathToExtractFrom && (TEXT('\0') != pszPathToExtractFrom[0])) 
    {
        TCHAR szFile[MAX_PATH+1] = {0};
        TCHAR szParams[MAX_PATH+1] = {0};
        LPCTSTR c_pszParamsFmt = TEXT("/c /q /t:%s");
        LPCTSTR c_pszFileFmt = TEXT("%scmbins.exe");
        LPCTSTR c_pszFileFmtWithSlash = TEXT("%s\\cmbins.exe");

        wsprintf(szParams, c_pszParamsFmt, pszPathToExtractTo);

        if (TEXT('\\') == pszPathToExtractFrom[lstrlen(pszPathToExtractFrom) - 1])
        {
            wsprintf(szFile, c_pszFileFmt, pszPathToExtractFrom);
        }
        else
        {
            wsprintf(szFile, c_pszFileFmtWithSlash, pszPathToExtractFrom);
        }
        
        SHELLEXECUTEINFO  sei = {0};

        sei.cbSize = sizeof(sei);
        sei.fMask = SEE_MASK_FLAG_NO_UI | SEE_MASK_NOCLOSEPROCESS;
        sei.nShow = SW_SHOWNORMAL;
        sei.lpFile = szFile;
        sei.lpParameters = szParams;
        sei.lpDirectory = pszPathToExtractFrom;

        if (ShellExecuteEx(&sei))
        {
            if (sei.hProcess)
            {
                WaitForSingleObject(sei.hProcess, 1000*60*1); // wait for one minute.
                CloseHandle(sei.hProcess);
            }

            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            //
            //  Make sure to return failure
            //
            if (SUCCEEDED(hr))
            {
                hr = E_UNEXPECTED;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsetup\nativecm.cpp ===
//+----------------------------------------------------------------------------
//
// File:     nativecm.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the CmIsNative function.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb       Created       01/14/99
//
//+----------------------------------------------------------------------------
#include "cmsetup.h"
#include "reg_str.h"



//+----------------------------------------------------------------------------
//
// Function:  CmIsNative
//
// Synopsis:  This function Returns TRUE if CM is native to the current OS.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if CM is native.
//
// History:   Created Header    1/17/99
//            quintinb NTRAID 364533 -- Changed IsNative so that Win98 SE won't be
//                     considered Native even if CmNative is set to 1.  See below
//                     and the bug for details.
//
//+----------------------------------------------------------------------------
BOOL CmIsNative()
{
    static BOOL bCmNotNative = -1;

    if (-1 == bCmNotNative)
    {
        const TCHAR* const c_pszRegCmNative = TEXT("CmNative");
        HKEY hKey;
        DWORD dwCmNative;

        ZeroMemory(&dwCmNative, sizeof(DWORD));

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmAppPaths, 0, KEY_READ, &hKey))
        {
            DWORD dwSize = sizeof(DWORD);
            DWORD dwType = REG_DWORD;

            if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegCmNative, NULL, &dwType, 
                (LPBYTE)&dwCmNative, &dwSize))
            {
                CPlatform cmplat;

                if (cmplat.IsWin98Sr())
                {
                    //
                    //  We no longer want Win98 SE to be native even though the key was set and
                    //  CM is a system component.  However, we may want to give ourselves an out
                    //  someday so if CmNative is set to 2 on win98 SE we will still consider it Native.
                    //  We hopefully will never need this but we might.
                    //
                    bCmNotNative = (2 != dwCmNative);
                }
                else
                {                
                    bCmNotNative = (dwCmNative ? 0 : 1);
                }
            }
            else
            {
               bCmNotNative = 1;
            }
            RegCloseKey(hKey);
        }
        else
        {
            bCmNotNative = 1;
        }
    }

    return !bCmNotNative;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsetup\regutil.cpp ===
//+----------------------------------------------------------------------------
//
// File:     regutil.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the CmDeleteRegKeyWithoutSubKeys function.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------
#include "cmsetup.h"

//+----------------------------------------------------------------------------
//
// Function:  CmDeleteRegKeyWithoutSubKeys
//
// Synopsis:  This function is used to safely delete keys on both Winnt and win95.
//            The win95 version of RegDeleteKey will delete a key with subkeys.
//            In certain situations this is desirable but in others it is not.
//
// Arguments: HKEY hBaseKey - key that pszSubKey is relative to (usually a predefined key)
//            LPCTSTR pszSubKey - String containing the subkey to delete.
//            BOOL bIgnoreValues - if TRUE, we delete even if values exist
//                                 if FALSE, then we won't delete if values exist.
//
// Returns:   LONG - Returns the value from RegDeleteKey unless it couldn't find the
//                   key specified (then returns ERROR_FILE_NOT_FOUND).  If the key
//                   exists but has subkeys (or values if bIgnoreValues == FALSE), then 
//                   it returns ERROR_FILE_EXISTS.
//
// History:   quintinb Created    9/21/98
//
//+----------------------------------------------------------------------------
LONG CmDeleteRegKeyWithoutSubKeys(HKEY hBaseKey, LPCTSTR pszKey, BOOL bIgnoreValues)
{
    DWORD dwSubKeys;
    DWORD dwValues;
    HKEY hKey = NULL;
    LPTSTR pszSubKey = NULL;
    LONG lReturn = ERROR_INVALID_PARAMETER;
    BOOL bFreePszSubKey = FALSE;

    if (hBaseKey && pszKey)
    {
        //
        //  First check to see if the subkey ends with a final slash.  If it
        //  does we need to remove it because the win9x versions of the registry
        //  APIs don't deal well with trailing slashes.
        //
        DWORD dwLen = lstrlen(pszKey);
        if (TEXT('\\') == pszKey[dwLen-1])
        {
            pszSubKey = (LPTSTR)CmMalloc((dwLen +1)*sizeof(TCHAR));
            if (pszSubKey)
            {
                lstrcpy(pszSubKey, pszKey);
                pszSubKey[dwLen-1] = TEXT('\0');
                bFreePszSubKey = TRUE; // we allocated it, so we need to delete it.
            }
            else
            {
                lReturn = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
        }
        else
        {
            pszSubKey = (LPTSTR)pszKey;
        }

        //
        //  Now open the key, check for values and subkeys, and then delete
        //  the key if it is appropriate.
        //
        if (ERROR_SUCCESS == RegOpenKeyEx(hBaseKey, pszSubKey, 0, KEY_ALL_ACCESS, &hKey))
        {
            if (ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, NULL, &dwSubKeys, NULL,
                                                 NULL, &dwValues, NULL, NULL, NULL, NULL))
            {
                if ((0 == dwSubKeys) && (bIgnoreValues || (0 == dwValues)))
                {
                    lReturn = RegDeleteKey(hBaseKey, pszSubKey);
                    goto exit;
                }
                else
                {
                    lReturn = ERROR_FILE_EXISTS;
                    goto exit;
                }
            }
        }

        lReturn = ERROR_FILE_NOT_FOUND;
    }

exit:

    if (hKey)
    {
        RegCloseKey(hKey);        
    }

    if (bFreePszSubKey)
    {
        CmFree(pszSubKey);
    }

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsetup\launchinf.cpp ===
//+----------------------------------------------------------------------------
//
// File:     launchinf.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the LaunchInfSection function.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb       Created Header        09/19/99
//
//+----------------------------------------------------------------------------
#include "cmsetup.h"
#include <advpub.h> // advpack.dll (IExpress) includes

//+----------------------------------------------------------------------------
//
// Function:  LaunchInfSection
//
// Synopsis:  Launches an specified inf section in a specified inf file using
//            advpack.dll's RunSetupCommand Function.
//
// Arguments: HINSTANCE hInstance - Instance Handle for string resources
//            LPCTSTR szInfFile - Inf file
//            LPCTSTR szInfSection - section to launch
//
// Returns:   HRESULT -- return code from advpack.dll's RunSetupCommand Function
//
// History:   Anas Jarrah A-anasj Created    2/10/98
//            quintinb  added hInstance to signature and modified to use
//                      CDynamicLibrary class       7-14-98
//            quintinb  added bQuiet Flag           7-27-98
//            quintinb  changed to use static linking to advpack.lib   11-1-98
//
//+----------------------------------------------------------------------------
HRESULT LaunchInfSection(LPCTSTR szInfFile, LPCTSTR szInfSection, LPCTSTR szTitle, BOOL bQuiet)
{

    //
    //  These flags control how the Inf Files are launched.
    //

    DWORD dwFlags;
    if (bQuiet)
    {
        dwFlags = RSC_FLAG_INF | RSC_FLAG_QUIET;
    }
    else
    {
        dwFlags = RSC_FLAG_INF;
    }
    
    //
    // holds return value of the calls to RunSetupCommand
    //
    HRESULT hrReturn;   
    
    //
    //	Set the current directory to the dir where the inf is located.
    //
    CHAR   szCurDir[MAX_PATH+1];
    CFileNameParts InfFile(szInfFile);
    
#ifdef UNICODE
    MYVERIFY(CELEMS(szCurDir) > (UINT)wsprintfA(szCurDir, "%S%S", InfFile.m_Drive, InfFile.m_Dir));
#else
    MYVERIFY(CELEMS(szCurDir) > (UINT)wsprintfA(szCurDir, "%s%s", InfFile.m_Drive, InfFile.m_Dir));
#endif


    HANDLE hWait = NULL;    // passed to the RunSetupCommand function.  Can be used to hold a process handle

    //
    //  Create the Char pointers to pass to RunSetupCommand
    //
    CHAR* pszInfFile;
    CHAR* pszInfSection;
    CHAR* pszTitle;

    //
    //  There is no UNICODE version of RunSetupCommand.  Thus we must convert strings and
    //  run it with the CHAR versions.
    //
#ifdef UNICODE

    pszInfFile = (CHAR*)CmMalloc(sizeof(CHAR)*(MAX_PATH+1));
    pszInfSection = (CHAR*)CmMalloc(sizeof(CHAR)*(MAX_PATH+1));
    pszTitle = (CHAR*)CmMalloc(sizeof(CHAR)*(MAX_PATH+1));

    if (pszInfFile && pszInfSection && pszTitle)
    {
        MYVERIFY (0 != WideCharToMultiByte(CP_ACP, 0, szInfFile, -1, 
		        pszInfFile, MAX_PATH, NULL, NULL));

        MYVERIFY (0 != WideCharToMultiByte(CP_ACP, 0, szInfSection, -1, 
		        pszInfSection, MAX_PATH, NULL, NULL));

        MYVERIFY (0 != WideCharToMultiByte(CP_ACP, 0, szTitle, -1, 
		        pszTitle, MAX_PATH, NULL, NULL));	
    }
    else
    {
        CmFree(pszInfFile);
        CmFree(pszInfSection);
        CmFree(pszTitle);

        return E_OUTOFMEMORY;
    }

#else

    pszInfFile = (char*)szInfFile;
    pszInfSection = (char*)szInfSection;
    pszTitle = (char*)szTitle;

#endif

    hrReturn = RunSetupCommand(NULL, pszInfFile, 
                    pszInfSection, szCurDir, pszTitle, &hWait, dwFlags, NULL);

    CloseHandle(hWait);

#ifdef UNICODE

    //
    //  Free the Allocated Buffers
    //
    CmFree(pszInfFile);
    CmFree(pszInfSection);
    CmFree(pszTitle);
#endif

    return hrReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  CallLaunchInfSectionEx
//
// Synopsis:  Launches an specified inf section in a specified inf file using
//            advpack.dll's RunSetupCommand Function.
//
// Arguments: LPCSTR pszInfFile - full path to the Inf file
//            LPCSTR pszInfSection - section to launch from the inf file
//            DWORD dwFlags - flags to give LaunchINFSectionEx, see advpub.h for more details
//
// Returns:   HRESULT -- standard COM error codes.  If ERROR_SUCCESS_REBOOT_REQUIRED,
//                       is returned, the caller should ask the user to reboot.
//                       
//
// History:   quintinb  created         02/09/2001
//
//+----------------------------------------------------------------------------
HRESULT CallLaunchInfSectionEx(LPCSTR pszInfFile, LPCSTR pszInfSection, DWORD dwFlags)
{
    //
    //  Check the inputs
    //
    if ((NULL == pszInfFile) || (NULL == pszInfSection) || (TEXT('\0') == pszInfFile[0]) || (TEXT('\0') == pszInfSection[0]))
    {
        return E_INVALIDARG;
    }

    //
    //  Now calculate how large of a buffer we will need to send to LaunchINFSectionEx with the params and allocate it.
    //
    DWORD dwSize = (lstrlenA(pszInfFile) + lstrlenA(pszInfSection) + 10 + 2 + 1)*sizeof(CHAR); // 10 chars is max size of a DWORD + 2 commas + a NULL

    LPSTR pszParams = (LPSTR)CmMalloc (dwSize);

    if (NULL == pszParams)
    {
        return E_OUTOFMEMORY;
    }

    //
    //  Fill in the allocated buffer
    //
    wsprintfA(pszParams, "%s,%s,,%d", pszInfFile, pszInfSection, dwFlags);

    //
    //  Call LaunchINFSectionEx
    //
    HRESULT hr = LaunchINFSectionEx(NULL, NULL, pszParams, 0);

    if (FAILED(hr))
    {
        CMTRACE3A("CallLaunchInfSectionEx -- LaunchINFSectionEx on file ""%s"" and section ""%s"" FAILED!  hr=0x%x", pszInfFile, pszInfSection, hr);
    }
    else
    {
        if ((HRESULT)ERROR_SUCCESS_REBOOT_REQUIRED == hr)
        {
            CMTRACE2A("CallLaunchInfSectionEx -- LaunchINFSectionEx on file ""%s"" and section ""%s"" returned reboot required.", pszInfFile, pszInfSection);
        }    
    }

    CmFree(pszParams);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmstp\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h
//
// Module:   CMSTP.EXE
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header    08/19/99
//
//+----------------------------------------------------------------------------

#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include "common.h"

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmstp\common.cpp ===
//+----------------------------------------------------------------------------
//
// File:     common.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This source file contains functions common to several 
//           different aspects of the CM profile installer (install, 
//           uninstall, migration).
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created     11/18/97
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

//
//  for GetPhoneBookPath
//
#include "linkdll.cpp"
#include "allowaccess.cpp"
#include "getpbk.cpp"

//
//  For GetAllUsersCmDir
//
#include "allcmdir.cpp"

//
//  Need the definition for CM_PBK_FILTER_PREFIX
//
#include "cmdefs.h"

//
//  Include the SafeNet detection code... note that
//  cmstp doesn't include the UAPI and thus requires
//  a fixup for RegOpenKeyExU
//
#ifndef RegOpenKeyExU
    #ifdef UNICODE
    #define RegOpenKeyExU RegOpenKeyExW
    #else
    #define RegOpenKeyExU RegOpenKeyExA
    #endif
#endif

#ifndef RegQueryValueExU
    #ifdef UNICODE
    #define RegQueryValueExU RegQueryValueExW
    #else
    #define RegQueryValueExU RegQueryValueExA
    #endif
#endif

#ifndef lstrcatU
    #ifdef UNICODE
    #define lstrcatU lstrcatW
    #else
    #define lstrcatU lstrcatA
    #endif
#endif

#ifndef lstrlenU
    #ifdef UNICODE
    #define lstrlenU lstrlenW
    #else
    #define lstrlenU lstrlenA
    #endif
#endif

#include "cmsafenet.cpp"

//
//  Include the Connections folder specific headers
//
//#include "shlobjp.h"
//#include <objbase.h>    // needed for initing guids
//#include <initguid.h>   // DON'T CHANGE the ORDER of these header files unless you know what you are doing
//#include <oleguid.h>    // IID_IDataObject
//#include <shlguid.h>    // IID_IShellFolder

//+----------------------------------------------------------------------------
//
// Function:  GetHiddenPhoneBookPath
//
// Synopsis:  This function returns the path for the hidden RAS pbk to contain
//            the PPP connectoid of a double dial connection.  Before returing
//            it checks to see if the phonebook exists or not.  If the phonebook
//            doesn't exist then it returns FALSE.  If the function returns
//            TRUE the path allocated and stored in *ppszPhonebook must be
//            freed using CmFree.
//
// Arguments: LPCTSTR pszProfileDir - full path to the profile directory (dir where cmp resides)
//            LPTSTR* ppszPhonebook - pointer to hold the allocated path
//
// Returns:   BOOL - TRUE if the phonebook path can be constructed and the
//                   phonebook file exists.
//
// History:   quintinb Created Header    04/14/00
//
//+----------------------------------------------------------------------------
BOOL GetHiddenPhoneBookPath(LPCTSTR pszInstallDir, LPTSTR* ppszPhonebook)
{
    //
    // Decided to fix this function so that it correctly returns the hidden phonebook path.
    // Most of this code is taken from GetPhoneBookPath. We needed to fix this functions
    // so that we can delete (local & global) Internet credentials.
    // This file is now named _CMPhone (no .pbk extension) and is now located in the same directory
    // as the rasphone.pbk file on NT4, Win2K, and WinXP.  Note that this function isn't
    // used on Win9x or NT4.  
    //

    BOOL bReturn = FALSE;

    if (NULL == ppszPhonebook)
    {
        CMASSERTMSG(FALSE, TEXT("GetHiddenPhoneBookPath -- Invalid Parameter"));
        return FALSE;
    }

    CPlatform plat;

    if (plat.IsAtLeastNT5())
    {
        if ((NULL == pszInstallDir) || (TEXT('\0') == pszInstallDir[0]))
        {
            CMASSERTMSG(FALSE, TEXT("GetHiddenPhoneBookPath -- Invalid Install Dir parameter."));
            return FALSE;
        }

        //
        //  Now Create the path to the phonebook.
        //
        LPTSTR pszPhonebook;
        TCHAR szInstallDir[MAX_PATH+1];
        ZeroMemory(szInstallDir, CELEMS(szInstallDir));

        if (TEXT('\\') == pszInstallDir[lstrlen(pszInstallDir) - 1])
        {
            //
            //  Then the path ends in a backslash.  Thus we won't properly
            //  remove CM from the path.  Remove the backslash.
            //
            
            lstrcpyn(szInstallDir, pszInstallDir, min(lstrlen(pszInstallDir), MAX_PATH));
        }
        else
        {
            lstrcpy(szInstallDir, pszInstallDir);
        }

        CFileNameParts InstallDirPath(szInstallDir);

        pszPhonebook = (LPTSTR)CmMalloc(lstrlen(InstallDirPath.m_Drive) + 
                                        lstrlen(InstallDirPath.m_Dir) + 
                                        lstrlen(c_pszPbk) + lstrlen(c_pszRasHiddenPhonePbk) + 1);

        if (NULL != pszPhonebook)
        {
            wsprintf(pszPhonebook, TEXT("%s%s%s"), InstallDirPath.m_Drive, 
                InstallDirPath.m_Dir, c_pszPbk);

            //
            //  Use CreateLayerDirectory to recursively create the directory structure as
            //  necessary (will create all the directories in a full path if necessary).
            //

            MYVERIFY(FALSE != CreateLayerDirectory(pszPhonebook));

            MYVERIFY(NULL != lstrcat(pszPhonebook, c_pszRasHiddenPhonePbk));

            HANDLE hPbk = CreateFile(pszPhonebook, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, 
                        FILE_ATTRIBUTE_NORMAL, NULL);

            //
            // If we get an invalid handle that's ok. We still have the path and should try to 
            // remove the credentials. So no need to return FALSE
            //
            if (hPbk != INVALID_HANDLE_VALUE)
            {
                MYVERIFY(0 != CloseHandle(hPbk));
            }

            *ppszPhonebook = pszPhonebook;
            bReturn = TRUE;
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("CmMalloc returned NULL"));
            return FALSE;
        }    
    }
    else
    {
        *ppszPhonebook = NULL;
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RemoveShowIconFromRunPostSetupCommands
//
// Synopsis:  This function removes showicon.exe from the RunPostSetupCommands
//            section of old 1.0 Infs.
//
// Arguments: LPCTSTR szInfFile - the inf file to remove showicon.exe from
//
// Returns:   Nothing
//
// History:   quintinb Created Header    10/22/98
//
//+----------------------------------------------------------------------------
void RemoveShowIconFromRunPostSetupCommands(LPCTSTR szInfFile)
{
    DWORD dwSize = 1024;
    DWORD dwSizeNeeded = 1024;
    TCHAR* pszBuffer = NULL;
    TCHAR* pszNewBuffer = NULL;
    const TCHAR* const c_pszRunPostSetupCommandsSection = TEXT("RunPostSetupCommandsSection");
    const TCHAR* const c_pszShowIcon = TEXT("showicon.exe");
    
    pszBuffer = (TCHAR*)CmMalloc(sizeof(TCHAR)*dwSize);
    if (NULL == pszBuffer)
    {
        CMASSERTMSG(FALSE, TEXT("RemoveShowIconFromRunPostSetupCommands -- CmMalloc returned a NULL pointer."));
        goto exit;
    }

    dwSizeNeeded = GetPrivateProfileSection(c_pszRunPostSetupCommandsSection, pszBuffer, 
        dwSize, szInfFile);

    while((dwSizeNeeded + 2) == dwSize)
    {
        //
        // the buffer isn't big enough, try again.
        //

        dwSize += 1024;

        MYDBGASSERT(dwSize <= 32*1024); // 32767 is the max size on Win95

        CmFree(pszBuffer);

        pszBuffer = (TCHAR*)CmMalloc(sizeof(TCHAR)*dwSize);
        if (NULL == pszBuffer)
        {
            CMASSERTMSG(FALSE, TEXT("RemoveShowIconFromRunPostSetupCommands -- CmMalloc returned a NULL pointer."));
            goto exit;
        }

        dwSizeNeeded = GetPrivateProfileSection(c_pszRunPostSetupCommandsSection, 
            pszBuffer, dwSize, szInfFile);
    }

    //
    //  Search the Buffer to find and remove and occurences of showicon.exe
    //

    if (0 != dwSizeNeeded)
    {
        //
        //  Allocate a new buffer of the same size.
        //
        pszNewBuffer = (TCHAR*)CmMalloc(sizeof(TCHAR)*dwSize);
        if (NULL == pszNewBuffer)
        {
            CMASSERTMSG(FALSE, TEXT("RemoveShowIconFromRunPostSetupCommands -- CmMalloc returned a NULL pointer."));
            goto exit;
        }

        //
        //  Use Temp pointers to walk the buffers
        //
        TCHAR *pszNewBufferTemp = pszNewBuffer;
        TCHAR *pszBufferTemp = pszBuffer;


        while (TEXT('\0') != pszBufferTemp[0])
        {
            //
            //  If the string isn't showicon.exe then go ahead and copy it to the new
            //  buffer.  Otherwise, don't.
            //
            if (0 != lstrcmpi(c_pszShowIcon, pszBufferTemp))
            {
                lstrcpy(pszNewBufferTemp, pszBufferTemp);
                pszNewBufferTemp = pszNewBufferTemp + (lstrlen(pszNewBufferTemp) + 1)*sizeof(TCHAR);
            }

            pszBufferTemp = pszBufferTemp + (lstrlen(pszBufferTemp) + 1)*sizeof(TCHAR);
        }

        //
        //  Erase the current Section and then rewrite it with the new section
        //

        MYVERIFY(0 != WritePrivateProfileSection(c_pszRunPostSetupCommandsSection, 
            NULL, szInfFile));

        MYVERIFY(0 != WritePrivateProfileSection(c_pszRunPostSetupCommandsSection, 
            pszNewBuffer, szInfFile));
    }

exit:
    CmFree(pszBuffer);
    CmFree(pszNewBuffer);
}


//+----------------------------------------------------------------------------
//
// Function:  HrRegDeleteKeyTree
//
// Synopsis:  Deletes an entire registry hive.
//
// Arguments:   hkeyParent  [in]   Handle to open key where the desired key resides.
//              szRemoveKey [in]   Name of key to delete.
//
// Returns:   HRESULT HrRegDeleteKeyTree - 
//
// History:   danielwe   25 Feb 1997
//            borrowed and modified -- quintinb -- 4-2-98
//
//+----------------------------------------------------------------------------
HRESULT HrRegDeleteKeyTree (HKEY hkeyParent, LPCTSTR szRemoveKey)
{
    LONG        lResult;
    HRESULT hr;
    MYDBGASSERT(hkeyParent);
    MYDBGASSERT(szRemoveKey);


    // Open the key we want to remove
    HKEY hkeyRemove;
    lResult = RegOpenKeyEx(hkeyParent, szRemoveKey, 0, KEY_ALL_ACCESS,
                                &hkeyRemove);
    hr = HRESULT_FROM_WIN32 (lResult);

    if (SUCCEEDED(hr))
    {
        TCHAR       szValueName [MAX_PATH+1];
        DWORD       cchBuffSize = MAX_PATH;
        FILETIME    ft;

        // Enum the keys children, and remove those sub-trees
        while (ERROR_NO_MORE_ITEMS != (lResult = RegEnumKeyEx(hkeyRemove,
                0,
                szValueName,
                &cchBuffSize,
                NULL,
                NULL,
                NULL,
                &ft)))
        {
            MYVERIFY(SUCCEEDED(HrRegDeleteKeyTree (hkeyRemove, szValueName)));
            cchBuffSize = MAX_PATH;
        }
        MYVERIFY(ERROR_SUCCESS == RegCloseKey (hkeyRemove));

        if ((ERROR_SUCCESS == lResult) || (ERROR_NO_MORE_ITEMS == lResult))
        {
            lResult = RegDeleteKey(hkeyParent, szRemoveKey);
        }

        hr = HRESULT_FROM_WIN32 (lResult);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  RemovePhonebookEntry
//
// Synopsis:  This function loads RAS dynamically and then deletes the specified
//            connectoids.  It will either delete only the connectoid exactly 
//            specified by the phonebook and entry name (bMatchSimilarEntries == FALSE)
//            or it will enumerate all entries in the phonebook and delete any
//            entry that matches the first lstrlen(pszEntryName) chars of the given
//            connectoid name (thus deleting backup and tunnel connectoids).  Note
//            that on NT5 we must set the <> parameter of the connectoid to "" so
//            that the RasCustomDeleteEntryNotify will not get called and thus have
//            cmstp.exe /u launched on the connection.
//
// Arguments: LPTSTR pszEntryName - the long service name of the profile to delete
//            LPTSTR pszPhonebook - the full path to the pbk file to delete entries from
//            BOOL bMatchSimilarEntries - whether the function should delete similarly
//                                        named connectoids or only the exact connectoid
//                                        specified.
//
// Returns:   BOOL - returns TRUE if the function was successful, FALSE otherwise
//
// History:   quintinb 7/14/98  Created    
//            quintinb 7/27/99  rewrote to include deleting a single connectoid or
//                              enumerating to delete all similarly named connectoids
//
//+----------------------------------------------------------------------------
BOOL RemovePhonebookEntry(LPCTSTR pszEntryName, LPTSTR pszPhonebook, BOOL bMatchSimilarEntries)
{
    pfnRasDeleteEntrySpec pfnDeleteEntry;
    pfnRasEnumEntriesSpec pfnEnumEntries;
    pfnRasSetEntryPropertiesSpec pfnSetEntryProperties;
    pfnRasSetCredentialsSpec pfnSetCredentials;

    DWORD dwStructSize;
    DWORD dwSize;
    DWORD dwNum;
    DWORD dwRet;
    DWORD dwIdx;
    DWORD dwLen;
    CPlatform plat;
    BOOL bReturn = FALSE;
    BOOL bExit;
    TCHAR szTemp[MAX_PATH+1];
    RASENTRYNAME* pRasEntries = NULL;
    RASENTRYNAME* pCurrentRasEntry = NULL;

    //
    //  Check Inputs
    //
    MYDBGASSERT(NULL != pszEntryName);
    MYDBGASSERT((NULL == pszPhonebook) || (TEXT('\0') != pszPhonebook[0]));

    if ((NULL == pszEntryName) || ((NULL != pszPhonebook) && (TEXT('\0') == pszPhonebook[0])))
    {
        CMTRACE(TEXT("RemovePhonebookEntry -- Invalid Parameter passed in."));
        goto exit;
    }
    
    //
    //  Get Function Pointers for the Ras Apis that we need
    //
    if(!GetRasApis(&pfnDeleteEntry, &pfnEnumEntries, &pfnSetEntryProperties, NULL, NULL, 
                   (plat.IsAtLeastNT5() ? &pfnSetCredentials : NULL)))
    {
        CMTRACE(TEXT("RemovePhonebookEntry -- Unable to get RAS apis."));
        bReturn = FALSE;
        goto exit;
    }

    //
    //  Setup the Structure Sizes correctly
    //
    if (plat.IsAtLeastNT5())
    {
        dwStructSize = sizeof(RASENTRYNAME_V500);
    }
    else
    {
        dwStructSize = sizeof(RASENTRYNAME);    
    }

    //
    //  Init the Size to one struct and dwNum to zero entries
    //
    bExit = FALSE;
    dwSize = dwStructSize*1;
    dwNum = 0;

    do
    {
        pRasEntries = (RASENTRYNAME*)CmMalloc(dwSize);

        if (NULL == pRasEntries)
        {
            CMASSERTMSG(FALSE, TEXT("RemovePhonebookEntry -- CmMalloc returned a NULL pointer."));
            goto exit;
        }

        //
        //  Set the struct size
        //
        pRasEntries->dwSize = dwStructSize;

        dwRet = (pfnEnumEntries)(NULL, pszPhonebook, (RASENTRYNAME*)pRasEntries, &dwSize, &dwNum); 

        //
        //  Check the return code from RasEnumEntries
        //

        if (ERROR_BUFFER_TOO_SMALL == dwRet)
        {
            CMTRACE1(TEXT("RemovePhonebookEntry -- RasEnumEntries said our buffer was too small, New Size=%u"), dwNum*dwStructSize);
            CmFree(pRasEntries);
            dwSize = dwStructSize * dwNum;
            dwNum = 0;
        }
        else if (ERROR_SUCCESS == dwRet)
        {
            CMTRACE1(TEXT("RemovePhonebookEntry -- RasEnumEntries successful, %u entries enumerated."), dwNum);
            bExit = TRUE;
        }
        else
        {
            CMTRACE1(TEXT("RemovePhonebookEntry -- RasEnumEntries Failed, dwRet == %u"), dwRet);
            goto exit;            
        }
    
    } while (!bExit);

    //
    //  At this point we should have entries to process, if not then we will exit here.  Otherwise
    //  we will look for matches and then delete any we find.
    //

    dwLen = lstrlen(pszEntryName) + 1; // get the length of the Entry Name
    bReturn = TRUE; // assume everything is okay at this point.

    //
    // okay now we are ready to perform the deletions
    //
    pCurrentRasEntry = pRasEntries;
    for (dwIdx=0; dwIdx < dwNum; dwIdx++)
    {
        CMTRACE2(TEXT("\tRemovePhonebookEntry -- RasEnumEntries returned %s in %s"), pCurrentRasEntry->szEntryName, MYDBGSTR(pszPhonebook));

        if (bMatchSimilarEntries)
        {
            //
            //  Match entries that have the first lstrlen(pszEntryName) chars
            //  the same.
            //
            lstrcpyn(szTemp, pCurrentRasEntry->szEntryName, dwLen);
        }
        else
        {
            //
            //  Only match exact entries.
            //
            lstrcpy(szTemp, pCurrentRasEntry->szEntryName);        
        }

        if (0 == lstrcmp(szTemp, pszEntryName))
        {
            //
            //  We have an entry that starts with the Long Service Name, so delete it.  Note
            //  that if this is NT5 then we need to clear the szCustomDialDll param of the 
            //  connectoid so we don't get called again on the RasCustomDeleteNotify entry
            //  point
            //

            if (plat.IsAtLeastNT5())
            {
                //
                //  On NT5, we also want to make sure we clean up any credentials associated with this
                //  connectoid.  We do that by calling RasSetCredentials
                //
                RASCREDENTIALSA RasCreds = {0};

                RasCreds.dwSize = sizeof(RASCREDENTIALSA);
                RasCreds.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain;

                dwRet = (pfnSetCredentials)(pszPhonebook, pCurrentRasEntry->szEntryName, &RasCreds, TRUE); // TRUE == fClearCredentials
                MYDBGASSERT(ERROR_SUCCESS == dwRet);

                RASENTRY_V500 RasEntryV5 = {0};

                RasEntryV5.dwSize = sizeof(RASENTRY_V500);
                RasEntryV5.dwType = RASET_Internet;
                // RasEntryV5.szCustomDialDll[0] = TEXT('\0'); -- already zero-ed

                dwRet = ((pfnSetEntryProperties)(pszPhonebook, pCurrentRasEntry->szEntryName, 
                                                 (RASENTRY*)&RasEntryV5, RasEntryV5.dwSize, NULL, 0));
                if (ERROR_SUCCESS != dwRet)
                {
                    CMTRACE3(TEXT("\t\tRemovePhonebookEntry -- RasSetEntryProperties failed on entry %s in %s, dwRet = %u"), pCurrentRasEntry->szEntryName, MYDBGSTR(pszPhonebook), dwRet);
                    bReturn = FALSE;
                    continue; // don't try to delete the entry it might cause a re-launch problem
                }
                else
                {
                    CMTRACE2(TEXT("\t\tRemovePhonebookEntry -- Clearing CustomDialDll setting with RasSetEntryProperties on entry %s in %s"), pCurrentRasEntry->szEntryName, MYDBGSTR(pszPhonebook));
                }
            }

            dwRet = (pfnDeleteEntry)(pszPhonebook, pCurrentRasEntry->szEntryName);
            
            if (ERROR_SUCCESS != dwRet)
            {
                CMTRACE3(TEXT("\t\tRemovePhonebookEntry -- RasDeleteEntry failed on entry %s in %s, dwRet = %u"), pCurrentRasEntry->szEntryName, MYDBGSTR(pszPhonebook), dwRet);
                bReturn = FALSE;  // set return to FALSE but continue trying to delete entries
            }
            else
            {
                CMTRACE2(TEXT("\t\tRemovePhonebookEntry -- Deleted entry %s in %s"), pCurrentRasEntry->szEntryName, MYDBGSTR(pszPhonebook));
            }
        }

        //
        //  Increment to next RasEntryName struct, note we have to do this manually since
        //  the sizeof(RASENTRYNAME) is wrong for NT5 structs.
        //
        pCurrentRasEntry = (RASENTRYNAME*)((BYTE*)pCurrentRasEntry + dwStructSize);
    }

exit:

    CmFree(pRasEntries);
  
    return bReturn;

}


//+----------------------------------------------------------------------------
//
// Function:  DeleteNT5ShortcutFromPathAndName
//
// Synopsis:  This function deletes the link specified by the CSIDL (see SHGetSpecialFolderLocation),
//            and the profilename.  Used before installing a profile to make
//            sure we don't get duplicate links.
//
// Arguments: LPCTSTR szProfileName - string that holds the profilename
//            int nFolder - the CSIDL identifier of the folder that holds the
//                          link to delete
//
// Returns:   Nothing
//
// History:   quintinb  Created    5/26/98
//
//+----------------------------------------------------------------------------
void DeleteNT5ShortcutFromPathAndName(HINSTANCE hInstance, LPCTSTR szProfileName, int nFolder)
{

    TCHAR szFolderDir[MAX_PATH+1];

    if (SUCCEEDED(GetNT5FolderPath(nFolder, szFolderDir)))
    {
        //
        //  Now add \Shortcut to %LongServiceName% to the end of path
        //

        TCHAR szCleanString[MAX_PATH+1];
        TCHAR szShortCutPreface[MAX_PATH+1];

        ZeroMemory(szCleanString, sizeof(szCleanString));
        MYVERIFY(0 != LoadString(hInstance, IDS_SHORTCUT_TO, szShortCutPreface, MAX_PATH));
        MYVERIFY(CELEMS(szCleanString) > (UINT)wsprintf(szCleanString, TEXT("%s\\%s %s.lnk"), szFolderDir, szShortCutPreface, szProfileName));
        
        if (SetFileAttributes(szCleanString, FILE_ATTRIBUTE_NORMAL))
        {
            SHFILEOPSTRUCT fOpStruct;
            ZeroMemory(&fOpStruct, sizeof(fOpStruct));
            fOpStruct.wFunc = FO_DELETE;
            fOpStruct.pFrom = szCleanString;
            fOpStruct.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;

            //
            //  The shell32.dll on Win95 doesn't contain the SHFileOperationW function.  Thus if we compile
            //  this Unicode we must revisit this code and dynamically link to it.
            //

            MYVERIFY(0 == SHFileOperation(&fOpStruct));
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CreateNT5ProfileShortcut
//
// Synopsis:  This function uses private APIs in NetShell.dll to create a desktop
//            shortcut to the specified connections.
//
// Arguments: LPTSTR pszProfileName - Name of the Connection to look for
//            LPTSTR pszPhoneBook - Full path to the pbk that the connection resides in
//            BOOL bAllUsers - TRUE if looking for an All Users connection
//
// Returns:   HRESULT - returns normal hr codes
//
// History:   quintinb Created    5/5/98
//            quintinb Updated to use Netshell APIs    2/17/99
//
//+----------------------------------------------------------------------------
HRESULT CreateNT5ProfileShortcut(LPCTSTR pszProfileName, LPCTSTR pszPhoneBook, BOOL bAllUsers)
{

    HRESULT hr = E_FAIL;
    pfnCreateShortcutSpec pfnCreateShortcut = NULL;
    pfnRasGetEntryPropertiesSpec pfnGetEntryProperties = NULL;

    //
    //  Check Inputs
    //
    if ((NULL == pszProfileName) || (TEXT('\0') == pszProfileName[0]) || 
        (NULL != pszPhoneBook && TEXT('\0') == pszPhoneBook[0]))
    {
        //
        //  Then they passed in an invalid string argument, thus return invalid arg.  Note
        //  that pszPhoneBook can be NULL but that if it isn't NULL it cannot be empty.
        //
        return E_INVALIDARG;    
    }

    //
    //  First Find the GUID of the connection
    //

    if (!GetRasApis(NULL, NULL, NULL, NULL, &pfnGetEntryProperties, NULL))
    {
        return E_UNEXPECTED;   
    }

    DWORD dwRes;
    DWORD dwSize;
    LPRASENTRY_V500 pRasEntry = NULL;

    pRasEntry = (LPRASENTRY_V500)CmMalloc(sizeof(RASENTRY_V500));

    if (NULL != pRasEntry)
    {
        ZeroMemory(pRasEntry, sizeof(RASENTRY_V500));        
        pRasEntry->dwSize = sizeof(RASENTRY_V500);
        dwSize = sizeof(RASENTRY_V500);

        dwRes = (pfnGetEntryProperties)(pszPhoneBook, pszProfileName, (LPRASENTRY)pRasEntry, &dwSize, NULL, NULL);
        if (0 == dwRes)
        {
            //
            //  Then we were able to get the RasEntry, load the NetShell API 
            //  and call HrCreateShortcut        
            //
            pfnSHGetSpecialFolderPathWSpec pfnSHGetSpecialFolderPathW;

            if(GetShell32Apis(NULL, &pfnSHGetSpecialFolderPathW))
            {                   
                WCHAR szwPath[MAX_PATH+1];
                
                hr = (pfnSHGetSpecialFolderPathW)(NULL, szwPath, 
                    bAllUsers ? CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY, FALSE);

                if (SUCCEEDED(hr) && GetNetShellApis(NULL, &pfnCreateShortcut, NULL))
                {
                    hr = (pfnCreateShortcut)(pRasEntry->guidId, szwPath);
                }
            }
        }
        else
        {
            CMTRACE1(TEXT("CreateNT5ProfileShortcut -- RasGetEntryProperties returned %u"), dwRes);
            CMASSERTMSG(FALSE, TEXT("Unable to find the connection for which the shortcut was requested in the RAS pbk."));
            return HRESULT_FROM_WIN32(ERROR_CONNECTION_INVALID);
        }
        CmFree(pRasEntry);
    }
    
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteCmPhonebookEntry
//
// Synopsis: This function creates an NT5 phonebook entry for a CM connection.
//           .
//           The function sets:
//              - the szAutoDialDll to cmdial32.dll
//              - the modem name and device type
//              - the type to RASET_Inernet. 
//
// Arguments: LPCTSTR szLongServiceName - Name of the Connectoid to be created
//            LPCTSTR szFullPathtoPBK - full path to the pbk to put the connectoid in, if NULL
//                                     the system phonebook is used.
//            LPCTSTR pszCmsFile - The full path of the referencing .CMS for the profile 
//
// Returns:   BOOL - TRUE on success
//
// History:   05/05/98 - quintinb - Created Header    
//            ??/??/?? - henryt   - Modified to work on multiple platforms.  added modem stuff.
//            01/12/99 - nickball - Replaced fDoDirectConnect with szCmsFile. Handled no modem case.
//
//+----------------------------------------------------------------------------
BOOL WriteCmPhonebookEntry(LPCTSTR szLongServiceName, 
                           LPCTSTR szFullPathtoPBK, 
                           LPCTSTR pszCmsFile)
{
    pfnRasSetEntryPropertiesSpec pfnSetEntryProperties;
    DWORD dwRet = 1;
    CPlatform plat;
    RASENTRY    *pRasEntry = NULL;
    BOOL bReturn = FALSE;
    DWORD dwReturn;
    BOOL fSupportDialup;
    BOOL fSupportDirect;
    BOOL fDoDirectConnect;
    BOOL fSeekVpn;
    const TCHAR* const c_pszOne                 = TEXT("1");

    MYDBGASSERT(szLongServiceName);
    MYDBGASSERT(pszCmsFile);

    if (NULL == szLongServiceName || NULL == pszCmsFile)
    {
        return FALSE;
    }

    CMTRACE2(TEXT("WriteCmPhonebookEntry() - szLongServiceName  is %s, szFullPathtoPBK is %s"), szLongServiceName, szFullPathtoPBK ? szFullPathtoPBK : TEXT("<NULL>"));

    if (!GetRasApis(NULL, NULL, &pfnSetEntryProperties, NULL, NULL, NULL))
    {
        return FALSE;   
    }

    //
    // alloc RASENTRY properly
    //

    if (plat.IsAtLeastNT5())
    {
        RASENTRY_V500 *pRasEntryV500 = (RASENTRY_V500 *)CmMalloc(sizeof(RASENTRY_V500));

        if (!pRasEntryV500)
        {
            CMTRACE(TEXT("WriteCmPhonebookEntry failed to alloc mem"));
            goto exit;
        }

        ZeroMemory(pRasEntryV500, sizeof(RASENTRY_V500));

        pRasEntryV500->dwSize = sizeof(RASENTRY_V500);
        pRasEntryV500->dwType = RASET_Internet;

        pRasEntry = (RASENTRY *)pRasEntryV500;
    }
    else
    {
        pRasEntry = (RASENTRY *)CmMalloc(sizeof(RASENTRY));

        if (!pRasEntry)
        {
            CMTRACE(TEXT("WriteCmPhonebookEntry failed to alloc mem"));
            goto exit;
        }

        pRasEntry->dwSize = sizeof(RASENTRY);
    }

    //
    // Update the RAS entry with our DLL name for AutoDial and CustomDial
    // Note: NT5 gets CustomDial only, no AutoDial and AutoDialFunc.
    //

    if (plat.IsAtLeastNT5())
    {
        //
        // Use the machine independent %windir%\system32\cmdial32.dll on NT5
        //

        lstrcpy(((RASENTRY_V500 *)pRasEntry)->szCustomDialDll, c_pszCmDialPath);
    }
    else
    {
        TCHAR szSystemDirectory[MAX_PATH+1];

        //
        // Specify _InetDialHandler@16 as the entry point used for AutoDial.
        //

        lstrcpy(pRasEntry->szAutodialFunc, c_pszInetDialHandler);

        //
        //  Get the system directory path
        //

        if (0 == GetSystemDirectory(szSystemDirectory, CELEMS(szSystemDirectory)))
        {
            goto exit;
        }

        UINT uCount = (UINT)wsprintf(pRasEntry->szAutodialDll, TEXT("%s\\cmdial32.dll"), szSystemDirectory);

        MYDBGASSERT(uCount < CELEMS(pRasEntry->szAutodialDll));
    }

    if (plat.IsWin9x())
    {
        //
        // Win9x requires these to be set
        //
        pRasEntry->dwFramingProtocol = RASFP_Ppp;
        pRasEntry->dwCountryID = 1;
        pRasEntry->dwCountryCode = 1;
        //lstrcpy(pRasEntry->szAreaCode, TEXT("425"));
        lstrcpy(pRasEntry->szLocalPhoneNumber, TEXT("default"));
    }

    //
    // Is the profile configured to first use Direct Connect
    //

    fSupportDialup = GetPrivateProfileInt(c_pszCmSection, c_pszCmEntryDialup, 1, pszCmsFile);
    fSupportDirect = GetPrivateProfileInt  (c_pszCmSection, c_pszCmEntryDirect, 1, pszCmsFile);

    fDoDirectConnect = ((fSupportDialup && fSupportDirect && 
                        GetPrivateProfileInt(c_pszCmSection, c_pszCmEntryConnectionType, 0, pszCmsFile)) ||
                        (!fSupportDialup));

   
    fSeekVpn = fDoDirectConnect;    

    //
    // First try dial-up if appropriate
    //

    if (!fDoDirectConnect && !PickModem(pRasEntry->szDeviceType, pRasEntry->szDeviceName, FALSE))
    {
        CMTRACE(TEXT("*******Failed to pick a dial-up device!!!!"));

        //
        // If direct capable, try to find a VPN device
        //
        
        fSeekVpn = fSupportDirect;
    }

    //
    // If seeking a VPN device
    //

    if (fSeekVpn)
    {
        if (!PickModem(pRasEntry->szDeviceType, pRasEntry->szDeviceName, TRUE))
        {
            CMTRACE(TEXT("*******Failed to pick a VPN device!!!!"));   
        }
        else
        {
            //
            // Found VPN device, set default type as appropriate
            //

            if (!fDoDirectConnect)
            {
                CFileNameParts CmsParts(pszCmsFile);
                TCHAR szCmpFile[MAX_PATH+1];

                MYVERIFY(CELEMS(szCmpFile) > (UINT)wsprintf(szCmpFile, TEXT("%s%s"), CmsParts.m_Drive, 
                    CmsParts.m_Dir));

                szCmpFile[lstrlen(szCmpFile) - 1] = TEXT('\0');
                lstrcat(szCmpFile, c_pszCmpExt);
                
                WritePrivateProfileString(c_pszCmSection, c_pszCmEntryConnectionType, c_pszOne, szCmpFile);  
            }       
        }
    }

    //
    // No device??? Use last resort for dial-up on NT5
    //
    
    if (plat.IsAtLeastNT5() && !pRasEntry->szDeviceType[0])
    {
        lstrcpy(pRasEntry->szDeviceType, RASDT_Modem);
        lstrcpy(pRasEntry->szDeviceName, TEXT("Unavailable device ()"));

        CMTRACE2(TEXT("*******Writing szDeviceType - %s and szDeviceName %s"), 
                 pRasEntry->szDeviceType, pRasEntry->szDeviceName);       
    }

    //
    //  Zero is the success return value from RasSetEntryProperties
    //      
    dwReturn = ((pfnSetEntryProperties)(szFullPathtoPBK, szLongServiceName, 
                                        pRasEntry, pRasEntry->dwSize, NULL, 0));
            
    if (ERROR_SUCCESS == dwReturn)
    {
        bReturn = TRUE;
    }

    CMTRACE1(TEXT("WriteCmPhonebookEntry() - RasSetEntryProperties failed with error %d"), dwReturn);      


exit:
    CmFree(pRasEntry);

    return bReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  GetRasModems
//
// Synopsis:  get a list of modem devices from RAS
//
// Arguments: pprdiRasDevInfo   Ras device info list
//            pdwCnt    modem count
//
// Returns:   TRUE, if a list is obtained
//
//+----------------------------------------------------------------------------
BOOL GetRasModems(
    LPRASDEVINFO    *pprdiRasDevInfo, 
    LPDWORD         pdwCnt
) 
{
    DWORD dwLen;
    DWORD dwRes;
    DWORD dwCnt;
    pfnRasEnumDevicesSpec pfnEnumDevices;

    if (pprdiRasDevInfo) 
    {
        *pprdiRasDevInfo = NULL;
    }
    
    if (pdwCnt) 
    {
        *pdwCnt = 0;
    }
    
    if (!GetRasApis(NULL, NULL, NULL, &pfnEnumDevices, NULL, NULL))
    {
        return FALSE;   
    }

    dwLen = 0;
    dwRes = pfnEnumDevices(NULL, &dwLen, &dwCnt);
    
    CMTRACE3(TEXT("GetRasModems() RasEnumDevices(NULL,pdwLen,&dwCnt) returns %u, dwLen=%u, dwCnt=%u."), dwRes, dwLen, dwCnt);
    
    if ((dwRes != ERROR_SUCCESS) && (dwRes != ERROR_BUFFER_TOO_SMALL) || 
        (dwLen < sizeof(**pprdiRasDevInfo))) 
    {
        return FALSE;
    }
    
    *pprdiRasDevInfo = (LPRASDEVINFO) CmMalloc(__max(dwLen, sizeof(**pprdiRasDevInfo)));

    if (*pprdiRasDevInfo)
    {
        (*pprdiRasDevInfo)->dwSize = sizeof(**pprdiRasDevInfo);

        dwRes = pfnEnumDevices(*pprdiRasDevInfo, &dwLen, &dwCnt);
    
        CMTRACE3(TEXT("GetRasModems() RasEnumDevices(NULL,pdwLen,&dwCnt) returns %u, dwLen=%u, dwCnt=%u."), dwRes, dwLen, dwCnt);
    
        if (dwRes != ERROR_SUCCESS) 
        {
            CmFree(*pprdiRasDevInfo);
            *pprdiRasDevInfo = NULL;
            return FALSE;
        }
        if (pdwCnt)
        {
            *pdwCnt = dwCnt;
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("GetRasModems -- CmMalloc returned a NULL pointer for *pprdiRasDevInfo."));
        return FALSE;
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Function:  PickModem
//
// Synopsis:  Pick a default modem
//
// Arguments: OUT pszDeviceType, the device type if not NULL
//            OUT pszDeviceName, the device name if not NULL
//            OUT fUseVpnDevice  Use VPN device or not 
//
// Returns:   TRUE, is modem is found
//
//+----------------------------------------------------------------------------
BOOL PickModem(
    LPTSTR           pszDeviceType, 
    LPTSTR           pszDeviceName,
    BOOL             fUseVpnDevice
)
{
    LPRASDEVINFO    prdiModems;
    DWORD           dwCnt;
    DWORD           dwIdx;

    //
    // First, get a list of modems from RAS
    //
    
    if (!GetRasModems(&prdiModems, &dwCnt) || dwCnt == 0) 
    {
        return FALSE;
    }

    //
    // find the first device and use it by default.
    // Use VPN device if it's a VPN connection.
    //

    for (dwIdx=0; dwIdx<dwCnt; dwIdx++) 
    {
        DWORD       Lcid = 0;
        CPlatform   plat;

        if (plat.IsAtLeastNT51())
        {
            Lcid = LOCALE_INVARIANT;
        }
        else
        {
            Lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
        }

        if (fUseVpnDevice && (CSTR_EQUAL == CompareString(Lcid, NORM_IGNORECASE, prdiModems[dwIdx].szDeviceType, -1, RASDT_Vpn, -1)) ||
            !fUseVpnDevice && ((CSTR_EQUAL == CompareString(Lcid, NORM_IGNORECASE, prdiModems[dwIdx].szDeviceType, -1, RASDT_Isdn, -1)) ||
                               (CSTR_EQUAL == CompareString(Lcid, NORM_IGNORECASE, prdiModems[dwIdx].szDeviceType, -1, RASDT_Modem, -1))))
        {
            break;
        }
    }

    // 
    // If we have a match, fill device name and device type
    //

    if (dwIdx < dwCnt)
    {
        if (pszDeviceType) 
        {
            lstrcpy(pszDeviceType, prdiModems[dwIdx].szDeviceType);
        }
        
        if (pszDeviceName) 
        {
            lstrcpy(pszDeviceName, prdiModems[dwIdx].szDeviceName);
        }
    }

    CmFree(prdiModems);

    return (dwIdx < dwCnt);
}


//+----------------------------------------------------------------------------
//
// Function:  GetNT5FolderPath
//
// Synopsis:  Get the folder path on NT5
//            Since cmstp.exe is launched in netman by CreateProcessAsUser
//            SHGetSpecialFolderPath does not work.  We have to call 
//            SHGetFolderPath with an access token.
//
// Arguments: int nFolder - Value specifying the folder for which to retrieve 
//                          the location. 
//            OUT LPTSTR lpszPath - Address of a character buffer that receives 
//                          the drive and path of the specified folder. This 
//                          buffer must be at least MAX_PATH characters in size. 
 
//
// Returns:   HRESULT - 
//
// History:   fengsun Created Header    6/18/98
//            quintinb modified to use GetShell32Apis   11-22-98
//
//+----------------------------------------------------------------------------
HRESULT GetNT5FolderPath(int nFolder, OUT LPTSTR lpszPath)
{
    MYDBGASSERT(lpszPath);
    pfnSHGetFolderPathSpec pfnSHGetFolderPath;

    //
    // Call shell32.dll-->SHGetFolderPath, which takes a token.
    //
    if(!GetShell32Apis(&pfnSHGetFolderPath, NULL))
    {
        CMASSERTMSG(FALSE, TEXT("Failed to load shell32.dll or ShGetFolderPath"));
        return E_UNEXPECTED;    
    }

    //
    // Get the current process token
    //
    HANDLE hToken;              // The token of the process, to be passed to SHGetFolderPath
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) 
    {
        CMASSERTMSG(FALSE, TEXT("OpenThreadToken failed"));
        return E_UNEXPECTED;
    }

    HRESULT hr = pfnSHGetFolderPath(NULL, nFolder, hToken, 0, lpszPath);

    MYVERIFY(0 != CloseHandle(hToken));

    return hr;
}



//+----------------------------------------------------------------------------
//
// Function:  HrIsCMProfilePrivate
//
// Synopsis:  This function compares the inputed file path with the application
//            data path of the system.  If the file path contains the app data
//            path then it is considered to be a private profile.
//
// Arguments: LPTSTR szFilePath - directory or file path to compare against
//
// Returns:   HRESULT - S_OK if a private profile, S_FALSE if it is an all users
//                      profile.  Standard error codes otherwise.
//
// History:   quintinb original code
//
//+----------------------------------------------------------------------------
HRESULT HrIsCMProfilePrivate(LPCTSTR szFilePath)
{
    UINT uiLen;
    TCHAR szAppDataDir[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1] = {TEXT("")};
    CPlatform plat;

    if ((NULL == szFilePath) || (TEXT('\0') == szFilePath[0]))
    {
        return E_POINTER;
    }

    //
    //  Can't be a private user profile unless we are on NT5
    //

    if (!(plat.IsAtLeastNT5()))
    {
        return S_FALSE;
    }

    //
    //  Figure out what the user directory of the current user is.  We can compare this
    //  against the directory of the phonebook and see if we have a private user
    //  profile or an all user profile.

    if (FAILED(GetNT5FolderPath(CSIDL_APPDATA, szAppDataDir)))
    {
        return E_UNEXPECTED;
    }

    uiLen = lstrlen(szAppDataDir) + 1;
    lstrcpyn(szTemp, szFilePath, uiLen);

    if ((NULL != szTemp) && (0 == lstrcmpi(szAppDataDir, szTemp)))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  RefreshDesktop
//
// Synopsis:  This function refreshes the desktop and basically takes the place
//            of showicon.exe (in fact the code is a cut and paste from the 
//            main of showicon).
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    5/5/98
//
//+----------------------------------------------------------------------------
void RefreshDesktop()
{
    LPMALLOC     pMalloc        = NULL;
    LPITEMIDLIST pItemIDList    = NULL;

    //
    //  Get the IMalloc for the Shell.
    //
    HRESULT hr = SHGetMalloc(&pMalloc);
    if (SUCCEEDED(hr))
    {
        //  Get the desktop ID list..
        hr = SHGetSpecialFolderLocation(NULL,
                                        CSIDL_DESKTOP,
                                        &pItemIDList);
        if (SUCCEEDED(hr))
        {
            //  Notify of change.
            SHChangeNotify(SHCNE_UPDATEDIR,
                           SHCNF_IDLIST,
                           (LPCVOID)pItemIDList,
                           NULL);

            pMalloc->Free(pItemIDList);
        }
        MYVERIFY(SUCCEEDED(pMalloc->Release()));
    }
}

//+----------------------------------------------------------------------------
//
// Function:  GetPrivateCmUserDir
//
// Synopsis:  This function fills in the string passed in with the path to the
//            path where CM should be installed.  For instance, it should return
//            c:\users\quintinb\Application Data\Microsoft\Network\Connection Manager
//            for me.  Please note that this function is NT5 only.
//
// Arguments: LPTSTR  pszDir - String to the Users Connection Manager Directory
//
// Returns:   LPTSTR - String to the Users Connection Manager Directory
//
// History:   quintinb Created Header    2/19/98
//
//+----------------------------------------------------------------------------
LPTSTR GetPrivateCmUserDir(LPTSTR  pszDir, HINSTANCE hInstance)
{
    LPITEMIDLIST pidl;
    LPMALLOC     pMalloc;
    CPlatform   plat;
    TCHAR szTemp[MAX_PATH+1];

    MYDBGASSERT(pszDir);
    pszDir[0] = TEXT('\0');

    if (!plat.IsAtLeastNT5())
    {
        CMASSERTMSG(FALSE, TEXT("GetPrivateCmUserDir -- This NT5 only function was called from a different platform."));
        goto exit;
    }

    if (FAILED(GetNT5FolderPath(CSIDL_APPDATA, pszDir)))
    {
        goto exit;
    }

    MYVERIFY(0 != LoadString(hInstance, IDS_CMSUBFOLDER, szTemp, MAX_PATH));
    MYVERIFY(NULL != lstrcat(pszDir, szTemp));

exit:
    return pszDir;
}

//+----------------------------------------------------------------------------
//
// Function:  LaunchProfile
//
// Synopsis:  This function handles launching the CM profile (NTRAID 201307) after
//            installation.  On NT5 it opens the connfolder and launches the 
//            correct connection by doing a shell execute on the pidl we get from
//            enumerating the connections folder.  On down level we use Cmmgr32.exe
//            and the full path to the cmp file.  Please note that on downlevel we
//            only care about the input param pszFullPathToCmpFile, while on NT5
//            we only care about pszwServiceName and bInstallForAllUsers.
//
// Arguments: LPCTSTR pszFullPathToCmpFile - the full path to the cmp file (used on legacy only)
//            LPCSTR pszServiceName - the Long Service Name
//            BOOL bInstallForAllUsers - 
//
// Returns:   HRESULT -- standard COM error codes
//
// History:   quintinb Created    11/16/98
//
//+----------------------------------------------------------------------------
HRESULT LaunchProfile(LPCTSTR pszFullPathToCmpFile, LPCTSTR pszServiceName, 
                   LPCTSTR pszPhoneBook, BOOL bInstallForAllUsers)
{
    CPlatform plat;
    HRESULT hr = E_FAIL;

    if ((NULL == pszFullPathToCmpFile) || (NULL == pszServiceName) ||
        (NULL != pszPhoneBook && TEXT('\0') == pszPhoneBook[0]))
    {
        CMASSERTMSG(FALSE, TEXT("Invalid argument passed to LaunchProfile"));
        return E_INVALIDARG;
    }

    if (plat.IsAtLeastNT5())
    {
        CMASSERTMSG((TEXT('\0') != pszServiceName), TEXT("Empty ServiceName passed to LaunchProfile on win2k."));
        
        pfnRasGetEntryPropertiesSpec pfnGetEntryProperties = NULL;

        if (!GetRasApis(NULL, NULL, NULL, NULL, &pfnGetEntryProperties, NULL))
        {
            return E_UNEXPECTED;   
        }

        DWORD dwRes;
        DWORD dwSize;
        LPRASENTRY_V500 pRasEntry = NULL;

        pRasEntry = (LPRASENTRY_V500)CmMalloc(sizeof(RASENTRY_V500));

        if (NULL != pRasEntry)
        {
            ZeroMemory(pRasEntry, sizeof(RASENTRY_V500));        
            pRasEntry->dwSize = sizeof(RASENTRY_V500);
            dwSize = sizeof(RASENTRY_V500);

            dwRes = (pfnGetEntryProperties)(pszPhoneBook, pszServiceName, (LPRASENTRY)pRasEntry, &dwSize, NULL, NULL);
        
            if (0 == dwRes)
            {
                //
                //  Then we were able to get the RasEntry, load the NetShell API 
                //  and call HrCreateShortcut
                //
                if (plat.IsAtLeastNT51())
                {
                    pfnLaunchConnectionExSpec pfnLaunchConnectionEx = NULL;

                    if (GetNetShellApis(NULL, NULL, &pfnLaunchConnectionEx))
                    {
                        //
                        //  Launch Connections Folder and Connection together
                        //
                        DWORD dwFlags = 0x1;    // 0x1 => Opens the folder before launching the connection

                        hr = (pfnLaunchConnectionEx)(dwFlags, pRasEntry->guidId);
                        MYVERIFY(SUCCEEDED(hr));
                    }
                }
                else
                {
                    pfnLaunchConnectionSpec pfnLaunchConnection = NULL;

                    if (GetNetShellApis(&pfnLaunchConnection, NULL, NULL))
                    {
                        //
                        //  Now Launch the Connections Folder
                        //

                        CLoadConnFolder Connections;
                        Connections.HrLaunchConnFolder();

                        //
                        //  Finally Launch the Connection
                        //
                        hr = (pfnLaunchConnection)(pRasEntry->guidId);
                        MYVERIFY(SUCCEEDED(hr));
                    }
                }
            }
            else
            {
                CMTRACE1(TEXT("LaunchProfile -- RasGetEntryProperties returned %u"), dwRes);
                CMASSERTMSG(FALSE, TEXT("Unable to find the connection that we are supposed to launch in the RAS pbk."));
                return HRESULT_FROM_WIN32(ERROR_CONNECTION_INVALID);
            }
            CmFree(pRasEntry);
        }
    }
    else
    {
        SHELLEXECUTEINFO  sei;

        if ((NULL != pszFullPathToCmpFile) && (TEXT('\0') != pszFullPathToCmpFile))
        {
            TCHAR szCmmgrPath[MAX_PATH+1]={0};
            TCHAR szSystemDir[MAX_PATH+1]={0};
            TCHAR szCmp[MAX_PATH+1]={0};

            lstrcpy(szCmp, TEXT("\""));
            lstrcat(szCmp, pszFullPathToCmpFile);
            lstrcat(szCmp, TEXT("\""));

            UINT uRet = GetSystemDirectory(szSystemDir, MAX_PATH);
            if ((0 == uRet) || (MAX_PATH < uRet))
            {
                //
                //  Give up, not the end of the world not to launch the profile
                //
                return E_UNEXPECTED;         
            }
            else
            {
                wsprintf(szCmmgrPath, TEXT("%s\\cmmgr32.exe"), szSystemDir);
            }

            ZeroMemory(&sei, sizeof(sei));
            sei.cbSize = sizeof(sei);
            sei.fMask = SEE_MASK_FLAG_NO_UI;
            sei.nShow = SW_SHOWNORMAL;
            sei.lpFile = szCmmgrPath;
            sei.lpParameters = szCmp;
            sei.lpDirectory = szSystemDir;

            if (!ShellExecuteEx(&sei))
            {
                CMASSERTMSG(FALSE, TEXT("Unable to launch installed connection!"));
            }
            else
            {
                hr = S_OK;
            }
        }
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  AllUserProfilesInstalled
//
// Synopsis:  Checks if any profiles are listed in the HKLM Mappings key.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if mappings values exist in the HKLM mappings key
//
// History:   quintinb Created Header    11/1/98
//
//+----------------------------------------------------------------------------
BOOL AllUserProfilesInstalled()
{
    BOOL bReturn = FALSE;
    HKEY hKey;
    DWORD dwNumValues;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, 
        KEY_READ, &hKey))
    {
        if ((ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, 
            &dwNumValues, NULL, NULL, NULL, NULL)) && (dwNumValues > 0))
        {
            //
            //  Then we have mappings values
            //
            bReturn = TRUE;

        }
        RegCloseKey(hKey);
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetProcAddressFromRasApi32orRnaph
//
// Synopsis:  A helper function to first look in RasApi32.dll (using the global
//            dll class pointer) and then check in Rnaph.dll if the required
//            function was not found.
//
// Arguments: LPTSTR pszFunc - String of the function to look for
//            CPlatform* pPlat - a CPlatform class pointer to prevent creating
//                               and destructing a new one everytime this is called.
//
// Returns:   LPVOID - NULL if the function wasn't found, a pFunc otherwise.
//
// History:   quintinb Created  11/23/98
//
//+----------------------------------------------------------------------------
LPVOID GetProcAddressFromRasApi32orRnaph(LPCSTR pszFunc, CPlatform* pPlat)
{
    LPVOID pFunc;
    MYDBGASSERT(g_pRasApi32);

    pFunc = g_pRasApi32->GetProcAddress(pszFunc);
    if (NULL == pFunc)
    {
        //
        //  On win95 gold check rnaph
        //
        if (pPlat->IsWin95Gold())
        {
            if (NULL == g_pRnaph)
            {
                g_pRnaph = (CDynamicLibrary*)CmMalloc(sizeof(CDynamicLibrary));
                if (NULL == g_pRnaph)
                {
                    return FALSE;
                }
            }

            if (!(g_pRnaph->IsLoaded()))
            {
                g_pRnaph->Load(TEXT("rnaph.dll"));
            }

            pFunc = g_pRnaph->GetProcAddress(pszFunc);                   
        }
    }
    return pFunc;
}

//+----------------------------------------------------------------------------
//
// Function:  GetNetShellApis
//
// Synopsis:  This is a wrapper function to access the private Netshell api's that allow
//            cmstp.exe to interact with the Connections folder on Windows 2000.
//            This function caches the Netshell function pointers as they are
//            accessed for later use.  NULL can be passed if a function isn't required.
//
// Arguments: pfnLaunchConnectionSpec* pLaunchConnection - var to hold function pointer
//            pfnCreateShortcutSpec* pCreateShortcut - var to hold function pointer
//            pfnLaunchConnectionEx pLaunchConnectionEx - var to hold function pointer
//
// Returns:   BOOL - TRUE if all required APIs were retrieved
//
// History:   quintinb Created    2/17/99
//
//+----------------------------------------------------------------------------
BOOL GetNetShellApis(pfnLaunchConnectionSpec* pLaunchConnection, pfnCreateShortcutSpec* pCreateShortcut,
                     pfnLaunchConnectionExSpec* pLaunchConnectionEx)
{
    CPlatform plat;
    static pfnLaunchConnectionSpec pfnLaunchConnection = NULL;
    static pfnCreateShortcutSpec pfnCreateShortcut = NULL;
    static pfnLaunchConnectionExSpec pfnLaunchConnectionEx = NULL;

    if (!(plat.IsAtLeastNT5()))
    {
        //
        //  These functions are only used on NT5.  Return FALSE otherwise.
        //
        CMASSERTMSG(FALSE, TEXT("Trying to use NetShell Private Api's on platforms other than Windows 2000."));
        return FALSE;
    }

    if (NULL == g_pNetShell)
    {
        g_pNetShell = (CDynamicLibrary*)CmMalloc(sizeof(CDynamicLibrary));
        if (NULL == g_pNetShell)
        {
            return FALSE;
        }
    }

    if (!(g_pNetShell->IsLoaded()))
    {
        g_pNetShell->Load(TEXT("netshell.dll"));
    }
    
    if (NULL != pLaunchConnection)
    {
        if (pfnLaunchConnection)
        {
            *pLaunchConnection = pfnLaunchConnection;
        }
        else
        {
            *pLaunchConnection = (pfnLaunchConnectionSpec)g_pNetShell->GetProcAddress("HrLaunchConnection");
            if (NULL == *pLaunchConnection)
            {
                return FALSE;
            }
            else
            {
                pfnLaunchConnection = *pLaunchConnection;
            }
        }
    }

    if (NULL != pCreateShortcut)
    {
        if (pfnCreateShortcut)
        {
            *pCreateShortcut = pfnCreateShortcut;
        }
        else
        {
            *pCreateShortcut = (pfnCreateShortcutSpec)g_pNetShell->GetProcAddress("HrCreateDesktopIcon");
            if (NULL == *pCreateShortcut)
            {
                return FALSE;
            }
            else
            {
                pfnCreateShortcut = *pCreateShortcut;
            }
        }
    }

    if (NULL != pLaunchConnectionEx)
    {
        if (pfnLaunchConnectionEx)
        {
            *pLaunchConnectionEx = pfnLaunchConnectionEx;
        }
        else
        {
            if (!(plat.IsAtLeastNT51()))
            {
                return FALSE;
            }
            else
            {
                *pLaunchConnectionEx = (pfnLaunchConnectionExSpec)g_pNetShell->GetProcAddress("HrLaunchConnectionEx");
                if (NULL == *pLaunchConnectionEx)
                {
                    return FALSE;
                }
                else
                {
                    pfnLaunchConnectionEx = *pLaunchConnectionEx;
                }
            }
        }
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Function:  GetRasApis
//
// Synopsis:  This is a wrapper function to access the RasApis that cmstp.exe uses.
//            This function caches the RAS api function pointers as they are
//            accessed for later use.  NULL can be passed if a function isn't required.
//
// Arguments: pfnRasDeleteEntrySpec* pRasDeleteEntry - var to hold func pointer
//            pfnRasEnumEntriesSpec* pRasEnumEntries - var to hold func pointer
//            pfnRasSetEntryPropertiesSpec* pRasSetEntryProperties - var to hold func pointer
//            pfnRasEnumDevicesSpec* pRasEnumDevices - var to hold func pointer
//            pfnRasSetCredentialsSpec* pRasSetCredentials - var to hold func pointer
//
// Returns:   BOOL - TRUE if all required APIs were retrieved
//
// History:   quintinb Created    11/23/98
//
//+----------------------------------------------------------------------------
BOOL GetRasApis(pfnRasDeleteEntrySpec* pRasDeleteEntry, pfnRasEnumEntriesSpec* pRasEnumEntries, 
                pfnRasSetEntryPropertiesSpec* pRasSetEntryProperties, 
                pfnRasEnumDevicesSpec* pRasEnumDevices, pfnRasGetEntryPropertiesSpec* pRasGetEntryProperties,
                pfnRasSetCredentialsSpec* pRasSetCredentials)
{
    CPlatform plat;
    static pfnRasDeleteEntrySpec pfnRasDeleteEntry = NULL;
    static pfnRasEnumEntriesSpec pfnRasEnumEntries = NULL;
    static pfnRasSetEntryPropertiesSpec pfnRasSetEntryProperties = NULL;
    static pfnRasEnumDevicesSpec pfnRasEnumDevices = NULL;
    static pfnRasGetEntryPropertiesSpec pfnRasGetEntryProperties = NULL;
    static pfnRasSetCredentialsSpec pfnRasSetCredentials = NULL;

    if (NULL == g_pRasApi32)
    {
        g_pRasApi32 = (CDynamicLibrary*)CmMalloc(sizeof(CDynamicLibrary));
        if (NULL == g_pRasApi32)
        {
            return FALSE;
        }
    }

    if (!(g_pRasApi32->IsLoaded()))
    {
        g_pRasApi32->Load(TEXT("rasapi32.dll"));
    }
    
    if (NULL != pRasDeleteEntry)
    {
        if (pfnRasDeleteEntry)
        {
            *pRasDeleteEntry = pfnRasDeleteEntry;
        }
        else
        {
            *pRasDeleteEntry = (pfnRasDeleteEntrySpec)GetProcAddressFromRasApi32orRnaph("RasDeleteEntryA",
                                                                                        &plat);
            if (NULL == *pRasDeleteEntry)
            {
                return FALSE;
            }
            else
            {
                pfnRasDeleteEntry = *pRasDeleteEntry;
            }
        }
    }

    if (NULL != pRasEnumEntries)
    {
        if (pfnRasEnumEntries)
        {
            *pRasEnumEntries = pfnRasEnumEntries;
        }
        else
        {
            *pRasEnumEntries = (pfnRasEnumEntriesSpec)g_pRasApi32->GetProcAddress("RasEnumEntriesA");

            if (NULL == *pRasEnumEntries)
            {
                //
                //  A required Function couldn't be loaded
                //
                return FALSE;
            }
            else
            {
                pfnRasEnumEntries = *pRasEnumEntries;
            }
        }
    }

    if (NULL != pRasSetEntryProperties)
    {
        if (pfnRasSetEntryProperties)
        {
            *pRasSetEntryProperties = pfnRasSetEntryProperties;
        }
        else
        {
            *pRasSetEntryProperties = (pfnRasSetEntryPropertiesSpec)GetProcAddressFromRasApi32orRnaph("RasSetEntryPropertiesA",
                                                                                        &plat);
            if (NULL == *pRasSetEntryProperties)
            {
                return FALSE;
            }
            else
            {
                pfnRasSetEntryProperties = *pRasSetEntryProperties;
            }
        }
    }

    if (NULL != pRasEnumDevices)
    {
        if (pfnRasEnumDevices)
        {
            *pRasEnumDevices = pfnRasEnumDevices;
        }
        else
        {
            *pRasEnumDevices = (pfnRasEnumDevicesSpec)GetProcAddressFromRasApi32orRnaph("RasEnumDevicesA",
                                                                                        &plat);
            if (NULL == *pRasEnumDevices)
            {
                return FALSE;
            }
            else
            {
                pfnRasEnumDevices = *pRasEnumDevices;
            }
        }
    }

    if (NULL != pRasGetEntryProperties)
    {
        if (pfnRasGetEntryProperties)
        {
            *pRasGetEntryProperties = pfnRasGetEntryProperties;
        }
        else
        {
            *pRasGetEntryProperties = (pfnRasGetEntryPropertiesSpec)GetProcAddressFromRasApi32orRnaph("RasGetEntryPropertiesA", &plat);
            if (NULL == *pRasGetEntryProperties)
            {
                return FALSE;
            }
            else
            {
                pfnRasGetEntryProperties = *pRasGetEntryProperties;
            }
        }
    }

    if (NULL != pRasSetCredentials)
    {
        if (pfnRasSetCredentials)
        {
            *pRasSetCredentials = pfnRasSetCredentials;
        }
        else
        {
            *pRasSetCredentials = (pfnRasSetCredentialsSpec)GetProcAddressFromRasApi32orRnaph("RasSetCredentialsA", &plat);
            if (NULL == *pRasSetCredentials)
            {
                return FALSE;
            }
            else
            {
                pfnRasSetCredentials = *pRasSetCredentials;
            }
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  GetShell32Apis
//
// Synopsis:  This function is used to load the shell32.dll and call getprocaddress
//            on the needed functions.  This function is used to speed up the process
//            by keeping one copy of shell32.dll in memory and caching the function
//            pointers requested.  If a function pointer hasn't been requested yet,
//            then it will have to be looked up.
//
// Arguments: pfnSHGetFolderPathSpec* pGetFolderPath - pointer for SHGetFolderPath
//            pfnSHGetSpecialFolderPathWSpec* pGetSpecialFolderPathW - pointer for GetSpecialFolderPathW
//
// Returns:   BOOL - TRUE if all requested function pointers were retreived.
//
// History:   quintinb Created     11/23/98
//
//+----------------------------------------------------------------------------
BOOL GetShell32Apis(pfnSHGetFolderPathSpec* pGetFolderPath,
                    pfnSHGetSpecialFolderPathWSpec* pGetSpecialFolderPathW)
{
    static pfnSHGetFolderPathSpec pfnSHGetFolderPath = NULL; // this takes a User token
    static pfnSHGetSpecialFolderPathWSpec pfnSHGetSpecialFolderPathW = NULL;

#ifdef UNICODE
    const CHAR c_pszSHGetFolderPath[] = "SHGetFolderPathW";
#else
    const CHAR c_pszSHGetFolderPath[] = "SHGetFolderPathA";
#endif
    const CHAR c_pszSHGetSpecialFolderPathW[] = "SHGetSpecialFolderPathW";


    if (NULL == g_pShell32)
    {
        g_pShell32 = (CDynamicLibrary*)CmMalloc(sizeof(CDynamicLibrary));
        if (NULL == g_pShell32)
        {
            return FALSE;
        }
    }

    if (!(g_pShell32->IsLoaded()))
    {
        if(!g_pShell32->Load(TEXT("shell32.dll")))
        {
            return FALSE;
        }
    }

    if (NULL != pGetFolderPath)
    {
        if (pfnSHGetFolderPath)
        {
            *pGetFolderPath = pfnSHGetFolderPath;
        }
        else
        {
            *pGetFolderPath = (pfnSHGetFolderPathSpec)g_pShell32->GetProcAddress(c_pszSHGetFolderPath);
            if (NULL == *pGetFolderPath)
            {
                return FALSE;
            }
            else
            {
                pfnSHGetFolderPath = *pGetFolderPath;
            }
        }
    }

    if (NULL != pGetSpecialFolderPathW)
    {
        if (pfnSHGetSpecialFolderPathW)
        {
            *pGetSpecialFolderPathW = pfnSHGetSpecialFolderPathW;
        }
        else
        {
            *pGetSpecialFolderPathW = (pfnSHGetSpecialFolderPathWSpec)g_pShell32->GetProcAddress(c_pszSHGetSpecialFolderPathW);
            if (NULL == *pGetSpecialFolderPathW)
            {
                return FALSE;
            }
            else
            {
                pfnSHGetSpecialFolderPathW = *pGetSpecialFolderPathW;
            }
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmsetup\setupmem.cpp ===
//+----------------------------------------------------------------------------
//
// File:     regutil.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Memory utility functions taken from cmutil.  Bare minimum of functionality
//           used in Cmutil, but gives a simple Heapalloc wrapper.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb       Created     10/06/98
//
//+----------------------------------------------------------------------------
#ifndef __SETUPMEM_CPP
#define __SETUPMEM_CPP
#include "cmsetup.h"

//+----------------------------------------------------------------------------
// definitions
//+----------------------------------------------------------------------------

#ifdef DEBUG
LONG    g_lMallocCnt = 0;  // a counter to detect memory leak
#endif

void *CmRealloc(void *pvPtr, size_t nBytes) 
{
	void* p = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pvPtr, nBytes);

    CMASSERTMSG(p, TEXT("CmRealloc failed"));

    return p;
}


void *CmMalloc(size_t nBytes) 
{
#ifdef DEBUG
	InterlockedIncrement(&g_lMallocCnt);
#endif

    MYDBGASSERT(nBytes < 1024*1024); // It should be less than 1 MB
    
    void* p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nBytes);
    
    CMASSERTMSG(p, TEXT("CmMalloc failed"));

    return p;
}


void CmFree(void *pvPtr) 
{
	if (pvPtr) 
    {	
	    MYVERIFY(HeapFree(GetProcessHeap(), 0, pvPtr));

#ifdef DEBUG
	    InterlockedDecrement(&g_lMallocCnt);
#endif
    
    }
}


void EndDebugMemory()
{
#ifdef DEBUG
    if (g_lMallocCnt)
    {
        TCHAR buf[256];
        wsprintf(buf, TEXT("Detect Memory Leak of %d blocks"), g_lMallocCnt);
        CMASSERTMSG(FALSE, buf);
    }
#endif
}

#endif //__SETUPMEM_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmstp\loadconnfolder.cpp ===
//+----------------------------------------------------------------------------
//
// File:     loadconnfolder.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This source file contains the code that implements the 
//           CLoadConnFolder Class.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created     07/14/98
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

CLoadConnFolder::CLoadConnFolder()
{
    ULONG ulCount;

    // "CLSID_MyComputer\CLSID_ControlPanel\CLSID_ConnectionsFolder"
    // Note -- ParseDisplayName() is miss declared, it should take a const ptr
    //
    #define NETCON_FOLDER_PATH  L"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\" \
                                L"::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\" \
                                L"::{7007acc7-3202-11d1-aad2-00805fc1270e}";

    WCHAR c_szMyFolderName[] =  NETCON_FOLDER_PATH;

    //
    //  Set initial states of class vars
    //

    m_pConnectionsFolder = NULL;
    m_ConnFolderpidl = NULL;
    m_pDesktopFolder = NULL;
    m_HrClassState = E_UNEXPECTED;


    //
    //  Start retrieving the conn folder
    //

    m_HrClassState = CoInitialize(NULL);

    //
    //  Save whether CoInit succeeded or not
    //
    m_CoInit = SUCCEEDED(m_HrClassState);
    
    if (SUCCEEDED(m_HrClassState))
    {
        //
        // Get the desktop folder, so we can parse the display name and get
        // the UI object of the connections folder
        //

        m_HrClassState = SHGetDesktopFolder(&m_pDesktopFolder);
        if (SUCCEEDED(m_HrClassState))
        {
            m_HrClassState = m_pDesktopFolder->ParseDisplayName(NULL, 0, (WCHAR *) c_szMyFolderName,
                                &ulCount, &m_ConnFolderpidl, NULL);
            if (SUCCEEDED(m_HrClassState))
            {
                //
                //  Now we have the pidl for the Connections Folder
                //
                m_HrClassState = m_pDesktopFolder->BindToObject(m_ConnFolderpidl, NULL, IID_IShellFolder, 
                    (LPVOID*)(&m_pConnectionsFolder));
            }
        }
    }
}


CLoadConnFolder::~CLoadConnFolder()
{
    if (m_pConnectionsFolder)
    {
        m_pConnectionsFolder->Release();
        m_pConnectionsFolder = NULL;
    }

    if (m_pDesktopFolder)
    {
        m_pDesktopFolder->Release();
        m_pDesktopFolder = NULL;
    }

    if (m_ConnFolderpidl)
    {
        LPMALLOC pMalloc;
        HRESULT hr = SHGetMalloc(&pMalloc);
        if (SUCCEEDED(hr))
        {
            pMalloc->Free(m_ConnFolderpidl);
            pMalloc->Release();
            m_ConnFolderpidl = NULL;
        }
    }

    if (m_CoInit)
    {
        CoUninitialize();
    }

    m_HrClassState = S_FALSE;

}

HRESULT CLoadConnFolder::HrLaunchConnFolder()
{
    SHELLEXECUTEINFO  sei;
    HRESULT hr = S_OK;

    if (NULL != m_ConnFolderpidl)
    {
        ZeroMemory(&sei, sizeof(sei));
        sei.cbSize = sizeof(sei);
        sei.fMask = SEE_MASK_IDLIST | SEE_MASK_CLASSNAME;
        sei.lpIDList = m_ConnFolderpidl;
        sei.lpClass = TEXT("folder");
        sei.hwnd = NULL; //lpcmi->hwnd;
        sei.nShow = SW_SHOWNORMAL;
        sei.lpVerb = TEXT("open");

        if (!ShellExecuteEx(&sei))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmstp\installerfuncs.h ===
//+----------------------------------------------------------------------------
//
// File:     installerfuncs.h
//
// Module:   CMSTP.EXE
//
// Synopsis: This header contains definitions for the mode entry point
//           functions (installing, uninstalling, uninstalling CM,
//           profile migration, OS upgrade migration, etc.) which need
//           to be shared because they may be called from other files within
//           cmstp.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header    07/14/98
//
//+----------------------------------------------------------------------------
HRESULT InstallInf(HINSTANCE hInstance, LPCTSTR szInfFile, BOOL bNoSupportFiles, 
				BOOL bNoLegacyIcon, BOOL bNoNT5Shortcut, BOOL bSilent, 
				BOOL bSingleUser, BOOL bSetAsDefault, CNamedMutex* pCmstpMutex);
HRESULT MigrateOldCmProfilesForProfileInstall(HINSTANCE hInstance, LPCTSTR szCurrentDir);
HRESULT MigrateCmProfilesForWin2kUpgrade(HINSTANCE hInstance);
HRESULT UninstallProfile(HINSTANCE hInstance, LPCTSTR szInfFile, BOOL bCleanUpCreds);
HRESULT UninstallCm(HINSTANCE hInstance, LPCTSTR szInfPath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmstp\cmstp.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmstp.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This file is the main function for the CM profile installer.  This
//           file basically processes command line switches for the installer and
//           then launches the appropriate function.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created     07/13/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "installerfuncs.h"
#include "cmstpex.h"
//
//  Text Constants
//
static const TCHAR CMSTPMUTEXNAME[] = TEXT("Connection Manager Profile Installer Mutex");


//
//  Global Dynamic Library Classes to hold the ras dll's and shell32.  See
//  the EnsureRasDllsLoaded and the EnsureShell32Loaded in common.cpp/common.h
//
CDynamicLibrary* g_pRasApi32 = NULL;
CDynamicLibrary* g_pRnaph = NULL;
CDynamicLibrary* g_pShell32 = NULL;
CDynamicLibrary* g_pNetShell = NULL;


//
//  Function Headers
//
BOOL PromptUserToUninstallProfile(HINSTANCE hInstance, LPCTSTR pszInfFile); // from uninstall.cpp
BOOL PromptUserToUninstallCm(HINSTANCE hInstance); // from uninstallcm.cpp


//
//  Enum for the LastManOut function which follows.
//
typedef enum _UNINSTALLTYPE
{
    PROFILEUNINSTALL,   // a profile is being uninstalled
    CMUNINSTALL        // the cm bits themselves are being uninstalled.

} UNINSTALLTYPE;


//+----------------------------------------------------------------------------
//
// Function:  LastManOut
//
// Synopsis:  This function determines if the current uninstall action is the
//            last uninstall action which should then delete cmstp.exe.  If the
//            uninstall action is a profile uninstall we need to check that 
//            cm has already been uninstalled and that there is only one profile
//            installed currently (the one we are about to delete).  If the
//            uninstall action is uninstalling CM then we need to make sure there
//            are no other profiles on the machine.  Notice that this function
//            never returns TRUE on Native CM platforms.  If it did, then cmstp.exe
//            would be deleted inadvertently even though UninstallCm wouldn't
//            actually delete the rest of CM.
//
// Arguments: UNINSTALLTYPE UninstallType - an enum value which tells if this is
//                                          a profile uninstall or a CM uninstall.
//
// Returns:   BOOL - TRUE if this install is the last one out and cmstp.exe should
//                   be deleted.
//
// History:   quintinb Created     6/28/99
//
//+----------------------------------------------------------------------------
BOOL LastManOut(UNINSTALLTYPE UninstallType, LPCTSTR pszInfFile)
{
    BOOL bReturn = FALSE;

    //
    //  First check to make sure that remcmstp.inf doesn't exist in the system
    //  directory.  If it does, then we know that Cmstp.exe has already determined
    //  that it is the last man and should delete itself.  Thus it wrote the cmstp.exe
    //  command into remcmstp.inf and the inf engine will delete cmstp.exe when it is done.
    //  Thus we need to check for this file and if it exists return FALSE.
    //

    TCHAR szSystemDir[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];

    if (0 == GetSystemDirectory(szSystemDir, CELEMS(szSystemDir)))
    {
        CMASSERTMSG(FALSE, TEXT("LastManOut -- Unable to obtain a path to the System Directory"));
        return FALSE;
    }
    
    wsprintf(szTemp, TEXT("%s\\remcmstp.inf"), szSystemDir);
    
    if (FileExists(szTemp))
    {
        CMTRACE1(TEXT("\tDetected remcmstp.inf, not setting last man out -- Process ID is 0x%x "), GetCurrentProcessId());
        Sleep(2000); // we sleep here to put a little delay in the processing to let any other copies
                     // of cmstp.exe clean themselves up.  I found that on a system with several copies of
                     // cmstp.exe all deleting profiles and then a cmstp to delete CM, not all of the cmstps
                     // would clean up in time and thus cmstp.exe wouldn't get deleted.  A sleep is hokey, but
                     // two seconds in the last man out situation only fixes it and it no down level user should
                     // ever have 8 profiles (which was home many I tested it with) let alone delete them 
                     // all at once.  It works fine for deleting two profiles and CM simultaneously either way.
        return FALSE;
    }

    //
    //  Make sure that we aren't trying to Remove cmstp.exe on a platform where CM is Native.
    //  If CM is Native, then always return FALSE because the CM uninstall function won't
    //  uninstall CM and we don't want to accidently delete cmstp.exe.
    //

    if (!CmIsNative())
    {
        if (PROFILEUNINSTALL == UninstallType)
        {
            //
            //  We are uninstalling a profile.  We need to check to see if CM has been deleted and
            //  if there are any other profiles on the machine besides the one we are going to delete.
            //
            wsprintf(szTemp, TEXT("%s\\cmdial32.dll"), szSystemDir);

            if (!FileExists(szTemp))
            {
                //
                //  Then we know that CM is already gone.  We need to check and see if any other
                //  profiles exist besides the one we are about to delete.
                //
                HKEY hKey;
                DWORD dwNumValues;
                TCHAR szServiceName[MAX_PATH+1];

                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, 
                    KEY_READ, &hKey))
                {
                    if ((ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, 
                        &dwNumValues, NULL, NULL, NULL, NULL)) && (dwNumValues == 1))
                    {
                        //
                        //  Then we have only the one profile mappings key, is it the correct one?
                        //
                        if (0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszCmEntryServiceName, 
                                                         TEXT(""), szServiceName, MAX_PATH, pszInfFile))
                        {
                            DWORD dwSize = MAX_PATH;
                            LONG lResult = RegQueryValueEx(hKey, szServiceName, NULL, 
                                                           NULL, (LPBYTE)szTemp, &dwSize);

                            if ((ERROR_SUCCESS == lResult) && (TEXT('\0') != szTemp[0]))
                            {
                                CMTRACE1(TEXT("\tDetected Last Man Out -- Process ID is 0x%x "), GetCurrentProcessId());
                                bReturn = TRUE;
                            }                            
                        }
                    }
                    RegCloseKey(hKey);
                }
            }
        }
        else if (CMUNINSTALL == UninstallType)
        {
            //
            //  We are uninstalling CM.  We want to make sure that we don't have any profiles
            //  still installed.  If not, then we are the last man out.
            //
            if (!AllUserProfilesInstalled())
            {
                CMTRACE1(TEXT("\tDetected Last Man Out -- Process ID is 0x%x "), GetCurrentProcessId());
                bReturn = TRUE;
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("LastManOut -- Unknown Uninstall Type"));
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  ExtractInfAndRelaunchCmstp
//
// Synopsis:  This function is used to cleanup Cmstp.exe in the last man out
//            scenario.  In order to not leave cmstp.exe on a users machine,
//            we must extract remcmstp.inf and write the uninstall command to it.
//            That way, the inf will monitor the cmstp.exe process and when it is
//            finished it can then delete cmstp.exe.
//
// Arguments: HINSTANCE hInstance - Instance handle to load resources
//            DWORD dwFlags - Command line param flags
//            LPCTSTR szInfPath - path to the inf file.
//
// Returns:   BOOL -- TRUE if Successful
//
// History:   quintinb Created    6/28/99
//
//+----------------------------------------------------------------------------
BOOL ExtractInfAndRelaunchCmstp(HINSTANCE hInstance, DWORD dwFlags, LPCTSTR pszInfPath)
{

    //
    //  Check Parameters
    //

    if (0 == dwFlags || NULL == pszInfPath || TEXT('\0') == pszInfPath[0])
    {
        CMASSERTMSG(FALSE, TEXT("Invalid Paramater passed to ExtractInfAndRelaunchCmstp."));
        return FALSE;
    }

    //
    //  Get the Path to the System Directory
    //
    TCHAR szSystemDir[MAX_PATH+1];
    if (0 == GetSystemDirectory(szSystemDir, CELEMS(szSystemDir)))
    {
        CMASSERTMSG(FALSE, TEXT("ExtractInfAndRelaunchCmstp -- Unable to obtain a path to the System Directory"));
        return FALSE;
    }

    //
    //  Extract remcmstp.inf
    //
    HGLOBAL hRemCmstp = NULL;
    LPTSTR pszRemCmstpInf = NULL;
    HRSRC hResource = FindResource(hInstance, MAKEINTRESOURCE(IDT_REMCMSTP_INF), TEXT("REGINST"));

    if (hResource)
    {
        hRemCmstp = LoadResource(hInstance, hResource);

        if (hRemCmstp)
        {
            //
            //  Note that we don't need to call FreeResource, which is obsolete, this
            //  will be cleaned up when cmstp.exe exits.
            //
            pszRemCmstpInf = (LPTSTR)LockResource(hRemCmstp);
        }
    }

    //
    //  Now that we have the remcmstp.inf file that is stored in the cmstp.exe resource
    //  loaded into memory and have a pointer to it, lets create the file that we are
    //  going to write it out to.
    //
    if (pszRemCmstpInf)
    {
        TCHAR szRemCmstpPath[MAX_PATH+1];
        wsprintf(szRemCmstpPath, TEXT("%s\\remcmstp.inf"), szSystemDir);

        HANDLE hFile = CreateFile(szRemCmstpPath, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL, NULL);

        if (INVALID_HANDLE_VALUE != hFile)
        {
            //
            //  Then we have the file, lets write the data to it.
            //
            DWORD cbWritten;

            if (WriteFile(hFile, pszRemCmstpInf, lstrlen(pszRemCmstpInf)*sizeof(TCHAR), 
                          &cbWritten, NULL))
            {
                //
                //  We launch the inf to delete cmstp right now.  The inf has a PreSetupCommand that
                //  launches the cmstp.exe uninstall command with a /s switch (which we write in the 
                //  inf after extracting it).  The inf then launches the new cmstp, which forces the newly 
                //  launched cmstp.exe to wait on the mutex of the current cmstp.exe until it is finished.
                //  Since profile installs will error on the mutex instead of waiting for it, we 
                //  shouldn't get any installs until after the uninstall and the cleanup inf have run.  
                //  Note that the inf will wait for the PreSetupCommands to finish before processing the inf.
                //  This is important because we could be waiting on User input (the OK dialog from 
                //  deleting CM for instance).
                //
                CloseHandle(hFile);

                //
                //  Now lets write the cmstp.exe command into remcmstp.inf
                //
                LPTSTR pszUninstallFlag = NULL;
                if (dwFlags & c_dwUninstallCm)
                {
                    pszUninstallFlag = c_pszUninstallCm;
                }
                else if (dwFlags & c_dwUninstall)
                {
                    pszUninstallFlag = c_pszUninstall;
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("ExtractInfAndRelaunchCmstp -- Unknown Uninstall Type, exiting"));
                    return FALSE;
                }

                TCHAR szShortInfPath[MAX_PATH+1] = {0};
                TCHAR szParams[2*MAX_PATH+1] = {0};

                DWORD dwRet = GetShortPathName(pszInfPath, szShortInfPath, MAX_PATH);
                
                if (0 == dwRet || MAX_PATH < dwRet)
                {
                    CMASSERTMSG(FALSE, TEXT("ExtractInfAndRelaunchCmstp -- Unable to get the short path to the Inf, exiting"));
                    return FALSE;
                }

                wsprintf(szParams, TEXT("%s\\cmstp.exe %s %s %s"), szSystemDir, pszUninstallFlag, c_pszSilent, szShortInfPath);

                WritePrivateProfileSection(TEXT("PreSetupCommandsSection"), szParams, szRemCmstpPath);  

                //
                //  Finally lets launch the inf uninstall with the new cmstp command in it.
                //
                wsprintf(szParams, 
                         TEXT("advpack.dll,LaunchINFSection %s\\remcmstp.inf, Uninstall"), 
                         szSystemDir);

                SHELLEXECUTEINFO  sei = {0};

                sei.cbSize = sizeof(sei);
                sei.fMask = SEE_MASK_FLAG_NO_UI;
                sei.nShow = SW_SHOWNORMAL;
                sei.lpFile = TEXT("Rundll32.exe");
                sei.lpParameters = szParams;
                sei.lpDirectory = szSystemDir;

                if (!ShellExecuteEx(&sei))
                {
                    CMTRACE1(TEXT("ExtractInfAndRelaunchCmstp -- ShellExecute Returned an error, GLE %d"), GetLastError());
                }
                else
                {
                    return TRUE;
                }
            }
            else
            {
                CloseHandle(hFile);
                CMASSERTMSG(FALSE, TEXT("ExtractInfAndRelaunchCmstp -- Unable to write the file data to remcmstp.inf"));
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("ExtractInfAndRelaunchCmstp -- Unable to Create remcmstp.inf in the system directory."));
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("ExtractInfAndRelaunchCmstp -- Unable to load the remcmstp.inf custom resource."));
    }

    return FALSE;
}




//+----------------------------------------------------------------------------
//
// Function:  IsInstall
//
// Synopsis:  Wrapper function to check and see if this is an install or not.
//
// Arguments: DWORD dwFlags - the action flags parameter returned from the 
//                            command line parsing class.
//
// Returns:   BOOL - TRUE if this is an Install command
//
// History:   quintinb Created Header    6/28/99
//
//+----------------------------------------------------------------------------
BOOL IsInstall(DWORD dwFlags)
{
    return (0 == (dwFlags & 0xFF));
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessCmstpExtensionDll
//
// Synopsis:  Processes the cmstp extension dll registry keys and calls out
//            to the extension proc as necessary to modify the action behavior.
//            Using the extension proc, we can modify the install, uninstall,
//            etc. behavior that cmstp exhibits.  This is most useful on platforms
//            that have Native CM (or just a very new copy of CM) but an older
//            profile is being installed.  Since the cmstp.exe that is in the package
//            does the actual installation, we can modify the installation parameters,
//            modify the inf path, or even stop the install.  Since we get called
//            after the install as well, we can even take post-install or cleanup
//            actions.
//
// Arguments: LPDWORD pdwFlags - pointer to the flags parameter, note that it 
//                               can be modified by the extension proc
//            LPTSTR pszInfPath - Inf path, note that it can be modified 
//                                by the extension proc.
//            HRESULT hrRet - current return value, this is only used on 
//                            the post action proc call.
//            EXTENSIONDLLPROCTIMES PreOrPost - if this is a Pre action 
//                                              call or a Post action call.
//
// Returns:   BOOL - TRUE if cmstp.exe should continue, FALSE stops the action 
//                   (install, uninstall, migration, whatever) without further 
//                   action.
//
// History:   quintinb Created Header    6/28/99
//
//+----------------------------------------------------------------------------
BOOL ProcessCmstpExtensionDll (LPDWORD pdwFlags, LPTSTR pszInfPath, HRESULT hrRet, EXTENSIONDLLPROCTIMES PreOrPost)
{

    //
    //  Check for the CmstpExtensionDll reg key in Cm App Paths
    //
    const TCHAR* const c_pszRegCmstpExtensionDll = TEXT("CmstpExtensionDll");
    const char* const c_pszCmstpExtensionProc = "CmstpExtensionProc";   // GetProcAddress takes ANSI strings -- quintinb
    pfnCmstpExtensionProcSpec pfnCmstpExtensionProc = NULL;

    HKEY hKey;

    TCHAR szCmstpExtensionDllPath[MAX_PATH+1];
    ZeroMemory(szCmstpExtensionDllPath, CELEMS(szCmstpExtensionDllPath));

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmAppPaths, 0, KEY_READ, &hKey))
    {
        DWORD dwSize = CELEMS(szCmstpExtensionDllPath);
        DWORD dwType = REG_SZ;

        if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegCmstpExtensionDll, NULL, &dwType, 
            (LPBYTE)szCmstpExtensionDllPath, &dwSize))
        {
            CDynamicLibrary CmstpExtensionDll (szCmstpExtensionDllPath);

            pfnCmstpExtensionProc = (pfnCmstpExtensionProcSpec)CmstpExtensionDll.GetProcAddress(c_pszCmstpExtensionProc);
            if (NULL == pfnCmstpExtensionProc)
            {
                return TRUE;
            }
            else
            {
                return (pfnCmstpExtensionProc)(pdwFlags, pszInfPath, hrRet, PreOrPost);
            }            
        }
        RegCloseKey(hKey);
    }

    return TRUE;
}

//_____________________________________________________________________________
//
// Function:  WinMain 
//
// Synopsis:  Processes command line switches -- see common\inc\cmstpex.h for full list
//             
//
// Arguments: HINSTANCE hInstance - 
//            HINSTANCE hPrevInstance - 
//            PSTR szCmdLine -      pass in the inf file name here
//            int iCmdShow - 
//
// Returns:   int WINAPI - 
//
// History:   Re-created    quintinb    7-13-98
//
//_____________________________________________________________________________
int WINAPI 
WinMain (HINSTANCE, //hInstance
         HINSTANCE, //hPrevInstance
         PSTR, //szCmdLine
         int //iCmdShow
         )
{
    CMTRACE(TEXT("====================================================="));
    CMTRACE1(TEXT(" CMSTP.EXE - LOADING - Process ID is 0x%x "), GetCurrentProcessId());
    CMTRACE(TEXT("====================================================="));

    BOOL bUsageError = FALSE;
    BOOL bAnotherInstanceRunning = FALSE;
    HRESULT hrReturn = S_OK;
    TCHAR szMsg[MAX_PATH+1];
    TCHAR szTitle[MAX_PATH+1];
    TCHAR szInfPath[MAX_PATH+1];
    DWORD dwFlags = 0;
    CPlatform plat;
    CNamedMutex CmstpMutex; // keep this here so it doesn't get destructed until main ends.
                            // this gives us better control of when it is unlocked.
    
    HINSTANCE hInstance = GetModuleHandleA(NULL);
    LPTSTR szCmdLine = GetCommandLine();

    //
    //  Check to make sure that we aren't an x86 version of cmstp running on an Alpha
    //
#ifdef CMX86BUILD
    if (plat.IsAlpha())
    {
        MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, MAX_PATH));
        MYVERIFY(0 != LoadString(hInstance, IDS_BINARY_NOT_ALPHA, szMsg, MAX_PATH));
        
        MessageBox(NULL, szMsg, szTitle, MB_OK);            
        return FALSE;        
    }
#endif

    //
    //  Setup the Command Line Arguments
    //

    ZeroMemory(szInfPath, sizeof(szInfPath));

    {   // Make sure ArgProcessor gets destructed properly and we don't leak mem

        CProcessCmdLn ArgProcessor(c_NumArgs, (ArgStruct*)&Args, TRUE, 
            FALSE); //bSkipFirstToken == TRUE, bBlankCmdLnOkay == FALSE

        if (ArgProcessor.GetCmdLineArgs(szCmdLine, &dwFlags, szInfPath, MAX_PATH))
        {
            
            //
            //  We want to wait indefinitely, unless this is an install.  If it is an
            //  install then we want to return immediately and throw an error if we couldn't
            //  get the lock (NTRAID 261248).  We also want to be able to launch two profiles
            //  simulaneously on NT5 (cmstp.exe takes the place of explorer.exe) thus we will
            //  pass the pointer to the CNamedMutex object to the install function so that
            //  it can release the mutex once the install is finished except for launching the
            //  profile (NTRAID 310478).
            //
            BOOL bWait = !IsInstall(dwFlags);

            if (CmstpMutex.Lock(CMSTPMUTEXNAME, bWait, INFINITE))
            {
                //
                //  We got the mutex lock, so go ahead and process the command line
                //  arguments.  First, however, check for a cmstp Dll listed in the 
                //  app paths key of CM.  If a dll is listed here, then we want to load
                //  the dll and pass it the inf path and the install flags.  If the dll
                //  proc returns FALSE, then we want to exit.  Otherwise continue with
                //  the install as normal.
                //  Of the install flags we first check for /x, ,/m, or /mp 
                //  (these switches must be by themselves, we don't allow any 
                //  modifier switches with these), the non-install commands.  We now allow the uninstall
                //  command to take the Silent switch to silence our uninstall prompt.
                //

                if (ProcessCmstpExtensionDll(&dwFlags, szInfPath, S_OK, PRE))
                {
                    CMTRACE2(TEXT("CMSTP.EXE -- Entering Flag Processing Loop, dwFlags = %u and szInfPath = %s"), dwFlags, szInfPath);
                    if (c_dwHelp & dwFlags)
                    {
                        bUsageError = TRUE;
                    }
                    else if (c_dwUninstall & dwFlags)
                    {
                        if (((c_dwUninstall == dwFlags) || ((c_dwUninstall | c_dwSilent) == dwFlags)) && 
                            (TEXT('\0') != szInfPath[0]))
                        {
                            BOOL bSilent = (dwFlags & c_dwSilent);

                            if (bSilent || PromptUserToUninstallProfile(hInstance, szInfPath))
                            {
                                //
                                //  Okay, the user wants to uninstall.  Now check to see if we are the last
                                //  man out.  If we are then we also need to delete cmstp.
                                //

                                if (LastManOut(PROFILEUNINSTALL, szInfPath))
                                {
                                    ExtractInfAndRelaunchCmstp(hInstance, dwFlags, szInfPath);
                                }
                                else
                                {
                                    hrReturn = UninstallProfile(hInstance, szInfPath, TRUE); // bCleanUpCreds == TRUE
                                    MYVERIFY(SUCCEEDED(hrReturn));
                                }
                            }
                        }
                        else
                        {
                            bUsageError = TRUE;
                        }
                    }
                    else if (c_dwOsMigration & dwFlags)
                    {
                        if ((c_dwOsMigration == dwFlags) && (TEXT('\0') == szInfPath[0]))
                        {
                            hrReturn = MigrateCmProfilesForWin2kUpgrade(hInstance);
                            MYVERIFY(SUCCEEDED(hrReturn));
                        }
                        else
                        {
                            bUsageError = TRUE;
                        }
                    }
                    else if (c_dwProfileMigration & dwFlags)
                    { 
                        if ((c_dwProfileMigration == dwFlags) && (TEXT('\0') == szInfPath[0]))
                        {
                            TCHAR szCurrentDir[MAX_PATH+1];
                            if (0 == GetCurrentDirectory(MAX_PATH, szCurrentDir))
                            {
                                return FALSE;
                            }
                            lstrcat(szCurrentDir, TEXT("\\"));

                            hrReturn = MigrateOldCmProfilesForProfileInstall(hInstance, szCurrentDir);
                            MYVERIFY(SUCCEEDED(hrReturn));
                        }
                        else
                        {
                            bUsageError = TRUE;
                        }
                    }                    
                    else if (c_dwUninstallCm & dwFlags)
                    {
                        if (((c_dwUninstallCm == dwFlags) || ((c_dwUninstallCm | c_dwSilent) == dwFlags)) && 
                            (TEXT('\0') != szInfPath[0]))
                        {
                            BOOL bNoBeginPrompt = (dwFlags & c_dwSilent);

                            if (bNoBeginPrompt || PromptUserToUninstallCm(hInstance))
                            {
                                //
                                //  Okay, the user wants to uninstall.  Now check to see if we are the last
                                //  man out.  If we are then we also need to delete cmstp.
                                //

                                if (LastManOut(CMUNINSTALL, szInfPath))
                                {
                                    if (ExtractInfAndRelaunchCmstp(hInstance, dwFlags, szInfPath))
                                    {
                                        //
                                        //  We need to delete the Uninstall key so that we don't leave
                                        //  it in Add/Remove Programs (the refresh is keyed off of this
                                        //  executable ending not the relaunched cmstp.exe's ending).
                                        //  NTRAID 336249
                                        //
                                        HRESULT hrTemp = HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, 
                                                                            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Connection Manager"));
                                        MYDBGASSERT(SUCCEEDED(hrTemp));
                                    }
                                }
                                else
                                {
                                    hrReturn = UninstallCm(hInstance, szInfPath);
                                    MYVERIFY(SUCCEEDED(hrReturn));
                                }
                            }
                        }
                        else
                        {
                            bUsageError = TRUE;
                        }
                    }
                    else
                    {
                        //
                        //  Figure out if the command line flags told us to install single user or
                        //  all user.  Note that we have command line flags for both now (we used to
                        //  default to all user but we now default to single user even for Admins).  If
                        //  the caller specified the all user flag and the single user flag then the
                        //  single user flag takes precedence.  Otherwise, if the all user flag is
                        //  specified we will honor it.
                        //
                        BOOL bSingleUser = ((dwFlags & c_dwSingleUser) || !(dwFlags & c_dwAllUser));

                        //
                        //  Install, note that on NT5 we will release the CmstpMutex once
                        //  we are finished installing and just want to launch the profile.
                        //
                        hrReturn = InstallInf(hInstance, szInfPath, 
                            (dwFlags & c_dwNoSupportFiles), (dwFlags & c_dwNoLegacyIcon), 
                            (dwFlags & c_dwNoNT5Shortcut), (dwFlags & c_dwSilent),
                            bSingleUser, (dwFlags & c_dwSetDefaultCon), &CmstpMutex);

                        if (FAILED(hrReturn))
                        {
                            CMTRACE2("Cmstp.exe -- InstallInf failed with error %d (0x%lx)", hrReturn, hrReturn);
                        }
                    }

                    //
                    //  Again call the Cmstp Extension Dll if one exists.  We want to give it
                    //  a chance to take post install actions if necessary.

                    ProcessCmstpExtensionDll(&dwFlags, szInfPath, hrReturn, POST);
                }
            }
            else
            {
                bAnotherInstanceRunning = TRUE;
            }        
        }
        else
        {
            bUsageError = TRUE;    
        }
    }
    
    //
    //  Clean up our Dll's
    //
    if (g_pRasApi32)
    {
        g_pRasApi32->Unload();
        CmFree(g_pRasApi32);
    }

    if (g_pRnaph)
    {
        g_pRnaph->Unload();
        CmFree(g_pRnaph);
    }

    if (g_pShell32)
    {
        g_pShell32->Unload();
        CmFree(g_pShell32);
    }

    if (g_pNetShell)
    {
        g_pNetShell->Unload();
        CmFree(g_pNetShell);
    }

    //
    //  UnLock the cmstp mutex, note that it may never have been locked or
    //  it could have been unlocked on Windows 2000 upon launching a profile,
    //  the named mutex class will handle this.
    //
    CmstpMutex.Unlock();
    
    //
    //  Display any error messages after unlocking the mutex so that don't hold
    //  it in the Usage message case.  Another instance running should only
    //  happen when an install tries to acquire the mutex while another cmstp
    //  is running, thus the mutex was never acquired but put the message code
    //  here to keep it in one place.
    //
    if (bUsageError)
    {
        CMTRACE("Cmstp.exe -- Usage Error!");
        if (0 == (dwFlags & c_dwSilent))
        {
            const int c_MsgLen = 2024;
            TCHAR* pszMsg = (TCHAR*)CmMalloc(sizeof(TCHAR)*(c_MsgLen+1));
            if (pszMsg)
            {
                MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, MAX_PATH));
                MYVERIFY(0 != LoadString(hInstance, IDS_USAGE_MSG, pszMsg, c_MsgLen));
        
                MessageBox(NULL, pszMsg, szTitle, MB_OK | MB_ICONINFORMATION);
                CmFree(pszMsg);
            }        
        }
    }
    else if (bAnotherInstanceRunning)
    {
        MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, MAX_PATH));
        MYVERIFY(0 != LoadString(hInstance, IDS_INUSE_MSG, szMsg, MAX_PATH));
        
        MessageBox(NULL, szMsg, szTitle, MB_OK);    
    }

    //
    //  Check for memory leaks
    //
    EndDebugMemory();

    //
    // get return value
    //
    BOOL bRet = SUCCEEDED(hrReturn) && !bUsageError && !bAnotherInstanceRunning;

    //
    //  Since we don't link to libc, we need to do this ourselves.
    //
    CMTRACE(TEXT("====================================================="));
    CMTRACE1(TEXT(" CMSTP.EXE - UNLOADING - Process ID is 0x%x "), GetCurrentProcessId());
    CMTRACE(TEXT("====================================================="));

    ExitProcess((UINT)bRet);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmstp\install.cpp ===
//+----------------------------------------------------------------------------
//
// File:     install.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This source file contains the code for installing CM profiles.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created     07/14/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "installerfuncs.h"
#include "winuserp.h"
#include <aclapi.h>
#include <advpub.h>
#include "tunl_str.h"
#include "cmsecure.h"
#include "gppswithalloc.cpp"

//
//  This global var, contains the path to the source files to install such as the
//  cmp, cms, and inf.  (From the inf path passed in to InstallInf).
//
TCHAR g_szProfileSourceDir[MAX_PATH+1];

//  This is really ugly, we need to consolidate our platform detection code between CM and
//  the setup components.
BOOL IsNT()
{
    CPlatform plat;
    return plat.IsNT();
}

#define OS_NT (IsNT())
BOOL IsAtLeastNT5()
{
    CPlatform plat;
    return plat.IsAtLeastNT5();
}

#define OS_NT5 (IsAtLeastNT5())
#include "MemberOfGroup.cpp"

#include "cmexitwin.cpp"

//+----------------------------------------------------------------------------
//
// Function:  SetPermissionsOnWin2kExceptionUninstallRegKeys
//
// Synopsis:  This function sets the permissions on the uninstall registry keys
//            created by the Windows 2000 exception installer.  The function
//            gives Everyone read access, Local Administrators full control, and
//            the CREATOR OWNER full control.
//
// Arguments: None
//
// Returns:   HRESULT -- standard COM style error codes
//
// History:   quintinb Created     10/04/01
//
//+----------------------------------------------------------------------------
HRESULT SetPermissionsOnWin2kExceptionUninstallRegKeys()
{
    DWORD dwRes;
    HRESULT hr = S_OK;
    LPWSTR pszCmExceptionUninstallKey = L"MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\CMEXCEPT";

    PACL pNewAccessList = NULL;
    PSID pEveryoneSid = NULL;
    PSID pAdministratorsSid = NULL;
    PSID pCreatorSid = NULL;
    PSID pCurrentUserSid = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    EXPLICIT_ACCESS_W AccessEntryArray[3] = {0};
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    HANDLE pTokenHandle = NULL;
    PTOKEN_USER ptu = NULL;
    DWORD dwNeeded = 0;
    
    BOOL bRet;

    //
    //  Link to Advapi32.dll so that we can load the security functions we need from it
    //

    typedef BOOL (WINAPI *pfnAllocateAndInitializeSidSpec)(PSID_IDENTIFIER_AUTHORITY, BYTE, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, PSID);
    typedef DWORD (WINAPI* pfnSetEntriesInAclWSpec)(ULONG, PEXPLICIT_ACCESS_W, PACL, PACL *);
    typedef DWORD (WINAPI* pfnSetNamedSecurityInfoWSpec)(LPWSTR, SE_OBJECT_TYPE, SECURITY_INFORMATION, PSID, PSID, PACL, PACL);
    typedef PVOID (WINAPI* pfnFreeSidSpec)(PSID);
    typedef VOID (WINAPI* pfnBuildTrusteeWithSidWSpec)(PTRUSTEE_W, PSID);
    typedef BOOL (WINAPI* pfnOpenProcessTokenSpec)(HANDLE, DWORD, PHANDLE);
    typedef BOOL (WINAPI* pfnGetTokenInformationSpec)(HANDLE, TOKEN_INFORMATION_CLASS, LPVOID, DWORD, PDWORD);

    pfnAllocateAndInitializeSidSpec pfnAllocateAndInitializeSid = NULL;
    pfnSetEntriesInAclWSpec pfnSetEntriesInAclW = NULL;
    pfnSetNamedSecurityInfoWSpec pfnSetNamedSecurityInfoW = NULL;
    pfnFreeSidSpec pfnFreeSid = NULL;
    pfnBuildTrusteeWithSidWSpec pfnBuildTrusteeWithSidW = NULL;
    pfnOpenProcessTokenSpec pfnOpenProcessToken = NULL;
    pfnGetTokenInformationSpec pfnGetTokenInformation = NULL;

    HMODULE hAdvapi32 = LoadLibrary(TEXT("advapi32.dll"));

    if (hAdvapi32)
    {
        pfnAllocateAndInitializeSid = (pfnAllocateAndInitializeSidSpec)GetProcAddress(hAdvapi32, "AllocateAndInitializeSid");
        pfnSetEntriesInAclW = (pfnSetEntriesInAclWSpec)GetProcAddress(hAdvapi32, "SetEntriesInAclW");
        pfnSetNamedSecurityInfoW = (pfnSetNamedSecurityInfoWSpec)GetProcAddress(hAdvapi32, "SetNamedSecurityInfoW");
        pfnFreeSid = (pfnFreeSidSpec)GetProcAddress(hAdvapi32, "FreeSid");
        pfnBuildTrusteeWithSidW = (pfnBuildTrusteeWithSidWSpec)GetProcAddress(hAdvapi32, "BuildTrusteeWithSidW");
        pfnOpenProcessToken = (pfnOpenProcessTokenSpec)GetProcAddress(hAdvapi32, "OpenProcessToken");
        pfnGetTokenInformation = (pfnGetTokenInformationSpec)GetProcAddress(hAdvapi32, "GetTokenInformation");

        if (0 == (pfnOpenProcessToken && pfnGetTokenInformation && 
                  pfnAllocateAndInitializeSid && pfnSetEntriesInAclW && 
                  pfnSetNamedSecurityInfoW && pfnFreeSid && 
                  pfnBuildTrusteeWithSidW))
        {
            hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
            goto exit;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;    
    }

    //
    //  Get the SID for Everyone
    //
    bRet = pfnAllocateAndInitializeSid (&WorldSidAuthority, 1, SECURITY_WORLD_RID, 
                                        0, 0, 0, 0, 0, 0, 0, &pEveryoneSid);

    if (!bRet || (NULL == pEveryoneSid))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    //
    //  Get the SID for the Local Administrators group
    //
    bRet = pfnAllocateAndInitializeSid (&NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                                        0, 0, 0, 0, 0, 0, &pAdministratorsSid);
    if (!bRet || (NULL == pAdministratorsSid))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    //
    //  Get the SID the for CREATOR OWNER
    //
    bRet = pfnAllocateAndInitializeSid (&CreatorSidAuthority, 1, SECURITY_CREATOR_OWNER_RID,
                                        0, 0, 0, 0, 0, 0, 0, &pCreatorSid);

    if (!bRet || (NULL == pCreatorSid))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }


    bRet = pfnOpenProcessToken(GetCurrentProcess(), TOKEN_READ  , &pTokenHandle);
    if (bRet && pTokenHandle)
    {
        bRet = pfnGetTokenInformation(pTokenHandle, TokenUser, NULL, 0, &dwNeeded);
        if (dwNeeded)
        {
            ptu = (PTOKEN_USER)CmMalloc(dwNeeded);
            if (ptu)
            {
                DWORD dwNeededAgain = 0;
                bRet = pfnGetTokenInformation(pTokenHandle, TokenUser, ptu, dwNeeded, &dwNeededAgain);
                if (bRet)
                {
                    pCurrentUserSid = ptu->User.Sid;
                }
            }
        }
        
        CloseHandle(pTokenHandle);
        pTokenHandle = NULL;
    }

    if (!bRet || (NULL == pCurrentUserSid))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }


    //
    // Give Everyone generic read access
    //
    pfnBuildTrusteeWithSidW(&(AccessEntryArray[0].Trustee), pEveryoneSid);
    AccessEntryArray[0].grfInheritance = NO_INHERITANCE;
    AccessEntryArray[0].grfAccessMode = GRANT_ACCESS;
    AccessEntryArray[0].grfAccessPermissions = GENERIC_READ;

    //
    // Give the local Administrators group full control
    //
    pfnBuildTrusteeWithSidW(&(AccessEntryArray[1].Trustee), pAdministratorsSid);
    AccessEntryArray[1].grfInheritance = NO_INHERITANCE;
    AccessEntryArray[1].grfAccessMode = GRANT_ACCESS;
    AccessEntryArray[1].grfAccessPermissions = (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL);

    //
    // Give current user full control
    //
    pfnBuildTrusteeWithSidW(&(AccessEntryArray[2].Trustee), pCurrentUserSid);
    AccessEntryArray[2].grfInheritance = NO_INHERITANCE; 
    AccessEntryArray[2].grfAccessMode = GRANT_ACCESS;
    AccessEntryArray[2].grfAccessPermissions = (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL); 


    //
    // Build an access list from the access list entry.
    //

    dwRes = pfnSetEntriesInAclW(3, &(AccessEntryArray[0]), NULL, &pNewAccessList);
    
    if (ERROR_SUCCESS == dwRes)
    {
        //
        // Set the access-control information in the object's DACL.  Note that setting PROTECTED_DACL_SECURITY_INFORMATION
        // turns off the inherited permissions.
        //
        dwRes = pfnSetNamedSecurityInfoW(pszCmExceptionUninstallKey,                                            // name of the object
                                         SE_REGISTRY_KEY,                                                       // type of object
                                         (DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION),     // type of information to set
                                         NULL,                                                                  // pointer to the new owner SID
                                         NULL,                                                                  // pointer to the new primary group SID
                                         pNewAccessList,                                                        // pointer to new DACL
                                         NULL);                                                                 // pointer to new SACL

    }

    hr = HRESULT_FROM_WIN32(dwRes);

exit:
    if (ptu)
    {
        CmFree(ptu);
        ptu = NULL;
    }

    if (pEveryoneSid && pfnFreeSid)
    {
        pfnFreeSid(pEveryoneSid);
    }

    if (pAdministratorsSid && pfnFreeSid)
    {
        pfnFreeSid(pAdministratorsSid);
    }

    if (pCreatorSid && pfnFreeSid)
    {
        pfnFreeSid(pCreatorSid);
    }

    if (pNewAccessList)
    {
        LocalFree(pNewAccessList);
    }

    if (pSecurityDescriptor)
    {
        LocalFree(pSecurityDescriptor);
    }

    if (hAdvapi32)
    {
        FreeLibrary(hAdvapi32);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CheckIeDllRequirements
//
// Synopsis:  This function checks to see if the browser agnostic dlls are of
//            a sufficient version for CM to work, or if we should copy the
//            dlls we carry in the package with us.
//
// Arguments: CPlatform* pPlat - a CPlatform object
//
// Returns:   BOOL - returns TRUE if all browser files meet the requirements, FALSE
//                   if any one of the files fails to meet what CM needs.
//
// History:   quintinb Created Header    5/24/99
//
//+----------------------------------------------------------------------------
BOOL CheckIeDllRequirements(CPlatform* pPlat)
{
    TCHAR szSysDir[MAX_PATH+1];
    TCHAR szDllToCheck[MAX_PATH+1];
    if(GetSystemDirectory(szSysDir, MAX_PATH))
    {
        if (pPlat->IsWin9x())
        {
            //
            //  Need Advapi32.dll to be version 4.70.0.1215 or greater.
            //
            const DWORD c_dwRequiredAdvapi32Version = (4 << c_iShiftAmount) + 70;
            const DWORD c_dwRequiredAdvapi32BuildNumber = 1215;

            MYVERIFY(CELEMS(szDllToCheck) > (UINT)wsprintf(szDllToCheck, TEXT("%s%s"), 
                szSysDir, TEXT("\\advapi32.dll")));
        
            CVersion AdvApi32Version(szDllToCheck);

            if ((c_dwRequiredAdvapi32Version > AdvApi32Version.GetVersionNumber()) ||
                ((c_dwRequiredAdvapi32Version == AdvApi32Version.GetVersionNumber()) && 
                 (c_dwRequiredAdvapi32BuildNumber > AdvApi32Version.GetBuildAndQfeNumber())))
            {
                return FALSE;
            }

            //
            //  Need comctl32.dll to be version 4.70.0.1146 or greater.
            //
            const DWORD c_dwRequiredComctl32Version = (4 << c_iShiftAmount) + 70;
            const DWORD c_dwRequiredComctl32BuildNumber = 1146;

            MYVERIFY(CELEMS(szDllToCheck) > (UINT)wsprintf(szDllToCheck, TEXT("%s%s"), 
                szSysDir, TEXT("\\comctl32.dll")));
        
            CVersion Comctl32Version(szDllToCheck);

            if ((c_dwRequiredComctl32Version > Comctl32Version.GetVersionNumber()) ||
                ((c_dwRequiredComctl32Version == Comctl32Version.GetVersionNumber()) && 
                 (c_dwRequiredComctl32BuildNumber > Comctl32Version.GetBuildAndQfeNumber())))
            {
                return FALSE;
            }

            //
            //  Need rnaph.dll to be version 4.40.311.0 or greater.
            //
            const DWORD c_dwRequiredRnaphVersion = (4 << c_iShiftAmount) + 40;
            const DWORD c_dwRequiredRnaphBuildNumber = (311 << c_iShiftAmount);

            MYVERIFY(CELEMS(szDllToCheck) > (UINT)wsprintf(szDllToCheck, TEXT("%s%s"), 
                szSysDir, TEXT("\\rnaph.dll")));
        
            CVersion RnaphVersion(szDllToCheck);
            if ((c_dwRequiredRnaphVersion > RnaphVersion.GetVersionNumber()) ||
                ((c_dwRequiredRnaphVersion == RnaphVersion.GetVersionNumber()) && 
                 (c_dwRequiredRnaphBuildNumber > RnaphVersion.GetBuildAndQfeNumber())))
            {
                return FALSE;
            }
        }

        //
        //  Need wininet.dll to be version 4.70.0.1301 or greater.
        //
        const DWORD c_dwRequiredWininetVersion = (4 << c_iShiftAmount) + 70;
        const DWORD c_dwRequiredWininetBuildNumber = 1301;

        MYVERIFY(CELEMS(szDllToCheck) > (UINT)wsprintf(szDllToCheck, TEXT("%s%s"), 
            szSysDir, TEXT("\\wininet.dll")));
    
        CVersion WininetVersion(szDllToCheck);

        if ((c_dwRequiredWininetVersion > WininetVersion.GetVersionNumber()) ||
            ((c_dwRequiredWininetVersion == WininetVersion.GetVersionNumber()) && 
             (c_dwRequiredWininetBuildNumber > WininetVersion.GetBuildAndQfeNumber())))
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteSingleUserProfileMappings
//
// Synopsis:  This function write the single user mappings key.
//
// Arguments: HINSTANCE hInstance - an Instance handle to load string resources with
//            LPCTSTR pszShortServiceName - short service name of the profile
//            LPCTSTR pszServiceName - Long service name of the profile
//
// Returns:   BOOL - TRUE if successful
//
// History:   quintinb Created     5/23/99
//
//+----------------------------------------------------------------------------
BOOL WriteSingleUserProfileMappings(LPCTSTR pszInstallDir, LPCTSTR pszShortServiceName, LPCTSTR pszServiceName)
{
    BOOL bReturn = FALSE;
    TCHAR szCmpFile [MAX_PATH+1];
    TCHAR szTemp [MAX_PATH+1];
    TCHAR szUserProfilePath [MAX_PATH+1];
    HKEY hKey = NULL;

    //
    //  Construct the Cmp Path
    //
    MYVERIFY(CELEMS(szCmpFile) > (UINT)wsprintf(szCmpFile, TEXT("%s\\%s.cmp"), 
        pszInstallDir, pszShortServiceName));

    //
    //  Figure out the User Profile directory
    //

    DWORD dwChars = ExpandEnvironmentStrings(TEXT("%AppData%"), szUserProfilePath, MAX_PATH);

    if (dwChars && (MAX_PATH >= dwChars))
    {
        //
        //  We want to do a lstrcmpi but with only so many chars.  Unfortunately this doesn't
        //  exist in Win32 so we will use lstrcpyn into a temp buffer and then use lstrcmpi.
        //
        lstrcpyn(szTemp, szCmpFile, lstrlen(szUserProfilePath) + 1);

        if (0 == lstrcmpi(szTemp, szUserProfilePath))
        {
            lstrcpy(szTemp, szCmpFile + lstrlen(szUserProfilePath));
            lstrcpy(szCmpFile, TEXT("%AppData%"));
            lstrcat(szCmpFile, szTemp);
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("Unable to build the Single User Mappings key value, exiting."));
            goto exit;
        }

        //
        //  Okay, now we need to write out the single user mappings key
        //
        DWORD dwDisposition;
        LONG lResult = RegCreateKeyEx(HKEY_CURRENT_USER, c_pszRegCmMappings, 0, NULL, 
                                      REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, 
                                      &hKey, &dwDisposition);

        if (ERROR_SUCCESS == lResult)
        {
            DWORD dwType = REG_SZ;
            DWORD dwSize = lstrlen(szCmpFile) + 1;

            if (ERROR_SUCCESS != RegSetValueEx(hKey, pszServiceName, NULL, dwType, 
                                               (CONST BYTE *)szCmpFile, dwSize))
            {
                CMASSERTMSG(FALSE, TEXT("Unable to write the Single User Mappings key value, exiting."));
                goto exit;
            }
            else
            {
                bReturn = TRUE;
            }
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("Unable to expand the AppData String, exiting."));
        goto exit;
    }

exit:

    if (hKey)
    {
        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessPreferencesUI
//
// Synopsis:  This function processes messages for either of the two dialogs used
//            to ask the user if they want a desktop shortcut.  One dialog is for 
//            non-admins and only contains the shortcut question, the other dialog
//            is for local admins and also contains whether the admin wants the 
//            profile installed for all users or just for single users.
//
//
// History:   quintinb Created    2/19/98
//            quintinb Renamed from ProcessAdminUI to ProcessPreferencesUI and 
//                     added new functionality  6/9/8
//            quintinb removed mention of Start Menu Shortcut  2/17/99
//
//+----------------------------------------------------------------------------
BOOL APIENTRY ProcessPreferencesUI(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    int iUiChoices;
    HKEY hKey;
    DWORD dwSize;
    DWORD dwTemp;
    DWORD dwType;
    InitDialogStruct* pDialogArgs = NULL;

    switch (message)
    {

        case WM_INITDIALOG:
            //
            //  Look up the preferences for Desktop Shortcuts/Start Menu Links
            //  in the registry and set them accordingly.
            // 
            pDialogArgs = (InitDialogStruct*)lParam;

            if (pDialogArgs->bNoDesktopIcon)
            {
                MYVERIFY(0 != CheckDlgButton(hDlg, IDC_DESKTOP, FALSE));
            }
            else
            {
                if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, c_pszRegStickyUiDefault, 
                    0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ, NULL, &hKey, &dwTemp))
                {
                    //
                    //  The default of whether a desktop shortcut should be created is stored in the
                    //  registry.  Get this value to populate the UI.  (default is off)
                    //
                    dwType = REG_DWORD;
                    dwSize = sizeof(DWORD);
                    dwTemp = 0;
                    RegQueryValueEx(hKey, c_pszRegDesktopShortCut, NULL, &dwType, (LPBYTE)&dwTemp, 
                        &dwSize);  //lint !e534
                    MYVERIFY(0 != CheckDlgButton(hDlg, IDC_DESKTOP, dwTemp));                    
                
                    MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
                }
            }

            //
            //  Set the Window Text to the Profile Name
            //
            MYVERIFY(FALSE != SetWindowText(hDlg, pDialogArgs->pszTitle));

            if (!(pDialogArgs->bSingleUser))
            {
                CheckDlgButton(hDlg, IDC_ALLUSERS, TRUE); //lint !e534 this will fail if using the nochoice UI
                
                //
                //  Set focus to the All user radio button
                //
                HWND hControl = GetDlgItem(hDlg, IDC_ALLUSERS);
                
                if (hControl)
                {
                    SetFocus(hControl);
                }
            }
            else
            {
                CheckDlgButton(hDlg, IDC_YOURSELF, TRUE); //lint !e534 this will fail if using the nochoice UI

                //
                //  Set focus to the Single user radio button
                //
                HWND hControl = GetDlgItem(hDlg, IDC_YOURSELF);
                
                if (hControl)
                {
                    SetFocus(hControl);
                }
            }

            //
            //  We return FALSE here but the focus is correctly set.
            //
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDOK:
                    //
                    //  Build the return value
                    //
                    if (IsDlgButtonChecked(hDlg, IDC_ALLUSERS) == BST_CHECKED)
                    {
                        iUiChoices = ALLUSERS;
                    }
                    else
                    {
                        iUiChoices = 0;
                    }
                    
                    if (IsDlgButtonChecked(hDlg, IDC_DESKTOP))
                    {
                        iUiChoices |= CREATEDESKTOPICON;
                    }

                    //
                    //  Make sure to save the users preferences for Desktop Icons
                    //  and Start Menu Links.
                    //

                    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, c_pszRegStickyUiDefault, 
                        0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwTemp))
                    {
                        //
                        //  Store the current state of whether we should create a desktop shortcut
                        //
                        dwTemp = IsDlgButtonChecked(hDlg, IDC_DESKTOP);
                        MYVERIFY(ERROR_SUCCESS == RegSetValueEx(hKey, c_pszRegDesktopShortCut, 0, 
                            REG_DWORD, (LPBYTE)&dwTemp, sizeof(DWORD)));
            
                        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
                    }

                    MYVERIFY(FALSE != EndDialog(hDlg, iUiChoices));

                    return (TRUE);

                case IDCANCEL:
                    MYVERIFY(FALSE != EndDialog(hDlg, -1));
                    return TRUE;

                default:
                    break;
            }
            break;

        case WM_CLOSE:
            MYVERIFY(FALSE != EndDialog(hDlg, -1));
            return TRUE;
            
        default:
            return FALSE;
    }
    return FALSE;   
}



//+----------------------------------------------------------------------------
//
// Function:  InstallCm
//
// Synopsis:  This function calls LaunchInfSection on the appropriate
//            install section to install Connection Manager.  It also installs
//            the browser files as appropriate.
//
// Arguments: HINSTANCE hInstance - Instance handle for strings
//            LPCTSTR szInfPath - Full path to the inf
//
// Returns:   HRESULT - standard com codes, could return ERROR_SUCCESS_REBOOT_REQUIRED
//                      so the caller must check for this case and ask for a reboot
//                      if required.
//
// History:   quintinb Created    8/12/98
//            quintinb Moved Browser file installation code here, since it is
//                     part of the installation of CM.      10-2-98
//
//+----------------------------------------------------------------------------
HRESULT InstallCm(HINSTANCE hInstance, LPCTSTR szInfPath)
{
    HRESULT hr = E_UNEXPECTED;

    MYDBGASSERT((szInfPath) && (TEXT('\0') != szInfPath[0]));

    //
    //  Load the Cmstp Title just in case we need to show error messages.
    //

    TCHAR szTitle[MAX_PATH+1] = {TEXT("")};
    MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, MAX_PATH));
    MYDBGASSERT(TEXT('\0') != szTitle[0]);

    //
    //  Make sure that the Inf File exists
    //
    if (!FileExists(szInfPath))
    {
        CMTRACE1(TEXT("InstallCm -- Can't find %s, the inputted Inf file."), szInfPath);
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    CPlatform plat;
    TCHAR szInstallSection[MAX_PATH+1] = {TEXT("")};

    if (plat.IsNT())
    {
        MYVERIFY(CELEMS(szInstallSection) > (UINT)wsprintf(szInstallSection, 
            TEXT("DefaultInstall_NT")));
    }
    else
    {
        MYVERIFY(CELEMS(szInstallSection) > (UINT)wsprintf(szInstallSection, 
            TEXT("DefaultInstall")));    
    }

    hr = LaunchInfSection(szInfPath, szInstallSection, szTitle, TRUE);  // bQuiet = TRUE

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  InstallWhistlerCmOnWin2k
//
// Synopsis:  This function uses the CM exception inf (cmexcept.inf) to install
//            the Whistler CM binaries on Win2k.
//
// Arguments: LPCSTR pszSourceDir - source directory for cmexcept.inf and CM
//                                  binaries, including the trailing slash.
//
// Returns:   HRESULT - standard com codes, could return ERROR_SUCCESS_REBOOT_REQUIRED
//                      which means the caller needs to request a reboot.
//
// History:   quintinb Created    02/09/2001
//
//+----------------------------------------------------------------------------
HRESULT InstallWhistlerCmOnWin2k(LPCSTR pszSourceDir)
{
    CPlatform cmplat;
    HRESULT hr = E_UNEXPECTED;
    LPSTR pszInfFile = NULL;
    LPCSTR c_pszExceptionInf = "cmexcept.inf";
    LPCSTR c_pszInstallSection = "DefaultInstall";
    LPCSTR c_pszUnInstallSection = "DefaultUninstall_NoPrompt";

    if (cmplat.IsNT5())
    {
        if (pszSourceDir && pszSourceDir[0])
        {
            DWORD dwSize = sizeof(CHAR)*(lstrlenA(pszSourceDir) + lstrlenA(c_pszExceptionInf) + 1);

            pszInfFile = (LPSTR)CmMalloc(dwSize);

            if (pszInfFile)
            {
                wsprintf(pszInfFile, "%s%s", pszSourceDir, c_pszExceptionInf);

                if (FileExists(pszInfFile))
                {
                    hr = CallLaunchInfSectionEx(pszInfFile, c_pszInstallSection, (ALINF_BKINSTALL | ALINF_QUIET));

                    if (FAILED(hr))
                    {
                        CMTRACE1(TEXT("InstallWhistlerCmOnWin2k -- CallLaunchInfSectionEx failed with hr=0x%x"), hr);

                        HRESULT hrTemp = CallLaunchInfSectionEx(pszInfFile, c_pszUnInstallSection, (ALINF_ROLLBKDOALL | ALINF_QUIET));

                        CMTRACE1(TEXT("InstallWhistlerCmOnWin2k -- Rolling back.  CallLaunchInfSectionEx returned hr=0x%x"), hrTemp);
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSTALL_PLATFORM_UNSUPPORTED); // kind of a double use of this error
    }

    CmFree(pszInfFile);

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  UpdateCmpDataFromExistingProfile
//
// Synopsis:  This function enumerates all of the keys in all of the sections
//            of an existing cmp file and copies them to the cmp file to be
//            installed.  This function copies all of the data in the existing
//            cmp unless that data already exists in the cmp to install.  This
//            allows Admins to preseed cmp files and have their settings override
//            what the user currently has in their cmp.
//
// Arguments: LPCTSTR pszShortServiceName - Short Service name of the profile
//            LPCTSTR szCurrentCmp - Full path to the currently installed cmp
//            LPCTSTR szCmpToBeInstalled - Full path to the cmp to install 
//
// Returns:   BOOL - TRUE if the cmp is copied and updated properly
//
// History:   quintinb Created                              03/16/99
//            quintinb rewrote for Whistler bug 18021       03/05/00
//
//+----------------------------------------------------------------------------
BOOL UpdateCmpDataFromExistingProfile(LPCTSTR pszShortServiceName, LPCTSTR pszCurrentCmp, LPCTSTR pszCmpToBeInstalled)
{

    if((NULL == pszShortServiceName) && (TEXT('\0') == pszShortServiceName[0]) &&
       (NULL == pszCurrentCmp) && (TEXT('\0') == pszCurrentCmp[0]) &&
       (NULL == pszCmpToBeInstalled) && (TEXT('\0') == pszCmpToBeInstalled[0]))
    {
        CMASSERTMSG(FALSE, TEXT("UpdateCmpDataFromExistingProfile -- Invalid parameter."));
        return FALSE;
    }

    BOOL bReturn = FALSE;
    BOOL bExitLoop = FALSE;
    DWORD dwSize = MAX_PATH;
    DWORD dwReturnedSize;
    LPTSTR pszAllSections = NULL;
    LPTSTR pszAllKeysInCurrentSection = NULL;
    LPTSTR pszCurrentSection = NULL;
    LPTSTR pszCurrentKey = NULL;
    TCHAR szData[MAX_PATH+1];

    //
    //  First lets get all of the sections from the existing cmp
    //
    pszAllSections = (TCHAR*)CmMalloc(dwSize*sizeof(TCHAR));

    do
    {
        MYDBGASSERT(pszAllSections);

        if (pszAllSections)
        {
            dwReturnedSize = GetPrivateProfileString(NULL, NULL, TEXT(""), pszAllSections, dwSize, pszCurrentCmp);

            if (dwReturnedSize == (dwSize - 2))
            {
                //
                //  The buffer is too small, lets allocate a bigger one
                //
                dwSize = 2*dwSize;
                if (dwSize > 1024*1024)
                {
                    CMASSERTMSG(FALSE, TEXT("UpdateCmpDataFromExistingProfile -- Allocation above 1MB, bailing out."));
                    goto exit;
                }

                pszAllSections = (TCHAR*)CmRealloc(pszAllSections, dwSize*sizeof(TCHAR));                
            }
            else if (0 == dwReturnedSize)
            {
                //
                //  We got an error, lets exit.
                //
                CMASSERTMSG(FALSE, TEXT("UpdateCmpDataFromExistingProfile -- GetPrivateProfileString returned failure."));
                goto exit;
            }
            else
            {
                bExitLoop = TRUE;
            }
        }
        else
        {
            goto exit; 
        }

    } while (!bExitLoop);

    //
    //  Okay, now we have all of the sections in the existing cmp file.  Lets enumerate
    //  all of the keys in each section and see which ones need to be copied over.
    //
    
    pszCurrentSection = pszAllSections;
    dwSize = MAX_PATH;

    pszAllKeysInCurrentSection = (TCHAR*)CmMalloc(dwSize*sizeof(TCHAR));

    while (TEXT('\0') != pszCurrentSection[0])
    {
        //
        //  Get all of the keys in the current section
        //
        bExitLoop = FALSE;

        do
        {
            if (pszAllKeysInCurrentSection)
            {
                dwReturnedSize = GetPrivateProfileString(pszCurrentSection, NULL, TEXT(""), pszAllKeysInCurrentSection, 
                                                         dwSize, pszCurrentCmp);

                if (dwReturnedSize == (dwSize - 2))
                {
                    //
                    //  The buffer is too small, lets allocate a bigger one
                    //
                    dwSize = 2*dwSize;
                    if (dwSize > 1024*1024)
                    {
                        CMASSERTMSG(FALSE, TEXT("UpdateCmpDataFromExistingProfile -- Allocation above 1MB, bailing out."));
                        goto exit;
                    }

                    pszAllKeysInCurrentSection = (TCHAR*)CmRealloc(pszAllKeysInCurrentSection, dwSize*sizeof(TCHAR));

                }
                else if (0 == dwReturnedSize)
                {
                    //
                    //  We got an error, lets exit.
                    //
                    CMASSERTMSG(FALSE, TEXT("UpdateCmpDataFromExistingProfile -- GetPrivateProfileString returned failure."));
                    goto exit;
                }
                else
                {
                    bExitLoop = TRUE;
                }
            }
            else
            {
               goto exit; 
            }

        } while (!bExitLoop);

        //
        //  Now process all of the keys in the current section
        //
        pszCurrentKey = pszAllKeysInCurrentSection;

        while (TEXT('\0') != pszCurrentKey[0])
        {
            //
            //  Try to get the value of the key from the new cmp.  If it
            //  doesn't exist, then copy of the old cmp value.  If it
            //  does exist keep the new cmp value and ignore the old one.
            //
            dwReturnedSize = GetPrivateProfileString(pszCurrentSection, pszCurrentKey, TEXT(""), 
                                                     szData, MAX_PATH, pszCmpToBeInstalled);
            if (0 == dwReturnedSize)
            {
                //
                //  Then we have a value in the old profile that we don't have in the new profile.
                //
                dwReturnedSize = GetPrivateProfileString(pszCurrentSection, pszCurrentKey, TEXT(""), 
                                                         szData, MAX_PATH, pszCurrentCmp);

                if (dwReturnedSize)
                {
                    MYVERIFY(0 != WritePrivateProfileString(pszCurrentSection, pszCurrentKey, szData, pszCmpToBeInstalled));
                }
            }

            //
            //  Advance to the next key in pszAllKeysInCurrentSection
            //
            pszCurrentKey = pszCurrentKey + lstrlen(pszCurrentKey) + 1;
        }


        //
        //  Now advance to the next string in pszAllSections 
        //
        pszCurrentSection = pszCurrentSection + lstrlen(pszCurrentSection) + 1;
    }


    //
    //  Flush the updated cmp
    //
    WritePrivateProfileString(NULL, NULL, NULL, pszCmpToBeInstalled); //lint !e534 this call will return 0

    bReturn = TRUE;

exit:

    CmFree(pszAllSections);
    CmFree(pszAllKeysInCurrentSection);

    return bReturn;

}

//+----------------------------------------------------------------------------
//
// Function:  MigrateCmpData
//
// Synopsis:  This function checks to see if a profile of the same long service
//            and short service name is already installed.  If it is, it migrates
//            the existing cmp data to the cmp file that is to be installed.
//            If the same piece of data exists in both profiles the data in the
//            cmp to be installed wins (allows admins to pre-seed data in the
//            cmp and override what users have picked).
//
// Arguments: HINSTANCE hInstance - Instance handle for string resources
//            BOOL bInstallForAllUsers - whether this is an all users profile or not
//            LPCTSTR pszServiceName - ServiceName of the current profile
//            LPCTSTR pszShortServiceName - Short Service name of the current profile
//            BOOL bSilent - whether messages to the user can be displayed or not
//
// Returns:   int - returns -1 on error, otherwise TRUE or FALSE depending on if a same name
//                  profile was discovered
//
// History:   quintinb  Created     9/8/98
//
//+----------------------------------------------------------------------------
BOOL MigrateCmpData(HINSTANCE hInstance, BOOL bInstallForAllUsers, LPCTSTR pszServiceName, 
                    LPCTSTR pszShortServiceName, BOOL bSilent)
{
    //
    //  Check the parameters
    //
    if ((NULL == pszShortServiceName) || (TEXT('\0') == pszShortServiceName[0]) || 
        (NULL == pszServiceName) || (TEXT('\0') == pszServiceName[0]))
    {
        CMASSERTMSG(FALSE, TEXT("MigrateCmpData -- Invalid Parameter"));
        return FALSE;
    }

    BOOL bReturn = TRUE;
    DWORD dwSize = MAX_PATH;
    HKEY hKey = NULL;
    HKEY hBaseKey = bInstallForAllUsers ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER;
    TCHAR szExistingCmp[MAX_PATH+1];
    TCHAR szCmpToBeInstalled[MAX_PATH+1];
    TCHAR szFmtString[2*MAX_PATH+1] = TEXT("");
    TCHAR szMsg[2*MAX_PATH+1] = TEXT("");

    //
    //  Read the mappings value
    //
    LONG lResult = RegOpenKeyEx(hBaseKey, c_pszRegCmMappings, 0, KEY_READ, &hKey);

    if (ERROR_SUCCESS == lResult)
    {
        lResult = RegQueryValueEx(hKey, pszServiceName, NULL, NULL, (LPBYTE)szFmtString, &dwSize);

        if (ERROR_SUCCESS == lResult)
        {
            //
            //  Expand the path in case it contains environment vars
            //
            if (0 == ExpandEnvironmentStrings(szFmtString, szExistingCmp, MAX_PATH))
            {
                CMASSERTMSG(FALSE, TEXT("MigrateCmpData -- Unable to expand environment strings, not migrating cmp data."));
                goto exit;
            }

            //
            //  If the file doesn't exist we have nothing to get cmp settings from ... thus
            //  lets just happily exit.
            //
            if (!FileExists(szExistingCmp))
            {                
                goto exit;
            }

            //
            //  Check to make sure that the Short Service Names agree for the two profiles
            //
            
            CFileNameParts ExistingCmpParts(szExistingCmp);
            if (0 != lstrcmpi(pszShortServiceName, ExistingCmpParts.m_FileName))
            {
                if (!bSilent)
                {
                    MYVERIFY(0 != LoadString(hInstance, IDS_SAME_LS_DIFF_SS, szFmtString, CELEMS(szFmtString)));
                    
                    MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szFmtString, pszShortServiceName, 
                                                            ExistingCmpParts.m_FileName, pszServiceName));

                    MessageBox(NULL, szMsg, pszServiceName, MB_OK);
                }

                bReturn = -1;
                goto exit;
            }
            
            //
            //  Get the path of the cmp to install
            //
            MYVERIFY(CELEMS(szCmpToBeInstalled) > (UINT)wsprintf(szCmpToBeInstalled, 
                TEXT("%s%s.cmp"), g_szProfileSourceDir, pszShortServiceName));
            
            if (FALSE == UpdateCmpDataFromExistingProfile(pszShortServiceName, szExistingCmp, szCmpToBeInstalled))
            {
                bReturn = -1;
            }
        }
    }

exit:

    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return bReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  NeedCM10Upgrade
//
// Synopsis:  This function detects and prepares data for the same name upgrade of a CM 1.0 profile.
//            Thus if you pass in a short service name and a service name, the
//            function detects if this profile is already installed for all users.
//            If it is, then the function checks the profile version stamps in the cmp.
//            If the current version isn't already newer and the user isn't a non-admin
//            on NT5, then we prompt the user if they want to upgrade the current install.
//            If they choose to upgrade then this function migrates the cmp data and
//            finds the uninstall inf.
//
// Arguments: HINSTANCE hInstance - Instance handle for string resources
//            LPCTSTR pszServiceName - ServiceName of the current profile
//            LPCTSTR pszShortServiceName - Short Service name of the current profile
//            LPTSTR pszOldInfPath - Out param for the old inf path, if the same name
//                                     upgrade is needed.
//
// Returns:   int - returns -1 on error, otherwise TRUE or FALSE depending on if a same name
//                  profile was discovered
//
// History:   quintinb  Created     9/8/98
//
//+----------------------------------------------------------------------------
int NeedCM10Upgrade(HINSTANCE hInstance, LPCTSTR pszServiceName, LPCTSTR pszShortServiceName, 
                    LPTSTR pszOldInfPath, BOOL bSilent, CPlatform* plat)
{
    HKEY hKey = NULL;
    int iReturn = FALSE;
    TCHAR   szFmtString[2*MAX_PATH+1] = TEXT("");
    TCHAR   szMsg[2*MAX_PATH+1] = TEXT("");
    const int c_iCM12ProfileVersion = 4;

    MYDBGASSERT((NULL != pszShortServiceName) && (TEXT('\0') != pszShortServiceName[0]));
    MYDBGASSERT((NULL != pszServiceName) && (TEXT('\0') != pszServiceName[0]));

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, 
        KEY_READ, &hKey))
    {
        int iCurrentCmpVersion;
        int iCmpVersionToInstall;
        TCHAR szCurrentCmp[MAX_PATH+1];
        TCHAR szCmpToBeInstalled[MAX_PATH+1];
        DWORD dwSize = MAX_PATH;

        if (ERROR_SUCCESS == RegQueryValueEx(hKey, pszServiceName, NULL, 
                                             NULL, (LPBYTE)szCurrentCmp, &dwSize))
        {
            //
            //  First check to see that the file really exists.  It is a somewhat probable case
            //  that the users will have deleted their Profile files but left the registry
            //  keys intact (they didn't uninstall it).  In fact, MSN 2.5 and 2.6 operate this
            //  way.   Thus if the cmp doesn't actually exist then we don't need a same name
            //  upgrade.
            //
            if (!FileExists(szCurrentCmp))
            {
                CMASSERTMSG(FALSE, TEXT("Detected a CM 1.0 Upgrade, but the cmp didn't exist.  Not Processing the upgrade."));
                iReturn = FALSE;
		goto exit;
            }

            //
            //  Check to make sure that the Short Service Names agree for the two profiles
            //
            
            CFileNameParts CurrentCmpParts(szCurrentCmp);
            if (0 != lstrcmpi(pszShortServiceName, CurrentCmpParts.m_FileName))
            {
                if (!bSilent)
                {
                    MYVERIFY(0 != LoadString(hInstance, IDS_SAME_LS_DIFF_SS, szFmtString, CELEMS(szFmtString)));
                    
                    MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szFmtString, pszShortServiceName, 
                                                            CurrentCmpParts.m_FileName, pszServiceName));

                    MessageBox(NULL, szMsg, pszServiceName, MB_OK);
                }

                iReturn = -1;
		goto exit;
            }

            //
            //  Then we have the same servicename profile installed as an all users install.
            //  Check the version number in the CMP.  If the same version or less then we want
            //  to run the same name upgrade.  If the current version is more recent, then
            //  we want to prevent the user from installing.
            //

            //
            //  Get Currently Installed Profile version
            //
            iCurrentCmpVersion = GetPrivateProfileInt(c_pszCmSectionProfileFormat, c_pszVersion, 
                0, szCurrentCmp);
            
            //
            //  Get the version of the profile to install
            //
            MYVERIFY(CELEMS(szCmpToBeInstalled) > (UINT)wsprintf(szCmpToBeInstalled, 
                TEXT("%s%s.cmp"), g_szProfileSourceDir, pszShortServiceName));
            
            iCmpVersionToInstall = GetPrivateProfileInt(c_pszCmSectionProfileFormat, c_pszVersion, 0, 
                szCmpToBeInstalled);

            if (iCurrentCmpVersion > iCmpVersionToInstall)
            {
                //
                //  We must not allow the install because a newer version of the profile format
                //  is already installed.
                //
                if (!bSilent)
                {
                    MYVERIFY(0 != LoadString(hInstance, IDS_NEWER_SAMENAME, szFmtString, CELEMS(szFmtString)));
                    MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szFmtString, pszServiceName));
                    MessageBox(NULL, szMsg, pszServiceName, MB_OK | MB_TOPMOST | MB_SYSTEMMODAL);
                }

                iReturn = -1;
		goto exit;
            }
            else if (iCurrentCmpVersion < c_iCM12ProfileVersion)
            {
                int iUserSelection = 0;

                //
                //  Make sure that this isn't a Non-Admin NT5 person trying to install
                //
                if (plat->IsAtLeastNT5() && !IsAdmin())
                {
                    CMASSERTMSG(!bSilent, TEXT("NeedCM10Upgrade -- NonAdmin trying to Same Name upgrade a profile, exiting!"));
                    if (!bSilent)
                    {
                        MYVERIFY(0 != LoadString(hInstance, IDS_GET_ADMIN, szFmtString, CELEMS(szFmtString)));
                        MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szFmtString, pszServiceName));
                        MessageBox(NULL, szMsg, pszServiceName, MB_OK);
                    }
                    
                    iReturn = -1;
                    goto exit;
                } 
                else
                {
                    //
                    //  Now prompt the user to make sure that they want to go ahead with the upgrade
                    //
                    if (!bSilent)
                    {
                        MYVERIFY(0 != LoadString(hInstance, IDS_UPGRADE_SAMENAME, szFmtString, CELEMS(szFmtString)));
                        MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szFmtString, pszServiceName));
                        iUserSelection = MessageBox(NULL, szMsg, pszServiceName, MB_YESNO | MB_TOPMOST | MB_SYSTEMMODAL);
                    }
                    else
                    {
                        //
                        //  Assume yes with Silent Same Name Upgrade
                        //

                        iUserSelection = IDYES;
                    }
                }

                if (IDYES == iUserSelection)
                {
                    if (UpdateCmpDataFromExistingProfile(pszShortServiceName, szCurrentCmp, szCmpToBeInstalled))
                    {                    
                        CFileNameParts FileParts(szCurrentCmp);
                        if (0 != GetSystemDirectory(szFmtString, MAX_PATH)) // use szFmtString as a temp
                        {
                            MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, TEXT("%s\\%s.inf"), szFmtString, FileParts.m_FileName));
                            if (FileExists(szMsg))
                            {
                                lstrcpy(pszOldInfPath, szMsg);
                            }
                            else
                            {
                                //
                                //  Not in the system directory, try profile dir.
                                //
                                MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, 
                                    TEXT("%s%s%s\\%s.inf"), FileParts.m_Drive, 
                                    FileParts.m_Dir, FileParts.m_FileName, 
                                    FileParts.m_FileName));
                                
                                if (FileExists(szMsg))
                                {
                                    lstrcpy(pszOldInfPath, szMsg);
                                }
                                else
                                {
                                    CMASSERTMSG(FALSE, TEXT("Unable to locate the profile INF -- old profile won't be uninstalled but installation will continue."));
                                    pszOldInfPath[0] = TEXT('\0');
                                }

                            }
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("Couldn't copy cmp file for same name upgrade.  Exiting."));
                        iReturn = -1;
                        goto exit;
                    }

                    iReturn = TRUE;
                    goto exit;
                }
                else
                {
                    iReturn = -1;
                    goto exit;
                }
            }
            else
            {
                //
                //  Then either the version numbers are the same or the version to install is newer but
                //  the existing profile is at least a 1.2 profile.
                //
                iReturn = FALSE;
		goto exit;
            }
        }
    }

exit:
    if (hKey)
    {
        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }

    return iReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  MeetsMinimumProfileInstallVersion
//
// Synopsis:  Because of problems with previous profile installers (namely 1.0),
//            we built in minimum install requirements for profiles.  Thus we
//            look under the Connection Manager App Paths key for a minimum profile
//            version, a minimum build number, and a minimum profile format version.
//            If the profile trying to install doesn't meet any of these requirements,
//            then the function returns FALSE and the install is failed.
//
// Arguments: DWORD dwInstallerVersionNumber - current installer version number
//            DWORD dwInstallerBuildNumber - current installer build number
//            LPCTSTR pszInfFile - path to the inf to get the profile format version number
//
// Returns:   BOOL - TRUE if all the version requirements are met
//
// History:   quintinb Created Header    5/24/99
//
//+----------------------------------------------------------------------------
BOOL MeetsMinimumProfileInstallVersion(DWORD dwInstallerVersionNumber, 
                                       DWORD dwInstallerBuildNumber, LPCTSTR pszInfFile)
{
    const TCHAR* const c_pszRegMinProfileVersion = TEXT("MinProfileVersion");
    const TCHAR* const c_pszRegMinProfileBuildNum = TEXT("MinProfileBuildNum");
    const TCHAR* const c_pszRegMinProfileFmtVersion = TEXT("MinProfileFmtVersion");

    HKEY hKey = NULL;
    BOOL bReturn = TRUE;
    DWORD dwTemp;

    //
    //  First check the format version.
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmAppPaths, 0, KEY_READ, &hKey))
    {
        DWORD dwSize = sizeof(DWORD);
        DWORD dwType = 0;

        if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegMinProfileFmtVersion, NULL, 
            &dwType, (LPBYTE)&dwTemp, &dwSize))
        {
            //
            //  Get the profile format version from the cmp file
            //
            DWORD dwFormatVersion;
            CFileNameParts InfParts(pszInfFile);
            TCHAR szCmpFile[MAX_PATH+1];

            MYVERIFY(CELEMS(szCmpFile) > (UINT)wsprintf(szCmpFile, TEXT("%s%s%s%s"), 
                InfParts.m_Drive, InfParts.m_Dir, InfParts.m_FileName, c_pszCmpExt));

            dwFormatVersion = (DWORD)GetPrivateProfileInt(c_pszCmSectionProfileFormat, 
                c_pszVersion, -1, szCmpFile);

            if (dwTemp > dwFormatVersion)
            {
                bReturn = FALSE;
                goto exit;
            }
        }

        //
        //  Next Check the profile version (equivalent to the version number of the 
        //  CM bits the profile was built with)
        //

        dwSize = sizeof(DWORD);

        if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegMinProfileVersion, NULL, 
            &dwType, (LPBYTE)&dwTemp, &dwSize))
        {
            //
            //  If the minimum version number from the registry is higher than the
            //  version number listed here, fail the install.
            //
            if (dwTemp > dwInstallerVersionNumber)
            {
                bReturn = FALSE;
                goto exit;
            }
        }

        //
        //  Next Check the profile build number (equivalent to the build number of the 
        //  CM bits the profile was built with)
        //

        dwSize = sizeof(DWORD);

        if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegMinProfileBuildNum, NULL, 
            &dwType, (LPBYTE)&dwTemp, &dwSize))
        {
            //
            //  If the minimum version number from the registry is higher than the
            //  version number listed here, fail the install.
            //
            if (dwTemp > dwInstallerBuildNumber)
            {
                bReturn = FALSE;
                goto exit;
            }
        }
    }

exit:

    if (hKey)
    {
        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  UninstallExistingCmException
//
// Synopsis:  This function looks for the cmexcept.inf file in the %windir%\inf
//            directory.  If this file exists, then we uninstall the
//            existing exception before we install the new one.  This prevents
//            the rollback information from being lost.
//
// Arguments: none
//
// Returns:   BOOL - returns TRUE if the installer needs to uninstall the
//                   existing CM exception install and FALSE if the install
//                   can continue without it.
//
// History:   quintinb Created      11/1/98
//
//+----------------------------------------------------------------------------
HRESULT UninstallExistingCmException()
{
    HRESULT hr = E_UNEXPECTED;
    LPCSTR c_pszCmExceptInfRelative = TEXT("\\Inf\\cmexcept.inf");
    LPCSTR c_pszUnInstallSection = "DefaultUninstall_NoPrompt";

    UINT uNumChars = GetWindowsDirectoryA(NULL, 0);

    if (uNumChars)
    {
        uNumChars = uNumChars + lstrlenA(c_pszCmExceptInfRelative);

        LPSTR pszPathToCmExceptInf = (LPSTR)CmMalloc(sizeof(CHAR)*(uNumChars + 1));

        if (pszPathToCmExceptInf)
        {
            if (GetWindowsDirectoryA(pszPathToCmExceptInf, uNumChars))
            {
                lstrcatA(pszPathToCmExceptInf, c_pszCmExceptInfRelative);

                if (FileExists(pszPathToCmExceptInf))
                {
                    //
                    //  We have an exception inf in the directory so we need to uninstall it.  Were the
                    //  bits already on the machine newer than the bits we have in the cab, then we wouldn't
                    //  be installing.  If the bits on the machine don't match the version that the inf says,
                    //  then we are better uninstalling those bits and putting them in a known state anyway.
                    //
                    hr = CallLaunchInfSectionEx(pszPathToCmExceptInf, c_pszUnInstallSection, ALINF_ROLLBKDOALL);

                    CMTRACE1(TEXT("UninstallExistingCmException -- CM Exception inf found, uninstalling.  CallLaunchInfSectionEx returned hr=0x%x"), hr);
                }
                else
                {
                    hr = S_FALSE; // nothing to delete
                }            
            }

            CmFree(pszPathToCmExceptInf);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CheckCmAndIeRequirements
//
// Synopsis:  This function checks the CM and IE requirements for a profile
//            and returns whether the CM should be installed, whether profile
//            migration should occur, and most importantly if the install should
//            exit now because of insufficient requirements.
//
// Arguments: BOOL* pbInstallCm -   tells if CM should be installed or not
//            BOOL* pbMigrateExistingProfiles - tells if profile migration should occur
//            LPCTSTR szInfFile - the inf file to install
//            LPCTSTR szServiceName - The Service name, used as a title
//
// Returns:   BOOL - returns TRUE if the install should continue, FALSE if
//                   if the install should be failed.
//
// History:   quintinb Created      11/1/98
//
//+----------------------------------------------------------------------------
BOOL CheckCmAndIeRequirements(HINSTANCE hInstance, BOOL* pbInstallCm, 
                              BOOL* pbMigrateExistingProfiles, LPCTSTR szInfFile, 
                              BOOL bNoSupportFiles, LPCTSTR szServiceName, BOOL bSilent)
{
    CmVersion   CmVer;
    CPlatform   plat;
    BOOL        bReturn;
    BOOL        bCMRequired;
    TCHAR       szMsg[2*MAX_PATH+1];
    TCHAR       szTemp[MAX_PATH+1];
    TCHAR       szString[MAX_PATH+1];
    DWORD dwInstallerBuildNumber = 0;
    DWORD dwInstallerVersionNumber = 0;


    //
    //  The inf file tells us if we included the CM bits
    //
    if (plat.IsNT5())
    {
        //
        //  We now need to check to see if we need to install the Windows XP bits on
        //  Windows 2000.  Thus we check the inf to see if this profile includes the CM
        //  bits or not.  Note that we never want to install the IE support files on
        //  Win2k so set bIERequired to TRUE.
        //
        bCMRequired = !GetPrivateProfileInt(c_pszCmakStatus, TEXT("IncludeCMCode"), 0, szInfFile);
    }
    else if (CmIsNative())
    {
        //
        //  CM and IE are required on Windows XP and any platforms with the Native
        //  regkey set except NT5 and Win98 SE as they are special cases.
        //
        bCMRequired = TRUE;
    }
    else
    {
        bCMRequired = !GetPrivateProfileInt(c_pszCmakStatus, TEXT("IncludeCMCode"), 
            0, szInfFile);
    }

    //
    //  Now try to get the version numbers from the profile INF
    //
    dwInstallerBuildNumber = (DWORD)GetPrivateProfileInt(c_pszSectionCmDial32, 
        c_pszVerBuild, ((VER_PRODUCTBUILD << c_iShiftAmount) + VER_PRODUCTBUILD_QFE), 
        szInfFile);

    dwInstallerVersionNumber = (DWORD)GetPrivateProfileInt(c_pszSectionCmDial32, 
        c_pszVersion, (HIBYTE(VER_PRODUCTVERSION_W) << c_iShiftAmount) + (LOBYTE(VER_PRODUCTVERSION_W)), 
        szInfFile);

    //
    //  First check to see if we have any install minimums in the registry.  If these
    //  minimums exist and our profile doesn't meet those minimums then we must
    //  throw an error message and exit.
    //
    if (!MeetsMinimumProfileInstallVersion(dwInstallerVersionNumber, 
                                           dwInstallerBuildNumber, szInfFile))
    {
        if (!bSilent)
        {
            MYVERIFY(0 != LoadString(hInstance, IDS_PROFILE_TOO_OLD, szMsg, MAX_PATH));
            MessageBox(NULL, szMsg, szServiceName, MB_OK | MB_ICONERROR);
        }

        return FALSE;
    }

    //
    //  Should we migrate existing profiles?  Always try to migrate if we find all user
    //  profiles already on the machine.
    //
    *pbMigrateExistingProfiles = AllUserProfilesInstalled();

    //
    //  Do CM bits exist on the machine?
    //
    if (CmVer.IsPresent())
    {
        if ((dwInstallerVersionNumber < CmVer.GetVersionNumber()) ||
                 (dwInstallerBuildNumber < CmVer.GetBuildAndQfeNumber()))
        {
            //
            //  If the CM bits on the machine are newer than the bits we have in the cab,
            //  then we only want to install the profile files and not the CM bits themselves.
            //

            *pbInstallCm = FALSE;
            bReturn = TRUE;        
        }
        else
        {
            //
            //  Then the CM bits on the machine are older than the bits in the cab or
            //  the two versions match.  Either way, we should install the bits in the
            //  cab unless this is Win2k where we never want to re-install the same
            //  version of CM bits as we will lose our rollback information.
            //

            if (bCMRequired)
            {
                if ((dwInstallerVersionNumber == CmVer.GetVersionNumber()) &&
                   (CmVer.GetBuildNumber() > c_CmMin13Version))
                {
                    //
                    //  Then the builds have the same major and minor version number
                    //  and should be considered in the same "Version Family".  Note
                    //  that we also check for a minimum build number because 7.00 is
                    //  the version number for the CM 1.0 release in NT4 SP4 and we want CM
                    //  profiles to not install on NT5 Beta2 Bits.
                    //

                    *pbInstallCm = FALSE;
                    bReturn = TRUE;                                    
                }
                else
                {
                    MYVERIFY(CELEMS(szString) > (UINT)wsprintf(szString, TEXT("%u.%u.%u.%u"), 
                        HIWORD(dwInstallerVersionNumber), LOWORD(dwInstallerVersionNumber), 
                        HIWORD(dwInstallerBuildNumber), LOWORD(dwInstallerBuildNumber)));

                    if (!bSilent)
                    {
                        MYVERIFY(0 != LoadString(hInstance, IDS_CM_OLDVERSION, szTemp, MAX_PATH));
                        MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szTemp, szString));
                        MessageBox(NULL, szMsg, szServiceName, MB_OK);
                    }
                    return FALSE;
                }
            }
            else
            {
                if ((dwInstallerVersionNumber == CmVer.GetVersionNumber()) &&
                    (dwInstallerBuildNumber == CmVer.GetBuildAndQfeNumber()))
                {
                    //
                    //  Don't reinstall the CM bits if they are the same version
                    //  and we are on Win2k.  Doing so will overwrite the version of
                    //  CM ready for rollback.
                    //
                    *pbInstallCm = !(plat.IsNT5());
                    bReturn = TRUE;           
                }
                else if (plat.IsNT5() && (FALSE == IsAdmin()))
                {
                    //
                    //  If this is Win2k and we need to install the CM binaries via the exception installer,
                    //  then the user must be an Administrator to do so.  Since this user isn't, fail
                    //  the install and give the user a warning message.
                    //

                    if (!bSilent)
                    {
                        MYVERIFY(0 != LoadString(hInstance, IDS_CANNOT_INSTALL_CM, szMsg, 2*MAX_PATH));
                        
                        MessageBox(NULL, szMsg, szServiceName, MB_OK | MB_ICONEXCLAMATION);
                    }

                    return FALSE;
                }
                else
                {
                    //
                    //  If this is Win2k, we need to make sure we aren't doing a cross language install.
                    //  Basically, we want to ensure that we aren't installing English CM bits on a native
                    //  German machine for instance.  If so, fail the install and inform the user why.
                    //
                    if (plat.IsNT5())
                    {
                        const TCHAR* const c_pszCmstp = TEXT("cmstp.exe");
                        CFileNameParts InfFileParts(szInfFile);
                        DWORD dwLen = lstrlen(InfFileParts.m_Drive) + lstrlen(InfFileParts.m_Dir) + lstrlen(c_pszCmstp);

                        if (MAX_PATH >= dwLen)
                        {
                            wsprintf(szTemp, TEXT("%s%s%s"), InfFileParts.m_Drive, InfFileParts.m_Dir, c_pszCmstp);
                            
                            CVersion CmstpVer(szTemp);
                            DWORD dwExistingCmLcid = CmVer.GetLCID();                            
                            DWORD dwCmstpLcid = CmstpVer.GetLCID();

                            if (FALSE == ArePrimaryLangIDsEqual(dwExistingCmLcid, dwCmstpLcid))
                            {
                                if (!bSilent)
                                {
                                    MYVERIFY(0 != LoadString(hInstance, IDS_CROSS_LANG_INSTALL, szMsg, 2*MAX_PATH));
                        
                                    MessageBox(NULL, szMsg, szServiceName, MB_OK | MB_ICONEXCLAMATION);
                                }

                                return FALSE;
                            }
                        }
                    }

                    //
                    //  Now check to see if installing CM is going to have an effect on CMAK
                    //
                    CmakVersion CmakVer;

                    if (CmakVer.Is121Cmak() || CmakVer.Is122Cmak())
                    {
                        //
                        //  Then the Win2k or IEAK5 version of CMAK is installed.  Installing
                        //  the Whistler version of CM will break this version of CMAK.  We
                        //  need to ask the user if they wish to continue the install and break
                        //  CMAK or abort the install and leave it as is.
                        //
                        if (bSilent)
                        {
                            return FALSE;
                        }
                        else
                        {
                            MYVERIFY(0 != LoadString(hInstance, IDS_INSTCM_WITH_OLD_CMAK, szMsg, 2*MAX_PATH));

                            if (IDNO == MessageBox(NULL, szMsg, szServiceName, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION))
                            {
                                return FALSE;                        
                            }
                        }
                    }

                    *pbInstallCm = TRUE;
                    bReturn = TRUE;
                }
            }
        }
    }
    else
    {
        if (bCMRequired)
        {
            //
            //  This is an error because we need CM bits but don't have any on
            //  the machine or in the cab (or its Whistler and we won't install them).
            //
            if (!bSilent)
            {
                MYVERIFY(0 != LoadString(hInstance, IDS_CM_NOTPRESENT, szMsg, MAX_PATH));
                MessageBox(NULL, szMsg, szServiceName, MB_OK);
            }

            return FALSE;
        }
        else
        {
            MYDBGASSERT(FALSE == plat.IsNT5()); // we shouldn't be in this state on Win2k but it is probably
                                                // better for the user if we install.

            *pbInstallCm = TRUE;
            bReturn = TRUE;
        }
    }

    if (!bNoSupportFiles)
    {
        if (!CheckIeDllRequirements(&plat))
        {
            if (!bSilent)
            {
                MYVERIFY(0 != LoadString(hInstance, IDS_NO_SUPPORTFILES, szMsg, MAX_PATH));
                MessageBox(NULL, szMsg, szServiceName, MB_OK);
            }
            return FALSE;        
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetInstallOptions
//
// Synopsis:  This function decides if the profile should be installed for all
//            users or the current user only, as well as whether the user prefers
//            a desktop icon, a start menu link, both, or neither.
//
// Arguments: OUT BOOL* pbInstallForAllUsers - should the profile be installed for all users
//            OUT BOOL* pbCreateDesktopIcon - should a desktop icon be created (if NT5)
//            IN BOOL bCM10Upgrade - is this profile upgrading an older same name profile
//            IN BOOL bNoNT5Shortcut - whether the user specified a switch saying they didn't want an NT5 Shortcut
//            IN BOOL bSilentSingleUser - whether the user specified a switch saying they wanted a silent Single User install
//            IN BOOL bSilentAllUser - whether the user specified a switch saying they wanted a silent ALL User install
//
// Returns:   TRUE if the install should continue, FALSE otherwise
//
// History:   quintinb Created    11/1/98
//
//+----------------------------------------------------------------------------
BOOL GetInstallOptions(HINSTANCE hInstance, BOOL* pbInstallForAllUsers, 
                       BOOL* pbCreateDesktopIcon, BOOL bCM10Upgrade, BOOL bNoNT5Shortcut, 
                       BOOL bSingleUser, BOOL bSilent, LPTSTR pszServiceName)
{
    //
    //  We will only allow NT5 users who are administrators to have a choice of how 
    //  the profile is installed.  If the user is on a legacy platform then the profile 
    //  will be installed for all users just as before.  If the profile is installed by 
    //  an NT5 user that is not an admin, it will be installed just for them.  If they 
    //  are an admin then they can choose if they want the profile available to all users
    //  or just for themselves.  If we are on NT5 we also allow the user to choose if 
    //  they want a Desktop Shortcut or not.
    //
    INT_PTR iUiReturn;
    CPlatform   plat;

    if (plat.IsWin9x() || plat.IsNT4())
    {
        //
        //  Legacy install, force to all users (ignore SingleUser flag because not supported).
        //
        *pbInstallForAllUsers = TRUE;
    }
    else
    {
        int iDialogID;
        
        if (bSilent)
        {
            *pbCreateDesktopIcon = !bNoNT5Shortcut;

            if (IsAdmin() && !bSingleUser)
            {
                *pbInstallForAllUsers = TRUE;
            }            
            else
            {
                *pbInstallForAllUsers = FALSE;
            }
        }
        else
        {
            if (IsAdmin())
            {
                //
                //  The user is a local admin, we need to prompt to see if they want to install 
                //  the profile for themselves or for all users.  However, if we are doing a
                //  same name upgrade, then we always do an all users install and don't give the
                //  admin any choice.
                //
                if (bCM10Upgrade)
                {
                    iDialogID = IDD_NOCHOICEUI;         
                }
                else
                {
                    iDialogID = IDD_ADMINUI;
                }
            }
            else
            {
                //
                //  Just a normal user, but we still need to prompt for whether they want 
                //  a desktop shortcut
                //
                if (bCM10Upgrade)
                {
                    CMASSERTMSG(FALSE, TEXT("Non-Admin NT5 made it to UI choice section.  Check CM 1.0 upgrade code."));
                    return FALSE;
                }
                else
                {
                    iDialogID = IDD_NOCHOICEUI;         
                }
            }

            InitDialogStruct DialogArgs;
            DialogArgs.pszTitle = pszServiceName;
            DialogArgs.bNoDesktopIcon = bNoNT5Shortcut;
            DialogArgs.bSingleUser = bSingleUser;

            iUiReturn = DialogBoxParam(hInstance, MAKEINTRESOURCE(iDialogID), NULL, 
                (DLGPROC)ProcessPreferencesUI, (LPARAM)&DialogArgs);

            if (-1 == iUiReturn)
            {
                // then we had an error or the user hit cancel.  Either way bail.
                return FALSE;
            }
            else
            {
                *pbInstallForAllUsers = (BOOL)(iUiReturn & ALLUSERS) || bCM10Upgrade;
                *pbCreateDesktopIcon = (BOOL)(iUiReturn & CREATEDESKTOPICON);
            }
        }
    }
    return TRUE;
}

BOOL VerifyProfileOverWriteIfExists(HINSTANCE hInstance, LPCTSTR pszCmsFile, LPCTSTR pszServiceName, 
                                    LPCTSTR pszShortServiceName, LPTSTR pszOldInfPath, BOOL bSilent)
{
    TCHAR szTmpServiceName [MAX_PATH+1] = TEXT("");
    TCHAR szDisplayMsg[3*MAX_PATH+1] = TEXT("");
    TCHAR szTemp [2*MAX_PATH+1] = TEXT("");
    int iRet;

    if (FileExists(pszCmsFile))
    {
        //
        //  If the file exists then we want to make sure that the service name is the same.
        //  If the Long Service Names are the same then we have a re-install.
        //  If they aren't the same then we need to prompt the user and find out whether to
        //  abandon the install or continue and overwrite it.
        //

        MYVERIFY(0 != GetPrivateProfileString(c_pszCmSection, c_pszCmEntryServiceName, 
            TEXT(""), szTmpServiceName, CELEMS(szTmpServiceName), pszCmsFile));

        if (0 != lstrcmp(szTmpServiceName, pszServiceName))
        {
            //
            //  If the install is silent, we will assume they know what they are doing
            //  and we will overwrite.  Otherwise prompt the user to see what they want
            //  us to do.
            //
            if (!bSilent)
            {
                MYVERIFY(0 != LoadString(hInstance, IDS_SAME_SS_DIFF_LS, szTemp, 2*MAX_PATH));

                MYVERIFY(CELEMS(szDisplayMsg) > (UINT)wsprintf(szDisplayMsg, szTemp, pszServiceName, 
                    szTmpServiceName, pszShortServiceName));
            
                MessageBox(NULL, szDisplayMsg, pszServiceName, MB_OK | MB_TOPMOST | MB_SYSTEMMODAL);
            }

            return FALSE;
        }
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Function:  PresharedKeyPINDlgProc
//
// Synopsis:  This function obtains the PIN to be used for the Pre-Shared key
//
// History:   SumitC    29-Mar-2001         Created
//
//+----------------------------------------------------------------------------
BOOL APIENTRY PresharedKeyPINDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    static PresharedKeyPINStruct * pPSKArgs;

    switch (message)
    {
        case WM_INITDIALOG:
            pPSKArgs = (PresharedKeyPINStruct*)lParam;
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDOK:
                    MYDBGASSERT(pPSKArgs);
                    if (pPSKArgs && pPSKArgs->szPIN)
                    {
                        GetDlgItemText(hDlg, IDC_PSK_PIN, pPSKArgs->szPIN, c_dwMaxPresharedKeyPIN);
                    }
                    MYVERIFY(FALSE != EndDialog(hDlg, 1));
                    return TRUE;

                case IDCANCEL:
                    MYVERIFY(FALSE != EndDialog(hDlg, -1));
                    return TRUE;

                default:
                    break;
            }
            break;

        case WM_CLOSE:
            MYVERIFY(FALSE != EndDialog(hDlg, -1));
            return TRUE;
            
        default:
            return FALSE;
    }
    return FALSE;   
}


//+----------------------------------------------------------------------------
//
// Function:  GetPINforPresharedKey
//
// Synopsis:  Asks the user for a PIN (to be used to decrypt the pre-shared key)
//
// Arguments: [hInstance]  - used for bringing up dialogs
//            [ppszPIN]    - ptr to where to put Pre-Shared Key PIN
//
// Returns:   LRESULT (ERROR_SUCCESS if we got a PIN,
//                     ERROR_INVALID_DATA if user cancelled out of PIN dialog,
//                     ERROR_INVALID_PARAMETER if params are bad (this is a coding issue)
//
// History:   3-Apr-2001    SumitC      Created
//
//-----------------------------------------------------------------------------
LRESULT GetPINforPresharedKey(HINSTANCE hInstance, LPTSTR * ppszPIN)
{
    LRESULT lRet = ERROR_SUCCESS;
    
    MYDBGASSERT(hInstance);
    MYDBGASSERT(ppszPIN);

    if (NULL == hInstance || NULL == ppszPIN)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    *ppszPIN = NULL;

    //
    //  Get the PIN
    //
    PresharedKeyPINStruct PresharedKeyPINArgs = {0};

    INT_PTR iUiReturn = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_PRESHAREDKEY_PIN), NULL, 
        (DLGPROC)PresharedKeyPINDlgProc, (LPARAM)&PresharedKeyPINArgs);

    if (-1 == iUiReturn)
    {
        lRet = ERROR_INVALID_DATA;  // caller maps to appropriate error message.
    }
    else
    {
        DWORD dwLen = lstrlen(PresharedKeyPINArgs.szPIN);
        if (0 == dwLen)
        {
            lRet = ERROR_INVALID_DATA;  // caller maps to appropriate error message.
        }
        else
        {
            *ppszPIN = (LPTSTR) CmMalloc((dwLen + 1) * sizeof(TCHAR));
            if (*ppszPIN)
            {
                lstrcpy(*ppszPIN, PresharedKeyPINArgs.szPIN);
            }
        }
    }

    return lRet;
}


//+----------------------------------------------------------------------------
//
// Function:  DecryptPresharedKeyUsingPIN
//
// Synopsis:  Given an encoded preshared key and a PIN to be used for decoding,
//            performs the decoding job.
//
// Arguments: [pszEncodedPresharedKey] - encoded Preshared key
//            [pszPreSharedKeyPIN]     - the PIN
//            [ppszPreSharedKey]       - ptr to buffer to place Pre-Shared Key
//
// Returns:   LRESULT (ERROR_SUCCESS successfully decoded
//                     ERROR_INVALID_PARAMETER if params are bad (this is a coding issue)
//                     other errors as encountered while calling crypto APIs
//
// History:   3-Apr-2001    SumitC      Created
//
//-----------------------------------------------------------------------------
LRESULT DecryptPresharedKeyUsingPIN(LPCTSTR pszEncodedPresharedKey,
                                    LPCTSTR pszPresharedKeyPIN,
                                    LPTSTR * ppszPresharedKey)
{
    LRESULT lRet = ERROR_BADKEY;

    if (lstrlen(pszPresharedKeyPIN) < c_dwMinPresharedKeyPIN)
    {
        CMTRACE(TEXT("DecryptPresharedKeyUsingPIN - PIN is too short"));
        return lRet;
    }
    if (lstrlen(pszPresharedKeyPIN) > c_dwMaxPresharedKeyPIN)
    {
        CMTRACE(TEXT("DecryptPresharedKeyUsingPIN - PIN is too long"));
        return lRet;
    }

    //
    //  Init Cmsecure
    //
    InitSecure(FALSE);      // use secure, not fast encryption

    //
    //  decrypt to get Preshared key
    //
    if (pszEncodedPresharedKey && pszPresharedKeyPIN)
    {
        DWORD dwLen = 0;

        if (FALSE == DecryptString((LPBYTE)pszEncodedPresharedKey,
                                   lstrlen(pszEncodedPresharedKey) * sizeof(TCHAR),
                                   (LPSTR)pszPresharedKeyPIN,
                                   (LPBYTE *)ppszPresharedKey,
                                   &dwLen,
                                   (PFN_CMSECUREALLOC)CmMalloc,
                                   (PFN_CMSECUREFREE)CmFree))
        {
            CMTRACE1(TEXT("DecryptPresharedKeyUsingPIN - DecryptString failed with %d"), GetLastError());
            lRet = ERROR_BADKEY;
        }
        else
        {
            lRet = ERROR_SUCCESS;
            CMASSERTMSG(dwLen, TEXT("DecryptString succeeded, but pre-shared key retrieved was 0 bytes?"));
        }
    }

    //
    //  Deinit cmsecure
    //
    DeInitSecure();

    return lRet;
}

//+----------------------------------------------------------------------------
//
// Function:  SetThisConnectionAsDefault
//
// Synopsis:  This function loads inetcfg.dll and calls the InetSetAutodial
//            entry on the given service name.  Thus this function sets the
//            given servicename as the IE default connection.
//
// Arguments: LPCSTR pszServiceName - Long service name of the connection to set
//
// Returns:   BOOL - TRUE if successful
//
// History:   quintinb Created    03/04/00
//
//+----------------------------------------------------------------------------
BOOL SetThisConnectionAsDefault(LPSTR pszServiceName)
{
    BOOL bReturn = FALSE;
    typedef HRESULT (WINAPI *pfnInetSetAutodialProc)(BOOL, LPSTR);

    if (pszServiceName && (TEXT('\0') != pszServiceName[0]))
    {
        CDynamicLibrary CnetCfg;

        if (CnetCfg.Load(TEXT("inetcfg.dll")))
        {
            pfnInetSetAutodialProc pfnInetSetAutodial = (pfnInetSetAutodialProc)CnetCfg.GetProcAddress("InetSetAutodial");

            if (pfnInetSetAutodial)
            {
                HRESULT hr = pfnInetSetAutodial(TRUE, pszServiceName); // TRUE == fEnable
                bReturn = SUCCEEDED(hr);
            }
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetPreSharedKey
//
// Synopsis:  This function does all the grunt work of getting a PreSharedKey
//            out of the profile and decrypting it if one exists.
//
// Arguments: LPCSTR pszCmpFile - full path to the cmp file
//
// Returns:   HRESULT -- S_OK on success
//                       S_FALSE if the profile doesn't contain a PSK
//                       E_XXX otherwise
//
// History:   quintinb Created    09/14/01
//
//+----------------------------------------------------------------------------
HRESULT GetPreSharedKey(HINSTANCE hInstance, LPCTSTR pszCmpFile, LPCTSTR pszServiceName, LPTSTR* ppszPreSharedKey, BOOL bSilent)
{
    //
    //  Check input parameters
    //
    if ((NULL == pszCmpFile) || (TEXT('\0') == pszCmpFile[0]) || (NULL == ppszPreSharedKey) || (NULL == pszServiceName) || (TEXT('\0') == pszServiceName[0]))
    {
        CMASSERTMSG(FALSE, TEXT("GetPreSharedKey -- Invalid parameter passed."));
        return E_INVALIDARG;
    }

    HRESULT hrReturn = S_OK;
    TCHAR szTemp[2*MAX_PATH+1];
    CPlatform   plat;

    //
    //  Check to see if we have a Pre-shared Key
    //
    if (FileExists(pszCmpFile))
    {
        LPTSTR pszPresharedKey = GetPrivateProfileStringWithAlloc(c_pszCmSection, c_pszCmEntryPresharedKey, TEXT(""), pszCmpFile);

        if (pszPresharedKey && (TEXT('\0') != pszPresharedKey[0]))
        {
            //
            //  Okay, we potentially have a PSK.  If we are on Win2k or a downlevel system without the SafeNet client,
            //  then we need to warn the user that their connection might not work and ask them if they wish to continue
            //  anyway.
            //
            UINT uMessageId = 0;

            if (plat.IsNT5()) // NT5 only
            {
                uMessageId = IDS_PSK_NEEDS_XP;
            }
            else if (plat.IsNT4() || plat.IsWin9x()) // downlevel without SafeNet
            {
                SafeNetLinkageStruct SnLinkage = {0};

                if (!IsSafeNetClientAvailable() || !LinkToSafeNet(&SnLinkage)) // UnLinkFromSafeNet needs to be called if we hit this
                {
                    uMessageId = IDS_PSK_NEEDS_SAFENET;
                }

                UnLinkFromSafeNet(&SnLinkage);
            }
            // else it is WinXP+ or downlevel with SafeNet and everything should work just nicely...

            if (uMessageId)
            {
                //
                //  Now show the user the error message unless we are in silent mode.  Either way we aren't going to do anything
                //  more with the PSK string since the user's OS cannot handle pre-shared keys.
                //
                int iMessageReturn = IDNO;

                if (!bSilent && LoadString(hInstance, uMessageId, szTemp, sizeof(szTemp)))
                {
                    iMessageReturn = MessageBox(NULL, szTemp, pszServiceName, MB_YESNO | MB_ICONWARNING);
                }

                if (IDYES == iMessageReturn)
                {
                    //
                    //  Okay, we are continuing but we cannot do anything with the PSK, so set the return code to S_FALSE.
                    //
                    hrReturn = S_FALSE;
                }
                else
                {
                    //
                    //  The user decided to bail or we are in silent mode and needed to show a warning.
                    //
                    hrReturn = E_ABORT;
                }

                //
                //  We cannot do anything with the PSK so let's free it.  We will erase it from the cmp below.
                //
                CmFree(pszPresharedKey);
                pszPresharedKey = NULL;

            }
            else
            {
                //
                //  Okay, we have a PSK and it needs further processing such as decryption and/or handing off to RAS/SafeNet.
                //

                CMTRACE(TEXT("Got a pre-shared key"));

                BOOL bEncrypted = (BOOL) GetPrivateProfileInt(c_pszCmSection, c_pszCmEntryKeyIsEncrypted, FALSE, pszCmpFile);

                if (bEncrypted)
                {
                    CMTRACE(TEXT("Pre-shared key is encrypted"));

                    if (bSilent)
                    {
                        //
                        //  If we are in silent mode, then we cannot exactly ask the user for a PIN.  Thus we will have to abort.
                        //
                        CmFree(pszPresharedKey);
                        hrReturn = E_ABORT;
                    }
                    else
                    {
                        LPTSTR pszPresharedKeyPIN = NULL;
                        LRESULT lRet = GetPINforPresharedKey(hInstance, &pszPresharedKeyPIN);

                        if ((ERROR_SUCCESS == lRet) && pszPresharedKeyPIN)
                        {
                            //
                            //  The Pre-shared key is encoded
                            //
                            LPTSTR pszPresharedKeyDecoded = NULL;
                            lRet = DecryptPresharedKeyUsingPIN(pszPresharedKey, pszPresharedKeyPIN, &pszPresharedKeyDecoded);

                            if (ERROR_SUCCESS == lRet)
                            {
                                *ppszPreSharedKey = pszPresharedKeyDecoded;
                            }
                            else
                            {
                                *ppszPreSharedKey = NULL;
                                lRet = ERROR_BADKEY;
                            }
                        }

                        CmFree(pszPresharedKey);
                        CmFree(pszPresharedKeyPIN);

                        if (ERROR_SUCCESS != lRet)
                        {
                            switch (lRet)
                            {
                            case ERROR_INVALID_DATA:
                                MYVERIFY(0 != LoadString(hInstance, IDS_PSK_GOTTA_HAVE_IT, szTemp, CELEMS(szTemp)));
                                break;
                            case ERROR_BADKEY:
                                MYVERIFY(0 != LoadString(hInstance, IDS_PSK_INCORRECT_PIN, szTemp, CELEMS(szTemp)));
                                break;
                            default:
                                MYVERIFY(0 != LoadString(hInstance, IDS_UNEXPECTEDERR, szTemp, CELEMS(szTemp)));
                                MYDBGASSERT(0);
                                break;
                            }

                            MessageBox(NULL, szTemp, pszServiceName, MB_OK | MB_ICONEXCLAMATION);
                            hrReturn = E_ACCESSDENIED;
                        }
                    }
                }
                else
                {
                    //
                    //  Nothing to decode, just save the PSK buffer
                    //
                    *ppszPreSharedKey = pszPresharedKey;
                }

                //
                //  Write to the cmp file that we need to delete this PSK on uninstall.  If we never get fully
                //  installed then the cmp file gets deleted anyway so no big deal.  Note that we do this here
                //  so that it is in the cmp file before we copy it to the profile directory.
                //
                if (SUCCEEDED(hrReturn) && (plat.IsNT4() || plat.IsWin9x()))
                {
                    WritePrivateProfileString(c_pszCmSection, c_pszDeletePskOnUninstall, TEXT("1"), pszCmpFile);
                }
            }

            //
            //  Erase the PSK from the cmp file
            //
            WritePrivateProfileString(c_pszCmSection, c_pszCmEntryPresharedKey, NULL, pszCmpFile);
            WritePrivateProfileString(c_pszCmSection, c_pszCmEntryKeyIsEncrypted, NULL, pszCmpFile);
        }
        else
        {
            CmFree(pszPresharedKey);
            hrReturn = S_FALSE;
        }
    }

    return hrReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  InstallInf
//
// Synopsis:  This is the driver code for installing a CM profile.
//
// Arguments: HINSTANCE hInstance - Instance handle for resources
//            LPCTSTR szInfFile - INF file to install
//            BOOL bNoSupportFiles - forces browser files not to be checked for
//            BOOL bNoLegacyIcon - Don't install with a legacy Icon
//            BOOL bNoNT5Shortcut - Don't give the user a NT5 Desktop Shortcut
//            BOOL bSilent - Install the profile silently
//            BOOL bSingleUser - Install the profile for the current user only
//                               Note that single user is the default now even for
//                               Admins.  Non-Admins always get single user installs.
//            BOOL bSetAsDefault - set as the default connection once installed
//            CNamedMutex* pCmstpMutex - pointer to the cmstp mutex object so 
//                                       that it can be released once the profile is launched
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created    7/14/98
//            quintinb added support for new switches (252872)    11/20/98
//
//+----------------------------------------------------------------------------
HRESULT InstallInf(HINSTANCE hInstance, LPCTSTR szInfFile, BOOL bNoSupportFiles, 
                BOOL bNoLegacyIcon, BOOL bNoNT5Shortcut, BOOL bSilent, 
                BOOL bSingleUser, BOOL bSetAsDefault, CNamedMutex* pCmstpMutex)
{
    CPlatform   plat;

    BOOL bMigrateExistingProfiles;
    BOOL bInstallCm;
    BOOL bMustReboot = FALSE;
    BOOL bCM10Upgrade = FALSE;
    HRESULT hrReturn = S_OK;
    HRESULT hrTemp = S_OK;
    BOOL bInstallForAllUsers;
    BOOL bCreateDesktopIcon = FALSE;

    HKEY hKey = NULL;

    DWORD dwSize;
    DWORD dwType;
    TCHAR szInstallDir[MAX_PATH+1];
    TCHAR szTemp[2*MAX_PATH+1];
    TCHAR szCmsFile[MAX_PATH+1];
    TCHAR szOldInfPath[MAX_PATH+1];
    TCHAR szServiceName[MAX_PATH+1];
    TCHAR szShortServiceName[MAX_PATH+1];
    TCHAR szTitle[MAX_PATH+1];
    LPTSTR pszPhonebook = NULL;
    LPTSTR pszCmpFile = NULL;
    LPTSTR pszPresharedKey = NULL;

//CMASSERTMSG(FALSE, TEXT("Attach the Debugger now!"));
    MYDBGASSERT((szInfFile) && (TEXT('\0') != szInfFile[0]));

    CFileNameParts InfParts(szInfFile);
    wsprintf(g_szProfileSourceDir, TEXT("%s%s"), InfParts.m_Drive, InfParts.m_Dir);

    MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, CELEMS(szTitle)));
    MYDBGASSERT(TEXT('\0') != szTitle[0]);

    //
    //  Get the ServiceName and ShortServicename from the inf file
    //

    MYVERIFY(0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszCmEntryServiceName, 
        TEXT(""), szServiceName, CELEMS(szServiceName), szInfFile));

    MYVERIFY(0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszShortSvcName, 
        TEXT(""), szShortServiceName, CELEMS(szShortServiceName), szInfFile));

    if ((TEXT('\0') == szServiceName[0]) || (TEXT('\0') == szShortServiceName[0]))
    {
        CMASSERTMSG(FALSE, TEXT("Either the ServiceName or the ShortServiceName are empty, exiting."));
        hrReturn = E_FAIL;
        goto exit;
    }

    //
    //  If this is NT5, check the New Connection Wizard Policy to see if the user is allowed to
    //  create new connections.  If not, then don't let them install.
    //
    if (plat.IsAtLeastNT5())
    {
        LPTSTR c_pszNewPolicy = TEXT("NC_NewConnectionWizard");
        LPTSTR c_pszConnectionsPoliciesKey = TEXT("Software\\Policies\\Microsoft\\Windows\\Network Connections");

        //
        //  Administrators and all Authenticated users have access to install profiles
        //  by default.  Non-Authenticated users don't have access to install profiles
        //  because they don't have permission to start Rasman.  Thus, even if we
        //  allowed them to try to install, it would fail when we couldn't create a
        //  connectoid for the profile.
        //
        DWORD dwAllowedToInstall = IsAuthenticatedUser() || IsAdmin();

        //
        //  Now we need to check the policy registry key to see if someone has overriden
        //  the default behavior.  If so, then we will honor it by setting dwAllowedToInstall
        //  to the value of the policy key.  Note that we even check the registry key for
        //  authenticated users (an Admin could enable installation for all users, but users
        //  that weren't Authenticated, namely guests, wouldn't be able to The default is to allow Users, Power Users (who are users), and Admins to install
        //  connections.  However the policy may be setup so that they cannot.  Lets assume they
        //  can and then check the regkey.
        //
        if (dwAllowedToInstall)
        {
            LONG lResult = RegOpenKeyEx(HKEY_CURRENT_USER, c_pszConnectionsPoliciesKey, 
                                        0, KEY_READ, &hKey);

            if (ERROR_SUCCESS == lResult)
            {
                dwSize = sizeof(dwAllowedToInstall);

                lResult = RegQueryValueEx(hKey, c_pszNewPolicy, NULL, 
                                          NULL, (LPBYTE)&dwAllowedToInstall, &dwSize);                
                RegCloseKey(hKey);
            }
        }

        if (!dwAllowedToInstall)
        {
            //
            //  The user isn't allowed to create new connections, thus they aren't allowed to install
            //  CM connections.  Throw an error message about permissions and exit.
            //
            MYVERIFY(0 != LoadString(hInstance, IDS_INSTALL_NOT_ALLOWED, szTemp, CELEMS(szTemp)));
            MessageBox(NULL, szTemp, szServiceName, MB_OK);
            hrReturn = E_ACCESSDENIED;
            goto exit;
        }
    }

    if (!CheckCmAndIeRequirements(hInstance, &bInstallCm, &bMigrateExistingProfiles, 
        szInfFile, bNoSupportFiles, szServiceName, bSilent))
    {
        hrReturn = E_FAIL;
        goto exit;
    }

    //
    //  Check to see if we have a same name upgrade
    //
    
    bCM10Upgrade = NeedCM10Upgrade(hInstance, szServiceName, szShortServiceName, 
                                   szOldInfPath, bSilent, &plat);

    if (-1 == bCM10Upgrade)
    {
        //
        //  if NeedCM10Upgrade returned -1 then either an error occurred or
        //  the user decided not to upgrade.  Either way, bail.
        //
        hrReturn = S_FALSE;
        goto exit;
    }

    //
    //  Check to see if a Pre-shared Key is present and if a PIN is required
    //
    pszCmpFile = szTemp;    // re-use szTemp to save stack space and not get into trouble on Win9x
    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(pszCmpFile, TEXT("%s%s.cmp"), 
        g_szProfileSourceDir, szShortServiceName));

    hrReturn = GetPreSharedKey(hInstance, pszCmpFile, szServiceName, &pszPresharedKey, bSilent);
 
    if (FAILED(hrReturn))
    {
        goto exit;
    }

    //
    //  Throw the UI to get user install options, unless we are in silent mode
    //
    if (!GetInstallOptions(hInstance, &bInstallForAllUsers, &bCreateDesktopIcon, 
        bCM10Upgrade, bNoNT5Shortcut, bSingleUser, bSilent, szServiceName))
    {
        hrReturn = S_FALSE;
        goto exit;    
    }

    //
    //  Get the installation path
    //

    ZeroMemory(szInstallDir, sizeof(szInstallDir));

    if (bInstallForAllUsers)
    {
        //
        //  Install for All Users
        //

        if (!GetAllUsersCmDir(szInstallDir, hInstance))
        {
            hrReturn = E_FAIL;
            goto exit; 
        }
    }
    else
    {
        //
        //  Install only for the current user
        //
        
        GetPrivateCmUserDir(szInstallDir, hInstance);   //lint !e534

        if (TEXT('\0') == szInstallDir[0])
        {
            hrReturn = E_FAIL;
            goto exit;        
        }
    }

    MYVERIFY(CELEMS(szCmsFile) > (UINT)wsprintf(szCmsFile, TEXT("%s\\%s\\%s.cms"), 
        szInstallDir, szShortServiceName, szShortServiceName));

    //
    //  Check for two profiles with the same Short Service Name and different Long Service
    //  Names
    //
    if (!VerifyProfileOverWriteIfExists(hInstance, szCmsFile, 
         szServiceName, szShortServiceName, szOldInfPath, bSilent))
    {
        hrReturn = S_FALSE;
        goto exit;
    }

    //  Now Migrate users old cm profiles (to have full paths to their CMP files in the 
    //  desktop GUID) if necessary
    //
    if (bMigrateExistingProfiles)
    {
        //
        //  Ignore the return here for now.  Not much we can do about it at this stage.
        //  Should we give them an error?
        //
        MYVERIFY(SUCCEEDED(MigrateOldCmProfilesForProfileInstall(hInstance, g_szProfileSourceDir)));
    }

    if (bCM10Upgrade)
    {
        //
        //  Uninstall the current profile so that we can install the newer version.  Note
        //  that we don't want to use the uninstall string because it might call for
        //  cmstp.exe which is already running.  Thus uninstall by calling UninstallProfile
        //  directly.  Note that we do not delete the credentials on a same name upgrade
        //  profile uninstall.
        //

        if (szOldInfPath[0])
        {
            RemoveShowIconFromRunPostSetupCommands(szOldInfPath);

            MYVERIFY(SUCCEEDED(UninstallProfile(hInstance, szOldInfPath, FALSE))); // bCleanUpCreds == FALSE
        }
    }
    else
    {
        //
        //  We need to check if we are installing over another profile of the same name.
        //  If so, then we want to recover the cmp data unless this is a CM 1.0 upgrade
        //  in which case we have already done this as part of that upgrade code.
        //
        if (-1 == MigrateCmpData(hInstance, bInstallForAllUsers, szServiceName, szShortServiceName, bSilent))
        {
            hrReturn = S_FALSE;
            goto exit;        
        }
    }

    //
    //  In order to keep MSN's online setup working we need to keep the all user install 
    //  registry key (used to communicate the path to the inf) in the same place that it was
    //  for the Win98 SE/Beta3 release.  The Single user reg key location had to be moved to 
    //  allow plain old users to install profiles.
    //
    HKEY hBaseKey;
    LPTSTR pszRegInfCommKeyPath;

    if (bInstallForAllUsers)
    {
        hBaseKey = HKEY_LOCAL_MACHINE;
        pszRegInfCommKeyPath = (LPTSTR)c_pszRegCmAppPaths;
    }
    else
    {
        hBaseKey = HKEY_CURRENT_USER;
        pszRegInfCommKeyPath = (LPTSTR)c_pszRegCmRoot;
    }


    //
    //  Now create the install dir and the reg key to communicate this info to the inf file.
    //
    if (TEXT('\0') != szInstallDir[0])
    {
        //
        //  Create the full path to the installation directory.
        //
        MYVERIFY(FALSE != CreateLayerDirectory(szInstallDir));

        //
        //  Make sure the CM directory is writable by all users so that phonebook updates can take place.
        //
        if (bInstallForAllUsers && plat.IsAtLeastNT5())
        {
            MYVERIFY(AllowAccessToWorld(szInstallDir));
        }

        //
        //  Create the Profile subdirectory too, that way we avoid profile
        //  install problems on Win98 -- NTRAID 376878
        //
        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s"), szInstallDir, szShortServiceName));
        MYVERIFY(FALSE != CreateLayerDirectory(szTemp));

        //
        //  We now need to write the registry key that the inf will use as the
        //  installation directory.  See the CustomDestination section of the 
        //  profile inf to see where this ties in.
        //
        if (plat.IsWin9x())
        {
            //
            //  Then we need to use the Short Name in the regkey or the inf will not install properly
            //
            MYVERIFY(0 != GetShortPathName(szInstallDir, szTemp, CELEMS(szTemp)));

            lstrcpyn(szInstallDir, szTemp, MAX_PATH);       // szTemp is larger than szInstallDir, we only use MAX_PATH chars
        }

        if (ERROR_SUCCESS != RegCreateKey(hBaseKey, pszRegInfCommKeyPath, &hKey))
        {
            CMASSERTMSG(FALSE, TEXT("InstallInf -- Unable to create the Inf Communication Key"));
            MYVERIFY(0 != LoadString(hInstance, IDS_UNEXPECTEDERR, szTemp, CELEMS(szTemp)));
            MessageBox(NULL, szTemp, szServiceName, MB_OK);
            hrReturn = E_FAIL;
            goto exit;
        }

        //
        //  We now need to create the value with our szInstallDir string.
        //
        
        dwType = REG_SZ;
        dwSize = lstrlen(szInstallDir);
        if (ERROR_SUCCESS != RegSetValueEx(hKey, c_pszProfileInstallPath, NULL, dwType, 
            (CONST BYTE *)szInstallDir, dwSize))
        {
            CMASSERTMSG(FALSE, TEXT("InstallInf -- Unable to set the Profile Install Path value."));
            MYVERIFY(0 != LoadString(hInstance, IDS_UNEXPECTEDERR, szTemp, CELEMS(szTemp)));
            MessageBox(NULL, szTemp, szServiceName, MB_OK);

            MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
            hrReturn = E_FAIL;
            goto exit;
        }

        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("InstallInf -- Unable to resolve the Install Directory."));
        MYVERIFY(0 != LoadString(hInstance, IDS_UNEXPECTEDERR, szTemp, CELEMS(szTemp)));
        MessageBox(NULL, szTemp, szServiceName, MB_OK);
        hrReturn = E_FAIL;
        goto exit;
    }

    //
    //  Install the Profile Files and create the mappings entry
    //

    if (bInstallForAllUsers)
    {
        hrTemp = LaunchInfSection(szInfFile, TEXT("DefaultInstall"), szTitle, bSilent);
        MYDBGASSERT(SUCCEEDED(hrTemp));
        bMustReboot = ((HRESULT)ERROR_SUCCESS_REBOOT_REQUIRED == hrTemp) ? TRUE: bMustReboot;

        //
        //  Still launch this for Legacy (read MSN online setup reasons, perhaps others)
        //
        hrTemp = LaunchInfSection(szInfFile, TEXT("Xnstall_AllUser"), szTitle, bSilent);
        MYDBGASSERT(SUCCEEDED(hrTemp));
        bMustReboot = ((HRESULT)ERROR_SUCCESS_REBOOT_REQUIRED == hrTemp) ? TRUE: bMustReboot;
    }
    else
    {
        hrTemp = LaunchInfSection(szInfFile, TEXT("DefaultInstall_SingleUser"), szTitle, bSilent);
        MYDBGASSERT(SUCCEEDED(hrTemp));
        bMustReboot = ((HRESULT)ERROR_SUCCESS_REBOOT_REQUIRED == hrTemp) ? TRUE: bMustReboot;

        //
        //  Still launch this for Legacy (I doubt anyone is using this but kept 
        //  for consistency with All User which at least MSN was using)
        //
        hrTemp = LaunchInfSection(szInfFile, TEXT("Xnstall_Private"), szTitle, bSilent);
        MYDBGASSERT(SUCCEEDED(hrTemp));
        bMustReboot = ((HRESULT)ERROR_SUCCESS_REBOOT_REQUIRED == hrTemp) ? TRUE: bMustReboot;

        //
        //  Write the single user mappings key in code since parsing is involved.
        //

        if (!WriteSingleUserProfileMappings(szInstallDir, szShortServiceName, szServiceName))
        {
            CMASSERTMSG(FALSE, TEXT("InstallInf -- WriteSingleUserProfileMappings Failed."));
            MYVERIFY(0 != LoadString(hInstance, IDS_UNEXPECTEDERR, szTemp, CELEMS(szTemp)));
            MessageBox(NULL, szTemp, szServiceName, MB_OK);
            hrReturn = E_FAIL;
            goto exit;            
        }
    }

    //
    //  Install the CM bits as necessary
    //
    if (bInstallCm)
    {
        MYDBGASSERT(FALSE == plat.IsNT51());

        //
        //  First, we must extract the CM binaries from the binaries
        //  executable/cab to the cmbins sub dir.
        //
        wsprintf(szTemp, TEXT("%scmbins\\"), g_szProfileSourceDir);

        hrTemp = ExtractCmBinsFromExe(g_szProfileSourceDir, szTemp);

        if (SUCCEEDED(hrTemp))
        {
            TCHAR szSource [MAX_PATH+1] = {0};
            TCHAR szDest [MAX_PATH+1] = {0};

            if (plat.IsNT5())
            {
                //
                //  Copy cmexcept.cat to the cmbins dir
                //
                MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s%s"), szTemp, TEXT("cmexcept.cat")));
                MYVERIFY(CELEMS(szSource) > (UINT)wsprintf(szSource, TEXT("%s%s"), g_szProfileSourceDir, TEXT("cmexcept.cat")));
        
                MYVERIFY(CopyFile(szSource, szDest, FALSE)); // FALSE == bFailIfExists


                //
                //  Check to see if we need to uninstall a previous CM exception inf
                //  and uninstall it as necessary.
                //
                hrTemp = UninstallExistingCmException();
                MYDBGASSERT((S_OK == hrTemp) || (S_FALSE == hrTemp));

                //
                //  Finally, install the CM bits
                //
                hrTemp = InstallWhistlerCmOnWin2k(szTemp);

                if (FAILED(hrTemp))
                {
                    if (!bSilent)
                    {
                        MYVERIFY(0 != LoadString(hInstance, IDS_WIN2K_CM_INSTALL_FAILED, szTemp, CELEMS(szTemp)));
                        
                        MessageBox(NULL, szTemp, szServiceName, MB_OK | MB_ICONEXCLAMATION);
                    }                
                }
                else
                {
                    //
                    //  Make sure to set permissions on the registry keys to avoid issues with non Admins uninstalling
                    //  the CM binaries.  If user's have permissions to the uninstall registry keys but not to
                    //  files in system32 we can get ourselves in a wierd state.  Fix this by locking down the reg permissions.
                    //
                    hrTemp = SetPermissionsOnWin2kExceptionUninstallRegKeys();
                    MYVERIFY(SUCCEEDED(hrTemp));
                }
            }
            else
            {
                //
                //  Okay, we need to copy the instcm.inf file to the cmbins dir and then
                //  call InstallCm
                //
                LPCTSTR ArrayOfFileNames[] = {
                                                TEXT("cnet16.dll"),
                                                TEXT("ccfg95.dll"),
                                                TEXT("cmutoa.dll"),
                                                TEXT("instcm.inf") // instcm.inf must be last so it is given to InstallCm correctly.
                };

                for (int i = 0; i < (sizeof(ArrayOfFileNames)/sizeof(LPCTSTR)); i++)
                {
                    MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s%s"), szTemp, ArrayOfFileNames[i]));
                    MYVERIFY(CELEMS(szSource) > (UINT)wsprintf(szSource, TEXT("%s%s"), g_szProfileSourceDir, ArrayOfFileNames[i]));
            
                    MYVERIFY(CopyFile(szSource, szDest, FALSE)); // FALSE == bFailIfExists
                }

                hrTemp = InstallCm(hInstance, szDest);
            }

            MYDBGASSERT(SUCCEEDED(hrTemp));
            bMustReboot = ((HRESULT)ERROR_SUCCESS_REBOOT_REQUIRED == hrTemp) ? TRUE: bMustReboot;
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("InstallInf -- ExtractCmBinsFromExe failed!"));
        }
    }

    //
    //  Now Create the Connectoid. Even if it fails, continue to install. 
    //
    if (GetPhoneBookPath(szInstallDir, &pszPhonebook, bInstallForAllUsers))
    {
       BOOL bReturn = WriteCmPhonebookEntry(szServiceName, pszPhonebook, szCmsFile);

       if (!bReturn && plat.IsAtLeastNT5())
       {
           CMASSERTMSG(FALSE, TEXT("CMSTP Failed to create a pbk entry on NT5, exiting."));
           hrReturn = E_FAIL;
           goto exit;      
       }

       if (bInstallForAllUsers && plat.IsAtLeastNT5())
       {        
           MYVERIFY(AllowAccessToWorld(pszPhonebook));
       }
    }
    else if (plat.IsAtLeastNT5())
    {
        CMASSERTMSG(FALSE, TEXT("CMSTP Failed to get a pbk path on NT5, exiting."));
        hrReturn = E_FAIL;
        goto exit;
    }

    //
    //  Now we have all the files installed and the pbk entry written,
    //  finally create the desktop shortcut/GUID
    //
    if ((plat.IsWin9x()) || (plat.IsNT4()))
    {
        //
        //  If we have a Legacy install, then we need to create a desktop icon
        //
        if  (!bNoLegacyIcon)
        {
            hrTemp = LaunchInfSection(szInfFile, TEXT("Xnstall_Legacy"), szTitle, bSilent);
            MYDBGASSERT(SUCCEEDED(hrTemp));
            bMustReboot = ((HRESULT)ERROR_SUCCESS_REBOOT_REQUIRED == hrTemp) ? TRUE: bMustReboot;
        }
    }
    else
    {
        //
        //  Create a desktop shortcut if necessary
        //
        DeleteNT5ShortcutFromPathAndName(hInstance, szServiceName, 
            bInstallForAllUsers ? CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY);

        if (bCreateDesktopIcon)
        {
            HRESULT hr = CreateNT5ProfileShortcut(szServiceName, pszPhonebook, bInstallForAllUsers);
            MYVERIFY(SUCCEEDED(hr));
        }
    }

    //
    //  The profile is now basically installed.  Before doing any post install commands, lets check to see
    //  if the caller asked us to set this connection as the default connection.  If so, then
    //  lets set it here.
    //
    if (bSetAsDefault)
    {
        MYVERIFY(SetThisConnectionAsDefault(szServiceName));
    }

    //
    //  if we have a preshared key, give it to RAS
    //
    if (pszPresharedKey)
    {
        if (plat.IsAtLeastNT51())
        {
            pfnRasSetCredentialsSpec pfnSetCredentials;

            hrReturn = E_FAIL;

            if (FALSE == GetRasApis(NULL, NULL, NULL, NULL, NULL, &pfnSetCredentials))
            {
                CMASSERTMSG(FALSE, TEXT("CMSTP Failed to get RAS API RasSetCredentials, exiting."));
                goto exit;      
            }
        
            if (lstrlen(pszPresharedKey) > PWLEN)
            {
                CMASSERTMSG(FALSE, TEXT("preshared key is larger than RasSetCredentials can handle!"));
                goto exit;      
            }

            RASCREDENTIALS * pRasCreds = NULL;

            pRasCreds = (RASCREDENTIALS *) CmMalloc(sizeof(RASCREDENTIALS));
            if (NULL == pRasCreds)
            {
                hrReturn = E_OUTOFMEMORY;
                goto exit;
            }

            pRasCreds->dwSize = sizeof(RASCREDENTIALS);
            pRasCreds->dwMask = RASCM_PreSharedKey;
            lstrcpyn(pRasCreds->szPassword, pszPresharedKey, lstrlen(pszPresharedKey) + 1);
            
            if (0 != pfnSetCredentials(pszPhonebook, szServiceName, pRasCreds, FALSE))    // FALSE => set the credentials
            {
               CMASSERTMSG(FALSE, TEXT("CMSTP RasSetCredentials failed, exiting."));
               CmFree(pRasCreds);
               goto exit;
            }

            CmFree(pRasCreds);
            hrReturn = S_OK;
        }
        else if ((plat.IsNT4() || plat.IsWin9x()))
        {
           SafeNetLinkageStruct SnLinkage = {0};

            if (IsSafeNetClientAvailable() && LinkToSafeNet(&SnLinkage))
            {
                DATA_BLOB DataBlob = {0};
                DataBlob.cbData = (lstrlen(pszPresharedKey) + 1)*sizeof(TCHAR);
                DataBlob.pbData = (BYTE*)pszPresharedKey;
            
                if (FALSE == SnLinkage.pfnSnPolicySet(SN_L2TPPRESHR, (void*)&DataBlob))
                {
                   CMASSERTMSG(FALSE, TEXT("CMSTP SnPolicySet failed, exiting."));
                    UnLinkFromSafeNet(&SnLinkage);
                   goto exit;            
                }

                //
                //  Now call SnPolicyReload so the SafeNet driver will take the settings changes
                //
                if (FALSE == SnLinkage.pfnSnPolicyReload())
                {
                    //
                    //  Then we need to ask the user to reboot after finishing the install for the changes to take affect.
                    //
                    bMustReboot = TRUE;
                }
            }
            else
            {
                CMTRACE(TEXT("CMSTP tried to set PSK but SafeNet interface unavailable."));
            }

            UnLinkFromSafeNet(&SnLinkage);
        }
     }

    //
    //  Do any postinstall cmds here
    //
    LPTSTR pszPostInstallSection;

    if (bInstallForAllUsers)
    {
        pszPostInstallSection = TEXT("PostInstall");
    }
    else
    {
        pszPostInstallSection = TEXT("PostInstall_Single");
    }

    hrTemp = LaunchInfSection(szInfFile, pszPostInstallSection, szTitle, bSilent);
    MYDBGASSERT(SUCCEEDED(hrTemp));
    bMustReboot = ((HRESULT)ERROR_SUCCESS_REBOOT_REQUIRED == hrTemp) ? TRUE: bMustReboot;

    //
    //  Delete the temporary reg key that we used to communicate the install path to the inf
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(hBaseKey, pszRegInfCommKeyPath, 
                                      0, KEY_ALL_ACCESS, &hKey))
    {
        MYVERIFY(ERROR_SUCCESS == RegDeleteValue(hKey, c_pszProfileInstallPath));
        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("Unable to delete the ProfileInstallPath temporary Reg value."));
    }

    //
    //  Refresh the desktop so that any GUID or shortcut changes will appear
    //
    RefreshDesktop();

    //
    //  For Win98 and Millennium, we write an App Compatibility flag in order to
    //  fix SetForegroundWindow.  Refer also to Q135788 for more details of the
    //  original fix (which requires this extra code on Win9x to actually work).
    //
    //  This fixes Whistler bugs 41696 and 90576.
    //
    if (plat.IsWin98())
    {
        if (!WriteProfileString(TEXT("Compatibility95"), TEXT("CMMON32"), TEXT("0x00000002")))
        {
            CMTRACE(TEXT("InstallInf - failed to write app compat entry for CMMON32 to fix SetForegroundWindow"));
        }
    }

    //
    //  We are finally completed.  If we need to reboot, show the user the reboot prompt.
    //  Otherwise, show the user a completion message.
    //

    if (bMustReboot)
    {
        MYVERIFY(0 != LoadString(hInstance, IDS_REBOOT_MSG, szTemp, CELEMS(szTemp)));

        int iRes = MessageBoxEx(NULL,
                                szTemp,
                                szServiceName,
                                MB_YESNO | MB_DEFBUTTON1 | MB_ICONWARNING | MB_SETFOREGROUND,
                                LANG_USER_DEFAULT);

        if (IDYES == iRes) 
        {
            //
            // Shutdown Windows
            //
            DWORD dwReason = plat.IsAtLeastNT51() ? (SHTDN_REASON_MAJOR_APPLICATION | SHTDN_REASON_MINOR_INSTALLATION) : 0;

            MyExitWindowsEx(EWX_REBOOT, dwReason);
        }
    }
    else if (!bSilent)
    {
        //
        //  Instead of giving the user a message box, we will launch the profile
        //  for them. (NTRAID 201307)
        //

        if (plat.IsAtLeastNT5())
        {
            pCmstpMutex->Unlock();  //NTRAID 310478

        }

        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s.cmp"), 
            szInstallDir, szShortServiceName));

        LaunchProfile(szTemp, szServiceName, pszPhonebook, bInstallForAllUsers);
    }

exit:

    CmFree(pszPresharedKey);
    CmFree(pszPhonebook);
    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmstp\common.h ===
//+----------------------------------------------------------------------------
//
// File:     common.h
//
// Module:   CMSTP.EXE
//
// Synopsis: This header contains common functions used for the different 
//           aspects of the profile installer (install, uninstall, migration).
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header    07/14/98
//
//+----------------------------------------------------------------------------
#ifndef _CMSTP_COMMON_H
#define _CMSTP_COMMON_H

#define _MBCS

//
//  Standard Windows Includes
//
#include <windows.h>
#include <ras.h>
#include <raserror.h>
#include <shlobj.h>
#include <shellapi.h>
#include <wincrypt.h>

//#include <objbase.h>

//
//  Our own includes
//
#include "cmdebug.h"
#include "resource.h"
#include "cmsetup.h"
#include "dynamiclib.h"
#include "cmras.h"
#include "mutex.h"
//#include "pidlutil.h"
//#include "netcon.h"
//#include "netconp.h"
//#include "cfpidl.h"
#include "loadconnfolder.h"

#include "base_str.h"
#include "mgr_str.h"
#include "inf_str.h"
#include "ras_str.h"
#include "stp_str.h"
#include "reg_str.h"
#include "userinfo_str.h"
#include "ver_str.h"
#include "cmsafenet.h"
#include "linkdll.h"
#include "allowaccess.h"
//
//  Type Definitions
//
typedef DWORD (WINAPI *pfnRasSetEntryPropertiesSpec)(LPCTSTR, LPCTSTR, LPRASENTRY, DWORD, LPBYTE, DWORD);
typedef DWORD (WINAPI *pfnRasGetEntryPropertiesSpec)(LPCTSTR, LPCTSTR, LPRASENTRY, LPDWORD, LPBYTE, LPDWORD);
typedef DWORD (WINAPI *pfnRasDeleteEntrySpec)(LPCTSTR, LPCTSTR);
typedef DWORD (WINAPI *pfnRasEnumEntriesSpec)(LPTSTR, LPTSTR, LPRASENTRYNAME, LPDWORD, LPDWORD);
typedef DWORD (WINAPI *pfnRasEnumDevicesSpec)(LPRASDEVINFO, LPDWORD, LPDWORD);
typedef DWORD (WINAPI *pfnRasSetCredentialsSpec)(LPCSTR, LPCSTR, LPRASCREDENTIALSA, BOOL);
typedef DWORD (WINAPI *pfnSHGetFolderPathSpec)(HWND, int, HANDLE, DWORD, LPTSTR);
typedef HRESULT (WINAPI *pfnLaunchConnectionSpec)(const GUID&); 
typedef HRESULT (WINAPI *pfnCreateShortcutSpec)(const GUID&, WCHAR*);
typedef HRESULT (WINAPI *pfnLaunchConnectionExSpec)(DWORD, const GUID&);
typedef DWORD (WINAPI *pfnSHGetSpecialFolderPathWSpec)(HWND, WCHAR*, int, BOOL);

typedef struct _InitDialogStruct
{
    LPTSTR pszTitle;
    BOOL bNoDesktopIcon;
    BOOL bSingleUser;
} InitDialogStruct;

//
//  Constants
//
const TCHAR* const c_pszRegNameSpace = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\explorer\\Desktop\\NameSpace");
const TCHAR* const c_pszRegUninstall = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall");
const TCHAR* const c_pszProfileInstallPath = TEXT("ProfileInstallPath");

const TCHAR* const c_pszRegStickyUiDefault = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\Network Connections");
const TCHAR* const c_pszRegDesktopShortCut = TEXT("DesktopShortcut");
const TCHAR* const c_pszDeletePskOnUninstall = TEXT("DeletePskOnUninstall");

const int ALLUSERS = 0x1;
const int CREATEDESKTOPICON = 0x10;

typedef struct _PresharedKeyPINStruct
{
    TCHAR szPIN[c_dwMaxPresharedKeyPIN + 1];
} PresharedKeyPINStruct;

//
//  Internal Functions (Used by other functions in the file)
//
void DeleteNT5ShortcutFromPathAndNameW(HINSTANCE hInstance, LPCWSTR szwProfileName, int nFolder);
void DeleteNT5ShortcutFromPathAndNameA(HINSTANCE hInstance, LPCSTR szProfileName, int nFolder);

//
//  Functions
//
BOOL RemovePhonebookEntry(LPCTSTR pszEntryName, LPTSTR pszPhonebook, BOOL bMatchSimilarEntries);
BOOL RemoveSpecificPhoneBookEntry(LPCTSTR szLongServiceName, LPTSTR pszPhonebook);
HRESULT CreateNT5ProfileShortcut(LPCTSTR pszProfileName, LPCTSTR pszPhoneBook, BOOL bAllUsers);
BOOL WriteCmPhonebookEntry(LPCTSTR szLongServiceName, LPCTSTR szFullPathtoPBK, LPCTSTR pszCmsFile);
BOOL GetRasModems(LPRASDEVINFO *pprdiRasDevInfo, LPDWORD pdwCnt);
BOOL PickModem(LPTSTR pszDeviceType, LPTSTR pszDeviceName, BOOL fUseVpnDevice);
BOOL IsAdmin(void);
BOOL IsAuthenticatedUser(void);
HRESULT HrIsCMProfilePrivate(LPCTSTR szPhonebook);
HRESULT GetNT5FolderPath(int nFolder, OUT LPTSTR lpszPath);
void RefreshDesktop(void);
BOOL GetAllUsersCmDir(LPTSTR  pszDir, HINSTANCE hInstance);
LPTSTR GetPrivateCmUserDir(LPTSTR  pszDir, HINSTANCE hInstance);
HRESULT HrRegDeleteKeyTree (HKEY hkeyParent, LPCTSTR szRemoveKey);
HRESULT LaunchProfile(LPCTSTR pszFullPathToCmpFile, LPCTSTR pszServiceName, 
                   LPCTSTR pszPhoneBook, BOOL bInstallForAllUsers);
BOOL AllUserProfilesInstalled();
BOOL GetPhoneBookPath(LPCTSTR pszInstallDir, LPTSTR* ppszPhoneBook, BOOL fAllUser);
void RemoveShowIconFromRunPostSetupCommands(LPCTSTR szInfFile);
BOOL GetHiddenPhoneBookPath(LPCTSTR pszProfileDir, LPTSTR* ppszPhonebook);

BOOL GetRasApis(pfnRasDeleteEntrySpec* pRasDeleteEntry, pfnRasEnumEntriesSpec* pRasEnumEntries, 
                pfnRasSetEntryPropertiesSpec* pRasSetEntryProperties, 
                pfnRasEnumDevicesSpec* pRasEnumDevices, pfnRasGetEntryPropertiesSpec* pRasGetEntryProperties,
                pfnRasSetCredentialsSpec* pRasSetCredentials);

BOOL GetShell32Apis(pfnSHGetFolderPathSpec* pGetFolderPath,
                    pfnSHGetSpecialFolderPathWSpec* pGetSpecialFolderPathW);

BOOL GetNetShellApis(pfnLaunchConnectionSpec* pLaunchConnection, 
                     pfnCreateShortcutSpec* pCreateShortcut,
                     pfnLaunchConnectionExSpec* pLaunchConnectionEx);

//
//  Defines
//
#ifdef UNICODE
#define DeleteNT5ShortcutFromPathAndName DeleteNT5ShortcutFromPathAndNameW
#else
#define DeleteNT5ShortcutFromPathAndName DeleteNT5ShortcutFromPathAndNameA
#endif

//
//  Externs -- these are defined in cmstp.cpp and allow us to use EnsureRasDllsLoaded and
//             EnsureShell32Loaded so that we only load the Ras Dll's and Shell32 once per
//             run of the exe.
//
extern CDynamicLibrary* g_pRasApi32;
extern CDynamicLibrary* g_pRnaph;
extern CDynamicLibrary* g_pShell32;
extern CDynamicLibrary* g_pNetShell;


#endif //_CMSTP_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmstp\loadconnfolder.h ===
//+----------------------------------------------------------------------------
//
// File:     loadconnfolder.h
//
// Module:   CMSTP.EXE
//
// Synopsis: This header file contains the CLoadConnFolder Class definition.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header    07/14/98
//
//+----------------------------------------------------------------------------
#ifndef _LOADCONNFOLDER_H_
#define _LOADCONNFOLDER_H_

#include <windows.h>
#include <shlobj.h>
#include <shellapi.h>

class CLoadConnFolder
{

public:
    CLoadConnFolder();
    ~CLoadConnFolder();
    HRESULT HrLaunchConnFolder();

    inline HRESULT GetConnFolder(LPSHELLFOLDER* ppConnectionsFolder)
    {
        if (SUCCEEDED(m_HrClassState))
        {
            *ppConnectionsFolder = m_pConnectionsFolder;
        }

        return m_HrClassState;
    }

    inline LPITEMIDLIST pidlGetConnFolderPidl()
    {
        return m_ConnFolderpidl;
    }


private:    
    LPSHELLFOLDER m_pConnectionsFolder;
    LPSHELLFOLDER m_pDesktopFolder;
    LPITEMIDLIST m_ConnFolderpidl;
    HRESULT m_HrClassState;
    BOOL m_CoInit;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmstp\mutexclass.cpp ===
//+----------------------------------------------------------------------------
//
// File:     mutexclass.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This source file pound includes the mutex class from 
//           common\source\mutex.cpp.  Please see this file for details.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header     08/19/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

#ifndef UNICODE
#define CreateMutexU CreateMutexA
#else
#define CreateMutexU CreateMutexW
#endif

//
//	Please see pnpu\common\source for the actual source here.
//
#include "mutex.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmstp\resource.h ===
//+----------------------------------------------------------------------------
//
// File:     resource.h
//
// Module:   CMSTP.EXE
//
// Synopsis: Resource IDs
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb    Created    06/09/98
//
//+----------------------------------------------------------------------------
#ifndef _CMSTP_RESOURCE_H
#define _CMSTP_RESOURCE_H

#include "allcmdir.h"

#define IDC_STATIC               -1
#define IDC_ALLUSERS                101
#define IDC_YOURSELF                102
#define IDD_ADMINUI                 103
#define IDD_NOCHOICEUI              104
//#define IDC_STARTMENU             105
#define IDC_DESKTOP                 106
#define EXE_ICON                    107

#define IDS_USAGE_MSG               200
#define IDS_SHORTCUT_TO             201
#define IDS_UNINSTALL_PROMPT        202
#define IDS_NO_SUPPORTFILES         207
#define IDS_CM_NOTPRESENT           208
#define IDS_INUSE_MSG               209
#define IDS_CMSTP_TITLE             210
#define IDS_UNEXPECTEDERR           211
//#define IDS_RASPBKPATH              212
#define IDD_PRESHAREDKEY_PIN        213
#define IDC_PSK_PIN                 214
#define IDS_SUCCESS                 215
#define IDS_CM_OLDVERSION           216
//#define   IDS_CMSUBFOLDER           217
#define IDS_INSTCM_WITH_OLD_CMAK    218
#define IDS_BINARY_NOT_ALPHA        219
#define IDS_REBOOT_MSG              220
#define IDS_NEWER_SAMENAME          221
#define IDS_UPGRADE_SAMENAME        222
#define IDS_GET_ADMIN               223
#define IDS_CM_UNINST_PROMPT        224
#define IDS_CM_UNINST_TITLE         225
#define IDS_CM_UNINST_SUCCESS       226
#define IDS_UNINSTCM_BOTH           227
#define IDS_UNINSTCM_WCM            228
#define IDS_UNINSTCM_WCMAK          229
#define IDS_NEEDSERVICEPACK         230
#define IDS_PROFILE_TOO_OLD         231
#define IDS_SAME_SS_DIFF_LS         232
#define IDS_SAME_LS_DIFF_SS         233
#define IDS_INSTALL_NOT_ALLOWED     234
#define IDS_CANNOT_INSTALL_CM       235
#define IDS_WIN2K_CM_INSTALL_FAILED 236
#define IDS_CROSS_LANG_INSTALL      237
#define IDS_PSK_GOTTA_HAVE_IT       238
#define IDS_PSK_INCORRECT_PIN       239
#define IDS_PSK_NEEDS_XP            240
#define IDS_PSK_NEEDS_SAFENET       241

// custom resource, remcmstp.inf, must have an ID greater than 255
#define IDT_REMCMSTP_INF                5000

#endif //_CMSTP_RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmstp\uninstallcm.cpp ===
//+----------------------------------------------------------------------------
//
// File:     uninstallcm.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This source file contains the code for installing Connection Manager.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created     07/14/98
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"
#include "installerfuncs.h"

//+----------------------------------------------------------------------------
//
// Function:  CheckAndPromptForCmakAndProfiles
//
// Synopsis:  This function checks to see if CM profiles are installed or if
//            CMAK 1.21 is installed.  If it is, then uninstalling CM will make
//            the profiles and CMAK unusable and we want to prompt the user
//            to make sure they know what they are doing.
//
// Arguments: HINSTANCE hInstance - Exe instance handle to access resources
//
// Returns:   BOOL - returns TRUE if it is okay to continue with the uninstall
//
// History:   quintinb Created Header    10/21/98
//
//+----------------------------------------------------------------------------
BOOL CheckAndPromptForCmakAndProfiles(HINSTANCE hInstance, LPCTSTR pszTitle)
{
    BOOL bCmakInstalled = FALSE;
    BOOL bCmProfiles = FALSE;
    TCHAR szMsg[2*MAX_PATH+1];

    //
    //  First check to see if CMAK is installed.  If it is and has a version of 1.21 
    //  (build 1886 or newer) then we must prompt the user before uninstalling.
    //  Otherwise, if you uninstall CM out from under it, CMAK will no longer
    //  function.
    //
    DWORD dwFirst121VersionNumber = 0;
    int iShiftAmount = ((sizeof(DWORD)/2) * 8);
    //
    //  Construct the current version and build numbers
    //

    dwFirst121VersionNumber = (HIBYTE(VER_PRODUCTVERSION_W) << iShiftAmount) + (LOBYTE(VER_PRODUCTVERSION_W));
    
    CmakVersion CmakVer;
    
    if (CmakVer.IsPresent()) 
    {
        if ((dwFirst121VersionNumber < CmakVer.GetVersionNumber()) ||
            (c_Cmak121Version < CmakVer.GetBuildNumber()))
        {
            bCmakInstalled = TRUE;
        }
    }

    //
    //  Now check to see if we have CM profiles installed.
    //
    HKEY hKey;
    DWORD dwNumValues;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, 
        KEY_READ, &hKey))
    {
        if ((ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, 
            &dwNumValues, NULL, NULL, NULL, NULL)) && (dwNumValues > 0))
        {
            //
            //  Then we have mappings values, so we need to migrate them.
            //
            bCmProfiles = TRUE;

        }
        RegCloseKey(hKey);
    }

    if (bCmProfiles)
    {
        MYVERIFY(0 != LoadString(hInstance, bCmakInstalled ? IDS_UNINSTCM_BOTH : IDS_UNINSTCM_WCM, szMsg, 2*MAX_PATH));
        MYDBGASSERT(TEXT('\0') != szMsg[0]);
        if (IDNO == MessageBox(NULL, szMsg, pszTitle, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION))
        {
            return FALSE;
        }
    }
    else if (bCmakInstalled)
    {
        //
        //  Just CMAK is installed
        //

        MYVERIFY(0 != LoadString(hInstance, IDS_UNINSTCM_WCMAK, szMsg, 2*MAX_PATH));
        MYDBGASSERT(TEXT('\0') != szMsg[0]);
        if (IDNO == MessageBox(NULL, szMsg, pszTitle, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION))
        {
            return FALSE;
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  PromptUserToUninstallCm
//
// Synopsis:  This function prompts the user to see if they wish to uninstall
//            Connection Manager.  It also deals with the warning prompts if
//            the user has CMAK or CM profiles installed.
//
// Arguments: HINSTANCE hInstance - Instance handle to load resources with.
//
// Returns:   BOOL - Returns TRUE if CM should be uninstalled, FALSE otherwise
//
// History:   quintinb Created    6/28/99
//
//+----------------------------------------------------------------------------
BOOL PromptUserToUninstallCm(HINSTANCE hInstance)
{
    BOOL bReturn = FALSE;
    TCHAR szMsg[MAX_PATH+1] = {TEXT("")};
    TCHAR szTitle[MAX_PATH+1] = {TEXT("")};

    //
    //  Load the Cmstp Title just in case we need to show error messages.
    //
    MYVERIFY(0 != LoadString(hInstance, IDS_CM_UNINST_TITLE, szTitle, MAX_PATH));
    MYDBGASSERT(TEXT('\0') != szTitle[0]);

    //
    //  Now show the uninstall prompt to see if the user wants to uninstall CM
    //
    MYVERIFY(0 != LoadString(hInstance, IDS_CM_UNINST_PROMPT, szMsg, MAX_PATH));
    MYDBGASSERT(TEXT('\0') != szMsg[0]);

    if (IDYES == MessageBox(NULL, szMsg, szTitle, MB_YESNO | MB_DEFBUTTON2))
    {
        //
        //  Check to see if CMAK is installed or if there are profiles that are installed.
        //
        if (CheckAndPromptForCmakAndProfiles(hInstance, szTitle))
        {
            bReturn = TRUE;
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  UninstallCm
//
// Synopsis:  Uninstalls connection manager.
//
// Arguments: HINSTANCE hInstance - instance handle to access resources
//            LPCTSTR szInfPath - path to the instcm.inf file to use to uninstall cm with
//
// Returns:   HRESULT -- Standard COM Error Codes
//
// History:   Created Header    10/21/98
//
//+----------------------------------------------------------------------------
HRESULT UninstallCm(HINSTANCE hInstance, LPCTSTR szInfPath)
{
    MYDBGASSERT((szInfPath) && (TEXT('\0') != szInfPath[0]));

    //
    //  Load the Cmstp Title just in case we need to show error messages.
    //
    TCHAR szTitle[MAX_PATH+1] = {TEXT("")};
    TCHAR szMsg[MAX_PATH+1] = {TEXT("")};

    MYVERIFY(0 != LoadString(hInstance, IDS_CM_UNINST_TITLE, szTitle, MAX_PATH));
    MYDBGASSERT(TEXT('\0') != szTitle[0]);

    //
    //  Protect /x on NT5 and win98 SR1.  We don't want CM uninstalled on Native Platforms.
    //
    HRESULT hr = S_FALSE;
    if (!CmIsNative())
    {
        if (SUCCEEDED(LaunchInfSection(szInfPath, TEXT("1.2Legacy_Uninstall"), szTitle, FALSE)))  // bQuiet = FALSE
        {
            MYVERIFY(0 != LoadString(hInstance, IDS_CM_UNINST_SUCCESS, szMsg, MAX_PATH));
            MYDBGASSERT(TEXT('\0') != szMsg[0]);

            MYVERIFY(IDOK == MessageBox(NULL, szMsg, szTitle, MB_OK));

            hr = S_OK;
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("Connection Manager Uninstall Failed."));
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmstp\migrate.cpp ===
//+----------------------------------------------------------------------------
//
// File:     migrate.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This source file contains most of the code necessary for 
//           the migration of CM profiles.  This code handles both migrating 
//           a user when a CM1.2 profile is installed on a machine with 
//           existing 1.0 profiles and if the user upgrades their OS to NT5.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created     07/14/98
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

//
//  For ProfileNeedsMigration
//
#include "needsmig.cpp"

//+----------------------------------------------------------------------------
//
// Function:  CreateRegAndValue
//
// Synopsis:  This function is a wrapper to Create a Reg Key and then add a defualt 
//            value to that same key.
//
// Arguments: HKEY hBaseKey - Relative starting point for the new subkey
//            LPTSTR szSubKey - SubKey path
//            LPTSTR szValue - String to put in the Keys default value.
//
// Returns:   BOOL - TRUE if the key and value were successfully created
//
// History:   quintinb Created Header    5/5/98
//
//+----------------------------------------------------------------------------
BOOL CreateRegAndValue(HKEY hBaseKey, LPCTSTR szSubKey, LPCTSTR szValue)
{
    DWORD dwDisp;
    BOOL bReturn = FALSE;
    HKEY hKey;


    if (ERROR_SUCCESS == RegCreateKeyEx(hBaseKey, szSubKey, 0, NULL, 
        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisp))
    {
        bReturn = (ERROR_SUCCESS == RegSetValueEx(hKey, NULL, 0, REG_SZ, 
            (BYTE*)szValue, (lstrlen(szValue)+1)));

        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }
    return bReturn;
}

// Note: I added this function because I needed to get the following CFileNameParts
//       off the stack of UpdateProfileLegacyGUIDs so that I didn't need a
//       stack checking function.  Not the greatest workaround but it sufficed.
BOOL IsDefaultIcon(LPCTSTR szIconPath)
{
    BOOL bReturn = TRUE;
    CFileNameParts IconPath(szIconPath);

    DWORD Lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);

    if (CSTR_EQUAL != CompareString(Lcid, NORM_IGNORECASE, IconPath.m_FileName, -1, TEXT("cmmgr32"), -1))
    {
        //
        //  Then the icon path is something else besides cmmgr32.exe, we must not
        //  update it.
        //
        bReturn = FALSE;
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  UpdateProfileLegacyGUIDs
//
// Synopsis:  This function upgrades GUIDs on a Legacy OS install to make sure
//            that older profile still function.  This is necessary because CM
//            1.0/1.1 profiles expected the CM bits to be in the same directory as
//            the cmp file.  Thus only the cmp filename was given.  In CM 1.2 we need
//            the full path to the CMP file since the cm bits are now located in
//            system32.  The GUIDs are also updated to have a delete option and
//            the attributes were changed to not allow renaming.
//
// Arguments: LPTSTR szCmpFile - Full path to the cmp file of the profile to update
//
// Returns:   BOOL - returns TRUE if the profile was successfully updated
//
// History:   quintinb Created Header    5/5/98
//
//+----------------------------------------------------------------------------
BOOL UpdateProfileLegacyGUIDs(LPCTSTR szCmpFile)
{
    TCHAR szInfFile[MAX_PATH+1];
    TCHAR szGUID[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szSubKey[MAX_PATH+1];
    TCHAR szCommandStr[2*MAX_PATH+1];
    BOOL bReturn = TRUE;
    HKEY hKey;
    UINT nNumChars;

    MYDBGASSERT(NULL != szCmpFile);
    MYDBGASSERT(TEXT('\0') != szCmpFile[0]);

    //
    //  Now split the path
    //
    CFileNameParts FileParts(szCmpFile);

    //
    //  Now construct the path to the INF file (1.0 and 1.1 profiles kept the infs in 
    //  the system dir)
    //
    MYVERIFY(0 != GetSystemDirectory(szTemp, MAX_PATH));

    nNumChars = (UINT)wsprintf(szInfFile, TEXT("%s\\%s%s"), szTemp, FileParts.m_FileName, TEXT(".inf"));
    MYDBGASSERT(CELEMS(szInfFile) > nNumChars);

    //
    //  Get the GUID from the inf file.
    //
    ZeroMemory(szGUID, sizeof(szGUID));
    GetPrivateProfileString(c_pszInfSectionStrings, c_pszDesktopGuid, TEXT(""), szGUID, 
        MAX_PATH, szInfFile);

    if (0 != szGUID[0])
    {

        //
        //  Update the DefaultIcon Value if it points to cmmgr32.exe
        //
        BOOL bUpdateIconPath = TRUE;

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\DefaultIcon"), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szSubKey, 0, KEY_READ | KEY_WRITE, &hKey))
        {
            DWORD dwSize = CELEMS(szTemp);
            DWORD dwType = REG_SZ;

            if (ERROR_SUCCESS == RegQueryValueEx(hKey, NULL, NULL, &dwType, (LPBYTE)szTemp, &dwSize))
            {
                bUpdateIconPath = IsDefaultIcon(szTemp);
            }

            RegCloseKey(hKey);
        }

        if (bUpdateIconPath)
        {
            if (GetSystemDirectory(szTemp, CELEMS(szTemp)))
            {
                nNumChars = (UINT)wsprintf(szCommandStr, TEXT("%s\\cmmgr32.exe,0"), szTemp);
                MYDBGASSERT(CELEMS(szCommandStr) > nNumChars);

                bReturn &= CreateRegAndValue(HKEY_CLASSES_ROOT, szSubKey, szCommandStr);
            }
        }

        //
        //  Update Settings to Properties on the desktop icon menu
        //

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\Shell\\Settings..."), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        nNumChars = (UINT)wsprintf(szCommandStr, TEXT("P&roperties"));
        MYDBGASSERT(CELEMS(szCommandStr) > nNumChars);

        bReturn &= CreateRegAndValue(HKEY_CLASSES_ROOT, szSubKey, szCommandStr);

        //
        //  Now change the underlying command to give the full
        //  path to the cmp file.
        //

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\Shell\\Settings...\\Command"), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        nNumChars = (UINT)wsprintf(szCommandStr, TEXT("cmmgr32.exe /settings \"%s\""), szCmpFile);
        MYDBGASSERT(CELEMS(szCommandStr) > nNumChars);

        bReturn &= CreateRegAndValue(HKEY_CLASSES_ROOT, szSubKey, szCommandStr);
        

        //
        //  Update Open to Connect on the desktop icon menu
        //
        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\Shell\\Open"), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        nNumChars = (UINT)wsprintf(szCommandStr, TEXT("C&onnect"));
        MYDBGASSERT(CELEMS(szCommandStr) > nNumChars);

        bReturn &= CreateRegAndValue(HKEY_CLASSES_ROOT, szSubKey, szCommandStr);

        //
        //  Now change the underlying command string to use the full path to the cmp file.
        //

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\Shell\\Open\\Command"), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        nNumChars = (UINT)wsprintf(szCommandStr, TEXT("cmmgr32.exe \"%s\""), szCmpFile);
        MYDBGASSERT(CELEMS(szCommandStr) > nNumChars);

        bReturn &= CreateRegAndValue(HKEY_CLASSES_ROOT, szSubKey, szCommandStr);

        //
        //  Remove the showicon command from the inf. 
        //
//      RemoveShowIconFromRunPostSetupCommands(szInfFile);
        
        //
        //  Add the delete menu option
        //
        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\Shell\\Delete"), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        nNumChars = (UINT)wsprintf(szCommandStr, TEXT("&Delete"));
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        bReturn &= CreateRegAndValue(HKEY_CLASSES_ROOT, szSubKey, szCommandStr);

        //
        //  Create the uninstall command
        //
        lstrcpy(szTemp, TEXT("cmstp.exe /u \""));
        lstrcat(szTemp, szInfFile);
        lstrcat(szTemp, TEXT("\""));

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\Shell\\Delete\\Command"), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        bReturn &= CreateRegAndValue(HKEY_CLASSES_ROOT, szSubKey, szTemp);

        //
        //  Remove the Add/Remove Programs entry, making sure to leave the uninstall dir
        //  value.
        //
        
        nNumChars = (UINT)wsprintf(szSubKey, TEXT("%s\\%s"), c_pszRegUninstall, 
            FileParts.m_FileName);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);
        
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
            szSubKey, 0, KEY_ALL_ACCESS, &hKey))
        {
            RegDeleteValue(hKey, TEXT("UninstallString"));
            RegDeleteValue(hKey, TEXT("DisplayName"));
            RegCloseKey(hKey);
        }

        //
        //  Change the attributes to not allow rename
        //

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\ShellFolder"), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, 
            szSubKey, 0, KEY_ALL_ACCESS, &hKey))
        {
            DWORD dwZero = 0;
            bReturn &= (ERROR_SUCCESS == RegSetValueEx(hKey, TEXT("Attributes"), 
                0, REG_DWORD, (BYTE*)&dwZero, sizeof(DWORD)));  //lint !e514 this is desired behavior

            MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
        }
        else
        {
            bReturn = FALSE;
        }
    }
    else
    {
        bReturn = FALSE;
    }

    return bReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  UpdateProfileDesktopIconsOnNT5
//
// Synopsis:  This function is meant to be called in an upgrade scenario of NT5.
//            Thus if the user has Connection Manager installed on a legacy platform
//            and then upgrades to NT5, this code would be called.  Basically the code
//            removes the users existing Desktop GUID and replaces it with a Desktop
//            icon that is a shortcut to the connection object in the connections folder.
//            This code assumes the new NT5 pbk entry is written and that the connections folder
//            is uptodate.
//
// Arguments: LPTSTR szCmpFilePath - path to the cmp file for the profile
//            LPTSTR szLongServiceName -  Long Service Name of the profile
//
// Returns:   BOOL - TRUE if the profile is successfully updated
//
// History:   quintinb Created Header    5/5/98
//
//+----------------------------------------------------------------------------
BOOL UpdateProfileDesktopIconsOnNT5(HINSTANCE hInstance, LPCTSTR szCmpFilePath, LPCTSTR szLongServiceName)
{

    TCHAR szInfFile[MAX_PATH+1];
    TCHAR szGUID[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szSubKey[MAX_PATH+1];
    BOOL bReturn = TRUE;
    HKEY hKey;
    HRESULT hr;
    UINT nNumChars;

    //
    //  Now split the path
    //

    CFileNameParts FileParts(szCmpFilePath);

    //
    //  Now construct the path to the 1.2 inf file location
    //
    nNumChars = (UINT)wsprintf(szInfFile, TEXT("%s%s%s\\%s%s"), FileParts.m_Drive, 
        FileParts.m_Dir, FileParts.m_FileName, FileParts.m_FileName, TEXT(".inf"));

    MYDBGASSERT(nNumChars < CELEMS(szInfFile));

    if (!FileExists(szInfFile))
    {
        //
        //  Now construct the path to the INF file (1.0 and 1.1 profiles kept the infs in 
        //  the system dir)
        //
        MYVERIFY(0 != GetSystemDirectory(szTemp, MAX_PATH));

        nNumChars = (UINT)wsprintf(szInfFile, TEXT("%s\\%s%s"), szTemp, FileParts.m_FileName, TEXT(".inf"));
        MYDBGASSERT(nNumChars < CELEMS(szInfFile));

        if (!FileExists(szInfFile))
        {
            return FALSE;
        }
//else
//{
            //
            //  Remove ShowIcon from the Inf File so that the user won't get an error if they
            //  try to uninstall it.
            //
//  RemoveShowIconFromRunPostSetupCommands(szInfFile);      
//}
    }

    //
    //  Get the GUID from the inf file.
    //
    ZeroMemory(szGUID, sizeof(szGUID));
    MYVERIFY(0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszDesktopGuid, TEXT(""), szGUID, 
        MAX_PATH, szInfFile));

    if (0 != szGUID[0])
    {
        //
        //  Delete the Explorer\Desktop entry
        //

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("%s\\%s"), c_pszRegNameSpace, szGUID);
        if (CELEMS(szSubKey) > nNumChars)
        {
            hr = HrRegDeleteKeyTree (HKEY_LOCAL_MACHINE, szSubKey);
            bReturn &= SUCCEEDED(hr);   //lint !e514 intended use, quintinb
        }

        //
        //  Delete the GUID
        //

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s"), szGUID);
        if (CELEMS(szSubKey) > nNumChars)
        {
            hr = HrRegDeleteKeyTree (HKEY_CLASSES_ROOT, szSubKey);
            bReturn &= SUCCEEDED(hr);//lint !e514 intended use, quintinb
        }

        //
        //  Delete the uninstall strings
        //

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("%s\\%s"), c_pszRegUninstall, FileParts.m_FileName);

        if (CELEMS(szSubKey) > nNumChars)
        {
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                szSubKey, 0, KEY_ALL_ACCESS, &hKey))
            {
                //
                //  Leave the UninstallDir value but delete the other two.  We still use
                //  UninstallDir to know where to uninstall from.
                //

                bReturn &= (ERROR_SUCCESS == RegDeleteValue(hKey, 
                    TEXT("DisplayName")));    //lint !e514 intended use, quintinb
                bReturn &= (ERROR_SUCCESS ==RegDeleteValue(hKey, 
                    TEXT("UninstallString"))); //lint !e514 intended use, quintinb

                (VOID)RegCloseKey(hKey);
                hKey = NULL;
            }
        }

        //
        //  Construct the InstallDir path to get the phonebook path to 
        //  pass to CreateShortcut
        //
        szTemp[0] = TEXT('\0');

        if (GetAllUsersCmDir(szTemp, hInstance))
        {
            LPTSTR pszPhoneBook = NULL;

            //
            //  Assuming that legacy platform was All-Users thus we use TRUE
            //
            if (GetPhoneBookPath(szTemp, &pszPhoneBook, TRUE))
            {
                //
                //  Create a desktop shortcut
                //
                DeleteNT5ShortcutFromPathAndName(hInstance, szLongServiceName, CSIDL_COMMON_DESKTOPDIRECTORY);

                hr = CreateNT5ProfileShortcut(szLongServiceName, pszPhoneBook, TRUE); // bAllUsers == TRUE
                bReturn &= SUCCEEDED(hr);   //lint !e514 intended use, quintinb        
            }
            CmFree(pszPhoneBook);
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RemoveOldCmInstalls
//
// Synopsis:  This function tries to remove old Connection Manager installs by
//            using the instcm.inf file.
//
// Arguments: LPTSTR szCmpFile - Path to a cmp file (gives the directory of 
//                               the CM install to delete)
//
// Returns:   BOOL - returns TRUE if instcm.inf was successfully launched or
//                   if the cmp was in winsys, in which case we don't want to 
//                   launch.
//
// History:   quintinb Created Header    5/5/98
//
//+----------------------------------------------------------------------------
BOOL RemoveOldCmInstalls(HINSTANCE hInstance, LPCTSTR szCmpFile, LPCTSTR szCurrentDir)
{
    TCHAR szDest[MAX_PATH+1];
    TCHAR szSource[MAX_PATH+1];
    TCHAR szCmDir[MAX_PATH+1];
    TCHAR szSystemDir[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    UINT nNumChars;
    BOOL bReturn = FALSE;
    HKEY hKey;

    //
    //  Check the input
    //
    if ((szCmpFile == NULL) || (TEXT('\0') == szCmpFile[0]))
    {
        return FALSE;
    }

    //
    //  Next make a copy of instcm.inf
    //

    const TCHAR* const c_pszInstCmInfFmt = TEXT("%sinstcm.inf");
    const TCHAR* const c_pszRemoveCmInfFmt = TEXT("%sremovecm.inf");

    if (0 == GetSystemDirectory(szSystemDir, MAX_PATH))
    {
        return FALSE;
    }

    lstrcat(szSystemDir, TEXT("\\"));

    nNumChars = (UINT)wsprintf(szSource, c_pszInstCmInfFmt, szSystemDir);
    MYDBGASSERT(CELEMS(szSource) > nNumChars);

    nNumChars = (UINT)wsprintf(szDest, c_pszRemoveCmInfFmt, szSystemDir);
    MYDBGASSERT(CELEMS(szDest) > nNumChars);

    if (!FileExists(szSource))
    {
        //
        //  We probably haven't installed instcm.inf yet, check in the current dir.
        //

        nNumChars = (UINT)wsprintf(szSource, c_pszInstCmInfFmt, szCurrentDir);
        MYDBGASSERT(CELEMS(szSource) > nNumChars);

        nNumChars = (UINT)wsprintf(szDest, c_pszRemoveCmInfFmt, szCurrentDir);
        MYDBGASSERT(CELEMS(szDest) > nNumChars);
    }

    if (CopyFile(szSource, szDest, FALSE))
    {
        //
        //  Now construct the directory that the old cm bits could be in.
        //

        CFileNameParts FileParts(szCmpFile);

        nNumChars = (UINT)wsprintf(szCmDir, TEXT("%s%s"), FileParts.m_Drive, FileParts.m_Dir);
        MYDBGASSERT(CELEMS(szCmDir) > nNumChars);
        
        //
        //  Make sure that we are not uninstalling CM from system32 (the new 1.2 location)
        //

        if (0 == lstrcmpi(szSystemDir, szCmDir))
        {
            //
            //  Then the cmp file is in winsys, so don't remove the new cm bits
            //
            return TRUE;
        }

        //  Next put the path to the CM bits in the OldPath Value of the CMMGR32.EXE
        //  App Paths Key

        lstrcpyn(szTemp, c_pszRegCmAppPaths, CELEMS(szTemp));

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
            szTemp, 0, KEY_ALL_ACCESS, &hKey))
        {
            if (ERROR_SUCCESS == RegSetValueEx(hKey, TEXT("OldPath"), 0, REG_SZ, 
                (BYTE*)szCmDir, (lstrlen(szCmDir) + sizeof(TCHAR)))) // must include size of NULL char
            {
                //
                //  Finally launch the inf file to uninstall CM
                // 
                
                TCHAR szTitle[MAX_PATH+1] = {TEXT("")};
                MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, MAX_PATH));
                MYDBGASSERT(TEXT('\0') != szTitle[0]);

                MYVERIFY(SUCCEEDED(LaunchInfSection(szDest, TEXT("Remove"), szTitle, TRUE)));  // bQuiet = TRUE
                
                RegDeleteValue(hKey, TEXT("OldPath")); //lint !e534 if CM app path is removed so is this
                
                bReturn = TRUE;
            }

            MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  MigratePhonebookEntry
//
// Synopsis:  This function migrates an old phonebook entry to the new 
//
// Arguments: HINSTANCE hInstance - Module instance handle so that resources can be accessed
//            LPCTSTR pszCmpFile - full path to the cmp file
//            LPCTSTR pszLongServiceName - Long service name of the profile
//
// Returns:   BOOL - returns TRUE on success
//
// History:   quintinb Created for NTRAID 227444    9/30/98
//            quintinb modified to delete from ras\rasphone.pbk 
//                     as well on NT5 (NTRAID 280738)           2/1/99
//
//+----------------------------------------------------------------------------
BOOL MigratePhonebookEntry(HINSTANCE hInstance, LPCTSTR pszCmpFile, LPCTSTR pszLongServiceName)
{
    TCHAR szCmsFile[MAX_PATH+1]={0};
    TCHAR szInstallDir[MAX_PATH+1]={0};
    TCHAR szTemp[MAX_PATH+1]={0};
    LPTSTR pszPhonebook = NULL;
    CPlatform plat;

    //
    //  First try to delete the phonebook entry from the old phonebook location,
    //  namely %windir%\system32\ras\rasphone.pbk
    //
    if (plat.IsAtLeastNT5() && GetSystemDirectory(szTemp, CELEMS(szTemp)))
    {
        pszPhonebook = (LPTSTR)CmMalloc(1 + lstrlen(c_pszRasDirRas) + 
                                            lstrlen(c_pszRasPhonePbk) + 
                                            lstrlen (szTemp));
        if (NULL != pszPhonebook)
        {
            wsprintf(pszPhonebook, TEXT("%s%s%s"), szTemp, c_pszRasDirRas, c_pszRasPhonePbk);
        
            CMTRACE2(TEXT("MigratePhonebookEntry -- Calling RemovePhonebookEntry on %s in phone book %s"), pszLongServiceName, MYDBGSTR(pszPhonebook));

            RemovePhonebookEntry(pszLongServiceName, pszPhonebook, TRUE);

            CmFree(pszPhonebook);
        }
    }

    //
    //  Next try to delete the phonebook entry from the new location, namely
    //  C:\Documents and Settings\All Users\Application Data\Microsoft\Network\Connections\PBK\rasphone.pbk
    //
    if (!GetAllUsersCmDir(szInstallDir, hInstance))
    {
        return FALSE;
    }

    //
    //  Construct the cms file
    //
    CFileNameParts  CmpFileParts(pszCmpFile);

    MYVERIFY(CELEMS(szCmsFile) > (UINT)wsprintf(szCmsFile, TEXT("%s%s\\%s.cms"), 
        szInstallDir, CmpFileParts.m_FileName, CmpFileParts.m_FileName));

    //
    //  Get the new phonebook path.
    //  Assuming that legacy platform was All-Users thus we use TRUE
    //
    if (!GetPhoneBookPath(szInstallDir, &pszPhonebook, TRUE))
    {
        return FALSE;
    }

    CMTRACE2(TEXT("MigratePhonebookEntry -- Calling RemovePhonebookEntry on %s in phone book %s"), pszLongServiceName, MYDBGSTR(pszPhonebook));

    MYVERIFY(FALSE != RemovePhonebookEntry(pszLongServiceName, pszPhonebook, TRUE));

    //
    //  Finally write the new pbk entry.
    //
    BOOL bReturn = WriteCmPhonebookEntry(pszLongServiceName, pszPhonebook, szCmsFile);

    CmFree(pszPhonebook);

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  MigrateOldCmProfileForProfileInstall
//
// Synopsis:  This function is used to migrate Old cm profiles when a 1.2 profile
//            is installed.  This ensures that old profiles will still work but
//            that already migrated profiles won't be migrated over and over again.
//            This function should only be called when a 1.2 profile is installed
//            and not on OS migration, call MigrateCmProfilesForWin2kUpgrade for
//            that.  Migration of the profile consists of deleting the old connectoids
//            and creating new style connectoids.  Ensuring that the desktop guid
//            is up to date or is replaced by a shortcut on NT5.  It also removes
//            old installs of CM as neccessary.
//
// Arguments: HINSTANCE hInstance - Instance handle to load resources as necessary
//
// Returns:   HRESULT -- Standard COM Error Codes
//
// History:   quintinb Created    11/18/98
//
//+----------------------------------------------------------------------------
HRESULT MigrateOldCmProfilesForProfileInstall(HINSTANCE hInstance, LPCTSTR szCurrentDir)
{
    HKEY hKey;
    DWORD dwValueSize;
    DWORD dwType;
    DWORD dwDataSize;
    TCHAR szCurrentValue[MAX_PATH+1];
    TCHAR szCurrentData[MAX_PATH+1];
    BOOL bReturn = TRUE;
    CPlatform plat;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, KEY_ALL_ACCESS, &hKey))
    {
        DWORD dwIndex = 0;
        dwValueSize = MAX_PATH;
        dwDataSize = MAX_PATH;
                
        while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szCurrentValue, &dwValueSize, NULL, &dwType, 
               (LPBYTE)szCurrentData, &dwDataSize))
        {
            if (REG_SZ == dwType)
            {
                MYDBGASSERT(0 != szCurrentValue[0]);
                MYDBGASSERT(0 != szCurrentData[0]);

                if (ProfileNeedsMigration(szCurrentValue, szCurrentData))
                {
                    //
                    //  Update the phonebook entries
                    //
                    bReturn &= MigratePhonebookEntry(hInstance, szCurrentData, szCurrentValue);

                    if (plat.IsAtLeastNT5())
                    {
                        //
                        //  when we are moving a machine to NT5 we need to remove the profiles
                        //  old pbk entries and create new ones.  Then we need to remove the 
                        //  profile GUIDS and replace them with desktop shortcuts.
                        //

                        bReturn &= UpdateProfileDesktopIconsOnNT5(hInstance, szCurrentData, 
                            szCurrentValue);
                    }
                    else
                    {
                        //
                        //  Fix up the users desktop GUIDs so they work with the new
                        //  command line format.
                        //
                        bReturn &= UpdateProfileLegacyGUIDs(szCurrentData);
                    }
                
                    //
                    //  Always try to remove old CM installs
                    //
                    bReturn &= RemoveOldCmInstalls(hInstance, szCurrentData, szCurrentDir);                
                }
            }
            dwValueSize = MAX_PATH;
            dwDataSize = MAX_PATH;
            dwIndex++;
        }
        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }
    else
    {
       CMTRACE(TEXT("No CM mappings key to migrate."));
    }

    RefreshDesktop();

    return (bReturn ? S_OK : E_FAIL);
}

//+----------------------------------------------------------------------------
//
// Function:  MigrateCmProfilesForWin2kUpgrade
//
// Synopsis: 
//  
//  This function opens the HKLM Mappings key and enumerates all the profiles that are 
//  listed there.  This function is used when a legacy machine is upgraded to Win2K and
//  CM is installed.  In this case we have 1.0/1.1/1.2 profiles that need to be migrated to use
//  the NT5 connections folder.  Thus they need to have their connectoids upgraded to the new
//  NT 5 style and they need to have their Desktop Guids replaced by shortcuts to the connections
//  folder.  We should always attempt to remove any old installations of connection manager 
//  that are discovered in the old cmp directories.
//
// Arguments: hInstance - Instance handle for string resources
//
// Returns:   HRESULT -- Standard COM Error codes
//
// History:   quintinb created  5/2/98
//
//+----------------------------------------------------------------------------
HRESULT MigrateCmProfilesForWin2kUpgrade(HINSTANCE hInstance)
{
    HKEY hKey;
    DWORD dwValueSize;
    DWORD dwType;
    DWORD dwDataSize;
    TCHAR szCurrentDir[MAX_PATH+1];
    TCHAR szCurrentValue[MAX_PATH+1];
    TCHAR szCurrentData[MAX_PATH+1];

    CPlatform plat;
    if (0 == GetCurrentDirectory(MAX_PATH, szCurrentDir))
    {
        return E_FAIL;
    }
    lstrcat(szCurrentDir, TEXT("\\"));

    if (!(plat.IsAtLeastNT5()))
    {
        CMASSERTMSG(FALSE, TEXT("MigrateCmProfilesForWin2kUpgrade - This function is supposed to be NT5 only"));
        return E_FAIL;
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, KEY_ALL_ACCESS, &hKey))
    {
        DWORD dwIndex = 0;
        dwValueSize = MAX_PATH;
        dwDataSize = MAX_PATH;
                
        while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szCurrentValue, &dwValueSize, NULL, &dwType, 
               (LPBYTE)szCurrentData, &dwDataSize))
        {
            if (REG_SZ == dwType)
            {
                MYDBGASSERT(0 != szCurrentValue[0]);
                MYDBGASSERT(0 != szCurrentData[0]);

                //
                //  Update the phonebook entries
                //
                BOOL bReturn = MigratePhonebookEntry(hInstance, szCurrentData, szCurrentValue);

                if (!bReturn)
                {
                    CMTRACE2(TEXT("MigrateCmProfilesForWin2kUpgrade -- MigratePhonebookEntry for profile %s failed.  Cmp path is %s"), szCurrentValue, szCurrentData);
                }

                //
                //  when we are moving a machine to NT5 we need to remove the profiles
                //  old pbk entries and create new ones.  Then we need to remove the 
                //  profile GUIDS and replace them with desktop shortcuts.
                //

                bReturn = UpdateProfileDesktopIconsOnNT5(hInstance, szCurrentData, szCurrentValue);

                if (!bReturn)
                {
                    CMTRACE2(TEXT("MigrateCmProfilesForWin2kUpgrade -- UpdateProfileDesktopIconsOnNT5 for profile %s failed.  Cmp path is %s"), szCurrentValue, szCurrentData);
                }

                
                //
                //  Always try to remove old CM installs
                //

                bReturn = RemoveOldCmInstalls(hInstance, szCurrentData, szCurrentDir);

                if (!bReturn)
                {
                    CMTRACE2(TEXT("MigrateCmProfilesForWin2kUpgrade -- RemoveOldCmInstalls for profile %s failed.  Cmp path is %s"), szCurrentValue, szCurrentData);
                }
            }
            dwValueSize = MAX_PATH;
            dwDataSize = MAX_PATH;
            dwIndex++;
        }
        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }
    else
    {
       CMTRACE(TEXT("No CM mappings key to migrate."));
    }

    RefreshDesktop();

    static const TCHAR c_ValueString[] = TEXT("Connection Manager Profiles Upgrade");

    LONG lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"),
                           0,
                           KEY_SET_VALUE,
                           &hKey);

    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    if (SUCCEEDED(hr))
    {
        RegDeleteValue(hKey, c_ValueString); //lint !e534 this value may not exist
        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }        

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmstp\uninstall.cpp ===
//+----------------------------------------------------------------------------
//
// File:     uninstall.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This source file contains most of the code to uninstall CM profiles.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created     07/14/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

const TCHAR* const c_pszCmPath = TEXT("%s\\SOFTWARE\\Microsoft\\Connection Manager");
const TCHAR* const c_pszUserInfoPath = TEXT("%s\\SOFTWARE\\Microsoft\\Connection Manager\\UserInfo");
const TCHAR* const c_pszProfileUserInfoPath = TEXT("%s\\SOFTWARE\\Microsoft\\Connection Manager\\UserInfo\\%s");

//+----------------------------------------------------------------------------
//
// Function:  PromptUserToUninstallProfile
//
// Synopsis:  This function prompts the user to see if they wish to uninstall
//            the given profile.
//
// Arguments: HINSTANCE hInstance - Instance Handle to get resources with
//            LPCTSTR pszInfFile - full path to the profile inf file
//
// Returns:   int - Return Value of the MessageBox prompt, IDNO signifies an
//                  error or that the user didn't want to continue.  IDYES
//                  signifies that the install should continue.
//
// History:   quintinb Created     6/28/99
//
//+----------------------------------------------------------------------------
BOOL PromptUserToUninstallProfile(HINSTANCE hInstance, LPCTSTR pszInfFile)
{

    BOOL bReturn = FALSE;

    //
    //  On Legacy Platforms we need to prompt to see if the user wants to uninstall.
    //  On NT5 this is taken care of by the connections folder.  We also use no prompt
    //  when uninstalling the old profile for a same name upgrade.
    //
    TCHAR szServiceName[MAX_PATH+1];
    TCHAR szMessage[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szTitle[MAX_PATH+1] = {TEXT("")};

    MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, MAX_PATH));
    MYDBGASSERT(TEXT('\0') != szTitle[0]);
    
    MYVERIFY(0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszCmEntryServiceName, 
        TEXT(""), szServiceName, MAX_PATH, pszInfFile));

    if(TEXT('\0') != szServiceName[0])
    {
        MYVERIFY(0 != LoadString(hInstance, IDS_UNINSTALL_PROMPT, szTemp, MAX_PATH));
        MYDBGASSERT(TEXT('\0') != szTemp[0]);

        MYVERIFY(CELEMS(szMessage) > (UINT)wsprintf(szMessage, szTemp, szServiceName));

        bReturn = (IDYES == MessageBox(NULL, szMessage, szTitle, MB_YESNO | MB_DEFBUTTON2));
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("PromptUserToUninstallProfile: Failed to retrieve ServiceName from INF"));            
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  BuildUninstallDirKey
//
// Synopsis:  Utility function to expand any environment strings in the passed
//            in Mappings Data value and then parse that path into the Install
//            dir value (basically remove the \<short service name>.cmp from
//            the full path to the cmp)
//
// Arguments: LPCTSTR pszMappingsData - Raw data from the mappings key, may 
//                                      contain environment strings.
//            LPTSTR szInstallDir - Out buffer for the install dir
//
// Returns:   Nothing
//
// History:   quintinb Created Header    6/28/99
//
//+----------------------------------------------------------------------------
void BuildUninstallDirKey(LPCTSTR pszMappingsData, LPTSTR szInstallDir)
{
    TCHAR szCmp[MAX_PATH+1];
    ExpandEnvironmentStrings(pszMappingsData, szCmp, CELEMS(szCmp));

    CFileNameParts CmpParts(szCmp);

    wsprintf(szInstallDir, TEXT("%s%s"), CmpParts.m_Drive, CmpParts.m_Dir);

    if (TEXT('\\') == szInstallDir[lstrlen(szInstallDir) - 1])
    {
        szInstallDir[lstrlen(szInstallDir) - 1] = TEXT('\0');
    }
}

//+----------------------------------------------------------------------------
//
// Function:  DeleteSafeNetPskOnUninstall
//
// Synopsis:  Determines if a PSK was written to the PSK store on profile
//            install and then deletes it.
//
// Arguments: 
//
// Returns:   Nothing
//
// History:   quintinb  Created    09/16/01
//
//+----------------------------------------------------------------------------
void DeleteSafeNetPskOnUninstall(LPCTSTR pszCmpFile)
{
    if (pszCmpFile && pszCmpFile[0])
    {
        //
        //  First check the CMP file to see if we wrote the key to remind ourselves
        //  to delete the Psk on uninstall...
        //
        if ((BOOL)GetPrivateProfileInt(c_pszCmSection, c_pszDeletePskOnUninstall, 0, pszCmpFile))
        {
            //
            //  Okay if we have the key then delete the PSK
            //

           SafeNetLinkageStruct SnLinkage = {0};

            if (IsSafeNetClientAvailable() && LinkToSafeNet(&SnLinkage))
            {
                const TCHAR* const c_pszDeletedPsk = TEXT("****************"); // unfortunately we cannot clear the PSK so this is the best we can do
                DATA_BLOB DataBlob = {0};
                DataBlob.cbData = (lstrlen(c_pszDeletedPsk) + 1)*sizeof(TCHAR);
                DataBlob.pbData = (BYTE*)c_pszDeletedPsk;
            
                if (SnLinkage.pfnSnPolicySet(SN_L2TPPRESHR, (void*)&DataBlob))
                {
                   (void)SnLinkage.pfnSnPolicyReload();
                }
            }

            UnLinkFromSafeNet(&SnLinkage);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  UninstallProfile
//
// Synopsis:  This function uninstalls a CM profile.
//
// Arguments: HINSTANCE hInstance - Instance handle for resources
//            LPCTSTR szInfPath - full path of the INF to uninstall
//            BOOL bCleanUpCreds -- whether credential info in the registry 
//                                  should be cleaned up or not
//
// Returns:   HRESULT -- Standard COM Error Codes
//
// History:   Created Header    7/14/98
//
//+----------------------------------------------------------------------------
HRESULT UninstallProfile(HINSTANCE hInstance, LPCTSTR szInfFile, BOOL bCleanUpCreds)
{
    TCHAR* pszPhonebook = NULL;
    TCHAR szSectionName[MAX_PATH+1];
    TCHAR szCmsFile[MAX_PATH+1];
    TCHAR szCmpFile[MAX_PATH+1];
    TCHAR szProfileDir[MAX_PATH+1];
    TCHAR szInstallDir[MAX_PATH+1];
    TCHAR szShortServiceName[MAX_PATH+1];
    TCHAR szPhonebookPath[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
	TCHAR szLongServiceName[MAX_PATH+1];

    CPlatform plat;
    HANDLE hFile;
    BOOL bReturn = FALSE;
	BOOL bAllUserUninstall;
    HKEY hBaseKey;
    HKEY hKey;
    int nDesktopFolder;
    int iCmsVersion;
    HRESULT  hr;

    const TCHAR* const c_pszRegGuidMappings = TEXT("SOFTWARE\\Microsoft\\Connection Manager\\Guid Mappings");

    ZeroMemory(szCmsFile, sizeof(szCmsFile));
    ZeroMemory(szLongServiceName, sizeof(szLongServiceName));
    ZeroMemory(szProfileDir, sizeof(szProfileDir));
    ZeroMemory(szPhonebookPath, sizeof(szPhonebookPath));
    
    //
    //  Load the title in case IExpress needs to show error dialogs
    //

    TCHAR szTitle[MAX_PATH+1] = {TEXT("")};
    MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, MAX_PATH));
    MYDBGASSERT(TEXT('\0') != szTitle[0]);
    
    //
 	//	Get the Long Service Name
 	//
    if (0 == GetPrivateProfileString(c_pszInfSectionStrings, c_pszCmEntryServiceName, 
		                             TEXT(""), szLongServiceName, MAX_PATH, szInfFile))
    {
        CMASSERTMSG(FALSE, TEXT("UninstallProfile -- Unable to get Long Service Name.  This situation will occur normally when cmstp.exe /u is called by hand on NT5."));
        return E_FAIL;
    }

    //
    //  Determine if we are a private user profile or not
    //
    hr = HrIsCMProfilePrivate(szInfFile);

    if (FAILED(hr))
    {
        CMASSERTMSG(FALSE, TEXT("UninstallProfile: HrIsCMProfilePrivate failed"));
        goto exit;
    }
    else if (S_OK == hr)
    {
        //
        //  Then we have a Private Profile, send Remove_Private as the uninstall command
        //
        lstrcpy(szSectionName, TEXT("Remove_Private"));

        //
        //  All Registry access should be to the HKCU key
        //
        hBaseKey = HKEY_CURRENT_USER;
        
        //
        //  Set these just in case we are on NT5 and will need them to remove the
        //  Desktop and Start Menu shortcuts.
        //
        nDesktopFolder = CSIDL_DESKTOPDIRECTORY;

		//
		//	We use this to determine if we need a phonebook path or if NULL will work
		//
		bAllUserUninstall = FALSE;

    }
    else
    {
        //
        //  Then we have an All User profile, so send Remove as the uninstall command
        //
        lstrcpy(szSectionName, TEXT("Remove"));

        //
        //  All Registry settings will be under HKLM
        //
        hBaseKey = HKEY_LOCAL_MACHINE;

        //
        //  Set these just in case we are on NT5 and will need them to remove the
        //  Desktop shortcut.
        //
        nDesktopFolder = CSIDL_COMMON_DESKTOPDIRECTORY;

		//
		//	We use this to determine if we need a phonebook path or if NULL will work
		//
		bAllUserUninstall = TRUE;
    }

    //
    //  Get the Short Service Name from the INF and use it to build the UninstallDir in the
    //  registry.
    //
    MYVERIFY(0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszShortSvcName, 
        TEXT(""), szShortServiceName, MAX_PATH, szInfFile));

    if (0 != szShortServiceName[0])
    {
        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, 
            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\%s"), 
            szShortServiceName));

        DWORD dwDisposition = 0;

        LONG lResult = RegCreateKeyEx(hBaseKey, szTemp, 0, NULL, REG_OPTION_NON_VOLATILE, 
                                      KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisposition);
        if (ERROR_SUCCESS == lResult)
        {
            const TCHAR* const c_pszUninstallDir = TEXT("UninstallDir");
            DWORD dwType = REG_SZ;
            DWORD dwSize;

            //
            //  If this value doesn't exist then the inf will fail, so we need to create it from the
            //  cmp path value.  We used to write it on install, but since we were always expanding
            //  it and rewriting it anyway (because of single user profiles), it is just easier 
            //  to ignore the existing value and create it from scratch.
            //
            HKEY hMappingsKey;

            lResult = RegOpenKeyEx(hBaseKey, c_pszRegCmMappings, 0, KEY_READ, &hMappingsKey);

            if (ERROR_SUCCESS == lResult)
            {
                dwSize = CELEMS(szCmpFile);

                lResult = RegQueryValueEx(hMappingsKey, szLongServiceName, NULL, 
                                          NULL, (LPBYTE)szCmpFile, &dwSize);

                if (ERROR_SUCCESS == lResult)
                {
                    //
                    //  Now build the UninstallDir key
                    //
                    BuildUninstallDirKey(szCmpFile, szInstallDir);
                }
                else
                {
                    MYVERIFY(ERROR_SUCCESS == RegCloseKey(hMappingsKey));
                    MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
                    CMASSERTMSG(FALSE, TEXT("UninstallProfile: Unable  to find the Profile Entry in Mappings!"));
                    goto exit;                    
                }

                RegCloseKey(hMappingsKey);
            }
            else
            {
                MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
                CMASSERTMSG(FALSE, TEXT("UninstallProfile: Unable to open the Mappings key!"));
                goto exit;
            }

            //
            //  We need to write the UninstallDir key to the registry now that we
            //  have created it.  We do this because the inf processing code in advpack
            //  doesn't understand environment strings and single user strings contain
            //  the %userprofile% variable, thus we were always rewriting it anyway.
            //  Note we only write this on install of All User profiles and only because
            //  we cannot update the bits on win98 OSR1 and on IEAK5 machines (with CMAK).
            //  Otherwise we don't write this at setup time anymore.
            //
            dwSize = lstrlen(szInstallDir) + 1;
            if (ERROR_SUCCESS != RegSetValueEx(hKey, c_pszUninstallDir, NULL, dwType, 
                (CONST BYTE *)szInstallDir, dwSize))
            {
                CMASSERTMSG(FALSE, TEXT("UninstallProfile: Unable to set the UninstallDir key!"));
                goto exit;
            }

            //
            //  szInstallDir currently contains the directory above the profile directory, add
            //  the shortservice name on the end
            //
            UINT uCount = (UINT)wsprintf(szProfileDir, TEXT("%s\\%s"), szInstallDir, szShortServiceName);
            MYDBGASSERT(uCount <= CELEMS(szProfileDir));
            MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));

        }
        else
        {
            //
            //  If this key doesn't exist then the inf will fail, so exit.
            //
            CMASSERTMSG(FALSE, TEXT("UninstallProfile: Unable to open profile uninstall key."));
            goto exit;
        }
    }
    else
    {
        //
        //  We shouldn't have a problem getting the short service name from a profile.
        //  something is definitely wrong here.
        //
        CMASSERTMSG(FALSE, TEXT("UninstallProfile: Unable to retrieve the ShortServiceName"));
        goto exit;
    }

    //
    //  Let's check to see if we should delete the user's pre-shared key from
    //  the SafeNet PSK store.  If so, we stored a reminder flag in the CMP file
    //  at install time.
    //
    if (plat.IsWin9x() || plat.IsNT4())
    {
        DeleteSafeNetPskOnUninstall(szCmpFile);
    }

    //
    //  Create the path to the cms file
    //

    MYVERIFY(CELEMS(szCmsFile) > (UINT)wsprintf(szCmsFile, TEXT("%s\\%s.cms"), szProfileDir, 
        szShortServiceName));
    
    //
    //  Remove the phonebook entry
    //

    if (TEXT('\0') != szLongServiceName[0])
    {
        if (plat.IsAtLeastNT5())
        {
            //
            //  On NT5 we want to delete the hidden phonebook entry for
            //  double dial profiles.
            //

            if (GetHiddenPhoneBookPath(szInstallDir , &pszPhonebook))
            {
                MYVERIFY(FALSE != RemovePhonebookEntry(szLongServiceName, pszPhonebook, !(plat.IsAtLeastNT5())));
		        CmFree(pszPhonebook);
            }

            if (bAllUserUninstall)
            {
                //
                //  On NT5 legacy profiles could be installed anywhere and the
                //  install dir may not reflect the actual pbk path.  Thus if it
                //  is an all user install we want to force the directory to
                //  the Cm All Users dir so we get the correct phonebook.
                //
                MYVERIFY(FALSE != GetAllUsersCmDir(szInstallDir, hInstance));
            }
        }

        if (GetPhoneBookPath(szInstallDir, &pszPhonebook, bAllUserUninstall))
        {
            //
            //  Note that usually on NT5 we are called by RasCustomDeleteEntryNotify (in cmdial32.dll)
            //  throw RasDeleteEntry.  Thus we don't really need to delete the entry.  However, it is
            //  possible that someone would call cmstp.exe /u directly and not through the RAS API, thus
            //  we want to delete the connectoid in that case.  Since we are called after RAS has already
            //  deleted the entry it shouldn't be a problem.
            //  Note that on NT5 we only remove the exact entry to fix NTRAID 349749
            //  otherwise we could end up deleting similarly named connectoids
            //  and lose the users only interface to CM.
            //
            MYVERIFY(FALSE != RemovePhonebookEntry(szLongServiceName, pszPhonebook, !(plat.IsAtLeastNT5())));
        }

		CmFree(pszPhonebook);
    }

    //
    //  Launch the uninstall INF
    //
    iCmsVersion = GetPrivateProfileInt(c_pszCmSectionProfileFormat, c_pszVersion, 
		0, szCmsFile);

    if (1 >= iCmsVersion)
    {
        //
        //  Then we have an old 1.0 profile and we should remove the showicon.exe
        //  postsetup command.
        //
        RemoveShowIconFromRunPostSetupCommands(szInfFile);
    }

    bReturn = SUCCEEDED(LaunchInfSection(szInfFile, szSectionName, szTitle, FALSE));  // bQuiet = FALSE

    //
    //  On NT5 we need to delete the desktop shortcut
    //
    if (plat.IsAtLeastNT5())
    {    
        DeleteNT5ShortcutFromPathAndName(hInstance, szLongServiceName, nDesktopFolder);
    }

    //
    //  Finally delete the profile directory. (Not deleted because the inf file resides there.  
    //  The dir can't be removed because the inf file is still in it and in use, unless this 
    //  is a legacy profile).  Not that we could cause cmstp to cause an Access Violation 
    //  if we ask it to delete an empty string.
    //
    if ((TEXT('\0') != szProfileDir[0]) && SetFileAttributes(szProfileDir, FILE_ATTRIBUTE_NORMAL))
    {
    
        SHFILEOPSTRUCT fOpStruct;
        ZeroMemory(&fOpStruct, sizeof(fOpStruct));
        
        fOpStruct.wFunc = FO_DELETE;
        fOpStruct.pFrom = szProfileDir;
        fOpStruct.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;
        
        MYVERIFY(ERROR_SUCCESS == SHFileOperation(&fOpStruct));
    }

    //
    //  We need to try to delete the following regkeys:
    //  HKCU\\Software\\Microsoft\\Connection Manager\\<UserInfo/SingleUserInfo>
    //  HKCU\\Software\\Microsoft\\Connection Manager\\Mappings
    //  HKLM\\Software\\Microsoft\\Connection Manager\\Mappings
    //  HKCU\\Software\\Microsoft\\Connection Manager
    //  HKLM\\Software\\Microsoft\\Connection Manager
    //  

    //
    //  Registry Cleanup.  We want to delete the UserInfo keys if they are empty.
    //  We then want to delete the mappings keys if they don't contain any more
    //  values.  We also want to delete the CM registry keys if they don't contain
    //  any subkeys.  Also kill the GUID Mappings key (this was beta only but still
    //  should be deleted).  The problem here is that win95 infs delete keys recursively,
    //  even if they have subkeys.  Thus we must use code to safely delete these keys.
    //  Please note that this does mean we could be unnecessarily deleting the Components
    //  Checked value in HKLM\\...\\Connection Manager but this can't be helped.  I
    //  would rather take the small startup perf hit than leave the users registry
    //  dirty.
    //

    if (bAllUserUninstall)
    {
        wsprintf(szTemp, TEXT("%s%s"), c_pszRegCmUserInfo, szLongServiceName);
    }
    else
    {
        wsprintf(szTemp, TEXT("%s%s"), c_pszRegCmSingleUserInfo, szLongServiceName);    
    }

    //
    //  Delete the User Data, note that we have to do this programatically because
    //  of 1.0 profiles that don't know to delete their User Data on uninstall (no commands
    //  in the 1.0 inf to do so).  Note that we don't want to cleanup user data if this
    //  is a same name upgrade uninstall (uninstall the 1.0 profile before installing the
    //  new profile).
    //

    if (bCleanUpCreds)
    {
        CmDeleteRegKeyWithoutSubKeys(HKEY_CURRENT_USER, szTemp, TRUE);

        CmDeleteRegKeyWithoutSubKeys(HKEY_CURRENT_USER, c_pszRegCmUserInfo, TRUE);
        CmDeleteRegKeyWithoutSubKeys(HKEY_CURRENT_USER, c_pszRegCmSingleUserInfo, TRUE);
    }

    CmDeleteRegKeyWithoutSubKeys(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, FALSE);
    CmDeleteRegKeyWithoutSubKeys(HKEY_CURRENT_USER, c_pszRegCmMappings, FALSE);

    HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, c_pszRegGuidMappings);

    CmDeleteRegKeyWithoutSubKeys(HKEY_LOCAL_MACHINE, c_pszRegCmRoot, TRUE);
    CmDeleteRegKeyWithoutSubKeys(HKEY_CURRENT_USER, c_pszRegCmRoot, TRUE);

    //
    //  Refresh the desktop so Desktop GUIDS disappear
    //
    RefreshDesktop();

exit:
    return (bReturn ? S_OK : E_FAIL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmutil\cmlog.cpp ===
//+----------------------------------------------------------------------------
//
// File:    cmlog.cpp
//
// Module:  CMLOG.LIB
//
// Synopsis: Connection Manager Logging File i/o class
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  25-May-2000 SumitC  Created
//
// Note:
//
//-----------------------------------------------------------------------------

#define CMLOG_IMPLEMENTATION
#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>
#include <psapi.h>
#include <tlhelp32.h>

#include "cmmaster.h"

#include "CmLogStr.h"
#include "cmlog.h"
#include "cmlogutil.h"

#include "getmodulever.cpp"

//
//  Constants
//
LPCTSTR c_szSep     = TEXT("\\");
LPCTSTR c_szDotLog  = TEXT(".log");
LPCTSTR c_szNewLine = TEXT("\r\n");
LPCTSTR c_szEmpty   = TEXT("");
#define CHECKEMPTY(sz) ((sz) ? (sz) : c_szEmpty)

LPCTSTR c_szLineOfStars = TEXT("******************************************************************");
LPCTSTR c_szFieldSeparator = TEXT("\t");

//
// Byte order mark constant, written as the first two bytes to a Unicode file to mark it as such
//
const WCHAR c_wchBOM = BYTE_ORDER_MARK;

//
//  Globals
//
extern HINSTANCE g_hInst;

//
//  utility macros
//
#define INBETWEEN(x, a, b)      ( ( (x) >= (a) ) && ( (x) <= (b) ) )

//
//  local function declarations
//
LPTSTR GetLogDesc(_CMLOG_ITEM eItem);
LPTSTR GetLogFormat(_CMLOG_ITEM eItem, BOOL fUnicode);



typedef struct _CM_LOG_ITEM_DESC
{
    enum _CMLOG_ITEM    eLogItem;       // id of the log item (enum is in cmlog.h)
    UINT                idDesc;         // resource id of the description string
    UINT                idFormat;       // resource id of the format string used
}
CMLOGITEM;

//
//
//  Array with information about each log entry.  All logging is driven by this table.
//  See above for column details.
//
//
static CMLOGITEM s_aCmLogItems[] =
{
    { LOGGING_ENABLED_EVENT,    IDS_LOGDESC_LOGENABLED,                 0 },
    { LOGGING_DISABLED_EVENT,   IDS_LOGDESC_LOGDISABLED,                0 },
    { PREINIT_EVENT,            IDS_LOGDESC_PREINIT,                    IDS_LOGFMT_PREINIT, },
    { PRECONNECT_EVENT,         IDS_LOGDESC_PRECONNECT,                 IDS_LOGFMT_PRECONNECT },
    { PREDIAL_EVENT,            IDS_LOGDESC_PREDIAL,                    IDS_LOGFMT_PREDIAL },
    { PRETUNNEL_EVENT,          IDS_LOGDESC_PRETUNNEL,                  IDS_LOGFMT_PRETUNNEL },
    { CONNECT_EVENT,            IDS_LOGDESC_CONNECT,                    0 },
    { CUSTOMACTIONDLL,          IDS_LOGDESC_CUSTOMACTIONDLL,            IDS_LOGFMT_CUSTOMACTIONDLL },
    { CUSTOMACTIONEXE,          IDS_LOGDESC_CUSTOMACTIONEXE,            IDS_LOGFMT_CUSTOMACTIONEXE },
    { CUSTOMACTION_NOT_ALLOWED, IDS_LOGDESC_CUSTOMACTION_NOT_ALLOWED,   IDS_LOGFMT_CUSTOMACTION_NOT_ALLOWED},
    { CUSTOMACTION_WONT_RUN,    IDS_LOGDESC_CUSTOMACTION_WONT_RUN,      IDS_LOGFMT_CUSTOMACTION_WONT_RUN},
    { CUSTOMACTION_SKIPPED,     IDS_LOGDESC_CUSTOMACTION_SKIPPED,       IDS_LOGFMT_CUSTOMACTION_SKIPPED},
    { DISCONNECT_EVENT,         IDS_LOGDESC_DISCONNECT,                 IDS_LOGFMT_DISCONNECT },
    { RECONNECT_EVENT,          IDS_LOGDESC_RECONNECT,                  0 },
    { RETRY_AUTH_EVENT,         IDS_LOGDESC_RETRYAUTH,                  0 },
    { CALLBACK_NUMBER_EVENT,    IDS_LOGDESC_CALLBACKNUMBER,             IDS_LOGFMT_CALLBACKNUMBER },
    { PASSWORD_EXPIRED_EVENT,   IDS_LOGDESC_PWDEXPIRED,                 IDS_LOGFMT_PWDEXPIRED },
    { PASSWORD_RESET_EVENT,     IDS_LOGDESC_PWDRESET,                   IDS_LOGFMT_PWDRESET },
    { CUSTOM_BUTTON_EVENT,      IDS_LOGDESC_CUSTOMBUTTON,               0 },
    { ONCANCEL_EVENT,           IDS_LOGDESC_ONCANCEL,                   0 },
    { ONERROR_EVENT,            IDS_LOGDESC_ONERROR,                    IDS_LOGFMT_ONERROR },
    { CLEAR_LOG_EVENT,          IDS_LOGDESC_CLEARLOG,                   0 },
    { DISCONNECT_EXT,           IDS_LOGDESC_EXT_DISCONNECT,             0 },
    { DISCONNECT_INT_MANUAL,    IDS_LOGDESC_INT_DISCONNECT_MANUAL,      0 },
    { DISCONNECT_INT_AUTO,      IDS_LOGDESC_INT_DISCONNECT_AUTO,        0 },
    { DISCONNECT_EXT_LOST_CONN, IDS_LOGDESC_EXT_DISCONNECT_LOST_CONN,   0 },
    { PB_DOWNLOAD_SUCCESS,      IDS_LOGDESC_PB_DOWNLOAD_SUCCESS,        IDS_LOGFMT_PB_DOWNLOAD_SUCCESS },
    { PB_DOWNLOAD_FAILURE,      IDS_LOGDESC_PB_DOWNLOAD_FAILURE,        IDS_LOGFMT_PB_DOWNLOAD_FAILURE },
    { PB_UPDATE_SUCCESS,        IDS_LOGDESC_PB_UPDATE_SUCCESSFUL,       IDS_LOGFMT_PB_UPDATE_SUCCESSFUL  },
    { PB_UPDATE_FAILURE_PBS,    IDS_LOGDESC_PB_UPDATE_FAILED_PBS,       IDS_LOGFMT_PB_UPDATE_FAILED_PBS  },
    { PB_UPDATE_FAILURE_CMPBK,  IDS_LOGDESC_PB_UPDATE_FAILED_CMPBK,     IDS_LOGFMT_PB_UPDATE_FAILED_CMPBK },
    { PB_ABORTED,               IDS_LOGDESC_PB_ABORTED,                 0 },
    { VPN_DOWNLOAD_SUCCESS,     IDS_LOGDESC_VPN_DOWNLOAD_SUCCESS,       IDS_LOGFMT_VPN_DOWNLOAD_SUCCESS },
    { VPN_DOWNLOAD_FAILURE,     IDS_LOGDESC_VPN_DOWNLOAD_FAILURE,       IDS_LOGFMT_VPN_DOWNLOAD_FAILURE },
    { VPN_UPDATE_SUCCESS,       IDS_LOGDESC_VPN_UPDATE_SUCCESSFUL,      IDS_LOGFMT_VPN_UPDATE_SUCCESSFUL  },
    { VPN_UPDATE_FAILURE,       IDS_LOGDESC_VPN_UPDATE_FAILURE,         IDS_LOGFMT_VPN_UPDATE_FAILURE  },
    { ONERROR_EVENT_W_SAFENET,  IDS_LOGDESC_ONERROR_W_SAFENET,          IDS_LOGFMT_ONERROR_W_SAFENET},
    { SN_ADAPTER_CHANGE_EVENT,  IDS_LOGDESC_SN_ADAPTER_CHANGE,          IDS_LOGFMT_SN_ADAPTER_CHANGE},
    { USER_FORMATTED,           0,                                      0 }
};

int s_cCmLogItems = sizeof(s_aCmLogItems) / sizeof(CMLOGITEM);

#define VERIFY_CMLOG_ITEM_OK(x)  INBETWEEN(x, 1, s_cCmLogItems)


//
//  Usage Note:  Caller/User of logging must:
//                  p = new CmLogFile
//                  p->Init( instancehandle, fIsItAnAllUserProfile, "name of connectoid" )
//                  p->SetParams( ... the params ... )
//                  if (p->m_fEnabled)
//                      p->Start
//                  else
//                      p->Stop
//


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::CmLogFile
//
// Desc:    constructor
//
// Args:    none
//
// Return:  n/a
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
CmLogFile::CmLogFile()
{
    m_fInitialized = FALSE;
    
    m_hfile = NULL;
    m_dwSize = 0;
    m_pszServiceName = NULL;
    m_szModule[0] = TEXT('\0');
    m_pszLogFile = NULL;

    m_dwMaxSize = 0;
    m_fEnabled = FALSE;
    m_pszLogFileDir = NULL;
}
    

//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::~CmLogFile
//
// Desc:    destructor
//
// Args:    none
//
// Return:  n/a
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
CmLogFile::~CmLogFile()
{
    if (m_fInitialized)
    {
        DeInit();
    }
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::Init
//
// Desc:    Initializes the CmLogFile object
//
// Args:    [hInst]          -- instance handle
//          [fAllUser]       -- is this an all user profile?
//          [pszServiceName] -- long service name
//
// Return:  HRESULT
//
// Notes:   There are both Ansi and Unicode versions for this function
//
// History: 18-Jul-2000   SumitC      Created
//          11-Apr-2001   SumitC      Added Ansi version
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::Init(HINSTANCE hInst, BOOL fAllUser, LPCSTR pszAnsiServiceName)
{
    LPWSTR pszServiceName = SzToWzWithAlloc(pszAnsiServiceName);

    HRESULT hr = pszServiceName ? Init(hInst, fAllUser, pszServiceName) : E_OUTOFMEMORY;

    CmFree(pszServiceName);
    return hr;
}

HRESULT
CmLogFile::Init(HINSTANCE hInst, BOOL fAllUser, LPCWSTR pszServiceName)
{
    HRESULT hr = S_OK;
    
    // if m_fInitialized is already true, assert and exit
    CMASSERTMSG(!m_fInitialized, TEXT("CmLogFile::Init - called twice"));
    if (TRUE == m_fInitialized)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    CMASSERTMSG(pszServiceName && pszServiceName[0], TEXT("CmLogFile::Init - invalid servicename, investigate"));
    if ((NULL == pszServiceName) || (TEXT('\0') == pszServiceName[0]))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // set the args as member vars
    m_fAllUser = fAllUser;

    m_pszServiceName = CmStrCpyAlloc(pszServiceName);
    if (NULL == m_pszServiceName)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    //  store away the module name
    //
    if (FALSE == CmGetModuleBaseName(hInst, m_szModule))
    {
        lstrcpyU(m_szModule, TEXT("cm"));
    }
    
    // if all is well, set m_fInitialized to true
    m_fInitialized = TRUE;

Cleanup:
    CMTRACEHR(TEXT("CmLogFile::Init"), hr);
    return hr;
}



//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::SetParams
//
// Desc:    Read logging params from the CMS file
//
// Args:    [fEnabled]      -- is logging enabled?
//          [dwMaxFileSize] -- maximum file size, in KB.
//          [pszLogFileDir] -- put logging files in this dir.
//
// Return:  HRESULT
//
// Notes:   There are both Ansi and Unicode versions for this function
//
// History: 18-Jul-2000   SumitC      Created
//          11-Apr-2001   SumitC      Added Ansi version
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::SetParams(BOOL fEnabled, DWORD dwMaxFileSize, LPCSTR pszAnsiLogFileDir)
{
    LPWSTR pszLogFileDir = SzToWzWithAlloc(pszAnsiLogFileDir);

    HRESULT hr = pszLogFileDir ? SetParams(fEnabled, dwMaxFileSize, pszLogFileDir) : E_OUTOFMEMORY;

    CmFree(pszLogFileDir);
    return hr;
}

HRESULT
CmLogFile::SetParams(BOOL fEnabled, DWORD dwMaxFileSize, LPCWSTR pszLogFileDir)
{
    HRESULT hr = S_OK;
    LPTSTR  szUnexpanded = NULL;
    CIni *  pIni = NULL;

    //
    //  logging must be stopped for this function to be called
    //
    CMASSERTMSG(NULL == m_hfile, TEXT("CmLogFile::SetParams - m_hfile must be null when this is called"));
    if (m_hfile)
    {
        CMTRACE(TEXT("CmLogFile::SetParams was called during logging - must call Stop first"));
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // BUGBUG: temp
    CMTRACE1(TEXT("CmLogFile::SetParams - called with Enabled = %d"), fEnabled);
    CMTRACE1(TEXT("CmLogFile::SetParams - called with MaxFileSize = %d"), dwMaxFileSize);
    CMTRACE1(TEXT("CmLogFile::SetParams - called with LogFileDir = %s"), pszLogFileDir);

    //
    //  EnableLogging (BOOL)
    //
    m_fEnabled = fEnabled;
    
    //
    //  MaxFileSize (DWORD)
    //
    m_dwMaxSize = dwMaxFileSize;
    if (0 == m_dwMaxSize)
    {
        m_dwMaxSize = c_dwMaxFileSize;
    }
    m_dwMaxSize *= 1024;        // size was in KB, convert to bytes.

    //
    //  FileDirectory (string)
    //
    if (CmStrStr(pszLogFileDir, TEXT("%")))
    {
        //
        //  now expand the string we have
        //

        LPTSTR sz = NULL;
        DWORD  cch = ExpandEnvironmentStringsU(pszLogFileDir, NULL, 0);

        //
        //  if cch is zero, the pszLogFileDir string supplied is essentially bogus,
        //  i.e. it contains '%' indicating there's a macro to be expanded, but
        //  ExpandEnvironmentStrings can't expand it.  Here we let m_pszLogFileDir
        //  be set to NULL (the logging code will then use the Temp dir.
        //
        if (cch)
        {
            sz = (LPTSTR) CmMalloc(cch * sizeof(TCHAR));
            if (NULL == sz)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            if (cch != ExpandEnvironmentStringsU(pszLogFileDir, sz, cch))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CmFree(sz);
                goto Cleanup;
            }

            // success...
        }
        CmFree(m_pszLogFileDir);
        m_pszLogFileDir = sz;
        CMTRACE1(TEXT("CmLogFile::SetParams - LogFileDir was finally = %s"), m_pszLogFileDir); // BUGBUG
    }
    else
    {
        CmFree(m_pszLogFileDir);
        if (pszLogFileDir)
        {
            m_pszLogFileDir = CmStrCpyAlloc(pszLogFileDir);
            if (NULL == m_pszLogFileDir)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        else
        {
            m_pszLogFileDir = NULL;
        }
    }

Cleanup:

    CMTRACEHR(TEXT("CmLogFile::SetParams"), hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::Start
//
// Desc:    Start logging
//
// Args:    [fBanner] -- write a banner when starting
//
// Return:  HRESULT
//
// Notes:   
//
// History: 18-Jul-2000     SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::Start(BOOL fBanner)
{
    HRESULT hr = S_OK;
    
    // if already started, or already Initialized, or not enabled, exit
    CMASSERTMSG(!m_hfile, TEXT("CmLogFile::Start - already started!"));
    CMASSERTMSG(m_fInitialized, TEXT("CmLogFile::Start - must be initialized"));
    CMASSERTMSG(m_fEnabled, TEXT("CmLogFile::Start - must be enabled"));
    if (NULL != m_hfile || FALSE == m_fInitialized || FALSE == m_fEnabled)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // open log file
    hr = OpenFile();
    if (S_OK != hr)
    {
        goto Cleanup;
    }

    // set m_dwSize while doing so.

    m_dwSize = GetFileSize(m_hfile, NULL);
    if (DWORD(-1) == m_dwSize)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        m_dwSize = 0;
        goto Cleanup;
    }

    //
    //  no matter what the size of the file, we only clear an 'over the size limit'
    //  file at the start of a call.  The fBanner param covers this.
    //
    if (fBanner)
    {
        // check file size, if over size Clear the file
        if (m_dwSize > m_dwMaxSize)
        {
            Clear();    // this writes a banner as well
        }
        else
        {
            // log banner
            Banner();
        }
    }

    CMASSERTMSG(m_hfile, TEXT("CmLogFile::Start - at end of fn, m_hfile must be valid"));

Cleanup:
    CMTRACEHR(TEXT("CmLogFile::Start"), hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::Stop
//
// Desc:    Stops logging
//
// Args:    none
//
// Return:  HRESULT
//
// Notes:   
//
// History: 18-Jul-2000     SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::Stop()
{
    HRESULT hr = S_OK;

    //
    //  if initialized is false, assert and exit
    //
    CMASSERTMSG(m_fInitialized, TEXT("CmLogFile::Stop - must be initialized"));
    if (FALSE == m_fInitialized)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    //  if already stopped, exit - nothing to do
    //
    if (NULL == m_hfile || FALSE == m_fEnabled)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    //  end log and close file
    //
    CloseFile();

    m_fEnabled = FALSE;

    CMASSERTMSG(NULL == m_hfile, TEXT("CmLogFile::Stop - at end of fn, m_hfile must be NULL"));
    
Cleanup:

    CMTRACEHR(TEXT("CmLogFile::Stop"), hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::DeInit
//
// Desc:    Uninitializes cm logging
//
// Args:    none
//
// Return:  HRESULT
//
// Notes:   
//
// History: 18-Jul-2000     SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::DeInit()
{
    HRESULT hr = S_OK;

    //
    //  if initialized is false, assert and exit
    //
    CMASSERTMSG(m_fInitialized, TEXT("CmLogFile::DeInit - must be initialized"));
    if (FALSE == m_fInitialized)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    //  end log and close file
    //
    CloseFile();

    CmFree(m_pszServiceName);
    m_pszServiceName = NULL;
    CmFree(m_pszLogFileDir);
    m_pszLogFileDir = NULL;
    CmFree(m_pszLogFile);
    m_pszLogFile = NULL;

    m_fInitialized = FALSE;

Cleanup:

    CMTRACEHR(TEXT("CmLogFile::DeInit"), hr);
    return hr;

}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::Log
//
// Desc:    Logs a connection manager or connection point services event
//
// Args:    [fUnicode] - are the args Unicode or ANSI?
//          [eLogItem] - word containing source, type & description of log item
//          [...]       - optional args (depends on log item)
//
// Return:  void
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
void
CmLogFile::Log(_CMLOG_ITEM eLogItem, ...)
{
    TCHAR   sz[2*MAX_PATH]; // REVIEW: Is this big enough?  Could we dynamically allocate it?
    LPTSTR  pszTmp = NULL;

    CMASSERTMSG(m_fInitialized, TEXT("CmLogFile::Log - must be initialized"));
    CMASSERTMSG((m_hfile && m_fEnabled) || (!m_hfile && !m_fEnabled), TEXT("CmLogFile::Log - m_hfile and m_fenabled must be in sync"));

    if (NULL == m_hfile || NULL == m_fEnabled)
    {
        // Start hasn't been called yet, or logging is disabled.  Nothing to do.
        goto Cleanup;
    }

    //
    //  Verify that the log item is a valid one
    //
    CMASSERTMSG(VERIFY_CMLOG_ITEM_OK(eLogItem), TEXT("CmLogFile::Log - eItem must represent valid Log item"));

#if DBG
    pszTmp = GetLogDesc(eLogItem);
    CMTRACE2(TEXT("Logging item = %d, desc = %s"), eLogItem, CHECKEMPTY(pszTmp));
    CmFree(pszTmp);
#endif

    if (VERIFY_CMLOG_ITEM_OK(eLogItem))
    {
        switch (eLogItem)
        {
        case USER_FORMATTED:
            {
                va_list valArgs;

                va_start(valArgs, eLogItem);
                lstrcpynU(sz, va_arg(valArgs, LPTSTR), CELEMS(sz));
                FormatWrite(eLogItem, sz);
                va_end(valArgs);
            }
            break;

        default:
            //
            //  Format the arguments, and log the result
            //
            lstrcpyU(sz, c_szEmpty);

            pszTmp = GetLogFormat(eLogItem, TRUE);
            if (pszTmp)
            {
                va_list valArgs;

                va_start(valArgs, eLogItem);
                wvsprintfU(sz, pszTmp, valArgs);
                CmFree(pszTmp);
                FormatWrite(eLogItem, sz);
                va_end(valArgs);
            }
            else
            {
                FormatWrite(eLogItem, NULL);
            }
        }
    }
    else
    {
        CMTRACE2(TEXT("Illegal CmLog entry %d (0x%x)"), eLogItem, eLogItem);
        CMASSERTMSG(FALSE, TEXT("Illegal CmLog type - check trace, then edit code to fix"));
    }

Cleanup:
    ;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::Write
//
// Desc:    Actually writes out the logged string (to debug console and logfile)
//
// Args:    [szLog] - string to log
//
// Return:  void
//
// Notes:   *ALL* writes to the log file must be done using this function
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::Write(LPTSTR szLog)
{
    HRESULT hr = S_OK;
    DWORD   cb = 0;
    DWORD   cbActuallyWritten = 0;
    LPSTR   szLogAnsi = NULL;

    CMASSERTMSG(m_hfile, TEXT("CmLogFile::Write - m_hfile must be valid, check code"));

    if (NULL == m_hfile)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

#if 0    
    //
    //  Dump string to debug console as well
    //
    CMTRACE(szLog);
#endif

    //
    //  Check for max size, open new log file if necessary
    //
    if (OS_NT)
    {
        cb = lstrlenW(szLog) * sizeof(TCHAR);
    }
    else
    {
        szLogAnsi = WzToSzWithAlloc(szLog);
        cb = lstrlenA(szLogAnsi) * sizeof(CHAR);
    }

#if 0
    // I'm leaving this here, but for now logging will not terminate a log file
    // during a log even if it goes past the max size.
    //
    if (m_dwSize + cb > m_dwMaxSize)
    {
        Clear();
    }
#endif

    //
    //  Write string to logfile
    //

    SetFilePointer(m_hfile, 0, NULL, FILE_END);
    if (OS_NT)
    {
        WriteFile(m_hfile, szLog, cb, &cbActuallyWritten, 0);
    }
    else
    {
        WriteFile(m_hfile, szLogAnsi, cb, &cbActuallyWritten, 0);
    }

    if (cb != cbActuallyWritten)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CMTRACE(TEXT("CMLOG: incomplete write to logfile"));
        goto Cleanup;
    }

    m_dwSize += cb;

Cleanup:

    CmFree(szLogAnsi);
    
    CMTRACEHR(TEXT("CmLogFile::Write"), hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::FormatWrite
//
// Desc:    Formats a log message with additional information and call Write fn
//
// Args:    [eItem]  - id of item being logged
//          [szArgs] - string containing all the args.
//
// Return:  void
//
// Notes:   
//
// History: 30-Apr-2000     SumitC      Created
//
//-----------------------------------------------------------------------------
void
CmLogFile::FormatWrite(_CMLOG_ITEM eItem, LPTSTR szArgs)
{
    // There are string length checks for fit into these buffers.
    //
    TCHAR       szLog[(2*MAX_PATH) + 1]; // REVIEW: Is this big enough?  Could we dynamically allocate it?
    TCHAR       sz[(2*MAX_PATH) + 1]; // REVIEW: Is this big enough?  Could we dynamically allocate it?
    int iFieldSepLen = lstrlen(c_szFieldSeparator);
    int iCalculatedSize = 0;
    int iActualSize = 0; 

    CMASSERTMSG(VERIFY_CMLOG_ITEM_OK(eItem), TEXT("CmLogFile::FormatWrite - eItem must represent valid Log item"));

    szLog[0] = TEXT('\0');

    //
    //  Thread and Module name
    //
    TCHAR szModuleWithParens[15];  // m_szModule is originally in 8.3 format = 12 + '[' + ']' = 15 although we only keep the filename

    szModuleWithParens[0] = TEXT('\0');

    iCalculatedSize = lstrlenU(m_szModule) + 2 ;

    if ((CELEMS(szModuleWithParens)) > iCalculatedSize)
    {
        wsprintfU(szModuleWithParens, TEXT("[%s]"), m_szModule);
        
        iActualSize = lstrlenU(szModuleWithParens);
        CMASSERTMSG(iActualSize == iCalculatedSize, TEXT("CmLogFile::FormatWrite - Actual String size differs than calculated size!!!"));
    }


    iCalculatedSize = iFieldSepLen + max(lstrlenU(szModuleWithParens), 10);
    if ((CELEMS(sz)) > iCalculatedSize)
    {
        wsprintfU(sz, TEXT("%-10s%s"), szModuleWithParens, c_szFieldSeparator);

        iActualSize = lstrlenU(sz);
        CMASSERTMSG(iActualSize == iCalculatedSize, TEXT("CmLogFile::FormatWrite - Actual String size differs than calculated size!!!"));

        lstrcpynU(szLog, sz, (int)min((int)lstrlenU(sz)+1, (int)CELEMS(szLog)));
    }

    //
    //  Time
    //
    LPTSTR pszTime = NULL;
    
    CmGetDateTime(NULL, &pszTime);
    if (pszTime)
    {
        int iTimeLen = lstrlenU(pszTime);
        int iLogLen = lstrlenU(szLog);

        iCalculatedSize = (iTimeLen + iLogLen + iFieldSepLen);
        if ((CELEMS(szLog)) > iCalculatedSize)
        {
            lstrcatU(szLog, pszTime);
            lstrcatU(szLog, c_szFieldSeparator);
            iActualSize = lstrlenU(szLog);
            CMASSERTMSG(iActualSize == iCalculatedSize, TEXT("CmLogFile::FormatWrite - Actual String size differs than calculated size!!!"));
        }        
        CmFree(pszTime);
    }

    //
    //  Description
    //
    if (USER_FORMATTED == eItem)
    {
        int iBufLen = lstrlenU(szArgs);

        //
        // 4 = \r + \n + eItem
        //
        iCalculatedSize = iBufLen + iFieldSepLen + 4;
        
        if ((CELEMS(sz)) > iCalculatedSize)
        {
            wsprintfU(sz, TEXT("%02d%s%s\r\n"), eItem, c_szFieldSeparator, szArgs);
            iActualSize = lstrlenU(sz);
            CMASSERTMSG(iActualSize == iCalculatedSize, TEXT("CmLogFile::FormatWrite - Actual String size differs than calculated size!!!"));
        }
    }
    else
    {
        LPTSTR pszDesc = GetLogDesc(eItem);
        int iDescLen = 0;

        if (pszDesc)
        {
            iDescLen = lstrlenU(pszDesc);
        }

        if (szArgs)
        {        
            iCalculatedSize = (2 + iFieldSepLen + iDescLen + iFieldSepLen + lstrlenU(szArgs) + 2);
            if ((CELEMS(sz)) > iCalculatedSize)
            {
                wsprintfU(sz, TEXT("%02d%s%s%s%s\r\n"),
                        eItem, c_szFieldSeparator, CHECKEMPTY(pszDesc), c_szFieldSeparator, szArgs);

                iActualSize = lstrlenU(sz);
                CMASSERTMSG(iActualSize == iCalculatedSize, TEXT("CmLogFile::FormatWrite - Actual String size differs than calculated size!!!"));
            }
        }
        else
        {
            iCalculatedSize = (2 + iFieldSepLen + iDescLen + 2);
            if ((CELEMS(sz)) > iCalculatedSize)
            {
                wsprintfU(sz, TEXT("%02d%s%s\r\n"),
                        eItem, c_szFieldSeparator, CHECKEMPTY(pszDesc));
                
                iActualSize = lstrlenU(sz);
                CMASSERTMSG(iActualSize == iCalculatedSize, TEXT("CmLogFile::FormatWrite - Actual String size differs than calculated size!!!"));
            }
        }
        CmFree(pszDesc);
    }

    iCalculatedSize = (lstrlenU(szLog) + lstrlenU(sz));
    if ((CELEMS(szLog)) > iCalculatedSize)
    {
        lstrcatU(szLog, sz);

        iActualSize = lstrlenU(szLog);
        CMASSERTMSG(iActualSize == iCalculatedSize, TEXT("CmLogFile::FormatWrite - Actual String size differs than calculated size!!!"));
        
        //
        //  Write it out...
        //
        Write(szLog);
    }
}



//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::OpenFile
//
// Desc:    Utility function to open the log file
//
// Args:    none
//
// Return:  HRESULT (S_OK for success, else error)
//
// Notes:   
//
// History: 22-Jul-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::OpenFile()
{
    HRESULT hr          = S_OK;
    HANDLE  hDir        = NULL;
    LPTSTR  pszUsers    = NULL;
    BOOL    fFileOpened = FALSE;

    CMASSERTMSG(m_pszServiceName, TEXT("CmLogFile::OpenFile - m_pszServiceName must be valid"));

    if (m_fAllUser)
    {
        // this is the more common case, so no suffix
        pszUsers = CmStrCpyAlloc(TEXT(""));
    }
    else
    {
        LPTSTR pszTmp = CmLoadString(g_hInst, IDS_LOGSTR_SINGLEUSER);
        if (pszTmp)
        {
            pszUsers = (LPTSTR) CmMalloc((lstrlenU(pszTmp) + 4) * sizeof(TCHAR));
            if (pszUsers)
            {
                wsprintfU(pszUsers, TEXT(" (%s)"), pszTmp);
            }
            CmFree(pszTmp);
        }
    }

    if (NULL == pszUsers)
    {
        hr = E_OUTOFMEMORY;
        CMTRACE1(TEXT("CmLogFile::OpenFile - couldn't get Users strings, hr=%x"), hr);
        goto Cleanup;
    }

    //
    //  To open a log file, we first try the location provided by the user.  If
    //  that fails for whatever reason, we try GetTempPath.  If that fails, no
    //  logging.
    //
    for (int i = 0; (i < 2) && (FALSE == fFileOpened); ++i)
    {
        TCHAR szBuf[2 * MAX_PATH];

        CMTRACE1(TEXT("CmLogFile::OpenFile, iteration %d."), i + 1);

        //
        //  get the directory name
        //
        switch (i)
        {
        case 0:
            if (m_pszLogFileDir && (0 != lstrcmpiU(m_pszLogFileDir, c_szLogFileDirectory)))
            {
                lstrcpyU(szBuf, m_pszLogFileDir);
            }
            else
            {
                CMTRACE(TEXT("CmLogFile::OpenFile, HERE HERE skipping past case 0"));
                continue;
            }
            break;

        case 1:
            if (0 == GetTempPathU(2 * MAX_PATH, szBuf))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CMTRACE1(TEXT("GetTempPath failed with error 0x%x"), hr);
                goto Cleanup;
            }
            CMTRACE1(TEXT("CmLogFile::OpenFile, HERE HERE in case 1 and szBuf is %s"), szBuf);
            break;

        default:
            MYDBGASSERT(0);
            goto Cleanup;
            break;
        }

        CMTRACE1(TEXT("CmLogFile::OpenFile, directory name is %s"), szBuf);

        //
        //  see if the directory exists, if not try to create it
        //
        DWORD dwAttrib = GetFileAttributesU(szBuf);
        if (-1 == dwAttrib)
        {
            // directory does not exist
            CMTRACE(TEXT("CmLogFile::OpenFile - directory does not exist, trying to create it"));
            if (FALSE == CreateDirectoryU(szBuf, NULL))
            {
                DWORD dw = GetLastError();

                if (ERROR_ALREADY_EXISTS != dw)
                {
                    // real failure
                    hr = HRESULT_FROM_WIN32(dw);
                    CMTRACE2(TEXT("CmLogFile::OpenFile - Failed to create logging directory (%s), hr=%x"), szBuf, hr);
                    continue;
                }
                //
                //  On Win95/98, CreateDirectory fails with ERROR_ALREADY_EXISTS
                //  if the dir already exists. i.e. we have a dir, so keep going.
                //
                CMTRACE(TEXT("CmLogFile::OpenFile - directory created"));
            }
        }
        else
        {
            CMTRACE(TEXT("CmLogFile::OpenFile - directory already exists"));
            
            if (0 == (FILE_ATTRIBUTE_DIRECTORY & dwAttrib))
            {
                // there is a file of that name
                CMTRACE(TEXT("CmLogFile::OpenFile - there is a file of the same name as requested dir"));
                hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
                continue;
            }
            else if (FILE_ATTRIBUTE_READONLY & dwAttrib)
            {
                // the directory is readonly
                CMTRACE(TEXT("CmLogFile::OpenFile - the directory is readonly"));
                hr = E_ACCESSDENIED;
                continue;
            }
        }

        //
        //  the directory exists, try to create/open the logfile
        //
        if (*c_szSep != szBuf[lstrlenU(szBuf) - 1])
        {
            lstrcatU(szBuf, c_szSep);
        }
        lstrcatU(szBuf, m_pszServiceName);
        lstrcatU(szBuf, pszUsers);
        lstrcatU(szBuf, c_szDotLog);

        m_hfile = CreateFileU(szBuf,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

        //
        //  Since we asked for open existing, the file may just need to be created
        //
        if (INVALID_HANDLE_VALUE == m_hfile)
        {
            m_hfile = CreateFileU(szBuf,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  CREATE_NEW,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);

            if ((INVALID_HANDLE_VALUE != m_hfile) && OS_NT)
            {
                //
                //  Set the Byte order mark on the file
                //
                DWORD cbActuallyWritten = 0;

                WriteFile(m_hfile, &c_wchBOM, sizeof(c_wchBOM), &cbActuallyWritten, 0);

                if (sizeof(c_wchBOM) != cbActuallyWritten)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    CMTRACE(TEXT("CMLOG: Unable to set the Byte order mark while opening the file"));
                    goto Cleanup;
                }

                m_dwSize += sizeof(c_wchBOM);
            }
        }

        if (INVALID_HANDLE_VALUE == m_hfile)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CMTRACE2(TEXT("CmLogFile::OpenFile - Failed to open log file in dir %s with error 0x%x"), szBuf, hr);
            continue;
        }

        //
        //  Success!!
        //
        CmFree(m_pszLogFile);
        m_pszLogFile = CmStrCpyAlloc(szBuf);
        if (NULL == m_pszLogFile)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        hr = S_OK;
        fFileOpened = TRUE;
    }

#if DBG
    if (S_OK == hr)
    {
        CMASSERTMSG(m_hfile, TEXT("CmLogFile::OpenFile - at end.  m_hfile must be valid here"));
    }
#endif    

Cleanup:

    CmFree(pszUsers);

    CMTRACEHR(TEXT("CmLogFile::OpenFile"), hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::CloseFile
//
// Desc:    Closes the logging file
//
// Args:    none
//
// Return:  HRESULT
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::CloseFile()
{
    HRESULT hr = S_OK;
    
    if (m_hfile)
    {
        //
        //  Close the file
        //
        FlushFileBuffers(m_hfile);
        CloseHandle(m_hfile);
        m_hfile = NULL;
    }

    CMTRACEHR(TEXT("CmLogFile::CloseFile"), hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::Clear
//
// Desc:    Clears (resets) the logging file
//
// Args:    [fWriteBannerAfterwards] -- after clearing, write the banner?
//
// Return:  void
//
// Notes:   
//
// History: 17-Jul-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
void
CmLogFile::Clear(BOOL fWriteBannerAfterwards)
{
    HRESULT hr              = S_OK;
    BOOL    fWasDisabled    = FALSE;

    if (NULL == m_hfile)
    {
        fWasDisabled = TRUE;    // if called when logging is disabled, we still clear the log file
        
        hr = OpenFile();
        if (S_OK != hr)
        {
            goto Cleanup;
        }
    }

    //
    //  make sure everything gets written out (ignore errors for this one)
    //
    FlushFileBuffers(m_hfile);

    //
    //  clear the file (set fileptr to the start, then set EOF to that).
    //
    if (INVALID_SET_FILE_POINTER == SetFilePointer(m_hfile, 0, NULL, FILE_BEGIN))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }
    
    if (FALSE == SetEndOfFile(m_hfile))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    m_dwSize = 0;

    CMTRACE(TEXT("CmLogFile::Clear - cleared log file"));

    //
    //  If this is NT and thus a Unicode file, we need to set the Byte order mark
    //
    if (OS_NT)
    {
        if ((INVALID_HANDLE_VALUE != m_hfile) && OS_NT)
        {
            //
            //  Set the Byte order mark on the file
            //
            DWORD cbActuallyWritten = 0;

            WriteFile(m_hfile, &c_wchBOM, sizeof(c_wchBOM), &cbActuallyWritten, 0);

            if (sizeof(c_wchBOM) != cbActuallyWritten)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CMTRACE(TEXT("CMLOG: Unable to set the Byte order mark while clearing the file"));
                goto Cleanup;
            }

            m_dwSize += sizeof(c_wchBOM);
        }    
    }

    if (fWriteBannerAfterwards)
    {
        Banner();
    }

    if (fWasDisabled)
    {
        CloseFile();
    }

Cleanup:
    CMTRACEHR(TEXT("CmLogFile::Clear"), hr);
    return;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::Banner
//
// Desc:    Logs the banner heading for a Connection Manager log
//
// Args:    none
//
// Return:  void
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
void
CmLogFile::Banner()
{
    HRESULT     hr = S_OK;
    LPTSTR      psz = NULL;

    if (NULL == m_hfile)
    {
        return;
    }

    //
    //  System information, Process, Time
    //
    OSVERSIONINFO VersionInfo;
    LPTSTR        pszPlatform = TEXT("NT");

    ZeroMemory(&VersionInfo, sizeof(VersionInfo));
    VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
    GetVersionExU(&VersionInfo);

    if (VER_PLATFORM_WIN32_WINDOWS == VersionInfo.dwPlatformId)
    {
        pszPlatform = TEXT("9x");
    }
    else if (VER_PLATFORM_WIN32_NT == VersionInfo.dwPlatformId)
    {
        pszPlatform = TEXT("NT");
    }
    else
    {
        CMASSERTMSG(0, TEXT("CmLogFile::Banner - platform ID is not Windows or NT"));
    }

    //
    //  Connection Manager version number (using cmdial32.dll)
    //
    DWORD dwCMVer = 0;
    DWORD dwCMBuild = 0;
    DWORD dwLCID = 0;
    TCHAR szModulePath[MAX_PATH + 1];
    UINT  uRet = 0;

    uRet = GetSystemDirectoryU(szModulePath, MAX_PATH);
    if (0 == uRet)
    {
        CMTRACE1(TEXT("CmLogFile::Banner - GetSystemDirectoryU failed, GLE=%d"), GetLastError());
    }
    else
    {
        const LPTSTR c_pszCmdial32 = TEXT("\\cmdial32.dll");

        if ((uRet + lstrlenU(c_pszCmdial32) + 1) <= MAX_PATH)
        {
            lstrcatU(szModulePath, c_pszCmdial32);

            hr = GetModuleVersionAndLCID(szModulePath, &dwCMVer, &dwCMBuild, &dwLCID);
            if (FAILED(hr))
            {
                CMTRACE1(TEXT("CmLogFile::Banner - couldn't get CM version, hr=%x"), hr);
            }
        }
    }
   
    //
    //  Date & Time
    //

    LPTSTR pszDate = NULL;
    LPTSTR pszTime = NULL;
    
    CmGetDateTime(&pszDate, &pszTime);
    // strings can be NULL, but we handle that when using them (below)

    LPTSTR pszFmt = CmLoadString(g_hInst, IDS_LOGFMT_BANNER);
    LPTSTR pszUsers = CmLoadString(g_hInst,
                                   m_fAllUser ? IDS_LOGSTR_ALLUSERS : IDS_LOGSTR_SINGLEUSER);

    if (pszFmt && pszUsers)
    {
        UINT cch = lstrlenU(pszFmt) +
                   1 +
                   (3 * lstrlenU(c_szLineOfStars)) +     // occurs thrice total
                   lstrlenU(pszPlatform) +
                   (6 * 10) +               // how big can a DWORD get
                   lstrlenU(VersionInfo.szCSDVersion) +
                   lstrlenU(m_pszServiceName) +
                   lstrlenU(pszUsers) +
                   (pszDate ? lstrlenU(pszDate) : 0) +
                   (pszTime ? lstrlenU(pszTime) : 0) +
                   1;
        
        psz = (LPTSTR) CmMalloc(cch * sizeof(TCHAR));
        CMASSERTMSG(psz, TEXT("CmLogFile::Banner - couldn't log banner, malloc failed"));
        if (psz)
        {
            //
            //  Unicode logfiles are marked as such using a byte order mark, which
            //  means that to check for an "empty" file we have to account for the
            //  presence of the BOM.
            //
            BOOL fFileIsEmpty = (m_dwSize == (OS_NT ? sizeof(c_wchBOM) : 0));
            
            wsprintfU(psz, pszFmt,
                  fFileIsEmpty ? c_szEmpty : c_szNewLine,    // don't start with a newline if the file is empty
                  c_szLineOfStars,
                  pszPlatform,
                  VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, VersionInfo.szCSDVersion,
                  HIWORD(dwCMVer), LOWORD(dwCMVer), HIWORD(dwCMBuild), LOWORD(dwCMBuild),
                  m_pszServiceName,
                  pszUsers,
                  (pszDate ? pszDate : TEXT("")),
                  (pszTime ? pszTime : TEXT("")),
                  c_szLineOfStars,
                  c_szLineOfStars);

            CMTRACE(TEXT("CmLogFile::Banner - wrote banner"));
        }
    }
    
    CmFree(pszFmt);
    CmFree(pszUsers);
    CmFree(pszDate);
    CmFree(pszTime);

    //
    //  Write it out...
    //
    if (psz)
    {
        Write(psz);
        CmFree(psz);
    }
}


//+----------------------------------------------------------------------------
//
// Func:    GetLogDesc
//
// Desc:    Utility function, returns log item friendly name (desc)
//
// Args:    [eItem] - the log item about which to return information
//
// Return:  LPTSTR if found, or NULL if not
//
// Notes:
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
LPTSTR
GetLogDesc(_CMLOG_ITEM eItem)
{
    CMASSERTMSG(VERIFY_CMLOG_ITEM_OK(eItem), TEXT("GetLogDesc - eItem must represent valid Log item"));

    return CmLoadString(g_hInst, s_aCmLogItems[eItem - 1].idDesc);
}



//+----------------------------------------------------------------------------
//
// Func:    GetLogFormat
//
// Desc:    Utility function, returns log item Format
//
// Args:    [eItem]    - the log item about which to return information
//          [fUnicode] - is the caller unicode?
//
// Return:  LPTSTR if found, or NULL if not
//
// Notes:
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
LPTSTR
GetLogFormat(_CMLOG_ITEM eItem, BOOL fUnicode)
{
    CMASSERTMSG(VERIFY_CMLOG_ITEM_OK(eItem), TEXT("GetLogFormat - eItem must represent valid Log item"));

    CMASSERTMSG(fUnicode, TEXT("GetLogFormat - currently cmlog is only being compiled unicode"));
    
    LPTSTR pszFmt = CmLoadString(g_hInst, s_aCmLogItems[eItem - 1].idFormat);

    if (0 == lstrcmpU(TEXT(""), pszFmt))
    {
        // NOTE: CmLoadString has a rather broken implementation where it decides
        //       to return empty strings in case of failure.  This is a problem
        //       because (a) it makes it impossible to detect an actual failure,
        //       as opposed to an empty string, and and (b) it uses an alloc within
        //       a return statement, so it can fail anyway.  This 'if' block
        //       gives me back a NULL so that my code can work the way it should.
        CmFree(pszFmt);
        return NULL;
    }
    else if (pszFmt)
    {
        // If the module is compiled unicode, then fUnicode=false requires conversion.
        // If the module is compiled ANSI, then fUnicode=true requires conversion.

#if 0 // since we're compiled Unicode for now        
#ifdef UNICODE
        if (!fUnicode)
        {
            if (FALSE == ConvertFormatString(pszFmt))
            {
                return NULL;
            }
        }
#else
        if (fUnicode)
        {
            if (FALSE == ConvertFormatString(pszFmt))
            {
                return NULL;
            }
        }
#endif
#endif // 0
        return pszFmt;
    }
    else
    {
        return NULL;
    }
}


#undef CMLOG_IMPLEMENTATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmutil\ciniw.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ciniW.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Unicode CIni implementation
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:	 henryt - relocated to CMUTIL           03/15/98
//           quintinb - created A and W versions    05/12/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//+----------------------------------------------------------------------------
//
// Function:  CIniW_Set
//
// Synopsis:  This function takes a pointer to a string and a string as arguments.  It
//            frees the string currently in the destination pointer, allocates the correct
//            amount of memory and then copies the source string to the string pointed
//            to by the destination string pointer.  The allocated memory is the
//            responsibility of the caller.
//
// Arguments: LPWSTR *ppszDest - pointer to the destination string
//            LPCWSTR pszSrc - source string for the set
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
static void CIniW_Set(LPWSTR *ppszDest, LPCWSTR pszSrc)
{
    MYDBGASSERT(ppszDest);

    if (ppszDest)
    {
        CmFree(*ppszDest);
        *ppszDest = ((pszSrc && *pszSrc) ? CmStrCpyAllocW(pszSrc) : NULL);
    }
}


//+----------------------------------------------------------------------------
//
// Function:  CIniW_LoadCat
//
// Synopsis:  This function concatenates the suffix argument onto the string
//            argument and returns the resulting string through the return
//            value.  Note that the function allocates the correct amount of
//            memory which must be freed by the caller.  Also not passing in
//            an empty string returns NULL while passing just an empty suffix
//            returns just a copy of the string.
//
// Arguments: LPCWSTR pszStr - source string to duplicate
//            LPCWSTR pszSuffix - suffix to add onto the duplicated string
//
// Returns:   LPWSTR - a duplicate of the concatenated string
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
static LPWSTR CIniW_LoadCat(LPCWSTR pszStr, LPCWSTR pszSuffix)
{
	LPWSTR pszTmp;

	if (!pszStr || !*pszStr)
    {
		return (NULL);
	}
	
	if (!pszSuffix || !*pszSuffix)
    {
		pszTmp = CmStrCpyAllocW(pszStr);
	}
	else
	{
        pszTmp = CmStrCpyAllocW(pszStr);

        if (pszTmp)
        {
    	    CmStrCatAllocW(&pszTmp, pszSuffix);
    	}
	}

    MYDBGASSERT(pszTmp);
	
	return (pszTmp);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW_GPPS
//
// Synopsis:  Wrapper for the Windows API GetPrivateProfileString.  The return
//            value is the requested value, allocated on behalf of the caller.
//            Note that the function assumes a reasonable default size and then
//            loops and reallocates until it can fit the whole string.
//
// Arguments: LPCWSTR pszSection - Ini file section to retrieve data from
//            LPCWSTR pszEntry - key name to retrieve data from
//            LPCWSTR pszDefault - the default string value to return, defaults
//                                to the empty string ("") if not specified
//            LPCWSTR pszFile - full path to the ini file to get the data from
//
// Returns:   LPWSTR - the requested data from the ini file, must be freed 
//                     by the caller
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
static LPWSTR CIniW_GPPS(LPCWSTR pszSection, LPCWSTR pszEntry, LPCWSTR pszDefault, LPCWSTR pszFile)
 {
	LPWSTR pszBuffer;
	LPCWSTR pszLocalDefault = pszDefault ? pszDefault : L"";

    
    if ((NULL == pszFile) || (L'\0' == *pszFile))
    {
        CMASSERTMSG(FALSE, "CIniW_GPPS -- NULL or Empty file path passed.");
        return CmStrCpyAllocW(pszLocalDefault);
    }

    size_t nLen = __max((pszDefault ? lstrlenU(pszDefault) : 0) +4,48);

	while (1)
    {
		size_t nNewLen;

		pszBuffer = (LPWSTR) CmMalloc(nLen*sizeof(WCHAR));

        MYDBGASSERT(pszBuffer);

        if (pszBuffer)
        {
		
    		nNewLen = GetPrivateProfileStringU(pszSection, pszEntry, pszLocalDefault, 
                                               pszBuffer, nLen, pszFile);

    		if (nNewLen+2 < nLen) 
            {
    			return (pszBuffer);
    		}

    		CmFree(pszBuffer);
    		nLen *= 2;
    	}
    	else
    	{
            CMASSERTMSG(FALSE, "CIniW_GPPS -- CmMalloc Failed.");
            return CmStrCpyAllocW(pszLocalDefault);
    	}
	}
}

//+----------------------------------------------------------------------------
//
// Function:  CIni_SetFile
//
// Synopsis:  This function is very similar to CIniA_Set in that it takes
//            a source string and duplicates it into the string pointed to
//            by the destination pointer.  However, the difference is that
//            this function assumes the pszSrc argument to be a full path to
//            a file and thus calls CreateFile on the pszSrc string
//            before duplicating the string.
//
// Arguments: LPWSTR* ppszDest - pointer to a string to accept the duplicated buffer
//            LPCWSTR pszSrc - full path to a file, text to be duplicated
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::CIni_SetFile(LPWSTR *ppszDest, LPCWSTR pszSrc) 
{


    MYDBGASSERT(ppszDest);

    if (ppszDest)
    {
        CmFree(*ppszDest);           
        *ppszDest = NULL;

        if (pszSrc && *pszSrc) // pszSrc could be NULL
        {
            //
            // A full path to an existing file is expected
            //
        
            HANDLE hFile = CreateFileU(pszSrc, 0, 
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
    					               NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

            MYDBGASSERT(hFile != INVALID_HANDLE_VALUE);

    	    if (hFile != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFile);

                //
                // Update internal file
                //

                *ppszDest = CmStrCpyAllocW(pszSrc);
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::CIniW
//
// Synopsis:  CIniW constructor
//
// Arguments: HINSTANCE hInst - Instance handle used to load resources
//            LPCWSTR pszFile - Ini file the object describes
//            LPCWSTR pszSection - a section suffix that will be appended to 
//                                all section references
//            LPCWSTR pszEntry - an entry suffix that will be appended to all 
//                              entry references
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//+----------------------------------------------------------------------------
CIniW::CIniW(HINSTANCE hInst, LPCWSTR pszFile, LPCWSTR pszRegPath, LPCWSTR pszSection, LPCWSTR pszEntry) 
{

    //
    //  Input pointers default to NULL and in fact the constructor is rarely called
    //  with parameters.  Thus we will skip checking the input pointers and just
    //  pass them on to the functions below, which are designed to except NULL inputs.
    //

	m_hInst = hInst;

    //
    //  Make sure to NULL the string params before setting them below.  This
    //  is because we call free on the inputted params and we don't want to try
    //  to free garbage.
    //
	m_pszFile = NULL;
	m_pszSection = NULL;
	m_pszEntry = NULL;	
	m_pszPrimaryFile = NULL;
	m_pszRegPath = NULL;
    m_pszPrimaryRegPath = NULL;
    //m_fIgnoreRegOnRead = FALSE;
    //m_fWriteToBoth = FALSE;
    //m_fReadOnlyAccess = FALSE;
    m_pszICSDataPath = NULL;
    m_fReadICSData = FALSE;
    m_fWriteICSData = FALSE;

	SetFile(pszFile);
	SetSection(pszSection);
	SetEntry(pszEntry);
	SetRegPath(pszRegPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::~CIniW
//
// Synopsis:  CIniW destructor, frees dynamically allocated strings held onto
//            by the CIniW object.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
CIniW::~CIniW()
{
	CmFree(m_pszFile);
	CmFree(m_pszSection);
	CmFree(m_pszEntry);
	CmFree(m_pszPrimaryFile);
	CmFree(m_pszRegPath);
    CmFree(m_pszPrimaryRegPath);
    CmFree(m_pszICSDataPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::Clear
//
// Synopsis:  Clears all of the member variables of the CIniW class.  Used
//            so that a single CIniW object can be re-used without having to
//            destruct the old object and construct a new one.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//+----------------------------------------------------------------------------
void CIniW::Clear()
{
	SetHInst(NULL);
	SetFile(NULL);
	SetSection(NULL);
	SetEntry(NULL);
	SetPrimaryFile(NULL);
	SetRegPath(NULL);
    SetPrimaryRegPath(NULL);
    SetICSDataPath(NULL);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetSection
//
// Synopsis:  Sets the internal section suffix using the CIniW_Set 
//            helper function.
//
// Arguments: LPCWSTR pszSection - section suffix to remember
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::SetSection(LPCWSTR pszSection)
{
	CIniW_Set(&m_pszSection, pszSection);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetEntry
//
// Synopsis:  Sets the internal entry suffix using the CIniW_Set 
//            helper function.
//
// Arguments: LPCWSTR pszSection - entry suffix to remember
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::SetEntry(LPCWSTR pszEntry)
{
	CIniW_Set(&m_pszEntry, pszEntry);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetEntryFromIdx
//
// Synopsis:  Sets the internal entry suffix just as SetEntry does.  However,
//            the input parameter is a DWORD value that must be converted to
//            a string before it is stored as the index
//
// Arguments: DWORD dwEntry - index number to append to entries
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::SetEntryFromIdx(DWORD dwEntry)
{
	WCHAR szEntry[sizeof(dwEntry)*6+1];

	wsprintfU(szEntry, L"%u", dwEntry);
	SetEntry(szEntry);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::LoadSection
//
// Synopsis:  This function concatenates the given section parameter and the
//            section suffix and returns the result via the return value.  Note
//            that the memory must be freed by the calller.
//
// Arguments: LPCWSTR pszSection - base section to concatenate the suffix to
//
// Returns:   LPWSTR - a newly allocated string containing the pszSection value
//                     with the section suffix appended
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPWSTR CIniW::LoadSection(LPCWSTR pszSection) const
{
	return (CIniW_LoadCat(pszSection, m_pszSection));
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::LoadEntry
//
// Synopsis:  This function concatenates the given entry parameter and the
//            entry suffix and returns the result via the return value.  Note
//            that the memory must be freed by the calller.
//
// Arguments: LPCWSTR pszEntry - base entry to concatenate the suffix to
//
// Returns:   LPWSTR - a newly allocated string containing the pszEntry value
//                     with the entry suffix appended
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPWSTR CIniW::LoadEntry(LPCWSTR pszEntry) const
{

	return (CIniW_LoadCat(pszEntry ,m_pszEntry));
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::GPPS
//
// Synopsis:  CIni's version of GetPrivateProfileString.  Duplicates the Win32
//            API functionality except that it will append the Section and Entry
//            suffixes (if any) before calling the Win32 API.  The function all
//            allocates the string it returns in the return value which must be
//            freed by the caller.
//
// Arguments: LPCWSTR pszSection - Ini section to look for the data in
//            LPCWSTR pszEntry - Ini key name that contains the requested data
//            LPCWSTR pszDefault - default value to return if the key 
//                                 cannot be found
//
// Returns:   LPWSTR - the requested string value
//
// History:   quintinb Created Header    01/05/2000
//			  t-urama	modified		 07/15/2000
//
//+----------------------------------------------------------------------------
LPWSTR CIniW::GPPS(LPCWSTR pszSection, LPCWSTR pszEntry, LPCWSTR pszDefault) const
{
    LPWSTR pszSectionTmp = LoadSection(pszSection);
    LPWSTR pszEntryTmp = LoadEntry(pszEntry);
	LPWSTR pszBuffer = NULL;
    

    if (m_fReadICSData)
    {
        //
        // We need first read the data from ICSData reg key, if it's not present then try to 
        // get it from the file and then see if we have a primary file and read it from there.
        //
        pszBuffer = (LPWSTR)CIniW_GetEntryFromReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, REG_SZ, ((MAX_PATH + 1) * sizeof(TCHAR))); 
        if (NULL == pszBuffer)
        {
            LPWSTR pszICSTmp = NULL;
            pszBuffer = CIniW_GPPS(pszSectionTmp, pszEntryTmp, pszDefault, GetFile());
            
            if (m_pszPrimaryFile)
            {
                pszICSTmp = pszBuffer;
                pszBuffer = CIniW_GPPS(pszSectionTmp, pszEntryTmp, pszICSTmp, GetPrimaryFile());
            }

            if (NULL == pszBuffer)
            {
                if (pszDefault)
                {
                    pszBuffer = CmStrCpyAllocW(pszDefault);
                }
                else
                {
                    //
                    // We should not return a null from this wrapper, but an empty string instead
                    //
                    pszBuffer = CmStrCpyAllocW(L"");
                }
            }

            CmFree(pszICSTmp);
        }
    }
    else
    {
        //
        // If there is a reg path present. Registry access for m_pszFile
        // unless we want to read it from the file
        //
        if (m_pszRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
                pszBuffer = (LPWSTR) CIniW_GetEntryFromReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, REG_SZ, ((MAX_PATH + 1) * sizeof(TCHAR))); 
            }
        }

        if (NULL == pszBuffer)
        {
            // This could mean that there is no reg path, or that the reg access failed. Either way, we 
            // try to get the entry from pszFile
            //
            // Skip input pointer check since pszSection could be NULL to get all of 
            // the Section Names in the file, pszEntry could be NULL to get all of the
            // key names in a section, and pszDefault is NULL by default.
            // GetPrivateProfileString cannot take a NULL default but this is taken care of
            // by CIniW_GPPS.
            //
            pszBuffer = CIniW_GPPS(pszSectionTmp, pszEntryTmp, pszDefault, GetFile());
        }

        MYDBGASSERT(pszBuffer);

        // Now we try to get the entry from the primary file
        //
        LPWSTR pszTmp = NULL;

        if (m_pszPrimaryRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
                pszTmp = pszBuffer;
                pszBuffer = (LPWSTR) CIniW_GetEntryFromReg(HKEY_CURRENT_USER, m_pszPrimaryRegPath, pszEntryTmp, REG_SZ, ((MAX_PATH + 1) * sizeof(TCHAR)));
            }
        }

        if (NULL == pszBuffer)
        {
    
            // Skip input pointer check since pszSection could be NULL to get all of 
            // the Section Names in the file, pszEntry could be NULL to get all of the
            // key names in a section, and pszDefault is NULL by default.
            // GetPrivateProfileString cannot take a NULL default but this is taken care of
            // by CIniW_GPPS.
            //
            pszBuffer = CIniW_GPPS(pszSectionTmp, pszEntryTmp, pszTmp, GetPrimaryFile());
        
        }

        CmFree(pszTmp);
    }

    
    CmFree(pszEntryTmp);
    CmFree(pszSectionTmp);
    
    MYDBGASSERT(pszBuffer);
    
    return (pszBuffer);
}



//+----------------------------------------------------------------------------
//
// Function:  CIniW::GPPI
//
// Synopsis:  CIni's version of GetPrivateProfileInt.  Duplicates the Win32
//            API functionality except that it will append the Section and Entry
//            suffixes (if any) before calling the Win32 API.  The function all
//            allocates the string it returns in the return value which must be
//            freed by the caller.
//
// Arguments: LPCWSTR pszSection - Ini section to look for the data in
//            LPCWSTR pszEntry - Ini key name that contains the requested data
//            DWORD dwDefault - default value to return if the key 
//                              cannot be found
//
// Returns:   DWORD - the requested numerical value
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//+----------------------------------------------------------------------------
DWORD CIniW::GPPI(LPCWSTR pszSection, LPCWSTR pszEntry, DWORD dwDefault) const
{
	//
	//  GetPrivateProfileInt doesn't take NULL's for the section and entry
	//  parameters as GetPrivateProfileString will.  Thus check the values returned
	//  from LoadSection and LoadEntry, which will return NULL if the input parameter
	//  is either NULL or empty.  Since we don't really know what to do in this
	//  situation lets just assert and return the default value.
	//
    DWORD   dwRet = dwDefault;
	LPWSTR pszSectionTmp = LoadSection(pszSection);
	LPWSTR pszEntryTmp = LoadEntry(pszEntry);
	LPCWSTR pszFileTmp = GetFile();
    DWORD* pdwData = NULL;
	
    if (m_fReadICSData)
    {
        //
        // We need first read the data from ICSData reg key, if it's not present then try to 
        // get it from the file and then see if we have a primary file and read it from there.
        //
        pdwData = (DWORD*)CIniW_GetEntryFromReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, REG_DWORD, sizeof(DWORD));
        
        //
        // If we got something, assign it to the return value, otherwise try reading from the files
        // and using the default.
        //
        if (NULL == pdwData)
        {
            //
            // The registry access failed, or there is no reg. path. try to get the 
            // entry from pszFile
            //
            MYDBGASSERT(pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp);

            if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
            {
                dwRet = GetPrivateProfileIntU(pszSectionTmp, pszEntryTmp, dwDefault, pszFileTmp);
            }

            if (m_pszPrimaryFile)
            {
                //
                // The registry access failed, or there is no reg. path. try to get the 
                // entry from pszPrimaryFile
                //
        
                pszFileTmp = GetPrimaryFile();
                if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
                {
                    dwRet = GetPrivateProfileIntU(pszSectionTmp, pszEntryTmp, dwRet, pszFileTmp);
                }
            }
        }
        else
        {
            dwRet = *pdwData;
        }

    }
    else
    {
        //
        // Follow the normal rules
        // 
        if (m_pszRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
		        pdwData = (DWORD*)CIniW_GetEntryFromReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, REG_DWORD, sizeof(DWORD));
            }
        }

        if (NULL == pdwData)
        {
            //
            // The registry access failed, or there is no reg. path. try to get the 
            // entry from pszFile
            //
            MYDBGASSERT(pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp);

            if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
		    {
			    dwRet = GetPrivateProfileIntU(pszSectionTmp, pszEntryTmp, dwDefault, pszFileTmp);
		    }
        }
        else
	    {
		    dwRet = *pdwData;
	    }

        if (m_pszPrimaryRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
                CmFree(pdwData);

                pdwData = (DWORD*)CIniW_GetEntryFromReg(HKEY_CURRENT_USER, m_pszPrimaryRegPath, pszEntryTmp, REG_DWORD, sizeof(DWORD));
                if (pdwData)
                {
                    dwRet = *pdwData;
                }
            }
        }

        if (NULL == pdwData && m_pszPrimaryFile)
        {
            //
            // The registry access failed, or there is no reg. path. try to get the 
            // entry from pszPrimaryFile
            //
        
            pszFileTmp = GetPrimaryFile();
            if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
            {
	            dwRet = GetPrivateProfileIntU(pszSectionTmp, pszEntryTmp, dwRet, pszFileTmp);
            }
        }
    }

    CmFree(pdwData);
	CmFree(pszEntryTmp);
	CmFree(pszSectionTmp);

    return dwRet;
}
		
   

//+----------------------------------------------------------------------------
//
// Function:  CIniW::GPPB
//
// Synopsis:  CIni's version of GetPrivateProfileBool (which doesn't exactly
//            exist). Basically this function is the same as GPPI except that
//            the return value is cast to a BOOL value (1 or 0).
//
// Arguments: LPCWSTR pszSection - Ini section to look for the data in
//            LPCWSTR pszEntry - Ini key name that contains the requested data
//            DWORD dwDefault - default value to return if the key 
//                              cannot be found
//
// Returns:   DWORD - the requested BOOL value
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
BOOL CIniW::GPPB(LPCWSTR pszSection, LPCWSTR pszEntry, BOOL bDefault) const
{
    return (GPPI(pszSection, pszEntry, (DWORD)bDefault) != 0);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::WPPI
//
// Synopsis:  CIni's version of WritePrivateProfileInt (which doesn't exist as
//            a Win32 function).  Basically takes the inputted DWORD and prints
//            it into a string and then calls WPPS.
//
// Arguments: LPCWSTR pszSection - Ini section to write the data to
//            LPCWSTR pszEntry - Ini key name to store the data at
//            DWORD dwBuffer - Numeric value to write
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//
//+----------------------------------------------------------------------------
void CIniW::WPPI(LPCWSTR pszSection, LPCWSTR pszEntry, DWORD dwBuffer)
{
    // Technically pszEntry could be NULL, which would erase all of the keys in
    // the section pointed to by pszSection.  However, this doesn't seem to be
    // in the spirit of this wrapper so we will check both string pointers to make
    // sure they are valid.
	BOOL bRes = FALSE;

	//
    // Check is we are allowed to save info
    //
	if ((NULL != pszSection) && (L'\0' != pszSection[0]) &&
        (NULL != pszEntry) && (L'\0' != pszEntry[0]))
    {
		LPWSTR pszEntryTmp = LoadEntry(pszEntry);
			
	    MYDBGASSERT(pszEntryTmp || (NULL == pszEntry) || (L'\0' == pszEntry[0]));

        if (m_pszRegPath)
		{
			
			if (NULL != pszEntryTmp && *pszEntryTmp)
			{
    			bRes = CIniW_WriteEntryToReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, (BYTE *) &dwBuffer, REG_DWORD, sizeof(DWORD));
			}
		}
		
		if (!bRes)
		{
			// This loop is only entered if we are trying to write to the cmp and the registry 
			// write failed, or we are writing to the cms, in which case we will not even 
			// try to write to the reg.

            LPWSTR pszSectionTmp = LoadSection(pszSection);
	        LPCWSTR pszFileTmp = GetFile();
			        
	        MYDBGASSERT(pszFileTmp && *pszFileTmp);
	        MYDBGASSERT(pszSectionTmp && *pszSectionTmp);

            WCHAR szBuffer[sizeof(dwBuffer)*6+1];
    	
			wsprintfU(szBuffer, L"%u", dwBuffer);
					
			if (pszFileTmp && *pszFileTmp && pszSectionTmp && *pszSectionTmp && pszEntryTmp && *pszEntryTmp)
			{
    			bRes = WritePrivateProfileStringU(pszSectionTmp, pszEntryTmp, szBuffer, pszFileTmp);
			}
            if (!bRes)
            {
                DWORD dwError = GetLastError();
                CMTRACE3W(L"CIniW::WPPI() WritePrivateProfileString[*pszSection=%s,*pszEntry=%s,*pszBuffer=%s", pszSectionTmp, MYDBGSTRW(pszEntryTmp), MYDBGSTRW(szBuffer));
                CMTRACE2W(L"*pszFile=%s] failed, GLE=%u", pszFileTmp, dwError);
            }
            CmFree(pszSectionTmp);
               	
		}

        if (m_fWriteICSData)
        {
            if (NULL != pszEntryTmp && *pszEntryTmp)
			{
    			bRes = CIniW_WriteEntryToReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, (BYTE *) &dwBuffer, REG_DWORD, sizeof(DWORD));
			}
        }

        CmFree(pszEntryTmp);
    }
	else
    {
        CMASSERTMSG(FALSE, "Invalid input paramaters to CIniW::WPPI");
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::WPPB
//
// Synopsis:  CIni's version of WritePrivateProfileBool (which doesn't exist as
//            a Win32 function).  Basically takes the inputted BOOL and prints
//            either 1 or 0 into a string and then calls WPPI.
//
// Arguments: LPCWSTR pszSection - Ini section to write the data to
//            LPCWSTR pszEntry - Ini key name to store the data at
//            DWORD dwBuffer - Numeric value to write
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::WPPB(LPCWSTR pszSection, LPCWSTR pszEntry, BOOL bBuffer)
{

	WPPI(pszSection, pszEntry, bBuffer ? 1 : 0);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::WPPS
//
// Synopsis:  CIni's version of WritePrivateProfileString
//
// Arguments: LPCWSTR pszSection - Ini section to write the data to
//            LPCWSTR pszEntry - Ini key name to store the data at
//            LPCWSTR pszBuffer - data buffer to write to the ini file
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//
//+----------------------------------------------------------------------------
void CIniW::WPPS(LPCWSTR pszSection, LPCWSTR pszEntry, LPCWSTR pszBuffer) 
{
    
    LPWSTR pszEntryTmp = LoadEntry(pszEntry);
    LPWSTR pszSectionTmp = LoadSection(pszSection);
	LPCWSTR pszFileTmp = GetFile();
			
	MYDBGASSERT(pszFileTmp && *pszFileTmp);
	MYDBGASSERT(pszSectionTmp && *pszSectionTmp);
    // Both pszEntry and pszBuffer could be NULL or Empty.  However, pszSection and
    // the file path must not be NULL or empty.  We also don't want to have a non-NULL
    // or non-Empty value for pszEntry and then get a NULL value back from LoadEntry
    // (indicating that LoadEntry had text to duplicate but failed for some reason).
    // Writing with a NULL value accidently will delete the key value we were trying to set.
    // Make sure to assert and prevent data loss in this case.
    //

   
    MYDBGASSERT(pszEntryTmp || (NULL == pszEntry) || (L'\0' == pszEntry[0]));

	//
    // Check is we are allowed to save info
    //
    if(pszEntryTmp || (NULL == pszEntry) || (L'\0' == pszEntry[0]))
    {	
		BOOL bRes = FALSE;
		
		// First try to write to registry if pszRegPath exists

		if (m_pszRegPath)
		{
            if (NULL == pszBuffer)
            {
                CIniW_DeleteEntryFromReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp);
                bRes = TRUE; // never erase from the cmp or cms file if there is a regpath.
            }
            else
            {
			    DWORD dwSize = (lstrlenU(pszBuffer) + 1) * sizeof(WCHAR);            
        
			    bRes = CIniW_WriteEntryToReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, (BYTE *) pszBuffer, REG_SZ, dwSize);
            }
		}

		if (!bRes)
		{
			// This loop is only entered if we are trying to write to the cmp and the registry 
			// write failed, or we are writing to the cms, in which case we will not even 
			// try to write to the reg.
			
			
			if (pszFileTmp && *pszFileTmp && pszSectionTmp && *pszSectionTmp )
			{
    			bRes = WritePrivateProfileStringU(pszSectionTmp, pszEntryTmp, pszBuffer, pszFileTmp);
			}
		}
        if (!bRes)
        {
            DWORD dwError = GetLastError();
            CMTRACE3W(L"CIniW::WPPS() WritePrivateProfileString[*pszSection=%s,*pszEntry=%s,*pszBuffer=%s", pszSectionTmp, MYDBGSTRW(pszEntryTmp), MYDBGSTRW(pszBuffer));
            CMTRACE2W(L"*pszFile=%s] failed, GLE=%u", pszFileTmp, dwError);
        }

        if (m_fWriteICSData)
        {
            if (NULL == pszBuffer)
            {
                CIniW_DeleteEntryFromReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp);
                bRes = TRUE; // never erase from the cmp or cms file if there is a regpath.
            }
            else
            {
			    DWORD dwSize = (lstrlenU(pszBuffer) + 1) * sizeof(WCHAR);            
        
			    bRes = CIniW_WriteEntryToReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, (BYTE *) pszBuffer, REG_SZ, dwSize);
            }

        }
    }

    CmFree(pszEntryTmp);
    CmFree(pszSectionTmp);
	
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::GetSection
//
// Synopsis:  Accessor function for the Section suffix member variable.  Will
//            return the empty string if m_pszSection is NULL.
//
// Arguments: None
//
// Returns:   LPCWSTR - Value of the section suffix member variable or "" 
//                      if it is NULL
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPCWSTR CIniW::GetSection() const
{
	return (m_pszSection ? m_pszSection : L"");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::GetPrimaryFile
//
// Synopsis:  Accessor function for the Primary File member variable.  Will
//            return the empty string if m_pszPrimaryFile is NULL.
//
// Arguments: None
//
// Returns:   LPCWSTR - Value of the primary file member variable or "" 
//                      if it is NULL
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPCWSTR CIniW::GetPrimaryFile() const
{
    return (m_pszPrimaryFile ? m_pszPrimaryFile : L"");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::GetHInst
//
// Synopsis:  Accessor function for the m_hInst member variable.
//
// Arguments: None
//
// Returns:   HINSTANCE - Value of the m_hInst
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
HINSTANCE CIniW::GetHInst() const
{
	return (m_hInst);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetFile
//
// Synopsis:  Function to set the m_pszFile member variable.  Uses CIni_SetFile.
//            Note that if the input parameter is NULL or the empty string then
//            m_pszFile will be set to NULL.
//
// Arguments: LPCWSTR pszFile - full path to set the m_pszFile member var to
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::SetFile(LPCWSTR pszFile) 
{
    CIni_SetFile(&m_pszFile, pszFile);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetPrimaryFile
//
// Synopsis:  Function to set the m_pszPrimaryFile member variable.  Uses CIni_SetFile.
//            Note that if the input parameter is NULL or the empty string then
//            m_pszPrimaryFile will be set to NULL.
//
// Arguments: LPCWSTR pszFile - full path to set the m_pszPrimaryFile member var to
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::SetPrimaryFile(LPCWSTR pszFile) 
{
    CIni_SetFile(&m_pszPrimaryFile, pszFile);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::GetFile
//
// Synopsis:  Accessor function for the File member variable.  Will
//            return the empty string if m_pszFile is NULL.
//
// Arguments: None
//
// Returns:   LPCWSTR - the contents of m_pszFile or "" if it is NULL
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPCWSTR CIniW::GetFile() const
{
    return (m_pszFile ? m_pszFile : L"");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetHInst
//
// Synopsis:  Function to set the m_hInst member variable.
//
// Arguments: HINSTANCE hInst - instance handle to set m_hInst to
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::SetHInst(HINSTANCE hInst) 
{
    m_hInst = hInst;
}

//
//	Loading sections by string resource isn't used anymore
//
#if 0

LPWSTR CIniW::LoadSection(UINT nSection) const
{
	LPWSTR pszTmp;

	pszTmp = CmLoadStringW(GetHInst(), nSection);
	CmStrCatAllocW(&pszTmp, GetSection());
	return (pszTmp);
}
#endif

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetRegPath
//
// Synopsis:  Sets the registry path for registry access
//
// Arguments: LPCSTR pszRegPath - entry suffix to remember
//
// Returns:   Nothing
//
// History:   t-urama Created Header    07/13/2000
//
//+----------------------------------------------------------------------------

void CIniW::SetRegPath(LPCWSTR pszRegPath)
{
	CIniW_Set(&m_pszRegPath, pszRegPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetPrimaryRegPath
//
// Synopsis:  Sets the registry path for primary file registry access
//
// Arguments: LPCSTR pszPrimaryRegPath - Primary reg path 
//
// Returns:   Nothing
//
// History:   t-urama Created Header    07/13/2000
//
//+----------------------------------------------------------------------------

void CIniW::SetPrimaryRegPath(LPCWSTR pszPrimaryRegPath)
{
	CIniW_Set(&m_pszPrimaryRegPath, pszPrimaryRegPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetICSDataPath
//
// Synopsis:  Sets the internal registry key to store data for ICS.
//            Need to make sure the string isn't empty since we don't want
//            to write in HKLM
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   03/30/2001    tomkel      Created 
//
//+----------------------------------------------------------------------------
void CIniW::SetICSDataPath(LPCWSTR pszICSPath)
{
    CIniW_Set(&m_pszICSDataPath, pszICSPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetReadICSData
//
// Synopsis:  Sets the read flag, to read data from the ICS registry key.
//
// Arguments: fValue
//
// Returns:   Nothing
//
// History:   03/30/2001    tomkel      Created 
//
//+----------------------------------------------------------------------------
void CIniW::SetReadICSData(BOOL fValue)
{
    m_fReadICSData = fValue;
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetWriteICSData
//
// Synopsis:  Sets the write flag, to write data to the ICS registry key.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   03/30/2001    tomkel      Created 
//
//+----------------------------------------------------------------------------
void CIniW::SetWriteICSData(BOOL fValue)
{
    m_fWriteICSData = fValue;
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::CiniW_WriteEntryToReg
//
// Synopsis:  Function to write and entry to the registry. 
//
// Arguments: HKEY hKey 
//            LPCWSTR pszRegPathTmp - reg key name
//            LPCWSTR pszEntry - Registry value name to which data is to be written
//			  CONST BYTE *lpData - Data to be written
//            DWORD dwType - The type of value to be entered
//			  DWORD dwSize - The size of the value entered
//
// Returns:   BOOL - Success or failure
//
// History:   t-urama Created Header    07/15/2000
//
//+----------------------------------------------------------------------------
BOOL CIniW::CIniW_WriteEntryToReg(HKEY hKey, LPCWSTR pszRegPathTmp, LPCWSTR pszEntry, CONST BYTE *lpData, DWORD dwType, DWORD dwSize) const
{
   MYDBGASSERT(pszEntry && *pszEntry);
   MYDBGASSERT(lpData);
   MYDBGASSERT(pszRegPathTmp && *pszRegPathTmp);

    

   if (NULL == pszEntry || !*pszEntry || NULL == lpData || NULL == pszRegPathTmp || !*pszRegPathTmp || NULL == hKey)
    {
        return FALSE;
    }

   HKEY    hKeyCm;
   DWORD   dwDisposition;

   DWORD dwRes = RegCreateKeyExU(hKey,
                                 pszRegPathTmp,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_ALL_ACCESS,
                                 NULL,
                                 &hKeyCm,
                                 &dwDisposition);


	//
    // If we opened the key successfully, write the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {                        
        dwRes = RegSetValueExU(hKeyCm, 
                               pszEntry, 
                               0, 
                               dwType,
                               lpData, 
                               dwSize);             

        
        RegCloseKey(hKeyCm);
    }
#ifdef DEBUG
        if (ERROR_SUCCESS != dwRes)
        {
            CMTRACE1(TEXT("CIniW_WriteEntryToReg() - %s failed"), (LPWSTR)pszEntry);
        }
#endif

    return (ERROR_SUCCESS == dwRes);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::CiniW_GetEntryFromReg
//
// Synopsis:  Function to get the value from the registry. The function 
//            allocates the string it returns in the return value which must be
//            freed by the caller.
//
// Arguments: HKEY hKey - reg hkey
//            LPCWSTR pszRegPathTmp - reg key
//            LPCWSTR pszEntry - Registry value name that contains the requested data
//            DORD dwType - Type of value
//            DWORD dwSize - Size of value
//
// Returns:   LPBYTE - the requested value
//
// History:   07/15/2000    t-urama Created Header    
//            04/03/2001    tomkel  Added hkey and reg key path name to parameters
//
//+----------------------------------------------------------------------------
LPBYTE CIniW::CIniW_GetEntryFromReg(HKEY hKey, LPCWSTR pszRegPathTmp, LPCWSTR pszEntry, DWORD dwType, DWORD dwSize) const
    
{    
    MYDBGASSERT(pszEntry);

    if (NULL == pszEntry || !*pszEntry || NULL == pszRegPathTmp || !*pszRegPathTmp || NULL == hKey)
    {
        return NULL;
    }
    
    //
    // Everything is ok. We have a reg path and a entry name. 
    //

    LPBYTE lpData = NULL;
    DWORD dwTypeTmp = dwType;
    DWORD dwSizeTmp = dwSize;
    HKEY hKeyCm;
 
    //
    // Open the sub key under hKey
    //

    DWORD dwRes = RegOpenKeyExU(hKey,
                               pszRegPathTmp,
                               0,
                               KEY_QUERY_VALUE,
                               &hKeyCm);
    //
    // If we opened the key successfully, retrieve the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {
        do
        {
            //
            //	Allocate a buffer
            //
            CmFree(lpData);
            lpData = (BYTE *) CmMalloc(dwSizeTmp);

            if (NULL == lpData)
            {
                RegCloseKey(hKeyCm);
                return FALSE;
            }

            dwRes = RegQueryValueExU(hKeyCm, 
                                     pszEntry,
                                     NULL,
                                     &dwTypeTmp,
                                     lpData, 
                                     &dwSizeTmp);

        } while (ERROR_MORE_DATA == dwRes);

		RegCloseKey(hKeyCm);
	}
	
	if (ERROR_SUCCESS == dwRes && dwTypeTmp == dwType)
	{
		return lpData;     
	}
	else
	{
		CmFree(lpData);
		return NULL;
	}

}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::CiniW_GetRegPath
//
// Synopsis:  Function to get the value ofm_pszRegPath
//
// Arguments: none
//
// Returns:   LPWCSTR - Value of m_pszRegPath
//
// History:   t-urama Created Header    07/15/2000
//
//+----------------------------------------------------------------------------
LPCWSTR CIniW::GetRegPath() const
{
	return (m_pszRegPath ? m_pszRegPath : L"");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::CiniW_GetPrimaryRegPath
//
// Synopsis:  Function to get the value ofm_pszPrimaryRegPath
//
// Arguments: none
//
// Returns:   LPWCSTR - Value of m_pszPrimaryRegPath
//
// History:   t-urama Created     07/15/2000
//
//+----------------------------------------------------------------------------
LPCWSTR CIniW::GetPrimaryRegPath() const
{
	return (m_pszPrimaryRegPath ? m_pszPrimaryRegPath : L"");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::CiniW_DeleteEntryFromReg
//
// Synopsis:  Function to delete an entry from the registry. 
//
// Arguments: HKEY hKey
//            LPCWSTR pszRegPathTmp - reg key name
//            LPCWSTR pszEntry - Registry value name to be deleted
//
// Returns:   BOOL - Success or failure
//
// History:   07/15/2000    t-urama Created
//            04/03/2001    tomkel  Added Hkey and reg key name to parameters
//
//+----------------------------------------------------------------------------
BOOL CIniW::CIniW_DeleteEntryFromReg(HKEY hKey, LPCWSTR pszRegPathTmp, LPCWSTR pszEntry) const
{
    
    MYDBGASSERT(pszEntry);

    if (NULL == pszEntry || !*pszEntry || NULL == pszRegPathTmp || !*pszRegPathTmp || NULL == hKey)
    {
        return FALSE;
    }
       
    //
    // Everything is ok. We have a reg path and a entry name.
    //
    
    HKEY    hKeyCm;
    BOOL dwRes = RegOpenKeyExU(hKey,
                               pszRegPathTmp,
                               0,
                               KEY_SET_VALUE,
                               &hKeyCm);

    //
    // If we opened the key successfully, retrieve the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {                        
        dwRes = RegDeleteValueU(hKeyCm, pszEntry);
        RegCloseKey(hKeyCm);
    }

    return (ERROR_SUCCESS == dwRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmutil\atol.cpp ===
//+----------------------------------------------------------------------------
//
// File:     atol.cpp (from libc atox.c)
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Conversion routines
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:	 henryt     Created   03/01/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//+----------------------------------------------------------------------------
//
// Function:  WINAPI CmAtolW
//
// Synopsis:  This function converts a Unicode string to a long
//
// Arguments: *nptr - Unicode string to convert
//
// Returns:   LONG - long representation of the string passed in
//
// History:   quintinb Rewrote for Unicode conversion     4/8/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LONG WINAPI CmAtolW(const WCHAR *nptr)
{
    WCHAR* pszCurrent = (WCHAR*)nptr;
    WCHAR sign = L'\0';       // if '-', then negative, otherwise positive
    long total = 0;           // current total

    MYDBGASSERT(nptr);

    if (nptr)
    {
        //
        //  skip whitespace
        //
        while (CmIsSpaceW(pszCurrent))
        {
            pszCurrent = CharNextU(pszCurrent);
        }

        //
        //  Save the sign if necessary
        //
        sign = *pszCurrent;
        if ((L'-' == sign) || (L'+' == sign))
        {
            pszCurrent = CharNextU(pszCurrent);
        }

        //
        //  Construct the number
        //
        total = 0;

        while (CmIsDigitW(pszCurrent))
        {
            total = (10 * total) + (*pszCurrent - L'0');     // accumulate digit
            pszCurrent = CharNextU(pszCurrent);  // get next char
        }
    }

    if (sign == L'-')
    {
        return -total;
    }
    else
    {
        return total;   // return result, negated if necessary
    }
}

//+----------------------------------------------------------------------------
//
// Function:  WINAPI CmAtolA
//
// Synopsis:  This function converts an ANSI string to a long value
//
// Arguments: *nptr - string to convert
//
// Returns:   LONG - long representation of the string passed in
//
// History:   quintinb Rewrote for Unicode conversion     4/8/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LONG WINAPI CmAtolA(const CHAR *nptr)
{
    CHAR* pszCurrent = (CHAR*)nptr;
    CHAR sign = '\0';           // if '-', then negative, otherwise positive
    long total = 0;           // current total

    MYDBGASSERT(nptr);

    if (nptr)
    {
        //
        //  skip whitespace
        //
        while (CmIsSpaceA(pszCurrent))
        {
            pszCurrent = CharNextA(pszCurrent);
        }

        //
        //  Save the sign if necessary
        //
        sign = *pszCurrent;
        if (('-' == sign) || ('+' == sign))
        {
            pszCurrent = CharNextA(pszCurrent);
        }

        //
        //  Construct the number
        //
        total = 0;

        while (CmIsDigitA(pszCurrent))
        {
            total = (10 * total) + (*pszCurrent - '0');     // accumulate digit
            pszCurrent = CharNextA(pszCurrent);  // get next char
        }
    }

    if (sign == '-')
    {
        return -total;
    }
    else
    {
        return total;   // return result, negated if necessary
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmutil\cmlogstr.h ===
//+----------------------------------------------------------------------------
//
// File:    CmLogStr.h
//
// Module:  CMLOG.LIB
//
// Synopsis: Resource ID definitions for Connection Manager Logging
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  24-May-2000 SumitC  Created
//
// Note:
//
//-----------------------------------------------------------------------------


#define IDS_LOGDESC_LOGENABLED                  15000
#define IDS_LOGDESC_LOGDISABLED                 15001
#define IDS_LOGDESC_PREINIT                     15002
#define IDS_LOGFMT_PREINIT                      15003
#define IDS_LOGDESC_PRECONNECT                  15004
#define IDS_LOGFMT_PRECONNECT                   15005
#define IDS_LOGDESC_PREDIAL                     15006
#define IDS_LOGFMT_PREDIAL                      15007
#define IDS_LOGDESC_PRETUNNEL                   15008
#define IDS_LOGFMT_PRETUNNEL                    15009
#define IDS_LOGDESC_CONNECT                     15010
#define IDS_LOGDESC_CUSTOMACTIONDLL             15011
#define IDS_LOGFMT_CUSTOMACTIONDLL              15012
#define IDS_LOGDESC_CUSTOMACTIONEXE             15013
#define IDS_LOGFMT_CUSTOMACTIONEXE              15014
#define IDS_LOGDESC_DISCONNECT                  15015
#define IDS_LOGFMT_DISCONNECT                   15016
#define IDS_LOGDESC_RECONNECT                   15017
#define IDS_LOGDESC_RETRYAUTH                   15018
#define IDS_LOGDESC_CALLBACKNUMBER              15019
#define IDS_LOGFMT_CALLBACKNUMBER               15020
#define IDS_LOGDESC_PWDEXPIRED                  15021
#define IDS_LOGFMT_PWDEXPIRED                   15022
#define IDS_LOGDESC_PWDRESET                    15023
#define IDS_LOGFMT_PWDRESET                     15024
#define IDS_LOGDESC_CUSTOMBUTTON                15025
#define IDS_LOGDESC_ONCANCEL                    15026
#define IDS_LOGDESC_ONERROR                     15027
#define IDS_LOGFMT_ONERROR                      15028
#define IDS_LOGDESC_CLEARLOG                    15029
#define IDS_LOGDESC_EXT_DISCONNECT              15030
#define IDS_LOGDESC_INT_DISCONNECT_MANUAL       15031
#define IDS_LOGDESC_INT_DISCONNECT_AUTO         15032
#define IDS_LOGDESC_EXT_DISCONNECT_LOST_CONN    15033
#define IDS_LOGDESC_CUSTOMACTION_NOT_ALLOWED    15034
#define IDS_LOGFMT_CUSTOMACTION_NOT_ALLOWED     15035
#define IDS_LOGDESC_CUSTOMACTION_WONT_RUN       15036
#define IDS_LOGFMT_CUSTOMACTION_WONT_RUN        15037
#define IDS_LOGDESC_PB_DOWNLOAD_SUCCESS         15038
#define IDS_LOGFMT_PB_DOWNLOAD_SUCCESS          15039
#define IDS_LOGDESC_PB_DOWNLOAD_FAILURE         15040
#define IDS_LOGFMT_PB_DOWNLOAD_FAILURE          15041
#define IDS_LOGDESC_PB_UPDATE_SUCCESSFUL        15042
#define IDS_LOGFMT_PB_UPDATE_SUCCESSFUL         15043
#define IDS_LOGDESC_PB_UPDATE_FAILED_PBS        15044
#define IDS_LOGFMT_PB_UPDATE_FAILED_PBS         15045
#define IDS_LOGDESC_PB_UPDATE_FAILED_CMPBK      15046
#define IDS_LOGFMT_PB_UPDATE_FAILED_CMPBK       15047
#define IDS_LOGDESC_PB_ABORTED                  15048
#define IDS_LOGDESC_CUSTOMACTION_SKIPPED        15049
#define IDS_LOGFMT_CUSTOMACTION_SKIPPED         15050
#define IDS_LOGDESC_VPN_DOWNLOAD_SUCCESS        15051
#define IDS_LOGFMT_VPN_DOWNLOAD_SUCCESS         15052
#define IDS_LOGDESC_VPN_DOWNLOAD_FAILURE        15053
#define IDS_LOGFMT_VPN_DOWNLOAD_FAILURE         15054
#define IDS_LOGDESC_VPN_UPDATE_SUCCESSFUL       15055
#define IDS_LOGFMT_VPN_UPDATE_SUCCESSFUL        15056
#define IDS_LOGDESC_VPN_UPDATE_FAILURE          15057
#define IDS_LOGFMT_VPN_UPDATE_FAILURE           15058
#define IDS_LOGFMT_ONERROR_W_SAFENET            15059
#define IDS_LOGDESC_ONERROR_W_SAFENET           15060
#define IDS_LOGDESC_SN_ADAPTER_CHANGE           15061
#define IDS_LOGFMT_SN_ADAPTER_CHANGE            15062

#define IDS_LOGFMT_BANNER                       16000
#define IDS_LOGSTR_ALLUSERS                     16001
#define IDS_LOGSTR_SINGLEUSER                   16002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmutil\cinia.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ciniA.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Ansi CIni implementation
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   henryt - relocated to CMUTIL           03/15/98
//           quintinb - created A and W versions    05/12/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//+----------------------------------------------------------------------------
//
// Function:  CIniA_Set
//
// Synopsis:  This function takes a pointer to a string and a string as arguments.  It
//            frees the string currently in the destination pointer, allocates the correct
//            amount of memory and then copies the source string to the string pointed
//            to by the destination string pointer.  The allocated memory is the
//            responsibility of the caller.
//
// Arguments: LPSTR *ppszDest - pointer to the destination string
//            LPCSTR pszSrc - source string for the set
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
static void CIniA_Set(LPSTR *ppszDest, LPCSTR pszSrc)
{
    MYDBGASSERT(ppszDest);

    if (ppszDest)
    {
        CmFree(*ppszDest);
        *ppszDest = ((pszSrc && *pszSrc) ? CmStrCpyAllocA(pszSrc) : NULL);    
    }
}


//+----------------------------------------------------------------------------
//
// Function:  CIniA_LoadCat
//
// Synopsis:  This function concatenates the suffix argument onto the string
//            argument and returns the resulting string through the return
//            value.  Note that the function allocates the correct amount of
//            memory which must be freed by the caller.  Also not passing in
//            an empty string returns NULL while passing just an empty suffix
//            returns just a copy of the string.
//
// Arguments: LPCSTR pszStr - source string to duplicate
//            LPCSTR pszSuffix - suffix to add onto the duplicated string
//
// Returns:   LPSTR - a duplicate of the concatenated string
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
static LPSTR CIniA_LoadCat(LPCSTR pszStr, LPCSTR pszSuffix)
{
    LPSTR pszTmp;

    if (!pszStr || !*pszStr)
    {
        return (NULL);
    }

    if (!pszSuffix || !*pszSuffix)
    {
        pszTmp = CmStrCpyAllocA(pszStr);
    }
    else
    {
        pszTmp = CmStrCpyAllocA(pszStr);

        if (pszTmp)
        {
            CmStrCatAllocA(&pszTmp,pszSuffix);
        }
    }

    MYDBGASSERT(pszTmp);

    return (pszTmp);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA_GPPS
//
// Synopsis:  Wrapper for the Windows API GetPrivateProfileString.  The return
//            value is the requested value, allocated on behalf of the caller.
//            Note that the function assumes a reasonable default size and then
//            loops and reallocates until it can fit the whole string.
//
// Arguments: LPCSTR pszSection - Ini file section to retrieve data from
//            LPCSTR pszEntry - key name to retrieve data from
//            LPCSTR pszDefault - the default string value to return, defaults
//                                to the empty string ("") if not specified
//            LPCSTR pszFile - full path to the ini file to get the data from
//
// Returns:   LPSTR - the requested data from the ini file, must be freed 
//                    by the caller
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
static LPSTR CIniA_GPPS(LPCSTR pszSection, LPCSTR pszEntry, LPCSTR pszDefault, LPCSTR pszFile)
 {
    LPSTR pszBuffer;
    LPCSTR pszLocalDefault = pszDefault ? pszDefault : "";

    if ((NULL == pszFile) || ('\0' == *pszFile))
    {
        CMASSERTMSG(FALSE, "CIniA_GPPS -- NULL or Empty file path passed.");
        return CmStrCpyAllocA(pszLocalDefault);
    }
    
    size_t nLen = __max((pszDefault ? lstrlenA(pszDefault) : 0) +4,48);

    while (1)
    {
        size_t nNewLen;

        pszBuffer = (LPSTR) CmMalloc(nLen*sizeof(CHAR));
		
        MYDBGASSERT(pszBuffer);

        if (pszBuffer)
        {
            nNewLen = GetPrivateProfileStringA(pszSection, pszEntry, pszLocalDefault,
                                               pszBuffer, nLen, pszFile);

            if (nNewLen+2 < nLen) 
            {
                return (pszBuffer);
            }

            CmFree(pszBuffer);
            nLen *= 2;
        }
        else
        {
            CMASSERTMSG(FALSE, "CIniA_GPPS -- CmMalloc Failed.");
            return CmStrCpyAllocA(pszLocalDefault);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CIni_SetFile
//
// Synopsis:  This function is very similar to CIniA_Set in that it takes
//            a source string and duplicates it into the string pointed to
//            by the destination pointer.  However, the difference is that
//            this function assumes the pszSrc argument to be a full path to
//            a file and thus calls CreateFile on the pszSrc string
//            before duplicating the string.
//
// Arguments: LPSTR* ppszDest - pointer to a string to accept the duplicated buffer
//            LPCSTR pszSrc - full path to a file, text to be duplicated
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::CIni_SetFile(LPSTR *ppszDest, LPCSTR pszSrc) 
{
    MYDBGASSERT(ppszDest);

    if (ppszDest)
    {
        CmFree(*ppszDest);           
        *ppszDest = NULL;

        if (pszSrc && *pszSrc) // pszSrc could be NULL
        {
            //
            // A full path to an existing file is expected
            //
	    
            HANDLE hFile = CreateFileA(pszSrc, 0, 
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

            MYDBGASSERT(hFile != INVALID_HANDLE_VALUE);

            if (hFile != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFile);

                //
                // Update internal file
                //

                *ppszDest = CmStrCpyAllocA(pszSrc);
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::CIniA
//
// Synopsis:  CIniA constructor
//
// Arguments: HINSTANCE hInst - Instance handle used to load resources
//            LPCSTR pszFile - Ini file the object describes
//            LPCSTR pszSection - a section suffix that will be appended to 
//                                all section references
//			  LPCSTR pszRegPath - a path to be used for registry access
//            LPCSTR pszEntry - an entry suffix that will be appended to all 
//                              entry references
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama Modified			 07/19/2000
//
//+----------------------------------------------------------------------------
CIniA::CIniA(HINSTANCE hInst, LPCSTR pszFile, LPCSTR pszRegPath, LPCSTR pszSection, LPCSTR pszEntry) 
{
    //
    //  Input pointers default to NULL and in fact the constructor is rarely called
    //  with parameters.  Thus we will skip checking the input pointers and just
    //  pass them on to the functions below, which are designed to except NULL inputs.
    //

    m_hInst = hInst;

    //
    //  Make sure to NULL the string params before setting them below.  This
    //  is because we call free on the inputted params and we don't want to try
    //  to free garbage.
    //
	m_pszFile = NULL;
	m_pszSection = NULL;
	m_pszEntry = NULL;	
	m_pszPrimaryFile = NULL;
	m_pszRegPath = NULL;
    m_pszPrimaryRegPath = NULL;
    m_pszICSDataPath = NULL;
    m_fReadICSData = FALSE;
    m_fWriteICSData = FALSE;

    SetFile(pszFile);
	SetSection(pszSection);
	SetEntry(pszEntry);
	SetRegPath(pszRegPath);
}


//+----------------------------------------------------------------------------
//
// Function:  CIniA::~CIniA
//
// Synopsis:  CIniA destructor, frees dynamically allocated strings held onto
//            by the CIniA object.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//+----------------------------------------------------------------------------
CIniA::~CIniA()
{
	CmFree(m_pszFile);
	CmFree(m_pszSection);
	CmFree(m_pszEntry);
	CmFree(m_pszPrimaryFile);
	CmFree(m_pszRegPath);
    CmFree(m_pszPrimaryRegPath);
    CmFree(m_pszICSDataPath);
}


//+----------------------------------------------------------------------------
//
// Function:  CIniA::Clear
//
// Synopsis:  Clears all of the member variables of the CIniA class.  Used
//            so that a single CIniA object can be re-used without having to
//            destruct the old object and construct a new one.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//+----------------------------------------------------------------------------
void CIniA::Clear()
{
	SetHInst(NULL);
	SetFile(NULL);
	SetSection(NULL);
	SetEntry(NULL);
	SetPrimaryFile(NULL);
	SetRegPath(NULL);
    SetPrimaryRegPath(NULL);
    SetICSDataPath(NULL);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetSection
//
// Synopsis:  Sets the internal section suffix using the CIniA_Set 
//            helper function.
//
// Arguments: LPCSTR pszSection - section suffix to remember
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::SetSection(LPCSTR pszSection)
{
	CIniA_Set(&m_pszSection, pszSection);
}


//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetEntry
//
// Synopsis:  Sets the internal entry suffix using the CIniA_Set 
//            helper function.
//
// Arguments: LPCSTR pszSection - entry suffix to remember
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::SetEntry(LPCSTR pszEntry)
{
	CIniA_Set(&m_pszEntry, pszEntry);
}


//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetEntryFromIdx
//
// Synopsis:  Sets the internal entry suffix just as SetEntry does.  However,
//            the input parameter is a DWORD value that must be converted to
//            a string before it is stored as the index
//
// Arguments: DWORD dwEntry - index number to append to entries
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::SetEntryFromIdx(DWORD dwEntry)
{
	CHAR szEntry[sizeof(dwEntry)*6+1];

	wsprintfA(szEntry, "%u", dwEntry);
	SetEntry(szEntry);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::LoadSection
//
// Synopsis:  This function concatenates the given section parameter and the
//            section suffix and returns the result via the return value.  Note
//            that the memory must be freed by the calller.
//
// Arguments: LPCSTR pszSection - base section to concatenate the suffix to
//
// Returns:   LPSTR - a newly allocated string containing the pszSection value
//                    with the section suffix appended
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPSTR CIniA::LoadSection(LPCSTR pszSection) const
{
	return (CIniA_LoadCat(pszSection, m_pszSection));
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::LoadEntry
//
// Synopsis:  This function concatenates the given entry parameter and the
//            entry suffix and returns the result via the return value.  Note
//            that the memory must be freed by the calller.
//
// Arguments: LPCSTR pszEntry - base entry to concatenate the suffix to
//
// Returns:   LPSTR - a newly allocated string containing the pszEntry value
//                    with the entry suffix appended
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPSTR CIniA::LoadEntry(LPCSTR pszEntry) const
{
	return (CIniA_LoadCat(pszEntry, m_pszEntry));
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::GPPS
//
// Synopsis:  CIni's version of GetPrivateProfileString.  Duplicates the Win32
//            API functionality except that it will append the Section and Entry
//            suffixes (if any) before calling the Win32 API.  The function all
//            allocates the string it returns in the return value which must be
//            freed by the caller.
//
// Arguments: LPCSTR pszSection - Ini section to look for the data in
//            LPCSTR pszEntry - Ini key name that contains the requested data
//            LPCSTR pszDefault - default value to return if the key 
//                                cannot be found
//
// Returns:   LPSTR - the requested string value
//
// History:   quintinb Created Header    01/05/2000
//			  t-urama	modified		 07/15/2000
//
//+----------------------------------------------------------------------------
LPSTR CIniA::GPPS(LPCSTR pszSection, LPCSTR pszEntry, LPCSTR pszDefault) const
{
    //
    // Skip input pointer check since pszSection could be NULL to get all of 
    // the Section Names in the file, pszEntry could be NULL to get all of the
    // key names in a section, and pszDefault is NULL by default.
    // GetPrivateProfileString cannot take a NULL default but this is taken care of
    // by CIniA_GPPS.
    //

    LPSTR pszSectionTmp = LoadSection(pszSection);
    LPSTR pszEntryTmp = LoadEntry(pszEntry);
	LPSTR pszBuffer = NULL;

    if (m_fReadICSData)
    {
        //
        // We need first read the data from ICSData reg key, if it's not present then try to 
        // get it from the file and then see if we have a primary file and read it from there.
        //
        pszBuffer = (LPTSTR)CIniA_GetEntryFromReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, REG_SZ, ((MAX_PATH + 1) * sizeof(CHAR))); 
        if (NULL == pszBuffer)
        {
            LPSTR pszICSTmp = NULL;
            pszBuffer = CIniA_GPPS(pszSectionTmp, pszEntryTmp, pszDefault, GetFile());

            if (m_pszPrimaryFile)
            {
                pszICSTmp = pszBuffer;
                pszBuffer = CIniA_GPPS(pszSectionTmp, pszEntryTmp, pszICSTmp, GetPrimaryFile());
            }

            if (NULL == pszBuffer)
            {
                if (pszDefault)
                {
                    pszBuffer = CmStrCpyAllocA(pszDefault);
                }
                else
                {
                    //
                    // We should not return a null from this wrapper, but an empty string instead
                    //
                    pszBuffer = CmStrCpyAllocA(TEXT(""));
                }
            }

            CmFree(pszICSTmp);
        }
    }
    else
    {
        //
        // If there is a reg path present. Registry access for m_pszFile
        // unless we want to read it from the file
        //
        if (m_pszRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
                pszBuffer = (LPTSTR) CIniA_GetEntryFromReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, REG_SZ, ((MAX_PATH + 1) * sizeof(CHAR))); 
            }
        }

        if (NULL == pszBuffer)
        {
            // This could mean that there is no reg path, or that the reg access failed. Either way, we 
            // try to get the entry from pszFile
            //
            // Skip input pointer check since pszSection could be NULL to get all of 
            // the Section Names in the file, pszEntry could be NULL to get all of the
            // key names in a section, and pszDefault is NULL by default.
            // GetPrivateProfileString cannot take a NULL default but this is taken care of
            // by CIniW_GPPS.
            //
            pszBuffer = CIniA_GPPS(pszSectionTmp, pszEntryTmp, pszDefault, GetFile());
        }

        MYDBGASSERT(pszBuffer);

        // Now we try to get the entry from the primary file
        //
        LPTSTR pszTmp = NULL;

        if (m_pszPrimaryRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
                pszTmp = pszBuffer;
                pszBuffer = (LPTSTR) CIniA_GetEntryFromReg(HKEY_CURRENT_USER, m_pszPrimaryRegPath, pszEntryTmp, REG_SZ, ((MAX_PATH + 1) * sizeof(CHAR)));
            }
        }

        if (NULL == pszBuffer)
        {
    
            // Skip input pointer check since pszSection could be NULL to get all of 
            // the Section Names in the file, pszEntry could be NULL to get all of the
            // key names in a section, and pszDefault is NULL by default.
            // GetPrivateProfileString cannot take a NULL default but this is taken care of
            // by CIniW_GPPS.
            //
            pszBuffer = CIniA_GPPS(pszSectionTmp, pszEntryTmp, pszTmp, GetPrimaryFile());
        
        }

        CmFree(pszTmp);

    }

    CmFree(pszEntryTmp);
    CmFree(pszSectionTmp);
    
    MYDBGASSERT(pszBuffer);
    
    return (pszBuffer);
}
			


//+----------------------------------------------------------------------------
//
// Function:  CIniA::GPPI
//
// Synopsis:  CIni's version of GetPrivateProfileInt.  Duplicates the Win32
//            API functionality except that it will append the Section and Entry
//            suffixes (if any) before calling the Win32 API.  The function all
//            allocates the string it returns in the return value which must be
//            freed by the caller.
//
// Arguments: LPCSTR pszSection - Ini section to look for the data in
//            LPCSTR pszEntry - Ini key name that contains the requested data
//            DWORD dwDefault - default value to return if the key 
//                              cannot be found
//
// Returns:   DWORD - the requested numerical value
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//
//+----------------------------------------------------------------------------
DWORD CIniA::GPPI(LPCSTR pszSection, LPCSTR pszEntry, DWORD dwDefault) const
{
    //
    //  GetPrivateProfileInt doesn't take NULL's for the section and entry
    //  parameters as GetPrivateProfileString will.  Thus check the values returned
    //  from LoadSection and LoadEntry, which will return NULL if the input parameter
    //  is either NULL or empty.  Since we don't really know what to do in this
    //  situation lets just assert and return the default value.
    //
    DWORD   dwRet = dwDefault;
    LPSTR pszSectionTmp = LoadSection(pszSection);
    LPSTR pszEntryTmp = LoadEntry(pszEntry);
    LPCSTR pszFileTmp = GetFile();
    DWORD* pdwData = NULL;

    if (m_fReadICSData)
    {
        //
        // We need first read the data from ICSData reg key, if it's not present then try to 
        // get it from the file and then see if we have a primary file and read it from there.
        //
        pdwData = (DWORD*)CIniA_GetEntryFromReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, REG_DWORD, sizeof(DWORD));
        
        //
        // If we got something, assign it to the return value, otherwise try reading from the files
        // and using the default.
        //
        if (NULL == pdwData)
        {
            //
            // The registry access failed, or there is no reg. path. try to get the 
            // entry from pszFile
            //
            MYDBGASSERT(pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp);

            if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
            {
                dwRet = GetPrivateProfileIntA(pszSectionTmp, pszEntryTmp, dwDefault, pszFileTmp);
            }

            if (m_pszPrimaryFile)
            {
                //
                // The registry access failed, or there is no reg. path. try to get the 
                // entry from pszPrimaryFile
                //
        
                pszFileTmp = GetPrimaryFile();
                if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
                {
                    dwRet = GetPrivateProfileIntA(pszSectionTmp, pszEntryTmp, dwRet, pszFileTmp);
                }
            }
        }
        else
        {
            dwRet = *pdwData;
        }
    }
    else
    {
        //
        // Follow the normal rules
        // 
        if (m_pszRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
                pdwData = (DWORD*)CIniA_GetEntryFromReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, REG_DWORD, sizeof(DWORD));
            }
        }

        if (NULL == pdwData)
        {
            //
            // The registry access failed, or there is no reg. path. try to get the 
            // entry from pszFile
            //
            MYDBGASSERT(pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp);

            if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
		    {
			    dwRet = GetPrivateProfileIntA(pszSectionTmp, pszEntryTmp, dwDefault, pszFileTmp);
		    }
        }
        else
	    {
		    dwRet = *pdwData;
	    }

        if (m_pszPrimaryRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
               CmFree(pdwData);
          
               pdwData = (DWORD*)CIniA_GetEntryFromReg(HKEY_CURRENT_USER, m_pszPrimaryRegPath, pszEntryTmp, REG_DWORD, sizeof(DWORD));
               if (pdwData)
                {
                    dwRet = *pdwData;
                }
            }
        
        }

        if (NULL == pdwData && m_pszPrimaryFile)
        {
            //
            // The registry access failed, or there is no reg. path. try to get the 
            // entry from pszPrimaryFile
            //

            pszFileTmp = GetPrimaryFile();
            if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
            {
	            dwRet = GetPrivateProfileIntA(pszSectionTmp, pszEntryTmp, dwRet, pszFileTmp);
            }
        }
    }

    CmFree(pdwData);
	CmFree(pszEntryTmp);
	CmFree(pszSectionTmp);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::GPPB
//
// Synopsis:  CIni's version of GetPrivateProfileBool (which doesn't exactly
//            exist). Basically this function is the same as GPPI except that
//            the return value is cast to a BOOL value (1 or 0).
//
// Arguments: LPCSTR pszSection - Ini section to look for the data in
//            LPCSTR pszEntry - Ini key name that contains the requested data
//            DWORD dwDefault - default value to return if the key 
//                              cannot be found
//
// Returns:   DWORD - the requested BOOL value
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
BOOL CIniA::GPPB(LPCSTR pszSection, LPCSTR pszEntry, BOOL bDefault) const
{
    return (GPPI(pszSection, pszEntry, (DWORD)bDefault) != 0);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::WPPI
//
// Synopsis:  CIni's version of WritePrivateProfileInt (which doesn't exist as
//            a Win32 function).  Basically takes the inputted DWORD and prints
//            it into a string and then calls WPPS.
//
// Arguments: LPCSTR pszSection - Ini section to write the data to
//            LPCSTR pszEntry - Ini key name to store the data at
//            DWORD dwBuffer - Numeric value to write
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//+----------------------------------------------------------------------------

void CIniA::WPPI(LPCSTR pszSection, LPCSTR pszEntry, DWORD dwBuffer)
{
    // Technically pszEntry could be NULL, which would erase all of the keys in
    // the section pointed to by pszSection.  However, this doesn't seem to be
    // in the spirit of this wrapper so we will check both string pointers to make
    // sure they are valid.
	BOOL bRes = FALSE;
    
	//
    // Check is we are allowed to save info
    //
    if ((NULL != pszSection) && ('\0' != pszSection[0]) &&
        (NULL != pszEntry) && ('\0' != pszEntry[0]))
    {
        LPSTR pszEntryTmp = LoadEntry(pszEntry);
		
        if(m_pszRegPath)
		{
			MYDBGASSERT(pszEntryTmp || (NULL == pszEntry) || ('\0' == pszEntry[0]));

			if (NULL != pszEntryTmp && *pszEntryTmp)
			{
    			bRes = CIniA_WriteEntryToReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, (BYTE *) &dwBuffer, REG_DWORD, sizeof(DWORD));
			}
		}
		
		if(!bRes)
		{
		    // This loop is only entered if we are trying to write to the cmp and the registry 
			// write failed, or we are writing to the cms, in which case we will not even 
			// try to write to the reg.

            LPSTR pszSectionTmp = LoadSection(pszSection);
	        LPCSTR pszFileTmp = GetFile();
			        
	        MYDBGASSERT(pszFileTmp && *pszFileTmp);
	        MYDBGASSERT(pszSectionTmp && *pszSectionTmp);

            CHAR szBuffer[sizeof(dwBuffer)*6+1] = {0};
    	
			wsprintfA(szBuffer, "%u", dwBuffer);
					
			if (pszFileTmp && *pszFileTmp && pszSectionTmp && *pszSectionTmp && pszEntryTmp && *pszEntryTmp)
			{
    			bRes = WritePrivateProfileStringA(pszSectionTmp, pszEntryTmp, szBuffer, pszFileTmp);
			}
            if (!bRes)
            {
                DWORD dwError = GetLastError();
                CMTRACE3A("CIniA::WPPI() WritePrivateProfileString[*pszSection=%s,*pszEntry=%s,*pszBuffer=%s", pszSectionTmp, MYDBGSTRA(pszEntryTmp), MYDBGSTRA(szBuffer));
                CMTRACE2A("*pszFile=%s] failed, GLE=%u", pszFileTmp, dwError);
            }
            CmFree(pszSectionTmp);
               	
		}

        if (m_fWriteICSData)
        {
            if (NULL != pszEntryTmp && *pszEntryTmp)
			{
    			bRes = CIniA_WriteEntryToReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, (BYTE *) &dwBuffer, REG_DWORD, sizeof(DWORD));
			}
        }

        CmFree(pszEntryTmp);
    }
	else
    {
        CMASSERTMSG(FALSE, "Invalid input paramaters to CIniA::WPPI");
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::WPPB
//
// Synopsis:  CIni's version of WritePrivateProfileBool (which doesn't exist as
//            a Win32 function).  Basically takes the inputted BOOL and prints
//            either 1 or 0 into a string and then calls WPPI.
//
// Arguments: LPCSTR pszSection - Ini section to write the data to
//            LPCSTR pszEntry - Ini key name to store the data at
//            DWORD dwBuffer - Numeric value to write
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::WPPB(LPCSTR pszSection, LPCSTR pszEntry, BOOL bBuffer)
{
	WPPI(pszSection, pszEntry, bBuffer ? 1 : 0);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::WPPS
//
// Synopsis:  CIni's version of WritePrivateProfileString
//
// Arguments: LPCSTR pszSection - Ini section to write the data to
//            LPCSTR pszEntry - Ini key name to store the data at
//            LPCSTR pszBuffer - data buffer to write to the ini file
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//+----------------------------------------------------------------------------
void CIniA::WPPS(LPCSTR pszSection, LPCSTR pszEntry, LPCSTR pszBuffer) 
{
    
    LPSTR pszEntryTmp = LoadEntry(pszEntry);
    LPSTR pszSectionTmp = LoadSection(pszSection);
	LPCSTR pszFileTmp = GetFile();
			
	MYDBGASSERT(pszFileTmp && *pszFileTmp);
	MYDBGASSERT(pszSectionTmp && *pszSectionTmp);
	MYDBGASSERT(pszEntryTmp || (NULL == pszEntry) || (L'\0' == pszEntry[0]));

    // Both pszEntry and pszBuffer could be NULL or Empty.  However, pszSection and
    // the file path must not be NULL or empty.  We also don't want to have a non-NULL
    // or non-Empty value for pszEntry and then get a NULL value back from LoadEntry
    // (indicating that LoadEntry had text to duplicate but failed for some reason).
    // Writing with a NULL value accidently will delete the key value we were trying to set.
    // Make sure to assert and prevent data loss in this case.
    //
   
	//
    // Check is we are allowed to save info
    //
    if(pszEntryTmp || (NULL == pszEntry) || (L'\0' == pszEntry[0]))
    {	
		BOOL bRes = FALSE;
		
		// First try to write to registry if pszRegPath exists

		if(m_pszRegPath)
		{
            if (NULL == pszBuffer)
            {
                CIniA_DeleteEntryFromReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp);
                bRes = TRUE; // never erase from the cmp or cms file if there is a regpath.
            }
            else
            {
			    DWORD dwSize = (lstrlenA(pszBuffer) + 1) * sizeof(CHAR);            
        
			    bRes = CIniA_WriteEntryToReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, (BYTE *) pszBuffer, REG_SZ, dwSize);
            }
		}

		if(!bRes)
		{
			// This loop is only entered if we are trying to write to the cmp and the registry 
			// write failed, or we are writing to the cms, in which case we will not even 
			// try to write to the reg.
			
			if (pszFileTmp && *pszFileTmp && pszSectionTmp && *pszSectionTmp )
			{
    			bRes = WritePrivateProfileStringA(pszSectionTmp, pszEntryTmp, pszBuffer, pszFileTmp);
			}
		}
        if (!bRes)
        {
            DWORD dwError = GetLastError();
            CMTRACE3A("CIniA::WPPS() WritePrivateProfileStringA[*pszSection=%s,*pszEntry=%s,*pszBuffer=%s", pszSectionTmp, MYDBGSTRA(pszEntryTmp), MYDBGSTRA(pszBuffer));
        	CMTRACE2A("*pszFile=%s] failed, GLE=%u", GetFile(), dwError);
        }

        if (m_fWriteICSData)
        {
            //
            // The return values are ignored and are here to prevent prefix errors
            //
            if (NULL == pszBuffer)
            {
                bRes = CIniA_DeleteEntryFromReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp);
            }
            else
            {
			    DWORD dwSize = (lstrlenA(pszBuffer) + 1) * sizeof(CHAR);            
        
			    bRes = CIniA_WriteEntryToReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, (BYTE *) pszBuffer, REG_SZ, dwSize);
            }
        }
    }

    CmFree(pszEntryTmp);
  	CmFree(pszSectionTmp);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::GetSection
//
// Synopsis:  Accessor function for the Section suffix member variable.  Will
//            return the empty string if m_pszSection is NULL.
//
// Arguments: None
//
// Returns:   LPCSTR - Value of the section suffix member variable or "" 
//                     if it is NULL
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPCSTR CIniA::GetSection() const
{
    return (m_pszSection ? m_pszSection : "");
}


//+----------------------------------------------------------------------------
//
// Function:  CIniA::GetPrimaryFile
//
// Synopsis:  Accessor function for the Primary File member variable.  Will
//            return the empty string if m_pszPrimaryFile is NULL.
//
// Arguments: None
//
// Returns:   LPCSTR - Value of the primary file member variable or "" 
//                     if it is NULL
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPCSTR CIniA::GetPrimaryFile() const
{
    return (m_pszPrimaryFile ? m_pszPrimaryFile : "");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::GetHInst
//
// Synopsis:  Accessor function for the m_hInst member variable.
//
// Arguments: None
//
// Returns:   HINSTANCE - Value of the m_hInst
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
HINSTANCE CIniA::GetHInst() const
{
    return (m_hInst);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetFile
//
// Synopsis:  Function to set the m_pszFile member variable.  Uses CIni_SetFile.
//            Note that if the input parameter is NULL or the empty string then
//            m_pszFile will be set to NULL.
//
// Arguments: LPCSTR pszFile - full path to set the m_pszFile member var to
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::SetFile(LPCSTR pszFile) 
{
    CIni_SetFile(&m_pszFile, pszFile);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetPrimaryFile
//
// Synopsis:  Function to set the m_pszPrimaryFile member variable.  Uses CIni_SetFile.
//            Note that if the input parameter is NULL or the empty string then
//            m_pszPrimaryFile will be set to NULL.
//
// Arguments: LPCSTR pszFile - full path to set the m_pszPrimaryFile member var to
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::SetPrimaryFile(LPCSTR pszFile) 
{
    CIni_SetFile(&m_pszPrimaryFile, pszFile);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::GetFile
//
// Synopsis:  Accessor function for the File member variable.  Will
//            return the empty string if m_pszFile is NULL.
//
// Arguments: None
//
// Returns:   LPCSTR - the contents of m_pszFile or "" if it is NULL
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPCSTR CIniA::GetFile() const
{
    return (m_pszFile ? m_pszFile : "");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetHInst
//
// Synopsis:  Function to set the m_hInst member variable.
//
// Arguments: HINSTANCE hInst - instance handle to set m_hInst to
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::SetHInst(HINSTANCE hInst) 
{
    m_hInst = hInst;
}

//
//	Loading sections by string resource isn't used anymore
//
#if 0
LPSTR CIniA::LoadSection(UINT nSection) const
{
	LPSTR pszTmp = CmLoadStringA(GetHInst(),nSection);
	CmStrCatAllocA(&pszTmp,GetSection());
	return (pszTmp);
}
#endif

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetRegPath
//
// Synopsis:  Sets the registry path for registry access
//
// Arguments: LPCSTR pszRegPath - entry suffix to remember
//
// Returns:   Nothing
//
// History:   t-urama Created Header    07/13/2000
//
//+----------------------------------------------------------------------------

void CIniA::SetRegPath(LPCSTR pszRegPath)
{
	CIniA_Set(&m_pszRegPath, pszRegPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetPrimaryRegPath
//
// Synopsis:  Sets the primary registry path for registry access
//
// Arguments: LPCSTR pszPrimaryRegPath - Primary reg path
//
// Returns:   Nothing
//
// History:   t-urama Created Header    07/13/2000
//
//+----------------------------------------------------------------------------

void CIniA::SetPrimaryRegPath(LPCSTR pszPrimaryRegPath)
{
	CIniA_Set(&m_pszPrimaryRegPath, pszPrimaryRegPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetICSDataPath
//
// Synopsis:  Sets the internal registry key to store data for ICS.
//            Need to make sure the string isn't empty since we don't want
//            to write in HKLM
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   03/30/2001    tomkel      Created 
//
//+----------------------------------------------------------------------------
void CIniA::SetICSDataPath(LPCSTR pszICSPath)
{
    CIniA_Set(&m_pszICSDataPath, pszICSPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetReadICSData
//
// Synopsis:  Sets the read flag, to read data from the ICS registry key.
//
// Arguments: fValue
//
// Returns:   Nothing
//
// History:   03/30/2001    tomkel      Created 
//
//+----------------------------------------------------------------------------
void CIniA::SetReadICSData(BOOL fValue)
{
    m_fReadICSData = fValue;
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetWriteICSData
//
// Synopsis:  Sets the write flag, to write data to the ICS registry key.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   03/30/2001    tomkel      Created 
//
//+----------------------------------------------------------------------------
void CIniA::SetWriteICSData(BOOL fValue)
{
    m_fWriteICSData = fValue;
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::CiniA_GetRegPath
//
// Synopsis:  Function to get the value ofm_pszRegPath
//
// Arguments: none
//
// Returns:   LPCSTR - Value of m_pszRegPath
//
// History:   t-urama Created Header    07/15/2000
//
//+----------------------------------------------------------------------------
LPCSTR CIniA::GetRegPath() const
{
	return (m_pszRegPath ? m_pszRegPath : "");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::CiniA_GetPrimaryRegPath
//
// Synopsis:  Function to get the value ofm_pszPrimaryRegPath
//
// Arguments: none
//
// Returns:   LPCSTR - Value of m_pszPrimaryRegPath
//
// History:   t-urama Created     07/15/2000
//
//+----------------------------------------------------------------------------
LPCSTR CIniA::GetPrimaryRegPath() const
{
	return (m_pszPrimaryRegPath ? m_pszPrimaryRegPath : "");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::CIniA_DeleteEntryFromReg
//
// Synopsis:  Function to delete an entry from the registry. 
//
// Arguments: HKEY - hkey
//            LPCSTR pszRegPathTmp - Reg path
//            LPCSTR pszEntry - Registry value name to be deleted
//
// Returns:   BOOL - Success or failure
//
// History:   t-urama Created     07/15/2000
//            04/03/2001    tomkel  Added reg key string to parameters
//
//+----------------------------------------------------------------------------
BOOL CIniA::CIniA_DeleteEntryFromReg(HKEY hKey, LPCSTR pszRegPathTmp, LPCSTR pszEntry) const
{
    
    MYDBGASSERT(pszEntry);

    if (NULL == pszEntry || !*pszEntry || NULL == pszRegPathTmp || !*pszRegPathTmp || NULL == hKey)
    {
        return FALSE;
    }
       
    //
    // Everything is ok. We have a reg path and a entry name. 
    //
    
    HKEY    hKeyCm;

    BOOL dwRes = RegOpenKeyExA(hKey,
                               pszRegPathTmp,
                               0,
                               KEY_SET_VALUE,
                               &hKeyCm);

    //
    // If we opened the key successfully, retrieve the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {                        
        dwRes = RegDeleteValueA(hKeyCm, pszEntry);
        (VOID)RegCloseKey(hKeyCm);
    }

    return (ERROR_SUCCESS == dwRes);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::CiniA_GetEntryFromReg
//
// Synopsis:  Function to get the value from the registry. The function 
//            allocates the string it returns in the return value which must be
//            freed by the caller.
//
// Arguments: HKEY hKey - reg hkey
//            pszRegPathTmp - reg key name
//            LPCSTR pszEntry - Registry value name that contains the requested data
//            DWORD dwType - Type of value
//			  DWORD dwSize - Size of value
//            
//
// Returns:   LPBYTE - the requested value
//
// History:   07/15/2000    t-urama Created Header    
//            04/03/2001    tomkel  Changed to pass in registry key string
//
//+----------------------------------------------------------------------------
LPBYTE CIniA::CIniA_GetEntryFromReg(HKEY hKey, LPCSTR pszRegPathTmp, LPCSTR pszEntry, DWORD dwType, DWORD dwSize) const
    
{    
    MYDBGASSERT(pszEntry);

    if (NULL == pszEntry || !*pszEntry || NULL == pszRegPathTmp || !*pszRegPathTmp || NULL == hKey)
    {
        return NULL;
    }

    //
    // Everything is ok. We have a reg path and a entry name. 
    //

    DWORD dwTypeTmp = dwType;
    DWORD dwSizeTmp = dwSize;
    HKEY hKeyCm;
    LPBYTE lpData = NULL;

    //
    // Open the sub key under HKCU
    //
    
    DWORD dwRes = RegOpenKeyExA(hKey,
                                pszRegPathTmp,
                                0,
                                KEY_QUERY_VALUE,
                                &hKeyCm);

    //
    // If we opened the key successfully, retrieve the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {
        do
        {
            //
            //	Allocate a buffer
            //
            CmFree(lpData);
            lpData = (BYTE *) CmMalloc(dwSizeTmp);

            if (NULL == lpData)
            {
                RegCloseKey(hKeyCm);
                return FALSE;
            }

            dwRes = RegQueryValueExA(hKeyCm, 
                                     pszEntry,
                                     NULL,
                                     &dwTypeTmp,
                                     lpData, 
                                     &dwSizeTmp);        
       			
        } while (ERROR_MORE_DATA == dwRes);
          
        RegCloseKey(hKeyCm);
    }

    if (ERROR_SUCCESS == dwRes && dwTypeTmp == dwType)
    {
       return lpData;     
    }
	else
	{
		CmFree(lpData);
		return NULL;
	}
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::CiniA_WriteEntryToReg
//
// Synopsis:  Function to write and entry to the registry. 
//
// Arguments: HKEY hKey
//            LPCSTR pszRegPathTmp - name of the reg key
//            LPCSTR pszEntry - Registry value name to which data is to be written
//			  CONST BYTE *lpData - Data to be written
//            DWORD dwType - The type of value to be entered
//			  DWORD dwSize - The size of the value entered
//
// Returns:   BOOL - Success or failure
//
// History:   t-urama Created Header    07/15/2000
//
//+----------------------------------------------------------------------------
BOOL CIniA::CIniA_WriteEntryToReg(HKEY hKey, LPCSTR pszRegPathTmp, LPCSTR pszEntry, CONST BYTE *lpData, DWORD dwType, DWORD dwSize) const
{
   MYDBGASSERT(pszEntry && *pszEntry);
   MYDBGASSERT(lpData);
   MYDBGASSERT(pszRegPathTmp && *pszRegPathTmp);

    

   if (NULL == pszEntry || !*pszEntry || NULL == lpData || NULL == pszRegPathTmp || !*pszRegPathTmp || NULL == hKey)
    {
        return FALSE;
    }

   HKEY    hKeyCm;
   DWORD   dwDisposition;
   DWORD   dwRes = 1;

   dwRes = RegCreateKeyExA(hKey,
                           pszRegPathTmp,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_SET_VALUE,
                           NULL,
                           &hKeyCm,
                           &dwDisposition);


	//
    // If we opened the key successfully, write the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {                        
        dwRes = RegSetValueExA(hKeyCm, 
                               pszEntry, 
                               0, 
                               dwType,
                               lpData, 
                               dwSize);             

        
        RegCloseKey(hKeyCm);
    }

#ifdef DEBUG
        if (ERROR_SUCCESS != dwRes)
        {
            CMTRACE1(TEXT("CIniA_WriteEntryToReg() - %s failed"), (LPTSTR)pszEntry);
        }
#endif

    return (ERROR_SUCCESS == dwRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmutil\cmlogutil.h ===
//+----------------------------------------------------------------------------
//
// File:    cmlogutil.h
//
// Module:  logging.LIB
//
// Synopsis: Connection Manager Logging
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  25-May-2000 SumitC  Created
//
//-----------------------------------------------------------------------------


BOOL ConvertFormatString(LPTSTR pszFmt);
BOOL CmGetModuleBaseName(HINSTANCE hInst, LPTSTR szModule);
void CmGetDateTime(LPTSTR * ppszDate, LPTSTR * ppszTime);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmutil\cmlogutil.cpp ===
//+----------------------------------------------------------------------------
//
// File:    cmlogutil.cpp
//
// Module:  CMLOG.LIB
//
// Synopsis: Utility function for Connection Manager Logging
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  25-May-2000 SumitC  Created
//
// Note:
//
//-----------------------------------------------------------------------------

#define CMLOG_IMPLEMENTATION
#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>
#include <psapi.h>
#include <tlhelp32.h>

#include "cmmaster.h"

#include "cmlog.h"
#include "cmlogutil.h"

#if 0
const DWORD c_szFmtSize = 128;          // largest format string possible.

/*
//+----------------------------------------------------------------------------
//
// Func:    ConvertFormatString
//
// Desc:    Utility function, converts %s to %S within a given format string
//
// Args:    [pszFmt] - format string with %s's and %c's in it, to be converted
//
// Return:  LPTSTR buffer containing new format string
//
// Notes:   return value is a static buffer and doesn't have to be freed.
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
ConvertFormatString(LPTSTR pszFmt)
{
    MYDBGASSERT(pszFmt);

    if (lstrlenU(pszFmt) > c_szFmtSize)
    {
        MYDBGASSERT(!"Cmlog format string too large, fix code");
        return FALSE;
    }

    for (int i = 1; i < lstrlenU(pszFmt); i++)
    {
        if (pszFmt[i - 1] == TEXT('%') && pszFmt[i] == TEXT('s'))
        {
            // uppercase it.
            pszFmt[i] = TEXT('S');
        }
        if (pszFmt[i - 1] == TEXT('%') && pszFmt[i] == TEXT('c'))
        {
            // uppercase it.
            pszFmt[i] = TEXT('C');
        }
    }
    
    return TRUE;
}
*/
#endif




//+----------------------------------------------------------------------------
//
// Func:    CmGetModuleNT
//
// Desc:    Utility function to get module name on WinNT systems
//
// Args:    [hInst]    -- IN, instance handle
//          [szModule] -- OUT, buffer to return module name
//
// Return:  BOOL
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
CmGetModuleNT(HINSTANCE hInst, LPTSTR szModule)
{
    BOOL    fRet = FALSE;
    HMODULE hModLib = NULL;

    typedef DWORD (WINAPI* PFN_GMBN)(HANDLE, HMODULE, LPTSTR, DWORD);
    
    PFN_GMBN pfnGetModuleBaseName = NULL;

    //
    //  Load the library
    //
    hModLib = LoadLibrary(TEXT("PSAPI.dll"));
    if (NULL == hModLib)
    {
        CMTRACE(TEXT("NT - could not load psapi.dll"));
        goto Cleanup;
    }

    //
    //  Get the necessary function(s)
    //
#ifdef UNICODE
    pfnGetModuleBaseName = (PFN_GMBN)GetProcAddress(hModLib, "GetModuleBaseNameW");
#else
    pfnGetModuleBaseName = (PFN_GMBN)GetProcAddress(hModLib, TEXT("GetModuleBaseNameA"));
#endif
    if (NULL == pfnGetModuleBaseName)
    {
        CMTRACE(TEXT("NT - couldn't find GetModuleBaseName within psapi.dll !!"));
        goto Cleanup;
    }

    //
    //  Get the module name
    //
    fRet = (0 != pfnGetModuleBaseName(GetCurrentProcess(), hInst, szModule, 13));

Cleanup:
    if (hModLib)
    {
        FreeLibrary(hModLib);
    }

    return fRet;
}



//
//  tlhelp32.h does something "interesting".  There is no MODULEENTRY32A version,
//  thus if you're compiled UNICODE (and we care) there is no way to have an ANSI
//  version of the struct defined.  So, we're defining one.
//
typedef struct tagMODULEENTRY32A
{
    DWORD   dwSize;
    DWORD   th32ModuleID;       // This module
    DWORD   th32ProcessID;      // owning process
    DWORD   GlblcntUsage;       // Global usage count on the module
    DWORD   ProccntUsage;       // Module usage count in th32ProcessID's context
    BYTE  * modBaseAddr;        // Base address of module in th32ProcessID's context
    DWORD   modBaseSize;        // Size in bytes of module starting at modBaseAddr
    HMODULE hModule;            // The hModule of this module in th32ProcessID's context
    char    szModule[MAX_MODULE_NAME32 + 1];
    char    szExePath[MAX_PATH];
} MODULEENTRY32A;
typedef MODULEENTRY32A *  PMODULEENTRY32A;
typedef MODULEENTRY32A *  LPMODULEENTRY32A;

//+----------------------------------------------------------------------------
//
// Func:    CmGetModule9x
//
// Desc:    Utility function to get module name on Win9x systems
//
// Args:    [hInst]    -- IN, instance handle
//          [szModule] -- OUT, buffer to return module name
//
// Return:  BOOL
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
CmGetModule9x(HINSTANCE hInst, LPTSTR szModule)
{
    BOOL    fRet = FALSE;
    HMODULE hModLib = NULL;
    HANDLE  hSnap = NULL;

    typedef HANDLE (WINAPI* PFN_TH32SS) (DWORD, DWORD);
    typedef BOOL (WINAPI* PFN_MOD32F) (HANDLE, LPMODULEENTRY32A);
    typedef BOOL (WINAPI* PFN_MOD32N) (HANDLE, LPMODULEENTRY32A);
    
    PFN_TH32SS      pfnSnapshot = NULL;
    PFN_MOD32F      pfnModule32First = NULL;
    PFN_MOD32N      pfnModule32Next = NULL;

    //
    //  Load the library
    //
    hModLib = LoadLibraryA("kernel32.dll");
    if (NULL == hModLib)
    {
        CMTRACE(TEXT("9x - could not load kernel32.dll"));
        goto Cleanup;
    }

    //
    //  Get the necessary function(s)
    //
    pfnSnapshot = (PFN_TH32SS) GetProcAddress(hModLib, "CreateToolhelp32Snapshot");
    pfnModule32First = (PFN_MOD32F) GetProcAddress(hModLib, "Module32First");
    pfnModule32Next = (PFN_MOD32N) GetProcAddress(hModLib, "Module32Next");

    if (NULL == pfnModule32Next || NULL == pfnModule32First || NULL == pfnSnapshot)
    {
        CMTRACE(TEXT("9x - couldn't get ToolHelp functions"));
        goto Cleanup;
    }

    //
    //  Get the module name
    //
    hSnap = pfnSnapshot(TH32CS_SNAPMODULE, 0);

    if (INVALID_HANDLE_VALUE == hSnap)
    {
        CMTRACE(TEXT("9x - could not get ToolHelp32Snapshot"));
        goto Cleanup;
    }
    else
    {
        MODULEENTRY32A  moduleentry;
        BOOL            fDone = FALSE;
        CHAR            szModuleAnsi[13];

        moduleentry.dwSize = sizeof(MODULEENTRY32A);

        for (fDone = pfnModule32First(hSnap, &moduleentry);
             fDone;
             fDone = pfnModule32Next(hSnap, &moduleentry))
        {
            if ((HMODULE)moduleentry.hModule == hInst)
            {
                lstrcpynA(szModuleAnsi, moduleentry.szModule, 13);
                fRet = TRUE;
                break;
            }
        }

        SzToWz(szModuleAnsi, szModule, 13);
    }

Cleanup:

    if (hSnap)
    {
        CloseHandle(hSnap);
    }
    if (hModLib)
    {
        FreeLibrary(hModLib);
    }

    return fRet;
}


//+----------------------------------------------------------------------------
//
// Func:    CmGetModuleBaseName
//
// Desc:    Utility function to figure out our module name
//
// Args:    [hInst]    -- IN, instance handle
//          [szModule] -- OUT, buffer to return module name
//
// Return:  BOOL
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
CmGetModuleBaseName(HINSTANCE hInst, LPTSTR szModule)
{
    BOOL fRet = FALSE;

    if (OS_NT)
    {
        fRet = CmGetModuleNT(hInst, szModule);
    }
    else
    {
        fRet = CmGetModule9x(hInst, szModule);
    }

    if (fRet)
    {
        // trim the string to just the basename
        for (int i = 0; i < lstrlenU(szModule); ++i)
        {
            if (TEXT('.') == szModule[i])
            {
                szModule[i] = TEXT('\0');
                break;
            }
        }
    }

    return fRet;
}


//+----------------------------------------------------------------------------
//
// Func:    CmGetDateTime
//
// Desc:    Utility function to get system-formatted date and/or time
//
// Args:    [ppszDate] -- OUT, ptr to where to put the date (NULL=>don't want the date)
//          [ppszTime] -- OUT, ptr to where to put the time (NULL=>don't want the time)
//
// Return:  void
//
// Notes:   
//
// History: 17-Nov-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
void
CmGetDateTime(LPTSTR * ppszDate, LPTSTR * ppszTime)
{
    int iRet;
    
    if (ppszDate)
    {
        iRet = GetDateFormatU(LOCALE_SYSTEM_DEFAULT, DATE_SHORTDATE, NULL, NULL, NULL, 0);

        if (iRet)
        {
            *ppszDate = (LPTSTR) CmMalloc(iRet * sizeof(TCHAR));
            if (*ppszDate)
            {
                iRet = GetDateFormatU(LOCALE_SYSTEM_DEFAULT, DATE_SHORTDATE, NULL, NULL, *ppszDate, iRet);
            }
        }
        else
        {
            MYDBGASSERT(!"CmGetDateTime - GetDateFormat failed");
            *ppszDate = NULL;
        }
    }

    if (ppszTime)
    {
        iRet = GetTimeFormatU(LOCALE_SYSTEM_DEFAULT, 0, NULL, NULL, NULL, 0);

        if (iRet)
        {
            *ppszTime = (LPTSTR) CmMalloc(iRet * sizeof(TCHAR));
            if (*ppszTime)
            {
                iRet = GetTimeFormatU(LOCALE_SYSTEM_DEFAULT, TIME_FORCE24HOURFORMAT|TIME_NOTIMEMARKER, NULL, NULL, *ppszTime, iRet);
            }
        }
        else
        {
            MYDBGASSERT(!"CmGetDateTime - GetTimeFormat failed");
            *ppszTime = NULL;
        }
    }
}

#undef CMLOG_IMPLEMENTATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmutil\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:	 henryt     Created   03/01/98
//
//+----------------------------------------------------------------------------

#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include <windows.h>
#include <stdlib.h>
#include <tchar.h>

#include "uapi.h"
#include "cm_def.h"
#include "cmdebug.h"
#define  _CMUTIL_MODULE_
#include "cmutil.h"

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmutil\makefile.inc ===
$(O)\cmutilp.def: cmutil.src
    $(C_PREPROCESSOR) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmutil\image.cpp ===
//+----------------------------------------------------------------------------
//
// File:     image.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Common image loading routines
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   nickball   Created   03/30/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//+---------------------------------------------------------------------------
//
//  Function:   CmLoadImageA
//
//  Synopsis:   ANSI Wrapper for LoadImage API which loads a resource based upon
//              pszSpec which can be any of 3 formats:
//
//              1) Filename
//              2) Resource ID name
//
//  Arguments:  hMainInst - Our application instance handle
//              pszSpec   - The name of the resource
//              nResType  - The resource type
//              nCX       - Resource X dimension (ie. 32 X 32 icon)
//              nCY       - Resource Y dimension (ie. 32 X 32 icon)
//
// Notes:       Now includes hInst of main app for portability, due to different OS 
//              implementations of GetModuleHandle, the 16-bit compilation would grab 
//              default icons (ie. Question Mark) from the system dll.
//
//  Returns:    TRUE on Success
//
//  History:    a-nichb     Re-Written                      03/21/97
//              quintinb    Implemented Wide/ANSI forms     04/08/99
//              sumitc      cleanup                         03/14/2000
//
//----------------------------------------------------------------------------

HANDLE CmLoadImageA(HINSTANCE hMainInst, LPCSTR pszSpec, UINT nResType, UINT nCX, UINT nCY) 
{
    HANDLE hRes = NULL;
    
    // Ensure that the resource is one we can handle
    MYDBGASSERT(nResType == IMAGE_BITMAP || nResType == IMAGE_ICON);
    // enforce that icons can only be 16x16 or 32x32.
    MYDBGASSERT(nResType != IMAGE_ICON ||
                ((GetSystemMetrics(SM_CXICON) == (int) nCX && GetSystemMetrics(SM_CYICON) == (int) nCY)) ||
                 (GetSystemMetrics(SM_CXSMICON) == (int) nCX && GetSystemMetrics(SM_CYSMICON) == (int) nCY));

    if (NULL == pszSpec) 
    {
        return NULL;
    }

    DWORD dwFlags = 0;
    
    if (HIWORD(PtrToUlong(pszSpec))) 
    {
        if (NULL == *pszSpec) 
        {
            return NULL;
        }
        CMASSERTMSG(NULL == CmStrchrA(pszSpec, ','), TEXT("dll,id syntax no longer supported "));

        // If the HIWORD is empty, it's a resource ID, else it is a string.
        dwFlags |= LR_LOADFROMFILE;
    }

    if (nResType == IMAGE_BITMAP)
    {
        dwFlags |= LR_CREATEDIBSECTION;
    }

    // Apparently, this is intended to cause the low-order word of the 
    // name to used as an OEM image identifier by LoadImage on Win95. 
    
    HINSTANCE hInstTmp = (dwFlags & LR_LOADFROMFILE) ? NULL : hMainInst;
    
    hRes = LoadImageA(hInstTmp, pszSpec, nResType, nCX, nCY, (UINT) dwFlags);

#ifdef DEBUG
    if (!hRes)
    {
        if (dwFlags & LR_LOADFROMFILE)
        {
            CMTRACE3A("LoadImage(hInst=0x%x, pszSpec=%S, dwFlags|dwImageFlags=0x%x) failed.", hInstTmp, pszSpec, dwFlags);
        }
        else
        {
            CMTRACE3A("LoadImage(hInst=0x%x, pszSpec=0x%x, dwFlags|dwImageFlags=0x%x) failed.", hInstTmp, pszSpec, dwFlags);
        }
    }
#endif

    return hRes;
}

//+---------------------------------------------------------------------------
//
//  Function:   CmLoadImageW
//
//  Synopsis:   Wide Wrapper for LoadImage API which loads a resource based upon
//              pszSpec which can be any of 2 formats:
//
//              1) Filename
//              2) Resource ID name
//
//  Arguments:  hMainInst - Our application instance handle
//              pszSpec   - The name of the resource
//              nResType  - The resource type
//              nCX       - Resource X dimension (ie. 32 X 32 icon)
//              nCY       - Resource Y dimension (ie. 32 X 32 icon)
//
// Notes:       Now includes hInst of main app for portability, due to different OS 
//              implementations of GetModuleHandle, the 16-bit compilation would grab 
//              default icons (ie. Question Mark) from the system dll.
//
//  Returns:    TRUE on Success
//
//  History:    a-nichb     Re-Written                      03/21/1997
//              quintinb    Implemented Wide/ANSI forms     04/08/1999
//              sumitc      cleanup                         03/14/2000
//
//----------------------------------------------------------------------------

HANDLE CmLoadImageW(HINSTANCE hMainInst, LPCWSTR pszSpec, UINT nResType, UINT nCX, UINT nCY) 
{
    HANDLE hRes = NULL;
    
    // Ensure that the resource is one we can handle
    MYDBGASSERT(nResType == IMAGE_BITMAP || nResType == IMAGE_ICON);
    // enforce that icons can only be 16x16 or 32x32.
    MYDBGASSERT(nResType != IMAGE_ICON ||
                ((GetSystemMetrics(SM_CXICON) == (int) nCX && GetSystemMetrics(SM_CYICON) == (int) nCY)) ||
                 (GetSystemMetrics(SM_CXSMICON) == (int) nCX && GetSystemMetrics(SM_CYSMICON) == (int) nCY));

    if (NULL == pszSpec) 
    {
        return NULL;
    }

    DWORD dwFlags = 0;
    
    if (HIWORD(PtrToUlong(pszSpec))) 
    {
        if (NULL == *pszSpec) 
        {
            return NULL;
        }
        CMASSERTMSG(NULL == CmStrchrW(pszSpec, L','), TEXT("dll,id syntax no longer supported "));

        // If the HIWORD is empty, it's a resource ID, else it is a string.
        dwFlags |= LR_LOADFROMFILE;
        
    }

    if (nResType == IMAGE_BITMAP)
    {
        dwFlags |= LR_CREATEDIBSECTION;
    }

    // Apparently, this is intended to cause the low-order word of the 
    // name to used as an OEM image identifier by LoadImage on Win95. 

    HINSTANCE hInstTmp = (dwFlags & LR_LOADFROMFILE) ? NULL : hMainInst;
    
    hRes = LoadImageU(hInstTmp, pszSpec, nResType, nCX, nCY, (UINT) dwFlags);

#ifdef DEBUG
    if (!hRes)
    {
        if (dwFlags & LR_LOADFROMFILE)
        {
            CMTRACE3W(L"LoadImage(hInst=0x%x, pszSpec=%s, dwFlags|dwImageFlags=0x%x) failed.", hInstTmp, pszSpec, dwFlags);
        }
        else
        {
            CMTRACE3W(L"LoadImage(hInst=0x%x, pszSpec=0x%x, dwFlags|dwImageFlags=0x%x) failed.", hInstTmp, pszSpec, dwFlags);
        }
    }
#endif
    
    return hRes;
}

//+---------------------------------------------------------------------------
//
//  Function:   CmLoadIconA
//
//  Synopsis:   This function loads a large icon from the given file path or
//              the given instance handle and resource ID.
//
//  Arguments:  HINSTANCE hInst - Instance Handle
//              LPCSTR pszSpec - either filename path or a resource ID, see
//                               CmLoadImage for details.
//
//  Returns:    HICON - Handle to an Icon on Success, NULL on Failure
//
//  History:    quintinb    Created Header      01/13/2000
//
//----------------------------------------------------------------------------
HICON CmLoadIconA(HINSTANCE hInst, LPCSTR pszSpec) 
{
    return ((HICON) CmLoadImageA(hInst,
                                 pszSpec,
                                 IMAGE_ICON,
                                 GetSystemMetrics(SM_CXICON),
                                 GetSystemMetrics(SM_CYICON)));
}

//+---------------------------------------------------------------------------
//
//  Function:   CmLoadIconW
//
//  Synopsis:   This function loads a large icon from the given file path or
//              the given instance handle and resource ID.
//
//  Arguments:  HINSTANCE hInst - Instance Handle
//              LPCWSTR pszSpec - either filename path or a resource ID, see
//                               CmLoadImage for details.
//
//  Returns:    HICON - Handle to an Icon on Success, NULL on Failure
//
//  History:    quintinb    Created Header      01/13/2000
//
//----------------------------------------------------------------------------
HICON CmLoadIconW(HINSTANCE hInst, LPCWSTR pszSpec) 
{
    return ((HICON) CmLoadImageW(hInst,
                                 pszSpec,
                                 IMAGE_ICON,
                                 GetSystemMetrics(SM_CXICON),
                                 GetSystemMetrics(SM_CYICON)));
}


//+---------------------------------------------------------------------------
//
//  Function:   CmLoadSmallIconA
//
//  Synopsis:   This function loads a small icon from the given file path or
//              the given instance handle and resource ID.
//
//  Arguments:  HINSTANCE hInst - Instance Handle
//              LPCWSTR pszSpec - either filename path or a resource ID, see
//                               CmLoadImage for details.
//
//  Returns:    HICON - Handle to an Icon on Success, NULL on Failure
//
//  History:    quintinb    Created Header      01/13/2000
//
//----------------------------------------------------------------------------
HICON CmLoadSmallIconA(HINSTANCE hInst, LPCSTR pszSpec) 
{
    HICON hRes = NULL;

    hRes = (HICON) CmLoadImageA(hInst,
                                pszSpec,
                                IMAGE_ICON,
                                GetSystemMetrics(SM_CXSMICON),
                                GetSystemMetrics(SM_CYSMICON));
    if (!hRes) 
    {
        hRes = CmLoadIconA(hInst, pszSpec);
    }

    return hRes;
}

//+---------------------------------------------------------------------------
//
//  Function:   CmLoadSmallIconW
//
//  Synopsis:   This function loads a small icon from the given file path or
//              the given instance handle and resource ID.
//
//  Arguments:  HINSTANCE hInst - Instance Handle
//              LPCWSTR pszSpec - either filename path or a resource ID, see
//                               CmLoadImage for details.
//
//  Returns:    HICON - Handle to an Icon on Success, NULL on Failure
//
//  History:    quintinb    Created Header      01/13/2000
//
//----------------------------------------------------------------------------
HICON CmLoadSmallIconW(HINSTANCE hInst, LPCWSTR pszSpec) 
{
    HICON hRes = NULL;

    hRes = (HICON) CmLoadImageW(hInst,
                                pszSpec,
                                IMAGE_ICON,
                                GetSystemMetrics(SM_CXSMICON),
                                GetSystemMetrics(SM_CYSMICON));
    if (!hRes) 
    {
        hRes = CmLoadIconW(hInst, pszSpec);
    }

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmutil\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     main.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Main entry point for cmutil.dll
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:	 henryt     Created   03/01/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "cmlog.h"

HINSTANCE g_hInst = NULL;

//
// thread local storage index
//
DWORD  g_dwTlsIndex;

extern HANDLE g_hProcessHeap;  // defined in mem.cpp
extern void EndDebugMemory();  // impemented in mem.cpp

extern "C" BOOL WINAPI DllMain(
    HINSTANCE   hinstDLL,       // handle to DLL module 
    DWORD       fdwReason,      // reason for calling function 
    LPVOID      lpvReserved     // reserved 
)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        //
        //  First Things First, lets initialize the U Api's
        //
        if (!InitUnicodeAPI())
        {
            //
            //  Without our U api's we are going no where.  Bail.
            //
            return FALSE;
        }

        g_hProcessHeap = GetProcessHeap();

        //
        // alloc tls index
        //
        g_dwTlsIndex = TlsAlloc();
        if (g_dwTlsIndex == TLS_OUT_OF_INDEXES)
        {
            return FALSE;
        }
        
        MYVERIFY(DisableThreadLibraryCalls(hinstDLL));

        g_hInst = hinstDLL;
    }

    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        //
        // free the tls index
        //
        if (g_dwTlsIndex != TLS_OUT_OF_INDEXES)
        {
            TlsFree(g_dwTlsIndex);
        }

        if (!UnInitUnicodeAPI())
        {
            CMASSERTMSG(FALSE, TEXT("cmutil Dllmain, UnInitUnicodeAPI failed - we are probably leaking a handle"));
        }

#ifdef  DEBUG
        EndDebugMemory();
#endif
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cnetcfg\clsutil.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  CLSUTIL.H - header file for utility C++ classes
//

//  HISTORY:
//  
//  12/07/94  jeremys    Borrowed from WNET common library
//

#ifndef _CLSUTIL_H_
#define _CLSUTIL_H_

/*************************************************************************

    NAME:    BUFFER_BASE

    SYNOPSIS:  Base class for transient buffer classes

    INTERFACE:  BUFFER_BASE()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Returns TRUE if
          successful.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    None

    USES:    None

    CAVEATS:  This is an abstract class, which unifies the interface
        of BUFFER, GLOBAL_BUFFER, etc.

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created base class

**************************************************************************/

class BUFFER_BASE
{
protected:
  UINT _cb;

  virtual BOOL Alloc( UINT cbBuffer ) = 0;
  virtual BOOL Realloc( UINT cbBuffer ) = 0;

public:
  BUFFER_BASE()
    { _cb = 0; }  // buffer not allocated yet
  ~BUFFER_BASE()
    { _cb = 0; }  // buffer size no longer valid
  BOOL Resize( UINT cbNew );
  UINT QuerySize() const { return _cb; };
};

#define GLOBAL_BUFFER  BUFFER

/*************************************************************************

    NAME:    BUFFER

    SYNOPSIS:  Wrapper class for new and delete

    INTERFACE:  BUFFER()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Only works if the
          buffer hasn't been allocated yet.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    BUFFER_BASE

    USES:    operator new, operator delete

    CAVEATS:

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created

**************************************************************************/

class BUFFER : public BUFFER_BASE
{
protected:
  CHAR *_lpBuffer;

  virtual BOOL Alloc( UINT cbBuffer );
  virtual BOOL Realloc( UINT cbBuffer );

public:
  BUFFER( UINT cbInitial=0 );
  ~BUFFER();
  BOOL Resize( UINT cbNew );
  CHAR * QueryPtr() const { return (CHAR *)_lpBuffer; }
  operator CHAR *() const { return (CHAR *)_lpBuffer; }
};

class RegEntry
{
  public:
    RegEntry(const char *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
    ~RegEntry();
    
    long  GetError()  { return _error; }
    long  SetValue(const char *pszValue, const char *string);
    long  SetValue(const char *pszValue, unsigned long dwNumber);
    char *  GetString(const char *pszValue, char *string, unsigned long length);
    long  GetNumber(const char *pszValue, long dwDefault = 0);
    long  DeleteValue(const char *pszValue);
    long  FlushKey();
        long    MoveToSubKey(const char *pszSubKeyName);
        HKEY    GetKey()    { return _hkey; }

  private:
    HKEY  _hkey;
    long  _error;
        BOOL    bhkeyValid;
};

class RegEnumValues
{
  public:
    RegEnumValues(RegEntry *pRegEntry);
    ~RegEnumValues();
    long  Next();
    char *  GetName()       {return pchName;}
        DWORD   GetType()       {return dwType;}
        LPBYTE  GetData()       {return pbValue;}
        DWORD   GetDataLength() {return dwDataLength;}
    long  GetError()  { return _error; }

  private:
        RegEntry * pRegEntry;
    DWORD   iEnum;
        DWORD   cEntries;
    CHAR *  pchName;
    LPBYTE  pbValue;
        DWORD   dwType;
        DWORD   dwDataLength;
        DWORD   cMaxValueName;
        DWORD   cMaxData;
        LONG    _error;
};

/*************************************************************************

    NAME:    WAITCURSOR

    SYNOPSIS:  Sets the cursor to an hourclass until object is destructed

**************************************************************************/
class WAITCURSOR
{
private:
    HCURSOR m_curOld;
    HCURSOR m_curNew;

public:
    WAITCURSOR() { m_curNew = ::LoadCursor( NULL, IDC_WAIT ); m_curOld = ::SetCursor( m_curNew ); }
    ~WAITCURSOR() { ::SetCursor( m_curOld ); }
};

#endif  // _CLSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmutil\font.cpp ===
//+----------------------------------------------------------------------------
//
// File:     font.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Font handling utility routines provided by CMUTIL
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb       Created   04/11/99
//
//+----------------------------------------------------------------------------

//
//  Moved these routines from cmutil\misc.cpp
//

#include "cmmaster.h"


//+---------------------------------------------------------------------------
//
//  Function:   EnumChildProc
//
//  Synopsis:   Callback function to manipulate enumerated child windows.
//              Interprets lParam as a font and applies it to each child.
//
//  Arguments:  hwndChild - Handle of child control
//              lParam    - App defined data (font)
//
//  Returns:    TRUE
//
//  Note:       This function is never exposed to clients of CMUTIL
// 
//  History:    5/13/97 - a-nichb - Created
//
//----------------------------------------------------------------------------

BOOL CALLBACK EnumChildProc(HWND hwndChild, LPARAM lParam) 
{
    HFONT hFont = (HFONT) lParam;

    if (hFont)
    {
        SendMessageU(hwndChild, WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
    }
    
    MYDBGTST(!hFont, (TEXT("EnumChildProc() - Invalid hFont - NULL lParam.")));

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   MakeBold
//
//  Synopsis:   Bold the text in the given window (usually a control).  The
//              caller is responsbile for calling ReleaseBold to free the
//              allocated font resources.
//
//  Arguments:  hwnd - Window handle of the page
//              fSize - If height should be changed proportionately
//
//  Returns:    ERROR_SUCCESS if successful
//              Otherwise error code
// 
//  History:    10/16/1996    VetriV        Created
//              01/12/2000    Quintinb      Commonized for Cmmon and Profwiz
//----------------------------------------------------------------------------
CMUTILAPI HRESULT MakeBold (HWND hwnd, BOOL fSize)
{
    HRESULT hr = ERROR_SUCCESS;
    HFONT hfont = NULL;
    HFONT hnewfont = NULL;
    LOGFONTA* plogfont = NULL;

    //
    //  No window, no-op
    //
    if (!hwnd)
    {
        goto MakeBoldExit;
    }

    //
    //  Get the current Font
    //
    hfont = (HFONT)SendMessageU(hwnd, WM_GETFONT, 0, 0);
    
    if (!hfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    //
    //  Allocate a logical font struct to work with
    //
    plogfont = (LOGFONTA*) CmMalloc(sizeof(LOGFONTA));
    
    if (!plogfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    //
    //  Get the logical font and make it bold and a larger size
    //  if the caller specified the fSize flag as TRUE.
    //
    if (!GetObjectA(hfont, sizeof(LOGFONTA), (LPVOID)plogfont))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    if (abs(plogfont->lfHeight) < 24 && fSize)
    {
        plogfont->lfHeight = plogfont->lfHeight + (plogfont->lfHeight / 4);
    }

    plogfont->lfWeight = FW_BOLD;

    //
    //  Create the new font
    //
    if (!(hnewfont = CreateFontIndirectA(plogfont)))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    //
    //  Tell the window to use the new font
    //
    SendMessageU(hwnd, WM_SETFONT, (WPARAM)hnewfont, MAKELPARAM(TRUE,0)); //lint !e534 WM_SETFONT doesn't return anything
        
MakeBoldExit:

    CmFree(plogfont);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseBold
//
//  Synopsis:   Release the bold font use for title of the page
//
//  Arguments:  hwnd - Window handle of the page
//
//  Returns:    ERROR_SUCCESS
// 
//  History:    10/16/96    VetriV  Created
//----------------------------------------------------------------------------
CMUTILAPI HRESULT ReleaseBold(HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessageU(hwnd, WM_GETFONT, 0, 0);

    if (hfont) 
    {
        DeleteObject(hfont);
    }
    
    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   UpdateFont
//
//  Synopsis:   Converts all child controls of the specified dialog to use 
//              DBCS compatible font. Use this in WM_INITDIALOG.
//
//  Arguments:  hwnd - Window handle of the dialog
//
//  Returns:    Nothing
// 
//  History:    4/31/97  - a-frankh - Created
//              5/13/97  - a-nichb  - Revised to enum child windows
//
//----------------------------------------------------------------------------
CMUTILAPI void UpdateFont(HWND hDlg)
{
    BOOL bEnum = FALSE;
    HFONT hFont = NULL;
    
    //
    // Get the default UI font, or system font if that fails
    //

    hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
            
    if (hFont == NULL)
    {
        hFont = (HFONT) GetStockObject(SYSTEM_FONT);
    }
            
    //
    // Enum child windows and set new font
    //

    if (hFont)
    {
        bEnum = EnumChildWindows(hDlg, EnumChildProc, (LPARAM) hFont);
        MYDBGTST(!bEnum, (TEXT("UpdateFont() - EnumChildWindows() failed.")));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmutil\strings.cpp ===
//+----------------------------------------------------------------------------
//
// File:     strings.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Basic string manipulation routines
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   henryt     Created   03/01/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//
//  Include the locale-safe replacement for lstrcmpi
//
#define _CMUTIL_STRINGS_CPP_
#include "CompareString.cpp"

//+----------------------------------------------------------------------------
//
// Function:  WzToSz
//
// Synopsis:  Standard conversion function for converting Wide Characters to
//            Ansi Characters
//
// Arguments: IN LPCWSTR pszwStrIn - Input Unicode string
//            OUT LPSTR pszStrOut - Ansi Ouput Buffer
//            IN int nOutBufferSize - number of Chars in pszStrOut
//
// Returns:   int - 0 on failure, if return Value is > nOutBufferSize then the
//                  buffer is too small.  Otherwise the number of chars copied
//                  to pszStrOut.
//
// History:   Created Header    4/22/99
//
//+----------------------------------------------------------------------------
CMUTILAPI int WzToSz(IN LPCWSTR pszwStrIn, OUT LPSTR pszStrOut, IN int nOutBufferSize)
{
    int nReturn = 0;

    //
    //  nOutBufferSize could be 0 and pszStrOut could be NULL (passing zero size and a NULL out
    //  buffer causes WideCharToMultiByte to return the number of chars needed to convert the
    //  input string.  It is used as a sizing technique).  Only check pszwStrIn
    //

    if (pszwStrIn)
    {
        nReturn = WideCharToMultiByte(CP_ACP, 0, pszwStrIn, -1, pszStrOut, nOutBufferSize, NULL, NULL);
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return nReturn; 
}

//+----------------------------------------------------------------------------
//
// Function:  SzToWz
//
// Synopsis:  Standard Wrapper for converting from an Ansi string to a Wide String
//
// Arguments: IN LPCSTR pszInput - Ansi String to Convert
//            OUT LPWSTR pszwOutput - Wide string output buffer
//            IN int nBufferSize - number of chars in Wide String buffer
//
// Returns:   int - 0 on failure, otherwise if return is < nBufferSize then insufficient
//                  buffer space.  Otherwise the number of chars copied to the buffer.
//
// History:   quintinb Created  4/22/99
//
//+----------------------------------------------------------------------------
CMUTILAPI int SzToWz(IN LPCSTR pszInput, OUT LPWSTR pszwOutput, IN int nBufferSize)
{
    int nReturn = 0;

    if (pszInput)
    {
        return MultiByteToWideChar(CP_ACP, 0, pszInput, -1, pszwOutput, nBufferSize);
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return nReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  SzToWzWithAlloc
//
// Synopsis:  Simple wrapper to encapsulate converting a string from
//            MultiByte To Wide Char that Allocates memory using the sizing
//            capabilities of the MultiByteToWideChar Api.
//
// Arguments: LPCSTR pszAnsiString - Source string to be converted.
//
// Returns:   LPWSTR - returns NULL on failure, otherwise the converted string.
//                     The caller is responsible for freeing the Alloc-ed Memory.
//
// History:   quintinb Created    4/8/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR SzToWzWithAlloc(LPCSTR pszAnsiString)
{    
    LPWSTR pszwString = NULL;
    DWORD  dwSize = 0;
        
    //
    //  Find out how large the string is by calling MultiByteToWideChar with
    //  Zero for the size field.
    //
    if (NULL != pszAnsiString)
    {
        dwSize = SzToWz(pszAnsiString, NULL, 0);
        
        CMASSERTMSG((dwSize != 0), TEXT("SzToWzWithAlloc -- First MultiByteToWideChar Failed."));
        
        if (0 != dwSize)
        {
            pszwString = (LPWSTR)CmMalloc(dwSize*sizeof(WCHAR));

            CMASSERTMSG(pszwString, TEXT("SzToWzWithAlloc -- CmMalloc of pszwString Failed."));

            if (pszwString)
            {
                if (!SzToWz(pszAnsiString, pszwString, dwSize))
                {
                    //
                    //  Make sure to return a NULL string if we fail.
                    //
                    CMASSERTMSG(FALSE, TEXT("SzToWzWithAlloc -- Second MultiByteToWideChar Failed."));
                    CmFree(pszwString);
                    pszwString = NULL;
                }
#ifdef DEBUG
                else
                {
                    //
                    //  If this is a debug build then we want to take the Wide string that we are going to
                    //  return, convert it to Ansi and compare it to the original ansi string passed in.
                    //
                    LPSTR pszString;

                    dwSize = WzToSz(pszwString, NULL, 0);

                    if (0 != dwSize)
                    {
                        pszString = (LPSTR)CmMalloc(dwSize*sizeof(CHAR));
                        CMASSERTMSG(pszString, TEXT("SzToWzWithAlloc -- conversion of return value back to original Ansi string failed.  Unable to allocate memory."));

                        if (pszString)
                        {
                            if (WzToSz(pszwString, pszString, dwSize))
                            {
                                MYDBGASSERT(0 == lstrcmpA(pszString, pszAnsiString));
                            }
                            else
                            {
                                CMASSERTMSG(FALSE, TEXT("SzToWzWithAlloc -- conversion of return value back to original Ansi string failed."));
                            }
                            CmFree(pszString);
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("SzToWzWithAlloc -- conversion of return value back to original Ansi string failed.  Unable to properly size the string."));                        
                    }
  
                }
#endif
            }
        }
    }

    return pszwString;
}

//+----------------------------------------------------------------------------
//
// Function:  WzToSzWithAlloc
//
// Synopsis:  Simple wrapper to encapsulate converting a string from
//            Unicode to MBCS that allocates memory using the sizing
//            capabilities of the WideCharToMultiByte Api.
//
// Arguments: LPCWSTR pszwWideString - Source string to be converted.
//
// Returns:   LPSTR - returns NULL on failure, otherwise the converted string.
//                     The caller is responsible for freeing the Alloc-ed Memory.
//
// History:   quintinb Created    4/8/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR WzToSzWithAlloc(LPCWSTR pszwWideString)
{    
    LPSTR pszString = NULL;
    DWORD dwSize = 0;

    //
    //  Find out how large the string is by calling WideCharToMultiByte with
    //  Zero for the size field.
    //
    if (NULL != pszwWideString)
    {
        dwSize = WzToSz(pszwWideString, NULL, 0);

        CMASSERTMSG((0 != dwSize), TEXT("WzToSzWithAlloc -- First WzToSz Failed."));

        if (0 != dwSize)
        {
            pszString = (LPSTR)CmMalloc(dwSize*sizeof(CHAR));

            CMASSERTMSG(pszString, TEXT("WzToSzWithAlloc -- CmMalloc failed to alloc pszString."));

            if (pszString)
            {
                if (!WzToSz(pszwWideString, pszString, dwSize))
                {
                    //
                    //  Make sure to return a NULL string if we fail.
                    //
                    CMASSERTMSG(FALSE, TEXT("WzToSzWithAlloc -- Second WzToSz Failed."));
                    CmFree(pszString);
                    pszString = NULL;
                }
#ifdef DEBUG
                else
                {
                    //
                    //  If this is a debug build then we want to take the Ansi string that we are 
                    //  going to return, convert it to Unicode and compare it to the original Unicode 
                    //  string passed in.
                    //
                    LPWSTR pszwString;
                    dwSize = SzToWz(pszString, NULL, 0);
        
                    if (0 != dwSize)
                    {
                        pszwString = (LPWSTR)CmMalloc(dwSize*sizeof(WCHAR));

                        CMASSERTMSG(pszwString, TEXT("WzToSzWithAlloc -- conversion of return value back to original Ansi string failed.  Unable to allocate memory."));

                        if (pszwString)
                        {
                            if (SzToWz(pszString, pszwString, dwSize))
                            {
                                MYDBGASSERT(0 == lstrcmpU(pszwString, pszwWideString));
                            }
                            else
                            {
                                CMASSERTMSG(FALSE, TEXT("WzToSzWithAlloc -- conversion of return value back to original Ansi string failed."));
                            }
                            CmFree(pszwString);
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("WzToSzWithAlloc -- conversion of return value back to original Ansi string failed.  Unable to properly size the string."));                        
                    }
                }
#endif
            }
        }
    }

    return pszString;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrTrimA
//
// Synopsis:  Helper function to trim leading and trailing blanks from a
//            string
//
// Arguments: LPTSTR pszStr - The string to be trimmed
//
// Returns:   void WINAPI - Nothing
//
// History:   nickball    Created Header   3/11/98
//
//+----------------------------------------------------------------------------
CMUTILAPI void WINAPI CmStrTrimA(LPSTR pszStr) 
{
    //
    // first, skip all the spaces at the begining of the string
    //
    MYDBGASSERT(pszStr);       

    if (pszStr)
    {
        LPSTR pszTmp = pszStr;

        while (CmIsSpaceA(pszTmp)) 
        {
            pszTmp = CharNextA(pszTmp);
        }
        
        if (pszTmp != pszStr) 
        {
            CmMoveMemory(pszStr, pszTmp, lstrlenA(pszTmp)+1);
        }

        //
        // secondly, delete all the spaces at the end of the string
        //
    
        pszTmp = CmEndOfStrA(pszStr);
        while (pszTmp != pszStr) 
        {
            pszTmp = CharPrevA(pszStr, pszTmp);
            if (!CmIsSpaceA(pszTmp)) 
            {
                break;
            }
            *pszTmp = TEXT('\0');
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrTrimW
//
// Synopsis:  Helper function to trim leading and trailing blanks from a
//            string. 
//
// Arguments: LPTSTR pszStr - The string to be trimmed
//
// Returns:   void WINAPI - Nothing
//
// History:   quintinb    Created   2/27/99
//
//+----------------------------------------------------------------------------
CMUTILAPI void WINAPI CmStrTrimW(LPWSTR pszStr)
{  
    //
    // first, skip all the spaces at the begining of the string
    //

    MYDBGASSERT(pszStr);

    if (pszStr)
    {
        LPWSTR pszTmp = pszStr;

        while (CmIsSpaceW(pszTmp)) 
        {
            pszTmp = CharNextU(pszTmp);
        }

        if (pszTmp != pszStr) 
        {
            CmMoveMemory(pszStr, pszTmp, (lstrlenU(pszTmp)+1)*sizeof(WCHAR));
        }

        //
        // secondly, delete all the spaces at the end of the string
        //
    
        pszTmp = CmEndOfStrW(pszStr);

        while (pszTmp != pszStr) 
        {
            pszTmp = CharPrevU(pszStr, pszTmp);

            if (!CmIsSpaceW(pszTmp)) 
            {
                break;
            }

            *pszTmp = TEXT('\0');
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CmIsSpaceA
//
// Synopsis:  Checks to see if the char is a space.  Note that spaces, new line chars,
//            line feed chars, tabs, and most other forms of whitespace are considered
//            spaces.
//
// Arguments: psz - an ansi or dbcs char
//
// Returns:   TRUE or FALSE
//
//+----------------------------------------------------------------------------
CMUTILAPI BOOL WINAPI CmIsSpaceA(LPSTR psz) 
{    
    WORD wType = 0;

    MYDBGASSERT(psz);

    if (psz)
    {
        if (IsDBCSLeadByte(*psz))
        {
            MYVERIFY(GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType));
        }
        else
        {
            MYVERIFY(GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType));
        }
    }

    return (wType & C1_SPACE);
}

//+----------------------------------------------------------------------------
//
// Function:  CmIsSpaceW
//
// Synopsis:  Checks to see if the char is a space.  Note that spaces, new line chars,
//            line feed chars, tabs, and most other forms of whitespace are considered
//            spaces.
//
// Arguments: psz - pointer to a string
//
// Returns:   TRUE or FALSE
//
//+----------------------------------------------------------------------------
CMUTILAPI BOOL WINAPI CmIsSpaceW(LPWSTR pszwStr)
{
    WORD wType = 0;
    LPWSTR pszwNextChar;
    int iCharCount;

    MYDBGASSERT(pszwStr);

    if (pszwStr)
    {
        pszwNextChar = CharNextU(pszwStr);

        iCharCount = (INT)(pszwNextChar - pszwStr);

        if (0 == GetStringTypeExU(LOCALE_USER_DEFAULT, CT_CTYPE1, pszwStr, iCharCount, &wType))
        {
            CMTRACE3(TEXT("CmIsSpaceW -- GetStringTypeExW failed on %s, iCharCount is %d, GLE=%u"), pszwStr, iCharCount, GetLastError());
            return FALSE;
        }
    }
    
    return (wType & C1_SPACE);
}

//+----------------------------------------------------------------------------
//
// Function:  CmIsDigitA
//
// Synopsis:  Checks to see if the char is a digit.
//
// Arguments: psz - an ansi or dbcs char
//
// Returns:   TRUE or FALSE
//
//+----------------------------------------------------------------------------
CMUTILAPI BOOL WINAPI CmIsDigitA(LPSTR psz) 
{
    WORD wType = 0;

    MYDBGASSERT(psz);

    if (psz)
    {
        if (IsDBCSLeadByte(*psz))
        {
            MYVERIFY(GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType));
        }
        else
        {
            MYVERIFY(GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType));
        }
    }

    return (wType & C1_DIGIT);
}

//+----------------------------------------------------------------------------
//
// Function:  CmIsDigitW
//
// Synopsis:  Checks to see if the WCHAR is a digit.
//
// Arguments: pszwStr -- WCHAR string
//
// Returns:   TRUE or FALSE
//
//+----------------------------------------------------------------------------
CMUTILAPI BOOL WINAPI CmIsDigitW(LPWSTR pszwStr)
{
    WORD wType = 0;
    LPWSTR pszwNextChar;
    int iCharCount;

    MYDBGASSERT(pszwStr);

    if (pszwStr)
    {
        pszwNextChar = CharNextU(pszwStr);

        iCharCount = (INT)(pszwNextChar - pszwStr);

        if (0 == GetStringTypeExU(LOCALE_USER_DEFAULT, CT_CTYPE1, pszwStr, iCharCount, &wType))
        {
            CMTRACE1(TEXT("CmIsDigitW -- GetStringTypeExU failed, GLE=%u"), GetLastError());
            return FALSE;
        }
    }

    return (wType & C1_DIGIT);
}


//+----------------------------------------------------------------------------
//
// Function:  CmEndOfStrA
//
// Synopsis:  Given a string, returns the ptr to the end of the string(null char).
//
// Arguments: psz - an ansi or dbcs char
//
// Returns:   LPSTR    ptr to null char
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR WINAPI CmEndOfStrA(LPSTR psz) 
{
    MYDBGASSERT(psz);

    if (psz)
    {
        while (*psz)
        {
            psz = CharNextA(psz);
        }
    }

    return psz;
}

//+----------------------------------------------------------------------------
//
// Function:  CmEndOfStrW
//
// Synopsis:  Given a string, returns the ptr to the end of the string(null char).
//
// Arguments: pszwStr - a WCHAR
//
// Returns:   LPWSTR    ptr to null char
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR WINAPI CmEndOfStrW(LPWSTR pszwStr)
{
    MYDBGASSERT(pszwStr);

    if (pszwStr)
    {
        while (*pszwStr)
        {
            pszwStr = CharNextU(pszwStr);
        }
    }

    return pszwStr;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrCpyAllocA
//
// Synopsis:  Copies pszSrc into a newly allocated buffer (using CmMalloc) and
//            returns the buffer to its caller who is responsible for freeing
//            the buffer.
//
// Arguments: LPCSTR pszSrc - source string
//
// Returns:   LPSTR - returns NULL if pszSrc is NULL or the Alloc fails,
//                     otherwise it returns the newly allocated buffer with
//                     a copy of pszSrc in it.
//
// History:   quintinb  Created Header and changed name to include Alloc   4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmStrCpyAllocA(LPCSTR pszSrc) 
{
    LPSTR pszBuffer = NULL;

    if (pszSrc)
    {
        pszBuffer = (LPSTR) CmMalloc(lstrlenA(pszSrc) + 1);

        if (pszBuffer) 
        {
            lstrcpyA(pszBuffer, pszSrc);
        }
    }

    return (pszBuffer);
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrCpyAllocW
//
// Synopsis:  Copies pszSrc into a newly allocated buffer (using CmMalloc) and
//            returns the buffer to its caller who is responsible for freeing
//            the buffer.
//
// Arguments: LPCSTR pszSrc - source string
//
// Returns:   LPSTR - returns NULL if pszSrc is NULL or the Alloc fails,
//                    otherwise it returns the newly allocated buffer with
//                    a copy of pszSrc in it.
//
// History:   quintinb  Created Header and changed name to include Alloc   4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmStrCpyAllocW(LPCWSTR pszSrc) 
{
    LPWSTR pszBuffer = NULL;

    if (pszSrc)
    {
        size_t nLen = lstrlenU(pszSrc) + 1;

        pszBuffer = (LPWSTR) CmMalloc(nLen*sizeof(WCHAR));

        if (pszBuffer) 
        {
            lstrcpyU(pszBuffer, pszSrc);
        }
    }

    return (pszBuffer);
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrCatAllocA
//
// Synopsis:  This function reallocs the passed in string to a size large enough
//            to hold the original data and the concatenates the new string onto
//            the original string.
//
// Arguments: LPSTR *ppszDst - original string
//            LPCSTR pszSrc - new piece of string to concatenate
//
// Returns:   LPSTR - pointer to the concatenated string
//
// History:   quintinb Created Header    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmStrCatAllocA(LPSTR *ppszDst, LPCSTR pszSrc) 
{
    if (!ppszDst) 
    {
        return NULL;
    }

    if (pszSrc && *pszSrc) 
    {
        DWORD dwSize = (lstrlenA(*ppszDst) + lstrlenA(pszSrc) + 1);
        LPSTR pszTmp = (LPSTR)CmRealloc((LPVOID)*ppszDst, dwSize);

        if (NULL != pszTmp)
        {
            lstrcatA(pszTmp, pszSrc);
            *ppszDst = pszTmp;
        }
    }

    return (*ppszDst);
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrCatAllocW
//
// Synopsis:  This function reallocs the passed in string to a size large enough
//            to hold the original data and the concatenates the new string onto
//            the original string.
//
// Arguments: LPWSTR *ppszDst - original string
//            LPCWSTR pszSrc - new piece of string to concatenate
//
// Returns:   LPWSTR - pointer to the concatenated string
//
// History:   quintinb Created Header    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmStrCatAllocW(LPWSTR *ppszDst, LPCWSTR pszSrc) 
{
    if (!ppszDst) 
    {
        return NULL;
    }

    if (pszSrc && *pszSrc) 
    {
        DWORD dwSize = (lstrlenU(*ppszDst) + lstrlenU(pszSrc) + 1)*sizeof(WCHAR);
        LPWSTR pszTmp = (LPWSTR)CmRealloc((LPVOID)*ppszDst, dwSize);

        if (NULL != pszTmp)
        {
            lstrcatU(pszTmp, pszSrc);
            *ppszDst = pszTmp;
        }
    }

    return (*ppszDst);
}


//+----------------------------------------------------------------------------
//
// Function:  CmStrchrA
//
// Synopsis:  This function returns the first occurence of ch in the string pszString.
//
// Arguments: LPCSTR pszString - String to search in
//            CHAR ch - character to look for
//
// Returns:   LPSTR - pointer to the first occurence of the Character ch in pszString
//
// History:   quintinb Created Header    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR WINAPI CmStrchrA(LPCSTR pszString, const char ch)
{
    LPSTR pszTmp = (LPSTR)pszString;

    if (NULL == pszTmp)
    {
        CMASSERTMSG(FALSE, TEXT("CmStrchr - NULL pointer passed"));
        return NULL;
    }

    while (*pszTmp && (*pszTmp != ch))
    {
        pszTmp = CharNextA(pszTmp);
    }

    if (*pszTmp == ch)
    {
        return pszTmp;
    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrchrW
//
// Synopsis:  This function returns the first occurence of ch in the string pszString.
//
// Arguments: LPCWSTR pszString - String to search in
//            WCHAR ch - character to look for
//
// Returns:   LPWSTR - pointer to the first occurence of the Character ch in pszString
//
// History:   quintinb Created Header    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR WINAPI CmStrchrW(LPCWSTR pszString, const WCHAR ch)
{
    LPWSTR pszTmp = (LPWSTR)pszString;

    if (NULL == pszTmp)
    {
        CMASSERTMSG(FALSE, TEXT("CmStrchr - NULL pointer passed"));
        return NULL;
    }

    while (*pszTmp && (*pszTmp != ch))
    {
        pszTmp = CharNextU(pszTmp);
    }

    if (*pszTmp == ch)
    {
        return pszTmp;
    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrrchrA 
//
// Synopsis:  Find the last occurence of a character in a string
//
// Arguments: LPCSTR pszString - string to search in
//            CHAR ch - character to look for
//
// Returns:   LPSTR - NULL if the char is not found, a pointer to the char in
//                    the string otherwise
//
// History:   quintinb Created Header and cleaned up    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmStrrchrA (LPCSTR pszString, const char ch)
{
    LPSTR pszTmp = NULL;
    LPSTR pszCurrent = (LPSTR)pszString;
    
    if (NULL == pszString)
    {
        CMASSERTMSG(FALSE, TEXT("CmStrrchr - NULL pointer passed"));
    }
    else
    {
        while (TEXT('\0') != *pszCurrent)
        {
            if (ch == (*pszCurrent))
            {
                pszTmp = pszCurrent;
            }
            pszCurrent = CharNextA(pszCurrent);
        }    
    }

    return pszTmp;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrrchrW
//
// Synopsis:  Find the last occurence of a character in a string
//
// Arguments: LPCWSTR pszString - string to search in
//            WCHAR ch - character to look for
//
// Returns:   LPWSTR - NULL if the char is not found, a pointer to the char in
//                     the string otherwise
//
// History:   quintinb Created Header and cleaned up    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmStrrchrW (LPCWSTR pszString, const WCHAR ch)
{
    LPWSTR pszTmp = NULL;
    LPWSTR pszCurrent = (LPWSTR)pszString;

    if (NULL == pszString)
    {
        CMASSERTMSG(FALSE, TEXT("CmStrrchr - NULL pointer passed"));
    }
    else
    {
        while (TEXT('\0') != *pszCurrent)
        {
            if (ch == (*pszCurrent))
            {
                pszTmp = pszCurrent;
            }
            pszCurrent = CharNextU(pszCurrent);
        }    
    }

    return pszTmp;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrtokA
//
// Synopsis:  CM implementation of strtok
//
// Arguments: LPSTR pszStr - string to tokenize or NULL if getting a second token
//            LPCSTR pszControl - set of token chars
//
// Returns:   LPSTR - NULL if no token could be found or a pointer to a token string.
//
// History:   quintinb Created Header and cleaned up for UNICODE conversion    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmStrtokA(LPSTR pszStr, LPCSTR pszControl)
{
    LPSTR pszToken;
    LPSTR pszTmpStr;
    LPCSTR pszTmpCtl;
    LPSTR pszTmpDelim;
    

    //
    //  If the pszStr param is NULL, then we need to retrieve the stored string
    //
    if (NULL != pszStr)
    {
        pszTmpStr = pszStr;
    }
    else
    {
        pszTmpStr = (LPSTR)TlsGetValue(g_dwTlsIndex);
    }

    //
    //  Find beginning of token (skip over leading delimiters). Note that
    //  there is no token if this loop sets string to point to the terminal
    //  null (*string == '\0') 
    //
    while (*pszTmpStr)
    {
        for (pszTmpCtl = pszControl; *pszTmpCtl && *pszTmpCtl != *pszTmpStr; 
             pszTmpCtl = CharNextA(pszTmpCtl))
        {
            ; // do nothing
        }

        if (!*pszTmpCtl)
        {
            break;
        }

        pszTmpStr = CharNextA(pszTmpStr);
    }

    pszToken = pszTmpStr;

    //
    //  Find the end of the token. If it is not the end of the string,
    //  put a null there.
    //
    for ( ; *pszTmpStr ; pszTmpStr = CharNextA(pszTmpStr))
    {
        for (pszTmpCtl = pszControl; *pszTmpCtl && *pszTmpCtl != *pszTmpStr; 
             pszTmpCtl = CharNextA(pszTmpCtl))
        {
            ;   // Do nothing
        }

        if (*pszTmpCtl)
        {
            pszTmpDelim = pszTmpStr;
            pszTmpStr = CharNextA(pszTmpStr);
            *pszTmpDelim = '\0';
            break;
        }
    }

    //
    // Update nextoken (or the corresponding field in the per-thread data structure
    //
    TlsSetValue(g_dwTlsIndex, (LPVOID)pszTmpStr);

    //
    // Determine if a token has been found.
    //
    if (pszToken == pszTmpStr)
    {
        return NULL;
    }
    else
    {
        return pszToken;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrtokW
//
// Synopsis:  CM implementation of strtok
//
// Arguments: LPWSTR pszStr - string to tokenize or NULL if getting a second tokey
//            LPCWSTR pszControl - set of token chars
//
// Returns:   LPWSTR - NULL if no token could be found or a pointer to a token string.
//
// History:   quintinb Created Header and cleaned up for UNICODE conversion    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmStrtokW(LPWSTR pszStr, LPCWSTR pszControl)
{
    LPWSTR pszToken;
    LPWSTR pszTmpStr;
    LPWSTR pszTmpCtl;
    LPWSTR pszTmpDelim;

    //
    //  If the pszStr param is NULL, then we need to retrieve the stored string
    //
    if (NULL != pszStr)
    {
        pszTmpStr = pszStr;
    }
    else
    {
        pszTmpStr = (LPWSTR)TlsGetValue(g_dwTlsIndex);
    }

    //
    //  Find beginning of token (skip over leading delimiters). Note that
    //  there is no token iff this loop sets string to point to the terminal
    //  null (*string == '\0') 
    //
    while (*pszTmpStr)
    {
        for (pszTmpCtl = (LPWSTR)pszControl; *pszTmpCtl && *pszTmpCtl != *pszTmpStr; 
             pszTmpCtl = CharNextU(pszTmpCtl))
        {
            ; // do nothing
        }

        if (!*pszTmpCtl)
        {
            break;
        }

        pszTmpStr = CharNextU(pszTmpStr);
    }

    pszToken = pszTmpStr;
    
    //
    //  Find the end of the token. If it is not the end of the string,
    //  put a null there.
    //
    for ( ; *pszTmpStr ; pszTmpStr = CharNextU(pszTmpStr))
    {
        for (pszTmpCtl = (LPWSTR)pszControl; *pszTmpCtl && *pszTmpCtl != *pszTmpStr; 
             pszTmpCtl = CharNextU(pszTmpCtl))
        {
            ;   // Do nothing
        }

        if (*pszTmpCtl)
        {
            pszTmpDelim = pszTmpStr;
            pszTmpStr = CharNextU(pszTmpStr);
            *pszTmpDelim = L'\0';
            break;
        }
    }

    //
    // Update nextoken (or the corresponding field in the per-thread data structure
    //
    TlsSetValue(g_dwTlsIndex, (LPVOID)pszTmpStr);

    //
    // Determine if a token has been found.
    //
    if (pszToken == pszTmpStr)
    {
        return NULL;
    }
    else
    {
        return pszToken;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrStrA
//
// Synopsis:  Simple replacement for StrStr from C runtime
//
// Arguments: LPCTSTR pszString - The string to search in
//            LPCTSTR pszSubString - The string to search for
//
// Returns:   LPTSTR - Ptr to the first occurence of pszSubString in pszString. 
//                    NULL if pszSubString does not occur in pszString
//
//
// History:   nickball    Created Header    04/01/98
//            nickball    Added ptr check   02/21/99
//            quintinb    rewrote for unicode conversion 04/08/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmStrStrA(LPCSTR pszString, LPCSTR pszSubString)
{
    //
    //  Check the inputs
    //
    MYDBGASSERT(pszString);
    MYDBGASSERT(pszSubString);

    if (NULL == pszSubString || NULL == pszString)
    {
        return NULL;
    }

    //
    //  Check to make sure we have something to look for
    //
    if (TEXT('\0') == pszSubString[0])
    {
        return((LPSTR)pszString);
    }

    //
    //  Okay, start looking for the string
    //
    LPSTR pszCurrent = (LPSTR)pszString;
    LPSTR pszTmp1;
    LPSTR pszTmp2;

    while (*pszCurrent)
    {
        pszTmp1 = pszCurrent;
        pszTmp2 = (LPSTR) pszSubString;

        while (*pszTmp1 && *pszTmp2 && ((*pszTmp1) == (*pszTmp2)))
        {
            pszTmp1 = CharNextA(pszTmp1);
            pszTmp2 = CharNextA(pszTmp2);
        }

        if (TEXT('\0') == *pszTmp2)
        {        
            return pszCurrent;
        }

        pszCurrent = CharNextA(pszCurrent);
    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrStrW
//
// Synopsis:  Simple replacement for StrStr from C runtime
//
// Arguments: LPCTSTR pszString - The string to search in
//            LPCTSTR pszSubString - The string to search for
//
// Returns:   LPTSTR - Ptr to the first occurence of pszSubString in pszString. 
//                    NULL if pszSubString does not occur in pszString
//
//
// History:   nickball    Created Header    04/01/98
//            nickball    Added ptr check   02/21/99
//            quintinb    rewrote for unicode conversion 04/08/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmStrStrW(LPCWSTR pszString, LPCWSTR pszSubString)
{

    //
    //  Check the inputs
    //
    MYDBGASSERT(pszString);
    MYDBGASSERT(pszSubString);

    if (NULL == pszSubString || NULL == pszString)
    {
        return NULL;
    }

    //
    //  Check to make sure we have something to look for
    //
    if (TEXT('\0') == pszSubString[0])
    {
        return((LPWSTR)pszString);
    }

    //
    //  Okay, start looking for the string
    //
    LPWSTR pszCurrent = (LPWSTR)pszString;
    LPWSTR pszTmp1;
    LPWSTR pszTmp2;

    while (*pszCurrent)
    {
        pszTmp1 = pszCurrent;
        pszTmp2 = (LPWSTR) pszSubString;

        while (*pszTmp1 && *pszTmp2 && ((*pszTmp1) == (*pszTmp2)))
        {
            pszTmp1 = CharNextU(pszTmp1);
            pszTmp2 = CharNextU(pszTmp2);
        }

        if (TEXT('\0') == *pszTmp2)
        {        
            return pszCurrent;
        }

        pszCurrent = CharNextU(pszCurrent);
    }

    return NULL;
}


//+----------------------------------------------------------------------------
//
// Function:  CmCompareStringA
//
// Synopsis:  redirected to function in CompareString.cpp
//
//+----------------------------------------------------------------------------
CMUTILAPI int CmCompareStringA(LPCSTR lpString1, LPCSTR lpString2)
{
    return SafeCompareStringA(lpString1, lpString2);
}


//+----------------------------------------------------------------------------
//
// Function:  CmCompareStringW
//
// Synopsis:  redirected to function in CompareString.cpp
//
//+----------------------------------------------------------------------------
CMUTILAPI int CmCompareStringW(LPCWSTR lpString1, LPCWSTR lpString2)
{
    return SafeCompareStringW(lpString1, lpString2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmutil\misc.cpp ===
//+----------------------------------------------------------------------------
//
// File:     misc.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Misc. utility routines provided by CMUTIL
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   henryt     Created   03/01/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

#include "ver.cpp"

//+----------------------------------------------------------------------------
// defines
//+----------------------------------------------------------------------------

#define MAX_STR_LEN 512 // Maximum length for Format Message string
     
//+----------------------------------------------------------------------------
// code
//+----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   IsFarEastNonOSR2Win95()
//
//  Synopsis:   Checks to see if the OS is a far east version of Win95(golden
//              and OPK1, NOT OSR2).
//
//  Arguments:  NONE
//
//  Returns:    TRUE/FALSE
//
//  History:    henryt      07/09/97    Created         
//              nickball    03/11/98    Moved to cmutil
//----------------------------------------------------------------------------
CMUTILAPI BOOL WINAPI IsFarEastNonOSR2Win95(void)
{
    OSVERSIONINFO oviVersion;

    ZeroMemory(&oviVersion, sizeof(oviVersion));
    oviVersion.dwOSVersionInfoSize = sizeof(oviVersion);

    GetVersionEx(&oviVersion);

    //
    // Is it (Win95) and (not OSR2) and (DBCS enabled)?
    // Far east Win95 are DBCS enabled while other non-English versions
    // are SBCS-enabled.
    //
    MYDBGTST((oviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS       &&
              LOWORD(oviVersion.dwBuildNumber) != WIN95_OSR2_BUILD_NUMBER &&
              GetSystemMetrics(SM_DBCSENABLED)), (TEXT("It's a Far East non-OSR2 machine!\n")));

    return (oviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS       &&
            LOWORD(oviVersion.dwBuildNumber) != WIN95_OSR2_BUILD_NUMBER &&
            GetSystemMetrics(SM_DBCSENABLED));

}

//+---------------------------------------------------------------------------
//
//  Function:   CmLoadStringA
//
//  Synopsis:   Loads the ANSI version of the string resource specified by
//              the passed in module instance handle and resource ID.  The
//              function returns the requested string in a CmMalloc-ed buffer
//              through the return value.  This buffer must be freed by the
//              caller.  Note that CmLoadString figures out the proper buffer
//              size by guessing and then calling loadstring again if the buffer
//              is too small.
//
//  Arguments:  HINSTANCE hInst - module to load the string resource from
//              UINT nId - resource ID of the string to load
//
//  Returns:    LPSTR - On success returns a pointer to the requested string
//                      resource.  On failure the function tries to return
//                      a pointer to the Empty string ("") but if the memory
//                      allocation fails it can return NULL.
//
//  History:    quintinb     Created Header     01/14/2000
//
//----------------------------------------------------------------------------
CMUTILAPI LPSTR CmLoadStringA(HINSTANCE hInst, UINT nId) 
{
    //
    // In some far east versions of non-OSR2 win95, LoadString() ignores the 
    // nBufferMax paramater when loading DBCS strings.  As a result, if the
    // DBCS string is bigger than the buffer, the API overwrites the memory.
    // We workaround the bug by using a larger buffer size.
    //
    static fFarEastNonOSR2Win95 = IsFarEastNonOSR2Win95();
    size_t nLen = fFarEastNonOSR2Win95? 
                    FAREAST_WIN95_LOADSTRING_BUFSIZE : 
                    LOADSTRING_BUFSIZE;
    LPSTR pszString;

    if (!nId) 
    {
        return (CmStrCpyAllocA(""));
    }
    while (1) 
    {
        size_t nNewLen;

        pszString = (LPSTR) CmMalloc(nLen*sizeof(CHAR));

        MYDBGASSERT(pszString);
        if (NULL == pszString)
        {
            return (CmStrCpyAllocA(""));
        }
        
        nNewLen = LoadStringA(hInst, nId, pszString, nLen-1);
        //
        // we use nNewLen+3 because a DBCS char len can be 2 and a UNICODE
        // char len is 2.  Ideally, we can use nLen in the above LoadString()
        // call and use nNewLen+2 in the line below.  But nLen+3 is a safer
        // fix now...
        //
        if ((nNewLen + 3) < nLen) 
        {
            return (pszString);
        }

        //
        // shouldn't reach here for far east non osr2
        // this will allow us to catch DBCS string resources that are
        // longer than FAREAST_WIN95_LOADSTRING_BUFSIZE.
        //
        MYDBGASSERT(!fFarEastNonOSR2Win95);

        CmFree(pszString);
        nLen *= 2;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CmLoadStringW
//
//  Synopsis:   Loads the Unicode version of the string resource specified by
//              the passed in module instance handle and resource ID.  The
//              function returns the requested string in a CmMalloc-ed buffer
//              through the return value.  This buffer must be freed by the
//              caller.  Note that CmLoadString figures out the proper buffer
//              size by guessing and then calling loadstring again if the buffer
//              is too small.
//
//  Arguments:  HINSTANCE hInst - module to load the string resource from
//              UINT nId - resource ID of the string to load
//
//  Returns:    LPWSTR - On success returns a pointer to the requested string
//                       resource.  On failure the function tries to return
//                       a pointer to the Empty string ("") but if the memory
//                       allocation fails it can return NULL.
//
//  History:    quintinb     Created Header     01/14/2000
//
//----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmLoadStringW(HINSTANCE hInst, UINT nId) 
{  
    size_t nLen = LOADSTRING_BUFSIZE;

    LPWSTR pszString;

    if (!nId) 
    {
        return (CmStrCpyAllocW(L""));
    }

    while (1) 
    {
        size_t nNewLen;

        pszString = (LPWSTR) CmMalloc(nLen*sizeof(WCHAR));
        
        MYDBGASSERT(pszString);
        if (NULL == pszString)
        {
            return (CmStrCpyAllocW(L""));
        }
        
        nNewLen = LoadStringU(hInst, nId, pszString, nLen-1);
        //
        // we use nNewLen+3 because a DBCS char len can be 2 and a UNICODE
        // char len is 2.  Ideally, we can use nLen in the above LoadString()
        // call and use nNewLen+2 in the line below.  But nLen+3 is a safer
        // fix now...
        //
        if ((nNewLen + 3) < nLen) 
        {
            return (pszString);
        }

        CmFree(pszString);
        nLen *= 2;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CmFmtMsgW
//
//  Synopsis:   Simulation of FormatMessage using wvsprintf for cross-platform
//              compatibility.
//
//  Arguments:  hInst   - Application instance handle
//              dwMsgId - ID of message to use for formatting final output
//              ...     - Variable arguments to used in message fromatting
//
//  Returns:    Allocated to formatted string.
//
//  History:    nickball - Added function header    - 5/12/97
//              nickball - Moved to cmutil          - 03/30/98    
//              quintinb - Added W and A versions   - 03/09/99
//
//----------------------------------------------------------------------------

CMUTILAPI LPWSTR CmFmtMsgW(HINSTANCE hInst, DWORD dwMsgId, ...) 
{
    LPWSTR pszTmp = NULL;
    LPWSTR lpszOutput = NULL;
    LPWSTR lpszFormat = NULL;

    if (!dwMsgId) 
    {
        return (CmStrCpyAllocW(L""));
    }
    
    // Allocate a buffer to receive the RC string with specified msg ID

    lpszFormat = (LPWSTR) CmMalloc(MAX_STR_LEN*sizeof(WCHAR));

    if (!lpszFormat)
    {
        CMASSERTMSG(FALSE, "CmFmtMsgW -- CmMalloc returned a NULL pointer for lpszFormat");
        return (CmStrCpyAllocW(L""));
    }
    
    // Initialize argument list

    va_list valArgs;
    va_start(valArgs,dwMsgId);

    // Load the format string from the RC

    int nRes = LoadStringU(hInst, (UINT) dwMsgId, lpszFormat, MAX_STR_LEN - 1);

#ifdef DEBUG
    if (0 == nRes)
    {
        CMTRACE3(TEXT("MyFmtMsg() LoadString(dwMsgId=0x%x) return %u, GLE=%u."), dwMsgId, nRes, 
            nRes ? 0: GetLastError());
    }
#endif

    // If nothing loaded, free format buffer and bail

    if (nRes == 0 || lpszFormat[0] == '\0') 
    {
        CMASSERTMSG(FALSE, "CmFmtMsgW -- LoadStringU returned 0 or an empty buffer.");
        pszTmp = (CmStrCpyAllocW(L""));
        goto done;
    }

    // Allocate another buffer and for use by vsprintf

    lpszOutput = (LPWSTR) CmMalloc(MAX_STR_LEN*sizeof(WCHAR));

    if (!lpszOutput)
    {
        CMASSERTMSG(FALSE, "CmFmtMsgW -- CmMalloc returned a NULL pointer for lpszOutput");
        pszTmp = (CmStrCpyAllocW(L""));
        goto done;
    }

    // Format the final output using vsprintf

    nRes = wvsprintfU(lpszOutput, lpszFormat, valArgs);
    
    // If wvsprintfU failed, we're done 

    if (nRes < 0 || lpszOutput[0] == L'\0') 
    {
        CMASSERTMSG(FALSE, "CmFmtMsgW -- wvsprintfU returned 0 or an empty buffer");
        pszTmp = (CmStrCpyAllocW(L""));
        goto done;
    }
    
    // Remove trailing spaces

    pszTmp = lpszOutput + lstrlenU(lpszOutput) - 1;
    while (CmIsSpaceW(pszTmp) && (*pszTmp != L'\n')) 
    {
        *pszTmp = 0;
        if (pszTmp == lpszOutput) 
        {
            break;
        }
        pszTmp--;
    }

    pszTmp = CmStrCpyAllocW(lpszOutput); // allocates and copies
    CMASSERTMSG(pszTmp, "CmFmtMsgW -- CmStrCpyAllocW returned a NULL pointer.");

done:
    
    // Cleanup buffers, etc.

    if (lpszFormat)
    {
        CmFree(lpszFormat);
    }
    
    if (lpszOutput)
    {
        CmFree(lpszOutput);
    }
    
    va_end(valArgs);
    
    return (pszTmp);
}

//+---------------------------------------------------------------------------
//
//  Function:   CmFmtMsgA
//
//  Synopsis:   Simulation of FormatMessage using wvsprintf for cross-platform
//              compatibility.
//
//  Arguments:  hInst   - Application instance handle
//              dwMsgId - ID of message to use for formatting final output
//              ...     - Variable arguments to used in message fromatting
//
//  Returns:    Allocated to formatted string.
//
//  History:    nickball - Added function header    - 5/12/97
//              nickball - Moved to cmutil          - 03/30/98
//              quintinb - Added W and A versions   - 03/09/99    
//
//----------------------------------------------------------------------------

CMUTILAPI LPSTR CmFmtMsgA(HINSTANCE hInst, DWORD dwMsgId, ...) 
{
    LPSTR pszTmp = NULL;
    LPSTR lpszOutput = NULL;
    LPSTR lpszFormat = NULL;

    if (!dwMsgId) 
    {
        return (CmStrCpyAllocA(""));
    }
    
    // Allocate a buffer to receive the RC string with specified msg ID

    lpszFormat = (LPSTR) CmMalloc(MAX_STR_LEN);

    if (!lpszFormat)
    {
        CMASSERTMSG(FALSE, "CmFmtMsgA -- CmMalloc returned a NULL pointer for lpszFormat");
        return (CmStrCpyAllocA(""));
    }
    
    // Initialize argument list

    va_list valArgs;
    va_start(valArgs,dwMsgId);

    // Load the format string from the RC

    int nRes = LoadStringA(hInst, (UINT) dwMsgId, lpszFormat, MAX_STR_LEN - 1);
#ifdef DEBUG
    if (0 == nRes)
    {
        CMTRACE3(TEXT("MyFmtMsg() LoadString(dwMsgId=0x%x) return %u, GLE=%u."), dwMsgId, nRes, 
            nRes ? 0: GetLastError());
    }
#endif

    // If nothing loaded, free format buffer and bail

    if (nRes == 0 || lpszFormat[0] == '\0') 
    {
        pszTmp = (CmStrCpyAllocA(""));
        CMASSERTMSG(FALSE, "CmFmtMsgA -- LoadStringA returned 0 or an empty buffer.");
        goto done;
    }

    // Allocate another buffer and for use by vsprintf

    lpszOutput = (LPSTR) CmMalloc(MAX_STR_LEN);

    if (!lpszOutput)
    {
        pszTmp = (CmStrCpyAllocA(""));
        CMASSERTMSG(FALSE, "CmFmtMsgA -- CmMalloc returned a NULL pointer for lpszOutput");
        goto done;
    }

    // Format the final output using vsprintf

    nRes = wvsprintfA(lpszOutput, lpszFormat, valArgs);
    
    // If wvsprintfA failed, we're done 

    if (nRes < 0 || lpszOutput[0] == '\0') 
    {
        pszTmp = (CmStrCpyAllocA(""));
        CMASSERTMSG(FALSE, "CmFmtMsgA -- wvsprintfA returned 0 or an empty buffer");
        goto done;
    }
    
    // Remove trailing spaces

    pszTmp = lpszOutput + lstrlenA(lpszOutput) - 1;
    while (CmIsSpaceA(pszTmp) && (*pszTmp != '\n')) 
    {
        *pszTmp = 0;
        if (pszTmp == lpszOutput) 
        {
            break;
        }
        pszTmp--;
    }

    pszTmp = CmStrCpyAllocA(lpszOutput); // allocates and copies
    CMASSERTMSG(pszTmp, "CmFmtMsgA -- CmStrCpyAllocA returned a NULL pointer.");

done:
    
    // Cleanup buffers, etc.

    if (lpszFormat)
    {
        CmFree(lpszFormat);
    }
    
    if (lpszOutput)
    {
        CmFree(lpszOutput);
    }
    
    va_end(valArgs);
    
    return (pszTmp);

#if 0
/*
    // Replaced by the above code because we no longer use the platform specific .MC files
    // All strings resources are now managed via standard .RC files

    va_list valArgs;
    DWORD dwRes;
    LPTSTR pszBuffer = NULL;

    if (!dwMsgId) 
    {
        return (CmStrCpy(TEXT("")));
    }
    va_start(valArgs,dwMsgId);
    

    dwRes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_MAX_WIDTH_MASK,
                          hInst,
                          dwMsgId,
                          LANG_USER_DEFAULT,
                          (LPTSTR) &pszBuffer,
                          0,
                          &valArgs);
    MYDBGTST(dwRes==0,("MyFmtMsg() FormatMessage(dwMsgId=0x%x) return %u, GLE=%u.",dwMsgId,dwRes,dwRes?0:GetLastError()));
    va_end(valArgs);
    if (dwRes == 0) 
    {
        if (pszBuffer) 
        {
            LocalFree(pszBuffer);
        }
        return (CmStrCpy(TEXT("")));
    }
    if (!CmStrLen(pszBuffer)) 
    {
        LocalFree(pszBuffer);
        return (CmStrCpy(TEXT("")));
    }
    pszTmp = pszBuffer + CmStrLen(pszBuffer) - 1;
    while (MyIsSpace(*pszTmp) && (*pszTmp != '\n')) 
    {
        *pszTmp = 0;
        if (pszTmp == pszBuffer) 
        {
            break;
        }
        pszTmp--;
    }
    pszTmp = CmStrCpy(pszBuffer);
    LocalFree(pszBuffer);

    return (pszTmp);
*/
#endif

}

#if 0 // not used anywhere
/*
//+----------------------------------------------------------------------------
//
// Function:  GetMaxStringNumber
//
// Synopsis:  Given a buffer containing strings in INI section format, determines
//            which is the highest numbered string.
//
// Arguments: LPTSTR pszStr - The string containing an INI section
//            LPDWORD pdwMax - Ptr to a DOWRD to be filled with the result
//            *pdwMax gets the highest value of atol() of the strings.
//
// Returns:   Nothing
//
// History:   Anonymous    Created    3/30/98
//
//+----------------------------------------------------------------------------
CMUTILAPI void GetMaxStringNumber(LPTSTR pszStr, LPDWORD pdwMax)
{
    LPTSTR pszTmp;
    DWORD dwMax = 0;

    if (pszStr) 
    {
        pszTmp = pszStr;
        while (*pszTmp) 
        {
            DWORD dwMaxTmp;

            if (pdwMax) 
            {
                dwMaxTmp = (DWORD)CmAtol(pszTmp);
                if (dwMaxTmp > dwMax) 
                {
                    dwMax = dwMaxTmp;
                }
            }
            pszTmp += lstrlen(pszTmp) + 1;
        }
    }
    if (pdwMax) 
    {
        *pdwMax = dwMax;
    }
}
*/
#endif

//+---------------------------------------------------------------------------
//
//  Function:   CmParsePathW
//
//  Synopsis:   Converts a Cm command line and args path into its component
//              parts. If the command portion is a relative path, it is expanded
//              to a full path. A ptr to the top level service filename is required 
//              to make the relative path determination.
//              
//  Arguments:  pszCmdLine      - Ptr to the full entry
//              pszServiceFile  - Ptr to top-level service filename
//              ppszCommand     - Ptr-ptr to be allocated and filled with command portion
//              ppszArguments   - Ptr-ptr to be allocated and filled with args portion
//
//  Returns:    TRUE if ppszCmd and ppszArgs are allocated/filled. FALSE otherwise.
// 
//  History:    02/19/99    nickball    Created
//              02/21/99    nickball    Moved to cmutil 
//              03/09/99    quintinb    Created A and W versions
//
//----------------------------------------------------------------------------
CMUTILAPI BOOL CmParsePathW(LPCWSTR pszCmdLine, LPCWSTR pszServiceFile, LPWSTR *ppszCommand, LPWSTR *ppszArguments)
{
    LPWSTR pszArgs = NULL;
    LPWSTR pszCmd = NULL;
    LPWSTR pszTmp = NULL;

    BOOL bRet = FALSE;

    MYDBGASSERT(pszCmdLine);
    MYDBGASSERT(pszServiceFile);
    MYDBGASSERT(ppszCommand);
    MYDBGASSERT(ppszArguments);

    if (NULL == pszCmdLine      || 
        NULL == pszServiceFile  ||
        NULL == ppszCommand     ||
        NULL == ppszArguments)
    {       
        return FALSE;    
    }
    
    CMTRACE1(TEXT("CmParsePathW() pszCmdLine is %s"), pszCmdLine);

    //
    // Determine where our string begins and what the delimiting char should
    // be then make a copy of the entire command line string to muck with.
    //

    WCHAR tchDelim = L'+';

    if (pszCmdLine == CmStrchrW(pszCmdLine, tchDelim))
    {
        pszCmd = CmStrCpyAllocW(CharNextU(pszCmdLine));
    }
    else
    {
        pszCmd = CmStrCpyAllocW(pszCmdLine);
        tchDelim = L' ';
    }
    
    MYDBGASSERT(pszCmd);
    CmStrTrimW(pszCmd);

    //
    // Assuming valid inputs, pszCmd is now one of the following:
    //
    // "C:\\Program Files\\Custom.Exe+"
    // "C:\\Program Files\\Custom.Exe+ Args"
    // "C:\\Progra~1\\Custom.Exe 
    // "C:\\Progra~1\\Custom.Exe Args"
    // "service\custom.exe"
    // "service\custom.exe Args"
    //
    
    if (pszCmd && L'\0' != *pszCmd)
    {       
        //
        // Locate the right command delimiter
        //
    
        pszArgs = CmStrchrW(pszCmd, tchDelim);

        if (pszArgs)
        {        
            //
            // Content of pszTmp is now either "+ Args", "", or "+"
            // Get a pointer to the next char and truncate the pszCmd
            // that we have thus far.
            //

            pszTmp = CharNextU(pszArgs);    // pszArgs is " Args" or ""             
            *pszArgs = L'\0';               // The "+" becomes ""
            pszArgs = pszTmp;               // pszTmp is " Args" or ""             
        }

        //
        // Fill argument buffer from pszTmp and command buffer 
        // from pszCmd with a complete path if necessary.
        // 

        if (NULL == pszArgs)
        {
            *ppszArguments = (LPWSTR)CmMalloc(sizeof(WCHAR)); // one Zero-ed WCHAR
        }
        else
        {
            MYVERIFY(*ppszArguments = CmStrCpyAllocW(pszArgs));
        }

        MYVERIFY(*ppszCommand = CmConvertRelativePathW(pszServiceFile, pszCmd));
        
        //
        // Trim blanks as needed
        //
        
        if (*ppszCommand)
        {
            CmStrTrimW(*ppszCommand);
        }
        
        if (*ppszArguments)
        {
            CmStrTrimW(*ppszArguments);
        }

        bRet = TRUE;
    }

    //
    // Cleanup. Note: pszArgs is never allocated, so we don't have to free it.
    //

    CmFree(pszCmd); 

    return bRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CmParsePathA
//
//  Synopsis:   Converts a Cm command line and args path into its component
//              parts. If the command portion is a relative path, it is expanded
//              to a full path. A ptr to the top level service filename is required 
//              to make the relative path determination.
//              
//  Arguments:  pszCmdLine      - Ptr to the full entry
//              pszServiceFile  - Ptr to top-level service filename
//              ppszCommand     - Ptr-ptr to be allocated and filled with command portion
//              ppszArguments   - Ptr-ptr to be allocated and filled with args portion
//
//  Returns:    TRUE if ppszCmd and ppszArgs are allocated/filled. FALSE otherwise.
// 
//  History:    02/19/99    nickball    Created
//              02/21/99    nickball    Moved to cmutil 
//              03/09/99    quintinb    Created A and W versions
//
//----------------------------------------------------------------------------
CMUTILAPI BOOL CmParsePathA(LPCSTR pszCmdLine, LPCSTR pszServiceFile, LPSTR *ppszCommand, LPSTR *ppszArguments)
{
    LPSTR pszArgs = NULL;
    LPSTR pszCmd = NULL;
    LPSTR pszTmp = NULL;

    BOOL bRet = FALSE;

    MYDBGASSERT(pszCmdLine);
    MYDBGASSERT(pszServiceFile);
    MYDBGASSERT(ppszCommand);
    MYDBGASSERT(ppszArguments);

    if (NULL == pszCmdLine      || 
        NULL == pszServiceFile  ||
        NULL == ppszCommand     ||
        NULL == ppszArguments)
    {       
        return FALSE;    
    }
    
    CMTRACE1(TEXT("CmParsePathA() pszCmdLine is %s"), pszCmdLine);

    //
    // Determine where our string begins and what the delimiting char should
    // be then make a copy of the entire command line string to muck with.
    //

    CHAR tchDelim = '+';

    if (pszCmdLine == CmStrchrA(pszCmdLine, tchDelim))
    {
        pszCmd = CmStrCpyAllocA(CharNextA(pszCmdLine));
    }
    else
    {
        pszCmd = CmStrCpyAllocA(pszCmdLine);
        tchDelim = ' ';
    }
    
    MYDBGASSERT(pszCmd);
    CmStrTrimA(pszCmd);

    //
    // Assuming valid inputs, pszCmd is now one of the following:
    //
    // "C:\\Program Files\\Custom.Exe+"
    // "C:\\Program Files\\Custom.Exe+ Args"
    // "C:\\Progra~1\\Custom.Exe 
    // "C:\\Progra~1\\Custom.Exe Args"
    // "service\custom.exe"
    // "service\custom.exe Args"
    //
    
    if (pszCmd && '\0' != *pszCmd)
    {       
        //
        // Locate the right command delimiter
        //
    
        pszArgs = CmStrchrA(pszCmd, tchDelim);

        if (pszArgs)
        {        
            //
            // Content of pszTmp is now either "+ Args", "", or "+"
            // Get a pointer to the next char and truncate the pszCmd
            // that we have thus far.
            //

            pszTmp = CharNextA(pszArgs);    // pszArgs is " Args" or ""             
            *pszArgs = '\0';                // The "+" becomes ""
            pszArgs = pszTmp;               // pszTmp is " Args" or ""             
        }

        //
        // Fill argument buffer from pszTmp and command buffer 
        // from pszCmd with a complete path if necessary.
        // 

        if (NULL == pszArgs)
        {
            MYVERIFY(*ppszArguments = (LPSTR)CmMalloc(sizeof(CHAR))); // one Zero-ed char
        }
        else
        {
            MYVERIFY(*ppszArguments = CmStrCpyAllocA(pszArgs));
        }

        MYVERIFY(*ppszCommand = CmConvertRelativePathA(pszServiceFile, pszCmd));
        
        //
        // Trim blanks as needed
        //
        
        if (*ppszCommand)
        {
            CmStrTrimA(*ppszCommand);
        }
        
        if (*ppszArguments)
        {
            CmStrTrimA(*ppszArguments);
        }

        bRet = TRUE;
    }

    //
    // Cleanup. Note: pszArgs is never allocated, so we don't have to free it.
    //

    CmFree(pszCmd); 

    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CmConvertRelativePathA
//
// Synopsis:  Converts the specified relative path to a full path. If the 
//            specified path is not a relative path specific to this profile, 
//            it is ignored.
//
// Arguments: LPCSTR pszServiceFile - Full path to the .cms file
//            LPCSTR pszRelative    - The relative path fragment
//
// Returns:   LPSTR - NULL on failure
//
// Note:      Do not pass referenced profile service objects to this routine.
//            It is designed to derive the short-service name from the top-level
//            service filename and path.
//
// History:   03/11/98  nickball    Created    
//            02/03/99  nickball    Added header Note
//            02/21/99  nickball    Moved to cmutil
//            03/09/99  quintinb    Added W and A versions
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmConvertRelativePathA(LPCSTR pszServiceFile,
    LPSTR pszRelative)
{
    MYDBGASSERT(pszServiceFile);
    MYDBGASSERT(*pszServiceFile);
    MYDBGASSERT(pszRelative);
    MYDBGASSERT(*pszRelative);

    if (NULL == pszRelative     || 0 == pszRelative[0] ||
        NULL == pszServiceFile  || 0 == pszServiceFile[0])
    {
        return NULL;
    }
    
    //
    // Get the relative dir that we expect to find
    //

    LPSTR pszConverted = NULL;
    LPSTR pszRelDir = CmStripPathAndExtA(pszServiceFile);

    if (pszRelDir && *pszRelDir)
    {
        lstrcatA(pszRelDir, "\\");

        //
        // Compare against the specifed FRAGMENT. If it matches, convert.
        // 

        CharUpperA(pszRelDir);
        CharUpperA(pszRelative);

        if (pszRelative == CmStrStrA(pszRelative, pszRelDir))
        {
            //
            // Combine CMS path and relative for complete
            //

            LPSTR pszTmp = CmStripFileNameA(pszServiceFile, FALSE);           
            pszConverted = CmBuildFullPathFromRelativeA(pszTmp, pszRelative);    
            CmFree(pszTmp);
        }
        else
        {
            //
            // Its not a relative path for this profile, just make a copy
            //
    
            pszConverted = CmStrCpyAllocA(pszRelative);
        }
    }

    CmFree(pszRelDir);

    return pszConverted;
}

//+----------------------------------------------------------------------------
//
// Function:  CmConvertRelativePathW
//
// Synopsis:  Converts the specified relative path to a full path. If the 
//            specified path is not a relative path specific to this profile, 
//            it is ignored.
//
// Arguments: LPCWSTR pszServiceFile - Full path to the .cms file
//            LPCWSTR pszRelative    - The relative path fragment
//
// Returns:   LPWSTR - NULL on failure
//
// Note:      Do not pass referenced profile service objects to this routine.
//            It is designed to derive the short-service name from the top-level
//            service filename and path.
//
// History:   03/11/98  nickball    Created    
//            02/03/99  nickball    Added header Note
//            02/21/99  nickball    Moved to cmutil
//            03/09/99  quintinb    Added W and A versions
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmConvertRelativePathW(LPCWSTR pszServiceFile,
    LPWSTR pszRelative)
{
    MYDBGASSERT(pszServiceFile);
    MYDBGASSERT(*pszServiceFile);
    MYDBGASSERT(pszRelative);
    MYDBGASSERT(*pszRelative);

    if (NULL == pszRelative     || 0 == pszRelative[0] ||
        NULL == pszServiceFile  || 0 == pszServiceFile[0])
    {
        return NULL;
    }
    
    //
    // Get the relative dir that we expect to find
    //

    LPWSTR pszConverted = NULL;
    LPWSTR pszRelDir = CmStripPathAndExtW(pszServiceFile);

    if (pszRelDir && *pszRelDir)
    {
        lstrcatU(pszRelDir, L"\\");

        //
        // Compare against the specifed FRAGMENT. If it matches, convert.
        // 

        CharUpperU(pszRelDir);
        CharUpperU(pszRelative);

        if (pszRelative == CmStrStrW(pszRelative, pszRelDir))
        {
            //
            // Combine CMS path and relative for complete
            //

            LPWSTR pszTmp = CmStripFileNameW(pszServiceFile, FALSE);           
            pszConverted = CmBuildFullPathFromRelativeW(pszTmp, pszRelative);    
            CmFree(pszTmp);
        }
        else
        {
            //
            // Its not a relative path for this profile, just make a copy
            //
    
            pszConverted = CmStrCpyAllocW(pszRelative);
        }
    }

    CmFree(pszRelDir);

    return pszConverted;
}


//+----------------------------------------------------------------------------
//
// Function:  CmStripPathAndExtA
//
// Synopsis:  Helper function, strips path and extension from a filename path
//
// Arguments: pszFileName - the filename path to be modified
//
// Returns:   LPSTR - The base filename sub-string
//
// History:   nickball    Created header   8/12/98
//            nickball    Moved to cmutil   02/21/99
//            quintinb    Added W and A versions 03/09/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmStripPathAndExtA(LPCSTR pszFileName) 
{
    MYDBGASSERT(pszFileName);

    if (NULL == pszFileName)
    {
        return NULL;
    }

    MYDBGASSERT(*pszFileName);
    
    //
    // Make a copy of the string and validate format "\\." required.
    //

    LPSTR pszTmp = CmStrCpyAllocA(pszFileName);
    
    if (NULL == pszTmp)
    {
        MYDBGASSERT(pszTmp);
        return NULL;
    }

    LPSTR pszDot = CmStrrchrA(pszTmp, '.');
    LPSTR pszSlash = CmStrrchrA(pszTmp, '\\');

    if (NULL == pszDot || NULL == pszSlash || pszDot < pszSlash)
    {
        CmFree(pszTmp);
        MYDBGASSERT(FALSE);
        return NULL;
    }
    
    *pszDot = '\0';
   
    //
    // Increment past slash and copy remainder
    //

    pszSlash = CharNextA(pszSlash);       
        
    lstrcpyA(pszTmp, pszSlash);

    return (pszTmp);
}
//+----------------------------------------------------------------------------
//
// Function:  CmStripPathAndExtW
//
// Synopsis:  Helper function, strips path and extension from a filename path
//
// Arguments: pszFileName - the filename path to be modified
//
// Returns:   LPWSTR - The base filename sub-string
//
// History:   nickball    Created header   8/12/98
//            nickball    Moved to cmutil   02/21/99
//            quintinb    Added W and A versions 03/09/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmStripPathAndExtW(LPCWSTR pszFileName) 
{
    MYDBGASSERT(pszFileName);

    if (NULL == pszFileName)
    {
        return NULL;
    }

    MYDBGASSERT(*pszFileName);
    
    //
    // Make a copy of the string and validate format "\\." required.
    //

    LPWSTR pszTmp = CmStrCpyAllocW(pszFileName);

    if (NULL == pszTmp)
    {
        MYDBGASSERT(FALSE);
        return NULL;
    }

    LPWSTR pszDot = CmStrrchrW(pszTmp, L'.');
    LPWSTR pszSlash = CmStrrchrW(pszTmp, L'\\');

    if (NULL == pszDot || NULL == pszSlash || pszDot < pszSlash)
    {
        CmFree(pszTmp);
        MYDBGASSERT(FALSE);
        return NULL;
    }
    
    *pszDot = L'\0';
   
    //
    // Increment past slash and copy remainder
    //

    pszSlash = CharNextU(pszSlash);       
        
    lstrcpyU(pszTmp, pszSlash);

    return (pszTmp);
}

//+----------------------------------------------------------------------------
//
// Function:  CmStripFileNameA
//
// Synopsis:  Helper function to deal with the tedium of extracting the path 
//            part of a complete filename.
//
// Arguments: LPCSTR pszFullNameAndPath - Ptr to the filename 
//            BOOL fKeepSlash - Flag indicating that trailing directory '\' should be retained.
//
// Returns:   LPSTR - Ptr to an allocated buffer containing the dir, or NULL on failure.
//
// Note:      It is up to the caller to provide reasonable input, the only requirement
//            is that the input contain '\'. 
//
// History:   nickball    Created           3/10/98
//            nickball    Moved to cmutil   02/21/99
//            quintinb    Added W and A versions 03/09/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmStripFileNameA(LPCSTR pszFullNameAndPath, BOOL fKeepSlash)
{
    MYDBGASSERT(pszFullNameAndPath);

    if (NULL == pszFullNameAndPath)
    {
        return NULL;
    }

    //
    // Make a copy of the filename and locate the last '\'
    //
    
    LPSTR pszTmp = CmStrCpyAllocA(pszFullNameAndPath);
    
    if (NULL == pszTmp)
    {
        CMASSERTMSG(NULL, "CmStripFileNameA -- CmStrCpyAllocA returned a NULL pointer for pszTmp");
        return NULL;
    }

    LPSTR pszSlash = CmStrrchrA(pszTmp, '\\');

    if (NULL == pszSlash)
    {
        MYDBGASSERT(FALSE);
        CmFree(pszTmp);
        return NULL;
    }

    //
    // If slash is desired, move to next char before truncating
    //

    if (fKeepSlash)
    {
        pszSlash = CharNextA(pszSlash);
    }

    *pszSlash = '\0';

    return pszTmp;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStripFileNameW
//
// Synopsis:  Helper function to deal with the tedium of extracting the path 
//            part of a complete filename.
//
// Arguments: LPCWSTR pszFullNameAndPath - Ptr to the filename 
//            BOOL fKeepSlash - Flag indicating that trailing directory '\' should be retained.
//
// Returns:   LPWSTR - Ptr to an allocated buffer containing the dir, or NULL on failure.
//
// Note:      It is up to the caller to provide reasonable input, the only requirement
//            is that the input contain '\'. 
//
// History:   nickball    Created           3/10/98
//            nickball    Moved to cmutil   02/21/99
//            quintinb    Added W and A versions 03/09/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmStripFileNameW(LPCWSTR pszFullNameAndPath, BOOL fKeepSlash)
{
    MYDBGASSERT(pszFullNameAndPath);

    if (NULL == pszFullNameAndPath)
    {
        return NULL;
    }

    //
    // Make a copy of the filename and locate the last '\'
    //
    
    LPWSTR pszTmp = CmStrCpyAllocW(pszFullNameAndPath); 
    
    if (NULL == pszTmp)
    {
        CMASSERTMSG(NULL, "CmStripFileNameW -- CmStrCpyAllocW returned a NULL pointer for pszTmp");
        return NULL;
    }

    LPWSTR pszSlash = CmStrrchrW(pszTmp, L'\\');

    if (NULL == pszSlash)
    {
        MYDBGASSERT(FALSE);
        CmFree(pszTmp);
        return NULL;
    }

    //
    // If slash is desired, move to next char before truncating
    //

    if (fKeepSlash)
    {
        pszSlash = CharNextU(pszSlash);
    }

    *pszSlash = L'\0';

    return pszTmp;
}

//+----------------------------------------------------------------------------
//
// Function:  CmBuildFullPathFromRelativeA
//
// Synopsis:  Builds a full path by stripping the filename from pszFullFileName
//            and appending pszRelative.
//
// Arguments: LPCSTR pszFullFileName - A full path and filename
//            LPCSTR pszRelative - Relative path fragment. 
//
//            Typically used to construct a full path to a file in the profile directory
//            based upon the path to the .CMP file.
//
// Returns:   LPSTR - Ptr to the completed path which must be freed by the caller.
//
// Note:      pszRelative must NOT contain a leading "\"
//
// History:   nickball    Created           03/08/98
//            nickball    Moved to cmutil   02/21/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmBuildFullPathFromRelativeA(LPCSTR pszFullFileName,
    LPCSTR pszRelative)
{
    MYDBGASSERT(pszFullFileName);
    MYDBGASSERT(pszRelative);

    //
    // Check assumptions
    //

    if (NULL == pszFullFileName || NULL == pszRelative)
    {
        return NULL;
    }

    //
    // No empty strings please
    //

    MYDBGASSERT(*pszFullFileName);       
    MYDBGASSERT(*pszRelative);
    MYDBGASSERT(pszRelative[0] != '\\');

    //
    // Get the directory name including trailing '\'
    //
    
    LPSTR pszFull = NULL;
    LPSTR pszProfile = CmStripFileNameA(pszFullFileName, TRUE);

    if (pszProfile && *pszProfile)
    {
        pszFull = (LPSTR) CmMalloc(lstrlenA(pszProfile) + lstrlenA(pszRelative) + sizeof(CHAR));
    
        MYDBGASSERT(pszFull);

        if (pszFull)
        {           
            //
            // Build the complete path with new relative extension
            //

            lstrcpyA(pszFull, pszProfile);
            lstrcatA(pszFull, pszRelative);
        }   
    }
    
    CmFree(pszProfile);

    return pszFull;
}

//+----------------------------------------------------------------------------
//
// Function:  CmBuildFullPathFromRelativeW
//
// Synopsis:  Builds a full path by stripping the filename from pszFullFileName
//            and appending pszRelative.
//
// Arguments: LPWTSTR pszFullFileName - A full path and filename
//            LPWTSTR pszRelative - Relative path fragment. 
//
//            Typically used to construct a full path to a file in the profile directory
//            based upon the path to the .CMP file.
//
// Returns:   LPWSTR - Ptr to the completed path which must be freed by the caller.
//
// Note:      pszRelative must NOT contain a leading "\"
//
// History:   nickball    Created    3/8/98
//            nickball    Moved to cmutil   02/21/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmBuildFullPathFromRelativeW(LPCWSTR pszFullFileName,
    LPCWSTR pszRelative)
{
    MYDBGASSERT(pszFullFileName);
    MYDBGASSERT(pszRelative);

    //
    // Check assumptions
    //

    if (NULL == pszFullFileName || NULL == pszRelative)
    {
        return NULL;
    }

    //
    // No empty strings please
    //

    MYDBGASSERT(*pszFullFileName);       
    MYDBGASSERT(*pszRelative);
    MYDBGASSERT(pszRelative[0] != L'\\');

    //
    // Get the directory name including trailing '\'
    //
    
    LPWSTR pszFull = NULL;
    LPWSTR pszProfile = CmStripFileNameW(pszFullFileName, TRUE);

    if (pszProfile && *pszProfile)
    {
        pszFull = (LPWSTR) CmMalloc((lstrlenU(pszProfile) + lstrlenU(pszRelative) + 1)*sizeof(WCHAR));
    
        MYDBGASSERT(pszFull);

        if (pszFull)
        {           
            //
            // Build the complete path with new relative extension
            //

            lstrcpyU(pszFull, pszProfile);
            lstrcatU(pszFull, pszRelative);
        }   
    }
    
    CmFree(pszProfile);

    return pszFull;
}

//+-----------------------------------------------------------------------------------------
// Function: CmWinHelp
//
// Synopsis: Calls Winhelp using the command line parameters
//
// Arguments: See winhelp documentation
//              hWndItem - This is a additional parameter we use to designate the window/control for
//                          which help(context) is needed.
// Returns: TRUE if help was launched successfully otherwise FALSE
//
// Notes:
//
// History: v-vijayb 7/10/99
//
//+-----------------------------------------------------------------------------------------

CMUTILAPI BOOL CmWinHelp(HWND hWndMain, HWND hWndItem, CONST WCHAR *lpszHelp, UINT uCommand, ULONG_PTR dwData)
{
    DWORD   cb;
    TCHAR   szName[MAX_PATH];
    BOOL    fRun = FALSE;
    DWORD   *prgWinIdHelpId = (DWORD *) dwData;

    //
    // Get the name of the desktop. Normally returns default or Winlogon or system or WinNT
    // On Win95/98 GetUserObjectInformation is not supported and thus the desktop name
    // will be empty so we will use the good old help API
    //  
    szName[0] = 0;

    HDESK   hDesk = GetThreadDesktop(GetCurrentThreadId());
    
    if (hDesk)
    {
        GetUserObjectInformation(hDesk, UOI_NAME, szName, sizeof(szName), &cb);
    
        CMTRACE1(TEXT("Desktop = %s"), szName);
        
        if (CmCompareString(TEXT("Winlogon"), szName) == 0)
        {
            return FALSE;
        }
        else
        {
            fRun = WinHelpU(hWndMain, lpszHelp, uCommand, (ULONG_PTR) prgWinIdHelpId);               
        }
    }

    return (fRun);
}

//+----------------------------------------------------------------------------
//
// Function:  IsLogonAsSystem
//
// Synopsis:  Whether the current process is running in the system account
//
// Arguments: None
//
// Returns:   BOOL - TRUE if running in system account
//
// History:   fengsun Created Header    7/13/98
//            v-vijayb Modified to use SIDs instead of username 
//
//+----------------------------------------------------------------------------
CMUTILAPI BOOL IsLogonAsSystem()
{
    static BOOL fLogonAsSystem = -1;

    //
    // If this function has been called before, return the saved value.
    //

    if (fLogonAsSystem != -1)
    {
        return fLogonAsSystem;
    }

    //
    // Runs only under NT
    //

    if (OS_NT)
    {
        HANDLE          hProcess, hAccess;
        DWORD           cbTokenInfo, cbRetInfo;
        PTOKEN_USER     pTokenInfo;
        SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
        PSID            pSystemSID = NULL;

        //
        //  On NT, we pick the more stringent value for the default.
        //
        fLogonAsSystem = TRUE;
        
        if (AllocateAndInitializeSid(&SIDAuthNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pSystemSID))
        {
            hProcess = GetCurrentProcess();     // Pseudo handle, no need to close
            if (OpenProcessToken(hProcess, TOKEN_READ, &hAccess))
            {
                BOOL bRet = GetTokenInformation(hAccess, TokenUser, NULL, 0, &cbRetInfo);
                MYDBGASSERT((FALSE == bRet) && (0 != cbRetInfo));

                if (cbRetInfo)
                {
                    cbTokenInfo = cbRetInfo;
                    pTokenInfo = (PTOKEN_USER) CmMalloc( cbTokenInfo * sizeof(BYTE) );
                    if (pTokenInfo)
                    {
                        if (GetTokenInformation(hAccess, TokenUser, (PVOID) pTokenInfo, cbTokenInfo, &cbRetInfo))
                        {
                            if (EqualSid(pTokenInfo->User.Sid, pSystemSID))
                            {
                                CMTRACE(TEXT("Running under LOCALSYSTEM account"));
                                fLogonAsSystem = TRUE;
                            }
                            else
                            {
                                fLogonAsSystem = FALSE;
                            }
                        }
                        CmFree(pTokenInfo);
                    }
                }
                CloseHandle(hAccess);                   
            }
            
            FreeSid(pSystemSID);
        }
    }
    else
    {
        fLogonAsSystem = FALSE;
    }
    
    return fLogonAsSystem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmutil\mem.cpp ===
//+----------------------------------------------------------------------------
//
// File:     mem.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Basic memory manipulation routines
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:	 henryt     Created   03/01/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//+----------------------------------------------------------------------------
// definitions
//+----------------------------------------------------------------------------
HANDLE  g_hProcessHeap = NULL;

#ifdef DEBUG
LONG    g_lMallocCnt = 0;  // a counter to detect memory leak
#endif


#if defined(DEBUG) && defined(DEBUG_MEM)

//////////////////////////////////////////////////////////////////////////////////
//
// If DEBUG_MEM is defined, track all the memory alloction in debug version.
// Keep all the allocated memory blocks in the double link list.
// Record the file name and line #, where memory is allocated.
// Add extra tag at the beginning and end of the memory to watch for overwriten
// The whole list is checked against corruption for every alloc/free operation
//
// The folowing three function is exported:
// BOOL   CheckDebugMem(void); // return TRUE for succeed
// void* AllocDebugMem(long size,const char* lpFileName,int nLine);
// BOOL   FreeDebugMem(void* pMem); // return TRUE for succeed
//
///////////////////////////////////////////////////////////////////////////////////

//#undef new

#define MEMTAG 0xBEEDB77D     // the tag before/after the block to watch for overwriten
#define FREETAG 0xBD          // the flag to fill freed memory
#define TAGSIZE (sizeof(long))// Size of the tags appended to the end of the block


//
// memory block, a double link list
//
struct TMemoryBlock
{
     TMemoryBlock* pPrev;
     TMemoryBlock* pNext;
     long size;
     const char*   lpFileName;   // The filename
     int      nLine;             // The line number
     long     topTag;            // The watch tag at the beginning
     // followed by:
     //  BYTE            data[nDataSize];
     //  long     bottomTag;
     BYTE* pbData() const        // Return the pointer to the actual data
        { return (BYTE*) (this + 1); }
};

//
// The following internal function can be overwritten to change the behaivor
//
   
static void* MemAlloc(long size);    
static BOOL  MemFree(void* pMem);    
static void  LockDebugMem();   
static void  UnlockDebugMem();   
   
//
// Internal function
//
static BOOL RealCheckMemory();  // without call Enter/Leave critical Section
static BOOL CheckBlock(const TMemoryBlock* pBlock) ;

//
// Internal data, protected by the lock to be multi-thread safe
//
static long nTotalMem;    // Total bytes of memory allocated
static long nTotalBlock;  // Total # of blocks allocated
static TMemoryBlock head; // The head of the double link list


//
// critical section to lock \ unlock DebugMemory
// The constructor lock the memory, the destructor unlock the memory
//
class MemCriticalSection
{
public:
   MemCriticalSection()
   {
      LockDebugMem();
   }                                  
   
   ~MemCriticalSection()
   {
      UnlockDebugMem();
   }
};

static BOOL fDebugMemInited = FALSE; // whether the debug memory is initialized

//+----------------------------------------------------------------------------
//
// Function:  StartDebugMemory
//
// Synopsis:  Initialize the data for debug memory
//
// Arguments: None
//
// Returns:   
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
static void StartDebugMemory()
{
   fDebugMemInited = TRUE;

   head.pNext = head.pPrev = NULL;
   head.topTag = MEMTAG;
   head.size = 0;
   nTotalMem = 0;
   nTotalBlock = 0;
}                




//+----------------------------------------------------------------------------
//
// Function:  MemAlloc
//
// Synopsis:  Allocate a block of memory.  This function should be overwriten
//            if different allocation method is used
//
// Arguments: long size - size of the memory
//
// Returns:   void* - the memory allocated or NULL
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
static void* MemAlloc(long size) 
{ 
	return (HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size));
}



//+----------------------------------------------------------------------------
//
// Function:    MemFree
//
// Synopsis:  Free a block of memory.  This function should be overwriten
//            if different allocation method is used
//
// Arguments: void* pMem - The memory to be freed
//
// Returns:   static BOOL - TRUE if succeeded
//
// History:   Created Header    4/2/98
//
//+----------------------------------------------------------------------------
static BOOL MemFree(void* pMem)
{ 
    return HeapFree(GetProcessHeap(), 0, pMem);
}

//
// Data / functions to provide mutual exclusion.
// Can be overwritten, if other methed is to be used.
//
static BOOL fLockInited = FALSE;   // whether the critical section is inialized
static CRITICAL_SECTION cSection;  // The critical section to protect the link list

//+----------------------------------------------------------------------------
//
// Function:  InitLock
//
// Synopsis:  Initialize the memory lock which protects the doublely linked list
//            that contains all of the allocated memory blocks.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb      Created Header    01/14/2000
//
//+----------------------------------------------------------------------------
static void InitLock()
{
   fLockInited = TRUE;
   InitializeCriticalSection(&cSection);
}

//+----------------------------------------------------------------------------
//
// Function:  LockDebugMem
//
// Synopsis:  Locks the doublely linked list that contains all of the 
//            allocated memory blocks so that it can only be accessed by the
//            locking thread.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb      Created Header    01/14/2000
//
//+----------------------------------------------------------------------------
static void LockDebugMem()
{
   static int i = 0;
   if(!fLockInited)
   {
      InitLock();
   }
   
   EnterCriticalSection(&cSection);
}

//+----------------------------------------------------------------------------
//
// Function:  UnlockDebugMem
//
// Synopsis:  Unlocks the doublely linked list that contains all of the 
//            allocated memory blocks.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb      Created Header    01/14/2000
//
//+----------------------------------------------------------------------------
static void UnlockDebugMem()
{
   LeaveCriticalSection(&cSection);
}

//+----------------------------------------------------------------------------
//
// Function:  AllocDebugMem
//
// Synopsis:  Process memory allocation request.
//            Check the link list.  Allocate a larger block.  
//            Record filename/linenumber, add tags and insert to the list
//
// Arguments: long size - Size of the memory to be allocated
//            const char* lpFileName - File name to be recorded
//            int nLine - Line number to be recorted
//
// Returns:   CMUTILAPI void* - The memory allocated. Ready to use by the caller
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
CMUTILAPI void* AllocDebugMem(long size,const char* lpFileName,int nLine)
{
    if (!fDebugMemInited)
    {
        StartDebugMemory();
    }

    if (size<0)
    {
        CMASSERTMSG(FALSE,"Negtive size for alloc");
        return NULL;
    }

    if (size>1024*1024)
    {
        CMASSERTMSG(FALSE," size for alloc is great than 1Mb");
        return NULL;
    }

    if (size == 0)
    {
        CMTRACE("Allocate memory of size 0");
        return NULL;
    }


    //
    // Protect the access to the list
    //
    MemCriticalSection criticalSection;

    //
    // Check the link list first
    //
    if (!RealCheckMemory())
    {
        return NULL;
    }
              
    //
    // Allocate a large block to hold additional information
    //
    TMemoryBlock* pBlock = (TMemoryBlock*)MemAlloc(sizeof(TMemoryBlock)+size + TAGSIZE);
    if (!pBlock)                  
    {
        CMTRACE("Outof Memory");
        return NULL;
    }               

    //
    // record filename/line/size, add tag to the beginning and end
    //
    pBlock->size = size;
    pBlock->topTag = MEMTAG;   
    pBlock->lpFileName = lpFileName;
    pBlock->nLine = nLine;
    *(long*)(pBlock->pbData() + size) = MEMTAG;

    //
    // insert at head
    //
    pBlock->pNext = head.pNext;
    pBlock->pPrev = &head;  
    if(head.pNext)
      head.pNext->pPrev = pBlock; 
    head.pNext = pBlock;

    nTotalMem += size;
    nTotalBlock ++;

    return  pBlock->pbData();
}



//+----------------------------------------------------------------------------
//
// Function:  FreeDebugMem
//
// Synopsis: Free the memory allocated by AllocDebugMem
//           Check the link list, and the block to be freed.
//           Fill the block data with FREETAG before freed 
//
// Arguments: void* pMem - Memory to be freed
//
// Returns:   BOOL - TRUE for succeeded
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
CMUTILAPI BOOL FreeDebugMem(void* pMem)
{
    if (!fDebugMemInited)
    {
        StartDebugMemory();
    }

    if (!pMem)
    {
        return FALSE;
    }            
  
    //
    // Get the lock
    //
    MemCriticalSection criticalSection;

    //
    // Get pointer to our structure
    //
    TMemoryBlock* pBlock =(TMemoryBlock*)( (char*)pMem - sizeof(TMemoryBlock));

    //
    // Check the block to be freed
    //
    if (!CheckBlock(pBlock))
    {
        return FALSE;
    }

    //
    // Check the link list
    //
    if (!RealCheckMemory())
    {
        return FALSE;
    }

    //
    // remove the block from the list
    //
    pBlock->pPrev->pNext = pBlock->pNext;
    if (pBlock->pNext)
    {
      pBlock->pNext->pPrev = pBlock->pPrev;
    }
                 
    nTotalMem -= pBlock->size;
    nTotalBlock --;

    //
    // Fill the freed memory with 0xBD, leave the size/filename/lineNumber unchanged
    //
    memset(&pBlock->topTag, FREETAG, (size_t)pBlock->size + sizeof(pBlock->topTag) + TAGSIZE);
    return MemFree(pBlock);
}


//+----------------------------------------------------------------------------
//
// Function:  void* ReAllocDebugMem
//
// Synopsis:  Reallocate a memory with a diffirent size
//
// Arguments: void* pMem - memory to be reallocated
//            long nSize - size of the request
//            const char* lpFileName - FileName to be recorded
//            int nLine - Line umber to be recorded
//
// Returns:   void* - new memory returned
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
CMUTILAPI void* ReAllocDebugMem(void* pMem, long nSize, const char* lpFileName,int nLine)
{
   if (!fDebugMemInited)
   {
       StartDebugMemory();
   }

   if (!pMem)
   {
      CMTRACE("Free a NULL pointer");
      return NULL;
   }            
      
   //
   // Allocate a new block, copy the information over and free the old block.
   //
   TMemoryBlock* pBlock =(TMemoryBlock*)( (char*)pMem - sizeof(TMemoryBlock));

   long lOrginalSize = pBlock->size;

   void* pNew = AllocDebugMem(nSize, lpFileName, nLine);
   if(pNew)
   {
       CopyMemory(pNew, pMem, (nSize < lOrginalSize ? nSize : lOrginalSize));
       FreeDebugMem(pMem);
   }
    
   return pNew;
}

//+----------------------------------------------------------------------------
//
// Function:  CheckDebugMem
//
// Synopsis:  Exported to external module.
//            Call this function, whenever, you want to check against 
//            memory curruption
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the memory is fine.
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
CMUTILAPI BOOL CheckDebugMem()
{
   if (!fDebugMemInited)
   {
      StartDebugMemory();
   }

   MemCriticalSection criticalSection;

   return RealCheckMemory();                           
}

//+----------------------------------------------------------------------------
//
// Function:  RealCheckMemory
//
// Synopsis:  Go through the link list to check for memory corruption
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the memory is fine.
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
static BOOL RealCheckMemory() 
{
    TMemoryBlock* pBlock = head.pNext;
   
    int nBlock =0;
    while(pBlock!=NULL)
    {
        if(!CheckBlock(pBlock))
        {
            return FALSE;
        }            

        pBlock = pBlock->pNext;
        nBlock++;
    }
                              
    if(nBlock != nTotalBlock)
    {
        CMASSERTMSG(FALSE,"Memery corrupted");
        return FALSE;
    }            

    return TRUE;                           
}
   
//+----------------------------------------------------------------------------
//
// Function:  CheckBlock
//
// Synopsis:  Check a block for memory corruption
//
// Arguments: const TMemoryBlock* pBlock - 
//
// Returns:   BOOL - TRUE, if the block is fine
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
static BOOL CheckBlock(const TMemoryBlock* pBlock) 
{
   if (pBlock->topTag != MEMTAG)     // overwriten at top
   {
         CMASSERTMSG(FALSE, "Memery corrupted");
         return FALSE;
   }            

   if (pBlock->size<0)
   {
         CMASSERTMSG(FALSE, "Memery corrupted");
         return FALSE;
   }            

   if (*(long*)(pBlock->pbData() +pBlock->size) != MEMTAG) // overwriten at bottom
   {
         CMASSERTMSG(FALSE, "Memery corrupted");
         return FALSE;
   }            

   if (pBlock->pPrev && pBlock->pPrev->pNext != pBlock)
   {
         CMASSERTMSG(FALSE, "Memery corrupted");
         return FALSE;
   }            

   if (pBlock->pNext && pBlock->pNext->pPrev != pBlock)
   {
         CMASSERTMSG(FALSE, "Memery corrupted");
         return FALSE;
   }            
      
   return TRUE;
}  

/////////////////////////////////////////////////////////////////////////////
// operator new, delete
/*  We did not redefine new and delete

void*   __cdecl operator new(size_t nSize)
{
   void* p = AllocDebugMem(nSize,NULL,0);

   if (p == NULL)
   {
      CMTRACE("New failed");
   }

   return p;
}

void*   __cdecl operator new(size_t nSize, const char* lpszFileName, int nLine)
{
   void* p = AllocDebugMem(nSize, lpszFileName,nLine);

   if (p == NULL)
   {
      CMTRACE("New failed");
   }

   return p;
}

void  __cdecl operator delete(void* p)
{
   if(p)
      FreeDebugMem(p);
}
*/


//+----------------------------------------------------------------------------
//
// Function:  EndDebugMemory
//
// Synopsis:  Called before the program exits.  Report any unreleased memory leak
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
void EndDebugMemory()
{
   if(head.pNext != NULL || nTotalMem!=0 || nTotalBlock !=0)
   {
      CMTRACE("Detected memory leaks");
      TMemoryBlock * pBlock;

      for(pBlock = head.pNext; pBlock != NULL; pBlock = pBlock->pNext)
      {
         TCHAR buf[1024];
         wsprintf(buf, TEXT("Memory Leak of %d bytes:\n%S"), pBlock->size, pBlock->pbData());
         MyDbgAssertA(pBlock->lpFileName, pBlock->nLine, buf);    // do not print the file name
      }
      DeleteCriticalSection(&cSection);
   }
}                

#else // defined(DEBUG) && defined(DEBUG_MEM)

//////////////////////////////////////////////////////////////////////////////////
//
// If DEBUG_MEM if NOT defined, only track a count of memory for debug version
//
///////////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG

void TraceHeapBlock(PROCESS_HEAP_ENTRY* pheEntry)
{
    CMTRACE(TEXT("TraceHeapBlock -- Begin Entry Trace"));

    CMTRACE1(TEXT("\tEntry->lpData = 0x%x"), pheEntry->lpData);
    CMTRACE1(TEXT("\tEntry->cbData = %u"), pheEntry->cbData);
    CMTRACE1(TEXT("\tEntry->cbOverhead = %u"), pheEntry->cbOverhead);
    CMTRACE1(TEXT("\tEntry->iRegionIndex = %u"), pheEntry->iRegionIndex);

    if (pheEntry->wFlags & PROCESS_HEAP_REGION)
    {
        CMTRACE1(TEXT("\tEntry->dwCommittedSize = %u"), pheEntry->Region.dwCommittedSize);
        CMTRACE1(TEXT("\tEntry->dwUnCommittedSize = %u"), pheEntry->Region.dwUnCommittedSize);
        CMTRACE1(TEXT("\tEntry->lpFirstBlock = 0x%x"), pheEntry->Region.lpFirstBlock);
        CMTRACE1(TEXT("\tEntry->lpLastBlock = 0x%x"), pheEntry->Region.lpLastBlock);
        CMTRACE(TEXT("\tPROCESS_HEAP_REGION flag set."));
    }

    if (pheEntry->wFlags & PROCESS_HEAP_UNCOMMITTED_RANGE)
    {        
        CMTRACE(TEXT("\tPROCESS_HEAP_UNCOMMITTED_RANGE flag set."));
    }

    if ((pheEntry->wFlags & PROCESS_HEAP_ENTRY_BUSY) && (pheEntry->wFlags & PROCESS_HEAP_ENTRY_MOVEABLE))
    {
        CMTRACE1(TEXT("\tEntry->hMem = 0x%x"), pheEntry->Block.hMem);
        CMTRACE1(TEXT("\tEntry->dwReserved = %u"), pheEntry->Block.dwReserved);
        
        CMTRACE(TEXT("\tPROCESS_HEAP_ENTRY_BUSY and PROCESS_HEAP_ENTRY_MOVEABLE flags are set."));
    }

    if ((pheEntry->wFlags & PROCESS_HEAP_ENTRY_BUSY) && (pheEntry->wFlags & PROCESS_HEAP_ENTRY_DDESHARE))
    {
        CMTRACE(TEXT("\tPROCESS_HEAP_ENTRY_BUSY and PROCESS_HEAP_ENTRY_DDESHARE flags are set."));
    }

    CMTRACE(TEXT("TraceHeapBlock -- End Entry Trace"));
    CMTRACE(TEXT(""));
}

BOOL CheckProcessHeap()
{
    BOOL bRet;
    DWORD dwError;
    PROCESS_HEAP_ENTRY pheEntry;

    ZeroMemory(&pheEntry, sizeof(pheEntry));

    do
    {
        bRet = HeapWalk(g_hProcessHeap, &pheEntry);
        if (!bRet)
        {               
            dwError = GetLastError();
            if (ERROR_NO_MORE_ITEMS != dwError)
            {
                CMTRACE1(TEXT("HeapWalk returned FALSE, GLE returns %u"), dwError);
            }
            else
            {
                TraceHeapBlock(&pheEntry);
            }
        }
        else
        {
            TraceHeapBlock(&pheEntry);
        }
    
    } while(!bRet);

    return TRUE;
}
#endif // DEBUG

CMUTILAPI void *CmRealloc(void *pvPtr, size_t nBytes) 
{

#ifdef DEBUG
    if (OS_NT && !HeapValidate(g_hProcessHeap, 0, NULL))
    {
        CMTRACE(TEXT("CmRealloc -- HeapValidate Returns FALSE.  Checking Process Heap."));

        CheckProcessHeap();
    }
#endif

    void* p = HeapReAlloc(g_hProcessHeap, HEAP_ZERO_MEMORY, pvPtr, nBytes);

#ifdef DEBUG
    if (OS_NT && !HeapValidate(g_hProcessHeap, 0, NULL))
    {
        CMTRACE(TEXT("CmRealloc -- HeapValidate Returns FALSE.  Checking Process Heap."));

        CheckProcessHeap();
    }

    CMASSERTMSG(p, TEXT("CmRealloc failed"));
#endif

    return p;
}


CMUTILAPI void *CmMalloc(size_t nBytes) 
{

#ifdef DEBUG

    InterlockedIncrement(&g_lMallocCnt);

    MYDBGASSERT(nBytes < 1024*1024); // It should be less than 1 MB
    MYDBGASSERT(nBytes > 0);         // It should be *something*

    if (OS_NT && !HeapValidate(g_hProcessHeap, 0, NULL))
    {
        CMTRACE(TEXT("CmMalloc -- HeapValidate Returns FALSE.  Checking Process Heap."));

        CheckProcessHeap();
    }

#endif
    
    void* p = HeapAlloc(g_hProcessHeap, HEAP_ZERO_MEMORY, nBytes);
    
#ifdef DEBUG
    
    if (OS_NT && !HeapValidate(g_hProcessHeap, 0, NULL))
    {
        CMTRACE(TEXT("CmMalloc -- HeapValidate Returns FALSE.  Checking Process Heap."));

        CheckProcessHeap();
    }

    CMASSERTMSG(p, TEXT("CmMalloc failed"));

#endif

    return p;
}


CMUTILAPI void CmFree(void *pvPtr) 
{

#ifdef DEBUG
    if (OS_NT && !HeapValidate(g_hProcessHeap, 0, NULL))
    {
        CMTRACE(TEXT("CmMalloc -- HeapValidate Returns FALSE.  Checking Process Heap."));

        CheckProcessHeap();
    }
#endif

	if (pvPtr) 
    {	
	    MYVERIFY(HeapFree(g_hProcessHeap, 0, pvPtr));

#ifdef DEBUG

        if (OS_NT && !HeapValidate(g_hProcessHeap, 0, NULL))
        {
            CMTRACE(TEXT("CmMalloc -- HeapValidate Returns FALSE.  Checking Process Heap."));

            CheckProcessHeap();
        }

	    InterlockedDecrement(&g_lMallocCnt);
#endif
    
    }
}

#ifdef DEBUG
void EndDebugMemory()
{
    if (g_lMallocCnt)
    {
        char buf[256];
        wsprintfA(buf, TEXT("Detect Memory Leak of %d blocks"), g_lMallocCnt);
        CMASSERTMSGA(FALSE, buf);
    }
}
#endif

#endif

//
// the memory functions are for i386 only.
//
#ifdef _M_IX86
//+----------------------------------------------------------------------------
//
// memmove - Copy source buffer to destination buffer.  The code is copied from
//           libc.
//                                                                                
// Purpose:                                                                       
//        memmove() copies a source memory buffer to a destination memory buffer. 
//        This routine recognize overlapping buffers to avoid propogation.        
//        For cases where propogation is not a problem, memcpy() can be used.     
//                                                                                
// Entry:                                                                         
//        void *dst = pointer to destination buffer                               
//        const void *src = pointer to source buffer                              
//        size_t count = number of bytes to copy                                  
//                                                                                
// Exit:                                                                          
//        Returns a pointer to the destination buffer                             
//
//+----------------------------------------------------------------------------
CMUTILAPI PVOID WINAPI CmMoveMemory(
    PVOID       dst,
    CONST PVOID src,
    size_t      count
) 
{
    void * ret = dst;
    PVOID src1 = src;

    if (dst <= src1 || (char *)dst >= ((char *)src1 + count)) {
            /*
             * Non-Overlapping Buffers
             * copy from lower addresses to higher addresses
             */
            while (count--) {
                    *(char *)dst = *(char *)src1;
                    dst = (char *)dst + 1;
                    src1 = (char *)src1 + 1;
            }
    }
    else {
            /*
             * Overlapping Buffers
             * copy from higher addresses to lower addresses
             */
            dst = (char *)dst + count - 1;
            src1 = (char *)src1 + count - 1;

            while (count--) {
                    *(char *)dst = *(char *)src1;
                    dst = (char *)dst - 1;
                    src1 = (char *)src1 - 1;
            }
    }

    return(ret);
}

#endif //_M_IX86
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cnetcfg\callout.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  CALLOUT.C - Functions to call out to external components to install
//        devices
//

//  HISTORY:
//  
//  11/27/94  jeremys  Created.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//

#include "wizard.h"

// global variables 
static const char c_szModemCPL[] = "rundll32.exe Shell32.dll,Control_RunDLL modem.cpl,,add";


/*******************************************************************

  NAME:    InvokeModemWizard

  SYNOPSIS:  Starts the modem install wizard

  ENTRY:    hwndToHide - this window, if non-NULL, will be hidden while
        the modem CPL runs

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    launches RUNDLL32 as a process to run the modem wizard.
        Blocks on the completion of that process before returning.

        hwndToHide is not necessarily the calling window!
        For instance, in a property sheet hwndToHide should not be the
        dialog (hDlg), but GetParent(hDlg) so that we hide the property
        sheet itself instead of just the current page.

********************************************************************/
UINT InvokeModemWizard(HWND hwndToHide)
{
	BOOL bSleepNeeded = FALSE;

	if (TRUE == IsNT())
	{
		BOOL bNeedsStart;
		
		//
		// Call into icfg32 dll
		//
		if (NULL != lpIcfgInstallModem)
		{
			lpIcfgInstallModem(hwndToHide, 0L, &bNeedsStart);
			return ERROR_SUCCESS;
		}
		else
			return ERROR_GEN_FAILURE;

	}
	else
	{
		PROCESS_INFORMATION pi;
		BOOL fRet;
		STARTUPINFO sti;
		UINT err = ERROR_SUCCESS;
		CHAR szWindowTitle[255];

		ZeroMemory(&sti,sizeof(STARTUPINFO));
		sti.cb = sizeof(STARTUPINFO);

		// run the modem wizard
		fRet = CreateProcess(NULL, (LPSTR)c_szModemCPL,
							   NULL, NULL, FALSE, 0, NULL, NULL,
							   &sti, &pi);
		if (fRet) 
		{
			CloseHandle(pi.hThread);

			// wait for the modem wizard process to complete
			MsgWaitForMultipleObjectsLoop(pi.hProcess);
			CloseHandle(pi.hProcess);
		} 
		else
			err = GetLastError();

		// show the parent window again
		if (hwndToHide) 
		{
			ShowWindow(hwndToHide,SW_SHOW);
		}

		return err;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cnetcfg\clsutil.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1999 Microsoft Corporation
//*********************************************************************

//
//  CLSUTIL.C - some small, useful C++ classes to wrap memory allocation,
//        registry access, etc.
//

//  HISTORY:
//
//  12/07/94  jeremys    Borrowed from WNET common library
//

#include "wizard.h"

BOOL BUFFER::Alloc( UINT cbBuffer )
{
  _lpBuffer = (LPSTR)::GlobalAlloc(GPTR,cbBuffer);
  if (_lpBuffer != NULL) {
    _cb = cbBuffer;
    return TRUE;
  }
  return FALSE;
}

BOOL BUFFER::Realloc( UINT cbNew )
{
  LPVOID lpNew = ::GlobalReAlloc((HGLOBAL)_lpBuffer, cbNew,
    GMEM_MOVEABLE | GMEM_ZEROINIT);
  if (lpNew == NULL)
    return FALSE;

  _lpBuffer = (LPSTR)lpNew;
  _cb = cbNew;
  return TRUE;
}

BUFFER::BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
  _lpBuffer( NULL )
{
  if (cbInitial)
    Alloc( cbInitial );
}

BUFFER::~BUFFER()
{
  if (_lpBuffer != NULL) {
    GlobalFree((HGLOBAL) _lpBuffer);
    _lpBuffer = NULL;
  }
}

BOOL BUFFER::Resize( UINT cbNew )
{
  BOOL fSuccess;

  if (QuerySize() == 0)
    fSuccess = Alloc( cbNew );
  else {
    fSuccess = Realloc( cbNew );
  }
  if (fSuccess)
    _cb = cbNew;
  return fSuccess;
}

RegEntry::RegEntry(const char *pszSubKey, HKEY hkey)
{
  _error = RegCreateKey(hkey, pszSubKey, &_hkey);
  if (_error) {
    bhkeyValid = FALSE;
  }
  else {
    bhkeyValid = TRUE;
  }
}

RegEntry::~RegEntry()
{
    if (bhkeyValid) {
        RegCloseKey(_hkey);
    }
}

long RegEntry::SetValue(const char *pszValue, const char *string)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ,
            (unsigned char *)string, lstrlen(string)+1);
    }
  return _error;
}

long RegEntry::SetValue(const char *pszValue, unsigned long dwNumber)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_BINARY,
            (unsigned char *)&dwNumber, sizeof(dwNumber));
    }
  return _error;
}

long RegEntry::DeleteValue(const char *pszValue)
{
    if (bhkeyValid) {
      _error = RegDeleteValue(_hkey, (LPTSTR) pszValue);
  }
  return _error;
}


char *RegEntry::GetString(const char *pszValue, char *string, unsigned long length)
{
  DWORD   dwType = REG_SZ;

    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)string,
            &length);
    }
  if (_error) {
    *string = '\0';
     return NULL;
  }

  return string;
}

long RegEntry::GetNumber(const char *pszValue, long dwDefault)
{
   DWORD   dwType = REG_BINARY;
   long  dwNumber = 0L;
   DWORD  dwSize = sizeof(dwNumber);

    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)&dwNumber,
            &dwSize);
  }
  if (_error)
    dwNumber = dwDefault;

  return dwNumber;
}

long RegEntry::MoveToSubKey(const char *pszSubKeyName)
{
    HKEY  _hNewKey;

    if (bhkeyValid) {
        _error = RegOpenKey ( _hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (_error == ERROR_SUCCESS) {
            RegCloseKey(_hkey);
            _hkey = _hNewKey;
        }
    }

  return _error;
}

long RegEntry::FlushKey()
{
    if (bhkeyValid) {
      _error = RegFlushKey(_hkey);
    }
  return _error;
}

RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : pRegEntry(pReqRegEntry),
   iEnum(0),
   pchName(NULL),
   pbValue(NULL)
{
    _error = pRegEntry->GetError();
    if (_error == ERROR_SUCCESS) {
        _error = RegQueryInfoKey ( pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &cEntries,           // Number of value entries
                                   &cMaxValueName,      // Longest value name
                                   &cMaxData,           // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (_error == ERROR_SUCCESS) {
        if (cEntries != 0) {
            cMaxValueName = cMaxValueName + 1; // REG_SZ needs one more for null
            cMaxData = cMaxData + 1;           // REG_SZ needs one more for null
            pchName = new CHAR[cMaxValueName];
            if (!pchName) {
                _error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (cMaxData) {
                    pbValue = new BYTE[cMaxData];
                    if (!pbValue) {
                        _error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete pchName;
    delete pbValue;
}

long RegEnumValues::Next()
{
    if (_error != ERROR_SUCCESS) {
        return _error;
    }
    if (cEntries == iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = cMaxValueName;

    dwDataLength = cMaxData;
    _error = RegEnumValue ( pRegEntry->GetKey(), // Key
                            iEnum,               // Index of value
                            pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &dwType,             // Data type
                            pbValue,             // Address of buffer for value data
                            &dwDataLength );     // Address for size of data
    iEnum++;
    return _error;
}

int __cdecl _purecall(void)
{
   return(0);
}

void * _cdecl operator new(size_t size)
{
  return (void *)::GlobalAlloc(GPTR,size);
}

void _cdecl operator delete(void *ptr)
{
  GlobalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cnetcfg\export.cpp ===
//*******************************************************************
//
//  Copyright (c) 1996-1998 Microsoft Corporation
//
//  FILE: EXPORT.C
//
//  PURPOSE:  Contains external API's for use by signup wizard.
//
//  HISTORY:
//  96/03/05  markdu  Created.
//  96/03/11  markdu  Added InetConfigClient()
//  96/03/11  markdu  Added InetGetAutodial() and InetSetAutodial().
//  96/03/12  markdu  Added UI during file install.
//  96/03/12  markdu  Added ValidateConnectoidData().
//  96/03/12  markdu  Set connectoid for autodial if INETCFG_SETASAUTODIAL
//            is set.  Renamed ValidateConnectoidData to MakeConnectoid.
//  96/03/12  markdu  Added hwnd param to InetConfigClient() and
//            InetConfigSystem().
//  96/03/13  markdu  Added INETCFG_OVERWRITEENTRY.  Create unique neame
//            for connectoid if it already exists and we can't overwrite.
//  96/03/13  markdu  Added InstallTCPAndRNA().
//  96/03/13  markdu  Added LPINETCLIENTINFO param to InetConfigClient()
//  96/03/16  markdu  Added INETCFG_INSTALLMODEM flag.
//  96/03/16  markdu  Use ReInit member function to re-enumerate modems.
//  96/03/19  markdu  Split export.h into export.h and csexport.h
//  96/03/20  markdu  Combined export.h and iclient.h into inetcfg.h
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/24  markdu  Replaced lstrcpy with lstrcpyn where appropriate.
//  96/03/25  markdu  Validate lpfNeedsRestart before using.
//  96/03/25  markdu  Clean up some error handling.
//  96/03/26  markdu  Use MAX_ISP_NAME instead of RAS_MaxEntryName 
//            because of bug in RNA.
//  96/03/26  markdu  Implemented UpdateMailSettings().
//  96/03/27  mmaclin InetGetProxy()and InetSetProxy().
//  96/04/04  markdu  NASH BUG 15610  Check for file and printer sharing
//            bound to TCP/IP .
//  96/04/04  markdu  Added phonebook name param to InetConfigClient,
//            MakeConnectoid, SetConnectoidUsername, CreateConnectoid,
//            and ValidateConnectoidName.
//  96/04/05  markdu  Set internet icon on desktop to point to browser.
//  96/04/06  mmaclin Changed InetSetProxy to check for NULL.
//  96/04/06  markdu  NASH BUG 16404 Initialize gpWizardState in
//            UpdateMailSettings.
//  96/04/06  markdu  NASH BUG 16441 If InetSetAutodial is called with NULL
//            as the connection name, the entry is not changed.
//  96/04/18  markdu  NASH BUG 18443 Make exports WINAPI.
//  96/04/19  markdu  NASH BUG 18605 Handle ERROR_FILE_NOT_FOUND return
//            from ValidateConnectoidName.
//  96/04/19  markdu  NASH BUG 17760 Do not show choose profile UI.
//  96/04/22  markdu  NASH BUG 18901 Do not set desktop internet icon to 
//            browser if we are just creating a temp connectoid.
//  96/04/23  markdu  NASH BUG 18719 Make the choose profile dialog TOPMOST.
//  96/04/25  markdu  NASH BUG 19572 Only show choose profile dialog if
//            there is an existing profile.
//  96/04/29  markdu  NASH BUG 20003 Added InetConfigSystemFromPath
//            and removed InstallTCPAndRNA.
//  96/05/01  markdu  NASH BUG 20483 Do not display "installing files" dialog
//            if INETCFG_SUPPRESSINSTALLUI is set.
//  96/05/01  markdu  ICW BUG 8049 Reboot if modem is installed.  This is 
//            required because sometimes the configuration manager does not 
//            set up the modem correctly, and the user will not be able to
//            dial (will get cryptic error message) until reboot.
//  96/05/06  markdu  NASH BUG 21027  If DNS is set globally, clear it out so
//            the per-connectoid settings will be saved.
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//  96/05/25  markdu  Use ICFG_ flags for lpNeedDrivers and lpInstallDrivers.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.
//  96/05/28  markdu  Moved InitConfig and DeInitConfig to DllEntryPoint.
//	96/10/21  valdonb Added CheckConnectionWizard and InetCreateMailNewsAccount
//  99/11/10  nickball Reduced to CM essentials
//
//*******************************************************************

#include "wizard.h"
#include "inetcfg.h"

// structure to pass data back from IDD_NEEDDRIVERS handler
typedef struct tagNEEDDRIVERSDLGINFO
{
  DWORD       dwfOptions;
  LPBOOL      lpfNeedsRestart;
} NEEDDRIVERSDLGINFO, * PNEEDDRIVERSDLGINFO;

// Function prototypes internal to this file
INT_PTR CALLBACK NeedDriversDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
BOOL NeedDriversDlgInit(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo);
BOOL NeedDriversDlgOK(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo);
VOID EnableDlg(HWND hDlg,BOOL fEnable);

static DWORD GetOSMajorVersion(void);

// from rnacall.cpp
//
extern void InitTAPILocation(HWND hwndParent);

// Function prototypes external to this file

extern ICFGINSTALLSYSCOMPONENTS     lpIcfgInstallInetComponents;
extern ICFGNEEDSYSCOMPONENTS        lpIcfgNeedInetComponents;
extern ICFGGETLASTINSTALLERRORTEXT  lpIcfgGetLastInstallErrorText;

//*******************************************************************
//
//  FUNCTION:   InetConfigSystem
//
//  PURPOSE:    This function will install files that are needed
//              for internet access (such as TCP/IP and RNA) based
//              the state of the options flags.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install exchange and internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/05  markdu  Created.
//
//*******************************************************************

extern "C" HRESULT WINAPI InetConfigSystem(
										   HWND hwndParent,
										   DWORD dwfOptions,
										   LPBOOL lpfNeedsRestart)
{
	DWORD         dwRet = ERROR_SUCCESS;
	BOOL          fNeedsRestart = FALSE;  // Default to no reboot needed
	// 4/2/97 ChrisK	Olympus 209
	HWND          hwndWaitDlg = NULL;
	CHAR szWindowTitle[255];
	BOOL bSleepNeeded = FALSE;
	
	
	DEBUGMSG("export.c::InetConfigSystem()");
	
	// Validate the parent hwnd
	if (hwndParent && !IsWindow(hwndParent))
	{
		return ERROR_INVALID_PARAMETER;
	}
	
	// Set up the install options
	DWORD dwfInstallOptions = 0;
	if (dwfOptions & INETCFG_INSTALLTCP)
	{
		dwfInstallOptions |= ICFG_INSTALLTCP;
	}
	if (dwfOptions & INETCFG_INSTALLRNA)
	{
		dwfInstallOptions |= ICFG_INSTALLRAS;
	}
	if (dwfOptions & INETCFG_INSTALLMAIL)
	{
		dwfInstallOptions |= ICFG_INSTALLMAIL;
	}
	
	// see if we need to install drivers
	BOOL  fNeedSysComponents = FALSE;
    
	// 
	// Kill Modem control panel if it's already running
	// 4/16/97 ChrisK Olympus 239
	// 6/9/97 jmazner moved this functionality from InvokeModemWizard
	szWindowTitle[0] = '\0';
	LoadSz(IDS_MODEM_WIZ_TITLE,szWindowTitle,255);
	HWND hwndModem = FindWindow("#32770",szWindowTitle);
	if (NULL != hwndModem)
	{
		// Close modem installation wizard
		PostMessage(hwndModem, WM_CLOSE, 0, 0);
		bSleepNeeded = TRUE;
	}
	
	// close modem control panel applet
	LoadSz(IDS_MODEM_CPL_TITLE,szWindowTitle,255);
	hwndModem = FindWindow("#32770",szWindowTitle);
	if (NULL != hwndModem)
	{
		PostMessage(hwndModem, WM_SYSCOMMAND,SC_CLOSE, 0);
		bSleepNeeded = TRUE;
	}
	
	if (bSleepNeeded)
	{
		Sleep(1000);
	}
	
	dwRet = lpIcfgNeedInetComponents(dwfInstallOptions, &fNeedSysComponents);
	
	if (ERROR_SUCCESS != dwRet)
	{
		CHAR   szErrorText[MAX_ERROR_TEXT+1]="";
		
		
		// 4/2/97 ChrisK Olympus 209
		// Dismiss busy dialog
		if (NULL != hwndWaitDlg)
		{
			DestroyWindow(hwndWaitDlg);
			hwndWaitDlg = NULL;
		}
		
		//
		// Get the text of the error message and display it.
		//
		if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
		{
			MsgBoxSz(NULL,szErrorText,MB_ICONEXCLAMATION,MB_OK);
		}
		
		return dwRet;
	}
	
	if (fNeedSysComponents) 
	{
		// 4/2/97 ChrisK Olympus 209
		// if we are going to install something the busy dialog isn't needed
		if (NULL != hwndWaitDlg)
			ShowWindow(hwndWaitDlg,SW_HIDE);
		
		if (dwfOptions & INETCFG_SUPPRESSINSTALLUI)
		{
			dwRet = lpIcfgInstallInetComponents(hwndParent, dwfInstallOptions, &fNeedsRestart);
			//
			// Display error message only if it failed due to something 
			// other than user cancel
			//
			if ((ERROR_SUCCESS != dwRet) && (ERROR_CANCELLED != dwRet))
			{
				CHAR   szErrorText[MAX_ERROR_TEXT+1]="";
				
				// Get the text of the error message and display it.
				if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
				{
					MsgBoxSz(NULL,szErrorText,MB_ICONEXCLAMATION,MB_OK);
				}
			}
		}
		else
		{
			// structure to pass to dialog to fill out
			NEEDDRIVERSDLGINFO NeedDriversDlgInfo;
			NeedDriversDlgInfo.dwfOptions = dwfInstallOptions;
			NeedDriversDlgInfo.lpfNeedsRestart = &fNeedsRestart;
			
			// Clear out the last error code so we can safely use it.
			SetLastError(ERROR_SUCCESS);
			
			// Display a dialog and allow the user to cancel install
			BOOL fRet = (BOOL)DialogBoxParam(ghInstance,MAKEINTRESOURCE(IDD_NEEDDRIVERS),hwndParent,
				NeedDriversDlgProc,(LPARAM) &NeedDriversDlgInfo);
			if (FALSE == fRet)
			{
				// user cancelled or an error occurred.
				dwRet = GetLastError();
				if (ERROR_SUCCESS == dwRet)
				{
					// Error occurred, but the error code was not set.
					dwRet = ERROR_INETCFG_UNKNOWN;
				}
			}
		}
	}
	
	if ((ERROR_SUCCESS == dwRet) && 
		(TRUE == IsNT()) && 
		(dwfOptions & INETCFG_INSTALLMODEM))
	{
		BOOL bNeedModem = FALSE;
		
		if (NULL == lpIcfgNeedModem)
		{
			//
			// 4/2/97 ChrisK Olympus 209
			//
			if (NULL != hwndWaitDlg)
				DestroyWindow(hwndWaitDlg);
			hwndWaitDlg = NULL;
			
			return ERROR_GEN_FAILURE;
		}
		
		//
		// 4/2/97 ChrisK Olympus 209
		// Show busy dialog here, this can take a few seconds
		//
		if (NULL != hwndWaitDlg)
			ShowWindow(hwndWaitDlg,SW_SHOW);
		
		dwRet = (*lpIcfgNeedModem)(0, &bNeedModem);
		if (ERROR_SUCCESS != dwRet)
		{
			//
			// 4/2/97 ChrisK Olympus 209
			//
			if (NULL != hwndWaitDlg)
				DestroyWindow(hwndWaitDlg);
			hwndWaitDlg = NULL;
			
			return dwRet;
		}
		
		
		if (TRUE == bNeedModem) 
		{
			if (GetOSMajorVersion() != 5)
			{
				//
				// Not NT4 we cannot programmitcally install/configure modem 
				// separately. It has to be done when RAS in installed
				//
				if (NULL != hwndWaitDlg)
					DestroyWindow(hwndWaitDlg);
				hwndWaitDlg = NULL;
				
				MsgBoxParam(hwndParent,IDS_ERRNoDialOutModem,MB_ICONERROR,MB_OK);
				return ERROR_GEN_FAILURE;
			}
			else
			{
				//
				// Attempt to install Modem
				//
				BOOL bNeedToReboot = FALSE;
				
				if (NULL != hwndWaitDlg)
					DestroyWindow(hwndWaitDlg);
				hwndWaitDlg = NULL;

				dwRet = (*lpIcfgInstallModem)(NULL, 0, 	&bNeedToReboot);
				
				if (ERROR_SUCCESS == dwRet)
				{
					ASSERT(!bNeedToReboot);

					//
					// Need to check if user managed to add a modem
					//
					dwRet = (*lpIcfgNeedModem)(0, &bNeedModem);
					if (TRUE == bNeedModem)
					{
						//
						// User must have cancelled the modem setup
						//
						return ERROR_CANCELLED;
					}
				}
				else
				{
					return ERROR_GEN_FAILURE;
				}

			}
		}

	}
	
	//
	// 4/2/97 ChrisK Olympus 209
	//
	if (NULL != hwndWaitDlg)
		ShowWindow(hwndWaitDlg,SW_HIDE);

	// 4/2/97 ChrisK Olympus 209
	// Dismiss dialog for good
	if (NULL != hwndWaitDlg)
		DestroyWindow(hwndWaitDlg);
	hwndWaitDlg = NULL;
	
	
	//
	// If not NT then we install the modem after installing RAS
	//
	// See if we are supposed to install a modem
	if ((FALSE == IsNT()) && (ERROR_SUCCESS == dwRet) && 
		(dwfOptions & INETCFG_INSTALLMODEM))
	{
		// Load RNA if not already loaded since ENUM_MODEM needs it.
		dwRet = EnsureRNALoaded();
		if (ERROR_SUCCESS != dwRet)
		{
			return dwRet;
		}
		
		
		// Enumerate the modems 
		ENUM_MODEM  EnumModem;
		dwRet = EnumModem.GetError();
		if (ERROR_SUCCESS != dwRet)
		{
			return dwRet;
		}
		
		// If there are no modems, install one if requested.
		if (0 == EnumModem.GetNumDevices())
		{
			
			if (FALSE == IsNT())
			{
				//
				// 5/22/97 jmazner	Olympus #4698
				// On Win95, calling RasEnumDevices launches RNAAP.EXE
				// If RNAAP.EXE is running, any modems you install won't be usable
				// So, nuke RNAAP.EXE before installing the modem.
				//
				CHAR szOtherWindowTitle[255] = "\0nogood";
				
				//
				// Unload the RAS dll's before killing RNAAP, just to be safe
				//
				DeInitRNA();
				
				LoadSz(IDS_RNAAP_TITLE,szOtherWindowTitle,255);
				HWND hwnd = FindWindow(szOtherWindowTitle, NULL);
				if (NULL != hwnd)
				{
					if (!PostMessage(hwnd, WM_CLOSE, 0, 0))
					{
						DEBUGMSG("Trying to kill RNAAP window returned getError %d", GetLastError());
					}
				}
			}
			
			// invoke the modem wizard UI to install the modem
			UINT uRet = InvokeModemWizard(hwndParent);
			
			if (uRet != ERROR_SUCCESS)
			{
				DisplayErrorMessage(hwndParent,IDS_ERRInstallModem,uRet,
					ERRCLS_STANDARD,MB_ICONEXCLAMATION);
				return ERROR_INVALID_PARAMETER;
			}
			
			
			if (FALSE == IsNT())
			{
				// Reload the RAS dlls now that the modem has been safely installed.
				InitRNA(hwndParent);
			}
			
			// Re-numerate the modems to be sure we have the most recent changes  
			dwRet = EnumModem.ReInit();
			if (ERROR_SUCCESS != dwRet)
			{
				return dwRet;
			}
			
			// If there are still no modems, user cancelled
			if (0 == EnumModem.GetNumDevices())
			{
				return ERROR_CANCELLED;
			}
			else
			{
				// removed per GeoffR request 5-2-97
				////  96/05/01  markdu  ICW BUG 8049 Reboot if modem is installed.
				//fNeedsRestart = TRUE;
			}
		}
		else
		{
			//
			// 7/15/97	jmazner	Olympus #6294
			// make sure TAPI location info is valid
			//
			InitTAPILocation(hwndParent);
		}
	}
	
	// tell caller whether we need to reboot or not
	if ((ERROR_SUCCESS == dwRet) && (lpfNeedsRestart))
	{
		*lpfNeedsRestart = fNeedsRestart;
	}
	
	// 4/2/97 ChrisK	Olympus 209											2
	// Sanity check
	if (NULL != hwndWaitDlg)
		DestroyWindow(hwndWaitDlg);
	hwndWaitDlg = NULL;
	
	return dwRet;
}

//*******************************************************************
//
//  FUNCTION:   InetNeedSystemComponents
//
//  PURPOSE:    This function will check is components that are needed
//              for internet access (such as TCP/IP and RNA) are already
//				configured based the state of the options flags.
//
//  PARAMETERS: dwfOptions - a combination of INETCFG_ flags that controls
//								the installation and configuration as follows:
//
//								INETCFG_INSTALLRNA - install RNA (if needed)
//								INETCFG_INSTALLTCP - install TCP/IP (if needed)
//
//              lpfNeedsConfig - On return, this will be 
//									TRUE if system component(s)
//									should be installed
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:	05/02/97  VetriV  Created.
//				05/08/97  ChrisK  Added INSTALLLAN, INSTALLDIALUP, and
//				                  INSTALLTCPONLY
//
//*******************************************************************

extern "C" HRESULT WINAPI InetNeedSystemComponents(DWORD dwfOptions,
													  LPBOOL lpbNeedsConfig)
{
	DWORD	dwRet = ERROR_SUCCESS;


	DEBUGMSG("export.cpp::InetNeedSystemComponents()");

	//
	// Validate parameters
	//
	if (!lpbNeedsConfig)
	{
		return ERROR_INVALID_PARAMETER;
	}

	//
	// Set up the install options
	//
	DWORD dwfInstallOptions = 0;
	if (dwfOptions & INETCFG_INSTALLTCP)
	{
		dwfInstallOptions |= ICFG_INSTALLTCP;
	}
	if (dwfOptions & INETCFG_INSTALLRNA)
	{
		dwfInstallOptions |= ICFG_INSTALLRAS;
	}

	//
	// ChrisK 5/8/97
	//
	if (dwfOptions & INETCFG_INSTALLLAN)
	{
		dwfInstallOptions |= ICFG_INSTALLLAN;
	}
	if (dwfOptions & INETCFG_INSTALLDIALUP)
	{
		dwfInstallOptions |= ICFG_INSTALLDIALUP;
	}
	if (dwfOptions & INETCFG_INSTALLTCPONLY)
	{
		dwfInstallOptions |= ICFG_INSTALLTCPONLY;
	}

  
	//
	// see if we need to install drivers
	//
	BOOL  bNeedSysComponents = FALSE;

	dwRet = lpIcfgNeedInetComponents(dwfInstallOptions, &bNeedSysComponents);

	if (ERROR_SUCCESS != dwRet)
	{
		CHAR   szErrorText[MAX_ERROR_TEXT+1]="";

		//
		// Get the text of the error message and display it.
		//
		if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
		{
			DEBUGMSG(szErrorText);
		}

		return dwRet;
	}

	
	*lpbNeedsConfig = bNeedSysComponents;
	return ERROR_SUCCESS;
}

  

//*******************************************************************
//
//  FUNCTION:   InetNeedModem
//
//  PURPOSE:    This function will check if modem is needed or not
//
//  PARAMETERS: lpfNeedsConfig - On return, this will be 
//									TRUE if modem
//									should be installed
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:	05/02/97  VetriV  Created.
//
//*******************************************************************

extern "C" HRESULT WINAPI InetNeedModem(LPBOOL lpbNeedsModem)
{

	DWORD dwRet = ERROR_SUCCESS;
		
	//
	// Validate parameters
	//
	if (!lpbNeedsModem)
	{
		return ERROR_INVALID_PARAMETER;
	}

	
	if (TRUE == IsNT())
	{
		//
		// On NT call icfgnt.dll to determine if modem is needed
		//
		BOOL bNeedModem = FALSE;
		
		if (NULL == lpIcfgNeedModem)
		{
			return ERROR_GEN_FAILURE;
		}
	

		dwRet = (*lpIcfgNeedModem)(0, &bNeedModem);
		if (ERROR_SUCCESS != dwRet)
		{
			return dwRet;
		}

		*lpbNeedsModem = bNeedModem;
		return ERROR_SUCCESS;
	}
	else
	{
		//
		// Load RNA if not already loaded since ENUM_MODEM needs it.
		//
		dwRet = EnsureRNALoaded();
		if (ERROR_SUCCESS != dwRet)
		{
			return dwRet;
		}

		//
		// Enumerate the modems
		//
		ENUM_MODEM  EnumModem;
		dwRet = EnumModem.GetError();
		if (ERROR_SUCCESS != dwRet)
		{
			return dwRet;
		}

		//
		// If there are no modems, we need to install one
		//
		if (0 == EnumModem.GetNumDevices())
		{
			*lpbNeedsModem = TRUE;
		}
		else
		{
			*lpbNeedsModem = FALSE;
		}
		return ERROR_SUCCESS;
	}
}

/*******************************************************************

  NAME:     NeedDriversDlgProc

  SYNOPSIS: Dialog proc for installing drivers

********************************************************************/

INT_PTR CALLBACK NeedDriversDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
  switch (uMsg)
  {
    case WM_INITDIALOG:
      // lParam contains pointer to NEEDDRIVERSDLGINFO struct, set it
      // in window data
      ASSERT(lParam);
      SetWindowLongPtr(hDlg,DWLP_USER,lParam);
      return NeedDriversDlgInit(hDlg,(PNEEDDRIVERSDLGINFO) lParam);
      break;

    case WM_COMMAND:
      switch (LOWORD(wParam))
      {
         case IDOK:
        {
          // get data pointer from window data
          PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo =
            (PNEEDDRIVERSDLGINFO) GetWindowLongPtr(hDlg, DWLP_USER);
          ASSERT(pNeedDriversDlgInfo);

          // pass the data to the OK handler
          BOOL fRet=NeedDriversDlgOK(hDlg,pNeedDriversDlgInfo);
          EndDialog(hDlg,fRet);
        }
        break;

        case IDCANCEL:
          SetLastError(ERROR_CANCELLED);
          EndDialog(hDlg,FALSE);
          break;                  
      }
      break;
  }

  return FALSE;
}


/*******************************************************************

  NAME:    NeedDriversDlgInit

  SYNOPSIS: proc to handle initialization of dialog for installing files

********************************************************************/

BOOL NeedDriversDlgInit(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo)
{
  ASSERT(pNeedDriversDlgInfo);

  // put the dialog in the center of the screen
  RECT rc;
  GetWindowRect(hDlg, &rc);
  SetWindowPos(hDlg, NULL,
    ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
    ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
    0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

  return TRUE;
}

/*******************************************************************

  NAME:    NeedDriversDlgOK

  SYNOPSIS:  OK handler for dialog for installing files

********************************************************************/

BOOL NeedDriversDlgOK(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo)
{
  ASSERT(pNeedDriversDlgInfo);

  // set the dialog text to "Installing files..." to give feedback to
  // user
  CHAR szMsg[MAX_RES_LEN+1];
  LoadSz(IDS_INSTALLING_FILES,szMsg,sizeof(szMsg));
  SetDlgItemText(hDlg,IDC_TX_STATUS,szMsg);

  // disable buttons & dialog so it can't get focus
  EnableDlg(hDlg, FALSE);

  // install the drivers we need
  DWORD dwRet = lpIcfgInstallInetComponents(hDlg,
    pNeedDriversDlgInfo->dwfOptions,
    pNeedDriversDlgInfo->lpfNeedsRestart);

	if (ERROR_SUCCESS != dwRet)
	{
		//
		// Don't display error message if user cancelled
		//
		if (ERROR_CANCELLED != dwRet)
		{
			CHAR   szErrorText[MAX_ERROR_TEXT+1]="";
    
			// Get the text of the error message and display it.
			if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
			{
			  MsgBoxSz(NULL,szErrorText,MB_ICONEXCLAMATION,MB_OK);
			}
		}

    // Enable the dialog again
    EnableDlg(hDlg, TRUE);

    SetLastError(dwRet);
    return FALSE;
  }

  // Enable the dialog again
  EnableDlg(hDlg, TRUE);

  return TRUE;
}


/*******************************************************************

  NAME:      EnableDlg

  SYNOPSIS:  Enables or disables the dlg buttons and the dlg
            itself (so it can't receive focus)

********************************************************************/
VOID EnableDlg(HWND hDlg,BOOL fEnable)
{
  // disable/enable ok and cancel buttons
  EnableWindow(GetDlgItem(hDlg,IDOK),fEnable);
  EnableWindow(GetDlgItem(hDlg,IDCANCEL),fEnable);

  // disable/enable dlg
  EnableWindow(hDlg,fEnable);
  UpdateWindow(hDlg);
}

//+----------------------------------------------------------------------------
//	Function	InetStartServices
//
//	Synopsis	This function guarentees that RAS services are running
//
//	Arguments	none
//
//	Return		ERROR_SUCCESS - if the services are enabled and running
//
//	History		10/16/96	ChrisK	Created
//-----------------------------------------------------------------------------
extern "C" HRESULT WINAPI InetStartServices()
{
	ASSERT(lpIcfgStartServices);
	if (NULL == lpIcfgStartServices)
		return ERROR_GEN_FAILURE;
	return (lpIcfgStartServices());
}


#if !defined(WIN16)
// 4/1/97	ChrisK	Olympus 209


//+----------------------------------------------------------------------------
//
//	Function	GetOSMajorVersion
//
//	Synopsis	Get the Major version number of Operating system
//
//	Arguments	None
//
//	Returns		Major version Number of OS
//
//	History		2/19/98		VetriV		Created
//
//-----------------------------------------------------------------------------
DWORD GetOSMajorVersion(void)
{
    static dwMajorVersion = 0;
	OSVERSIONINFO oviVersion;

	if (0 != dwMajorVersion)
	{
		return dwMajorVersion;
	}

	ZeroMemory(&oviVersion,sizeof(oviVersion));
	oviVersion.dwOSVersionInfoSize = sizeof(oviVersion);
	GetVersionEx(&oviVersion);
	dwMajorVersion = oviVersion.dwMajorVersion;
	return dwMajorVersion;
}


#endif //!WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cnetcfg\icfgcall.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//  HISTORY:
//  
//  96/05/23  markdu  Created.
//  96/05/26  markdu  Update config API.
//  96/05/27  markdu  Added lpIcfgGetLastInstallErrorText.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.

#ifndef _ICFGCALL_H_
#define _ICFGCALL_H_

// function pointer typedefs for RNA apis from rnaph.dll and rasapi32.dll
typedef DWORD   (WINAPI * GETSETUPXERRORTEXT         )  (DWORD dwErr,LPSTR pszErrorDesc,DWORD cbErrorDesc);
typedef HRESULT (WINAPI * ICFGSETINSTALLSOURCEPATH   )  (LPCSTR lpszSourcePath);
typedef HRESULT (WINAPI * ICFGINSTALLSYSCOMPONENTS   )  (HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart);
typedef HRESULT (WINAPI * ICFGNEEDSYSCOMPONENTS      )  (DWORD dwfOptions, LPBOOL lpfNeedComponents);
typedef HRESULT (WINAPI * ICFGISGLOBALDNS            )  (LPBOOL lpfGlobalDNS);
typedef HRESULT (WINAPI * ICFGREMOVEGLOBALDNS        )  (void);
typedef HRESULT (WINAPI * ICFGTURNOFFFILESHARING     )  (DWORD dwfDriverType, HWND hwndParent);
typedef HRESULT (WINAPI * ICFGISFILESHARINGTURNEDON  )  (DWORD dwfDriverType, LPBOOL lpfSharingOn);
typedef DWORD   (WINAPI * ICFGGETLASTINSTALLERRORTEXT)  (LPSTR lpszErrorDesc, DWORD cbErrorDesc);
typedef HRESULT (WINAPI * ICFGSTARTSERVICES          )  (void);

//
// These are available only on the NT icfg32.dll
//
typedef HRESULT (WINAPI * ICFGNEEDMODEM				)	(DWORD dwfOptions, LPBOOL lpfNeedModem);
typedef HRESULT (WINAPI * ICFGINSTALLMODEM			)	(HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsStart);

BOOL InitConfig(HWND hWnd);
VOID DeInitConfig();

//
// global function pointers for Config apis
//
extern ICFGSETINSTALLSOURCEPATH    lpIcfgSetInstallSourcePath;
extern ICFGINSTALLSYSCOMPONENTS    lpIcfgInstallInetComponents;
extern ICFGNEEDSYSCOMPONENTS       lpIcfgNeedInetComponents;
extern ICFGISGLOBALDNS             lpIcfgIsGlobalDNS;
extern ICFGREMOVEGLOBALDNS         lpIcfgRemoveGlobalDNS;
extern ICFGTURNOFFFILESHARING      lpIcfgTurnOffFileSharing;
extern ICFGISFILESHARINGTURNEDON   lpIcfgIsFileSharingTurnedOn;
extern ICFGGETLASTINSTALLERRORTEXT lpIcfgGetLastInstallErrorText;
extern ICFGSTARTSERVICES           lpIcfgStartServices;
//
// These two calls are only in NT icfg32.dll
//
extern ICFGNEEDMODEM				lpIcfgNeedModem;
extern ICFGINSTALLMODEM			lpIcfgInstallModem;


#endif // _ICFGCALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cnetcfg\icfgcall.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************
//

//  HISTORY:
//  
//  96/05/23  markdu  Created.
//  96/05/26  markdu  Update config API.
//  96/05/27  markdu  Added lpIcfgGetLastInstallErrorText.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.

#include "wizard.h"

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)

// Global variables
HINSTANCE ghInstConfigDll=NULL; // handle to Config dll we load explicitly
DWORD     dwCfgRefCount=0;
BOOL      fCFGLoaded=FALSE; // TRUE if config function addresses have been loaded

// global function pointers for Config apis
GETSETUPXERRORTEXT          lpGetSETUPXErrorText=NULL;
ICFGSETINSTALLSOURCEPATH    lpIcfgSetInstallSourcePath=NULL;
ICFGINSTALLSYSCOMPONENTS    lpIcfgInstallInetComponents=NULL;
ICFGNEEDSYSCOMPONENTS       lpIcfgNeedInetComponents=NULL;
ICFGISGLOBALDNS             lpIcfgIsGlobalDNS=NULL;
ICFGREMOVEGLOBALDNS         lpIcfgRemoveGlobalDNS=NULL;
ICFGTURNOFFFILESHARING      lpIcfgTurnOffFileSharing=NULL;
ICFGISFILESHARINGTURNEDON   lpIcfgIsFileSharingTurnedOn=NULL;
ICFGGETLASTINSTALLERRORTEXT lpIcfgGetLastInstallErrorText=NULL;
ICFGSTARTSERVICES           lpIcfgStartServices=NULL;

//
// These two calls are only in NT icfg32.dll
//
ICFGNEEDMODEM				lpIcfgNeedModem = NULL;
ICFGINSTALLMODEM			lpIcfgInstallModem = NULL;


//////////////////////////////////////////////////////
// Config api function names
//////////////////////////////////////////////////////
//static const CHAR szDoGenInstall[] =                "DoGenInstall";
static const CHAR szGetSETUPXErrorText[] =          "GetSETUPXErrorText";

static const CHAR szIcfgSetInstallSourcePath[] =    "IcfgSetInstallSourcePath";
static const CHAR szIcfgInstallInetComponents[] =   "IcfgInstallInetComponents";
static const CHAR szIcfgNeedInetComponents[] =      "IcfgNeedInetComponents";
static const CHAR szIcfgIsGlobalDNS[] =             "IcfgIsGlobalDNS";
static const CHAR szIcfgRemoveGlobalDNS[] =         "IcfgRemoveGlobalDNS";
static const CHAR szIcfgTurnOffFileSharing[] =      "IcfgTurnOffFileSharing";
static const CHAR szIcfgIsFileSharingTurnedOn[] =   "IcfgIsFileSharingTurnedOn";
static const CHAR szIcfgGetLastInstallErrorText[] = "IcfgGetLastInstallErrorText";
static const CHAR szIcfgStartServices[] =           "IcfgStartServices";
//
// Available only on NT icfg32.dll
//
static const CHAR szIcfgNeedModem[] =				"IcfgNeedModem";
static const CHAR szIcfgInstallModem[] =			"IcfgInstallModem";


// API table for function addresses to fetch
#define NUM_CFGAPI_PROCS   12
APIFCN ConfigApiList[NUM_CFGAPI_PROCS] =
{
  { (PVOID *) &lpGetSETUPXErrorText,          szGetSETUPXErrorText},
  { (PVOID *) &lpIcfgSetInstallSourcePath,    szIcfgSetInstallSourcePath},
  { (PVOID *) &lpIcfgInstallInetComponents,   szIcfgInstallInetComponents},
  { (PVOID *) &lpIcfgNeedInetComponents,      szIcfgNeedInetComponents},
  { (PVOID *) &lpIcfgIsGlobalDNS,             szIcfgIsGlobalDNS},
  { (PVOID *) &lpIcfgRemoveGlobalDNS,         szIcfgRemoveGlobalDNS}, 
  { (PVOID *) &lpIcfgTurnOffFileSharing,      szIcfgTurnOffFileSharing},
  { (PVOID *) &lpIcfgIsFileSharingTurnedOn,   szIcfgIsFileSharingTurnedOn},
  { (PVOID *) &lpIcfgGetLastInstallErrorText, szIcfgGetLastInstallErrorText},
  { (PVOID *) &lpIcfgStartServices,           szIcfgStartServices},
	//
	// These two calls are only in NT icfg32.dll
	//
  { (PVOID *) &lpIcfgNeedModem,		      szIcfgNeedModem},
  { (PVOID *) &lpIcfgInstallModem,	      szIcfgInstallModem}
};

#pragma data_seg(DATASEG_DEFAULT)

extern BOOL GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,
  UINT nApiProcs);

/*******************************************************************

  NAME:    InitConfig

  SYNOPSIS:  Loads the Config dll (ICFG32), gets proc addresses,

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

********************************************************************/
BOOL InitConfig(HWND hWnd)
{
  UINT uiNumCfgApiProcs = 0;

	  
  DEBUGMSG("icfgcall.c::InitConfig()");

  // only actually do init stuff on first call to this function
  // (when reference count is 0), just increase reference count
  // for subsequent calls
  if (dwCfgRefCount == 0) {

    CHAR szConfigDll[SMALL_BUF_LEN];

    DEBUGMSG("Loading Config DLL");

    // set an hourglass cursor
    WAITCURSOR WaitCursor;

	if (TRUE == IsNT())
	{
		//
		// On Windows NT get the filename (ICFGNT.DLL) out of resource
		//
		LoadSz(IDS_CONFIGNTDLL_FILENAME,szConfigDll,sizeof(szConfigDll));
	}
	else
	{
		//
		// On Windows 95 get the filename (ICFG95.DLL) out of resource
		//
		LoadSz(IDS_CONFIG95DLL_FILENAME,szConfigDll,sizeof(szConfigDll));
	}

    // load the Config api dll
    ghInstConfigDll = LoadLibrary(szConfigDll);
    if (!ghInstConfigDll) {
      UINT uErr = GetLastError();
	  // Normandy 11985 - chrisk
	  // filenames changed for Win95 and NT
      if (TRUE == IsNT())
	  {
		  DisplayErrorMessage(hWnd,IDS_ERRLoadConfigDllNT1,uErr,ERRCLS_STANDARD,
			MB_ICONSTOP);
	  }
	  else
	  {
		  DisplayErrorMessage(hWnd,IDS_ERRLoadConfigDll1,uErr,ERRCLS_STANDARD,
			MB_ICONSTOP);
	  }
      return FALSE;
    }

    //
	// Cycle through the API table and get proc addresses for all the APIs we
    // need - on NT icfg32.dll has 2 extra entry points
	//
	if (TRUE == IsNT())
		uiNumCfgApiProcs = NUM_CFGAPI_PROCS;
	else
		uiNumCfgApiProcs = NUM_CFGAPI_PROCS - 2;
	
	if (!GetApiProcAddresses(ghInstConfigDll,ConfigApiList,uiNumCfgApiProcs)) {
	// Normandy 11985 - chrisk
	// filenames changed for Win95 and NT
	  if (TRUE == IsNT())
	  {
	    MsgBox(hWnd,IDS_ERRLoadConfigDllNT2,MB_ICONSTOP,MB_OK);
	  }
	  else
	  {
		MsgBox(hWnd,IDS_ERRLoadConfigDll2,MB_ICONSTOP,MB_OK);
	  }
      DeInitConfig();
      return FALSE;
    }

  }

  fCFGLoaded = TRUE;

  dwCfgRefCount ++;

  return TRUE;
}

/*******************************************************************

  NAME:    DeInitConfig

  SYNOPSIS:  Unloads Config dll.

********************************************************************/
VOID DeInitConfig()
{
  DEBUGMSG("icfgcall.c::DeInitConfig()");

  UINT nIndex;

  // decrement reference count
  if (dwCfgRefCount)
    dwCfgRefCount --;

  // when the reference count hits zero, do real deinitialization stuff
  if (dwCfgRefCount == 0)
  {
    if (fCFGLoaded)
    {
      // set function pointers to NULL
      for (nIndex = 0;nIndex<NUM_CFGAPI_PROCS;nIndex++) 
        *ConfigApiList[nIndex].ppFcnPtr = NULL;

      fCFGLoaded = FALSE;
    }

    // free the Config dll
    if (ghInstConfigDll)
    {
    DEBUGMSG("Unloading Config DLL");
      FreeLibrary(ghInstConfigDll);
      ghInstConfigDll = NULL;
    }

  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cnetcfg\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  
//  12/21/94  jeremys  Created.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//            Need to keep a modified SetInternetConnectoid to set the
//            MSN backup connectoid.
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//

#include "wizard.h"
#if 0
#include "string.h"
#endif

#include "winver.h"

// function prototypes
VOID _cdecl FormatErrorMessage(CHAR * pszMsg,DWORD cbMsg,CHAR * pszFmt,LPSTR szArg);
extern GETSETUPXERRORTEXT lpGetSETUPXErrorText;

/*******************************************************************

  NAME:    MsgBox

  SYNOPSIS:  Displays a message box with the specified string ID

********************************************************************/
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons)
{
    CHAR szMsgBuf[MAX_RES_LEN+1];
  CHAR szSmallBuf[SMALL_BUF_LEN+1];

    LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));
    LoadSz(nMsgID,szMsgBuf,sizeof(szMsgBuf));

    return (MessageBox(hWnd,szMsgBuf,szSmallBuf,uIcon | uButtons));

}

/*******************************************************************

  NAME:    MsgBoxSz

  SYNOPSIS:  Displays a message box with the specified text

********************************************************************/
int MsgBoxSz(HWND hWnd,LPSTR szText,UINT uIcon,UINT uButtons)
{
  CHAR szSmallBuf[SMALL_BUF_LEN+1];
  LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));

    return (MessageBox(hWnd,szText,szSmallBuf,uIcon | uButtons));
}

/*******************************************************************

  NAME:    MsgBoxParam

  SYNOPSIS:  Displays a message box with the specified string ID

  NOTES:    //extra parameters are string pointers inserted into nMsgID.
			jmazner 11/6/96 For RISC compatability, we don't want
			to use va_list; since current source code never uses more than
			one string parameter anyways, just change function signature
			to explicitly include that one parameter.

********************************************************************/
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,LPSTR szParam)
{
  BUFFER Msg(3*MAX_RES_LEN+1);  // nice n' big for room for inserts
  BUFFER MsgFmt(MAX_RES_LEN+1);
  //va_list args;

  if (!Msg || !MsgFmt) {
    return MsgBox(hWnd,IDS_ERROutOfMemory,MB_ICONSTOP,MB_OK);
  }

    LoadSz(nMsgID,MsgFmt.QueryPtr(),MsgFmt.QuerySize());

  //va_start(args,uButtons);
  //FormatErrorMessage(Msg.QueryPtr(),Msg.QuerySize(),
  //  MsgFmt.QueryPtr(),args);
	FormatErrorMessage(Msg.QueryPtr(),Msg.QuerySize(),
		MsgFmt.QueryPtr(),szParam);

  return MsgBoxSz(hWnd,Msg.QueryPtr(),uIcon,uButtons);
}

/*******************************************************************

  NAME:    LoadSz

  SYNOPSIS:  Loads specified string resource into buffer

  EXIT:    returns a pointer to the passed-in buffer

  NOTES:    If this function fails (most likely due to low
        memory), the returned buffer will have a leading NULL
        so it is generally safe to use this without checking for
        failure.

********************************************************************/
LPSTR LoadSz(UINT idString,LPSTR lpszBuf,UINT cbBuf)
{
  ASSERT(lpszBuf);

  // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        LoadString( ghInstance, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

/*******************************************************************

  NAME:    GetErrorDescription

  SYNOPSIS:  Retrieves the text description for a given error code
        and class of error (standard, setupx)

********************************************************************/
VOID GetErrorDescription(CHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass)
{
  ASSERT(pszErrorDesc);

  // set a leading null in error description
  *pszErrorDesc = '\0';
  
  switch (uErrorClass) {

    case ERRCLS_STANDARD:

      if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,NULL,
        uError,0,pszErrorDesc,cbErrorDesc,NULL)) {
        // if getting system text fails, make a string a la
        // "error <n> occurred"
        CHAR szFmt[SMALL_BUF_LEN+1];
        LoadSz(IDS_ERRFORMAT,szFmt,sizeof(szFmt));
        wsprintf(pszErrorDesc,szFmt,uError);
      }

      break;

    case ERRCLS_SETUPX:

      lpGetSETUPXErrorText(uError,pszErrorDesc,cbErrorDesc);
      break;

    default:

      DEBUGTRAP("Unknown error class %lu in GetErrorDescription",
        uErrorClass);

  }

}
  
/*******************************************************************

  NAME:    FormatErrorMessage

  SYNOPSIS:  Builds an error message by calling FormatMessage

  NOTES:    Worker function for DisplayErrorMessage

********************************************************************/
VOID _cdecl FormatErrorMessage(CHAR * pszMsg,DWORD cbMsg,CHAR * pszFmt,LPSTR szArg)
{
  ASSERT(pszMsg);
  ASSERT(pszFmt);

  // build the message into the pszMsg buffer
  DWORD dwCount = FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
    pszFmt,0,0,pszMsg,cbMsg,(va_list*) &szArg);
  ASSERT(dwCount > 0);
}

/*******************************************************************

  NAME:    DisplayErrorMessage

  SYNOPSIS:  Displays an error message for given error 

  ENTRY:    hWnd - parent window
        uStrID - ID of string resource with message format.
          Should contain %1 to be replaced by error text,
          additional parameters can be specified as well.
        uError - error code for error to display
        uErrorClass - ERRCLS_xxx ID of class of error that
          uError belongs to (standard, setupx)
        uIcon - icon to display
        //... - additional parameters to be inserted in string
        //  specified by uStrID
		jmazner 11/6/96 change to just one parameter for
		RISC compatability.

********************************************************************/
VOID _cdecl DisplayErrorMessage(HWND hWnd,UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,LPSTR szArg)
{
  // dynamically allocate buffers for messages
  BUFFER ErrorDesc(MAX_RES_LEN+1);
  BUFFER ErrorFmt(MAX_RES_LEN+1);
  BUFFER ErrorMsg(2*MAX_RES_LEN+1);  

  if (!ErrorDesc || !ErrorFmt || !ErrorMsg) {
    // if can't allocate buffers, display out of memory error
    MsgBox(hWnd,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
    return;
  }

  // get a text description based on the error code and the class
  // of error it is
  GetErrorDescription(ErrorDesc.QueryPtr(),
    ErrorDesc.QuerySize(),uError,uErrorClass);

  // load the string for the message format
  LoadSz(uStrID,ErrorFmt.QueryPtr(),ErrorFmt.QuerySize());

  //LPSTR args[MAX_MSG_PARAM];
  //args[0] = (LPSTR) ErrorDesc.QueryPtr();
  //memcpy(&args[1],((CHAR *) &uIcon) + sizeof(uIcon),(MAX_MSG_PARAM - 1) * sizeof(LPSTR));

  //FormatErrorMessage(ErrorMsg.QueryPtr(),ErrorMsg.QuerySize(),
  //  ErrorFmt.QueryPtr(),(va_list) &args[0]);
  FormatErrorMessage(ErrorMsg.QueryPtr(),ErrorMsg.QuerySize(),
    ErrorFmt.QueryPtr(),ErrorDesc.QueryPtr());


  // display the message
  MsgBoxSz(hWnd,ErrorMsg.QueryPtr(),uIcon,MB_OK);

}

/*******************************************************************

  NAME:    MsgWaitForMultipleObjectsLoop

  SYNOPSIS:  Blocks until the specified object is signaled, while
        still dispatching messages to the main thread.

********************************************************************/
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent)
{
    MSG msg;
    DWORD dwObject;
    while (1)
    {
        // NB We need to let the run dialog become active so we have to half handle sent
        // messages but we don't want to handle any input events or we'll swallow the
        // type-ahead.
        dwObject = MsgWaitForMultipleObjects(1, &hEvent, FALSE,INFINITE, QS_ALLINPUT);
        // Are we done waiting?
        switch (dwObject) {
        case WAIT_OBJECT_0:
        case WAIT_FAILED:
            return dwObject;

        case WAIT_OBJECT_0 + 1:
      // got a message, dispatch it and wait again
      while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE)) {
        DispatchMessage(&msg);
      }
            break;
        }
    }
    // never gets here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cnetcfg\ids.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

// dialog size
#define MY_CXDLG                      304
#define MY_CYDLG                      163
#define MY_CXBMP                      79
#define MY_CYBMP                      160

// string resource IDs
#define IDS_APPNAME                   1000

#define IDS_WAITCHECKING              1431

#define IDS_MODEM_WIZ_TITLE           1433
#define IDS_MODEM_CPL_TITLE           1434
#define IDS_RNAAP_TITLE				1437
#define IDS_INSTALLING_FILES          1303

#define IDS_ERRInstallModem           1101
#define IDS_ERRNoDialOutModem         1134
#define IDS_ERRLoadConfigDllNT1       1137
#define IDS_ERRLoadConfigDllNT2       1138
#define IDS_ERRLoadConfigDll1         1124
#define IDS_ERRLoadConfigDll2         1125
#define IDS_ERRLoadRNADll1            1106
#define IDS_ERRLoadRNADll2            1107
#define IDS_ERROutOfMemory            1100
#define IDS_ERRFORMAT                 1003


#define IDS_CONFIG95DLL_FILENAME      1031
#define IDS_CONFIGNTDLL_FILENAME      1032
#define IDS_RNADLL_FILENAME           1004
#define IDS_RNAPHDLL_FILENAME         1013
#define IDS_GENERIC_RNA_ERROR         1015
#define IDS_WARN_SERVER_BOUND         1205
#define IDS_WARN_SERVER_BOUND1        1207
#define IDS_REMOVE_SERVER_BOUND       1208
#define IDS_REMOVE_SERVER_BOUND1      1209

#define IDC_UNUSED                    -1
#define IDC_TX_STATUS                 2143

#define IDD_NEEDDRIVERS               2023

/*

#define IDS_QUERYCANCEL               1002
#define IDS_COUNTRY_FMT               1005
#define IDS_SHORT_FMT                 1006
#define IDS_DEFAULT_PROFILE_NAME      1007
#define IDS_MAPIDLL_FILENAME          1008
#define IDS_GENERIC_MAPI_ERROR        1016
#define IDS_HELPFILE_NAME             1022
#define IDS_MSN105_INF_FILE           1026
#define IDS_MSN105_UNINSTALL_SECT     1027
#define IDS_MSN100_INF_FILE           1028
#define IDS_MSN100_UNINSTALL_SECT     1029
#define IDS_SCRIPT_FILE_FILTER        1030

#define IDS_INTERNETMAIL_SERVICENAME  1050
#define IDS_MESSAGESTORE_SERVICENAME  1051
#define IDS_ADDRESSBOOK_SERVICENAME   1052
#define IDS_INTERNETMAIL_DESCRIPTION  1053
#define IDS_MESSAGESTORE_DESCRIPTION  1054
#define IDS_ADDRESSBOOK_DESCRIPTION   1055
#define IDS_PROFILENAME               1056
#define IDS_PROFILENAME1              1057

#define IDS_MESSAGESTORE_FILENAME     1060
#define IDS_MESSAGESTORE_FILENAME1    1061
#define IDS_ADDRESSBOOK_FILENAME      1062
#define IDS_ADDRESSBOOK_FILENAME1     1063

#define IDS_ERRReadConfig             1102
#define IDS_ERRCoInitialize           1103
#define IDS_ERRCreateConnectoid       1109
#define IDS_ERRLoadMAPIDll1           1110
#define IDS_ERRLoadMAPIDll2           1111
#define IDS_ERRInitMAPI               1112
#define IDS_ERRConfigureMail          1114
#define IDS_ERRConnectoidName95       1115
#define IDS_ERRSetPhoneNumber         1116
#define IDS_ERRWriteDNS               1119
#define IDS_ERRUninstallMSN           1120
#define IDS_ERREnumModem              1121
#define IDS_ERRConfigureProxy         1123
#define IDS_ERRCorruptConnection      1126
#define IDS_ERRCorruptAccount         1127
#define IDS_ERRDuplicateConnectoidName	1128
//#define IDS_ERRInvalidAcctName        1130
//#define IDS_ERRMailSetup              1131
//#define IDS_ERRNewsSetup              1132
//#define IDS_ERRIMNConfig              1133
#define IDS_ERRModifyCSLIP            1135
#define IDS_ERRProxyRequired        1136
#define IDS_ERRConnectoidNameNT       1139
//#define	IDS_ERRDirServSetup			  1140


#define IDS_WARN_EMPTY_USERNAME       1200
#define IDS_WARN_EMPTY_DNS            1201
#define IDS_WARN_EMPTY_PASSWORD		  1203
//#define IDS_NEED_ACCOUNT              1210
//#define IDS_NEED_NEWS_ACCOUNT_NAME    1211
//#define	IDS_DUP_ACCTNAME			  1212

#define IDS_WARNWillRemoveMSN         1221

#define IDS_OKTOCHANGECONFIG          1230
#define IDS_ABOUTTOCHANGECONFIG1      1231
#define IDS_ABOUTTOCHANGECONFIG2      1232
#define IDS_DEF_CONNECTION_NAME_1     1233
#define IDS_DEF_CONNECTION_NAME_2     1234
#define IDS_SYSTEM_ALREADY_CONFIGURED 1235
#define IDS_CONFIGAPIFAILED           1236
#define IDS_SERVICEDISABLED           1237

#define IDS_NEED_PHONENUMBER          1250
#define IDS_NEED_IPADDR               1251
#define IDS_NEED_ISPNAME              1252
#define IDS_NEED_PROFILENAME          1253
#define IDS_NEED_AREACODE             1254
#define IDS_DUPLICATE_PROFILENAME     1255
//#define IDS_NEED_ACCTNAME             1256

#define IDS_INVALID_PORTNUM			  1260
//#define IDS_NEED_NEWSSERV			  1261
#define IDS_INVALIDPHONE			  1262
//#define	IDS_NEED_SERVERNAME			  1263

#define IDS_INVALID_IPADDR            1300

#define IDS_MODIFYCONNECTION          1320

// Normandy 11970 ChrisK - we need a different title if launched from
// mail or news configuration
#define IDS_BEGINMANUAL_ALTERNATE     1323

#define	IDS_LOGINSCRIPTINVALID		  1324

#define IDS_HOWTOCONNECT_DESC1		  1400
#define IDS_HOWTOCONNECT_DESC2		  1401
#define	IDS_CONNECTION_DESC1		  1402
#define	IDS_CONNECTION_DESC2		  1403


//#define IDS_EXITFAILED                1429
#define IDS_WANTTOREBOOT              1430
//#define IDS_NEEDTOREBOOT						1428

#define IDS_SBCSONLY				  1435

#define IDS_CONNECTIONTO				  1436


// dialog page IDs
//#define IDD_PAGE_WELCOME              2000
#define IDD_PAGE_HOWTOCONNECT         2001
#define IDD_PAGE_CHOOSEMODEM          2002
#define IDD_PAGE_CONNECTEDOK          2003
#define IDD_PAGE_CONNECTION           2004
#define IDD_PAGE_CONNECTIONNAME       2005
#define IDD_PAGE_MODIFYCONNECTION     2006
#define IDD_PAGE_ADVANCED             2007
#define IDD_PAGE_PHONENUMBER          2008
#define IDD_PAGE_NAMEANDPASSWORD      2009
#define IDD_PAGE_CONNECTIONPROTOCOL   2010
#define IDD_PAGE_LOGINSCRIPT          2011
#define IDD_PAGE_USEPROXY             2012
#define IDD_PAGE_PROXYSERVERS         2013
#define IDD_PAGE_PROXYEXCEPTIONS      2014
#define IDD_PAGE_IPADDRESS            2015
#define IDD_PAGE_DNSADDRESS           2016

#define IDD_NEWPROFILENAME            2020
#define IDD_SECURITY_CHECK            2021
#define IDD_DNS_WARNING               2022
#define IDD_CHOOSEMODEMNAME           2024
#define IDD_CHOOSEPROFILENAME         2025
#define IDD_PAGE_LCPEXTENSIONS        2026

#define IDS_MAPIERROR_BASE            3000

#ifdef IDC_HELP
#undef IDC_HELP
#endif

// dialog control IDs
#define IDC_BMPFRAME                  2100
#define IDC_CONNECT_BY_PHONE          2102
#define IDC_CONNECT_BY_LAN            2103
#define	IDC_CONNECT_MANUAL			  2104
#define IDC_AREACODE                  2108
#define IDC_PHONENUMBER               2109
#define IDC_USERNAME                  2110
#define IDC_PASSWORD                  2111
#define IDC_CONFIRMPASSWORD           2112
#define IDC_MODIFYCONNECTION          2113
#define IDC_NOMODIFYCONNECTION        2114
#define IDC_CONNECTIONNAME            2115
#define IDC_NEWCONNECTION             2116
#define IDC_EXISTINGCONNECTION        2117
#define IDC_LBLMODIFYCONNECTION       2118
#define IDC_MODIFYADVANCED            2119
#define IDC_NOMODIFYADVANCED          2120
#define IDC_ISPNAME                   2121
#define IDC_USE_DHCP                  2123
#define IDC_USE_IP                    2124
#define IDC_IPADDR                    2125
#define IDC_DNSADDR1                  2127
#define IDC_DNSADDR2                  2128
#define IDC_TX_IPADDR                 2129
#define IDC_AUTO_DNS                  2130
#define IDC_STATIC_DNS                2131
#define IDC_TX_DNSADDR1               2132
#define IDC_TX_DNSADDR2               2133
#define IDC_COUNTRYCODE               2136
#define IDC_MODEM                     2137
#define IDC_SETDEFAULT                2149
#define IDC_NEW_PROFILE               2150
#define IDC_PROFILE_LIST              2151
#define IDC_PROFILENAME               2152
#define IDC_DISABLE_CHECK             2153
#define IDC_GRP_SETTINGS              2154
#define IDC_HELP                      2155
#define IDC_DISABLE_WARNING           2156
#define IDC_USEDIALRULES              2157
#define IDC_PROTOCOLPPP               2158
#define IDC_PROTOCOLSLIP              2159
#define IDC_PROTOCOLCSLIP             2160
#define IDC_NOTERMINALAFTERDIAL       2161
#define IDC_TERMINALAFTERDIAL         2162
#define IDC_SCRIPT                    2163
#define IDC_BROWSE                    2164
#define IDC_SCRIPTFILE                2170
#define IDC_TX_PROXYBYPASS            2178
#define IDC_TX_PROXYSERVER            2179
#define IDC_TX_AREACODE               2180
#define IDC_TX_COUNTRYCODE            2181
#define IDC_TX_SEPARATOR              2182
#define IDC_LBLTITLE                  2183
//#define IDC_INSTALLMAIL               2184
//#define IDC_NOMAIL                    2185
//#define IDC_MAILNAME                  2186
//#define IDC_MAILADDRESS               2187
//#define IDC_INCOMINGMAILSERVER                 2188
//#define IDC_SMTPSERVER                2189
//#define IDC_INSTALLNEWS               2190
//#define IDC_NONEWS                    2191
//#define IDC_SERVER                    2192
//#define IDC_NEWSNAME                  2193
//#define IDC_NEWSADDRESS               2194
//#define IDC_LOGONNEWS                 2195
//#define IDC_NEWSACCOUNT               2196
//#define IDC_NEWSSECURE                2197
#define IDC_TX_ACCOUNT                2198
#define IDC_TX_PASSWORD               2199

#define IDC_USEPROXY                  2200
#define IDC_NOUSEPROXY                2201
#define IDC_TX_PROXYTYPE              2202
#define IDC_TX_PROXYADDRESS           2203
#define IDC_TX_PROXYPORT              2204
#define IDC_TX_PROXYHTTP              2205
#define IDC_PROXYHTTP                 2206
#define IDC_PORTHTTP                  2207
#define IDC_TX_PROXYSECURE            2208
#define IDC_PROXYSECURE               2209
#define IDC_PORTSECURE                2210
#define IDC_TX_PROXYFTP               2211
#define IDC_PROXYFTP                  2212
#define IDC_PORTFTP                   2213
#define IDC_TX_PROXYGOPHER            2214
#define IDC_PROXYGOPHER               2215
#define IDC_PORTGOPHER                2216
#define IDC_TX_PROXYSOCKS             2217
#define IDC_PROXYSOCKS                2218
#define IDC_PORTSOCKS                 2219
#define IDC_PROXYSAME                 2220
#define IDC_TX_BYPASSPROXY            2222
#define IDC_BYPASSPROXY               2223
#define IDC_TX_USESEMICOLON           2224
#define IDC_BYPASSLOCAL               2225

#define IDC_INCOMINGMAILTYPE		  2226

#define IDC_NEWACCT                   2230
#define IDC_EXISTINGACCT              2231
#define IDC_ACCTNAME                  2232
#define IDC_ACCTLIST                  2233
#define IDC_LBLMODIFYACCT             2234
#define IDC_MODIFYACCT                2235
#define IDC_NOMODIFYACCT              2236

#define IDC_CANCEL                    2240
#define IDC_DISABLELCP                2241
#define IDC_NODISABLELCP              2242

#define	IDC_DESC					  2250
#define IDC_LOGONPLAIN				  2252
#define IDC_LOGONSICILY				  2253
#define	IDC_LBLUSERNAME				  2254
#define	IDC_LBLPASSWORD				  2255

//#define IDC_INSTALL_DIR_SERV		  2256
//#define	IDC_NO_DIR_SERV				  2257

#define	IDC_NOTE					2258

// bitmap IDs
#define IDB_BMP_WELCOME               2290

// icon IDs
#define IDI_WORLD                     2300
#define IDI_MODEM                     2303

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cnetcfg\wizdll.cpp ===
/*****************************************************************/
/**          Microsoft Windows for Workgroups        **/
/**          Copyright (c) 1991-1998 Microsoft Corporation
/*****************************************************************/ 

//
//  WIZDLL.C - 32-bit stubs for functions that call into 16-bit DLL
//

//  HISTORY:
//  
//  11/20/94  jeremys  Created.
//  96/03/13  markdu  Added IcfgSetInstallSourcePath().
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//  96/05/28  markdu  InitConfig and DeInitConfig in DllEntryPoint.
//

#include "wizard.h"

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)
HINSTANCE ghInstance=NULL;
#pragma data_seg(DATASEG_DEFAULT)

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

#ifdef __cplusplus
}
#endif // __cplusplus

/*******************************************************************

  NAME:    DllEntryPoint

  SYNOPSIS:  Entry point for DLL.

  NOTES:    Initializes thunk layer to WIZ16.DLL

********************************************************************/
BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
  if( fdwReason == DLL_PROCESS_ATTACH )
  {
    ghInstance = hInstDll;

	// load the config dll proc addresses
    BOOL fRet = InitConfig(NULL);
    if (FALSE == fRet)
    {
      // Error message was already displayed in InitConfig.
      return FALSE;
    }
  }

  if( fdwReason == DLL_PROCESS_DETACH )
  {
    DeInitConfig();
  }

  return TRUE;
}


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

void __cdecl main() {};

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cnetcfg\rnacall.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  RNACALL.H - header file for RNA functions 
//

//  HISTORY:
//  
//  1/20/95   jeremys Created (mostly cloned from RNA UI code)
//  96/01/31  markdu  Renamed CONNENTDLG to OLDCONNENTDLG to avoid
//            conflicts with RNAP.H.
//  96/02/23  markdu  Replaced RNAValidateEntryName with
//            RASValidateEntryName
//  96/02/24  markdu  Re-wrote the definition of ENUM_MODEM to
//            use RASEnumDevices() instead of RNAEnumDevices().
//            Also removed RNAGetDeviceInfo().
//  96/02/24  markdu  Re-wrote the definition of ENUM_CONNECTOID to
//            use RASEnumEntries() instead of RNAEnumConnEntries().
//  96/02/26  markdu  Replaced all remaining internal RNA APIs.
//            Also copied two structures (tagPhoneNum and tapIPData)
//            from rnap.h and tagIAddr from rnaphint.h for internal use only.
//  96/03/07  markdu  Extend ENUM_MODEM class
//  96/03/08  markdu  Added ENUM_MODEM::VerifyDeviceNameAndType
//  96/03/09  markdu  Moved all function prototypes here from wizard.h
//  96/03/09  markdu  Added LPRASENTRY parameter to CreateConnectoid()
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//            Also no longer need GetConnectoidPhoneNumber function.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Moved all references to phone number into RASENTRY.
//            Moved tagPhoneNum to inetapi.h
//  96/03/11  markdu  Moved code to set username and password out of
//            CreateConnectoid into SetConnectoidUsername so it can be reused.
//  96/03/13  markdu  Change ValidateConncectoidName to take LPCSTR.
//  96/03/16  markdu  Added ReInit member function to re-enumerate modems.
//  96/03/25  markdu  Removed GetIPInfo and SetIPInfo.
//  96/04/04  markdu  Added phonebook name param to CreateConnectoid,
//            ValidateConnectoidName, and SetConnectoidUsername.
//  96/05/16  markdu  NASH BUG 21810 Added function for IP address validation.
//

#ifndef _RNACALL_H_
#define _RNACALL_H_

// function pointer typedefs for RNA apis from rnaph.dll and rasapi32.dll
typedef DWORD       (WINAPI * RASENUMDEVICES) (LPRASDEVINFO, LPDWORD, LPDWORD);
typedef DWORD       (WINAPI * RASENUMENTRIES) (LPSTR,LPSTR,LPRASENTRYNAME,LPDWORD,LPDWORD);

class ENUM_MODEM
{
private:
  DWORD         m_dwError;
  DWORD         m_dwNumEntries;
  DWORD         m_dwIndex;
  LPRASDEVINFO  m_lpData;
public:
  ENUM_MODEM();
  ~ENUM_MODEM();
  DWORD ReInit();
  CHAR * Next();
  CHAR * GetDeviceTypeFromName(LPSTR szDeviceName);
  CHAR * GetDeviceNameFromType(LPSTR szDeviceType);
  BOOL VerifyDeviceNameAndType(LPSTR szDeviceName, LPSTR szDeviceType);
  DWORD GetNumDevices() { return m_dwNumEntries; }
  DWORD GetError()  { return m_dwError; }
  void  ResetIndex() { m_dwIndex = 0; }
};

// function prototypes

BOOL InitRNA(HWND hWnd);
VOID DeInitRNA();
DWORD EnsureRNALoaded(VOID);

#endif // _RNACALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\allcmdir.h ===
//+----------------------------------------------------------------------------
//
// File:     allcmdir.h
//
// Module:   CMSTP.EXE and CMCFG32.DLL
//
// Synopsis: Resource IDs for allcmdir.rc
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb  Created    08/05/99
//
//+----------------------------------------------------------------------------
#define	IDS_CMSUBFOLDER	        	500
#define	IDS_APPDATA	        	501
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cnetcfg\rnacall.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************
//
//  RNACALL.C - functions to call RNA dll to create connectoid
//
//  HISTORY:
//  
//  1/18/95   jeremys Cloned from RNA UI code
//  96/01/31  markdu  Renamed CONNENTDLG to OLDCONNENTDLG to avoid
//            conflicts with RNAP.H.
//  96/02/23  markdu  Replaced RNAValidateEntryName with
//            RASValidateEntryName
//  96/02/24  markdu  Re-wrote the implementation of ENUM_MODEM to
//            use RASEnumDevices() instead of RNAEnumDevices().
//            Also eliminated IsValidDevice() and RNAGetDeviceInfo().
//  96/02/24  markdu  Re-wrote the implementation of ENUM_CONNECTOID to
//            use RASEnumEntries() instead of RNAEnumConnEntries().
//  96/02/26  markdu  Replaced all remaining internal RNA APIs.
//  96/03/07  markdu  Extend ENUM_MODEM class, and use global modem
//            enum object.
//  96/03/08  markdu  Do complete verification of device name and type
//            strings passed in to CreateConnectoid.
//  96/03/09  markdu  Moved generic RASENTRY initialization into
//            its own function (InitRasEntry).  Added a wait cursor
//            during loading of RNA.
//  96/03/09  markdu  Added LPRASENTRY parameter to CreateConnectoid()
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//            Also no longer need GetConnectoidPhoneNumber function.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Moved all references to phone number into RASENTRY.
//  96/03/11  markdu  Moved code to set username and password out of
//            CreateConnectoid into SetConnectoidUsername so it can be reused.
//  96/03/11  markdu  Added some flags in InitRasEntry.
//  96/03/13  markdu  Change ValidateConncectoidName to take LPCSTR.
//  96/03/16  markdu  Added ReInit member function to re-enumerate modems.
//  96/03/21  markdu  Work around RNA bug in ENUM_MODEM::ReInit().
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/03/24  markdu  Replaced lstrcpy with lstrcpyn where appropriate.
//  96/03/25  markdu  Removed GetIPInfo and SetIPInfo.
//  96/04/04  markdu  Added phonebook name param to CreateConnectoid,
//            ValidateConnectoidName, and SetConnectoidUsername.
//  96/04/07  markdu  NASH BUG 15645 Work around RNA bug where area code
//            string is required even though it is not being used.
//  96/04/26  markdu  NASH BUG 18605 Handle ERROR_FILE_NOT_FOUND return
//            from ValidateConnectoidName.
//  96/05/14  markdu  NASH BUG 22730 Work around RNA bug.  Flags for terminal
//            settings are swapped by RasSetEntryproperties.
//  96/05/16  markdu  NASH BUG 21810 Added function for IP address validation.
//  96/06/04  markdu  OSR  BUG 7246 Add RASEO_SwCompression and
//            RASEO_ModemLights to default RASENTRY.
//

#include "wizard.h"
#include "tapi.h"
#include "CompareString.cpp"

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)

// Global variables
HINSTANCE ghInstRNADll=NULL; // handle to RNA dll we load explicitly
HINSTANCE ghInstRNAPHDll=NULL;  // handle to RNAPH dll we load explicitly
DWORD     dwRefCount=0;
BOOL      fRNALoaded=FALSE; // TRUE if RNA function addresses have been loaded

// global function pointers for RNA apis

RASENUMDEVICES          lpRasEnumDevices=NULL; 
RASENUMENTRIES          lpRasEnumEntries=NULL; 

// API table for function addresses to fetch
#define NUM_RNAAPI_PROCS   2
APIFCN RnaApiList[NUM_RNAAPI_PROCS] =
{
  { (PVOID *) &lpRasEnumDevices,"RasEnumDevicesA"},
  { (PVOID *) &lpRasEnumEntries,"RasEnumEntriesA"}
};

#pragma data_seg(DATASEG_DEFAULT)

ENUM_MODEM *      gpEnumModem=NULL;  // pointer modem enumeration object

BOOL  GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,UINT nApiProcs);

static const CHAR szRegValRNAWizard[] =     "wizard";
static const CHAR szRegPathRNAWizard[] =     REGSTR_PATH_REMOTEACCESS;

/*******************************************************************

  NAME:    InitRNA

  SYNOPSIS:  Loads the RNA dll (RASAPI32), gets proc addresses,
        and loads RNA engine

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

  NOTES:    We load the RNA dll explicitly and get proc addresses
        because these are private APIs and not guaranteed to
        be supported beyond Windows 95.  This way, if the DLL
        isn't there or the entry points we expect aren't there,
        we can display a coherent message instead of the weird
        Windows dialog you get if implicit function addresses
        can't be resolved.

********************************************************************/
BOOL InitRNA(HWND hWnd)
{
  DEBUGMSG("rnacall.c::InitRNA()");

  // only actually do init stuff on first call to this function
  // (when reference count is 0), just increase reference count
  // for subsequent calls
  if (dwRefCount == 0) {

    CHAR szRNADll[SMALL_BUF_LEN];

    DEBUGMSG("Loading RNA DLL");

    // set an hourglass cursor
    WAITCURSOR WaitCursor;

    // get the filename (RASAPI32.DLL) out of resource
    LoadSz(IDS_RNADLL_FILENAME,szRNADll,sizeof(szRNADll));

    // load the RNA api dll
    ghInstRNADll = LoadLibrary(szRNADll);
    if (!ghInstRNADll) {
      UINT uErr = GetLastError();
      DisplayErrorMessage(hWnd,IDS_ERRLoadRNADll1,uErr,ERRCLS_STANDARD,
        MB_ICONSTOP);
      return FALSE;
    }

    // cycle through the API table and get proc addresses for all the APIs we
    // need
    if (!GetApiProcAddresses(ghInstRNADll,RnaApiList,NUM_RNAAPI_PROCS)) {
      MsgBox(hWnd,IDS_ERRLoadRNADll2,MB_ICONSTOP,MB_OK);
      DeInitRNA();
      return FALSE;
    }

  }

  fRNALoaded = TRUE;

  dwRefCount ++;

  return TRUE;
}

/*******************************************************************

  NAME:    DeInitRNA

  SYNOPSIS:  Unloads RNA dll.

********************************************************************/
VOID DeInitRNA()
{
  DEBUGMSG("rnacall.c::DeInitRNA()");

  UINT nIndex;

  // decrement reference count
  if (dwRefCount)
    dwRefCount --;

  // when the reference count hits zero, do real deinitialization stuff
  if (dwRefCount == 0)
  {
    if (fRNALoaded)
    {
      // set function pointers to NULL
      for (nIndex = 0;nIndex<NUM_RNAAPI_PROCS;nIndex++) 
        *RnaApiList[nIndex].ppFcnPtr = NULL;

      fRNALoaded = FALSE;
    }

    // free the RNA dll
    if (ghInstRNADll)
    {
    DEBUGMSG("Unloading RNA DLL");
      FreeLibrary(ghInstRNADll);
      ghInstRNADll = NULL;
    }

    // free the RNAPH dll
    if (ghInstRNAPHDll)
    {
    DEBUGMSG("Unloading RNAPH DLL");
      FreeLibrary(ghInstRNAPHDll);
      ghInstRNAPHDll = NULL;
    }
  }
}

VOID FAR PASCAL LineCallback(DWORD hDevice, DWORD dwMsg, 
    DWORD dwCallbackInstance, DWORD dwParam1, DWORD dwParam2, 
    DWORD dwParam3)
{
	return;
}

/*******************************************************************

  NAME:    EnsureRNALoaded

  SYNOPSIS:  Loads RNA if not already loaded

********************************************************************/
DWORD EnsureRNALoaded(VOID)
{
  DEBUGMSG("rnacall.c::EnsureRNALoaded()");

  DWORD dwRet = ERROR_SUCCESS;

  // load RNA if necessary
  if (!fRNALoaded) {
    if (InitRNA(NULL))
      fRNALoaded = TRUE;
    else return ERROR_FILE_NOT_FOUND;
  }

  return dwRet;
}


/*******************************************************************

  NAME:    ENUM_MODEM::ENUM_MODEM

  SYNOPSIS:  Constructor for class to enumerate modems

  NOTES:    Useful to have a class rather than C functions for
        this, due to how the enumerators function

********************************************************************/
ENUM_MODEM::ENUM_MODEM() :
  m_dwError(ERROR_SUCCESS),m_lpData(NULL),m_dwIndex(0)
{
  DWORD cbSize = 0;

  // Use the reinit member function to do the work.
  this->ReInit();
}


/*******************************************************************

  NAME:     ENUM_MODEM::ReInit

  SYNOPSIS: Re-enumerate the modems, freeing the old memory.

********************************************************************/
DWORD ENUM_MODEM::ReInit()
{
  DWORD cbSize = 0;

  // Clean up the old list
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
  m_dwNumEntries = 0;
  m_dwIndex = 0;

  // call RasEnumDevices with no buffer to find out required buffer size
  ASSERT(lpRasEnumDevices);
  m_dwError = lpRasEnumDevices(NULL, &cbSize, &m_dwNumEntries);

  // Special case check to work around RNA bug where ERROR_BUFFER_TOO_SMALL
  // is returned even if there are no devices.
  // If there are no devices, we are finished.
  if (0 == m_dwNumEntries)
  {
    m_dwError = ERROR_SUCCESS;
    return m_dwError;
  }

  // Since we were just checking how much mem we needed, we expect
  // a return value of ERROR_BUFFER_TOO_SMALL, or it may just return
  // ERROR_SUCCESS (ChrisK  7/9/96).
  if (ERROR_BUFFER_TOO_SMALL != m_dwError && ERROR_SUCCESS != m_dwError)
  {
    return m_dwError;
  }

  // Allocate the space for the data
  m_lpData = (LPRASDEVINFO) new CHAR[cbSize];
  if (NULL == m_lpData)
  {
    DEBUGTRAP("ENUM_MODEM: Failed to allocate device list buffer");
    m_dwError = ERROR_NOT_ENOUGH_MEMORY;
    return m_dwError;
  }
  m_lpData->dwSize = sizeof(RASDEVINFO);
  m_dwNumEntries = 0;

  // enumerate the modems into buffer
  m_dwError = lpRasEnumDevices(m_lpData, &cbSize,
    &m_dwNumEntries);

  if (ERROR_SUCCESS != m_dwError)
	  return m_dwError;

    //
    // ChrisK Olympus 4560 do not include VPN's in the list
    //
    DWORD dwTempNumEntries;
    DWORD idx;
    LPRASDEVINFO lpNextValidDevice;

    dwTempNumEntries = m_dwNumEntries;
    lpNextValidDevice = m_lpData;

	//
	// Walk through the list of devices and copy non-VPN device to the first
	// available element of the array.
	//
	for (idx = 0;idx < dwTempNumEntries; idx++)
	{
        if (0 != SafeCompareStringA("VPN",m_lpData[idx].szDeviceType))
		{
			if (lpNextValidDevice != &m_lpData[idx])
			{
				MoveMemory(lpNextValidDevice ,&m_lpData[idx],sizeof(RASDEVINFO));
			}
			lpNextValidDevice++;
		}
		else
		{
			m_dwNumEntries--;
		}
	}
  
  return m_dwError;
}


/*******************************************************************

  NAME:    ENUM_MODEM::~ENUM_MODEM

  SYNOPSIS:  Destructor for class

********************************************************************/
ENUM_MODEM::~ENUM_MODEM()
{
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
}

/*******************************************************************

  NAME:     ENUM_MODEM::Next

  SYNOPSIS: Enumerates next modem 

  EXIT:     Returns a pointer to device info structure.  Returns
            NULL if no more modems or error occurred.  Call GetError
            to determine if error occurred.

********************************************************************/
CHAR * ENUM_MODEM::Next()
{
  if (m_dwIndex < m_dwNumEntries)
  {
    return m_lpData[m_dwIndex++].szDeviceName;
  }

  return NULL;
}


/*******************************************************************

  NAME:     ENUM_MODEM::GetDeviceTypeFromName

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device type string for first
            device name that matches.  Returns
            NULL if no device with specified name is found

********************************************************************/

CHAR * ENUM_MODEM::GetDeviceTypeFromName(LPSTR szDeviceName)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return m_lpData[dwIndex].szDeviceType;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     ENUM_MODEM::GetDeviceNameFromType

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device name string for first
            device type that matches.  Returns
            NULL if no device with specified Type is found

********************************************************************/

CHAR * ENUM_MODEM::GetDeviceNameFromType(LPSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType))
    {
      return m_lpData[dwIndex].szDeviceName;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     ENUM_MODEM::VerifyDeviceNameAndType

  SYNOPSIS: Determines whether there is a device with the name
            and type given.

  EXIT:     Returns TRUE if the specified device was found, 
            FALSE otherwise.

********************************************************************/

BOOL ENUM_MODEM::VerifyDeviceNameAndType(LPSTR szDeviceName, LPSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType) &&
      !lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return TRUE;
    }
    dwIndex++;
  }

  return FALSE;
}

/*******************************************************************

  NAME:    GetApiProcAddresses

  SYNOPSIS:  Gets proc addresses for a table of functions

  EXIT:    returns TRUE if successful, FALSE if unable to retrieve
        any proc address in table

  HISTORY: 
  96/02/28  markdu  If the api is not found in the module passed in,
            try the backup (RNAPH.DLL)

********************************************************************/
BOOL GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,UINT nApiProcs)
{
  DEBUGMSG("rnacall.c::GetApiProcAddresses()");

  UINT nIndex;
  // cycle through the API table and get proc addresses for all the APIs we
  // need
  for (nIndex = 0;nIndex < nApiProcs;nIndex++)
  {
    if (!(*pApiProcList[nIndex].ppFcnPtr = (PVOID) GetProcAddress(hModDLL,
      pApiProcList[nIndex].pszName)))
    {
      // Try to find the address in RNAPH.DLL.  This is useful in the
      // case that RASAPI32.DLL did not contain the function that we
      // were trying to load.
      if (FALSE == IsNT())
	  {
		  if (!ghInstRNAPHDll)
		  {
			CHAR szRNAPHDll[SMALL_BUF_LEN];

			LoadSz(IDS_RNAPHDLL_FILENAME,szRNAPHDll,sizeof(szRNAPHDll));
			ghInstRNAPHDll = LoadLibrary(szRNAPHDll);
		  }

		  if ((!ghInstRNAPHDll) ||  !(*pApiProcList[nIndex].ppFcnPtr =
			(PVOID) GetProcAddress(ghInstRNAPHDll,pApiProcList[nIndex].pszName)))
		  {
			DEBUGMSG("Unable to get address of function %s",
				pApiProcList[nIndex].pszName);

			for (nIndex = 0;nIndex<nApiProcs;nIndex++)
				*pApiProcList[nIndex].ppFcnPtr = NULL;

			return FALSE;
		  }
		}
	}
  }

  return TRUE;
}

//+----------------------------------------------------------------------------
//
//	Function:	InitTAPILocation
//
//	Synopsis:	Ensure that TAPI location information is configured correctly;
//				if not, prompt user to fill it in.
//
//	Arguments:	hwndParent -- parent window for TAPI dialog to use
//							(_must_ be a valid window HWND, see note below)
//
//	Returns:	void
//
//	Notes:		The docs for lineTranslateDialog lie when they say that the
//				fourth parameter (hwndOwner) can be null.  In fact, if this
//				is null, the call will return with LINEERR_INVALPARAM.
//				
//
//	History:	7/15/97	jmazner	Created for Olympus #6294
//
//-----------------------------------------------------------------------------
void InitTAPILocation(HWND hwndParent)
{
	HLINEAPP hLineApp=NULL;
	char szTempCountryCode[8];
	char szTempCityCode[8];
	DWORD dwTapiErr = 0;
	DWORD cDevices=0;
	DWORD dwCurDevice = 0;


	ASSERT( IsWindow(hwndParent) );

	//
	// see if we can get location info from TAPI
	//
	dwTapiErr = tapiGetLocationInfo(szTempCountryCode,szTempCityCode);
	if( 0 != dwTapiErr )
	{
		// 
		// GetLocation failed.  let's try calling the TAPI mini dialog.  Note
		// that when called in this fashion, the dialog has _no_ cancel option,
		// the user is forced to enter info and hit OK.
		//
		DEBUGMSG("InitTAPILocation, tapiGetLocationInfo failed");
		
		dwTapiErr = lineInitialize(&hLineApp,ghInstance,LineCallback," ",&cDevices);
		if (dwTapiErr == ERROR_SUCCESS)
		{
			//
			// loop through all TAPI devices and try to call lineTranslateDialog
			// The call might fail for VPN devices, thus we want to try every
			// device until we get a success.
			//
			dwTapiErr = LINEERR_INVALPARAM;

			while( (dwTapiErr != 0) && (dwCurDevice < cDevices) )
			{
				dwTapiErr = lineTranslateDialog(hLineApp,dwCurDevice,0x10004,hwndParent,NULL);
				if( 0 != dwTapiErr )
				{
					DEBUGMSG("InitTAPILocation, lineTranslateDialog on device %d failed with err = %d!",
						dwCurDevice, dwTapiErr);
				}
				dwCurDevice++;
			}
		}
		else
		{
			DEBUGMSG("InitTAPILocation, lineInitialize failed with err = %d", dwTapiErr);
		}

		dwTapiErr = tapiGetLocationInfo(szTempCountryCode,szTempCityCode);
		if( 0 != dwTapiErr )
		{
			DEBUGMSG("InitTAPILocation still failed on GetLocationInfo, bummer.");
		}
		else
		{
			DEBUGMSG("InitTAPILocation, TAPI location is initialized now");
		}
	}

	if( hLineApp )
	{
		lineShutdown(hLineApp);
		hLineApp = NULL;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cnetcfg\wizard.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1999 Microsoft Corporation
//*********************************************************************

//
//  WIZARD.H - central header file for Internet setup/signup wizard
//

//  HISTORY:
//
//  11/20/94  jeremys  Created.
//  96/02/24  markdu  Added RNAPH.H
//  96/02/27  markdu  Replaced internal RNA header files with RAS.H
//  96/03/07  markdu  Added gpEnumModem
//  96/03/09  markdu  Moved all rnacall function prototypes to rnacall.h
//  96/03/09  markdu  Added gpRasEntry
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//  96/04/24  markdu  NASH BUG 19289 Added /NOMSN command line flag
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//

#ifndef _WIZARD_H_
#define _WIZARD_H_

#define STRICT                      // Use strict handle types
#define _SHELL32_

  #include <windows.h>
  #include <commctrl.h>
  #include <oharestr.h>

  // various RNA header files
#pragma pack(8)
  #include <ras.h>
  #include <ras2.h>
#pragma pack()
  #include <raserror.h>
  #include "rnacall.h"
  #include <wizglob.h>
  #include <wizdebug.h>

#undef DATASEG_READONLY
#define DATASEG_READONLY  ".rdata"

#include "cfgapi.h"
#include "clsutil.h"

#include "icfgcall.h"
#include "ids.h"

// Globals

extern ENUM_MODEM*  gpEnumModem;    // modem enumeration object
extern HINSTANCE    ghInstance;     // global module instance handle

// Defines

#define MAX_REG_LEN			2048	// max length of registry entries
#define MAX_RES_LEN         255 // max length of string resources
#define SMALL_BUF_LEN       48  // convenient size for small text buffers

// error class defines for DisplayErrorMessage
#define ERRCLS_STANDARD 0x0001
#define ERRCLS_SETUPX   0x0002
//#define ERRCLS_RNA      0x0003
//#define ERRCLS_MAPI     0x0004


// functions in TCPCFG.CPP

HRESULT WarnIfServerBound(HWND hDlg,DWORD dwCardFlags,BOOL* pfNeedsRestart);
HRESULT RemoveIfServerBound(HWND hDlg,DWORD dwCardFlags,BOOL* pfNeedsRestart);

// functions in CALLOUT.C
UINT InvokeModemWizard(HWND hwndToHide);

// functions in UTIL.C
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons);
int MsgBoxSz(HWND hWnd,LPSTR szText,UINT uIcon,UINT uButtons);
// jmazner 11/6/96	modified for RISC compatability
//int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,...);
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons, LPSTR szParam = NULL);

LPSTR LoadSz(UINT idString,LPSTR lpszBuf,UINT cbBuf);

// modified for RISC compatability
//VOID _cdecl DisplayErrorMessage(HWND hWnd,UINT uStrID,UINT uError,
//  UINT uErrorClass,UINT uIcon,...);
VOID _cdecl DisplayErrorMessage(HWND hWnd,UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,LPSTR szArg = NULL);

VOID GetErrorDescription(CHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass);

DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent);

// structure for getting proc addresses of api functions
typedef struct APIFCN {
  PVOID * ppFcnPtr;
  LPCSTR pszName;
} APIFCN;

#undef  DATASEG_PERINSTANCE
#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".data"
#define DATASEG_DEFAULT    DATASEG_SHARED

inline BOOL IsNT(void)
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);
}

#endif // _WIZARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\allowaccess.h ===
//+----------------------------------------------------------------------------
//
// File:     allowaccess.h
//
// Module:   Common Code
//
// Synopsis: Implements the function AllowAccessToWorld.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb    Created   12/04/01
//
//+----------------------------------------------------------------------------

#include <aclapi.h>

typedef WINUSERAPI DWORD (WINAPI *pfnGetSidLengthRequiredSpec)(UCHAR);
typedef WINUSERAPI BOOL (WINAPI *pfnInitializeSidSpec)(PSID, PSID_IDENTIFIER_AUTHORITY, BYTE);
typedef WINUSERAPI PDWORD (WINAPI *pfnGetSidSubAuthoritySpec)(PSID, DWORD);
typedef WINUSERAPI BOOL (WINAPI *pfnInitializeAclSpec)(PACL, DWORD, DWORD);
typedef WINUSERAPI BOOL (WINAPI *pfnAddAccessAllowedAceExSpec)(PACL, DWORD, DWORD, DWORD, PSID);
typedef WINUSERAPI BOOL (WINAPI *pfnInitializeSecurityDescriptorSpec)(PSECURITY_DESCRIPTOR, DWORD);
typedef WINUSERAPI BOOL (WINAPI *pfnSetSecurityDescriptorDaclSpec)(PSECURITY_DESCRIPTOR, BOOL, PACL, BOOL);
typedef WINUSERAPI BOOL (WINAPI *pfnSetSecurityDescriptorOwnerSpec)(PSECURITY_DESCRIPTOR, PSID, BOOL);
typedef WINUSERAPI BOOL (WINAPI *pfnSetSecurityDescriptorGroupSpec)(PSECURITY_DESCRIPTOR, PSID, BOOL);
typedef WINUSERAPI BOOL (WINAPI *pfnGetSecurityDescriptorDaclSpec)(PSECURITY_DESCRIPTOR, LPBOOL, PACL*, LPBOOL);
typedef WINUSERAPI DWORD (WINAPI *pfnSetNamedSecurityInfoSpec)(TCHAR*, SE_OBJECT_TYPE, SECURITY_INFORMATION, PSID, PSID, PACL, PACL);

typedef struct _AdvapiLinkageStruct {
	HMODULE hAdvapi32;
	union {
		struct {
            pfnGetSidLengthRequiredSpec pfnGetSidLengthRequired;
            pfnInitializeSidSpec pfnInitializeSid;
            pfnGetSidSubAuthoritySpec pfnGetSidSubAuthority;
            pfnInitializeAclSpec pfnInitializeAcl;
            pfnAddAccessAllowedAceExSpec pfnAddAccessAllowedAceEx;
            pfnInitializeSecurityDescriptorSpec pfnInitializeSecurityDescriptor;
            pfnSetSecurityDescriptorDaclSpec pfnSetSecurityDescriptorDacl;
            pfnSetSecurityDescriptorOwnerSpec pfnSetSecurityDescriptorOwner;
            pfnSetSecurityDescriptorGroupSpec pfnSetSecurityDescriptorGroup;
            pfnGetSecurityDescriptorDaclSpec pfnGetSecurityDescriptorDacl;
            pfnSetNamedSecurityInfoSpec pfnSetNamedSecurityInfo;
		};
		void *apvPfnAdvapi32[12];  
	};
} AdvapiLinkageStruct;

BOOL LinkToAdavapi32(AdvapiLinkageStruct* pAdvapiLink);
void UnlinkFromAdvapi32(AdvapiLinkageStruct* pAdvapiLink);
DWORD AllocateSecurityDescriptorAllowAccessToWorld(PSECURITY_DESCRIPTOR *ppSd, AdvapiLinkageStruct* pAdvapiLink);
BOOL AllowAccessToWorld(LPTSTR pszDirOrFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cfilename.h ===
//+----------------------------------------------------------------------------
//
// File:     cfilename.h
//
// Module:   CMUTIL.DLL
//
// Synopsis: Definition of the CFileNameParts class.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------
#ifndef _CFILENAMEPARTS_H_
#define _CFILENAMEPARTS_H_

#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include "cmdebug.h"

class CFileNameParts
{

public:

CFileNameParts(LPCTSTR szFullPath);
~CFileNameParts() {}

public: // Public member variables use them directly
   TCHAR m_szFullPath[MAX_PATH+1];

   TCHAR m_Drive[_MAX_DRIVE+1];
   TCHAR m_Dir[_MAX_DIR+1];
   TCHAR m_FileName[_MAX_FNAME+1];
   TCHAR m_Extension[_MAX_EXT+1];


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\bmpimage.h ===
//+----------------------------------------------------------------------------
//
// File:     bmpimage.h
//
// Module:   CMAK.EXE and CMDIAL32.DLL
//
// Synopsis: Definition of the CM Bitmap display routines.
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   quintinb/nickball      Created      08/06/98
//
//+----------------------------------------------------------------------------
#ifndef _BMP_IMAGE_H
#define _BMP_IMAGE_H

#include <windows.h>

#include "cmutil.h"
#include "cmdebug.h"

typedef struct tagBmpData
{
	HBITMAP hDIBitmap;	        // bitmap, in device-independent format
	HBITMAP hDDBitmap;		    // bitmap, in device-dependent format
	LPBITMAPINFO pBmi;          // bitmap info for the bitmap, the raw bits
    HPALETTE *phMasterPalette;	// Master Palette, used when displaying any bitmap
    BOOL bForceBackground;      // determines background/foreground mode
} BMPDATA, *LPBMPDATA;


LPBITMAPINFO CmGetBitmapInfo(HBITMAP hbm);
static HPALETTE CmCreateDIBPalette(LPBITMAPINFO pbmi);
void ReleaseBitmapData(LPBMPDATA pBmpData);
BOOL CreateBitmapData(HBITMAP hDIBmp, LPBMPDATA lpBmpData, HWND hwnd, BOOL fCustomPalette);
LRESULT CALLBACK BmpWndProc(HWND hwndBmp, UINT uMsg, WPARAM wParam, LPARAM lParam);
void QueryNewPalette(LPBMPDATA lpBmpData, HWND hwndDlg, int iBmpCtrl);
void PaletteChanged(LPBMPDATA lpBmpData, HWND hwndDlg, int iBmpCtrl);
HBITMAP CmLoadBitmap(HINSTANCE hInst, LPCTSTR pszSpec);


#endif // _BMP_IMAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cfgapi.h ===
//*******************************************************************
//
//  Copyright (c) 1996-1998 Microsoft Corporation
//
//  FILE: CFGAPI.H
//
//  PURPOSE:  Contains API's exported from icfg32.dll and structures
//            required by those functions.
//
//*******************************************************************

#ifndef _CFGAPI_H_
#define _CFGAPI_H_

// Maximum buffer size for error messages.
#define MAX_ERROR_TEXT  512

// Flags for dwfOptions

// install TCP (if needed)
#define ICFG_INSTALLTCP            0x00000001

// install RAS (if needed)
#define ICFG_INSTALLRAS            0x00000002

// install exchange and internet mail
#define ICFG_INSTALLMAIL           0x00000004

//
// ChrisK 5/8/97
// Note: the next three switches are only valid for IcfgNeedInetComponet
// check to see if a LAN adapter with TCP bound is installed
//
#define ICFG_INSTALLLAN            0x00000008

//
// Check to see if a DIALUP adapter with TCP bound is installed
//
#define ICFG_INSTALLDIALUP         0x00000010

//
// Check to see if TCP is installed
//
#define ICFG_INSTALLTCPONLY        0x00000020

// DRIVERTYPE_ defines for TCP/IP configuration apis
#define DRIVERTYPE_NET  0x0001
#define DRIVERTYPE_PPP  0x0002


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//*******************************************************************
//
//  FUNCTION:   IcfgNeedInetComponents
//
//  PURPOSE:    Detects whether the specified system components are
//              installed or not.
//
//  PARAMETERS: dwfOptions - a combination of ICFG_ flags that specify
//              which components to detect as follows:
//
//                ICFG_INSTALLTCP - is TCP/IP needed?
//                ICFG_INSTALLRAS - is RAS needed?
//                ICFG_INSTALLMAIL - is exchange or internet mail needed?
//
//              lpfNeedComponents - TRUE if any specified component needs
//              to be installed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT IcfgNeedInetComponents(DWORD dwfOptions, LPBOOL lpfNeedComponents);
HRESULT IcfgNeedInetComponentsNT4(DWORD dwfOptions, LPBOOL lpfNeedComponents);
HRESULT IcfgNeedInetComponentsNT5(DWORD dwfOptions, LPBOOL lpfNeedComponents);


//*******************************************************************
//
//  FUNCTION:   IcfgInstallInetComponents
//
//  PURPOSE:    Install the specified system components.
//
//  PARAMETERS: hwndParent - Parent window handle.
//              dwfOptions - a combination of ICFG_ flags that controls
//              the installation and configuration as follows:
//
//                ICFG_INSTALLTCP - install TCP/IP (if needed)
//                ICFG_INSTALLRAS - install RAS (if needed)
//                ICFG_INSTALLMAIL - install exchange and internet mail
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT IcfgInstallInetComponents(HWND hwndParent, DWORD dwfOptions,
  LPBOOL lpfNeedsRestart);
HRESULT IcfgInstallInetComponentsNT4(HWND hwndParent, DWORD dwfOptions,
  LPBOOL lpfNeedsRestart);
HRESULT IcfgInstallInetComponentsNT5(HWND hwndParent, DWORD dwfOptions,
  LPBOOL lpfNeedsRestart);


//+----------------------------------------------------------------------------
//
//	Function:	IcfgNeedModem
//
//	Synopsis:	Check system configuration to determine if there is at least
//				one physical modem installed
//
//	Arguments:	dwfOptions - currently not used
//
//	Returns:	HRESULT - S_OK if successfull
//				lpfNeedModem - TRUE if no modems are available
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
HRESULT IcfgNeedModem(DWORD dwfOptions, LPBOOL lpfNeedModem);
HRESULT IcfgNeedModemNT4(DWORD dwfOptions, LPBOOL lpfNeedModem) ;
HRESULT IcfgNeedModemNT5(DWORD dwfOptions, LPBOOL lpfNeedModem) ;



//+----------------------------------------------------------------------------
//
//	Function:	IcfgNeedModem
//
//	Synopsis:	Check system configuration to determine if there is at least
//				one physical modem installed
//
//	Arguments:	dwfOptions - currently not used
//
//	Returns:	HRESULT - S_OK if successfull
//				lpfNeedModem - TRUE if no modems are available
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
HRESULT IcfgInstallModem (HWND hwndParent, DWORD dwfOptions, 
							LPBOOL lpfNeedsStart);
HRESULT IcfgInstallModemNT4 (HWND hwndParent, DWORD dwfOptions, 
							LPBOOL lpfNeedsStart);
HRESULT IcfgInstallModemNT5 (HWND hwndParent, DWORD dwfOptions, 
							LPBOOL lpfNeedsStart);




//*******************************************************************
//
//  FUNCTION:   IcfgGetLastInstallErrorText
//
//  PURPOSE:    Get a text string that describes the last installation
//              error that occurred.  The string should be suitable
//              for display in a message box with no further formatting.
//
//  PARAMETERS: lpszErrorDesc - points to buffer to receive the string.
//              cbErrorDesc - size of buffer.
//
//  RETURNS:    The length of the string returned.
//
//*******************************************************************

DWORD IcfgGetLastInstallErrorText(LPSTR lpszErrorDesc, DWORD cbErrorDesc);


//*******************************************************************
//
//  FUNCTION:   IcfgSetInstallSourcePath
//
//  PURPOSE:    Sets the path where windows looks when installing files.
//
//  PARAMETERS: lpszSourcePath - full path of location of files to install.
//              If this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT IcfgSetInstallSourcePath(LPCSTR lpszSourcePath);


//*******************************************************************
//
//  FUNCTION:   IcfgIsGlobalDNS
//
//  PURPOSE:    Determines whether there is Global DNS set.
//
//  PARAMETERS: lpfGlobalDNS - TRUE if global DNS is set, FALSE otherwise.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and
//              should always return ERROR_SUCCESS and set lpfGlobalDNS
//              to FALSE in Windows NT.
//
//*******************************************************************

HRESULT IcfgIsGlobalDNS(LPBOOL lpfGlobalDNS);


//*******************************************************************
//
//  FUNCTION:   IcfgRemoveGlobalDNS
//
//  PURPOSE:    Removes global DNS info from registry.
//
//  PARAMETERS: None.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and
//              should always return ERROR_SUCCESS in Windows NT.
//
//*******************************************************************

HRESULT IcfgRemoveGlobalDNS(void);


//*******************************************************************
//
//  FUNCTION:   IcfgIsFileSharingTurnedOn
//
//  PURPOSE:    Determines if file server (VSERVER) is bound to TCP/IP
//              for specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to check server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP        - PPPMAC
//
//              lpfSharingOn - TRUE if bound once or more, FALSE if not bound
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT IcfgIsFileSharingTurnedOn(DWORD dwfDriverType, LPBOOL lpfSharingOn);


//*******************************************************************
//
//  FUNCTION:   IcfgTurnOffFileSharing
//
//  PURPOSE:    Unbinds file server (VSERVER) from TCP/IP for
//              specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to remove server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP        - PPPMAC
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT IcfgTurnOffFileSharing(DWORD dwfDriverType, HWND hwndParent);
VOID   GetSETUPXErrorText(DWORD dwErr,LPSTR pszErrorDesc,DWORD cbErrorDesc);
UINT DoGenInstall(HWND hwndParent,LPCSTR lpszInfFile,LPCSTR lpszInfSect);

//*******************************************************************
//*******************************************************************

HRESULT InetSetAutodial(BOOL fEnable, LPCSTR lpszEntryName);

//*******************************************************************
//*******************************************************************

HRESULT InetGetAutodial(LPBOOL lpfEnable, LPSTR lpszEntryName,
                        DWORD cbEntryName);

//*******************************************************************
//*******************************************************************

HRESULT InetSetAutodialAddress();

//*******************************************************************
//*******************************************************************

HRESULT InetGetSupportedPlatform(LPDWORD pdwPlatform);

//*******************************************************************
//*******************************************************************

HRESULT IcfgStartServices();

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //_CFGAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmdebug.h ===
//+----------------------------------------------------------------------------
//
// File:     cmdebug.h
//
// Module:   CMDEBUG.LIB
//
// Synopsis: Header file for Internal CM Debugging functions.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header     08/19/99
//
//+----------------------------------------------------------------------------
#ifndef CMDEBUG_H
#define CMDEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

//
// Macros for debugging support.
//
// MYDBGASSERT(x): If (!x) Assert MessageBox which has three option:
//                         Abort to end the application,
//                         Ignore to continue,
//                         Retry to debug
// 
// CMASSERTMSG(exp, msg)  Similar to MYDBGASSERT.  Except the msg is displayed instead of expression
//
// Use CMTRACE(x) for output, where x is a list of printf()-style parameters.  
//     CMTRACEn() is TRACE with n printf arguments
//     For example, CMTRACE2(("This shows how to print stuff, like a string %s, and a number %u.","string",5));
//
// MYDBG is obsolete and equivalent to CMTRACE
//
// Use MYDBGTST(y,x) to output x if y is TRUE.  For example,
//      MYDBGTST(1,("This always prints"));
//
// Use MYDBGSTR(x) for safe-printing of string pointers.  For example,
//      MYDBG(("This would normally, fault - %s.",MYDBGSTR(NULL)));
//
// USE MYVERIFY for expressions executed for both debug and release version

#ifdef DEBUG

    void MyDbgPrintfA(const char *pszFmt, ...);
    void MyDbgPrintfW(const WCHAR *pszFmt, ...);
    void MyDbgAssertA(const char *pszFile, unsigned nLine, const char *pszMsg);
    void MyDbgAssertW(const char *pszFile, unsigned nLine, WCHAR *pszMsg);
    void InvertPercentSAndPercentC(LPSTR pszFormat);
    int WINAPI wvsprintfWtoAWrapper(OUT LPSTR pszAnsiOut, IN LPCWSTR pszwFmt, IN va_list arglist);

    #define MYDBGASSERTA(x)     (void)((x) || (MyDbgAssertA(__FILE__,__LINE__,#x),0))
    #define MYDBGASSERTW(x)     (void)((x) || (MyDbgAssertW(__FILE__,__LINE__,L#x),0))

    #define MYVERIFYA(x) MYDBGASSERTA(x)
    #define MYVERIFYW(x) MYDBGASSERTW(x)

    #define MYDBGTSTA(y,x)      if (y) MyDbgPrintfA x
    #define MYDBGTSTW(y,x)      if (y) MyDbgPrintfW x


    // {MYDBGASSERT(pObj);pObj->AssertValid();} 
    #define ASSERT_VALID(pObj) ((MYDBGASSERT(pObj),1) && ((pObj)->AssertValid(),1))

    #define MYDBGA(x)           MyDbgPrintfA x
    #define MYDBGW(x)           MyDbgPrintfW x

    #define MYDBGSTRA(x)        ((x)?(x):"(null)")
    #define MYDBGSTRW(x)        ((x)?(x):L"(null)")

    #define CMASSERTMSGA(exp, msg)   (void)((exp) || (MyDbgAssertA(__FILE__,__LINE__,msg),0))
    #define CMASSERTMSGW(exp, msg)   (void)((exp) || (MyDbgAssertW(__FILE__,__LINE__,msg),0))

    #define CMTRACEA(pszFmt)                    MyDbgPrintfA(pszFmt)
    #define CMTRACEW(pszFmt)                    MyDbgPrintfW(pszFmt)

    #define CMTRACEHRA(pszFile, hr)             if (S_OK != hr) MyDbgPrintfA("%s: returns error %x", pszFile, (hr));
    #define CMTRACEHRW(pszFile, hr)             if (S_OK != hr) MyDbgPrintfW(L"%s: returns error %x", pszFile, (hr));

    #define CMTRACE1A(pszFmt, arg1)             MyDbgPrintfA(pszFmt, arg1)
    #define CMTRACE1W(pszFmt, arg1)             MyDbgPrintfW(pszFmt, arg1)

    #define CMTRACE2A(pszFmt, arg1, arg2)       MyDbgPrintfA(pszFmt, arg1, arg2)
    #define CMTRACE2W(pszFmt, arg1, arg2)       MyDbgPrintfW(pszFmt, arg1, arg2)

    #define CMTRACE3A(pszFmt, arg1, arg2, arg3) MyDbgPrintfA(pszFmt, arg1, arg2, arg3)
    #define CMTRACE3W(pszFmt, arg1, arg2, arg3) MyDbgPrintfW(pszFmt, arg1, arg2, arg3)

    #ifdef UNICODE
        #define MyDbgPrintf MyDbgPrintfW        
        #define MyDbgAssert MyDbgAssertW        
        #define MYDBGTST(y,x) MYDBGTSTW(y,x)
        #define MYDBG(x) MYDBGW(x)
        #define MYDBGSTR(x) MYDBGSTRW(x)
        #define CMASSERTMSG(exp, msg) CMASSERTMSGW(exp, msg)
        #define CMTRACE(pszFmt) CMTRACEW(pszFmt)
        #define CMTRACEHR(pszFile, hr) CMTRACEHRW(pszFile, hr)
        #define CMTRACE1(pszFmt, arg1) CMTRACE1W(pszFmt, arg1)
        #define CMTRACE2(pszFmt, arg1, arg2) CMTRACE2W(pszFmt, arg1, arg2)
        #define CMTRACE3(pszFmt, arg1, arg2, arg3) CMTRACE3W(pszFmt, arg1, arg2, arg3)
        #define MYDBGASSERT MYDBGASSERTW
        #define MYVERIFY MYVERIFYW
    #else
        #define MyDbgPrintf MyDbgPrintfA
        #define MyDbgAssert MyDbgAssertA
        #define MYDBGTST(y,x) MYDBGTSTA(y,x)
        #define MYDBG(x) MYDBGA(x)
        #define MYDBGSTR(x) MYDBGSTRA(x)
        #define CMASSERTMSG(exp, msg) CMASSERTMSGA(exp, msg)
        #define CMTRACE(pszFmt) CMTRACEA(pszFmt)
        #define CMTRACEHR(pszFile, hr) CMTRACEHRA(pszFile, hr)
        #define CMTRACE1(pszFmt, arg1) CMTRACE1A(pszFmt, arg1)
        #define CMTRACE2(pszFmt, arg1, arg2) CMTRACE2A(pszFmt, arg1, arg2)
        #define CMTRACE3(pszFmt, arg1, arg2, arg3) CMTRACE3A(pszFmt, arg1, arg2, arg3)
        #define MYDBGASSERT MYDBGASSERTA
        #define MYVERIFY MYVERIFYA
    #endif

#else // DEBUG

    #define ASSERT_VALID(pObj) 

    #define MYDBG(x)
    #define MYDBGTST(y,x)
    #define MYDBGSTR(x)
    #define MYDBGASSERT(x)

    #define CMASSERTMSG(exp, msg)
    #define MYVERIFY(x) ((VOID)(x))
    #define CMTRACE(pszFmt)
    #define CMTRACEHR(pszFile, hr)
    #define CMTRACE1(pszFmt, arg1)             
    #define CMTRACE2(pszFmt, arg1, arg2)       
    #define CMTRACE3(pszFmt, arg1, arg2, arg3)

    #define MYDBGASSERTA(x)
    #define MYDBGASSERTW(x)

    #define MYVERIFYA(x)
    #define MYVERIFYW(x)

    #define MYDBGTSTA(y,x)
    #define MYDBGTSTW(y,x)

    #define ASSERT_VALID(pObj)

    #define MYDBGA(x)
    #define MYDBGW(x)

    #define MYDBGSTRA(x)
    #define MYDBGSTRW(x)

    #define CMASSERTMSGA(exp, msg)
    #define CMASSERTMSGW(exp, msg)

    #define CMTRACEA(pszFmt)
    #define CMTRACEW(pszFmt)

    #define CMTRACEHRA(pszFile, hr)
    #define CMTRACEHRW(pszFile, hr)

    #define CMTRACE1A(pszFmt, arg1)
    #define CMTRACE1W(pszFmt, arg1)

    #define CMTRACE2A(pszFmt, arg1, arg2)
    #define CMTRACE2W(pszFmt, arg1, arg2)

    #define CMTRACE3A(pszFmt, arg1, arg2, arg3)
    #define CMTRACE3W(pszFmt, arg1, arg2, arg3)
    
#endif // DEBUG

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmakver.h ===
//+----------------------------------------------------------------------------
//
// File:     cmakver.h
//
// Module:   CMSETUP.LIB
//
// Synopsis: Definition of the CmakVersion class.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created     09/14/98
//
//+----------------------------------------------------------------------------

#ifndef __CMAKVER_H
#define __CMAKVER_H

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include "pnpuverp.h"

const int c_Cmak10Version = 613;
const int c_Cmak121Version = 1886;
const int c_CmakUnicodeAware = 2050;
const int c_Win2kRTMBuildNumber = 2195;

const DWORD c_dwCurrentCmakVersionNumber = ((HIBYTE(VER_PRODUCTVERSION_W) << c_iShiftAmount) + (LOBYTE(VER_PRODUCTVERSION_W)));
const DWORD c_dwVersionSevenPointOne = (7 << c_iShiftAmount) + 1;
const DWORD c_dwVersionSeven = (7 << c_iShiftAmount);
const DWORD c_dwVersionSix = (6 << c_iShiftAmount);
const DWORD c_dwCmak10BuildNumber = (c_Cmak10Version << c_iShiftAmount);
const DWORD c_dwFirst121BuildNumber = ((c_Cmak121Version << c_iShiftAmount) + VER_PRODUCTBUILD_QFE);
const DWORD c_dwFirstUnicodeBuildNumber = ((c_CmakUnicodeAware << c_iShiftAmount) + VER_PRODUCTBUILD_QFE);
const DWORD c_dwWin2kRTMBuildNumber = ((c_Win2kRTMBuildNumber << c_iShiftAmount) + VER_PRODUCTBUILD_QFE);

class CmakVersion : public CVersion
{
public:	//	Public Methods
	CmakVersion();
	~CmakVersion();
	BOOL GetInstallLocation	(LPTSTR szStr);
	BOOL Is10Cmak();
	BOOL Is11or12Cmak();
	BOOL Is121Cmak();    
    BOOL Is122Cmak();
    BOOL Is13Cmak();
    DWORD GetNativeCmakLCID();

private:	//	Member Variables

    //
    // this actually contains the install location path, C:\program files\cmak\cmak.exe
    //
    TCHAR m_szCmakPath[MAX_PATH+1];	
};

#endif	// __CMAKVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmdial.h ===
//+----------------------------------------------------------------------------
//
// File:     cmdial.h
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Header file for Private CM APIs
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   nickball   Created     02/05/98
//
//+----------------------------------------------------------------------------
#ifndef _CMDIAL_INC_
#define _CMDIAL_INC_

//
// Type definitions
//

typedef struct CmDialInfo
{
//    WCHAR szPassword[PWLEN + 1];        // Primary/Tunnel Password used for connection
//    WCHAR szInetPassword[PWLEN + 1];    // Secondary/ISP password used for connection
    DWORD dwCmFlags;
} CMDIALINFO, * LPCMDIALINFO;

//+----------------------------------------------------------------------------
//
// Function: CmCustomDialDlg
//
// Synopsis:  Our CM specific variation on RasCustomDialDlg.  
//
// Arguments: HWND          hwndParent - The HWND of the parent window.
//            DWORD         dwFlags - Dial flags
//            LPTSTR        lpszPhonebook - Ptr to the full path and filename of the phonebook.
//            LPTSTR        lpszEntry - Ptr to the name of the phone-book entry to dial.
//            LPTSTR        lpszPhoneNumber - Ptr to replacement phone number
//            LPRASDIALDLG  lpRasDialDlg - Ptr to structure for additional RAS parameters 
//            LPRASENTRYDLG lpRasEntryDlg -- Ptr to structure for additional RAS parameters 
//            LPCMDIALINFO  lpCmInfo - Ptr to structure containing CM dial info such as flags.
//            LPVOID lpv    lpv - Ptr to blob passed by RAS during WinLogon on W2K.
//
// Returns:   BOOL WINAPI - TRUE on success
//
//+----------------------------------------------------------------------------
extern "C" BOOL WINAPI CmCustomDialDlg(HWND hwndParent, 
    DWORD dwFlags, 
    LPWSTR lpszPhonebook, 
    LPCWSTR lpszEntry, 
    LPWSTR lpszPhoneNumber, 
    LPRASDIALDLG lpRasDialDlg,
    LPRASENTRYDLGW lpRasEntryDlg,
    LPCMDIALINFO lpCmInfo,
    LPVOID lpvLogonBlob=NULL);

//+----------------------------------------------------------------------------
//
// Function:  CmCustomHangUp
//
// Synopsis:  Our CM specific variation on RasCustomHangUp. Optionally, the entry
//            name may be given instead of the RAS handle.
//
// Arguments: HRASCONN hRasConn - The handle of the connection to be terminated.
//            LPCTSTR pszEntry - Ptr to the name of the entry to be terminated.
//            BOOL fPersist - Preserve the entry and its usage count.
//
// Returns:   DWORD WINAPI - Return code
//
//+----------------------------------------------------------------------------
extern "C" DWORD WINAPI CmCustomHangUp(HRASCONN hRasConn, 
    LPCWSTR pszEntry,
    BOOL fIgnoreRefCount,
    BOOL fPersist);

//+----------------------------------------------------------------------------
//
// Function:  CmReConnect
//
// Synopsis:  Used specificly for CMMON to call upon reconnect
//
// Arguments: LPTSTR        lpszPhonebook - Ptr to the full path and filename of the phonebook.
//            LPTSTR        lpszEntry - Ptr to the name of the phone-book entry to dial.
//            LPCMDIALINFO lpCmInfo - The reconnect information
//
// Returns:   DWORD WINAPI - Return code
//
//+----------------------------------------------------------------------------
extern "C"  
BOOL CmReConnect(    LPTSTR lpszPhonebook, 
    LPWSTR lpszEntry, 
    LPCMDIALINFO lpCmInfo);

#endif _CMDIAL_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cini.h ===
//+----------------------------------------------------------------------------
//
// File:     cini.h
//
// Module:   CMUTIL.DLL
//
// Synopsis: Definition of the CINIA and CINIW classes
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------
#ifndef _CM_INI_INC
#define _CM_INI_INC


#ifdef UNICODE
    #define CIni CIniW
#else
    #define CIni CIniA
#endif

//
//  Ansi Version
//
class CMUTILAPI_CLASS CIniA {
    public:
        CIniA(HINSTANCE hInst=NULL, LPCSTR pszFile=NULL, LPCSTR pszRegPath = NULL, LPCSTR pszSection=NULL, LPCSTR pszEntry=NULL);
        ~CIniA();
        void Clear();
        void SetHInst(HINSTANCE hInst);
        void SetFile(LPCSTR pszFile);
        void SetEntry(LPCSTR pszEntry);
        void SetEntryFromIdx(DWORD dwEntry);
        void SetPrimaryFile(LPCSTR pszFile);
        void SetSection(LPCSTR pszSection);
        void SetRegPath(LPCSTR pszRegPath);
        void SetPrimaryRegPath(LPCSTR pszPrimaryRegPath);
        void SetICSDataPath(LPCSTR pszICSPath);
        void SetReadICSData(BOOL fValue);
        void SetWriteICSData(BOOL fValue);

        HINSTANCE GetHInst() const;
        LPCSTR GetFile() const;
        LPCSTR GetPrimaryFile() const;
        LPCSTR GetRegPath() const;
        LPCSTR GetPrimaryRegPath() const;

        LPSTR GPPS(LPCSTR pszSection, LPCSTR pszEntry, LPCSTR pszDefault=NULL) const;
        DWORD GPPI(LPCSTR pszSection, LPCSTR pszEntry, DWORD dwDefault=0) const;
        BOOL GPPB(LPCSTR pszSection, LPCSTR pszEntry, BOOL bDefault=0) const;

        void WPPS(LPCSTR pszSection, LPCSTR pszEntry, LPCSTR pszBuffer);
        void WPPI(LPCSTR pszSection, LPCSTR pszEntry, DWORD dwBuffer);
        void WPPB(LPCSTR pszSection, LPCSTR pszEntry, BOOL bBuffer);

        LPSTR LoadSection(LPCSTR pszSection) const;
        LPCSTR GetSection() const;

    protected:

        LPSTR LoadEntry(LPCSTR pszEntry) const;
        static void CIni_SetFile(LPSTR *ppszDest, LPCSTR pszSrc);
        BOOL CIniA_DeleteEntryFromReg(HKEY hKey, LPCSTR pszRegPathTmp, LPCSTR pszEntry) const;
        LPBYTE CIniA_GetEntryFromReg(HKEY hKey, LPCSTR pszRegPathTmp, LPCSTR pszEntry, DWORD dwType, DWORD dwSize) const;
        BOOL CIniA_WriteEntryToReg(HKEY hKey, LPCSTR pszRegPathTmp, LPCSTR pszEntry, CONST BYTE *lpData, DWORD dwType, DWORD dwSize) const;

    private:
        HINSTANCE m_hInst;
        LPSTR m_pszFile;
        LPSTR m_pszSection;
        LPSTR m_pszEntry;
        LPSTR m_pszPrimaryFile;
        LPTSTR m_pszRegPath;
        LPTSTR m_pszPrimaryRegPath;
        LPTSTR m_pszICSDataPath;
        BOOL m_fReadICSData;
        BOOL m_fWriteICSData;
};


//
//  UNICODE Version
//
class CMUTILAPI_CLASS CIniW {
    public:

        CIniW(HINSTANCE hInst=NULL, LPCWSTR pszFile=NULL, LPCWSTR pszRegPath = NULL, LPCWSTR pszSection=NULL, LPCWSTR pszEntry=NULL);
        ~CIniW();
        void Clear();
        void SetHInst(HINSTANCE hInst);
        void SetFile(LPCWSTR pszFile);
        void SetEntry(LPCWSTR pszEntry);
        void SetEntryFromIdx(DWORD dwEntry);
        void SetPrimaryFile(LPCWSTR pszFile);
        void SetSection(LPCWSTR pszSection);
        void SetRegPath(LPCWSTR pszRegPath);
        void SetPrimaryRegPath(LPCWSTR pszRegPath);
        void SetICSDataPath(LPCWSTR pszICSPath);
        void SetReadICSData(BOOL fValue);
        void SetWriteICSData(BOOL fValue);

        HINSTANCE GetHInst() const;
        LPCWSTR GetFile() const;
        LPCWSTR GetPrimaryFile() const;
        LPCWSTR GetRegPath() const;
        LPCWSTR GetPrimaryRegPath() const;

        LPWSTR GPPS(LPCWSTR pszSection, LPCWSTR pszEntry, LPCWSTR pszDefault=NULL) const;
        DWORD GPPI(LPCWSTR pszSection, LPCWSTR pszEntry, DWORD dwDefault=0) const;
        BOOL GPPB(LPCWSTR pszSection, LPCWSTR pszEntry, BOOL bDefault=0) const;

        void WPPS(LPCWSTR pszSection, LPCWSTR pszEntry, LPCWSTR pszBuffer);
        void WPPI(LPCWSTR pszSection, LPCWSTR pszEntry, DWORD dwBuffer);
        void WPPB(LPCWSTR pszSection, LPCWSTR pszEntry, BOOL bBuffer);
        LPWSTR LoadSection(UINT nSection) const;
        LPWSTR LoadSection(LPCWSTR pszSection) const;
        LPCWSTR GetSection() const;
        
	protected:

        LPWSTR LoadEntry(LPCWSTR pszEntry) const;
        static void CIni_SetFile(LPWSTR *ppszDest, LPCWSTR pszSrc);
        BOOL CIniW_DeleteEntryFromReg(HKEY hKey, LPCWSTR pszRegPathTmp, LPCWSTR pszEntry) const;
        LPBYTE CIniW_GetEntryFromReg(HKEY hKey, LPCWSTR pszRegPathTmp, LPCWSTR pszEntry, DWORD dwType, DWORD dwSize) const;
        BOOL CIniW_WriteEntryToReg(HKEY hKey, LPCWSTR pszRegPathTmp, LPCWSTR pszEntry, CONST BYTE *lpData, DWORD dwType, DWORD dwSize) const;

    private:

        HINSTANCE m_hInst;
        LPWSTR m_pszFile;
        LPWSTR m_pszSection;
        LPWSTR m_pszEntry;
        LPWSTR m_pszPrimaryFile;
        LPWSTR m_pszRegPath;
        LPWSTR m_pszPrimaryRegPath;
        LPWSTR m_pszICSDataPath;
        BOOL m_fReadICSData;
        BOOL m_fWriteICSData;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmglobal.h ===
//+----------------------------------------------------------------------------
//
// File:     cmglobal.h
//
// Module:   CMDIAL32.DLL and CMSETUP.LIB
//
// Synopsis: Definitions global to all of CM.
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball   Created      07/10/97
//
//+----------------------------------------------------------------------------

#ifndef _CM_GLOBAL
#define _CM_GLOBAL

//
// Here is the Profile Version Number.  This number is used in cmak, cmstp, and
// in CM itself.  If you change this number, you must also update it in the template.inf,
// template.pmc (cmp), and the template.smc (cms).
//

const DWORD PROFILEVERSION = 4;

#endif // _CM_GLOBAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmplat.h ===
//+----------------------------------------------------------------------------
//
// File:     cmplat.h
//
// Module:   CMSETUP.LIB
//
// Synopsis: Definition of the CPlatform class.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header     08/19/99
//
//+----------------------------------------------------------------------------

#ifndef __CMPLAT_H
#define __CMPLAT_H

#include <windows.h>

//________________________________________________________________________________
//
// Class:  CPlatform
//
// Synopsis:  .instantiate one of these then query it with any of the member
//              functions.
//              
//          Public Interface Include :
//              IsX86();
//              IsAlpha();
//              IsWin95();
//              IsWin98();
//              IsWin9x();
//              IsNT31();
//              IsNT351();
//              IsNT4();
//              IsNT5();
//              IsNT();
// Notes: m_ClassState enum is very valuable. All new functions should make use of it.
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________


class CPlatform
{
public:
    enum e_ClassState{good,bad};
    CPlatform();
    BOOL    IsX86();
    BOOL    IsAlpha();
    BOOL    IsIA64();
    BOOL    IsWin95Gold();  // only build 950
    BOOL    IsWin95();  // any win95 build up one before the memphis builds
    BOOL    IsWin98Gold();
    BOOL    IsWin98Sr();
    BOOL    IsWin98();
    BOOL    IsWin9x();
    BOOL    IsNT31();
    BOOL    IsNT351();
    BOOL    IsNT4();
    BOOL    IsNT5();
    BOOL    IsNT51();
    BOOL    IsAtLeastNT5();
    BOOL    IsAtLeastNT51();
    BOOL    IsNT();
    BOOL    IsNTSrv();
    BOOL    IsNTWks();
private:
    DWORD   ServicePack(int spNum){return 0;};  //Not implemented
    BOOL                IsOS(DWORD OS, DWORD buildNum);
    BOOL                IsOSExact(DWORD OS, DWORD buildNum);
    SYSTEM_INFO         m_SysInfo;
    OSVERSIONINFO       m_OSVer; 
    e_ClassState        m_ClassState;
};

#endif  // __CMPLAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmprdver.h ===
//+----------------------------------------------------------------------------
//
// File:     cmprdver.h
//
// Module:   All CM Resource Scripts
//
// Synopsis: This file contains the Product Name description string for CM
//           components.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb   Created Header     08/19/99
//
//+----------------------------------------------------------------------------
#undef VER_PRODUCTNAME_STR
#define VER_PRODUCTNAME_STR		"Microsoft(R) Connection Manager"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmlog.h ===
//+----------------------------------------------------------------------------
//
// File:    cmlog.h
//
// Module:  cmutil.dll, cmdial32.dll etc
//
// Synopsis: Connection Manager Logging
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  04-May-2000 SumitC  Created
//
//-----------------------------------------------------------------------------

#ifdef CMLOG_IMPLEMENTATION
    #define CMLOG_CLASS __declspec(dllexport)
#else
    #define CMLOG_CLASS __declspec(dllimport)
#endif

// the following values follow the defaults for RAS/PPP logging (using rtutils.dll)
//
const BOOL    c_fEnableLogging        = TRUE;
const DWORD   c_dwMaxFileSize         = 0x64;           // 100K = 102,400 bytes
const LPTSTR  c_szLogFileDirectory    = TEXT("%Temp%");

//
//  #define constants
//
#define BYTE_ORDER_MARK 0xFEFF

//
//  List of CM/CPS events that can be logged
//

//
//  NOTE that this list must correspond with the s_aCmLogItems array in cmlog.cpp
//

enum _CMLOG_ITEM
{
    UNKNOWN_LOG_ITEM,       // guard item.  DO NOT USE WHEN CALLING CMLOG() !!
    LOGGING_ENABLED_EVENT,
    LOGGING_DISABLED_EVENT,
    PREINIT_EVENT,
    PRECONNECT_EVENT,
    PREDIAL_EVENT,
    PRETUNNEL_EVENT,
    CONNECT_EVENT,
    CUSTOMACTIONDLL,
    CUSTOMACTIONEXE,
    CUSTOMACTION_NOT_ALLOWED,
    CUSTOMACTION_WONT_RUN,
    CUSTOMACTION_SKIPPED,
    DISCONNECT_EVENT,
    RECONNECT_EVENT,
    RETRY_AUTH_EVENT,
    CALLBACK_NUMBER_EVENT,
    PASSWORD_EXPIRED_EVENT,
    PASSWORD_RESET_EVENT,
    CUSTOM_BUTTON_EVENT,
    ONCANCEL_EVENT,
    ONERROR_EVENT,
    CLEAR_LOG_EVENT,

    DISCONNECT_EXT,
    DISCONNECT_INT_MANUAL,
    DISCONNECT_INT_AUTO,
    DISCONNECT_EXT_LOST_CONN,

    PB_DOWNLOAD_SUCCESS,
    PB_DOWNLOAD_FAILURE,
    PB_UPDATE_SUCCESS,
    PB_UPDATE_FAILURE_PBS,
    PB_UPDATE_FAILURE_CMPBK,
    PB_ABORTED,
    VPN_DOWNLOAD_SUCCESS,
    VPN_DOWNLOAD_FAILURE,
    VPN_UPDATE_SUCCESS,
    VPN_UPDATE_FAILURE,
    ONERROR_EVENT_W_SAFENET,
    SN_ADAPTER_CHANGE_EVENT,

    USER_FORMATTED = 99,
};

//
//  Use this macro for all string args that may be null or empty.
//
#define SAFE_LOG_ARG(x) ( (!(x) || !(*(x))) ? TEXT("(none)") : (x) )

// ----------------------------------------------------------------------------
//
//  Implementor's section (from here to end)
//

class CMLOG_CLASS CmLogFile
{
public:
    CmLogFile();
    ~CmLogFile();

    //
    //  Initialization/termination functions
    //
    HRESULT Init(HINSTANCE hInst, BOOL fAllUser, LPCWSTR szLongServiceName);
    HRESULT Init(HINSTANCE hInst, BOOL fAllUser, LPCSTR szLongServiceName);

    HRESULT SetParams(BOOL fEnabled, DWORD dwMaxFileSize, LPCWSTR pszLogFileDir);
    HRESULT SetParams(BOOL fEnabled, DWORD dwMaxFileSize, LPCSTR pszLogFileDir);
    HRESULT Start(BOOL fBanner);
    HRESULT Stop();
    HRESULT DeInit();

    //
    //  Work functions
    //
    void    Banner();
    void    Clear(BOOL fWriteBannerAfterwards = TRUE);
    void    Log(_CMLOG_ITEM eLogItem, ...);

    //
    //  Status inquiries
    //
    BOOL    IsEnabled() { return m_fEnabled; }
    LPCWSTR GetLogFilePath() { return m_pszLogFile; }

private:
    HRESULT OpenFile();
    HRESULT CloseFile();
    void    FormatWrite(_CMLOG_ITEM eItem, LPWSTR szArgs);
    HRESULT Write(LPWSTR sz);

    HANDLE  m_hfile;            // file handle for logfile
    DWORD   m_dwSize;           // current size of log file
    LPWSTR  m_pszServiceName;   // name of connectoid (used as filename)
    WCHAR   m_szModule[13];     // cached module name (13 = 8 + '.' + 3 + null)
    DWORD   m_dwMaxSize;        // max size of log file
    LPWSTR  m_pszLogFileDir;    // log file directory
    BOOL    m_fAllUser;         // is this an All-User profile?

    LPWSTR  m_pszLogFile;       // this is the currently-opened log file (full path)

    // state variables

    BOOL    m_fInitialized;     // set after Init() has been called
    BOOL    m_fEnabled;         // set after GetParams() finds logging is enabled (FROM CMS)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmras.h ===
//+----------------------------------------------------------------------------
//
// File:     cmras.h
//
// Module:   CMDIAL32.DLL, CMCFG32.DLL, CMMGR32.EXE, CMSTP.EXE, CMUTOA.DLL
//
// Synopsis: The Connection Manager version of the RAS header.  Contains different
//           versions of several RAS structs as well as constants/structs we cannot
//           see when compiling with WinVer == 4.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header    08/19/99
//
//+----------------------------------------------------------------------------

#ifndef _CM_RAS_H_
#define _CM_RAS_H_

//
// Make sure we pack on the same alignment as RAS for 64-bit Windows
//

#ifdef _WIN64
#include <pshpack4.h>
#endif

///////////////////////////////////////////////////////////////////////////////////
// define's
///////////////////////////////////////////////////////////////////////////////////

#if (WINVER < 0x401)
    //
    // RASENTRY 'dwDialMode' values.
    //

    #define RASEDM_DialAll                  1
    #define RASEDM_DialAsNeeded             2

#define RASCREDENTIALSA struct tagRASCREDENTIALSA
RASCREDENTIALSA
{
    DWORD dwSize;
    DWORD dwMask;
    CHAR szUserName[ UNLEN + 1 ];
    CHAR szPassword[ PWLEN + 1 ];
    CHAR szDomain[ DNLEN + 1 ];
};

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASCREDENTIALS RASCREDENTIALSW
#else
#define RASCREDENTIALS RASCREDENTIALSA
#endif

#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define LPRASCREDENTIALSA RASCREDENTIALSA*
#define LPRASCREDENTIALS  RASCREDENTIALS*

//
// RASCREDENTIALS 'dwMask' values.
//

#define RASCM_UserName       0x00000001
#define RASCM_Password       0x00000002
#define RASCM_Domain         0x00000004

#define RASCM_PreSharedKey   0x00000010
#endif

//
// For global creds support. This is only used on WindowsXP,
// but we can't assume that RAS defined it since we compile with WINVER < WindowsXP
//
#ifndef RASCM_DefaultCreds
#define RASCM_DefaultCreds  0x00000008
#endif
      
//
// This is from the W2K ras.h
//

#ifndef RDEOPT_CustomDial
#define RDEOPT_CustomDial                0x00001000
#endif

#ifndef RDEOPT_UseCustomScripting        
#define RDEOPT_UseCustomScripting        0x00002000
#endif

//
// 5.00 RASEO Options
//

#ifndef RASEO_SecureLocalFiles          
#define RASEO_SecureLocalFiles          0x00010000
#endif

#ifndef RASEO_RequireEAP
#define RASEO_RequireEAP                0x00020000
#endif

#ifndef RASEO_RequirePAP
#define RASEO_RequirePAP                0x00040000
#endif

#ifndef RASEO_RequireSPAP
#define RASEO_RequireSPAP               0x00080000
#endif

#ifndef RASEO_Custom
#define RASEO_Custom                    0x00100000
#endif

#ifndef RASEO_RequireCHAP               
#define RASEO_RequireCHAP               0x08000000
#endif

#ifndef RASEO_RequireMsCHAP
#define RASEO_RequireMsCHAP             0x10000000
#endif


#ifndef RASEO_RequireMsCHAP2
#define RASEO_RequireMsCHAP2            0x20000000
#endif

#ifndef RASEO_RequireW95MSCHAP
#define RASEO_RequireW95MSCHAP          0x40000000
#endif

#ifndef RASEO_CustomScript
#define RASEO_CustomScript              0x80000000
#endif

//
// 5.01 RASEO options for dwfOptions2
//

#ifndef RASEO2_SecureFileAndPrint
#define RASEO2_SecureFileAndPrint       0x00000001
#endif

#ifndef RASEO2_SecureClientForMSNet
#define RASEO2_SecureClientForMSNet     0x00000002
#endif

#ifndef RASEO2_DontNegotiateMultilink
#define RASEO2_DontNegotiateMultilink   0x00000004
#endif

#ifndef RASEO2_DontUseRasCredentials
#define RASEO2_DontUseRasCredentials    0x00000008
#endif

#ifndef RASEO2_UsePreSharedKey
#define RASEO2_UsePreSharedKey          0x00000010
#endif

#ifndef RASEO2_Internet
#define RASEO2_Internet                 0x00000020
#endif

#ifndef RASEO2_DisableNbtOverIP
#define RASEO2_DisableNbtOverIP         0x00000040
#endif

#ifndef RASEO2_UseGlobalDeviceSettings
#define RASEO2_UseGlobalDeviceSettings  0x00000080
#endif

#ifndef RASEO2_ReconnectIfDropped
#define RASEO2_ReconnectIfDropped       0x00000100
#endif

//
//   Encryption Types
//
#define ET_None         0  // No encryption
#define ET_Require      1  // Require Encryption
#define ET_RequireMax   2  // Require max encryption
#define ET_Optional     3  // Do encryption if possible. None Ok.


//
//  RAS Custom Dial (RCD) flags
//  Note: Re-defined here because RAS.H defines them in a WINVER > 0x500 section.
//

#define RCD_SingleUser  0
#define RCD_AllUsers    0x00000001
#define RCD_Eap         0x00000002
#define RCD_Logon       0x00000004

///////////////////////////////////////////////////////////////////////////////////
// typedef's
///////////////////////////////////////////////////////////////////////////////////

//
// From RAS\UI\COMMON\PBK\UTIL.C
//

#ifndef EAP_CUSTOM_DATA

typedef struct _EAP_CUSTOM_DATA
{
    DWORD dwSignature;
    DWORD dwCustomAuthKey;
    DWORD dwSize;
    BYTE  abdata[1];
} EAP_CUSTOM_DATA;

#endif

//
// From RASMAN.H
//

#ifndef EAPLOGONINFO

typedef struct _EAPLOGONINFO
{
    DWORD dwSize;
    DWORD dwLogonInfoSize;
    DWORD dwOffsetLogonInfo;
    DWORD dwPINInfoSize;
    DWORD dwOffsetPINInfo;
    BYTE  abdata[1];
} EAPLOGONINFO, *PEAPLOGONINFO;

#endif

//
//  Private structure for use with DwSetEntryPropertiesPrivate on Win2k
//
typedef struct _tagRASENTRY_EX_0
{
	DWORD dwTcpWindowSize;
} RASENTRY_EX_0;

//
// From raseapif.h
//

#ifndef RAS_EAP_FLAG_NON_INTERACTIVE
#define RAS_EAP_FLAG_NON_INTERACTIVE    0x00000002  // No UI should be displayed
#endif

#ifndef RAS_EAP_FLAG_LOGON
#define RAS_EAP_FLAG_LOGON 0x00000004   // The user data was obtained from Winlogon
#endif

#ifndef RAS_EAP_FLAG_PREVIEW
#define RAS_EAP_FLAG_PREVIEW 0x00000008 // User has checked "Prompt for information"
#endif

#if (WINVER < 0x401)
    //
    // define RASSUBENTRY here since it's only define for 
    // WINVER >= x0401
    //
    
    //
    // A RAS phone book multilinked sub-entry.
    //

    #define RASSUBENTRYA struct tagRASSUBENTRYA
    RASSUBENTRYA
    {
        DWORD       dwSize;
        DWORD       dwfFlags;
        //
        // Device
        //
        CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
        CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
        //
        // Phone numbers
        //
        CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
        DWORD       dwAlternateOffset;   
    };
    
    #define RASSUBENTRYW struct tagRASSUBENTRYW
    RASSUBENTRYW
    {
        DWORD       dwSize;
        DWORD       dwfFlags;
        //
        // Device
        //
        WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
        WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
        //
        // Phone numbers
        //
        WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
        DWORD       dwAlternateOffset;   
    };
    
    #ifdef UNICODE
    #define RASSUBENTRY RASSUBENTRYW
    #else
    #define RASSUBENTRY RASSUBENTRYA
    #endif
    
    #define LPRASSUBENTRYW RASSUBENTRYW*
    #define LPRASSUBENTRYA RASSUBENTRYA*
    #define LPRASSUBENTRY  RASSUBENTRY*
#endif

//
//Describes connection establishment parameters.  (See RasDial)
//

#define RASDIALPARAMSW_V401 struct tagRASDIALPARAMSW_V401
RASDIALPARAMSW_V401
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
    DWORD dwSubEntry;
    ULONG_PTR dwCallbackId;
};

#define RASDIALPARAMSA_V401 struct tagRASDIALPARAMSA_V401
RASDIALPARAMSA_V401
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
    DWORD dwSubEntry;
    ULONG_PTR dwCallbackId;
};

#ifdef UNICODE
#define RASDIALPARAMS_V401 RASDIALPARAMSW_V401
#else
#define RASDIALPARAMS_V401 RASDIALPARAMSA_V401
#endif

#define LPRASDIALPARAMSW_V401 RASDIALPARAMSW_V401*
#define LPRASDIALPARAMSA_V401 RASDIALPARAMSA_V401*
#define LPRASDIALPARAMS_V401  RASDIALPARAMS_V401*


//
// A RAS phone book entry. - from ras.h for NT 4.0
//

#define RASENTRYA_V401 struct tagRASENTRYA_V401
RASENTRYA_V401
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
};

#define RASENTRYW_V401 struct tagRASENTRYW_V401
RASENTRYW_V401
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
};

#ifdef UNICODE
#define RASENTRY_V401 RASENTRYW_V401
#else
#define RASENTRY_V401 RASENTRYA_V401
#endif

#define LPRASENTRYW_V401 RASENTRYW_V401*
#define LPRASENTRYA_V401 RASENTRYA_V401*
#define LPRASENTRY_V401  RASENTRY_V401*

//
// A RAS phone book entry. - for NT5
//

#define RASENTRYA_V500 struct tagRASENTRYA_V500
RASENTRYA_V500
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial DLL
    //
    CHAR        szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;
};

#define RASENTRYW_V500 struct tagRASENTRYW_V500
RASENTRYW_V500
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial DLL
    //
    WCHAR       szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;
};

#ifdef UNICODE
#define RASENTRY_V500 RASENTRYW_V500
#else
#define RASENTRY_V500 RASENTRYA_V500
#endif

#define LPRASENTRYW_V500 RASENTRYW_V500*
#define LPRASENTRYA_V500 RASENTRYA_V500*
#define LPRASENTRY_V500  RASENTRY_V500*

// 
// 501 (whistler)
//
#define RASENTRYA_V501 struct tagRASENTRYA_V501
RASENTRYA_V501
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial DLL
    //
    CHAR        szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;

    //
    // More RASEO_* options
    //
    DWORD       dwfOptions2;

    //
    // For future use
    //
    DWORD       dwfOptions3;

    CHAR        szDnsSuffix[RAS_MaxDnsSuffix];

    DWORD       dwTcpWindowSize;
    CHAR        szPrerequisitePbk[MAX_PATH];
    CHAR        szPrerequisiteEntry[RAS_MaxEntryName + 1];

    DWORD       dwRedialCount;

    DWORD       dwRedialPause;

};

#define RASENTRYW_V501 struct tagRASENTRYW_V501
RASENTRYW_V501
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial DLL
    //
    WCHAR       szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;

    //
    // More RASEO_* options
    //
    DWORD       dwfOptions2;

    //
    // For future use
    //
    DWORD       dwfOptions3;

    WCHAR       szDnsSuffix[RAS_MaxDnsSuffix];

    DWORD       dwTcpWindowSize;
    WCHAR       szPrerequisitePbk[MAX_PATH];
    WCHAR       szPrerequisiteEntry[RAS_MaxEntryName + 1];

    DWORD       dwRedialCount;

    DWORD       dwRedialPause;
};

#ifdef UNICODE
#define RASENTRY_V501 RASENTRYW_V501
#else
#define RASENTRY_V501 RASENTRYA_V501
#endif

#define LPRASENTRYW_V501 RASENTRYW_V501*
#define LPRASENTRYA_V501 RASENTRYA_V501*
#define LPRASENTRY_V501  RASENTRY_V501*

// Describes EAP extended connection establishment option.  For NT5.

#define RASEAPINFO struct tagRASEAPINFO
RASEAPINFO
{
    DWORD dwSizeofEapInfo;
    BYTE  *pbEapInfo;
};

// Describes extended connection establishment options.  For NT5.  (See RasDial)

#define RASDIALEXTENSIONS_V500 struct tagRASDIALEXTENSIONS_V500
RASDIALEXTENSIONS_V500
{
    DWORD dwSize;
    DWORD dwfOptions;
    HWND  hwndParent;
    ULONG_PTR reserved;
    ULONG_PTR reserved1;
    RASEAPINFO RasEapInfo; 
};

#define LPRASDIALEXTENSIONS_V500 RASDIALEXTENSIONS_V500*

//
//  New RAS Entry Name Structs for NT5
//
#define RASENTRYNAMEW_V500 struct tagRASENTRYNAMEW_V500
RASENTRYNAMEW_V500
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];

    //
    // If this flag is RCD_AllUsers then its a
    // system phonebook.
    //
    DWORD dwFlags;
    WCHAR szPhonebookPath[MAX_PATH + 1];

};

#define RASENTRYNAMEA_V500 struct tagRASENTRYNAMEA_V500
RASENTRYNAMEA_V500
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];

    DWORD dwFlags;
    CHAR  szPhonebookPath[MAX_PATH + 1];
};

#ifdef UNICODE
#define RASENTRYNAME_V500 RASENTRYNAMEW_V500
#else
#define RASENTRYNAME_V500 RASENTRYNAMEA_V500
#endif

#define LPRASENTRYNAMEW_V500 RASENTRYNAMEW_V500*
#define LPRASENTRYNAME_V500A RASENTRYNAMEA_V500*
#define LPRASENTRYNAME_V500  RASENTRYNAME_V500*


// RasGetEapUserIdentity structure. - For NT5

#define RASEAPUSERIDENTITYA struct tagRASEAPUSERIDENTITYA
RASEAPUSERIDENTITYA
{
    CHAR        szUserName[ UNLEN + 1 ];
    DWORD       dwSizeofEapInfo;
    BYTE        pbEapInfo[ 1 ];
};

#define RASEAPUSERIDENTITYW struct tagRASEAPUSERIDENTITYW
RASEAPUSERIDENTITYW
{
    WCHAR       szUserName[ UNLEN + 1 ];
    DWORD       dwSizeofEapInfo;
    BYTE        pbEapInfo[ 1 ];
};

#ifdef UNICODE
#define RASEAPUSERIDENTITY RASEAPUSERIDENTITYW
#else
#define RASEAPUSERIDENTITY RASEAPUSERIDENTITYA
#endif

#define LPRASEAPUSERIDENTITYW RASEAPUSERIDENTITYW*
#define LPRASEAPUSERIDENTITYA RASEAPUSERIDENTITYA*

#define LPRASEAPUSERIDENTITY RASEAPUSERIDENTITY*

#ifdef _WIN64
#include <poppack.h>
#endif

#endif // _CM_RAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmsetup.h ===
//+----------------------------------------------------------------------------
//
// File:     cmsetup.h
//
// Module:   CMSETUP.LIB
//
// Synopsis: This header defines all of the capabilities of the CM setup library.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb      Created Header   08/19/99
//
//+----------------------------------------------------------------------------

//
//	Standard Windows Includes
//
#include <windows.h>
#include <tchar.h>

//
//	Common CM includes
//
#include "cmglobal.h"
#include "cmdebug.h"

//
//	Other source file includes
//	

#include "cmplat.h"
#include "cversion.h"
#include "cmakver.h"
#include "cmver.h"
#include "cfilename.h"
#include "processcmdln.h"
#include "setupmem.h"

HRESULT LaunchInfSection(LPCTSTR szInfFile, LPCTSTR szInfSection, LPCTSTR szTitle, BOOL bQuiet);
HRESULT CallLaunchInfSectionEx(LPCSTR pszInfFile, LPCSTR pszInfSection, DWORD dwFlags);
BOOL CreateLayerDirectory(LPCTSTR str);
BOOL FileExists(LPCTSTR pszFullNameAndPath);
HRESULT GetModuleVersionAndLCID (LPTSTR pszFile, LPDWORD pdwVersion, LPDWORD pdwBuild, LPDWORD pdwLCID);
LONG CmDeleteRegKeyWithoutSubKeys(HKEY hBaseKey, LPCTSTR pszSubKey, BOOL bIgnoreValues);
BOOL CmIsNative();
HRESULT ExtractCmBinsFromExe(LPTSTR pszPathToExtractFrom, LPTSTR pszPathToExtractTo);

//
//	Common Macros
//
#define CELEMS(x) ((sizeof(x))/(sizeof(x[0])))

//
//  Pre-shared key constants
//
const DWORD c_dwMaxPresharedKey = 256;
const DWORD c_dwMinPresharedKey = 8;
const DWORD c_dwMinPresharedKeyPIN = 4;
const DWORD c_dwMaxPresharedKeyPIN = 15;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmsecure.h ===
//+----------------------------------------------------------------------------
//
// File:     cmsecure.h
//
// Module:   CMSECURE.LIB
//
// Synopsis: This header describes the functionality available in the cmsecure
//           library.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   henryt      Created    05/21/97
//
//+----------------------------------------------------------------------------

#ifndef _CMSECURE_INC_
#define _CMSECURE_INC_

#include <windows.h>


//************************************************************************
// define's
//************************************************************************

//
// the encryption types that cmsecure currently supports
//
#define CMSECURE_ET_NOT_ENCRYPTED       0   // 0x0000
#define CMSECURE_ET_RC2                 1   // 0x0001
#define CMSECURE_ET_STREAM_CIPHER       2   // 0x0002
#define CMSECURE_ET_CBC_CIPHER          3   // 0x0003

//
// Extended codes for UNICODE designation
// Note: The encryption logic will not know anything about these new codes 
// they are designed for book-keeping by the calling modules, which will
// have to do the appropiate conversions based on the calling context/OS
//

#define CMSECURE_ET_NOT_ENCRYPTED_U     128 // 0x0080
#define CMSECURE_ET_RC2_U               129 // 0x0081
#define CMSECURE_ET_STREAM_CIPHER_U     130 // 0x0082
#define CMSECURE_ET_CBC_CIPHER_U        131 // 0x0083


#define CMSECURE_ET_MASK_U              128 // 0x0080 
#define CMSECURE_ET_RANDOM_KEY_MASK     256 // 0x0100   uses a randomly generated key
#define CMSECURE_ET_USE_SECOND_RND_KEY  512 // 0x1000   uses the second blob key

//
// structures, typdef's
//

typedef LPVOID  (*PFN_CMSECUREALLOC)(DWORD);
typedef void    (*PFN_CMSECUREFREE)(LPVOID);

//
// externs
//


//
// function prototypes
//
/*
#ifdef __cplusplus
extern "C" {
#endif
*/
// cmsecure.cpp

BOOL
InitSecure(
    BOOL fFastEncryption = FALSE   // default is more secure 
);

void
DeInitSecure(
    void
);

BOOL
EncryptData(
    IN  LPBYTE          pbData,                 // Data to be encrypted
    IN  DWORD           dwDataLength,           // Length of data in bytes
    OUT LPBYTE          *ppbEncryptedData,      // Encrypted secret key will be stored here(memory will be allocated)
    OUT LPDWORD         pdwEncrytedBufferLen,   // Length of this buffer
    OUT LPDWORD         pEncryptionType,        // type of the encryption used

    IN  PFN_CMSECUREALLOC  pfnAlloc,            // memory allocator(if NULL, then the default is used.
                                                //      Win32 - HeapAlloc(GetProcessHeap(), ...)
    IN  PFN_CMSECUREFREE   pfnFree,             // memory deallocator(if NULL, then the default is used.
                                                //      Win32 - HeapFree(GetProcessHeap(), ...)
    IN  LPSTR           pszUserKey              // Registry key to store encrypted key for passwords
);

BOOL
DecryptData(
    IN  LPBYTE          pbEncryptedData,        // Encrypted data
    IN  DWORD           dwEncrytedDataLen,      // Length of encrypted data
    OUT LPBYTE          *ppbData,               // Decrypted Data will be stored here(memory will be allocated)
    OUT LPDWORD         pdwDataBufferLength,    // Length of the above buffer in bytes
    IN  DWORD           dwEncryptionType,       // encryption type for decryption

    IN  PFN_CMSECUREALLOC  pfnAlloc,            // memory allocator(if NULL, then the default is used.
                                                //      Win32 - HeapAlloc(GetProcessHeap(), ...)
    IN  PFN_CMSECUREFREE   pfnFree,             // memory deallocator(if NULL, then the default is used.
                                                //      Win32 - HeapFree(GetProcessHeap(), ...)
    IN  LPSTR           pszUserKey              // Registry key to store encrypted key for passwords
);


BOOL
EncryptString(
    IN  LPSTR           pszToEncrypt,           // String to be encrypted (Ansi)
    IN  LPSTR           pszUserKey,             // Key to use for Encryption
    OUT LPBYTE *        ppbEncryptedData,       // Encrypted secret key will be stored here(memory will be allocated)
    OUT LPDWORD         pdwEncrytedBufferLen,   // Length of this buffer
    IN  PFN_CMSECUREALLOC  pfnAlloc,            // memory allocator(if NULL, then the default is used.
                                                //      Win32 - HeapAlloc(GetProcessHeap(), ...)
    IN  PFN_CMSECUREFREE   pfnFree              // memory deallocator(if NULL, then the default is used.
                                                //      Win32 - HeapFree(GetProcessHeap(), ...)
);

BOOL
DecryptString(
    IN  LPBYTE          pbEncryptedData,        // Encrypted data
    IN  DWORD           dwEncrytedDataLen,      // Length of encrypted data
    IN  LPSTR           pszUserKey,             // Registry key to store encrypted key for passwords
    OUT LPBYTE *        ppbData,                // Decrypted Data will be stored here
    OUT LPDWORD         pdwDataBufferLength,    // Length of the above buffer in bytes
    IN  PFN_CMSECUREALLOC  pfnAlloc,            // memory allocator(if NULL, then the default is used.
                                                //      Win32 - HeapAlloc(GetProcessHeap(), ...)
    IN  PFN_CMSECUREFREE   pfnFree              // memory deallocator(if NULL, then the default is used.
                                                //      Win32 - HeapFree(GetProcessHeap(), ...)
);


//+---------------------------------------------------------------------------
//
//  Function:   AnsiToUnicodePcs
//
//  Synopsis:   Wrapper to encapsulate translating a standard crypt type value
//              into its equivalent for UNICODE systems. 
//
//  Arguments:  IN DWORD dwCrypt - The code to be converted
//
//  Returns:    Converted code
//
//  History:    nickball    Created     06/02/99
//
//----------------------------------------------------------------------------
inline DWORD AnsiToUnicodePcs(IN DWORD dwCrypt)
{
    return (dwCrypt | CMSECURE_ET_MASK_U);
}

//+---------------------------------------------------------------------------
//
//  Function:   UnicodeToAnsiPcs
//
//  Synopsis:   Wrapper to encapsulate translating a UNICODE crypt type value
//              into its equivalent standard ANSI crypt type. 
//
//  Arguments:  IN DWORD dwCrypt - The code to be converted
//
//  Returns:    Converted code
//
//  History:    nickball    Created     06/02/99
//
//----------------------------------------------------------------------------
inline DWORD UnicodeToAnsiPcs(IN DWORD dwCrypt)
{
    return (dwCrypt & (~CMSECURE_ET_MASK_U));
}

//+---------------------------------------------------------------------------
//
//  Function:   IsUnicodePcs
//
//  Synopsis:   Wrapper to encapsulate determining if a crypt type has UNICODE 
//              designation.
//
//  Arguments:  IN DWORD dwCrypt - The code to be converted
//
//  Returns:    TRUE if UNICODE designation
//
//  History:    nickball    Created     06/02/99
//
//----------------------------------------------------------------------------
inline BOOL IsUnicodePcs(IN DWORD dwCrypt)
{
    return (!!(dwCrypt & CMSECURE_ET_MASK_U)); // !! == (BOOL)
}

//+---------------------------------------------------------------------------
//
//  Function:   IsAnsiPcs
//
//  Synopsis:   Wrapper to encapsulate determining if a crypt type has Ansi 
//              designation.
//
//  Arguments:  IN DWORD dwCrypt - The code to be converted
//
//  Returns:    TRUE if Ansi designation
//
//  History:    nickball    Created     06/02/99
//
//----------------------------------------------------------------------------
inline BOOL IsAnsiPcs(IN DWORD dwCrypt)
{
    return (!(dwCrypt & CMSECURE_ET_MASK_U));
}


/*
#ifdef __cplusplus
}
#endif
*/
#endif // _CMSECURE_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmsafenet.h ===
//+----------------------------------------------------------------------------
//
// File:     cmsafenet.h
//
// Module:   CMDIAL32.DLL AND CMSTP.EXE
//
// Synopsis: This header file contains the definitions to allow Connection Manager to
//           interact with the SafeNet downlevel L2TP/IPSec client.
//
// Copyright (c) 2001 Microsoft Corporation
//
// Author:   quintinb   created		09/10/01
//
//+----------------------------------------------------------------------------

#include "snpolicy.h"

//
//  Typedefs and Structure for linkage to the SafeNet configuration APIs
//
typedef BOOL (__cdecl *pfnSnPolicyApiNegotiateVersionSpec)(DWORD *,  DWORD *, POLICY_FUNCS *);
typedef BOOL (__cdecl *pfnSnPolicySetSpec)(LPCTSTR szAttrId, const void *pvData);
typedef BOOL (__cdecl *pfnSnPolicyGetSpec)(LPCTSTR szAttrId, const void *pvData, DWORD *pcbData);
typedef BOOL (__cdecl *pfnSnPolicyReloadSpec)(void);

typedef struct _SafeNetLinkageStruct {

    HMODULE hSnPolicy;
    pfnSnPolicySetSpec pfnSnPolicySet;
    pfnSnPolicyGetSpec pfnSnPolicyGet;
    pfnSnPolicyReloadSpec pfnSnPolicyReload;

} SafeNetLinkageStruct;

BOOL IsSafeNetClientAvailable(void);
BOOL LinkToSafeNet(SafeNetLinkageStruct* pSnLinkage);
void UnLinkFromSafeNet(SafeNetLinkageStruct* pSnLinkage);
LPTSTR GetPathToSafeNetLogFile(void);

//
//  String constants
//
const TCHAR* const c_pszSafeNetAdapterName_Win9x_old = TEXT("SafeNet_VPN 1"); // BUGBUG: this needs to be updated to the real name and the 1 removed or dealt with appropriately...
const TCHAR* const c_pszSafeNetAdapterType_Win9x_old = TEXT("VPN"); // BUGBUG: this needs to be updated to the real name and the 1 removed or dealt with appropriately...
const TCHAR* const c_pszSafeNetAdapterName_Winnt4_old = TEXT("SafeNet_VPN"); // BUGBUG: this needs to be updated to the real name and the 1 removed or dealt with appropriately...
const TCHAR* const c_pszSafeNetAdapterType_Winnt4_old = TEXT("L2TP"); // BUGBUG: this needs to be updated to the real name and the 1 removed or dealt with appropriately...

const TCHAR* const c_pszSafeNetAdapterName_Win9x = TEXT("Microsoft L2TP/IPSec VPN adapter"); // BUGBUG: this needs to be updated to the real name and the 1 removed or dealt with appropriately...
const TCHAR* const c_pszSafeNetAdapterName_Winnt4 = TEXT("RASL2TPM"); // BUGBUG: this needs to be updated to the real name and the 1 removed or dealt with appropriately...
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmtiming.h ===
//+----------------------------------------------------------------------------
//
// File:     cmtiming.h
//
// Module:   CMDIAL32.DLL and CMMGR32.EXE
//
// Synopsis: Header file for timing functions.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball      Created    04/28/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_TIMING_INC
#define _CM_TIMING_INC

//
// Add the following to the sources file of the target module to activate timing macros.
//
// C_DEFINES = -DCM_TIMING_ON
//
// NOTE: Never check in a sources file with this flag defined
//

#ifdef CM_TIMING_ON // For timing test only

#define CM_SET_TIMING_INTERVAL(x) SetTimingInterval(x)

//
// Defintions
//

#define MAX_TIMING_INTERVALS 50
#define CM_TIMING_TABLE_NAME "CM TIMING TABLE"

//
// Custom types for table
//

typedef struct Cm_Timing_Interval
{
    TCHAR szName[MAX_PATH];      // Name of timing interval
	DWORD dwTicks;              // TickCount
} CM_TIMING_INTERVAL, *LPCM_TIMING_INTERVAL;


typedef struct Cm_Timing_Table
{
	int iNext;                                           // Next available entry
	CM_TIMING_INTERVAL Intervals[MAX_TIMING_INTERVALS];  // a list of intervals
} CM_TIMING_TABLE, * LPCM_TIMING_TABLE;


//+----------------------------------------------------------------------------
//
// Function:  SetTimingInterval
//
// Synopsis:  A simple wrapper to encapsulate the process of updating the 
//            timing table with an interval entry.
//
// Arguments: char *szIntervalName - The optional name of the entry, the entry number is used if NULL
//
// Returns:   void - Nothing
//
// History:   nickball    4/7/98    Created   
//
//+----------------------------------------------------------------------------
inline void SetTimingInterval(char *szIntervalName)    
{    
    HANDLE hMap = OpenFileMapping(FILE_MAP_READ | FILE_MAP_WRITE, FALSE, CM_TIMING_TABLE_NAME);
         
    if (hMap)
    {
        //
        // File mapping opened successfully, map a view of it.
        //

        LPCM_TIMING_TABLE pTable = (LPCM_TIMING_TABLE) MapViewOfFile(hMap,
                                      FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);        
        if (pTable) 
        {
            if (pTable->iNext < MAX_TIMING_INTERVALS)
            {                
                //
                // Update the next available entry
                //

                if (szIntervalName)
                {
                    lstrcpy(pTable->Intervals[pTable->iNext].szName, szIntervalName);
                }
                else
                {
                    wsprintf(pTable->Intervals[pTable->iNext].szName, "(%d)", pTable->iNext);
                }

                pTable->Intervals[pTable->iNext].dwTicks = GetTickCount();                                            
                pTable->iNext++;
            }

            UnmapViewOfFile(pTable);
        }   

        CloseHandle(hMap);
    }   
}

#else // CM_TIMING_ON

#define CM_SET_TIMING_INTERVAL(x) 

#endif

#endif // _CM_TIMING_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmutil.h ===
//+----------------------------------------------------------------------------
//
// File:     cmutil.h	 
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Header file for Private CM APIs
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   henryt     Created   03/01/98
//
//+----------------------------------------------------------------------------

#ifndef _CMUTIL_INC_
#define _CMUTIL_INC_

#ifdef  _CMUTIL_MODULE_
#define CMUTILAPI   /*extern "C" __declspec(dllexport)*/
#define CMUTILAPI_CLASS __declspec(dllexport)
#else
#define CMUTILAPI   /*extern "C" __declspec(dllimport)*/
#define CMUTILAPI_CLASS __declspec(dllimport)
#endif

#include "cini.h"

//+----------------------------------------------------------------------------
// defines
//+----------------------------------------------------------------------------

//
// platform ID for WINDOWS98
//
#define VER_PLATFORM_WIN32_WINDOWS98    100 

//
// platform ID for WINDOWS Millennium
//
#define VER_PLATFORM_WIN32_MILLENNIUM   200 

//
// OS version macros
//

#define OS_NT  ((GetOSVersion() == VER_PLATFORM_WIN32_NT))
#define OS_W9X ((GetOSVersion() != VER_PLATFORM_WIN32_NT))

#define OS_NT6 ((GetOSVersion() == VER_PLATFORM_WIN32_NT) && (GetOSMajorVersion() >= 6))
#define OS_NT51 ((GetOSVersion() == VER_PLATFORM_WIN32_NT) && (GetOSMajorVersion() >= 5) && (GetOSBuildNumber() > 2195))
#define OS_NT5 ((GetOSVersion() == VER_PLATFORM_WIN32_NT) && (GetOSMajorVersion() >= 5))
#define OS_NT4 ((GetOSVersion() == VER_PLATFORM_WIN32_NT) && (GetOSMajorVersion() < 5))

#define OS_W2K ((GetOSVersion() == VER_PLATFORM_WIN32_NT) && (GetOSBuildNumber() == 2195))

#define OS_MIL ((GetOSVersion() == VER_PLATFORM_WIN32_MILLENNIUM))
#define OS_W98 ((GetOSVersion() == VER_PLATFORM_WIN32_WINDOWS98) || (GetOSVersion() == VER_PLATFORM_WIN32_MILLENNIUM))
#define OS_W95 ((GetOSVersion() == VER_PLATFORM_WIN32_WINDOWS))


#ifdef UNICODE
    #define CmStrTrim                       CmStrTrimW
    #define CmIsSpace                       CmIsSpaceW
    #define CmIsDigit                       CmIsDigitW
    #define CmEndOfStr                      CmEndOfStrW
    #define CmAtol                          CmAtolW
    #define CmStrStr                        CmStrStrW
    #define CmStrchr                        CmStrchrW
    #define CmStrrchr                       CmStrrchrW
    #define CmStrtok                        CmStrtokW
    #define CmStrCpyAlloc                   CmStrCpyAllocW
    #define CmStrCatAlloc                   CmStrCatAllocW
    #define CmLoadString                    CmLoadStringW
    #define CmParsePath                     CmParsePathW
    #define CmConvertRelativePath           CmConvertRelativePathW
    #define CmStripPathAndExt               CmStripPathAndExtW
    #define CmStripFileName                 CmStripFileNameW
    #define CmBuildFullPathFromRelative     CmBuildFullPathFromRelativeW
    #define CmFmtMsg                        CmFmtMsgW
    #define CmLoadImage                     CmLoadImageW
    #define CmLoadIcon                      CmLoadIconW
    #define CmLoadSmallIcon                 CmLoadSmallIconW
    #define CmCompareString                 CmCompareStringW
#else
    #define CmStrTrim                       CmStrTrimA
    #define CmIsSpace                       CmIsSpaceA
    #define CmIsDigit                       CmIsDigitA
    #define CmEndOfStr                      CmEndOfStrA
    #define CmAtol                          CmAtolA
    #define CmStrStr                        CmStrStrA
    #define CmStrchr                        CmStrchrA
    #define CmStrrchr                       CmStrrchrA
    #define CmStrtok                        CmStrtokA
    #define CmStrCpyAlloc                   CmStrCpyAllocA
    #define CmStrCatAlloc                   CmStrCatAllocA
    #define CmLoadString                    CmLoadStringA
    #define CmParsePath                     CmParsePathA
    #define CmConvertRelativePath           CmConvertRelativePathA
    #define CmStripPathAndExt               CmStripPathAndExtA
    #define CmStripFileName                 CmStripFileNameA
    #define CmBuildFullPathFromRelative     CmBuildFullPathFromRelativeA
    #define CmFmtMsg                        CmFmtMsgA
    #define CmLoadImage                     CmLoadImageA
    #define CmLoadIcon                      CmLoadIconA
    #define CmLoadSmallIcon                 CmLoadSmallIconA
    #define CmCompareString                 CmCompareStringA
#endif


//+----------------------------------------------------------------------------
// typedefs
//+----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
// declarations
//+----------------------------------------------------------------------------

CMUTILAPI int WzToSz(IN LPCWSTR pszwStrIn, OUT LPSTR pszStrOut, IN int nOutBufferSize);

CMUTILAPI int SzToWz(IN LPCSTR pszInput, OUT LPWSTR pszwOutput, IN int nBufferSize);

CMUTILAPI LPSTR WzToSzWithAlloc(LPCWSTR pszwWideString);

CMUTILAPI LPWSTR SzToWzWithAlloc(LPCSTR pszAnsiString);

CMUTILAPI DWORD WINAPI GetOSVersion(void);

CMUTILAPI DWORD WINAPI GetOSBuildNumber(void);

CMUTILAPI DWORD WINAPI GetOSMajorVersion(void);

CMUTILAPI BOOL WINAPI IsFarEastNonOSR2Win95(void);

CMUTILAPI HRESULT ReleaseBold(HWND hwnd);

CMUTILAPI HRESULT MakeBold (HWND hwnd, BOOL fSize);

CMUTILAPI void UpdateFont(HWND hDlg);

CMUTILAPI int WzToSz(IN LPCWSTR pszwStrIn, OUT LPSTR pszStrOut, IN int nOutBufferSize);

CMUTILAPI int SzToWz(IN LPCSTR pszInput, OUT LPWSTR pszwOutput, IN int nBufferSize);

CMUTILAPI LPSTR WzToSzWithAlloc(LPCWSTR pszwWideString);

CMUTILAPI LPWSTR SzToWzWithAlloc(LPCSTR pszAnsiString);

CMUTILAPI BOOL CmWinHelp(HWND hWndMain, HWND hWndItem, CONST WCHAR *lpszHelp, UINT uCommand, ULONG_PTR dwData);

CMUTILAPI BOOL IsLogonAsSystem();

//
//    Ansi Functions
//

CMUTILAPI LPSTR CmLoadStringA(HINSTANCE hInst, UINT nId);

CMUTILAPI void WINAPI CmStrTrimA(LPSTR);

CMUTILAPI BOOL WINAPI CmIsSpaceA(LPSTR);

CMUTILAPI BOOL WINAPI CmIsDigitA(LPSTR);

CMUTILAPI LPSTR WINAPI CmEndOfStrA(LPSTR);

CMUTILAPI LONG WINAPI CmAtolA(LPCSTR);

CMUTILAPI LPSTR CmStrStrA(LPCSTR, LPCSTR);

CMUTILAPI LPSTR WINAPI CmStrchrA(LPCSTR, CHAR);

CMUTILAPI LPSTR CmStrrchrA(LPCSTR, CHAR);

CMUTILAPI LPSTR CmStrtokA(LPSTR, LPCSTR);

CMUTILAPI LPSTR CmStrCpyAllocA(LPCSTR);

CMUTILAPI LPSTR CmStrCatAllocA(LPSTR *ppszDst, LPCSTR pszSrc);

CMUTILAPI LPSTR CmFmtMsgA(HINSTANCE hInst, DWORD dwMsgId, ...); 

CMUTILAPI HANDLE CmLoadImageA(HINSTANCE hMainInst, LPCSTR pszSpec, UINT nResType, UINT nCX, UINT nCY);

CMUTILAPI HICON CmLoadIconA(HINSTANCE hInst, LPCSTR pszSpec); 

CMUTILAPI HICON CmLoadSmallIconA(HINSTANCE hInst, LPCSTR pszSpec);

CMUTILAPI BOOL CmParsePathA(LPCSTR pszCmdLine, LPCSTR pszServiceFile, LPSTR *ppszCommand, LPSTR *ppszArguments);

CMUTILAPI LPSTR CmConvertRelativePathA(LPCSTR pszServiceFile, LPSTR pszRelative);

CMUTILAPI LPSTR CmStripPathAndExtA(LPCSTR pszFileName);

CMUTILAPI LPSTR CmStripFileNameA(LPCSTR pszFullNameAndPath, BOOL fKeepSlash);

CMUTILAPI LPSTR CmBuildFullPathFromRelativeA(LPCSTR pszFullFileName, LPCSTR pszRelative);

CMUTILAPI int CmCompareStringA(LPCSTR lpString1, LPCSTR lpString2);

//
//    Unicode Functions
//
CMUTILAPI LPWSTR CmLoadStringW(HINSTANCE hInst, UINT nId);

CMUTILAPI void WINAPI CmStrTrimW(LPWSTR);

CMUTILAPI BOOL WINAPI CmIsSpaceW(LPWSTR);

CMUTILAPI BOOL WINAPI CmIsDigitW(LPWSTR);

CMUTILAPI LPWSTR WINAPI CmEndOfStrW(LPWSTR);

CMUTILAPI LONG WINAPI CmAtolW(LPCWSTR);

CMUTILAPI LPWSTR CmStrStrW(LPCWSTR, LPCWSTR);

CMUTILAPI LPWSTR WINAPI CmStrchrW(LPCWSTR, WCHAR);

CMUTILAPI LPWSTR CmStrrchrW(LPCWSTR, WCHAR);

CMUTILAPI LPWSTR CmStrtokW(LPWSTR, LPCWSTR);

CMUTILAPI LPWSTR CmStrCpyAllocW(LPCWSTR);

CMUTILAPI LPWSTR CmStrCatAllocW(LPWSTR *ppszDst, LPCWSTR pszSrc);

CMUTILAPI LPWSTR CmFmtMsgW(HINSTANCE hInst, DWORD dwMsgId, ...); 

CMUTILAPI HANDLE CmLoadImageW(HINSTANCE hMainInst, LPCWSTR pszSpec, UINT nResType, UINT nCX, UINT nCY);

CMUTILAPI HICON CmLoadIconW(HINSTANCE hInst, LPCWSTR pszSpec); 

CMUTILAPI HICON CmLoadSmallIconW(HINSTANCE hInst, LPCWSTR pszSpec);

CMUTILAPI BOOL CmParsePathW(LPCWSTR pszCmdLine, LPCWSTR pszServiceFile, LPWSTR *ppszCommand, LPWSTR *ppszArguments);

CMUTILAPI LPWSTR CmConvertRelativePathW(LPCWSTR pszServiceFile, LPWSTR pszRelative);

CMUTILAPI LPWSTR CmStripPathAndExtW(LPCWSTR pszFileName);

CMUTILAPI LPWSTR CmStripFileNameW(LPCWSTR pszFullNameAndPath, BOOL fKeepSlash);

CMUTILAPI LPWSTR CmBuildFullPathFromRelativeW(LPCWSTR pszFullFileName, LPCWSTR pszRelative);

CMUTILAPI int CmCompareStringW(LPCWSTR lpString1, LPCWSTR lpString2);


//
// If DEBUG_MEM is defined, used a different set of functions
// to track memory
//
#if defined(DEBUG) && defined(DEBUG_MEM)

CMUTILAPI  void* AllocDebugMem(long nSize, const char* lpFileName,int nLine);
CMUTILAPI  BOOL FreeDebugMem(void* lpMem);
CMUTILAPI  void* ReAllocDebugMem(void* lpMem, long nSize, const char* lpFileName,int nLine);
CMUTILAPI  BOOL CheckDebugMem();

#define CmMalloc(nSize) AllocDebugMem(nSize,__FILE__, __LINE__)
#define CmFree(lpMem)  ((void)FreeDebugMem(lpMem))
#define CmRealloc(pvPtr, nSize) ReAllocDebugMem(pvPtr, nSize,__FILE__, __LINE__)

inline void   __cdecl operator delete(void* p) {CmFree(p);}
inline void*  __cdecl operator new(size_t nSize, const char* lpszFileName, int nLine)
{
    return AllocDebugMem(nSize, lpszFileName, nLine);
}


//
// Redefine new to keep trak of the file name and line number
//
#define DEBUG_NEW new(__FILE__, __LINE__)
#define new DEBUG_NEW
 
#else

CMUTILAPI void *CmRealloc(void *pvPtr, size_t nBytes);
CMUTILAPI void *CmMalloc(size_t nBytes);
CMUTILAPI void CmFree(void *pvPtr);
#define CheckDebugMem() (TRUE)

inline void   __cdecl operator delete(void* p) {CmFree(p);}
inline void* __cdecl operator new( size_t cSize ) { return CmMalloc(cSize); }

#endif

//
// for i386
//
#ifdef _M_IX86
CMUTILAPI PVOID WINAPI CmMoveMemory(
    PVOID       dst,
    CONST PVOID src,
    size_t      count
);
#else
//
// alpha has native support
//
#define CmMoveMemory    MoveMemory
#endif //_M_IX86

//+----------------------------------------------------------------------------
// definitions
//+----------------------------------------------------------------------------

//
// Returns a pseudo-random number 0 through 32767.  Taken from the C runtime rand().
//
class CMUTILAPI_CLASS CRandom
{
public:
    CRandom(void) { m_uiSeed = GetTickCount(); }
    CRandom(UINT uiSeed) { m_uiSeed = uiSeed; }
    void Init(DWORD uiSeed) { m_uiSeed = uiSeed; }
    int  Generate(void) { return(((m_uiSeed = m_uiSeed * 214013L + 2531011L) >> 16) & 0x7fff); }

protected:
    UINT m_uiSeed;
};


//
// thread local storage index
//
extern DWORD  g_dwTlsIndex;

#endif _CMUTIL_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cm_phbk.h ===
//+----------------------------------------------------------------------------
//
// File:     cm_phbk.h
//
// Module:   CMPBK32.DLL
//
// Synopsis: Description of CM phone book API
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header    08/19/99
//
//+----------------------------------------------------------------------------

#ifndef _CMPHBK_INC
#define _CMPHBK_INC

typedef struct tagPhoneBookFilterStruct {
	DWORD dwCnt;
	struct {
		DWORD dwMask;
		DWORD dwMatch;
	} aData[1];
} PhoneBookFilterStruct, *PPBFS;

#define CM_PHBK_DllExportH extern "C" HRESULT WINAPI 
#define CM_PHBK_DllExportB extern "C" BOOL WINAPI 
#define CM_PHBK_DllExportV extern "C" void WINAPI 
#define CM_PHBK_DllExportP extern "C" PPBFS WINAPI 
#define CM_PHBK_DllExportD extern "C" DWORD WINAPI 

CM_PHBK_DllExportP PhoneBookCopyFilter(PPBFS pFilterIn);
CM_PHBK_DllExportV PhoneBookFreeFilter(PPBFS pFilter);
CM_PHBK_DllExportB PhoneBookMatchFilter(PPBFS pFilter, DWORD dwValue);

typedef BOOL (WINAPI *PhoneBookParseInfoSvcFuncA)(LPCSTR pszSvc, PPBFS pFilter, DWORD_PTR dwParam);
typedef BOOL (WINAPI *PhoneBookParseInfoSvcFuncW)(LPCWSTR pszSvc, PPBFS pFilter, DWORD_PTR dwParam);
typedef BOOL (WINAPI *PhoneBookParseInfoRefFuncA)(LPCSTR pszFile, LPCSTR pszURL, PPBFS pFilterA, PPBFS pFilterB, DWORD_PTR dwParam);
typedef BOOL (WINAPI *PhoneBookParseInfoRefFuncW)(LPCWSTR pszFile, LPCWSTR pszURL, PPBFS pFilterA, PPBFS pFilterB, DWORD_PTR dwParam);

typedef struct tagPhoneBookParseInfoStructA {
	DWORD dwSize;
	LPSTR pszURL;
	DWORD dwURL;
	PPBFS pFilterA;
	PPBFS pFilterB;
	PhoneBookParseInfoSvcFuncA pfnSvc;
	DWORD_PTR dwSvcParam;
	PhoneBookParseInfoRefFuncA pfnRef;
	DWORD_PTR dwRefParam;
} PhoneBookParseInfoStructA;

typedef struct tagPhoneBookParseInfoStructW {
	DWORD dwSize;
	LPWSTR pszURL;
	DWORD dwURL;
	PPBFS pFilterA;
	PPBFS pFilterB;
	PhoneBookParseInfoSvcFuncW pfnSvc;
	DWORD_PTR dwSvcParam;
	PhoneBookParseInfoRefFuncW pfnRef;
	DWORD_PTR dwRefParam;
} PhoneBookParseInfoStructW;


CM_PHBK_DllExportB PhoneBookParseInfoA(LPCSTR pszFile, PhoneBookParseInfoStructA *pInfo);
CM_PHBK_DllExportB PhoneBookParseInfoW(LPCWSTR pszFile, PhoneBookParseInfoStructW *pInfo);


typedef void (WINAPI *PhoneBookCallBack)(unsigned int, DWORD_PTR);


CM_PHBK_DllExportV PhoneBookEnumCountries(DWORD_PTR dwPB, PhoneBookCallBack pfnCountry, PPBFS pFilter, DWORD_PTR dwParam);
CM_PHBK_DllExportB PhoneBookGetCountryNameA(DWORD_PTR dwPB, unsigned int nIdx, LPSTR pszCountryName, DWORD *pdwCountryName);
CM_PHBK_DllExportB PhoneBookGetCountryNameW(DWORD_PTR dwPB, unsigned int nIdx, LPWSTR pszCountryName, DWORD *pdwCountryName);
CM_PHBK_DllExportD PhoneBookGetCountryId(DWORD_PTR dwPB, unsigned int nIdx);
CM_PHBK_DllExportD PhoneBookGetCurrentCountryId();
CM_PHBK_DllExportV PhoneBookEnumRegions(DWORD_PTR dwPB, PhoneBookCallBack pfnRegion, DWORD dwCountryID, PPBFS pFilter, DWORD_PTR dwParam);
CM_PHBK_DllExportB PhoneBookGetRegionNameA(DWORD_PTR dwPB, unsigned int nIdx, LPSTR pszRegionName, DWORD *pdwRegionName);
CM_PHBK_DllExportB PhoneBookGetRegionNameW(DWORD_PTR dwPB, unsigned int nIdx, LPWSTR pszRegionName, DWORD *pdwRegionName);
CM_PHBK_DllExportB PhoneBookGetPhoneCanonicalA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszPhoneNumber, DWORD *pdwPhoneNumber);
CM_PHBK_DllExportB PhoneBookGetPhoneCanonicalW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszPhoneNumber, DWORD *pdwPhoneNumber);
CM_PHBK_DllExportB PhoneBookGetPhoneNonCanonicalA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszPhoneNumber, DWORD *pdwPhoneNumber);
CM_PHBK_DllExportB PhoneBookGetPhoneNonCanonicalW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszPhoneNumber, DWORD *pdwPhoneNumber);
CM_PHBK_DllExportB PhoneBookHasPhoneType(DWORD_PTR dwPB, PPBFS pFilter);
CM_PHBK_DllExportD PhoneBookGetPhoneType(DWORD_PTR dwPB, unsigned int nIdx);
CM_PHBK_DllExportB PhoneBookGetPhoneDUNA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszDUN, DWORD *pdwDUN);
CM_PHBK_DllExportB PhoneBookGetPhoneDUNW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszDUN, DWORD *pdwDUN);

CM_PHBK_DllExportV PhoneBookEnumNumbers(DWORD_PTR dwPB, PhoneBookCallBack pfnNumber, DWORD dwCountryID, unsigned int nRegion, 
                                        PPBFS pFilter, DWORD_PTR dwParam);

CM_PHBK_DllExportV PhoneBookEnumNumbersWithRegionsZero(DWORD_PTR dwPB, PhoneBookCallBack pfnNumber, DWORD dwCountryID, 
                                                       PPBFS pFilter, DWORD_PTR dwParam);

CM_PHBK_DllExportB PhoneBookGetPhoneDispA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszDisp, DWORD *pdwDisp);
CM_PHBK_DllExportB PhoneBookGetPhoneDispW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszDisp, DWORD *pdwDisp);
CM_PHBK_DllExportB PhoneBookGetPhoneDescA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszDesc, DWORD *pdwDesc);
CM_PHBK_DllExportB PhoneBookGetPhoneDescW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszDesc, DWORD *pdwDesc);

#define PhoneBookParseInfoRefFunc	PhoneBookParseInfoRefFuncA
#define PhoneBookParseInfoSvcFunc	PhoneBookParseInfoSvcFuncA
#define PhoneBookParseInfoStruct	PhoneBookParseInfoStructA
#define PhoneBookParseInfo			PhoneBookParseInfoA
#define PhoneBookGetCountryName		PhoneBookGetCountryNameA
#define PhoneBookGetRegionName		PhoneBookGetRegionNameA
#define PhoneBookGetPhoneCanonical	PhoneBookGetPhoneCanonicalA
#define PhoneBookGetPhoneNonCanonical	PhoneBookGetPhoneNonCanonicalA
#define PhoneBookGetPhoneDUN		PhoneBookGetPhoneDUNA
#define PhoneBookGetPhoneDisp		PhoneBookGetPhoneDispA
#define PhoneBookGetPhoneDesc		PhoneBookGetPhoneDescA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmstpex.h ===
//+----------------------------------------------------------------------------
//
// File:     cmstpex.h
//
// Module:   CMSTP.EXE and CMCFG32.DLL
//
// Synopsis: This header includes the type information and Extension Enumeration
//           for using the CMSTP Extension Proc that enables the user to modify
//           the installation behavior of cmstp.exe.  Use this with caution.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb      Created    05/01/99
//
//+----------------------------------------------------------------------------

typedef enum _EXTENSIONDLLPROCTIMES
{
    PRE,   // Before install, uninstall, etc.
    POST // after the cmstp action has been completed but before cmstp cleanup

} EXTENSIONDLLPROCTIMES;

typedef BOOL (WINAPI *pfnCmstpExtensionProcSpec)(LPDWORD, LPTSTR, HRESULT, EXTENSIONDLLPROCTIMES);

//
//  Modes of Operation
//
// const DWORD c_dwInstall = 0; -- not needed but 0 implies install.
TCHAR c_pszUninstall[] = TEXT("/u");
const DWORD c_dwUninstall = 0x1;
TCHAR c_pszOsMigration[] = TEXT("/m");
const DWORD c_dwOsMigration = 0x2;
TCHAR c_pszUninstallCm[] = TEXT("/x");
const DWORD c_dwUninstallCm = 0x4;
TCHAR c_pszProfileMigration[] = TEXT("/mp");
const DWORD c_dwProfileMigration = 0x8;
TCHAR c_pszHelp[] = TEXT("/?");
const DWORD c_dwHelp = 0x10;

//
//  Install Modifiers
//
TCHAR c_pszNoLegacyIcon[] = TEXT("/ni");
const DWORD c_dwNoLegacyIcon = 0x100;
TCHAR c_pszNoNT5Shortcut[] = TEXT("/ns");
const DWORD c_dwNoNT5Shortcut = 0x200;
TCHAR c_pszNoSupportFiles[] = TEXT("/nf");
const DWORD c_dwNoSupportFiles = 0x400;
TCHAR c_pszSilent[] = TEXT("/s");
const DWORD c_dwSilent = 0x800;
TCHAR c_pszSingleUser[] = TEXT("/su");
const DWORD c_dwSingleUser = 0x1000;

TCHAR c_pszIeakInstall[] = TEXT("/i");
const DWORD c_dwIeakInstall = c_dwSilent | c_dwNoSupportFiles;

TCHAR c_pszSetDefaultCon[] = TEXT("/sd"); // set IE default connection
const DWORD c_dwSetDefaultCon = 0x2000;

TCHAR c_pszAllUser[] = TEXT("/au");
const DWORD c_dwAllUser = 0x4000;


const int c_NumArgs = 13;

ArgStruct Args[c_NumArgs] = { 
    {c_pszUninstall, c_dwUninstall},
    {c_pszOsMigration, c_dwOsMigration},
    {c_pszUninstallCm, c_dwUninstallCm},
    {c_pszIeakInstall, c_dwIeakInstall},
    {c_pszProfileMigration, c_dwProfileMigration},
    {c_pszSilent, c_dwSilent},
    {c_pszSingleUser, c_dwSingleUser},
    {c_pszNoLegacyIcon, c_dwNoLegacyIcon},
    {c_pszNoNT5Shortcut, c_dwNoNT5Shortcut},
    {c_pszNoSupportFiles, c_dwNoSupportFiles},
    {c_pszHelp, c_dwHelp},
    {c_pszSetDefaultCon, c_dwSetDefaultCon},
    {c_pszAllUser, c_dwAllUser}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmver.h ===
//+----------------------------------------------------------------------------
//
// File:     cmver.h
//
// Module:   CMSETUP.LIB
//
// Synopsis: Definition of CmVersion, a utility class that helps in detecting
//           the version of Connection Manager that is installed.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   a-anasj    Created                             02/11/98
//           quintinb   Cleaned Up and removed CRegValue    07/14/98
//           quintinb   Rewrote                             09/14/98
//
//+----------------------------------------------------------------------------

#ifndef __CMVER_H
#define __CMVER_H

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>

const int c_CmMin13Version = 2450;
const int c_CmFirstUnicodeBuild = 2041;

class CmVersion : public CVersion
{
public:	//	Public Methods
	CmVersion();
	~CmVersion();
	BOOL GetInstallLocation	(LPTSTR szStr);

private:	//	Member Variables

    TCHAR m_szCmmgrPath[MAX_PATH+1];	// this actually contains the install location path
};


#endif	// __CMVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cm_def.h ===
//+----------------------------------------------------------------------------
//
// File:     cm_def.h
//
// Module:   CMDIAL32.DLL, CMDL32.EXE, CMMGR32.EXE, CMMON32.EXE, etc.
//
// Synopsis: Header file for all definitions common to the main CM components (CMDIAL, 
//           CMMON, CMDL, etc.)
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   nickball   created                         04/28/97
//           nickball   moved globals to cmglobal.h     07/10/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_DEF
#define _CM_DEF

const TCHAR* const c_pszCmMonReadyEvent = TEXT("CmMon Ready");

const TCHAR* const c_pszCMPhoneBookMutex = TEXT("Connection Manager Phonebook Access");

//
// IDs for data passed from CMDIAL to CMMON via WM_COPYDATA
//

#define CMMON_CONNECTED_INFO 0x0000
#define CMMON_HANGUP_INFO    0x0001

//
// Structure of data passed from CMDIAL to CMMON via WM_COPYDATA
//

#define CMLEN 256

typedef struct tagCmConnectedInfo
{   
    TCHAR szEntryName[CMLEN + 1];       // Name of Ras entry in connection table
    TCHAR szProfilePath[MAX_PATH + 1];  // Path of .CMP for entry
    TCHAR szUserName[CMLEN+1];          // For reconnect 
    TCHAR szPassword[CMLEN + 1];        // For reconnect 
    TCHAR szInetPassword[CMLEN + 1];    // For reconnect 
    TCHAR szRasPhoneBook[MAX_PATH + 1]; // For reconnect
    DWORD dwCmFlags;                    // Cm specific flags
    DWORD dwInitBytesRecv;              // For MSDUN12, read from registry pre-dial
    DWORD dwInitBytesSend;              // initial bytes send
    BOOL fDialup2;                      // Whether the stat is in Dialup-adapter#2 registry key
    HANDLE ahWatchHandles[1];           // (MUST ALWAYS BE LAST MEMBER OF STRUCT) - 
                                        // Array (null terminated) of Process handles 
} CM_CONNECTED_INFO, * LPCM_CONNECTED_INFO;

typedef struct tagCmHangupInfo
{   
  TCHAR szEntryName[CMLEN + 1]; // Name of Ras entry in connection table                
} CM_HANGUP_INFO, * LPCM_HANGUP_INFO;


//
// Cm specific flags 
//

#define FL_PROPERTIES           0x00000001  // settings display only
#define FL_AUTODIAL             0x00000002  // autodialing
#define FL_UNATTENDED           0x00000004  // unattended dial  
#define FL_RECONNECT            0x00000008  // its a reconnect request
#define FL_REMEMBER_DIALAUTO    0x00000010  // dial-auto on reconnect 
#define FL_REMEMBER_PASSWORD    0x00000020  // remember password on reconnect
#define FL_DESKTOP              0x00000040  // instance initiated from desktop
#define FL_GLOBALCREDS          0x00000080  // has global credentials stored


#define CELEMS(x) ((sizeof(x))/(sizeof(x[0])))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmuufns.h ===
//+----------------------------------------------------------------------------
//
// File:     cmuufns.h
//
// Module:   CMSECURE.LIB
//
// Synopsis: Definitions for CM's UUEncode and UUDecode functions
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   quintinb   Created Header    08/18/99
//
//+----------------------------------------------------------------------------


#ifndef _CMUUFNS_INC_
#define _CMUUFNS_INC_

//************************************************************************
// define's
//************************************************************************


//************************************************************************
// structures, typdef's
//************************************************************************



//************************************************************************
// externs
//************************************************************************


//************************************************************************
// function prototypes
//************************************************************************

#ifdef __cplusplus
extern "C" {
#endif

BOOL uudecode(
              const char   * bufcoded,
              CHAR   * pbuffdecoded,
              LPDWORD  pcbDecoded );

              
BOOL uuencode( const BYTE*   bufin,
               DWORD    nbytes,
               CHAR * pbuffEncoded,
               DWORD    outbufmax);

#ifdef __cplusplus
}
#endif


#endif // _CMUUFNS_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cmutoa.h ===
//+----------------------------------------------------------------------------
//
// File:     cmutoa.h
//
// Module:   CMUTOA.DLL
//
// Synopsis: This header file includes the type definitions and function headers
//           needed to use the CM Unicode to Ansi conversion dll.  This dll contains
//           UA APIs that allow a Unicode App to work on Win9x.  The idea for this 
//           dll was borrowed from F. Avery Bishop's April 1999 MSJ article 
//           "Design a Single Unicode App that Runs on Both Windows 98 and Windows 2000"
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb      Created    4-25-99
//
//+----------------------------------------------------------------------------

#ifndef _CMUTOA
#define _CMUTOA

typedef WINUSERAPI LRESULT (WINAPI *UAPI_CallWindowProc)(WNDPROC, HWND, UINT, WPARAM, LPARAM);
typedef WINUSERAPI LPWSTR (WINAPI *UAPI_CharLower)(LPWSTR);
typedef WINUSERAPI LPWSTR (WINAPI *UAPI_CharNext)(LPCWSTR);
typedef WINUSERAPI LPWSTR (WINAPI *UAPI_CharPrev)(LPCWSTR, LPCWSTR);
typedef WINUSERAPI LPWSTR (WINAPI *UAPI_CharUpper)(LPWSTR);
typedef WINBASEAPI int (WINAPI *UAPI_CompareString)(LCID, DWORD, LPCWSTR, int, LPCWSTR, int);
typedef WINUSERAPI HWND (WINAPI *UAPI_CreateDialogParam)(IN HINSTANCE, IN LPCWSTR, IN HWND, IN DLGPROC, IN LPARAM);
typedef WINBASEAPI BOOL (WINAPI *UAPI_CreateDirectory)(LPCWSTR, LPSECURITY_ATTRIBUTES);
typedef WINBASEAPI HANDLE (WINAPI *UAPI_CreateEvent)(LPSECURITY_ATTRIBUTES, BOOL, BOOL, LPCWSTR);
typedef WINBASEAPI HANDLE (WINAPI *UAPI_CreateFileMapping)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCWSTR);
typedef WINBASEAPI HANDLE (WINAPI *UAPI_CreateFile)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
typedef WINBASEAPI HANDLE (WINAPI *UAPI_CreateMutex)(LPSECURITY_ATTRIBUTES, BOOL, LPCWSTR);
typedef WINBASEAPI BOOL (WINAPI *UAPI_CreateProcess)(LPCWSTR, LPWSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCWSTR, LPSTARTUPINFOW, LPPROCESS_INFORMATION);
typedef WINUSERAPI HWND (WINAPI *UAPI_CreateWindowEx)(DWORD, LPCWSTR, LPCWSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, LPVOID);
typedef WINUSERAPI LRESULT (WINAPI *UAPI_DefWindowProc)(HWND, UINT, WPARAM, LPARAM);
typedef WINBASEAPI BOOL (WINAPI *UAPI_DeleteFile)(LPCWSTR);
typedef WINUSERAPI INT_PTR (WINAPI *UAPI_DialogBoxParam)(HINSTANCE, LPCWSTR, HWND, DLGPROC, LPARAM);
typedef WINUSERAPI LRESULT (WINAPI *UAPI_DispatchMessage)(CONST MSG*);
typedef WINBASEAPI DWORD (WINAPI *UAPI_ExpandEnvironmentStrings)(LPCWSTR, LPWSTR, DWORD);
typedef WINBASEAPI HRSRC (WINAPI *UAPI_FindResourceEx)(HMODULE, LPCWSTR, LPCWSTR, WORD);
typedef WINUSERAPI HWND (WINAPI *UAPI_FindWindowEx)(HWND, HWND, LPCWSTR, LPCWSTR);
typedef WINUSERAPI DWORD (WINAPI *UAPI_GetClassLong)(HWND, int);
typedef WINBASEAPI int (WINAPI *UAPI_GetDateFormat)(LCID, DWORD, CONST SYSTEMTIME *, LPCWSTR, LPWSTR, int);
typedef WINUSERAPI UINT (WINAPI *UAPI_GetDlgItemText)(HWND, int, LPWSTR, int);
typedef WINBASEAPI DWORD (WINAPI *UAPI_GetFileAttributes)(LPCWSTR);
typedef WINUSERAPI BOOL (WINAPI *UAPI_GetMessage)(LPMSG, HWND, UINT, UINT);
typedef WINBASEAPI DWORD (WINAPI *UAPI_GetModuleFileName)(HMODULE, LPWSTR, DWORD);
typedef WINBASEAPI HMODULE (WINAPI *UAPI_GetModuleHandle)(LPCWSTR);
typedef WINBASEAPI UINT (WINAPI *UAPI_GetPrivateProfileInt)(LPCWSTR, LPCWSTR, INT, LPCWSTR);
typedef WINBASEAPI DWORD (WINAPI *UAPI_GetPrivateProfileString)(LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, DWORD, LPCWSTR);
typedef WINBASEAPI BOOL (WINAPI *UAPI_GetStringTypeEx)(LCID, DWORD, LPCWSTR, int, LPWORD);
typedef WINBASEAPI UINT (WINAPI *UAPI_GetSystemDirectory)(LPWSTR, UINT);
typedef WINBASEAPI UINT (WINAPI *UAPI_GetTempFileName)(LPCWSTR, LPCWSTR, UINT, LPWSTR);
typedef WINBASEAPI DWORD (WINAPI *UAPI_GetTempPath)(DWORD, LPWSTR);
typedef WINBASEAPI int (WINAPI *UAPI_GetTimeFormat)(LCID, DWORD, CONST SYSTEMTIME *, LPCWSTR, LPWSTR, int);
typedef WINADVAPI BOOL (WINAPI *UAPI_GetUserName)(LPWSTR, LPDWORD);
typedef WINBASEAPI BOOL (WINAPI *UAPI_GetVersionEx)(LPOSVERSIONINFOW);
#ifdef _WIN64
typedef WINUSERAPI LONG_PTR (WINAPI *UAPI_GetWindowLong)(HWND, int);
#else
typedef WINUSERAPI LONG (WINAPI *UAPI_GetWindowLong)(HWND, int);
#endif
typedef WINUSERAPI int (WINAPI *UAPI_GetWindowTextLength)(HWND);
typedef WINUSERAPI int (WINAPI *UAPI_GetWindowText)(HWND, LPWSTR, int);
typedef WINUSERAPI BOOL (WINAPI *UAPI_InsertMenu)(HMENU, UINT, UINT, UINT_PTR, LPCWSTR);
typedef WINUSERAPI BOOL (WINAPI *UAPI_IsDialogMessage)(HWND, LPMSG);
typedef WINUSERAPI HCURSOR (WINAPI *UAPI_LoadCursor)(HINSTANCE, LPCWSTR);
typedef WINUSERAPI HICON (WINAPI *UAPI_LoadIcon)(HINSTANCE, LPCWSTR);
typedef WINUSERAPI HANDLE (WINAPI *UAPI_LoadImage)(IN HINSTANCE, IN LPCWSTR, IN UINT, IN int, IN int, IN UINT);
typedef WINBASEAPI HMODULE (WINAPI *UAPI_LoadLibraryEx)(LPCWSTR, HANDLE, DWORD);
typedef WINUSERAPI HMENU (WINAPI *UAPI_LoadMenu)(IN HINSTANCE, IN LPCWSTR);
typedef WINUSERAPI INT (WINAPI *UAPI_LoadString)(HINSTANCE, UINT, LPWSTR, INT);
typedef WINBASEAPI LPWSTR (WINAPI *UAPI_lstrcat)(LPWSTR, LPCWSTR);
typedef WINBASEAPI int (WINAPI *UAPI_lstrcmpi)(LPCWSTR, LPCWSTR);
typedef WINBASEAPI int (WINAPI *UAPI_lstrcmp)(LPCWSTR, LPCWSTR);
typedef WINBASEAPI LPWSTR (WINAPI *UAPI_lstrcpyn)(LPWSTR, LPCWSTR, int);
typedef WINBASEAPI LPWSTR (WINAPI *UAPI_lstrcpy)(LPWSTR, LPCWSTR);
typedef WINBASEAPI int (WINAPI *UAPI_lstrlen)(LPCWSTR);
typedef WINBASEAPI HANDLE (WINAPI *UAPI_OpenEvent)(DWORD, BOOL, LPCWSTR);
typedef WINBASEAPI HANDLE (WINAPI *UAPI_OpenFileMapping)(DWORD, BOOL, LPCWSTR);
typedef WINUSERAPI BOOL (WINAPI *UAPI_PeekMessage)(LPMSG, HWND, UINT, UINT, UINT);
typedef WINUSERAPI BOOL (WINAPI *UAPI_PostMessage)(HWND, UINT, WPARAM, LPARAM);
typedef WINUSERAPI BOOL (WINAPI *UAPI_PostThreadMessage)(IN DWORD, IN UINT, IN WPARAM, IN LPARAM);
typedef WINADVAPI LONG (APIENTRY *UAPI_RegCreateKeyEx)(HKEY, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD);
typedef WINADVAPI LONG (APIENTRY *UAPI_RegDeleteKey)(HKEY, LPCWSTR);
typedef WINADVAPI LONG (APIENTRY *UAPI_RegDeleteValue)(HKEY, LPCWSTR);
typedef WINADVAPI LONG (APIENTRY *UAPI_RegEnumKeyEx)(IN HKEY hKey, IN DWORD dwIndex, OUT LPWSTR lpName, IN OUT LPDWORD lpcbName, IN LPDWORD lpReserved, IN OUT LPWSTR lpClass, IN OUT LPDWORD lpcbClass, OUT PFILETIME lpftLastWriteTime);
typedef WINUSERAPI ATOM (WINAPI *UAPI_RegisterClassEx)(CONST WNDCLASSEXW *);
typedef WINUSERAPI UINT (WINAPI *UAPI_RegisterWindowMessage)(LPCWSTR);
typedef WINADVAPI LONG (APIENTRY *UAPI_RegOpenKeyEx)(HKEY, LPCWSTR, DWORD, REGSAM, PHKEY);
typedef WINADVAPI LONG (APIENTRY *UAPI_RegQueryValueEx)(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
typedef WINADVAPI LONG (APIENTRY *UAPI_RegSetValueEx)(HKEY, LPCWSTR, DWORD, DWORD, CONST BYTE*, DWORD);
typedef WINBASEAPI DWORD (WINAPI *UAPI_SearchPath)(IN LPCWSTR, IN LPCWSTR, IN LPCWSTR, IN DWORD, OUT LPWSTR, OUT LPWSTR *);
typedef WINUSERAPI LONG_PTR (WINAPI *UAPI_SendDlgItemMessage)(HWND, INT, UINT, WPARAM, LPARAM);
typedef WINUSERAPI LRESULT (WINAPI *UAPI_SendMessage)(HWND, UINT, WPARAM, LPARAM );
typedef WINBASEAPI BOOL (WINAPI* UAPI_SetCurrentDirectory)(IN LPCWSTR);
typedef WINUSERAPI BOOL (WINAPI *UAPI_SetDlgItemText)(HWND, int, LPCWSTR);
#ifdef _WIN64
typedef WINUSERAPI LONG_PTR (WINAPI *UAPI_SetWindowLong)(HWND, int, LONG_PTR);
#else
typedef WINUSERAPI LONG (WINAPI *UAPI_SetWindowLong)(HWND, int, LONG);
#endif
typedef WINUSERAPI BOOL (WINAPI *UAPI_SetWindowText)(HWND, LPCWSTR);
typedef WINUSERAPI BOOL (WINAPI *UAPI_UnregisterClass)(LPCWSTR, HINSTANCE);
typedef WINUSERAPI BOOL (WINAPI *UAPI_WinHelp)(HWND, LPCWSTR, UINT, ULONG_PTR);
typedef WINBASEAPI BOOL (WINAPI *UAPI_WritePrivateProfileString)(LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR);
typedef WINUSERAPI int (WINAPIV *UAPI_wsprintf)(LPWSTR, LPCWSTR, ...);
typedef WINUSERAPI int (WINAPI *UAPI_wvsprintf)(LPWSTR, LPCWSTR, va_list arglist);

//
//  If a module needs SHGetPathFromIDList it will have to include shlobj.h, which it will need to
//  have the definition of an LPCITEMIDLIST anyway.  This prevents modules that don't need
//  the shell header, from having to include it just to use cmutoa.dll.
//
#ifdef _SHLOBJ_H_
typedef WINSHELLAPI BOOL (WINAPI *UAPI_SHGetPathFromIDList)(LPCITEMIDLIST, LPWSTR);
#endif 

typedef union _tagUAPIInit {
	struct
    {
        UAPI_CallWindowProc             *pCallWindowProcU;
        UAPI_CharLower                  *pCharLowerU;
        UAPI_CharNext                   *pCharNextU;
        UAPI_CharPrev                   *pCharPrevU;
        UAPI_CharUpper                  *pCharUpperU;
        UAPI_CompareString              *pCompareStringU;
        UAPI_CreateDialogParam          *pCreateDialogParamU;
        UAPI_CreateDirectory            *pCreateDirectoryU;
        UAPI_CreateEvent                *pCreateEventU;
        UAPI_CreateFile                 *pCreateFileU;
        UAPI_CreateFileMapping          *pCreateFileMappingU;
        UAPI_CreateMutex                *pCreateMutexU;
        UAPI_CreateProcess              *pCreateProcessU;
        UAPI_CreateWindowEx             *pCreateWindowExU;
        UAPI_DefWindowProc              *pDefWindowProcU;
        UAPI_DeleteFile                 *pDeleteFileU;
        UAPI_DialogBoxParam             *pDialogBoxParamU;
        UAPI_DispatchMessage            *pDispatchMessageU;
        UAPI_ExpandEnvironmentStrings   *pExpandEnvironmentStringsU;
        UAPI_FindResourceEx             *pFindResourceExU;
        UAPI_FindWindowEx               *pFindWindowExU;
        UAPI_GetClassLong               *pGetClassLongU;
        UAPI_GetDateFormat              *pGetDateFormatU;
        UAPI_GetDlgItemText             *pGetDlgItemTextU;
        UAPI_GetFileAttributes          *pGetFileAttributesU;
        UAPI_GetMessage                 *pGetMessageU;
        UAPI_GetModuleFileName          *pGetModuleFileNameU;
        UAPI_GetModuleHandle            *pGetModuleHandleU;
        UAPI_GetPrivateProfileInt       *pGetPrivateProfileIntU;
        UAPI_GetPrivateProfileString    *pGetPrivateProfileStringU;
        UAPI_GetStringTypeEx            *pGetStringTypeExU;
        UAPI_GetSystemDirectory         *pGetSystemDirectoryU;
        UAPI_GetTempFileName            *pGetTempFileNameU;
        UAPI_GetTempPath                *pGetTempPathU;
        UAPI_GetTimeFormat              *pGetTimeFormatU;
        UAPI_GetUserName                *pGetUserNameU;
        UAPI_GetVersionEx               *pGetVersionExU;
        UAPI_GetWindowLong              *pGetWindowLongU;
        UAPI_GetWindowText              *pGetWindowTextU;
        UAPI_GetWindowTextLength        *pGetWindowTextLengthU;
        UAPI_InsertMenu                 *pInsertMenuU;
        UAPI_IsDialogMessage            *pIsDialogMessageU;
        UAPI_LoadCursor                 *pLoadCursorU;
        UAPI_LoadIcon                   *pLoadIconU;
        UAPI_LoadImage                  *pLoadImageU;
        UAPI_LoadLibraryEx              *pLoadLibraryExU;
        UAPI_LoadMenu                   *pLoadMenuU;
        UAPI_LoadString                 *pLoadStringU;
        UAPI_lstrcat                    *plstrcatU;
        UAPI_lstrcmp                    *plstrcmpU;
        UAPI_lstrcmpi                   *plstrcmpiU;
        UAPI_lstrcpy                    *plstrcpyU;
        UAPI_lstrcpyn                   *plstrcpynU;
        UAPI_lstrlen                    *plstrlenU;
        UAPI_OpenEvent                  *pOpenEventU;
        UAPI_OpenFileMapping            *pOpenFileMappingU;
        UAPI_PeekMessage                *pPeekMessageU;
        UAPI_PostMessage                *pPostMessageU;
        UAPI_PostThreadMessage          *pPostThreadMessageU;
        UAPI_RegCreateKeyEx             *pRegCreateKeyExU;
        UAPI_RegDeleteKey               *pRegDeleteKeyU;
        UAPI_RegDeleteValue             *pRegDeleteValueU;
        UAPI_RegEnumKeyEx               *pRegEnumKeyExU;
        UAPI_RegisterClassEx            *pRegisterClassExU;
        UAPI_RegisterWindowMessage      *pRegisterWindowMessageU;
        UAPI_RegOpenKeyEx               *pRegOpenKeyExU;
        UAPI_RegQueryValueEx            *pRegQueryValueExU;
        UAPI_RegSetValueEx              *pRegSetValueExU;
        UAPI_SearchPath                 *pSearchPathU;
        UAPI_SendDlgItemMessage         *pSendDlgItemMessageU;
        UAPI_SendMessage                *pSendMessageU;
        UAPI_SetCurrentDirectory        *pSetCurrentDirectoryU;
        UAPI_SetDlgItemText             *pSetDlgItemTextU;
        UAPI_SetWindowLong              *pSetWindowLongU;
        UAPI_SetWindowText              *pSetWindowTextU;
        UAPI_UnregisterClass            *pUnregisterClassU;
        UAPI_WinHelp                    *pWinHelpU;
        UAPI_WritePrivateProfileString  *pWritePrivateProfileStringU;
        UAPI_wsprintf                   *pwsprintfU;
        UAPI_wvsprintf                  *pwvsprintfU;    
    };

	LPVOID *ppvUapiFun[80];

}UAPIINIT, *PUAPIINIT;




BOOL InitCmUToA(PUAPIINIT);
BOOL InitCmRasUtoA();
void FreeCmRasUtoA();


#endif // _CMUTOA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\comparestring.h ===
//+----------------------------------------------------------------------------
//
// File:     CompareString.h
//
// Module:   CMPROXY.DLL, CMROUTE.DLL, CMAK.EXE
//
// Synopsis: definitions for SafeCompareStringA and SafeCompareStringW.
//
//           Note that these functions are also present in CMUTIL.dll.  However,
//           cmutil is an inappropriate dependency for components that do not
//           sim-ship with it (this includes customactions and CMAK).
//
// Copyright (c) 1998-2002 Microsoft Corporation
//
// Author:   SumitC     Created     12-Sep-2001
//
//+----------------------------------------------------------------------------

#ifdef UNICODE
#define SafeCompareString   SafeCompareStringW
#else
#define SafeCompareString   SafeCompareStringA
#endif

int SafeCompareStringA(LPCSTR lpString1, LPCSTR lpString2);
int SafeCompareStringW(LPCWSTR lpString1, LPCWSTR lpString2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\icwprdver.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1998 Microsoft Corporation
//*********************************************************************
#include "pnpuverp.h"

#undef VER_PRODUCTNAME_STR
#define VER_PRODUCTNAME_STR		"Microsoft(R) Connection Manager"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\conact.h ===
//+----------------------------------------------------------------------------
//
// File:     conact.h
//
// Module:   CMAK.EXE and CMDIAL32.DLL
//
// Synopsis: Header file to describe the custom action execution states.
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created                         02/26/00
//
//+----------------------------------------------------------------------------

//
//  Enum to mask ConData.dwFlags
//
const int c_iNumCustomActionExecutionStates = 5;

enum CustomActionExecutionStates {
    ALL_CONNECTIONS = 0x0,
    DIRECT_ONLY = 0x1,
    ALL_DIALUP = 0x2,
    DIALUP_ONLY = 0x4,
    ALL_TUNNEL = 0x8
};
const DWORD c_dwLargestExecutionState = ALL_TUNNEL;

const UINT NONINTERACTIVE = 0x10;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\gppswithalloc.h ===
//+----------------------------------------------------------------------------
//
// File:     gppswithalloc.h
//
// Module:   CMDIAL32.DLL, CMAK.EXE
//
// Synopsis: GetPrivateProfileStringWithAlloc and AddAllKeysInCurrentSectionToCombo
//           are defined here
//
// Copyright (c) 2000-2001 Microsoft Corporation
//
// Author:   quintinb   Created    11/01/00
//
//+----------------------------------------------------------------------------
LPTSTR GetPrivateProfileStringWithAlloc(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszDefault, LPCTSTR pszFile);
void AddAllKeysInCurrentSectionToCombo(HWND hDlg, UINT uComboId, LPCTSTR pszSection, LPCTSTR pszFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\contable.h ===
//+----------------------------------------------------------------------------
//
// File:     contable.h
//
// Module:   CMCONTBL.LIB
//
// Synopsis: Header file declaring CConnectionTable
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball    Created    02/02/98
//
//+----------------------------------------------------------------------------

#include <ras.h>
#include <raserror.h>  

const int MAX_CM_CONNECTIONS = 32;

//
// Data types used by Connection Table and clients
//

typedef enum _CmConnectState {
       CM_DISCONNECTED,    // unused entry
       CM_DISCONNECTING,   // in the process of disconnecting
       CM_RECONNECTPROMPT, // prompting user to reconnect
       CM_CONNECTING,      // actively connecting 
       CM_CONNECTED,       // fully connected
} CmConnectState;

typedef struct Cm_Connection
{
	DWORD dwUsage;        		            // Reference count
    TCHAR szEntry[RAS_MaxEntryName + 1];    // Name of entry/profile 
    BOOL fAllUser;                          // Is the entry "All user"
	CmConnectState CmState;		            // Current state 
	HRASCONN hDial;		                    // Dial-up RAS handle
	HRASCONN hTunnel;		                // Tunnel RAS handle
} CM_CONNECTION, * LPCM_CONNECTION;

typedef struct Cm_Connection_Table
{
	HWND hwndCmMon;                 // the CMMON32.EXE window handle
	CM_CONNECTION Connections[MAX_CM_CONNECTIONS];  // a list of connections.
} CM_CONNECTION_TABLE, * LPCM_CONNECTION_TABLE;

//
// Class declaration
//

class CConnectionTable
{

private:

    HANDLE m_hMap;                              // Handle of file mapping 
    LPCM_CONNECTION_TABLE m_pConnTable;         // Pointer to mapped view of file
    BOOL m_fLocked;                             // Internal error checking
    HANDLE m_hEvent;                            // Event handle for locking
	
protected:

    HRESULT LockTable();

    HRESULT UnlockTable();
   
    HRESULT FindEntry(LPCTSTR pszEntry, 
        LPINT piID);

    HRESULT FindEntry(HRASCONN hRasConn, 
        LPINT piID);
    
    HRESULT FindUnused(LPINT piID);

public:

    CConnectionTable();                         // ctor

    ~CConnectionTable();                        // dtor
    
    HRESULT Create();                      // creates a new table, fails if existing

    HRESULT Open();                        // opens an existing table
   
    HRESULT Close();                       // closes an existing table
 
    HRESULT AddEntry(LPCTSTR pszEntry, BOOL fAllUser); // adds a connection entry to the table

    HRESULT RemoveEntry(LPCTSTR pszEntry);       // removes a connection entry from the table

    HRESULT GetMonitorWnd(HWND *phWnd);         // fills phWnd with HWND of CMMON in the table

    HRESULT SetMonitorWnd(HWND hwndMonitor);    // assigns the hwnd of CMMON in the table

    HRESULT GetEntry(LPCTSTR pszEntry,           // Fills the specified CM_CONNECTION structure
        LPCM_CONNECTION pConnection);           // with the data for pszEntry

    HRESULT GetEntry(HRASCONN hRasConn,          // Fills the specified CM_CONNECTION structure
        LPCM_CONNECTION pConnection);           // with the data for hRasConn

    HRESULT SetConnected(LPCTSTR pszEntry,       // sets the connection to the connected state, hDial required 
        HRASCONN hDial,
        HRASCONN hTunnel);

    HRESULT SetDisconnecting(LPCTSTR pszEntry);  // sets the connection to the disconnected state

    HRESULT SetPrompting(LPCTSTR pszEntry);      // sets the connection to the prompting state 

    HRESULT ClearEntry(LPCTSTR pszEntry);        // clears the entry regardless of usage count
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\cversion.h ===
//+----------------------------------------------------------------------------
//
// File:     cversion.h
//
// Module:   CMSETUP.LIB
//
// Synopsis: Definition of CVersion, a utility class that wraps up the
//           functionality of detecting the version of a given module.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created     09/14/98
//
//+----------------------------------------------------------------------------
#ifndef __CVERSION_H
#define __CVERSION_H

#include <windows.h>
#include <tchar.h>

const int c_iShiftAmount = ((sizeof(DWORD)/2) * 8);

class CVersion 
{
public:	//	Public Methods
	CVersion(LPTSTR szFile);
	CVersion();
	~CVersion();

	BOOL IsPresent();
    BOOL GetBuildNumberString(LPTSTR szStr);
	BOOL GetVersionString(LPTSTR szStr);
	BOOL GetFilePath(LPTSTR szStr);

	DWORD GetVersionNumber(); // return Major Version in Hiword, Minor in Loword
    DWORD GetBuildAndQfeNumber(); // return Build number in Hiword, QFE in Loword
    DWORD GetMajorVersionNumber();
    DWORD GetMinorVersionNumber();
    DWORD GetBuildNumber();
    DWORD GetQfeNumber();
    DWORD GetLCID();

protected:

	//
	//	Protected Methods
	//
	void	Init();
    
	//
	//	Member Variables
	//
	TCHAR m_szPath[MAX_PATH+1];
    DWORD m_dwVersion;
    DWORD m_dwBuild;
    DWORD m_dwLCID;
	BOOL  m_bIsPresent;

};

//
//  This function doesn't belong to this class but makes the GetLCID function more useful, thus
//  I have included it here.
//
BOOL ArePrimaryLangIDsEqual(DWORD dwLCID1, DWORD dwLCID2);

#endif	// __CVERSION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\dynamiclib.h ===
//+----------------------------------------------------------------------------
//
// File:     dynamiclib.h
//
// Module:   Various Connection Manager modules (CMDIAL32.DLL, CMMON32.EXE, etc)
//
// Synopsis: Definition of CDynamicLibrary, a utility class that helps with
//           the dynamic loading of a library and the getting of proc 
//           addresses from that library.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun    Created    02/17/98
//
//+----------------------------------------------------------------------------

#ifndef DYNAMICLIB_H
#define DYNAMICLIB_H

//
// Define A_W as A for ansi and W for unicode
//
#ifdef UNICODE
#define A_W  "W"
#else
#define A_W  "A"
#endif // UNICODE

//
//  Define LoadLibraryExU since not everyone is using the UAPI's yet
//
#ifndef _CMUTOA

#ifdef UNICODE
#define LoadLibraryExU  LoadLibraryExW
#else
#define LoadLibraryExU  LoadLibraryExA
#endif // UNICODE

#endif // _CMUTOA

//+---------------------------------------------------------------------------
//
//	class :	CDynamicLibrary
//
//	Synopsis:	A class that will unload the library on destructor
//
//	History:	fengsun created		2/17/97
//
//----------------------------------------------------------------------------

class CDynamicLibrary
{
public:
    CDynamicLibrary();
    CDynamicLibrary(const TCHAR* lpLibraryName);
    ~CDynamicLibrary();

    BOOL Load(const TCHAR* lpLibraryName);
    void Unload();

    BOOL IsLoaded() const;
    BOOL EnsureLoaded(const TCHAR* lpLibraryName);
    HINSTANCE GetInstance() const;

    FARPROC GetProcAddress(const char* lpProcName) const; 

protected:
    HINSTANCE m_hInst; // The instance handle returned by LoadLibrary
};

//
// Constructor
//
inline CDynamicLibrary::CDynamicLibrary() :m_hInst(NULL) {}

//
// Constructor that calls LoadLibrary
//
inline CDynamicLibrary::CDynamicLibrary(const TCHAR* lpLibraryName)
{
    m_hInst = NULL;
    Load(lpLibraryName);
}


//
// Destructor that automatic FreeLibrary
//
inline CDynamicLibrary::~CDynamicLibrary()
{
    Unload();
}

//
// Call LoadLibrary
//
inline BOOL CDynamicLibrary::Load(const TCHAR* lpLibraryName)
{
    MYDBGASSERT(m_hInst == NULL);
    MYDBGASSERT(lpLibraryName);

	CMTRACE1(TEXT("CDynamicLibrary - Loading library - %s"), lpLibraryName);

    m_hInst = LoadLibraryExU(lpLibraryName, NULL, 0);

#ifdef DEBUG
    if (!m_hInst)
    {
        CMTRACE1(TEXT("CDynamicLibrary - LoadLibrary failed - GetLastError() = %u"), GetLastError());
    }
#endif

    return m_hInst != NULL;
}

//
// Call FreeLibrary
//
inline void CDynamicLibrary::Unload()
{
    if (m_hInst)
    {
        FreeLibrary(m_hInst);
        m_hInst = NULL;
    }
}


//
// Whether the library is successfully loaded
//
inline BOOL CDynamicLibrary::IsLoaded() const
{
    return m_hInst != NULL;
}

//
// Retrieve the instance handle
//
inline HINSTANCE CDynamicLibrary::GetInstance() const
{
    return m_hInst;
}

//
// call ::GetProcAddress on m_hInst
//
inline FARPROC CDynamicLibrary::GetProcAddress(const char* lpProcName) const
{
    MYDBGASSERT(m_hInst);

    if (m_hInst)
    {
        return ::GetProcAddress(m_hInst, lpProcName);
    }

    return NULL;
}

//
// Load the library, if not loaded yet,
// Note, we do not check the consistence of lpLibraryName.  Use caution with this function
//
inline BOOL CDynamicLibrary::EnsureLoaded(const TCHAR* lpLibraryName)
{
    MYDBGASSERT(lpLibraryName);
    if (m_hInst == NULL)
    {
        m_hInst = LoadLibraryEx(lpLibraryName, NULL, 0);
    }

    return m_hInst != NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\inetopt.h ===
//+----------------------------------------------------------------------------
//
// File:     inetopt.h
//
// Module:   CMDL32.EXE and CMROUTE.DLL
//
// Synopsis: Header file for shared APIs to set WinInet options
//
// Copyright (c) 2001 Microsoft Corporation
//
// Author:   quintinb   Created     08/22/01
//
//+----------------------------------------------------------------------------
#ifndef _INETOPT_INC_
#define _INETOPT_INC_

void SuppressInetAutoDial(HINTERNET hInternet);
BOOL SetInetStateConnected(HINTERNET hInternet);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\modelessdlg.h ===
//+----------------------------------------------------------------------------
//
// File:     modlessdlg.h
//
// Module:   CMDIAL32.DLL and CMMON32.EXE
//
// Synopsis: Definition of the class CModelessDlg
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:   nickball    Created file   03/22/00
//
//+----------------------------------------------------------------------------

#ifndef MODELESSDLG_H
#define MODELESSDLG_H

#include "modaldlg.h"

//+---------------------------------------------------------------------------
//
//	class CModelessDlg
//
//	Description: A general modeless dialog, call create to CreateDialog
//
//	History:	fengsun	        Created		    10/30/97
//              nickball        Added Flash     03/22/00
//
//----------------------------------------------------------------------------
class CModelessDlg :public CModalDlg
{
public:
    CModelessDlg(const DWORD* pHelpPairs = NULL, const TCHAR* lpszHelpFile = NULL)
        : CModalDlg(pHelpPairs, lpszHelpFile){};

    //
    // Create the dialog box
    //
    HWND Create(HINSTANCE hInstance, 
                LPCTSTR lpTemplateName,
                HWND hWndParent);

    HWND Create(HINSTANCE hInstance, 
                DWORD dwTemplateId,
                HWND hWndParent);
protected:
    virtual void OnOK() {DestroyWindow(m_hWnd);}          // WM_COMMAND, IDOK
    virtual void OnCancel(){DestroyWindow(m_hWnd);}      // WM_COMMAND, IDCANCEL
    void Flash();
};

inline HWND CModelessDlg::Create(HINSTANCE hInstance, DWORD dwTemplateId, HWND hWndParent)
{
    return Create(hInstance, (LPCTSTR)ULongToPtr(dwTemplateId), hWndParent);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\mutex.h ===
//+----------------------------------------------------------------------------
//
// File:     mutex.h
//
// Module:   CMSETUP.LIB, CMDIAL32.DLL, CMDL32.EXE
//
// Synopsis: Definition of the class CNamedMutex
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun    Created    02/26/98
//
//+----------------------------------------------------------------------------


#ifndef __CM_MUTEXT_H
#define __CM_MUTEXT_H

#include <windows.h>
#include "cmdebug.h"

//+---------------------------------------------------------------------------
//
//	class CNamedMutex
//
//	Description: A class to lock/unlock a named mutex
//               The destructor releases the mutex.
//
//	History:	fengsun	Created		2/19/98
//
//----------------------------------------------------------------------------

class CNamedMutex
{
public:
    CNamedMutex() {m_hMutex = NULL; m_fOwn = FALSE;}
    ~CNamedMutex() {Unlock();}

    BOOL Lock(LPCTSTR lpName, BOOL fWait = FALSE, DWORD dwMilliseconds = INFINITE, BOOL fNoAbandon = FALSE);
    void Unlock();
protected:
    HANDLE m_hMutex; // the handle of the mutex
    BOOL m_fOwn;     // whther we own the mutex
};

#endif //__CM_MUTEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\inetcfg.h ===
//*******************************************************************
//
//  Copyright (c) 1996-1998 Microsoft Corporation
//
//  *** N O T   F O R   E X T E R N A L   R E L E A S E *******
//  This header file is not intended for distribution outside Microsoft.
//
//  FILE: INETCFG.H
//
//  PURPOSE:  Contains API's exported from inetcfg.dll and structures
//            required by those functions. 
//            Note:  Definitions in this header file require RAS.H.
//
//*******************************************************************

#ifndef _INETCFG_H_
#define _INETCFG_H_

#ifndef UNLEN
#include <lmcons.h>
#endif

// Generic HRESULT error code
#define ERROR_INETCFG_UNKNOWN 0x20000000L

#define MAX_EMAIL_NAME          64
#define MAX_EMAIL_ADDRESS       128
#define MAX_LOGON_NAME          UNLEN
#define MAX_LOGON_PASSWORD      PWLEN
#define MAX_SERVER_NAME         64  // max length of DNS name per RFC 1035 +1

// Flags for dwfOptions

// install Internet mail
#define INETCFG_INSTALLMAIL           0x00000001
// Invoke InstallModem wizard if NO MODEM IS INSTALLED
#define INETCFG_INSTALLMODEM          0x00000002
// install RNA (if needed)
#define INETCFG_INSTALLRNA            0x00000004
// install TCP (if needed)
#define INETCFG_INSTALLTCP            0x00000008
// connecting with LAN (vs modem)
#define INETCFG_CONNECTOVERLAN        0x00000010
// Set the phone book entry for autodial
#define INETCFG_SETASAUTODIAL         0x00000020
// Overwrite the phone book entry if it exists
// Note: if this flag is not set, and the entry exists, a unique name will
// be created for the entry.
#define INETCFG_OVERWRITEENTRY        0x00000040
// Do not show the dialog that tells the user that files are about to be installed,
// with OK/Cancel buttons.
#define INETCFG_SUPPRESSINSTALLUI     0x00000080
// Check if TCP/IP file sharing is turned on, and warn user to turn it off.
// Reboot is required if the user turns it off.
//#define INETCFG_WARNIFSHARINGBOUND    0x00000100
// Check if TCP/IP file sharing is turned on, and force user to turn it off.
// If user does not want to turn it off, return will be ERROR_CANCELLED
// Reboot is required if the user turns it off.
//#define INETCFG_REMOVEIFSHARINGBOUND  0x00000200
// Indicates that this is a temporary phone book entry
// In Win3.1 an icon will not be created
#define INETCFG_TEMPPHONEBOOKENTRY    0x00000400
// Show the busy dialog while checking system configuration
//#define INETCFG_SHOWBUSYANIMATION     0x00000800

//
// Chrisk 5/8/97
// Note: the next three switches are only valid for InetNeedSystemComponents
// Check if LAN adapter is installed and bound to TCP
//
#define INETCFG_INSTALLLAN            0x00001000

//
// Check if DIALUP adapter is installed and bound to TCP
//
#define INETCFG_INSTALLDIALUP         0x00002000

//
// Check to see if TCP is installed requardless of binding
//
#define INETCFG_INSTALLTCPONLY        0x00004000

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

// constants for INETCLIENTINFO.dwFlags

#define INETC_LOGONMAIL     0x00000001
#define INETC_LOGONNEWS     0x00000002
#define INETC_LOGONDIRSERV  0x00000004

// Struct INETCLIENTINFO
//
// This structure is used when getting and setting the internet
// client parameters
//
// The members are as follows:
//
//  dwSize
//    size of this structure, for future versioning
//    this member should be set before passing the structure to the DLL
//  dwFlags
//    miscellaneous flags
//    see definitions above
//  szEMailName
//    user's internet email name
//  szEMailAddress
//    user's internet email address
//	***Note: the following three fields are outdated, and should only be used by old legacy code.
//  ***      new code should use szIncomingMail* and iIncomingProtocol fields.
//  szPOPLogonName
//    user's internet mail server logon name 
//  szPOPLogonPassword
//    user's internet mail server logon password
//  szPOPServer
//    user's internet mail POP3 server
//  szSMTPServer
//    user's internet mail SMTP server
//  szNNTPLogonName
//    user's news server logon name
//  szNNTPLogonPassword
//    user's news server logon password
//  szNNTPServer
//    user's news server
//  ** End of original 1.0 structure.
//	??/??/96 ValdonB
//  szNNTPName
//    user's friendly name to include in NNTP posts.(?? Valdon?)
//  szNNTPAddress
//    user's reply-to email address for NNTP posts.(?? Valdon?)
//  11/23/96  jmazner Normandy #8504
//  iIncomingProtocol
//	  user's choice of POP3 or IMAP4 protocol for incoming mail
//	  Holds the enum values defined in ACCTTYPE from imact.h//
//  szIncomingMailLogonName
//    user's internet mail server logon name 
//  szIncomingMailLogonPassword
//    user's internet mail server logon password
//  szIncomingMailServer
//    user's internet mail POP3 server
//  12/15/96	jmazner	
//  fMailLogonSPA
//	  Use Sicily/SPA/DPA for the incoming mail server
//  fNewsLogonSPA
//	  Use Sicily/SPA/DPA for the news server
//	2/4/96 jmazner -- LDAP functionality
//	szLDAPLogonName
//	szLDAPLogonPassword
//	szLDAPServer
//	fLDAPLogonSPA
//	fLDAPResolve

  typedef struct tagINETCLIENTINFO
  {
    DWORD   dwSize;
    DWORD   dwFlags;
    CHAR    szEMailName[MAX_EMAIL_NAME + 1];
    CHAR    szEMailAddress[MAX_EMAIL_ADDRESS + 1];
    CHAR    szPOPLogonName[MAX_LOGON_NAME + 1];
    CHAR    szPOPLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szPOPServer[MAX_SERVER_NAME + 1];
    CHAR    szSMTPServer[MAX_SERVER_NAME + 1];
    CHAR    szNNTPLogonName[MAX_LOGON_NAME + 1];
    CHAR    szNNTPLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szNNTPServer[MAX_SERVER_NAME + 1];
	// end of version 1.0 structure;
	// extended 1.1 structure includes the following fields:
    CHAR    szNNTPName[MAX_EMAIL_NAME + 1];
    CHAR    szNNTPAddress[MAX_EMAIL_ADDRESS + 1];
	int		iIncomingProtocol;
    CHAR    szIncomingMailLogonName[MAX_LOGON_NAME + 1];
    CHAR    szIncomingMailLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szIncomingMailServer[MAX_SERVER_NAME + 1];
	BOOL	fMailLogonSPA;
	BOOL	fNewsLogonSPA;
    CHAR    szLDAPLogonName[MAX_LOGON_NAME + 1];
    CHAR    szLDAPLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szLDAPServer[MAX_SERVER_NAME + 1];
	BOOL	fLDAPLogonSPA;
	BOOL	fLDAPResolve;

  } INETCLIENTINFO, *PINETCLIENTINFO, FAR *LPINETCLIENTINFO;


// Function prototypes

//*******************************************************************
//
//  FUNCTION:   InetGetClientInfo
//
//  PURPOSE:    This function will get the internet client params
//              from the registry
//
//  PARAMETERS: lpClientInfo - on return, this structure will contain
//              the internet client params as set in the registry.
//              lpszProfileName - Name of client info profile to
//              retrieve.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetGetClientInfo(
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFO  lpClientInfo);


//*******************************************************************
//
//  FUNCTION:   InetSetClientInfo
//
//  PURPOSE:    This function will set the internet client params
//
//  PARAMETERS: lpClientInfo - pointer to struct with info to set
//              in the registry.
//              lpszProfileName - Name of client info profile to
//              modify.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetSetClientInfo(
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFO  lpClientInfo);


//*******************************************************************
//
//  FUNCTION:   InetConfigSystem
//
//  PURPOSE:    This function will install files that are needed
//              for internet access (such as TCP/IP and RNA) based
//              the state of the options flags.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install Internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetConfigSystem(
  HWND    hwndParent,          
  DWORD   dwfOptions,         
  LPBOOL  lpfNeedsRestart);  


//*******************************************************************
//
//  FUNCTION:   InetConfigSystemFromPath
//
//  PURPOSE:    This function will install files that are needed
//              for internet access (such as TCP/IP and RNA) based
//              the state of the options flags and from the given [ath.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install Internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//              lpszSourcePath - full path of location of files to install.  If
//              this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetConfigSystemFromPath(
  HWND hwndParent,
  DWORD dwfOptions,
  LPBOOL lpfNeedsRestart,
  LPCSTR lpszSourcePath);


//*******************************************************************
//
//  FUNCTION:   InetConfigClient
//
//  PURPOSE:    This function requires a valid phone book entry name
//              (unless it is being used just to set the client info).
//              If lpRasEntry points to a valid RASENTRY struct, the phone
//              book entry will be created (or updated if it already exists)
//              with the data in the struct.
//              If username and password are given, these
//              will be set as the dial params for the phone book entry.
//              If a client info struct is given, that data will be set.
//              Any files (ie TCP and RNA) that are needed will be
//              installed by calling InetConfigSystem().
//              This function will also perform verification on the device
//              specified in the RASENTRY struct.  If no device is specified,
//              the user will be prompted to install one if there are none
//              installed, or they will be prompted to choose one if there
//              is more than one installed.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              lpszPhonebook - name of phone book to store the entry in
//              lpszEntryName - name of phone book entry to be
//              created or modified
//              lpRasEntry - specifies a RASENTRY struct that contains
//              the phone book entry data for the entry lpszEntryName
//              lpszUsername - username to associate with the phone book entry
//              lpszPassword - password to associate with the phone book entry
//              lpszProfileName - Name of client info profile to
//              retrieve.  If this is NULL, the default profile is used.
//              lpINetClientInfo - client information
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install Internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.  Note that if
//                                       no modem is installed and this flag
//                                       is not set, the function will fail
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_SETASAUTODIAL - Set the phone book entry for autodial
//                INETCFG_OVERWRITEENTRY - Overwrite the phone book entry if it
//                                         exists.  Note: if this flag is not
//                                         set, and the entry exists, a unique
//                                         name will be created for the entry.
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetConfigClient(
  HWND              hwndParent,         
  LPCSTR            lpszPhonebook,
  LPCSTR            lpszEntryName,
  LPRASENTRY        lpRasEntry,         
  LPCSTR            lpszUsername,       
  LPCSTR            lpszPassword,       
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFO  lpINetClientInfo,   
  DWORD             dwfOptions,                     
  LPBOOL            lpfNeedsRestart);              


//*******************************************************************
//
//  FUNCTION:   InetGetAutodial
//
//  PURPOSE:    This function will get the autodial settings from the registry.
//
//  PARAMETERS: lpfEnable - on return, this will be TRUE if autodial
//              is enabled
//              lpszEntryName - on return, this buffer will contain the 
//              name of the phone book entry that is set for autodial
//              cbEntryNameSize - size of buffer for phone book entry name
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetGetAutodial(
  LPBOOL  lpfEnable,     
  LPSTR   lpszEntryName,  
  DWORD   cbEntryNameSize);


//*******************************************************************
//
//  FUNCTION:   InetSetAutodial
//
//  PURPOSE:    This function will set the autodial settings in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, autodial will be enabled.
//                        If set to FALSE, autodial will be disabled.
//              lpszEntryName - name of the phone book entry to set
//                              for autodial.  If this is "", the
//                              entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI   InetSetAutodial(
  BOOL    fEnable,       
  LPCSTR  lpszEntryName); 


//*******************************************************************
//
//  FUNCTION:   InetSetProxy
//
//  PURPOSE:    This function will set the proxy settings in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//              If set to FALSE, proxy will be disabled.
//              lpszServer - name of the proxy server.  If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//              lpszOverride - proxy override. If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI   InetSetProxy(
  BOOL    fEnable,
  LPCSTR  lpszServer,
  LPCSTR  lpszOverride);

//*******************************************************************
//
//  FUNCTION:   InetGetProxy
//
//  PURPOSE:    This function will get the proxy settings from the registry.
//
//  PARAMETERS: lpfEnable - on return, this will be TRUE if proxy
//              is enabled
//              lpszServer - on return, this buffer will contain the 
//              name of the proxy server
//              cbServer - size of buffer for proxy server name
//              lpszOverride - on return, this buffer will contain the 
//              name of the proxy server
//              cbOverride - size of buffer for proxy override
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI   InetGetProxy(
  LPBOOL  lpfEnable,
  LPSTR   lpszServer,
  DWORD   cbServer,
  LPSTR   lpszOverride,
  DWORD   cbszOverride);

//*******************************************************************
//
//	FUNCTION:	InetStartServices
//
//	PURPOSE:	This function guarentees that RAS services are running
//
//	PARAMETERS:	none
//
//	RETURNS		ERROR_SUCCESS - if the services are enabled and running
//
//*******************************************************************
HRESULT WINAPI  InetStartServices();

//*******************************************************************
//
//	Function:	IsSmartStart
//
//	Synopsis:	This function will determine if the ICW should be run.  The
//				decision is made based on the current state of the user's machine.
//				
//	Arguments:	none
//
//	Returns:	TRUE - run ICW; FALSE - quit now
//
//	History:	5/8/97	ChrisK	Created
//
//*******************************************************************
DWORD WINAPI IsSmartStart();

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //_INETCFG_H_#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\linkdll.h ===
//+----------------------------------------------------------------------------
//
// File:     linkdll.h
//
// Module:   CMCFG32.DLL, CMDIAL32.DLL, CMSECURE.LIB, AND MIGRATE.DLL
//
// Synopsis: Header for linkage functions LinkToDll and BindLinkage.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------
BOOL LinkToDll(HINSTANCE *phInst, LPCSTR pszDll, LPCSTR *ppszPfn, void **ppvPfn);
BOOL BindLinkage(HINSTANCE hInstDll, LPCSTR *ppszPfn, void **ppvPfn);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\modaldlg.h ===
//+----------------------------------------------------------------------------
//
// File:     modaldlg.h
//
// Module:   CMDIAL32.DLL and CMMON32.EXE
//
// Synopsis: Definition of the classes CWindowWithHelp, CModalDlg
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun    Created    02/17/98
//
//+----------------------------------------------------------------------------

#ifndef MODALDLG_H
#define MODALDLG_H

#include "CmDebug.h"
//+---------------------------------------------------------------------------
//
//	class CWindowWithHelp
//
//	Description: A general window class that has context help
//
//	History:	fengsun	Created		10/30/97
//
//----------------------------------------------------------------------------

class CWindowWithHelp
{
public:
    CWindowWithHelp(const DWORD* pHelpPairs, const TCHAR* lpszHelpFile = NULL) ;
    ~CWindowWithHelp();
	HWND GetHwnd() const { return m_hWnd;}
    void SetHelpFileName(const TCHAR* lpszHelpFile);

protected:
    HWND m_hWnd;
    const DWORD* m_pHelpPairs; // pairs of <resource ID, help ID>
    LPTSTR m_lpszHelpFile; // the help file name

    void OnHelp(const HELPINFO* pHelpInfo); // WM_HELP
    BOOL OnContextMenu( HWND hWnd, POINT& pos ); // WM_CONTEXTMENU

    BOOL HasContextHelp(HWND hWndCtrl) const;

public:
#ifdef DEBUG
    void AssertValid()
    {
        MYDBGASSERT(m_hWnd == NULL || IsWindow(m_hWnd));
    }
#endif

};

//+---------------------------------------------------------------------------
//
//	class CModalDlg
//
//	Description: A general modal dialog class
//
//	History:	fengsun	Created		10/30/97
//
//----------------------------------------------------------------------------

class CModalDlg :public CWindowWithHelp
{
public:
    CModalDlg(const DWORD* pHelpPairs = NULL, const TCHAR* lpszHelpFile = NULL) 
        : CWindowWithHelp(pHelpPairs, lpszHelpFile){};

    //
    // Create the dialog box
    //
    INT_PTR DoDialogBox(HINSTANCE hInstance, 
                    LPCTSTR lpTemplateName,
                    HWND hWndParent);

    INT_PTR DoDialogBox(HINSTANCE hInstance, 
                    DWORD dwTemplateId,
                    HWND hWndParent);


    virtual BOOL OnInitDialog();  // WM_INITDIALOG
    virtual void OnOK();          // WM_COMMAND, IDOK
    virtual void OnCancel();      // WM_COMMAND, IDCANCEL

    virtual DWORD OnOtherCommand(WPARAM wParam, LPARAM lParam );
    virtual DWORD OnOtherMessage(UINT uMsg, WPARAM wParam, LPARAM lParam );

protected:
    static INT_PTR CALLBACK ModalDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam);
};

//
// Inline functions
//
inline INT_PTR CModalDlg::DoDialogBox(HINSTANCE hInstance, DWORD dwTemplateId, HWND hWndParent)
{
    return DoDialogBox(hInstance, (LPCTSTR)ULongToPtr(dwTemplateId), hWndParent);
}

inline BOOL CModalDlg::OnInitDialog()
{
    //
    // set the default keyboard focus
    //
    return TRUE;
}

inline void CModalDlg::OnOK()
{
	EndDialog(m_hWnd, IDOK);
}

inline void CModalDlg::OnCancel()
{
	EndDialog(m_hWnd, IDCANCEL);
}

inline DWORD CModalDlg::OnOtherCommand(WPARAM , LPARAM  )
{
    return FALSE;
}

inline DWORD CModalDlg::OnOtherMessage(UINT , WPARAM , LPARAM  )
{
    return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\oharestr.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//	OHARESTR.H - string defines for O'Hare components
//			
//

//	HISTORY:
//	
//	3/10/95		jeremys		Created.
//


#ifndef _OHARESTR_H_
#define _OHARESTR_H_

// path to RNA values (under HKEY_CURRENT_USER)
#define REGSTR_PATH_REMOTEACCESS	"RemoteAccess"

// string value under HKCU\REGSTR_PATH_REMOTEACCESS that contains name of
// connectoid used to connect to internet
#define REGSTR_VAL_INTERNETPROFILE	"InternetProfile"
#define REGSTR_VAL_BKUPINTERNETPROFILE	"BackupInternetProfile"

// path to global internet settings (also under HKEY_CURRENT_USER)
#define REGSTR_PATH_INTERNET_SETTINGS REGSTR_PATH_SETUP "\\Internet Settings"

// values under HKCY\REGSTR_PATH_INTERNET_SETTINGS

// 4-byte REG_BINARY, autodialing is enabled if this value is present and
// non-zero, disabled otherwise
#define REGSTR_VAL_ENABLEAUTODIAL 		"EnableAutodial"
#define REGSTR_VAL_ENABLEAUTODISCONNECT	"EnableAutodisconnect"
#define REGSTR_VAL_ENABLESECURITYCHECK	"EnableSecurityCheck"

// 4-byte REG_BINARY containing number of minutes of idle time to allow
// before autodisconnect.  Autodisconnect is disabled if this value is zero
// or not present.
#define REGSTR_VAL_DISCONNECTIDLETIME	"DisconnectIdleTime"

// class name for window to receive Winsock activity messages
#define AUTODIAL_MONITOR_CLASS_NAME	"MS_AutodialMonitor"

// name of connectoid-specific autodial handler dll and function
#define REGSTR_VAL_AUTODIALDLLNAME		"AutodialDllName"
#define REGSTR_VAL_AUTODIALFCNNAME		"AutodialFcnName"

// proxy settings
#define REGSTR_VAL_PROXYENABLE          "ProxyEnable"
#define REGSTR_VAL_PROXYSERVER          "ProxyServer"
#define REGSTR_VAL_PROXYOVERRIDE        "ProxyOverride"

// access medium (modem, LAN, [etc?])
#define REGSTR_VAL_ACCESSMEDIUM			"AccessMedium"

// access type (MSN, other)
#define REGSTR_VAL_ACCESSTYPE			"AccessType"

#endif // _OHARESTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\processcmdln.h ===
//+----------------------------------------------------------------------------
//
// File:     processcmdln.h
//
// Module:   CMSETUP.LIB
//
// Synopsis: Definition of the CProcessCmdLn class.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------

#ifndef _CM_PROCESSCMDLN_H_
#define _CM_PROCESSCMDLN_H_

#include <windows.h>
#include "cfilename.h"
#include "mutex.h"

//
//  Command Line struct for storing cmd line flags
//

typedef struct _ArgStruct
{
	TCHAR* pszArgString;
	DWORD dwFlagModifier;
} ArgStruct;

//
//  Command Line State enumeration taken from Icm.h
//

typedef enum _CMDLN_STATE
{
    CS_END_SPACE,   // done handling a space
    CS_BEGIN_QUOTE, // we've encountered a begin quote
    CS_END_QUOTE,   // we've encountered a end quote
    CS_CHAR,        // we're scanning chars
    CS_DONE
} CMDLN_STATE;

class CProcessCmdLn
{

public:
    CProcessCmdLn(UINT NumSwitches, ArgStruct* pArrayOfArgStructs, BOOL bSkipFirstToken, BOOL bBlankCmdLnOkay);
    ~CProcessCmdLn();

    BOOL GetCmdLineArgs(IN LPTSTR pszCmdln, OUT LPDWORD pdwFlags, OUT LPTSTR pszPath, UINT uPathStrLimit);

private:    
    UINT m_NumSwitches;
    BOOL m_bSkipFirstToken;
    BOOL m_bBlankCmdLnOkay;
    ArgStruct* m_CommandLineSwitches;

    BOOL IsValidSwitch(LPCTSTR pszSwitch, LPDWORD pdwFlags);
    BOOL IsValidFilePath(LPCTSTR pszFile);
    BOOL EnsureFullFilePath(LPTSTR pszFile, UINT uNumChars);
    BOOL CheckIfValidSwitchOrPath(LPCTSTR pszToken, LPDWORD pdwFlags, 
                                  BOOL* pbFoundPath, LPTSTR pszPath);
};


#endif  //_CM_PROCESSCMDLN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\setupmem.h ===
//+----------------------------------------------------------------------------
//
// File:     setupmem.h
//
// Module:   CMSETUP.LIB
//
// Synopsis: Memory utility functions taken from cmutil.  Bare minimum of functionality
//           used in Cmutil, but gives a simple Heapalloc wrapper.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created	10-6-98
//
//+----------------------------------------------------------------------------

#ifndef __SETUPMEM_H
#define __SETUPMEM_H
//+----------------------------------------------------------------------------
// definitions
//+----------------------------------------------------------------------------
#ifdef DEBUG
extern LONG    g_lMallocCnt;
#endif

void *CmRealloc(void *pvPtr, size_t nBytes);
void *CmMalloc(size_t nBytes);
void CmFree(void *pvPtr);
void EndDebugMemory();

#endif //__SETUPMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\pwutil.h ===
//+----------------------------------------------------------------------------
//
// File:     pwutil.h
//
// Module:   CMDIAL32.DLL, CMCFG32.DLL, AND MIGRATE.DLL
//
// Synopsis: Header for pwutil functions
//           Simple encryption functions borrowed from RAS
//
// Copyright (c) 1994-1999 Microsoft Corporation
//
// Author:   nickball    Created    08/03/99
//
//+----------------------------------------------------------------------------

#ifndef CM_PWUTIL_H_
#define CM_PWUTIL_H_



VOID
CmDecodePasswordA(
    CHAR* pszPassword
    );

VOID
CmDecodePasswordW(
    WCHAR* pszPassword
    );

VOID
CmEncodePasswordA(
    CHAR* pszPassword
    );

VOID
CmEncodePasswordW(
    WCHAR* pszPassword
    );

VOID
CmWipePasswordA(
    CHAR* pszPassword
    );

VOID
CmWipePasswordW(
    WCHAR* pszPassword
    );

PVOID CmSecureZeroMemory(IN PVOID ptr, IN SIZE_T cnt);

#ifdef UNICODE
#define CmDecodePassword  CmDecodePasswordW
#define CmEncodePassword  CmEncodePasswordW
#define CmWipePassword    CmWipePasswordW
#else
#define CmDecodePassword  CmDecodePasswordA
#define CmEncodePassword  CmEncodePasswordA
#define CmWipePassword    CmWipePasswordA
#endif



#ifdef _ICM_INC // Only include this code in cmdial32.dll

#include "dynamiclib.h"
#include <wincrypt.h>
#include <cmutil.h>
#include "pwd_str.h"

typedef BOOL (WINAPI *fnCryptProtectDataFunc)(DATA_BLOB*, LPCWSTR, DATA_BLOB*, PVOID, CRYPTPROTECT_PROMPTSTRUCT*, DWORD, DATA_BLOB*);
typedef BOOL (WINAPI *fnCryptUnprotectDataFunc)(DATA_BLOB*, LPWSTR*, DATA_BLOB*, PVOID, CRYPTPROTECT_PROMPTSTRUCT*, DWORD, DATA_BLOB*);


//+----------------------------------------------------------------------------
// Class:     CSecurePassword
//
// Synopsis:  Manages secrets (passwords) in memory. Because CM runs on Win9x,
//            NT4, Win2K, WinXP & .NET Server platform we need to handle 
//            secrets differently on different platforms. On Win2K+ 
//            this class uses CryptProtectData and CryptUnprotectData. On any
//            platform below Win2K there APIs are not supported thus CM
//            just uses the old way (not very secure) of XORing passwords in 
//            memory.
//  
//            If a caller gets a password from this class (GetPasswordWithAlloc)
//            in clear text, that memory needs to be freed by this class by 
//            calling ClearAndFree. The caller will get an assert upon 
//            destruction of this class if the caller doesn't use this
//            class to free the memory.
//              
//            This class can protect & unprotect strings of length 0.
//
// Arguments: none
//
// Returns:   Nothing
//
// History:   11/05/2002    tomkel    Created
//
//+----------------------------------------------------------------------------
class CSecurePassword
{
public:
    CSecurePassword();
    ~CSecurePassword();

    BOOL SetPassword(IN LPWSTR szPassword);
    BOOL GetPasswordWithAlloc(OUT LPWSTR* pszClearPw, OUT DWORD* cbClearPw);
    VOID ClearAndFree(IN OUT LPWSTR* pszClearPw, IN DWORD cbClearPw);

    VOID Init();
    VOID UnInit();
    BOOL IsEmptyString();
    BOOL IsHandleToPassword();

    VOID SetMaxDataLenToProtect(DWORD dwMaxDataLen);
    DWORD GetMaxDataLenToProtect();

private:
    VOID ClearMemberVars();    
    VOID FreePassword(IN DATA_BLOB *pDBPassword);
    BOOL LoadCrypt32AndGetFuncPtrs();
    VOID UnloadCrypt32();

    DWORD DecodePassword(IN DATA_BLOB * pDataBlobPassword, 
                         OUT DWORD     * pcbPassword, 
                         OUT PBYTE     * ppbPassword);

    DWORD EncodePassword(IN DWORD       cbPassword,  
                         IN PBYTE       pbPassword, 
                         OUT DATA_BLOB * pDataBlobPassword);


    //
    // Member variables
    //
    DATA_BLOB*                  m_pEncryptedPW;          // Encrypted PW used in Win2K+
    TCHAR                       m_tszPassword[PWLEN+1];  // password (used downlevel - Win9x & NT4)
    CDynamicLibrary             m_dllCrypt32;
    fnCryptProtectDataFunc      fnCryptProtectData;
    fnCryptUnprotectDataFunc    fnCryptUnprotectData;
    BOOL                        m_fIsLibAndFuncPtrsAvail; 
    BOOL                        m_fIsEmptyString;
    BOOL                        m_fIsHandleToPassword;  // When users sets 16 *s, this will be TRUE

    DWORD                       m_dwMaxDataLen;
    // Used for debugging. At destruction time this needs to be 0.
    // Each call to GetPasswordWithAlloc increments this
    // Each call to ClearAndFree decrements this. 
    int                         m_iAllocAndFreeCounter;    

}; //class CSecurePassword


#endif // _ICM_INC


#endif // CM_PWUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\setacl.h ===
//+----------------------------------------------------------------------------
//
// File:    setacl.h
//
// Module:  CMCONTBL.LIB
//
// Synopsis: Security/SID/ACL stuff for CM
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  09-Mar-2000 SumitC  Created
//
//-----------------------------------------------------------------------------

BOOL SetAclPerms(PACL * pAcl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\shelldll.h ===
//+----------------------------------------------------------------------------
//
// File:     shelldll.h
//
// Module:   CMMON32.EXE and CMDIAL32.DLL
//
// Synopsis: Definition of CShellDll, a shell32.dll wrapper.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun   Created    01/12/98
//
//+----------------------------------------------------------------------------
#ifndef SHELLDLL_H
#define SHELLDLL_H

#include <windows.h>
#include <shlobj.h>

//
// the following is to circumvent the NT 5.0 windows.h
//
#ifdef  WIN32_LEAN_AND_MEAN
#include <shellapi.h>
#endif

//+---------------------------------------------------------------------------
//
//	class CShellDll
//
//	Description: A class to dynamic load/unload shell32.dll to reduce the 
//               workingset under win95
//
//	History:	fengsun	Created		1/12/98
//
//----------------------------------------------------------------------------
class CShellDll
{
public:
    CShellDll(BOOL fKeepDllLoaded = FALSE);
    ~CShellDll();

    BOOL Load(); // can call even if loaded
    void Unload(); // can call even if not loaded
    BOOL IsLoaded();

    // For ShellExecuteEx
    BOOL ExecuteEx(LPSHELLEXECUTEINFO lpExecInfo);

    // For ShellNotifyIcon
    BOOL NotifyIcon(DWORD dwMessage, PNOTIFYICONDATA pnid ); 

    HRESULT ShellGetSpecialFolderLocation(HWND, int, LPITEMIDLIST *);
    BOOL ShellGetPathFromIDList(LPCITEMIDLIST, LPTSTR);
    HRESULT ShellGetMalloc(LPMALLOC * ppMalloc);

    //
    //  These three types and the associated function pointers were made public
    //  so that they could be passed to GetUsersApplicationDataDir.  Because of
    //  name decoration, passing the classes wrappers doesn't work.
    //
    typedef HRESULT (WINAPI* SHGetSpecialFolderLocationSpec)(HWND, int, LPITEMIDLIST *);
    typedef BOOL (WINAPI* SHGetPathFromIDListSpec)(LPCITEMIDLIST, LPTSTR);
    typedef HRESULT (WINAPI* SHGetMallocSpec)(LPMALLOC * ppMalloc);

    SHGetSpecialFolderLocationSpec m_pfnSHGetSpecialFolderLocation;
    SHGetPathFromIDListSpec m_pfnSHGetPathFromIDList;
    SHGetMallocSpec m_pfnSHGetMalloc;

protected:
    typedef BOOL  (WINAPI *SHELLEXECUTEEXPROC)(LPSHELLEXECUTEINFOW lpExecInfo);
    typedef BOOL (WINAPI *SHELL_NOTIFYICONPROC)(DWORD dwMessage, PNOTIFYICONDATAW pnid ); 

    HINSTANCE m_hInstShell;
    BOOL m_KeepDllLoaded;

    SHELLEXECUTEEXPROC m_fnShellExecuteEx;
    SHELL_NOTIFYICONPROC m_fnShell_NotifyIcon;
};

inline BOOL CShellDll::ExecuteEx(LPSHELLEXECUTEINFOW lpExecInfo)
{
    if (!Load())
    {
        return FALSE;
    }

    return m_fnShellExecuteEx(lpExecInfo);
}

inline BOOL CShellDll::NotifyIcon(DWORD dwMessage, PNOTIFYICONDATAW pnid )
{
    if (!Load())
    {
        return FALSE;
    }

    BOOL fRet = m_fnShell_NotifyIcon(dwMessage,pnid);

    return fRet;
}

inline BOOL CShellDll::IsLoaded()
{
    return m_hInstShell != NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\ras2.h ===
/* Copyright (c) 1992-1998 Microsoft Corporation
**
** ras.h
** Remote Access external API
** Public header for external API clients
**
** WINVER values in this file:
**      WINVER < 0x400 = Windows NT 3.5, Windows NT 3.51
**      WINVER = 0x400 = Windows 95, Windows NT SUR (default)
**      WINVER > 0x400 = Windows NT SUR enhancements
*/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef UNLEN
#include <lmcons.h>
#endif

#include <pshpack4.h>

/* Flags for RasConnectionNotification().
*/
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002
#define RASCN_BandwidthAdded    0x00000004
#define RASCN_BandwidthRemoved  0x00000008

/* RASENTRY 'dwDialMode' values.
*/
#define RASEDM_DialAll                  1
#define RASEDM_DialAsNeeded             2

/* RASENTRY 'dwIdleDisconnectSeconds' constants.
*/
#define RASIDS_Disabled                 0xffffffff
#define RASIDS_UseGlobalValue           0

/* AutoDial DLL function parameter block.
*/
#define RASADPARAMS struct tagRASADPARAMS
RASADPARAMS
{
    DWORD       dwSize;
    HWND        hwndOwner;
    DWORD       dwFlags;
    LONG        xDlg;
    LONG        yDlg;
};

#define LPRASADPARAMS RASADPARAMS*

/* AutoDial DLL function parameter block 'dwFlags.'
*/
#define RASADFLG_PositionDlg            0x00000001

/* Prototype AutoDial DLL function.
*/
typedef BOOL (WINAPI *RASADFUNCA)( LPSTR, LPSTR, LPRASADPARAMS, LPDWORD );
typedef BOOL (WINAPI *RASADFUNCW)( LPWSTR, LPWSTR, LPRASADPARAMS, LPDWORD );

#ifdef UNICODE
#define RASADFUNC RASADFUNCW
#else
#define RASADFUNC RASADFUNCA
#endif

/* A RAS phone book multilinked sub-entry.
*/
#define RASSUBENTRYA struct tagRASSUBENTRYA
RASSUBENTRYA
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#define RASSUBENTRYW struct tagRASSUBENTRYW
RASSUBENTRYW
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#ifdef UNICODE
#define RASSUBENTRY RASSUBENTRYW
#else
#define RASSUBENTRY RASSUBENTRYA
#endif

#define LPRASSUBENTRYW RASSUBENTRYW*
#define LPRASSUBENTRYA RASSUBENTRYA*
#define LPRASSUBENTRY  RASSUBENTRY*

/* Ras{Get,Set}Credentials structure.  These calls
** supercede Ras{Get,Set}EntryDialParams.
*/
#define RASCREDENTIALSA struct tagRASCREDENTIALSA
RASCREDENTIALSA
{
    DWORD dwSize;
    DWORD dwMask;
    CHAR szUserName[ UNLEN + 1 ];
    CHAR szPassword[ PWLEN + 1 ];
    CHAR szDomain[ DNLEN + 1 ];
};

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASCREDENTIALS RASCREDENTIALSW
#else
#define RASCREDENTIALS RASCREDENTIALSA
#endif

#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define LPRASCREDENTIALSA RASCREDENTIALSA*
#define LPRASCREDENTIALS  RASCREDENTIALS*

/* RASCREDENTIALS 'dwMask' values.
*/
#define RASCM_UserName       0x00000001
#define RASCM_Password       0x00000002
#define RASCM_Domain         0x00000004

/* AutoDial address properties.
*/
#define RASAUTODIALENTRYA struct tagRASAUTODIALENTRYA
RASAUTODIALENTRYA
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    CHAR szEntry[ RAS_MaxEntryName + 1];
};

#define RASAUTODIALENTRYW struct tagRASAUTODIALENTRYW
RASAUTODIALENTRYW
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    WCHAR szEntry[ RAS_MaxEntryName + 1];
};

#ifdef UNICODE
#define RASAUTODIALENTRY RASAUTODIALENTRYW
#else
#define RASAUTODIALENTRY RASAUTODIALENTRYA
#endif

#define LPRASAUTODIALENTRYW RASAUTODIALENTRYW*
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*
#define LPRASAUTODIALENTRY  RASAUTODIALENTRY*

/* AutoDial control parameter values for
** Ras{Get,Set}AutodialParam.
*/
#define RASADP_DisableConnectionQuery           0
#define RASADP_LoginSessionDisable              1
#define RASADP_SavedAddressesLimit              2
#define RASADP_FailedConnectionTimeout          3
#define RASADP_ConnectionQueryTimeout           4


DWORD APIENTRY RasGetSubEntryHandleA( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetSubEntryHandleW( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA);

DWORD APIENTRY RasGetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW );

DWORD APIENTRY RasSetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA, BOOL );

DWORD APIENTRY RasSetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW, BOOL );

DWORD APIENTRY RasConnectionNotificationA( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasConnectionNotificationW( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasGetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasGetAutodialAddressA( LPSTR, LPDWORD, LPRASAUTODIALENTRYA,
                    LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialAddressW( LPWSTR, LPDWORD, LPRASAUTODIALENTRYW,
                    LPDWORD, LPDWORD);

DWORD APIENTRY RasSetAutodialAddressA( LPSTR, DWORD, LPRASAUTODIALENTRYA,
                    DWORD, DWORD );

DWORD APIENTRY RasSetAutodialAddressW( LPWSTR, DWORD, LPRASAUTODIALENTRYW,
                    DWORD, DWORD );

DWORD APIENTRY RasEnumAutodialAddressesA( LPSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumAutodialAddressesW( LPWSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialEnableA( DWORD, LPBOOL );

DWORD APIENTRY RasGetAutodialEnableW( DWORD, LPBOOL );

DWORD APIENTRY RasSetAutodialEnableA( DWORD, BOOL );

DWORD APIENTRY RasSetAutodialEnableW( DWORD, BOOL );

DWORD APIENTRY RasGetAutodialParamA( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasGetAutodialParamW( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasSetAutodialParamA( DWORD, LPVOID, DWORD );

DWORD APIENTRY RasSetAutodialParamW( DWORD, LPVOID, DWORD );


#ifdef UNICODE
#define RasDial                 RasDialW
#define RasEnumConnections      RasEnumConnectionsW
#define RasEnumEntries          RasEnumEntriesW
#define RasGetConnectStatus     RasGetConnectStatusW
#define RasGetErrorString       RasGetErrorStringW
#define RasHangUp               RasHangUpW
#define RasGetProjectionInfo    RasGetProjectionInfoW
#define RasCreatePhonebookEntry RasCreatePhonebookEntryW
#define RasEditPhonebookEntry   RasEditPhonebookEntryW
#define RasSetEntryDialParams   RasSetEntryDialParamsW
#define RasGetEntryDialParams   RasGetEntryDialParamsW
#define RasEnumDevices          RasEnumDevicesW
#define RasGetCountryInfo       RasGetCountryInfoW
#define RasGetEntryProperties   RasGetEntryPropertiesW
#define RasSetEntryProperties   RasSetEntryPropertiesW
#define RasRenameEntry          RasRenameEntryW
#define RasDeleteEntry          RasDeleteEntryW
#define RasValidateEntryName    RasValidateEntryNameW
#define RasGetSubEntryHandle        RasGetSubEntryHandleW
#define RasConnectionNotification   RasConnectionNotificationW
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesW
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesW
#define RasGetCredentials           RasGetCredentialsW
#define RasSetCredentials           RasSetCredentialsW
#define RasGetAutodialAddress       RasGetAutodialAddressW
#define RasSetAutodialAddress       RasSetAutodialAddressW
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesW
#define RasGetAutodialEnable        RasGetAutodialEnableW
#define RasSetAutodialEnable        RasSetAutodialEnableW
#define RasGetAutodialParam         RasGetAutodialParamW
#define RasSetAutodialParam         RasSetAutodialParamW
#else
#define RasDial                 RasDialA
#define RasEnumConnections      RasEnumConnectionsA
#define RasEnumEntries          RasEnumEntriesA
#define RasGetConnectStatus     RasGetConnectStatusA
#define RasGetErrorString       RasGetErrorStringA
#define RasHangUp               RasHangUpA
#define RasGetProjectionInfo    RasGetProjectionInfoA
#define RasCreatePhonebookEntry RasCreatePhonebookEntryA
#define RasEditPhonebookEntry   RasEditPhonebookEntryA
#define RasSetEntryDialParams   RasSetEntryDialParamsA
#define RasGetEntryDialParams   RasGetEntryDialParamsA
#define RasEnumDevices          RasEnumDevicesA
#define RasGetCountryInfo       RasGetCountryInfoA
#define RasGetEntryProperties   RasGetEntryPropertiesA
#define RasSetEntryProperties   RasSetEntryPropertiesA
#define RasRenameEntry          RasRenameEntryA
#define RasDeleteEntry          RasDeleteEntryA
#define RasValidateEntryName    RasValidateEntryNameA
#define RasGetSubEntryHandle        RasGetSubEntryHandleA
#define RasConnectionNotification   RasConnectionNotificationA
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesA
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesA
#define RasGetCredentials           RasGetCredentialsA
#define RasSetCredentials           RasSetCredentialsA
#define RasGetAutodialAddress       RasGetAutodialAddressA
#define RasSetAutodialAddress       RasSetAutodialAddressA
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesA
#define RasGetAutodialEnable        RasGetAutodialEnableA
#define RasSetAutodialEnable        RasSetAutodialEnableA
#define RasGetAutodialParam         RasGetAutodialParamA
#define RasSetAutodialParam         RasSetAutodialParamA
#endif
					  
#ifdef __cplusplus
}
#endif

#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\raslink.h ===
//+----------------------------------------------------------------------------
//
// File:     raslink.h
//
// Module:   CMDIAL32.DLL and CMUTOA.DLL
//
// Synopsis: Structures and function types for RAS Linkage.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb   Created     05/05/99
//
//+----------------------------------------------------------------------------
//
//  If you modify any of the functions below (add/remove/whatever), you may need to modify the
//  constant string arrays in common\source\raslink.cpp
//

//
//  Ansi prototypes
//
typedef DWORD (WINAPI *pfnRasDeleteEntryA)(LPCSTR, LPCSTR);
typedef DWORD (WINAPI *pfnRasGetEntryPropertiesA)(LPCSTR, LPCSTR, LPRASENTRYA, LPDWORD, LPBYTE, LPDWORD);
typedef DWORD (WINAPI *pfnRasSetEntryPropertiesA)(LPCSTR, LPCSTR, LPRASENTRYA, DWORD, LPBYTE, DWORD);
typedef DWORD (WINAPI *pfnRasGetEntryDialParamsA)(LPCSTR, LPRASDIALPARAMSA,  LPBOOL);
typedef DWORD (WINAPI *pfnRasSetEntryDialParamsA)(LPCSTR, LPRASDIALPARAMSA,  BOOL);
typedef DWORD (WINAPI *pfnRasEnumDevicesA)(LPRASDEVINFOA, LPDWORD, LPDWORD);
typedef DWORD (WINAPI *pfnRasDialA)(LPRASDIALEXTENSIONS,LPCSTR,LPRASDIALPARAMSA,DWORD,LPVOID,LPHRASCONN);
typedef DWORD (WINAPI *pfnRasGetErrorStringA)(UINT, LPSTR, DWORD);
typedef DWORD (WINAPI *pfnRasGetConnectStatusA)(HRASCONN, LPRASCONNSTATUSA);

//  These are never used on win9x but we need a prototype for the struct
typedef DWORD (WINAPI *pfnRasSetSubEntryPropertiesA)(LPCSTR, LPCSTR, DWORD, LPRASSUBENTRYA, DWORD, LPBYTE, DWORD);
typedef DWORD (WINAPI *pfnRasSetCustomAuthDataA)(LPCSTR, LPCSTR, BYTE *, DWORD);  

typedef DWORD (WINAPI *pfnRasGetEapUserIdentityA)(LPCSTR, LPCSTR, DWORD, HWND, LPRASEAPUSERIDENTITYA*);
typedef VOID  (WINAPI *pfnRasFreeEapUserIdentityA)(LPRASEAPUSERIDENTITYA);
typedef DWORD (WINAPI *pfnRasDeleteSubEntryA)(LPCSTR, LPCSTR, DWORD);
typedef DWORD (WINAPI *pfnRasGetCredentialsA)(LPCSTR, LPCSTR, LPRASCREDENTIALSA);
typedef DWORD (WINAPI *pfnRasSetCredentialsA)(LPCSTR, LPCSTR, LPRASCREDENTIALSA, BOOL);
typedef DWORD (WINAPI* pfnRasGetCustomAuthDataA)(LPCSTR, LPCSTR, PBYTE, DWORD*);
typedef DWORD (WINAPI* pfnRasGetProjectionInfoA)(HRASCONN, RASPROJECTION, LPVOID, LPDWORD);

//
//  Unicode Prototypes
//
typedef DWORD (WINAPI *pfnRasDeleteEntryW)(LPCWSTR, LPCWSTR);
typedef DWORD (WINAPI *pfnRasGetEntryPropertiesW)(LPCWSTR, LPCWSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD);
typedef DWORD (WINAPI *pfnRasSetEntryPropertiesW)(LPCWSTR, LPCWSTR, LPRASENTRYW, DWORD, LPBYTE, DWORD);
typedef DWORD (WINAPI *pfnRasGetEntryDialParamsW)(LPCWSTR, LPRASDIALPARAMSW,  LPBOOL);
typedef DWORD (WINAPI *pfnRasSetEntryDialParamsW)(LPCWSTR, LPRASDIALPARAMSW,  BOOL);
typedef DWORD (WINAPI *pfnRasEnumDevicesW)(LPRASDEVINFOW, LPDWORD, LPDWORD);
typedef DWORD (WINAPI *pfnRasDialW)(LPRASDIALEXTENSIONS,LPCWSTR,LPRASDIALPARAMSW,DWORD,LPVOID,LPHRASCONN);
typedef DWORD (WINAPI *pfnRasGetErrorStringW)(UINT, LPWSTR, DWORD);
typedef DWORD (WINAPI *pfnRasGetConnectStatusW)(HRASCONN, LPRASCONNSTATUSW);
typedef DWORD (WINAPI *pfnRasSetSubEntryPropertiesW)(LPCWSTR, LPCWSTR, DWORD, LPRASSUBENTRYW, DWORD, LPBYTE, DWORD);
typedef DWORD (WINAPI *pfnRasSetCustomAuthDataW)(LPCWSTR, LPCWSTR, BYTE *, DWORD);  
typedef DWORD (WINAPI *pfnRasDeleteSubEntryW)(LPCWSTR, LPCWSTR, DWORD);

typedef DWORD (WINAPI *pfnRasGetEapUserIdentityW)(LPCWSTR, LPCWSTR, DWORD, HWND, LPRASEAPUSERIDENTITYW*);
typedef VOID  (WINAPI *pfnRasFreeEapUserIdentityW)(LPRASEAPUSERIDENTITYW);
typedef DWORD (WINAPI *pfnRasGetCredentialsW)(LPCWSTR, LPCWSTR, LPRASCREDENTIALSW);
typedef DWORD (WINAPI *pfnRasSetCredentialsW)(LPCWSTR, LPCWSTR, LPRASCREDENTIALSW, BOOL);
typedef DWORD (WINAPI* pfnRasGetCustomAuthDataW)(LPCWSTR, LPCWSTR, PBYTE, DWORD*);
typedef DWORD (WINAPI* pfnRasGetProjectionInfoW) (HRASCONN, RASPROJECTION, LPVOID, LPDWORD);


//
// Char size independent prototypes
//

typedef DWORD (WINAPI *pfnRasInvokeEapUI) (HRASCONN, DWORD, LPRASDIALEXTENSIONS, HWND);
typedef DWORD (WINAPI *pfnRasHangUp)(HRASCONN);


//
// Structure used to describe the linkage to RAS.  NOTE:  Changes to this structure
// will probably require changes to LinkToRas() and UnlinkFromRas() as well as the
// win9x UtoA code in cmutoa.cpp.
//
typedef struct _RasLinkageStructA {

    HINSTANCE hInstRas;
    HINSTANCE hInstRnaph;
    union {
        struct {
            pfnRasDeleteEntryA pfnDeleteEntry;
            pfnRasGetEntryPropertiesA pfnGetEntryProperties;
            pfnRasSetEntryPropertiesA pfnSetEntryProperties;
            pfnRasGetEntryDialParamsA pfnGetEntryDialParams;
            pfnRasSetEntryDialParamsA pfnSetEntryDialParams;
            pfnRasEnumDevicesA pfnEnumDevices;
            pfnRasDialA pfnDial;
            pfnRasHangUp pfnHangUp;
            pfnRasGetErrorStringA pfnGetErrorString;
            pfnRasGetConnectStatusA pfnGetConnectStatus;
            pfnRasGetProjectionInfoA pfnGetProjectionInfo;
            pfnRasSetSubEntryPropertiesA pfnSetSubEntryProperties;
            pfnRasDeleteSubEntryA pfnDeleteSubEntry;
            pfnRasSetCustomAuthDataA pfnSetCustomAuthData;
            pfnRasGetEapUserIdentityA pfnGetEapUserIdentity;
            pfnRasFreeEapUserIdentityA pfnFreeEapUserIdentity;
            pfnRasInvokeEapUI pfnInvokeEapUI;
            pfnRasGetCredentialsA pfnGetCredentials;
            pfnRasSetCredentialsA pfnSetCredentials;
            pfnRasGetCustomAuthDataA pfnGetCustomAuthData;

        };
        void *apvPfnRas[21];  // This was from the old hacking code. The size of 
                              // apvPfnRas[] should always be 1 size bigger than
                              // the number of functions. 
                              // Refer to apszRas[] in 'ras.cpp'. The size of 
                              // apszRas[] is equal to sizeof(apvPfnRas[]).
    };
} RasLinkageStructA ;


typedef struct _RasLinkageStructW {

    HINSTANCE hInstRas;
    union {
        struct {
            pfnRasDeleteEntryW pfnDeleteEntry;
            pfnRasGetEntryPropertiesW pfnGetEntryProperties;
            pfnRasSetEntryPropertiesW pfnSetEntryProperties;
            pfnRasGetEntryDialParamsW pfnGetEntryDialParams;
            pfnRasSetEntryDialParamsW pfnSetEntryDialParams;
            pfnRasEnumDevicesW pfnEnumDevices;
            pfnRasDialW pfnDial;
            pfnRasHangUp pfnHangUp;
            pfnRasGetErrorStringW pfnGetErrorString;
            pfnRasGetConnectStatusW pfnGetConnectStatus;
            pfnRasGetProjectionInfoW pfnGetProjectionInfo;
            pfnRasSetSubEntryPropertiesW pfnSetSubEntryProperties;
            pfnRasDeleteSubEntryW pfnDeleteSubEntry;
            pfnRasSetCustomAuthDataW pfnSetCustomAuthData;
            pfnRasGetEapUserIdentityW pfnGetEapUserIdentity;
            pfnRasFreeEapUserIdentityW pfnFreeEapUserIdentity;
            pfnRasInvokeEapUI pfnInvokeEapUI;
            pfnRasGetCredentialsW pfnGetCredentials;
            pfnRasSetCredentialsW pfnSetCredentials;
            pfnRasGetCustomAuthDataW pfnGetCustomAuthData;
        };
        void *apvPfnRas[21];  // This was from the old hacking code. The size of 
                              // apvPfnRas[] should always be 1 size bigger than
                              // the number of functions. 
                              // Refer to apszRas[] in 'ras.cpp'. The size of 
                              // apszRas[] is equal to sizeof(apvPfnRas[]).
    };
} RasLinkageStructW ;


#ifdef UNICODE
#define RasLinkageStruct RasLinkageStructW
#else
#define RasLinkageStruct RasLinkageStructA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\snpolicy.h ===
//+---------------------------------------------------------------------------
// SnPolicy - SafeNet Policy Configuration Library
//
// Copyright 2001 SafeNet, Inc.
//
// Description: Functions to get and set SafeNet IPSec policy attributes.
//
// HISTORY:
//
// 11-Oct-2001 KCW Modified to make calling convention, structure packing explicit.
//
//----------------------------------------------------------------------------

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#if !(defined(SNPOLICY_H_INCLUDED))
#define SNPOLICY_H_INCLUDED

#ifdef  __cplusplus
extern "C" {
#endif

/************************* Embedded Include Headers. *************************/
#include <windows.h>

/**************************** Constant Definitions ***************************/
//
// Version Info
//    
#define POLICY_MAJOR_VERSION		1
#define POLICY_MINOR_VERSION		0

//
// Policy Attribute Types
//
#define SN_USELOGFILE       ((LPCTSTR) 1)
#define SN_AUTHMODE         ((LPCTSTR) 2)
#define SN_L2TPCERT         ((LPCTSTR) 3)
#define SN_L2TPPRESHR       ((LPCTSTR) 4)

//
// SN_AUTHMODE authentication modes
//
#define SN_AUTOCERT 0
#define SN_CERT     1
#define SN_PRESHR   2

/***************************** Macro Definitions *****************************/

// Calling Convention
#define SNPOLAPI					__cdecl

//
// DLL Import/Export Definitions    
//
#ifdef POLICY_DLL
#define POLICY_FUNC					_declspec (dllexport)
#else
#define POLICY_FUNC					_declspec (dllimport)
#endif

/*************************** Structure Definitions ***************************/

#include <pshpack8.h>

//
// Policy Function Table
//
typedef struct POLICY_FUNCS_V1_0_ {

	/* 1.0 functions. */
      BOOL (SNPOLAPI *SnPolicySet) (LPCTSTR szAttrId, const void *pvData);
      BOOL (SNPOLAPI *SnPolicyGet) (LPCTSTR szAttrId, const void *pvData, DWORD *pcbData);
      BOOL (SNPOLAPI *SnPolicyReload) (void);
} POLICY_FUNCS_V1_0, *PPOLICY_FUNCS_V1_0;

#include	<poppack.h>

/****************************** Type Definitions *****************************/
typedef POLICY_FUNCS_V1_0	POLICY_FUNCS, *PPOLICY_FUNCS;

typedef BOOL (*PPOLICYAPINEGOTIATOR) (DWORD *pMajorVersion, DWORD *pMinorVersion, POLICY_FUNCS *pApiFuncs);

/************************** API Function Prototypes **************************/

POLICY_FUNC BOOL SNPOLAPI SnPolicySet(LPCTSTR szAttrId, const void *pvData);

POLICY_FUNC BOOL SNPOLAPI SnPolicyGet(LPCTSTR szAttrId, const void *pvData, DWORD *pcbData); 

POLICY_FUNC BOOL SNPOLAPI SnPolicyReload(void);

POLICY_FUNC BOOL SNPOLAPI SnPolicyApiNegotiateVersion( DWORD *pMajorVersion,  DWORD *pMinorVersion, POLICY_FUNCS *pPolicyFuncs);


#if defined(__cplusplus)
}
#endif 

#endif // SNPOLICY_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\struct.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
// STRUCT.H - global data structures that need to go through thunk layers
//

//	HISTORY:
//	
//	11/20/94	jeremys		Created.
//  96/03/11  markdu    Added fDisallowTCPInstall and fDisallowRNAInstall.
//            These are used to prevent installing the components, and
//            since we want to allow the installation by default, setting
//            the structure to zeros gives default behaviour with these flags.
//  96/03/12  markdu    Removed nModems since we enumerate modems
//            with RNA now.
//

// Note: this structure is separated out from the main global inc file
// because #define's and other valid C syntax aren't valid for the thunk
// compiler, which just needs the structure.

// structure to hold information about client software configuration
typedef struct tagCLIENTCONFIG {
	BOOL fTcpip;			// TCP/IP currently installed

	BOOL fNetcard;			// net card installed
	BOOL fNetcardBoundTCP;	// TCP/IP bound to net card

	BOOL fPPPDriver;		// PPP driver installed
	BOOL fPPPBoundTCP;		// TCP/IP bound to PPP driver

	BOOL fMailInstalled;	// microsoft mail (exchange) files installed
	BOOL fRNAInstalled;		// RNA (remote access) files installed
	BOOL fMSNInstalled;		// Microsoft network files installed
	BOOL fMSN105Installed;	// MSN 1.05 (Rome) files installed
	BOOL fInetMailInstalled;	// Internet mail (rt. 66) files installed
  BOOL fDisallowTCPInstall; // Do not allow TCP/IP to be installed
  BOOL fDisallowRNAInstall; // Do not allow RNA to be installed
} CLIENTCONFIG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\uapi.h ===
//+----------------------------------------------------------------------------
//
// File:     uapi.h
//
// Module:   UAPIINIT.LIB
//
// Synopsis: This header file contains the extern declarations of all the UAPI
//           function pointers declared in the uapiinit.lib.  The idea for this 
//           dll was borrowed from F. Avery Bishop's April 1999 MSJ article 
//           "Design a Single Unicode App that Runs on Both Windows 98 and Windows 2000"
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb      Created    04/25/99
//
//+----------------------------------------------------------------------------

#ifndef _UAPIH


// Uncomment this line to emmulate Windows 98 behavior when developing on
// Windows NT
//#define EMULATE9X

#include "cmutoa.h"

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

extern UAPI_CallWindowProc CallWindowProcU;
extern UAPI_CharLower CharLowerU;
extern UAPI_CharPrev CharPrevU;
extern UAPI_CharNext CharNextU;
extern UAPI_CharUpper CharUpperU;
extern UAPI_CompareString CompareStringU;
extern UAPI_CreateDialogParam CreateDialogParamU;
extern UAPI_CreateDirectory CreateDirectoryU;
extern UAPI_CreateEvent CreateEventU;
extern UAPI_CreateFile CreateFileU;
extern UAPI_CreateFileMapping CreateFileMappingU;
extern UAPI_CreateMutex CreateMutexU;
extern UAPI_CreateProcess CreateProcessU;
extern UAPI_CreateWindowEx CreateWindowExU;
extern UAPI_DefWindowProc DefWindowProcU;
extern UAPI_DeleteFile DeleteFileU;
extern UAPI_DialogBoxParam DialogBoxParamU;
extern UAPI_DispatchMessage DispatchMessageU;
extern UAPI_ExpandEnvironmentStrings ExpandEnvironmentStringsU;
extern UAPI_FindResourceEx FindResourceExU;
extern UAPI_FindWindowEx FindWindowExU;
extern UAPI_GetClassLong GetClassLongU;
extern UAPI_GetDateFormat GetDateFormatU;
extern UAPI_GetDlgItemText GetDlgItemTextU;
extern UAPI_GetFileAttributes GetFileAttributesU;
extern UAPI_GetMessage GetMessageU;
extern UAPI_GetModuleFileName GetModuleFileNameU;
extern UAPI_GetModuleHandle GetModuleHandleU;
extern UAPI_GetPrivateProfileInt GetPrivateProfileIntU;
extern UAPI_GetPrivateProfileString GetPrivateProfileStringU;
extern UAPI_GetStringTypeEx GetStringTypeExU;
extern UAPI_GetSystemDirectory GetSystemDirectoryU;
extern UAPI_GetTempFileName GetTempFileNameU;
extern UAPI_GetTempPath GetTempPathU;
extern UAPI_GetTimeFormat GetTimeFormatU;
extern UAPI_GetUserName GetUserNameU;
extern UAPI_GetVersionEx GetVersionExU;
extern UAPI_GetWindowLong GetWindowLongU;
extern UAPI_GetWindowText GetWindowTextU;
extern UAPI_GetWindowTextLength GetWindowTextLengthU;
extern UAPI_InsertMenu InsertMenuU;
extern UAPI_IsDialogMessage IsDialogMessageU;
extern UAPI_LoadCursor LoadCursorU;
extern UAPI_LoadIcon LoadIconU;
extern UAPI_LoadImage LoadImageU;
extern UAPI_LoadLibraryEx LoadLibraryExU;
extern UAPI_LoadMenu LoadMenuU;
extern UAPI_LoadString LoadStringU;
extern UAPI_lstrcat lstrcatU;
extern UAPI_lstrcmp lstrcmpU;
extern UAPI_lstrcmpi lstrcmpiU;
extern UAPI_lstrcpy lstrcpyU;
extern UAPI_lstrcpyn lstrcpynU;
extern UAPI_lstrlen lstrlenU;
extern UAPI_OpenEvent OpenEventU;
extern UAPI_OpenFileMapping OpenFileMappingU;
extern UAPI_PeekMessage PeekMessageU;
extern UAPI_PostMessage PostMessageU;
extern UAPI_PostThreadMessage PostThreadMessageU;
extern UAPI_RegCreateKeyEx RegCreateKeyExU;
extern UAPI_RegDeleteKey RegDeleteKeyU;
extern UAPI_RegDeleteValue RegDeleteValueU;
extern UAPI_RegEnumKeyEx RegEnumKeyExU;
extern UAPI_RegisterClassEx RegisterClassExU;
extern UAPI_RegisterWindowMessage RegisterWindowMessageU;
extern UAPI_RegOpenKeyEx RegOpenKeyExU;
extern UAPI_RegQueryValueEx RegQueryValueExU;
extern UAPI_RegSetValueEx RegSetValueExU;
extern UAPI_SearchPath SearchPathU;
extern UAPI_SendDlgItemMessage SendDlgItemMessageU;
extern UAPI_SendMessage SendMessageU;
extern UAPI_SetCurrentDirectory SetCurrentDirectoryU;
extern UAPI_SetDlgItemText SetDlgItemTextU;
extern UAPI_SetWindowLong SetWindowLongU;
extern UAPI_SetWindowText SetWindowTextU;
extern UAPI_UnregisterClass UnregisterClassU;
extern UAPI_WinHelp WinHelpU;
extern UAPI_wsprintf wsprintfU;
extern UAPI_WritePrivateProfileString WritePrivateProfileStringU;
extern UAPI_wvsprintf wvsprintfU;

// Implemented as a macro, just as DialogBoxW is on Windows NT
#define DialogBoxU(hInstance, lpTemplate, hWndParent, lpDialogFunc    ) \
   DialogBoxParamU(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)

//
// External function prototypes. The client of the Unicode API calls this to 
// set the pointer functions as appropriate
//
BOOL   InitUnicodeAPI(); 
BOOL   UnInitUnicodeAPI();

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#define _UAPIH
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\tapi.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

The  Telephony  API  is jointly copyrighted by Intel and Microsoft.  You are
granted  a royalty free worldwide, unlimited license to make copies, and use
the   API/SPI  for  making  applications/drivers  that  interface  with  the
specification provided that this paragraph and the Intel/Microsoft copyright
statement is maintained as is in the text and source code files.

Copyright 1995-96 Microsoft, all rights reserved.
Portions copyright 1992, 1993 Intel/Microsoft, all rights reserved.

Module Name:

    tapi.h

Notes:

    Additions to the Telephony Application Programming Interface (TAPI) since
    version 1.0 are noted by version number (e.g. "TAPI v1.4").

--*/

#ifndef TAPI_H
#define TAPI_H



//
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//
// To build  a TAPI 1.4 application put a define as below in your source
// file before you include TAPI.H:
//
// #define TAPI_CURRENT_VERSION 0x00010004
//
//
#ifndef TAPI_CURRENT_VERSION
#define TAPI_CURRENT_VERSION 0x00020000
#endif

#include <windows.h>

#pragma pack(1)
// Type definitions of the data types used in tapi

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


//
// TAPI type definitions
//

#define DECLARE_OPAQUE32(name)  struct name##__ { int unused; }; \
                typedef const struct name##__ FAR* name

DECLARE_OPAQUE32(HCALL);
typedef HCALL FAR * LPHCALL;

DECLARE_OPAQUE32(HLINE);
typedef HLINE FAR * LPHLINE;

DECLARE_OPAQUE32(HPHONE);
typedef HPHONE FAR * LPHPHONE;

DECLARE_OPAQUE32(HLINEAPP);
typedef HLINEAPP FAR * LPHLINEAPP;

DECLARE_OPAQUE32(HPHONEAPP);
typedef HPHONEAPP FAR * LPHPHONEAPP;

typedef HICON FAR * LPHICON;

typedef void (CALLBACK * LINECALLBACK)(
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD               dwInstance,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    );

typedef void (CALLBACK * PHONECALLBACK)(
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD               dwInstance,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    );


// Messages for Phones and Lines

#define LINE_ADDRESSSTATE                       0L
#define LINE_CALLINFO                           1L
#define LINE_CALLSTATE                          2L
#define LINE_CLOSE                              3L
#define LINE_DEVSPECIFIC                        4L
#define LINE_DEVSPECIFICFEATURE                 5L
#define LINE_GATHERDIGITS                       6L
#define LINE_GENERATE                           7L
#define LINE_LINEDEVSTATE                       8L
#define LINE_MONITORDIGITS                      9L
#define LINE_MONITORMEDIA                       10L
#define LINE_MONITORTONE                        11L
#define LINE_REPLY                              12L
#define LINE_REQUEST                            13L
#define PHONE_BUTTON                            14L
#define PHONE_CLOSE                             15L
#define PHONE_DEVSPECIFIC                       16L
#define PHONE_REPLY                             17L
#define PHONE_STATE                             18L
#define LINE_CREATE                             19L             // TAPI v1.4
#define PHONE_CREATE                            20L             // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINE_AGENTSPECIFIC                      21L             // TAPI v2.0
#define LINE_AGENTSTATUS                        22L             // TAPI v2.0
#define LINE_APPNEWCALL                         23L             // TAPI v2.0
#define LINE_PROXYREQUEST                       24L             // TAPI v2.0
#define LINE_REMOVE                             25L             // TAPI v2.0
#define PHONE_REMOVE                            26L             // TAPI v2.0
#endif


#define INITIALIZE_NEGOTIATION                  0xFFFFFFFFL

#define LINEADDRCAPFLAGS_FWDNUMRINGS            0x00000001
#define LINEADDRCAPFLAGS_PICKUPGROUPID          0x00000002
#define LINEADDRCAPFLAGS_SECURE                 0x00000004
#define LINEADDRCAPFLAGS_BLOCKIDDEFAULT         0x00000008
#define LINEADDRCAPFLAGS_BLOCKIDOVERRIDE        0x00000010
#define LINEADDRCAPFLAGS_DIALED                 0x00000020
#define LINEADDRCAPFLAGS_ORIGOFFHOOK            0x00000040
#define LINEADDRCAPFLAGS_DESTOFFHOOK            0x00000080
#define LINEADDRCAPFLAGS_FWDCONSULT             0x00000100
#define LINEADDRCAPFLAGS_SETUPCONFNULL          0x00000200
#define LINEADDRCAPFLAGS_AUTORECONNECT          0x00000400
#define LINEADDRCAPFLAGS_COMPLETIONID           0x00000800
#define LINEADDRCAPFLAGS_TRANSFERHELD           0x00001000
#define LINEADDRCAPFLAGS_TRANSFERMAKE           0x00002000
#define LINEADDRCAPFLAGS_CONFERENCEHELD         0x00004000
#define LINEADDRCAPFLAGS_CONFERENCEMAKE         0x00008000
#define LINEADDRCAPFLAGS_PARTIALDIAL            0x00010000
#define LINEADDRCAPFLAGS_FWDSTATUSVALID         0x00020000
#define LINEADDRCAPFLAGS_FWDINTEXTADDR          0x00040000
#define LINEADDRCAPFLAGS_FWDBUSYNAADDR          0x00080000
#define LINEADDRCAPFLAGS_ACCEPTTOALERT          0x00100000
#define LINEADDRCAPFLAGS_CONFDROP               0x00200000
#define LINEADDRCAPFLAGS_PICKUPCALLWAIT         0x00400000
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRCAPFLAGS_PREDICTIVEDIALER       0x00800000      // TAPI v2.0
#define LINEADDRCAPFLAGS_QUEUE                  0x01000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_ROUTEPOINT             0x02000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_HOLDMAKESNEW           0x04000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOINTERNALCALLS        0x08000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOEXTERNALCALLS        0x10000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_SETCALLINGID           0x20000000      // TAPI v2.0
#endif

#define LINEADDRESSMODE_ADDRESSID               0x00000001
#define LINEADDRESSMODE_DIALABLEADDR            0x00000002

#define LINEADDRESSSHARING_PRIVATE              0x00000001
#define LINEADDRESSSHARING_BRIDGEDEXCL          0x00000002
#define LINEADDRESSSHARING_BRIDGEDNEW           0x00000004
#define LINEADDRESSSHARING_BRIDGEDSHARED        0x00000008
#define LINEADDRESSSHARING_MONITORED            0x00000010

#define LINEADDRESSSTATE_OTHER                  0x00000001
#define LINEADDRESSSTATE_DEVSPECIFIC            0x00000002
#define LINEADDRESSSTATE_INUSEZERO              0x00000004
#define LINEADDRESSSTATE_INUSEONE               0x00000008
#define LINEADDRESSSTATE_INUSEMANY              0x00000010
#define LINEADDRESSSTATE_NUMCALLS               0x00000020
#define LINEADDRESSSTATE_FORWARD                0x00000040
#define LINEADDRESSSTATE_TERMINALS              0x00000080
#define LINEADDRESSSTATE_CAPSCHANGE             0x00000100      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRESSSTATE_AGENT                  0x00000200      // TAPI v2.0
#define LINEADDRESSSTATE_AGENTSTATE             0x00000400      // TAPI v2.0
#define LINEADDRESSSTATE_AGENTACTIVITY          0x00000800      // TAPI v2.0
#endif

#define LINEADDRFEATURE_FORWARD                 0x00000001
#define LINEADDRFEATURE_MAKECALL                0x00000002
#define LINEADDRFEATURE_PICKUP                  0x00000004
#define LINEADDRFEATURE_SETMEDIACONTROL         0x00000008
#define LINEADDRFEATURE_SETTERMINAL             0x00000010
#define LINEADDRFEATURE_SETUPCONF               0x00000020
#define LINEADDRFEATURE_UNCOMPLETECALL          0x00000040
#define LINEADDRFEATURE_UNPARK                  0x00000080
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRFEATURE_PICKUPHELD              0x00000100      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPGROUP             0x00000200      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPDIRECT            0x00000400      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPWAITING           0x00000800      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDFWD              0x00001000      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDDND              0x00002000      // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEAGENTFEATURE_SETAGENTGROUP          0x00000001      // TAPI v2.0
#define LINEAGENTFEATURE_SETAGENTSTATE          0x00000002      // TAPI v2.0
#define LINEAGENTFEATURE_SETAGENTACTIVITY       0x00000004      // TAPI v2.0
#define LINEAGENTFEATURE_AGENTSPECIFIC          0x00000008      // TAPI v2.0
#define LINEAGENTFEATURE_GETAGENTACTIVITYLIST   0x00000010      // TAPI v2.0
#define LINEAGENTFEATURE_GETAGENTGROUP          0x00000020      // TAPI v2.0

#define LINEAGENTSTATE_LOGGEDOFF                0x00000001      // TAPI v2.0
#define LINEAGENTSTATE_NOTREADY                 0x00000002      // TAPI v2.0
#define LINEAGENTSTATE_READY                    0x00000004      // TAPI v2.0
#define LINEAGENTSTATE_BUSYACD                  0x00000008      // TAPI v2.0
#define LINEAGENTSTATE_BUSYINCOMING             0x00000010      // TAPI v2.0
#define LINEAGENTSTATE_BUSYOUTBOUND             0x00000020      // TAPI v2.0
#define LINEAGENTSTATE_BUSYOTHER                0x00000040      // TAPI v2.0
#define LINEAGENTSTATE_WORKINGAFTERCALL         0x00000080      // TAPI v2.0
#define LINEAGENTSTATE_UNKNOWN                  0x00000100      // TAPI v2.0
#define LINEAGENTSTATE_UNAVAIL                  0x00000200      // TAPI v2.0

#define LINEAGENTSTATUS_GROUP                   0x00000001      // TAPI v2.0
#define LINEAGENTSTATUS_STATE                   0x00000002      // TAPI v2.0
#define LINEAGENTSTATUS_NEXTSTATE               0x00000004      // TAPI v2.0
#define LINEAGENTSTATUS_ACTIVITY                0x00000008      // TAPI v2.0
#define LINEAGENTSTATUS_ACTIVITYLIST            0x00000010      // TAPI v2.0
#define LINEAGENTSTATUS_GROUPLIST               0x00000020      // TAPI v2.0
#define LINEAGENTSTATUS_CAPSCHANGE              0x00000040      // TAPI v2.0
#define LINEAGENTSTATUS_VALIDSTATES             0x00000080      // TAPI v2.0
#define LINEAGENTSTATUS_VALIDNEXTSTATES         0x00000100      // TAPI v2.0
#endif


#define LINEANSWERMODE_NONE                     0x00000001
#define LINEANSWERMODE_DROP                     0x00000002
#define LINEANSWERMODE_HOLD                     0x00000004

#define LINEBEARERMODE_VOICE                    0x00000001
#define LINEBEARERMODE_SPEECH                   0x00000002
#define LINEBEARERMODE_MULTIUSE                 0x00000004
#define LINEBEARERMODE_DATA                     0x00000008
#define LINEBEARERMODE_ALTSPEECHDATA            0x00000010
#define LINEBEARERMODE_NONCALLSIGNALING         0x00000020
#define LINEBEARERMODE_PASSTHROUGH              0x00000040      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEBEARERMODE_RESTRICTEDDATA           0x00000080      // TAPI v2.0
#endif

#define LINEBUSYMODE_STATION                    0x00000001
#define LINEBUSYMODE_TRUNK                      0x00000002
#define LINEBUSYMODE_UNKNOWN                    0x00000004
#define LINEBUSYMODE_UNAVAIL                    0x00000008

#define LINECALLCOMPLCOND_BUSY                  0x00000001
#define LINECALLCOMPLCOND_NOANSWER              0x00000002

#define LINECALLCOMPLMODE_CAMPON                0x00000001
#define LINECALLCOMPLMODE_CALLBACK              0x00000002
#define LINECALLCOMPLMODE_INTRUDE               0x00000004
#define LINECALLCOMPLMODE_MESSAGE               0x00000008

#define LINECALLFEATURE_ACCEPT                  0x00000001
#define LINECALLFEATURE_ADDTOCONF               0x00000002
#define LINECALLFEATURE_ANSWER                  0x00000004
#define LINECALLFEATURE_BLINDTRANSFER           0x00000008
#define LINECALLFEATURE_COMPLETECALL            0x00000010
#define LINECALLFEATURE_COMPLETETRANSF          0x00000020
#define LINECALLFEATURE_DIAL                    0x00000040
#define LINECALLFEATURE_DROP                    0x00000080
#define LINECALLFEATURE_GATHERDIGITS            0x00000100
#define LINECALLFEATURE_GENERATEDIGITS          0x00000200
#define LINECALLFEATURE_GENERATETONE            0x00000400
#define LINECALLFEATURE_HOLD                    0x00000800
#define LINECALLFEATURE_MONITORDIGITS           0x00001000
#define LINECALLFEATURE_MONITORMEDIA            0x00002000
#define LINECALLFEATURE_MONITORTONES            0x00004000
#define LINECALLFEATURE_PARK                    0x00008000
#define LINECALLFEATURE_PREPAREADDCONF          0x00010000
#define LINECALLFEATURE_REDIRECT                0x00020000
#define LINECALLFEATURE_REMOVEFROMCONF          0x00040000
#define LINECALLFEATURE_SECURECALL              0x00080000
#define LINECALLFEATURE_SENDUSERUSER            0x00100000
#define LINECALLFEATURE_SETCALLPARAMS           0x00200000
#define LINECALLFEATURE_SETMEDIACONTROL         0x00400000
#define LINECALLFEATURE_SETTERMINAL             0x00800000
#define LINECALLFEATURE_SETUPCONF               0x01000000
#define LINECALLFEATURE_SETUPTRANSFER           0x02000000
#define LINECALLFEATURE_SWAPHOLD                0x04000000
#define LINECALLFEATURE_UNHOLD                  0x08000000
#define LINECALLFEATURE_RELEASEUSERUSERINFO     0x10000000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLFEATURE_SETTREATMENT            0x20000000      // TAPI v2.0
#define LINECALLFEATURE_SETQOS                  0x40000000      // TAPI v2.0
#define LINECALLFEATURE_SETCALLDATA             0x80000000      // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLFEATURE2_NOHOLDCONFERENCE       0x00000001      // TAPI v2.0
#define LINECALLFEATURE2_ONESTEPTRANSFER        0x00000002      // TAPI v2.0
#define LINECALLFEATURE2_COMPLCAMPON            0x00000004      // TAPI v2.0
#define LINECALLFEATURE2_COMPLCALLBACK          0x00000008      // TAPI v2.0
#define LINECALLFEATURE2_COMPLINTRUDE           0x00000010      // TAPI v2.0
#define LINECALLFEATURE2_COMPLMESSAGE           0x00000020      // TAPI v2.0
#define LINECALLFEATURE2_TRANSFERNORM           0x00000040      // TAPI v2.0
#define LINECALLFEATURE2_TRANSFERCONF           0x00000080      // TAPI v2.0
#define LINECALLFEATURE2_PARKDIRECT             0x00000100      // TAPI v2.0
#define LINECALLFEATURE2_PARKNONDIRECT          0x00000200      // TAPI v2.0
#endif

#define LINECALLINFOSTATE_OTHER                 0x00000001
#define LINECALLINFOSTATE_DEVSPECIFIC           0x00000002
#define LINECALLINFOSTATE_BEARERMODE            0x00000004
#define LINECALLINFOSTATE_RATE                  0x00000008
#define LINECALLINFOSTATE_MEDIAMODE             0x00000010
#define LINECALLINFOSTATE_APPSPECIFIC           0x00000020
#define LINECALLINFOSTATE_CALLID                0x00000040
#define LINECALLINFOSTATE_RELATEDCALLID         0x00000080
#define LINECALLINFOSTATE_ORIGIN                0x00000100
#define LINECALLINFOSTATE_REASON                0x00000200
#define LINECALLINFOSTATE_COMPLETIONID          0x00000400
#define LINECALLINFOSTATE_NUMOWNERINCR          0x00000800
#define LINECALLINFOSTATE_NUMOWNERDECR          0x00001000
#define LINECALLINFOSTATE_NUMMONITORS           0x00002000
#define LINECALLINFOSTATE_TRUNK                 0x00004000
#define LINECALLINFOSTATE_CALLERID              0x00008000
#define LINECALLINFOSTATE_CALLEDID              0x00010000
#define LINECALLINFOSTATE_CONNECTEDID           0x00020000
#define LINECALLINFOSTATE_REDIRECTIONID         0x00040000
#define LINECALLINFOSTATE_REDIRECTINGID         0x00080000
#define LINECALLINFOSTATE_DISPLAY               0x00100000
#define LINECALLINFOSTATE_USERUSERINFO          0x00200000
#define LINECALLINFOSTATE_HIGHLEVELCOMP         0x00400000
#define LINECALLINFOSTATE_LOWLEVELCOMP          0x00800000
#define LINECALLINFOSTATE_CHARGINGINFO          0x01000000
#define LINECALLINFOSTATE_TERMINAL              0x02000000
#define LINECALLINFOSTATE_DIALPARAMS            0x04000000
#define LINECALLINFOSTATE_MONITORMODES          0x08000000
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLINFOSTATE_TREATMENT             0x10000000      // TAPI v2.0
#define LINECALLINFOSTATE_QOS                   0x20000000      // TAPI v2.0
#define LINECALLINFOSTATE_CALLDATA              0x40000000      // TAPI v2.0
#endif

#define LINECALLORIGIN_OUTBOUND                 0x00000001
#define LINECALLORIGIN_INTERNAL                 0x00000002
#define LINECALLORIGIN_EXTERNAL                 0x00000004
#define LINECALLORIGIN_UNKNOWN                  0x00000010
#define LINECALLORIGIN_UNAVAIL                  0x00000020
#define LINECALLORIGIN_CONFERENCE               0x00000040
#define LINECALLORIGIN_INBOUND                  0x00000080      // TAPI v1.4

#define LINECALLPARAMFLAGS_SECURE               0x00000001
#define LINECALLPARAMFLAGS_IDLE                 0x00000002
#define LINECALLPARAMFLAGS_BLOCKID              0x00000004
#define LINECALLPARAMFLAGS_ORIGOFFHOOK          0x00000008
#define LINECALLPARAMFLAGS_DESTOFFHOOK          0x00000010
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLPARAMFLAGS_NOHOLDCONFERENCE     0x00000020      // TAPI v2.0
#define LINECALLPARAMFLAGS_PREDICTIVEDIAL       0x00000040      // TAPI v2.0
#define LINECALLPARAMFLAGS_ONESTEPTRANSFER      0x00000080      // TAPI v2.0
#endif

#define LINECALLPARTYID_BLOCKED                 0x00000001
#define LINECALLPARTYID_OUTOFAREA               0x00000002
#define LINECALLPARTYID_NAME                    0x00000004
#define LINECALLPARTYID_ADDRESS                 0x00000008
#define LINECALLPARTYID_PARTIAL                 0x00000010
#define LINECALLPARTYID_UNKNOWN                 0x00000020
#define LINECALLPARTYID_UNAVAIL                 0x00000040

#define LINECALLPRIVILEGE_NONE                  0x00000001
#define LINECALLPRIVILEGE_MONITOR               0x00000002
#define LINECALLPRIVILEGE_OWNER                 0x00000004

#define LINECALLREASON_DIRECT                   0x00000001
#define LINECALLREASON_FWDBUSY                  0x00000002
#define LINECALLREASON_FWDNOANSWER              0x00000004
#define LINECALLREASON_FWDUNCOND                0x00000008
#define LINECALLREASON_PICKUP                   0x00000010
#define LINECALLREASON_UNPARK                   0x00000020
#define LINECALLREASON_REDIRECT                 0x00000040
#define LINECALLREASON_CALLCOMPLETION           0x00000080
#define LINECALLREASON_TRANSFER                 0x00000100
#define LINECALLREASON_REMINDER                 0x00000200
#define LINECALLREASON_UNKNOWN                  0x00000400
#define LINECALLREASON_UNAVAIL                  0x00000800
#define LINECALLREASON_INTRUDE                  0x00001000      // TAPI v1.4
#define LINECALLREASON_PARKED                   0x00002000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLREASON_CAMPEDON                 0x00004000      // TAPI v2.0
#define LINECALLREASON_ROUTEREQUEST             0x00008000      // TAPI v2.0
#endif

#define LINECALLSELECT_LINE                     0x00000001
#define LINECALLSELECT_ADDRESS                  0x00000002
#define LINECALLSELECT_CALL                     0x00000004

#define LINECALLSTATE_IDLE                      0x00000001
#define LINECALLSTATE_OFFERING                  0x00000002
#define LINECALLSTATE_ACCEPTED                  0x00000004
#define LINECALLSTATE_DIALTONE                  0x00000008
#define LINECALLSTATE_DIALING                   0x00000010
#define LINECALLSTATE_RINGBACK                  0x00000020
#define LINECALLSTATE_BUSY                      0x00000040
#define LINECALLSTATE_SPECIALINFO               0x00000080
#define LINECALLSTATE_CONNECTED                 0x00000100
#define LINECALLSTATE_PROCEEDING                0x00000200
#define LINECALLSTATE_ONHOLD                    0x00000400
#define LINECALLSTATE_CONFERENCED               0x00000800
#define LINECALLSTATE_ONHOLDPENDCONF            0x00001000
#define LINECALLSTATE_ONHOLDPENDTRANSFER        0x00002000
#define LINECALLSTATE_DISCONNECTED              0x00004000
#define LINECALLSTATE_UNKNOWN                   0x00008000

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLTREATMENT_SILENCE               0x00000001      // TAPI v2.0
#define LINECALLTREATMENT_RINGBACK              0x00000002      // TAPI v2.0
#define LINECALLTREATMENT_BUSY                  0x00000003      // TAPI v2.0
#define LINECALLTREATMENT_MUSIC                 0x00000004      // TAPI v2.0
#endif

#define LINECARDOPTION_PREDEFINED               0x00000001      // TAPI v1.4
#define LINECARDOPTION_HIDDEN                   0x00000002      // TAPI v1.4

#define LINECONNECTEDMODE_ACTIVE                0x00000001      // TAPI v1.4
#define LINECONNECTEDMODE_INACTIVE              0x00000002      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECONNECTEDMODE_ACTIVEHELD            0x00000004      // TAPI v2.0
#define LINECONNECTEDMODE_INACTIVEHELD          0x00000008      // TAPI v2.0
#define LINECONNECTEDMODE_CONFIRMED             0x00000010      // TAPI v2.0
#endif

#define LINEDEVCAPFLAGS_CROSSADDRCONF           0x00000001
#define LINEDEVCAPFLAGS_HIGHLEVCOMP             0x00000002
#define LINEDEVCAPFLAGS_LOWLEVCOMP              0x00000004
#define LINEDEVCAPFLAGS_MEDIACONTROL            0x00000008
#define LINEDEVCAPFLAGS_MULTIPLEADDR            0x00000010
#define LINEDEVCAPFLAGS_CLOSEDROP               0x00000020
#define LINEDEVCAPFLAGS_DIALBILLING             0x00000040
#define LINEDEVCAPFLAGS_DIALQUIET               0x00000080
#define LINEDEVCAPFLAGS_DIALDIALTONE            0x00000100

#define LINEDEVSTATE_OTHER                      0x00000001
#define LINEDEVSTATE_RINGING                    0x00000002
#define LINEDEVSTATE_CONNECTED                  0x00000004
#define LINEDEVSTATE_DISCONNECTED               0x00000008
#define LINEDEVSTATE_MSGWAITON                  0x00000010
#define LINEDEVSTATE_MSGWAITOFF                 0x00000020
#define LINEDEVSTATE_INSERVICE                  0x00000040
#define LINEDEVSTATE_OUTOFSERVICE               0x00000080
#define LINEDEVSTATE_MAINTENANCE                0x00000100
#define LINEDEVSTATE_OPEN                       0x00000200
#define LINEDEVSTATE_CLOSE                      0x00000400
#define LINEDEVSTATE_NUMCALLS                   0x00000800
#define LINEDEVSTATE_NUMCOMPLETIONS             0x00001000
#define LINEDEVSTATE_TERMINALS                  0x00002000
#define LINEDEVSTATE_ROAMMODE                   0x00004000
#define LINEDEVSTATE_BATTERY                    0x00008000
#define LINEDEVSTATE_SIGNAL                     0x00010000
#define LINEDEVSTATE_DEVSPECIFIC                0x00020000
#define LINEDEVSTATE_REINIT                     0x00040000
#define LINEDEVSTATE_LOCK                       0x00080000
#define LINEDEVSTATE_CAPSCHANGE                 0x00100000      // TAPI v1.4
#define LINEDEVSTATE_CONFIGCHANGE               0x00200000      // TAPI v1.4
#define LINEDEVSTATE_TRANSLATECHANGE            0x00400000      // TAPI v1.4
#define LINEDEVSTATE_COMPLCANCEL                0x00800000      // TAPI v1.4
#define LINEDEVSTATE_REMOVED                    0x01000000      // TAPI v1.4

#define LINEDEVSTATUSFLAGS_CONNECTED            0x00000001
#define LINEDEVSTATUSFLAGS_MSGWAIT              0x00000002
#define LINEDEVSTATUSFLAGS_INSERVICE            0x00000004
#define LINEDEVSTATUSFLAGS_LOCKED               0x00000008

#define LINEDIALTONEMODE_NORMAL                 0x00000001
#define LINEDIALTONEMODE_SPECIAL                0x00000002
#define LINEDIALTONEMODE_INTERNAL               0x00000004
#define LINEDIALTONEMODE_EXTERNAL               0x00000008
#define LINEDIALTONEMODE_UNKNOWN                0x00000010
#define LINEDIALTONEMODE_UNAVAIL                0x00000020
    
#define LINEDIGITMODE_PULSE                     0x00000001
#define LINEDIGITMODE_DTMF                      0x00000002
#define LINEDIGITMODE_DTMFEND                   0x00000004
    
#define LINEDISCONNECTMODE_NORMAL               0x00000001
#define LINEDISCONNECTMODE_UNKNOWN              0x00000002
#define LINEDISCONNECTMODE_REJECT               0x00000004
#define LINEDISCONNECTMODE_PICKUP               0x00000008
#define LINEDISCONNECTMODE_FORWARDED            0x00000010
#define LINEDISCONNECTMODE_BUSY                 0x00000020
#define LINEDISCONNECTMODE_NOANSWER             0x00000040
#define LINEDISCONNECTMODE_BADADDRESS           0x00000080
#define LINEDISCONNECTMODE_UNREACHABLE          0x00000100
#define LINEDISCONNECTMODE_CONGESTION           0x00000200
#define LINEDISCONNECTMODE_INCOMPATIBLE         0x00000400
#define LINEDISCONNECTMODE_UNAVAIL              0x00000800
#define LINEDISCONNECTMODE_NODIALTONE           0x00001000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEDISCONNECTMODE_NUMBERCHANGED        0x00002000      // TAPI v2.0
#define LINEDISCONNECTMODE_OUTOFORDER           0x00004000      // TAPI v2.0
#define LINEDISCONNECTMODE_TEMPFAILURE          0x00008000      // TAPI v2.0
#define LINEDISCONNECTMODE_QOSUNAVAIL           0x00010000      // TAPI v2.0
#define LINEDISCONNECTMODE_BLOCKED              0x00020000      // TAPI v2.0
#define LINEDISCONNECTMODE_DONOTDISTURB         0x00040000      // TAPI v2.0
#endif

#define LINEERR_ALLOCATED                       0x80000001
#define LINEERR_BADDEVICEID                     0x80000002
#define LINEERR_BEARERMODEUNAVAIL               0x80000003
#define LINEERR_CALLUNAVAIL                     0x80000005
#define LINEERR_COMPLETIONOVERRUN               0x80000006
#define LINEERR_CONFERENCEFULL                  0x80000007
#define LINEERR_DIALBILLING                     0x80000008
#define LINEERR_DIALDIALTONE                    0x80000009
#define LINEERR_DIALPROMPT                      0x8000000A
#define LINEERR_DIALQUIET                       0x8000000B
#define LINEERR_INCOMPATIBLEAPIVERSION          0x8000000C
#define LINEERR_INCOMPATIBLEEXTVERSION          0x8000000D
#define LINEERR_INIFILECORRUPT                  0x8000000E
#define LINEERR_INUSE                           0x8000000F
#define LINEERR_INVALADDRESS                    0x80000010
#define LINEERR_INVALADDRESSID                  0x80000011
#define LINEERR_INVALADDRESSMODE                0x80000012
#define LINEERR_INVALADDRESSSTATE               0x80000013
#define LINEERR_INVALAPPHANDLE                  0x80000014
#define LINEERR_INVALAPPNAME                    0x80000015
#define LINEERR_INVALBEARERMODE                 0x80000016
#define LINEERR_INVALCALLCOMPLMODE              0x80000017
#define LINEERR_INVALCALLHANDLE                 0x80000018
#define LINEERR_INVALCALLPARAMS                 0x80000019
#define LINEERR_INVALCALLPRIVILEGE              0x8000001A
#define LINEERR_INVALCALLSELECT                 0x8000001B
#define LINEERR_INVALCALLSTATE                  0x8000001C
#define LINEERR_INVALCALLSTATELIST              0x8000001D
#define LINEERR_INVALCARD                       0x8000001E
#define LINEERR_INVALCOMPLETIONID               0x8000001F
#define LINEERR_INVALCONFCALLHANDLE             0x80000020
#define LINEERR_INVALCONSULTCALLHANDLE          0x80000021
#define LINEERR_INVALCOUNTRYCODE                0x80000022
#define LINEERR_INVALDEVICECLASS                0x80000023
#define LINEERR_INVALDEVICEHANDLE               0x80000024
#define LINEERR_INVALDIALPARAMS                 0x80000025
#define LINEERR_INVALDIGITLIST                  0x80000026
#define LINEERR_INVALDIGITMODE                  0x80000027
#define LINEERR_INVALDIGITS                     0x80000028
#define LINEERR_INVALEXTVERSION                 0x80000029
#define LINEERR_INVALGROUPID                    0x8000002A
#define LINEERR_INVALLINEHANDLE                 0x8000002B
#define LINEERR_INVALLINESTATE                  0x8000002C
#define LINEERR_INVALLOCATION                   0x8000002D
#define LINEERR_INVALMEDIALIST                  0x8000002E
#define LINEERR_INVALMEDIAMODE                  0x8000002F
#define LINEERR_INVALMESSAGEID                  0x80000030
#define LINEERR_INVALPARAM                      0x80000032
#define LINEERR_INVALPARKID                     0x80000033
#define LINEERR_INVALPARKMODE                   0x80000034
#define LINEERR_INVALPOINTER                    0x80000035
#define LINEERR_INVALPRIVSELECT                 0x80000036
#define LINEERR_INVALRATE                       0x80000037
#define LINEERR_INVALREQUESTMODE                0x80000038
#define LINEERR_INVALTERMINALID                 0x80000039
#define LINEERR_INVALTERMINALMODE               0x8000003A
#define LINEERR_INVALTIMEOUT                    0x8000003B
#define LINEERR_INVALTONE                       0x8000003C
#define LINEERR_INVALTONELIST                   0x8000003D
#define LINEERR_INVALTONEMODE                   0x8000003E
#define LINEERR_INVALTRANSFERMODE               0x8000003F
#define LINEERR_LINEMAPPERFAILED                0x80000040
#define LINEERR_NOCONFERENCE                    0x80000041
#define LINEERR_NODEVICE                        0x80000042
#define LINEERR_NODRIVER                        0x80000043
#define LINEERR_NOMEM                           0x80000044
#define LINEERR_NOREQUEST                       0x80000045
#define LINEERR_NOTOWNER                        0x80000046
#define LINEERR_NOTREGISTERED                   0x80000047
#define LINEERR_OPERATIONFAILED                 0x80000048
#define LINEERR_OPERATIONUNAVAIL                0x80000049
#define LINEERR_RATEUNAVAIL                     0x8000004A
#define LINEERR_RESOURCEUNAVAIL                 0x8000004B
#define LINEERR_REQUESTOVERRUN                  0x8000004C
#define LINEERR_STRUCTURETOOSMALL               0x8000004D
#define LINEERR_TARGETNOTFOUND                  0x8000004E
#define LINEERR_TARGETSELF                      0x8000004F
#define LINEERR_UNINITIALIZED                   0x80000050
#define LINEERR_USERUSERINFOTOOBIG              0x80000051
#define LINEERR_REINIT                          0x80000052
#define LINEERR_ADDRESSBLOCKED                  0x80000053
#define LINEERR_BILLINGREJECTED                 0x80000054
#define LINEERR_INVALFEATURE                    0x80000055
#define LINEERR_NOMULTIPLEINSTANCE              0x80000056
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEERR_INVALAGENTID                    0x80000057      // TAPI v2.0
#define LINEERR_INVALAGENTGROUP                 0x80000058      // TAPI v2.0
#define LINEERR_INVALPASSWORD                   0x80000059      // TAPI v2.0
#define LINEERR_INVALAGENTSTATE                 0x8000005A      // TAPI v2.0
#define LINEERR_INVALAGENTACTIVITY              0x8000005B      // TAPI v2.0
#define LINEERR_DIALVOICEDETECT                 0x8000005C      // TAPI v2.0
#endif

#define LINEFEATURE_DEVSPECIFIC                 0x00000001
#define LINEFEATURE_DEVSPECIFICFEAT             0x00000002
#define LINEFEATURE_FORWARD                     0x00000004
#define LINEFEATURE_MAKECALL                    0x00000008
#define LINEFEATURE_SETMEDIACONTROL             0x00000010
#define LINEFEATURE_SETTERMINAL                 0x00000020
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEFEATURE_SETDEVSTATUS                0x00000040      // TAPI v2.0
#define LINEFEATURE_FORWARDFWD                  0x00000080      // TAPI v2.0
#define LINEFEATURE_FORWARDDND                  0x00000100      // TAPI v2.0
#endif

#define LINEFORWARDMODE_UNCOND                  0x00000001
#define LINEFORWARDMODE_UNCONDINTERNAL          0x00000002
#define LINEFORWARDMODE_UNCONDEXTERNAL          0x00000004
#define LINEFORWARDMODE_UNCONDSPECIFIC          0x00000008
#define LINEFORWARDMODE_BUSY                    0x00000010
#define LINEFORWARDMODE_BUSYINTERNAL            0x00000020
#define LINEFORWARDMODE_BUSYEXTERNAL            0x00000040
#define LINEFORWARDMODE_BUSYSPECIFIC            0x00000080
#define LINEFORWARDMODE_NOANSW                  0x00000100
#define LINEFORWARDMODE_NOANSWINTERNAL          0x00000200
#define LINEFORWARDMODE_NOANSWEXTERNAL          0x00000400
#define LINEFORWARDMODE_NOANSWSPECIFIC          0x00000800
#define LINEFORWARDMODE_BUSYNA                  0x00001000
#define LINEFORWARDMODE_BUSYNAINTERNAL          0x00002000
#define LINEFORWARDMODE_BUSYNAEXTERNAL          0x00004000
#define LINEFORWARDMODE_BUSYNASPECIFIC          0x00008000
#define LINEFORWARDMODE_UNKNOWN                 0x00010000      // TAPI v1.4
#define LINEFORWARDMODE_UNAVAIL                 0x00020000      // TAPI v1.4

#define LINEGATHERTERM_BUFFERFULL               0x00000001
#define LINEGATHERTERM_TERMDIGIT                0x00000002
#define LINEGATHERTERM_FIRSTTIMEOUT             0x00000004
#define LINEGATHERTERM_INTERTIMEOUT             0x00000008
#define LINEGATHERTERM_CANCEL                   0x00000010

#define LINEGENERATETERM_DONE                   0x00000001
#define LINEGENERATETERM_CANCEL                 0x00000002

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEINITIALIZEEXOPTION_USEHIDDENWINDOW      0x00000001  // TAPI v2.0
#define LINEINITIALIZEEXOPTION_USEEVENT             0x00000002  // TAPI v2.0
#define LINEINITIALIZEEXOPTION_USECOMPLETIONPORT    0x00000004  // TAPI v2.0
#endif

#define LINELOCATIONOPTION_PULSEDIAL            0x00000001      // TAPI v1.4

#define LINEMAPPER                              0xFFFFFFFF

#define LINEMEDIACONTROL_NONE                   0x00000001
#define LINEMEDIACONTROL_START                  0x00000002
#define LINEMEDIACONTROL_RESET                  0x00000004
#define LINEMEDIACONTROL_PAUSE                  0x00000008
#define LINEMEDIACONTROL_RESUME                 0x00000010
#define LINEMEDIACONTROL_RATEUP                 0x00000020
#define LINEMEDIACONTROL_RATEDOWN               0x00000040
#define LINEMEDIACONTROL_RATENORMAL             0x00000080
#define LINEMEDIACONTROL_VOLUMEUP               0x00000100
#define LINEMEDIACONTROL_VOLUMEDOWN             0x00000200
#define LINEMEDIACONTROL_VOLUMENORMAL           0x00000400

#define LINEMEDIAMODE_UNKNOWN                   0x00000002
#define LINEMEDIAMODE_INTERACTIVEVOICE          0x00000004
#define LINEMEDIAMODE_AUTOMATEDVOICE            0x00000008
#define LINEMEDIAMODE_DATAMODEM                 0x00000010
#define LINEMEDIAMODE_G3FAX                     0x00000020
#define LINEMEDIAMODE_TDD                       0x00000040
#define LINEMEDIAMODE_G4FAX                     0x00000080
#define LINEMEDIAMODE_DIGITALDATA               0x00000100
#define LINEMEDIAMODE_TELETEX                   0x00000200
#define LINEMEDIAMODE_VIDEOTEX                  0x00000400
#define LINEMEDIAMODE_TELEX                     0x00000800
#define LINEMEDIAMODE_MIXED                     0x00001000
#define LINEMEDIAMODE_ADSI                      0x00002000
#define LINEMEDIAMODE_VOICEVIEW                 0x00004000      // TAPI v1.4
#define LAST_LINEMEDIAMODE                      0x00004000

#define LINEOFFERINGMODE_ACTIVE                 0x00000001      // TAPI v1.4
#define LINEOFFERINGMODE_INACTIVE               0x00000002      // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEOPENOPTION_SINGLEADDRESS            0x80000000      // TAPI v2.0
#define LINEOPENOPTION_PROXY                    0x40000000      // TAPI v2.0
#endif

#define LINEPARKMODE_DIRECTED                   0x00000001
#define LINEPARKMODE_NONDIRECTED                0x00000002

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEPROXYREQUEST_SETAGENTGROUP          0x00000001      // TAPI v2.0
#define LINEPROXYREQUEST_SETAGENTSTATE          0x00000002      // TAPI v2.0
#define LINEPROXYREQUEST_SETAGENTACTIVITY       0x00000003      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTCAPS           0x00000004      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTSTATUS         0x00000005      // TAPI v2.0
#define LINEPROXYREQUEST_AGENTSPECIFIC          0x00000006      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTACTIVITYLIST   0x00000007      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTGROUPLIST      0x00000008      // TAPI v2.0
#endif

#define LINEREMOVEFROMCONF_NONE                 0x00000001
#define LINEREMOVEFROMCONF_LAST                 0x00000002
#define LINEREMOVEFROMCONF_ANY                  0x00000003

#define LINEREQUESTMODE_MAKECALL                0x00000001
#define LINEREQUESTMODE_MEDIACALL               0x00000002
#define LINEREQUESTMODE_DROP                    0x00000004
#define LAST_LINEREQUESTMODE                    LINEREQUESTMODE_MEDIACALL

#define LINEROAMMODE_UNKNOWN                    0x00000001
#define LINEROAMMODE_UNAVAIL                    0x00000002
#define LINEROAMMODE_HOME                       0x00000004
#define LINEROAMMODE_ROAMA                      0x00000008
#define LINEROAMMODE_ROAMB                      0x00000010

#define LINESPECIALINFO_NOCIRCUIT               0x00000001
#define LINESPECIALINFO_CUSTIRREG               0x00000002
#define LINESPECIALINFO_REORDER                 0x00000004
#define LINESPECIALINFO_UNKNOWN                 0x00000008
#define LINESPECIALINFO_UNAVAIL                 0x00000010

#define LINETERMDEV_PHONE                       0x00000001
#define LINETERMDEV_HEADSET                     0x00000002
#define LINETERMDEV_SPEAKER                     0x00000004

#define LINETERMMODE_BUTTONS                    0x00000001
#define LINETERMMODE_LAMPS                      0x00000002
#define LINETERMMODE_DISPLAY                    0x00000004
#define LINETERMMODE_RINGER                     0x00000008
#define LINETERMMODE_HOOKSWITCH                 0x00000010
#define LINETERMMODE_MEDIATOLINE                0x00000020
#define LINETERMMODE_MEDIAFROMLINE              0x00000040
#define LINETERMMODE_MEDIABIDIRECT              0x00000080

#define LINETERMSHARING_PRIVATE                 0x00000001
#define LINETERMSHARING_SHAREDEXCL              0x00000002
#define LINETERMSHARING_SHAREDCONF              0x00000004

#define LINETOLLLISTOPTION_ADD                  0x00000001
#define LINETOLLLISTOPTION_REMOVE               0x00000002

#define LINETONEMODE_CUSTOM                     0x00000001
#define LINETONEMODE_RINGBACK                   0x00000002
#define LINETONEMODE_BUSY                       0x00000004
#define LINETONEMODE_BEEP                       0x00000008
#define LINETONEMODE_BILLING                    0x00000010

#define LINETRANSFERMODE_TRANSFER               0x00000001
#define LINETRANSFERMODE_CONFERENCE             0x00000002

#define LINETRANSLATEOPTION_CARDOVERRIDE        0x00000001
#define LINETRANSLATEOPTION_CANCELCALLWAITING   0x00000002      // TAPI v1.4
#define LINETRANSLATEOPTION_FORCELOCAL          0x00000004      // TAPI v1.4
#define LINETRANSLATEOPTION_FORCELD             0x00000008      // TAPI v1.4

#define LINETRANSLATERESULT_CANONICAL           0x00000001
#define LINETRANSLATERESULT_INTERNATIONAL       0x00000002
#define LINETRANSLATERESULT_LONGDISTANCE        0x00000004
#define LINETRANSLATERESULT_LOCAL               0x00000008
#define LINETRANSLATERESULT_INTOLLLIST          0x00000010
#define LINETRANSLATERESULT_NOTINTOLLLIST       0x00000020
#define LINETRANSLATERESULT_DIALBILLING         0x00000040
#define LINETRANSLATERESULT_DIALQUIET           0x00000080
#define LINETRANSLATERESULT_DIALDIALTONE        0x00000100
#define LINETRANSLATERESULT_DIALPROMPT          0x00000200
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINETRANSLATERESULT_VOICEDETECT         0x00000400      // TAPI v2.0
#endif

#define PHONEBUTTONFUNCTION_UNKNOWN             0x00000000
#define PHONEBUTTONFUNCTION_CONFERENCE          0x00000001
#define PHONEBUTTONFUNCTION_TRANSFER            0x00000002
#define PHONEBUTTONFUNCTION_DROP                0x00000003
#define PHONEBUTTONFUNCTION_HOLD                0x00000004
#define PHONEBUTTONFUNCTION_RECALL              0x00000005
#define PHONEBUTTONFUNCTION_DISCONNECT          0x00000006
#define PHONEBUTTONFUNCTION_CONNECT             0x00000007
#define PHONEBUTTONFUNCTION_MSGWAITON           0x00000008
#define PHONEBUTTONFUNCTION_MSGWAITOFF          0x00000009
#define PHONEBUTTONFUNCTION_SELECTRING          0x0000000A
#define PHONEBUTTONFUNCTION_ABBREVDIAL          0x0000000B
#define PHONEBUTTONFUNCTION_FORWARD             0x0000000C
#define PHONEBUTTONFUNCTION_PICKUP              0x0000000D
#define PHONEBUTTONFUNCTION_RINGAGAIN           0x0000000E
#define PHONEBUTTONFUNCTION_PARK                0x0000000F
#define PHONEBUTTONFUNCTION_REJECT              0x00000010
#define PHONEBUTTONFUNCTION_REDIRECT            0x00000011
#define PHONEBUTTONFUNCTION_MUTE                0x00000012
#define PHONEBUTTONFUNCTION_VOLUMEUP            0x00000013
#define PHONEBUTTONFUNCTION_VOLUMEDOWN          0x00000014
#define PHONEBUTTONFUNCTION_SPEAKERON           0x00000015
#define PHONEBUTTONFUNCTION_SPEAKEROFF          0x00000016
#define PHONEBUTTONFUNCTION_FLASH               0x00000017
#define PHONEBUTTONFUNCTION_DATAON              0x00000018
#define PHONEBUTTONFUNCTION_DATAOFF             0x00000019
#define PHONEBUTTONFUNCTION_DONOTDISTURB        0x0000001A
#define PHONEBUTTONFUNCTION_INTERCOM            0x0000001B
#define PHONEBUTTONFUNCTION_BRIDGEDAPP          0x0000001C
#define PHONEBUTTONFUNCTION_BUSY                0x0000001D
#define PHONEBUTTONFUNCTION_CALLAPP             0x0000001E
#define PHONEBUTTONFUNCTION_DATETIME            0x0000001F
#define PHONEBUTTONFUNCTION_DIRECTORY           0x00000020
#define PHONEBUTTONFUNCTION_COVER               0x00000021
#define PHONEBUTTONFUNCTION_CALLID              0x00000022
#define PHONEBUTTONFUNCTION_LASTNUM             0x00000023
#define PHONEBUTTONFUNCTION_NIGHTSRV            0x00000024
#define PHONEBUTTONFUNCTION_SENDCALLS           0x00000025
#define PHONEBUTTONFUNCTION_MSGINDICATOR        0x00000026
#define PHONEBUTTONFUNCTION_REPDIAL             0x00000027
#define PHONEBUTTONFUNCTION_SETREPDIAL          0x00000028
#define PHONEBUTTONFUNCTION_SYSTEMSPEED         0x00000029
#define PHONEBUTTONFUNCTION_STATIONSPEED        0x0000002A
#define PHONEBUTTONFUNCTION_CAMPON              0x0000002B
#define PHONEBUTTONFUNCTION_SAVEREPEAT          0x0000002C
#define PHONEBUTTONFUNCTION_QUEUECALL           0x0000002D
#define PHONEBUTTONFUNCTION_NONE                0x0000002E

#define PHONEBUTTONMODE_DUMMY                   0x00000001
#define PHONEBUTTONMODE_CALL                    0x00000002
#define PHONEBUTTONMODE_FEATURE                 0x00000004
#define PHONEBUTTONMODE_KEYPAD                  0x00000008
#define PHONEBUTTONMODE_LOCAL                   0x00000010
#define PHONEBUTTONMODE_DISPLAY                 0x00000020

#define PHONEBUTTONSTATE_UP                     0x00000001
#define PHONEBUTTONSTATE_DOWN                   0x00000002
#define PHONEBUTTONSTATE_UNKNOWN                0x00000004      // TAPI v1.4
#define PHONEBUTTONSTATE_UNAVAIL                0x00000008      // TAPI v1.4

#define PHONEERR_ALLOCATED                      0x90000001
#define PHONEERR_BADDEVICEID                    0x90000002
#define PHONEERR_INCOMPATIBLEAPIVERSION         0x90000003
#define PHONEERR_INCOMPATIBLEEXTVERSION         0x90000004
#define PHONEERR_INIFILECORRUPT                 0x90000005
#define PHONEERR_INUSE                          0x90000006
#define PHONEERR_INVALAPPHANDLE                 0x90000007
#define PHONEERR_INVALAPPNAME                   0x90000008
#define PHONEERR_INVALBUTTONLAMPID              0x90000009
#define PHONEERR_INVALBUTTONMODE                0x9000000A
#define PHONEERR_INVALBUTTONSTATE               0x9000000B
#define PHONEERR_INVALDATAID                    0x9000000C
#define PHONEERR_INVALDEVICECLASS               0x9000000D
#define PHONEERR_INVALEXTVERSION                0x9000000E
#define PHONEERR_INVALHOOKSWITCHDEV             0x9000000F
#define PHONEERR_INVALHOOKSWITCHMODE            0x90000010
#define PHONEERR_INVALLAMPMODE                  0x90000011
#define PHONEERR_INVALPARAM                     0x90000012
#define PHONEERR_INVALPHONEHANDLE               0x90000013
#define PHONEERR_INVALPHONESTATE                0x90000014
#define PHONEERR_INVALPOINTER                   0x90000015
#define PHONEERR_INVALPRIVILEGE                 0x90000016
#define PHONEERR_INVALRINGMODE                  0x90000017
#define PHONEERR_NODEVICE                       0x90000018
#define PHONEERR_NODRIVER                       0x90000019
#define PHONEERR_NOMEM                          0x9000001A
#define PHONEERR_NOTOWNER                       0x9000001B
#define PHONEERR_OPERATIONFAILED                0x9000001C
#define PHONEERR_OPERATIONUNAVAIL               0x9000001D
#define PHONEERR_RESOURCEUNAVAIL                0x9000001F
#define PHONEERR_REQUESTOVERRUN                 0x90000020
#define PHONEERR_STRUCTURETOOSMALL              0x90000021
#define PHONEERR_UNINITIALIZED                  0x90000022
#define PHONEERR_REINIT                         0x90000023

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define PHONEFEATURE_GETBUTTONINFO              0x00000001      // TAPI v2.0
#define PHONEFEATURE_GETDATA                    0x00000002      // TAPI v2.0
#define PHONEFEATURE_GETDISPLAY                 0x00000004      // TAPI v2.0
#define PHONEFEATURE_GETGAINHANDSET             0x00000008      // TAPI v2.0
#define PHONEFEATURE_GETGAINSPEAKER             0x00000010      // TAPI v2.0
#define PHONEFEATURE_GETGAINHEADSET             0x00000020      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHHANDSET       0x00000040      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHSPEAKER       0x00000080      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHHEADSET       0x00000100      // TAPI v2.0
#define PHONEFEATURE_GETLAMP                    0x00000200      // TAPI v2.0
#define PHONEFEATURE_GETRING                    0x00000400      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMEHANDSET           0x00000800      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMESPEAKER           0x00001000      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMEHEADSET           0x00002000      // TAPI v2.0
#define PHONEFEATURE_SETBUTTONINFO              0x00004000      // TAPI v2.0
#define PHONEFEATURE_SETDATA                    0x00008000      // TAPI v2.0
#define PHONEFEATURE_SETDISPLAY                 0x00010000      // TAPI v2.0
#define PHONEFEATURE_SETGAINHANDSET             0x00020000      // TAPI v2.0
#define PHONEFEATURE_SETGAINSPEAKER             0x00040000      // TAPI v2.0
#define PHONEFEATURE_SETGAINHEADSET             0x00080000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHHANDSET       0x00100000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHSPEAKER       0x00200000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHHEADSET       0x00400000      // TAPI v2.0
#define PHONEFEATURE_SETLAMP                    0x00800000      // TAPI v2.0
#define PHONEFEATURE_SETRING                    0x01000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMEHANDSET           0x02000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMESPEAKER           0x04000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMEHEADSET           0x08000000      // TAPI v2.0
#endif

#define PHONEHOOKSWITCHDEV_HANDSET              0x00000001
#define PHONEHOOKSWITCHDEV_SPEAKER              0x00000002
#define PHONEHOOKSWITCHDEV_HEADSET              0x00000004

#define PHONEHOOKSWITCHMODE_ONHOOK              0x00000001
#define PHONEHOOKSWITCHMODE_MIC                 0x00000002
#define PHONEHOOKSWITCHMODE_SPEAKER             0x00000004
#define PHONEHOOKSWITCHMODE_MICSPEAKER          0x00000008
#define PHONEHOOKSWITCHMODE_UNKNOWN             0x00000010

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define PHONEINITIALIZEEXOPTION_USEHIDDENWINDOW     0x00000001  // TAPI v2.0
#define PHONEINITIALIZEEXOPTION_USEEVENT            0x00000002  // TAPI v2.0
#define PHONEINITIALIZEEXOPTION_USECOMPLETIONPORT   0x00000004  // TAPI v2.0
#endif

#define PHONELAMPMODE_DUMMY                     0x00000001
#define PHONELAMPMODE_OFF                       0x00000002
#define PHONELAMPMODE_STEADY                    0x00000004
#define PHONELAMPMODE_WINK                      0x00000008
#define PHONELAMPMODE_FLASH                     0x00000010
#define PHONELAMPMODE_FLUTTER                   0x00000020
#define PHONELAMPMODE_BROKENFLUTTER             0x00000040
#define PHONELAMPMODE_UNKNOWN                   0x00000080

#define PHONEPRIVILEGE_MONITOR                  0x00000001
#define PHONEPRIVILEGE_OWNER                    0x00000002

#define PHONESTATE_OTHER                        0x00000001
#define PHONESTATE_CONNECTED                    0x00000002
#define PHONESTATE_DISCONNECTED                 0x00000004
#define PHONESTATE_OWNER                        0x00000008
#define PHONESTATE_MONITORS                     0x00000010
#define PHONESTATE_DISPLAY                      0x00000020
#define PHONESTATE_LAMP                         0x00000040
#define PHONESTATE_RINGMODE                     0x00000080
#define PHONESTATE_RINGVOLUME                   0x00000100
#define PHONESTATE_HANDSETHOOKSWITCH            0x00000200
#define PHONESTATE_HANDSETVOLUME                0x00000400
#define PHONESTATE_HANDSETGAIN                  0x00000800
#define PHONESTATE_SPEAKERHOOKSWITCH            0x00001000
#define PHONESTATE_SPEAKERVOLUME                0x00002000
#define PHONESTATE_SPEAKERGAIN                  0x00004000
#define PHONESTATE_HEADSETHOOKSWITCH            0x00008000
#define PHONESTATE_HEADSETVOLUME                0x00010000
#define PHONESTATE_HEADSETGAIN                  0x00020000
#define PHONESTATE_SUSPEND                      0x00040000
#define PHONESTATE_RESUME                       0x00080000
#define PHONESTATE_DEVSPECIFIC                  0x00100000
#define PHONESTATE_REINIT                       0x00200000
#define PHONESTATE_CAPSCHANGE                   0x00400000      // TAPI v1.4
#define PHONESTATE_REMOVED                      0x00800000      // TAPI v1.4

#define PHONESTATUSFLAGS_CONNECTED              0x00000001
#define PHONESTATUSFLAGS_SUSPENDED              0x00000002

#define STRINGFORMAT_ASCII                      0x00000001
#define STRINGFORMAT_DBCS                       0x00000002
#define STRINGFORMAT_UNICODE                    0x00000003
#define STRINGFORMAT_BINARY                     0x00000004

#define TAPI_REPLY                              WM_USER + 99

#define TAPIERR_CONNECTED                       0L
#define TAPIERR_DROPPED                         -1L
#define TAPIERR_NOREQUESTRECIPIENT              -2L
#define TAPIERR_REQUESTQUEUEFULL                -3L
#define TAPIERR_INVALDESTADDRESS                -4L
#define TAPIERR_INVALWINDOWHANDLE               -5L
#define TAPIERR_INVALDEVICECLASS                -6L
#define TAPIERR_INVALDEVICEID                   -7L
#define TAPIERR_DEVICECLASSUNAVAIL              -8L
#define TAPIERR_DEVICEIDUNAVAIL                 -9L
#define TAPIERR_DEVICEINUSE                     -10L
#define TAPIERR_DESTBUSY                        -11L
#define TAPIERR_DESTNOANSWER                    -12L
#define TAPIERR_DESTUNAVAIL                     -13L
#define TAPIERR_UNKNOWNWINHANDLE                -14L
#define TAPIERR_UNKNOWNREQUESTID                -15L
#define TAPIERR_REQUESTFAILED                   -16L
#define TAPIERR_REQUESTCANCELLED                -17L
#define TAPIERR_INVALPOINTER                    -18L

#define TAPIMAXDESTADDRESSSIZE                  80L
#define TAPIMAXAPPNAMESIZE                      40L
#define TAPIMAXCALLEDPARTYSIZE                  40L
#define TAPIMAXCOMMENTSIZE                      80L
#define TAPIMAXDEVICECLASSSIZE                  40L
#define TAPIMAXDEVICEIDSIZE                     40L



typedef struct lineaddresscaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwLineDeviceID;
    DWORD       dwAddressSize;
    DWORD       dwAddressOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;
    DWORD       dwAddressSharing;
    DWORD       dwAddressStates;
    DWORD       dwCallInfoStates;
    DWORD       dwCallerIDFlags;
    DWORD       dwCalledIDFlags;
    DWORD       dwConnectedIDFlags;
    DWORD       dwRedirectionIDFlags;
    DWORD       dwRedirectingIDFlags;
    DWORD       dwCallStates;
    DWORD       dwDialToneModes;
    DWORD       dwBusyModes;
    DWORD       dwSpecialInfo;
    DWORD       dwDisconnectModes;
    DWORD       dwMaxNumActiveCalls;
    DWORD       dwMaxNumOnHoldCalls;
    DWORD       dwMaxNumOnHoldPendingCalls;
    DWORD       dwMaxNumConference;
    DWORD       dwMaxNumTransConf;
    DWORD       dwAddrCapFlags;
    DWORD       dwCallFeatures;
    DWORD       dwRemoveFromConfCaps;
    DWORD       dwRemoveFromConfState;
    DWORD       dwTransferModes;
    DWORD       dwParkModes;
    DWORD       dwForwardModes;
    DWORD       dwMaxForwardEntries;
    DWORD       dwMaxSpecificEntries;
    DWORD       dwMinFwdNumRings;
    DWORD       dwMaxFwdNumRings;
    DWORD       dwMaxCallCompletions;
    DWORD       dwCallCompletionConds;
    DWORD       dwCallCompletionModes;
    DWORD       dwNumCompletionMessages;
    DWORD       dwCompletionMsgTextEntrySize;
    DWORD       dwCompletionMsgTextSize;
    DWORD       dwCompletionMsgTextOffset;

    DWORD       dwAddressFeatures;                              // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwPredictiveAutoTransferStates;                 // TAPI v2.0
    DWORD       dwNumCallTreatments;                            // TAPI v2.0
    DWORD       dwCallTreatmentListSize;                        // TAPI v2.0
    DWORD       dwCallTreatmentListOffset;                      // TAPI v2.0
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
    DWORD       dwMaxCallDataSize;                              // TAPI v2.0
    DWORD       dwCallFeatures2;                                // TAPI v2.0
    DWORD       dwMaxNoAnswerTimeout;                           // TAPI v2.0
    DWORD       dwConnectedModes;                               // TAPI v2.0
    DWORD       dwOfferingModes;                                // TAPI v2.0
    DWORD       dwAvailableMediaModes;                          // TAPI v2.0
#endif

} LINEADDRESSCAPS, FAR *LPLINEADDRESSCAPS;

typedef struct lineaddressstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumInUse;
    DWORD       dwNumActiveCalls;
    DWORD       dwNumOnHoldCalls;
    DWORD       dwNumOnHoldPendCalls;
    DWORD       dwAddressFeatures;
    DWORD       dwNumRingsNoAnswer;
    DWORD       dwForwardNumEntries;
    DWORD       dwForwardSize;
    DWORD       dwForwardOffset;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

} LINEADDRESSSTATUS, FAR *LPLINEADDRESSSTATUS;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct lineagentactivityentry_tag
{
    DWORD       dwID;                                           // TAPI v2.0
    DWORD       dwNameSize;                                     // TAPI v2.0
    DWORD       dwNameOffset;                                   // TAPI v2.0

} LINEAGENTACTIVITYENTRY, *LPLINEAGENTACTIVITYENTRY;

typedef struct lineagentactivitylist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwNumEntries;                                   // TAPI v2.0
    DWORD       dwListSize;                                     // TAPI v2.0
    DWORD       dwListOffset;                                   // TAPI v2.0

} LINEAGENTACTIVITYLIST, *LPLINEAGENTACTIVITYLIST;

typedef struct lineagentcaps_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwAgentHandlerInfoSize;                         // TAPI v2.0
    DWORD       dwAgentHandlerInfoOffset;                       // TAPI v2.0
    DWORD       dwCapsVersion;                                  // TAPI v2.0
    DWORD       dwFeatures;                                     // TAPI v2.0
    DWORD       dwStates;                                       // TAPI v2.0
    DWORD       dwNextStates;                                   // TAPI v2.0
    DWORD       dwMaxNumGroupEntries;                           // TAPI v2.0
    DWORD       dwAgentStatusMessages;                          // TAPI v2.0
    DWORD       dwNumAgentExtensionIDs;                         // TAPI v2.0
    DWORD       dwAgentExtensionIDListSize;                     // TAPI v2.0
    DWORD       dwAgentExtensionIDListOffset;                   // TAPI v2.0

} LINEAGENTCAPS, *LPLINEAGENTCAPS;

typedef struct lineagentgroupentry_tag
{
    struct
    {
        DWORD   dwGroupID1;                                     // TAPI v2.0
        DWORD   dwGroupID2;                                     // TAPI v2.0
        DWORD   dwGroupID3;                                     // TAPI v2.0
        DWORD   dwGroupID4;                                     // TAPI v2.0

    } GroupID;

    DWORD       dwNameSize;                                     // TAPI v2.0
    DWORD       dwNameOffset;                                   // TAPI v2.0

} LINEAGENTGROUPENTRY, *LPLINEAGENTGROUPENTRY;

typedef struct lineagentgrouplist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwNumEntries;                                   // TAPI v2.0
    DWORD       dwListSize;                                     // TAPI v2.0
    DWORD       dwListOffset;                                   // TAPI v2.0

} LINEAGENTGROUPLIST, *LPLINEAGENTGROUPLIST;

typedef struct lineagentstatus_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwNumEntries;                                   // TAPI v2.0
    DWORD       dwGroupListSize;                                // TAPI v2.0
    DWORD       dwGroupListOffset;                              // TAPI v2.0
    DWORD       dwState;                                        // TAPI v2.0
    DWORD       dwNextState;                                    // TAPI v2.0
    DWORD       dwActivityID;                                   // TAPI v2.0
    DWORD       dwActivitySize;                                 // TAPI v2.0
    DWORD       dwActivityOffset;                               // TAPI v2.0
    DWORD       dwAgentFeatures;                                // TAPI v2.0
    DWORD       dwValidStates;                                  // TAPI v2.0
    DWORD       dwValidNextStates;                              // TAPI v2.0

} LINEAGENTSTATUS, *LPLINEAGENTSTATUS;

typedef struct lineappinfo_tag
{
    DWORD       dwMachineNameSize;                              // TAPI v2.0
    DWORD       dwMachineNameOffset;                            // TAPI v2.0
    DWORD       dwUserNameSize;                                 // TAPI v2.0
    DWORD       dwUserNameOffset;                               // TAPI v2.0
    DWORD       dwModuleFilenameSize;                           // TAPI v2.0
    DWORD       dwModuleFilenameOffset;                         // TAPI v2.0
    DWORD       dwFriendlyNameSize;                             // TAPI v2.0
    DWORD       dwFriendlyNameOffset;                           // TAPI v2.0
    DWORD       dwMediaModes;                                   // TAPI v2.0
    DWORD       dwAddressID;                                    // TAPI v2.0

} LINEAPPINFO, *LPLINEAPPINFO;
#endif


typedef struct linedialparams_tag
{
    DWORD       dwDialPause;
    DWORD       dwDialSpeed;
    DWORD       dwDigitDuration;
    DWORD       dwWaitForDialtone;

} LINEDIALPARAMS, FAR *LPLINEDIALPARAMS;

typedef struct linecallinfo_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    HLINE       hLine;
    DWORD       dwLineDeviceID;
    DWORD       dwAddressID;
    DWORD       dwBearerMode;
    DWORD       dwRate;
    DWORD       dwMediaMode;
    DWORD       dwAppSpecific;
    DWORD       dwCallID;
    DWORD       dwRelatedCallID;
    DWORD       dwCallParamFlags;
    DWORD       dwCallStates;
    DWORD       dwMonitorDigitModes;
    DWORD       dwMonitorMediaModes;
    LINEDIALPARAMS  DialParams;
    DWORD       dwOrigin;
    DWORD       dwReason;
    DWORD       dwCompletionID;
    DWORD       dwNumOwners;
    DWORD       dwNumMonitors;
    DWORD       dwCountryCode;
    DWORD       dwTrunk;
    DWORD       dwCallerIDFlags;
    DWORD       dwCallerIDSize;
    DWORD       dwCallerIDOffset;
    DWORD       dwCallerIDNameSize;
    DWORD       dwCallerIDNameOffset;
    DWORD       dwCalledIDFlags;
    DWORD       dwCalledIDSize;
    DWORD       dwCalledIDOffset;
    DWORD       dwCalledIDNameSize;
    DWORD       dwCalledIDNameOffset;
    DWORD       dwConnectedIDFlags;
    DWORD       dwConnectedIDSize;
    DWORD       dwConnectedIDOffset;
    DWORD       dwConnectedIDNameSize;
    DWORD       dwConnectedIDNameOffset;
    DWORD       dwRedirectionIDFlags;
    DWORD       dwRedirectionIDSize;
    DWORD       dwRedirectionIDOffset;
    DWORD       dwRedirectionIDNameSize;
    DWORD       dwRedirectionIDNameOffset;
    DWORD       dwRedirectingIDFlags;
    DWORD       dwRedirectingIDSize;
    DWORD       dwRedirectingIDOffset;
    DWORD       dwRedirectingIDNameSize;
    DWORD       dwRedirectingIDNameOffset;
    DWORD       dwAppNameSize;
    DWORD       dwAppNameOffset;
    DWORD       dwDisplayableAddressSize;
    DWORD       dwDisplayableAddressOffset;
    DWORD       dwCalledPartySize;
    DWORD       dwCalledPartyOffset;
    DWORD       dwCommentSize;
    DWORD       dwCommentOffset;
    DWORD       dwDisplaySize;
    DWORD       dwDisplayOffset;
    DWORD       dwUserUserInfoSize;
    DWORD       dwUserUserInfoOffset;
    DWORD       dwHighLevelCompSize;
    DWORD       dwHighLevelCompOffset;
    DWORD       dwLowLevelCompSize;
    DWORD       dwLowLevelCompOffset;
    DWORD       dwChargingInfoSize;
    DWORD       dwChargingInfoOffset;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwCallTreatment;                                // TAPI v2.0
    DWORD       dwCallDataSize;                                 // TAPI v2.0
    DWORD       dwCallDataOffset;                               // TAPI v2.0
    DWORD       dwSendingFlowspecSize;                          // TAPI v2.0
    DWORD       dwSendingFlowspecOffset;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecSize;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecOffset;                      // TAPI v2.0
#endif

} LINECALLINFO, FAR *LPLINECALLINFO;

typedef struct linecalllist_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwCallsNumEntries;
    DWORD       dwCallsSize;
    DWORD       dwCallsOffset;

} LINECALLLIST, FAR *LPLINECALLLIST;

typedef struct linecallparams_tag               // Defaults:
{
    DWORD       dwTotalSize;                    // ---------
    DWORD       dwBearerMode;                   // voice
    DWORD       dwMinRate;                      // (3.1kHz)
    DWORD       dwMaxRate;                      // (3.1kHz)
    DWORD       dwMediaMode;                    // interactiveVoice
    DWORD       dwCallParamFlags;               // 0
    DWORD       dwAddressMode;                  // addressID
    DWORD       dwAddressID;                    // (any available)
    LINEDIALPARAMS  DialParams;                 // (0, 0, 0, 0)
    DWORD       dwOrigAddressSize;              // 0
    DWORD       dwOrigAddressOffset;
    DWORD       dwDisplayableAddressSize;
    DWORD       dwDisplayableAddressOffset;
    DWORD       dwCalledPartySize;              // 0
    DWORD       dwCalledPartyOffset;
    DWORD       dwCommentSize;                  // 0
    DWORD       dwCommentOffset;
    DWORD       dwUserUserInfoSize;             // 0
    DWORD       dwUserUserInfoOffset;
    DWORD       dwHighLevelCompSize;            // 0
    DWORD       dwHighLevelCompOffset;
    DWORD       dwLowLevelCompSize;             // 0
    DWORD       dwLowLevelCompOffset;
    DWORD       dwDevSpecificSize;              // 0
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwPredictiveAutoTransferStates;                 // TAPI v2.0
    DWORD       dwTargetAddressSize;                            // TAPI v2.0
    DWORD       dwTargetAddressOffset;                          // TAPI v2.0
    DWORD       dwSendingFlowspecSize;                          // TAPI v2.0
    DWORD       dwSendingFlowspecOffset;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecSize;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecOffset;                      // TAPI v2.0
    DWORD       dwDeviceClassSize;                              // TAPI v2.0
    DWORD       dwDeviceClassOffset;                            // TAPI v2.0
    DWORD       dwDeviceConfigSize;                             // TAPI v2.0
    DWORD       dwDeviceConfigOffset;                           // TAPI v2.0
    DWORD       dwCallDataSize;                                 // TAPI v2.0
    DWORD       dwCallDataOffset;                               // TAPI v2.0
    DWORD       dwNoAnswerTimeout;                              // TAPI v2.0
    DWORD       dwCallingPartyIDSize;                           // TAPI v2.0
    DWORD       dwCallingPartyIDOffset;                         // TAPI v2.0
#endif

} LINECALLPARAMS, FAR *LPLINECALLPARAMS;

typedef struct linecallstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwCallState;
    DWORD       dwCallStateMode;
    DWORD       dwCallPrivilege;
    DWORD       dwCallFeatures;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwCallFeatures2;                                // TAPI v2.0
#if WIN32
    SYSTEMTIME  tStateEntryTime;                                // TAPI v2.0
#else
    WORD        tStateEntryTime[8];                             // TAPI v2.0
#endif
#endif

} LINECALLSTATUS, FAR *LPLINECALLSTATUS;


#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linecalltreatmententry_tag
{
    DWORD       dwCallTreatmentID;                              // TAPI v2.0
    DWORD       dwCallTreatmentNameSize;                        // TAPI v2.0
    DWORD       dwCallTreatmentNameOffset;                      // TAPI v2.0

} LINECALLTREATMENTENTRY, FAR *LPLINECALLTREATMENTENTRY;
#endif


typedef struct linecardentry_tag
{
    DWORD       dwPermanentCardID;
    DWORD       dwCardNameSize;
    DWORD       dwCardNameOffset;
    DWORD       dwCardNumberDigits;                             // TAPI v1.4
    DWORD       dwSameAreaRuleSize;                             // TAPI v1.4
    DWORD       dwSameAreaRuleOffset;                           // TAPI v1.4
    DWORD       dwLongDistanceRuleSize;                         // TAPI v1.4
    DWORD       dwLongDistanceRuleOffset;                       // TAPI v1.4
    DWORD       dwInternationalRuleSize;                        // TAPI v1.4
    DWORD       dwInternationalRuleOffset;                      // TAPI v1.4
    DWORD       dwOptions;                                      // TAPI v1.4

} LINECARDENTRY, FAR *LPLINECARDENTRY;

typedef struct linecountryentry_tag
{
    DWORD       dwCountryID;                                    // TAPI v1.4
    DWORD       dwCountryCode;                                  // TAPI v1.4
    DWORD       dwNextCountryID;                                // TAPI v1.4
    DWORD       dwCountryNameSize;                              // TAPI v1.4
    DWORD       dwCountryNameOffset;                            // TAPI v1.4
    DWORD       dwSameAreaRuleSize;                             // TAPI v1.4
    DWORD       dwSameAreaRuleOffset;                           // TAPI v1.4
    DWORD       dwLongDistanceRuleSize;                         // TAPI v1.4
    DWORD       dwLongDistanceRuleOffset;                       // TAPI v1.4
    DWORD       dwInternationalRuleSize;                        // TAPI v1.4
    DWORD       dwInternationalRuleOffset;                      // TAPI v1.4

} LINECOUNTRYENTRY, FAR *LPLINECOUNTRYENTRY;

typedef struct linecountrylist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v1.4
    DWORD       dwNeededSize;                                   // TAPI v1.4
    DWORD       dwUsedSize;                                     // TAPI v1.4
    DWORD       dwNumCountries;                                 // TAPI v1.4
    DWORD       dwCountryListSize;                              // TAPI v1.4
    DWORD       dwCountryListOffset;                            // TAPI v1.4

} LINECOUNTRYLIST, FAR *LPLINECOUNTRYLIST;

typedef struct linedevcaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwProviderInfoSize;
    DWORD       dwProviderInfoOffset;
    DWORD       dwSwitchInfoSize;
    DWORD       dwSwitchInfoOffset;
    DWORD       dwPermanentLineID;
    DWORD       dwLineNameSize;
    DWORD       dwLineNameOffset;
    DWORD       dwStringFormat;
    DWORD       dwAddressModes;
    DWORD       dwNumAddresses;
    DWORD       dwBearerModes;
    DWORD       dwMaxRate;
    DWORD       dwMediaModes;
    DWORD       dwGenerateToneModes;
    DWORD       dwGenerateToneMaxNumFreq;
    DWORD       dwGenerateDigitModes;
    DWORD       dwMonitorToneMaxNumFreq;
    DWORD       dwMonitorToneMaxNumEntries;
    DWORD       dwMonitorDigitModes;
    DWORD       dwGatherDigitsMinTimeout;
    DWORD       dwGatherDigitsMaxTimeout;
    DWORD       dwMedCtlDigitMaxListSize;
    DWORD       dwMedCtlMediaMaxListSize;
    DWORD       dwMedCtlToneMaxListSize;
    DWORD       dwMedCtlCallStateMaxListSize;
    DWORD       dwDevCapFlags;
    DWORD       dwMaxNumActiveCalls;
    DWORD       dwAnswerMode;
    DWORD       dwRingModes;
    DWORD       dwLineStates;
    DWORD       dwUUIAcceptSize;
    DWORD       dwUUIAnswerSize;
    DWORD       dwUUIMakeCallSize;
    DWORD       dwUUIDropSize;
    DWORD       dwUUISendUserUserInfoSize;
    DWORD       dwUUICallInfoSize;
    LINEDIALPARAMS  MinDialParams;
    LINEDIALPARAMS  MaxDialParams;
    LINEDIALPARAMS  DefaultDialParams;
    DWORD       dwNumTerminals;
    DWORD       dwTerminalCapsSize;
    DWORD       dwTerminalCapsOffset;
    DWORD       dwTerminalTextEntrySize;
    DWORD       dwTerminalTextSize;
    DWORD       dwTerminalTextOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

    DWORD       dwLineFeatures;                                 // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwSettableDevStatus;                            // TAPI v2.0
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
#endif

} LINEDEVCAPS, FAR *LPLINEDEVCAPS;
    
typedef struct linedevstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumOpens;
    DWORD       dwOpenMediaModes;
    DWORD       dwNumActiveCalls;
    DWORD       dwNumOnHoldCalls;
    DWORD       dwNumOnHoldPendCalls;
    DWORD       dwLineFeatures;
    DWORD       dwNumCallCompletions;
    DWORD       dwRingMode;
    DWORD       dwSignalLevel;
    DWORD       dwBatteryLevel;
    DWORD       dwRoamMode;
    DWORD       dwDevStatusFlags;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwAvailableMediaModes;                          // TAPI v2.0
    DWORD       dwAppInfoSize;                                  // TAPI v2.0
    DWORD       dwAppInfoOffset;                                // TAPI v2.0
#endif

} LINEDEVSTATUS, FAR *LPLINEDEVSTATUS;

typedef struct lineextensionid_tag
{
    DWORD       dwExtensionID0;
    DWORD       dwExtensionID1;
    DWORD       dwExtensionID2;
    DWORD       dwExtensionID3;

} LINEEXTENSIONID, FAR *LPLINEEXTENSIONID;

typedef struct lineforward_tag
{
    DWORD       dwForwardMode;
    DWORD       dwCallerAddressSize;
    DWORD       dwCallerAddressOffset;
    DWORD       dwDestCountryCode;
    DWORD       dwDestAddressSize;
    DWORD       dwDestAddressOffset;

} LINEFORWARD, FAR *LPLINEFORWARD;

typedef struct lineforwardlist_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNumEntries;
    LINEFORWARD ForwardList[1];

} LINEFORWARDLIST, FAR *LPLINEFORWARDLIST;

typedef struct linegeneratetone_tag
{
    DWORD       dwFrequency;
    DWORD       dwCadenceOn;
    DWORD       dwCadenceOff;
    DWORD       dwVolume;

} LINEGENERATETONE, FAR *LPLINEGENERATETONE;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct lineinitializeexparams_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwOptions;                                      // TAPI v2.0

    union
    {
        HANDLE  hEvent;                                         // TAPI v2.0
        HANDLE  hCompletionPort;                                // TAPI v2.0

    } Handles;

    DWORD       dwCompletionKey;                                // TAPI v2.0

} LINEINITIALIZEEXPARAMS, FAR *LPLINEINITIALIZEEXPARAMS;
#endif

typedef struct linelocationentry_tag
{
    DWORD       dwPermanentLocationID;
    DWORD       dwLocationNameSize;
    DWORD       dwLocationNameOffset;
    DWORD       dwCountryCode;
    DWORD       dwCityCodeSize;
    DWORD       dwCityCodeOffset;
    DWORD       dwPreferredCardID;

    DWORD       dwLocalAccessCodeSize;                          // TAPI v1.4
    DWORD       dwLocalAccessCodeOffset;                        // TAPI v1.4
    DWORD       dwLongDistanceAccessCodeSize;                   // TAPI v1.4
    DWORD       dwLongDistanceAccessCodeOffset;                 // TAPI v1.4
    DWORD       dwTollPrefixListSize;                           // TAPI v1.4
    DWORD       dwTollPrefixListOffset;                         // TAPI v1.4
    DWORD       dwCountryID;                                    // TAPI v1.4
    DWORD       dwOptions;                                      // TAPI v1.4
    DWORD       dwCancelCallWaitingSize;                        // TAPI v1.4
    DWORD       dwCancelCallWaitingOffset;                      // TAPI v1.4

} LINELOCATIONENTRY, FAR *LPLINELOCATIONENTRY;

typedef struct linemediacontrolcallstate_tag
{
    DWORD       dwCallStates;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLCALLSTATE, FAR *LPLINEMEDIACONTROLCALLSTATE;

typedef struct linemediacontroldigit_tag
{
    DWORD       dwDigit;
    DWORD       dwDigitModes;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLDIGIT, FAR *LPLINEMEDIACONTROLDIGIT;

typedef struct linemediacontrolmedia_tag
{
    DWORD       dwMediaModes;
    DWORD       dwDuration;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLMEDIA, FAR *LPLINEMEDIACONTROLMEDIA;

typedef struct linemediacontroltone_tag
{
    DWORD       dwAppSpecific;
    DWORD       dwDuration;
    DWORD       dwFrequency1;
    DWORD       dwFrequency2;
    DWORD       dwFrequency3;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLTONE, FAR *LPLINEMEDIACONTROLTONE;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linemessage_tag
{
    DWORD       hDevice;                                        // TAPI v2.0
    DWORD       dwMessageID;                                    // TAPI v2.0
    DWORD       dwCallbackInstance;                             // TAPI v2.0
    DWORD       dwParam1;                                       // TAPI v2.0
    DWORD       dwParam2;                                       // TAPI v2.0
    DWORD       dwParam3;                                       // TAPI v2.0

} LINEMESSAGE, FAR *LPLINEMESSAGE;
#endif

typedef struct linemonitortone_tag
{
    DWORD       dwAppSpecific;
    DWORD       dwDuration;
    DWORD       dwFrequency1;
    DWORD       dwFrequency2;
    DWORD       dwFrequency3;

} LINEMONITORTONE, FAR *LPLINEMONITORTONE;

typedef struct lineproviderentry_tag
{
    DWORD       dwPermanentProviderID;                          // TAPI v1.4
    DWORD       dwProviderFilenameSize;                         // TAPI v1.4
    DWORD       dwProviderFilenameOffset;                       // TAPI v1.4

} LINEPROVIDERENTRY, FAR *LPLINEPROVIDERENTRY;

typedef struct lineproviderlist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v1.4
    DWORD       dwNeededSize;                                   // TAPI v1.4
    DWORD       dwUsedSize;                                     // TAPI v1.4
    DWORD       dwNumProviders;                                 // TAPI v1.4
    DWORD       dwProviderListSize;                             // TAPI v1.4
    DWORD       dwProviderListOffset;                           // TAPI v1.4

} LINEPROVIDERLIST, FAR *LPLINEPROVIDERLIST;


#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct lineproxyrequest_tag
{
    DWORD       dwSize;                                         // TAPI v2.0
    DWORD       dwClientMachineNameSize;                        // TAPI v2.0
    DWORD       dwClientMachineNameOffset;                      // TAPI v2.0
    DWORD       dwClientUserNameSize;                           // TAPI v2.0
    DWORD       dwClientUserNameOffset;                         // TAPI v2.0
    DWORD       dwClientAppAPIVersion;                          // TAPI v2.0
    DWORD       dwRequestType;                                  // TAPI v2.0

    union
    {
    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTGROUPLIST      GroupList;                      // TAPI v2.0

    } SetAgentGroup;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        DWORD                   dwAgentState;                   // TAPI v2.0
        DWORD                   dwNextAgentState;               // TAPI v2.0

    } SetAgentState;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        DWORD                   dwActivityID;                   // TAPI v2.0

    } SetAgentActivity;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTCAPS           AgentCaps;                      // TAPI v2.0

    } GetAgentCaps;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTSTATUS         AgentStatus;                    // TAPI v2.0

    } GetAgentStatus;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        DWORD                   dwAgentExtensionIDIndex;        // TAPI v2.0
        DWORD                   dwSize;                         // TAPI v2.0
        BYTE                    Params[1];                      // TAPI v2.0

    } AgentSpecific;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTACTIVITYLIST   ActivityList;                   // TAPI v2.0

    } GetAgentActivityList;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTGROUPLIST      GroupList;                      // TAPI v2.0

    } GetAgentGroupList;
    }; //ProxyRequestType;

} LINEPROXYREQUEST, *LPLINEPROXYREQUEST;
#endif


typedef struct linereqmakecall_tag
{
    char        szDestAddress[TAPIMAXDESTADDRESSSIZE];
    char        szAppName[TAPIMAXAPPNAMESIZE];
    char        szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    char        szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMAKECALL, FAR *LPLINEREQMAKECALL;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linereqmakecallW_tag
{
    WCHAR       szDestAddress[TAPIMAXDESTADDRESSSIZE];
    WCHAR       szAppName[TAPIMAXAPPNAMESIZE];
    WCHAR       szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    WCHAR       szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMAKECALLW, FAR *LPLINEREQMAKECALLW;
#endif

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define LINEREQMAKECALL LINEREQMAKECALLW
#endif
#endif

typedef struct linereqmediacall_tag
{
    HWND        hWnd;
    WPARAM      wRequestID;
    char        szDeviceClass[TAPIMAXDEVICECLASSSIZE];
    unsigned char   ucDeviceID[TAPIMAXDEVICEIDSIZE];
    DWORD       dwSize;
    DWORD       dwSecure;
    char        szDestAddress[TAPIMAXDESTADDRESSSIZE];
    char        szAppName[TAPIMAXAPPNAMESIZE];
    char        szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    char        szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMEDIACALL, FAR *LPLINEREQMEDIACALL;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linereqmediacallW_tag
{
    HWND        hWnd;
    WPARAM      wRequestID;
    WCHAR       szDeviceClass[TAPIMAXDEVICECLASSSIZE];
    unsigned char   ucDeviceID[TAPIMAXDEVICEIDSIZE];
    DWORD       dwSize;
    DWORD       dwSecure;
    WCHAR       szDestAddress[TAPIMAXDESTADDRESSSIZE];
    WCHAR       szAppName[TAPIMAXAPPNAMESIZE];
    WCHAR       szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    WCHAR       szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMEDIACALLW, FAR *LPLINEREQMEDIACALLW;
#endif

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define LINEREQMEDIACALL LINEREQMEDIACALLW
#endif
#endif


typedef struct linetermcaps_tag
{
    DWORD       dwTermDev;
    DWORD       dwTermModes;
    DWORD       dwTermSharing;

} LINETERMCAPS, FAR *LPLINETERMCAPS;

typedef struct linetranslatecaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumLocations;
    DWORD       dwLocationListSize;
    DWORD       dwLocationListOffset;
    DWORD       dwCurrentLocationID;
    DWORD       dwNumCards;
    DWORD       dwCardListSize;
    DWORD       dwCardListOffset;
    DWORD       dwCurrentPreferredCardID;

} LINETRANSLATECAPS, FAR *LPLINETRANSLATECAPS;

typedef struct linetranslateoutput_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwDialableStringSize;
    DWORD       dwDialableStringOffset;
    DWORD       dwDisplayableStringSize;
    DWORD       dwDisplayableStringOffset;
    DWORD       dwCurrentCountry;
    DWORD       dwDestCountry;
    DWORD       dwTranslateResults;

} LINETRANSLATEOUTPUT, FAR *LPLINETRANSLATEOUTPUT;

typedef struct phonebuttoninfo_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwButtonMode;
    DWORD       dwButtonFunction;
    DWORD       dwButtonTextSize;
    DWORD       dwButtonTextOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

    DWORD       dwButtonState;                                  // TAPI v1.4

} PHONEBUTTONINFO, FAR *LPPHONEBUTTONINFO;

typedef struct phonecaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwProviderInfoSize;
    DWORD       dwProviderInfoOffset;
    DWORD       dwPhoneInfoSize;
    DWORD       dwPhoneInfoOffset;
    DWORD       dwPermanentPhoneID;
    DWORD       dwPhoneNameSize;
    DWORD       dwPhoneNameOffset;
    DWORD       dwStringFormat;
    DWORD       dwPhoneStates;
    DWORD       dwHookSwitchDevs;
    DWORD       dwHandsetHookSwitchModes;
    DWORD       dwSpeakerHookSwitchModes;
    DWORD       dwHeadsetHookSwitchModes;
    DWORD       dwVolumeFlags;
    DWORD       dwGainFlags;
    DWORD       dwDisplayNumRows;
    DWORD       dwDisplayNumColumns;
    DWORD       dwNumRingModes;
    DWORD       dwNumButtonLamps;
    DWORD       dwButtonModesSize;
    DWORD       dwButtonModesOffset;
    DWORD       dwButtonFunctionsSize;
    DWORD       dwButtonFunctionsOffset;
    DWORD       dwLampModesSize;
    DWORD       dwLampModesOffset;
    DWORD       dwNumSetData;
    DWORD       dwSetDataSize;
    DWORD       dwSetDataOffset;
    DWORD       dwNumGetData;
    DWORD       dwGetDataSize;
    DWORD       dwGetDataOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
    DWORD       dwPhoneFeatures;                                // TAPI v2.0
    DWORD       dwSettableHandsetHookSwitchModes;               // TAPI v2.0
    DWORD       dwSettableSpeakerHookSwitchModes;               // TAPI v2.0
    DWORD       dwSettableHeadsetHookSwitchModes;               // TAPI v2.0
    DWORD       dwMonitoredHandsetHookSwitchModes;              // TAPI v2.0
    DWORD       dwMonitoredSpeakerHookSwitchModes;              // TAPI v2.0
    DWORD       dwMonitoredHeadsetHookSwitchModes;              // TAPI v2.0
#endif

} PHONECAPS, FAR *LPPHONECAPS;

typedef struct phoneextensionid_tag
{
    DWORD       dwExtensionID0;
    DWORD       dwExtensionID1;
    DWORD       dwExtensionID2;
    DWORD       dwExtensionID3;

} PHONEEXTENSIONID, FAR *LPPHONEEXTENSIONID;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct phoneinitializeexparams_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwOptions;                                      // TAPI v2.0

    union
    {
        HANDLE  hEvent;                                         // TAPI v2.0
        HANDLE  hCompletionPort;                                // TAPI v2.0

    } Handles;

    DWORD       dwCompletionKey;                                // TAPI v2.0

} PHONEINITIALIZEEXPARAMS, FAR *LPPHONEINITIALIZEEXPARAMS;

typedef struct phonemessage_tag
{
    DWORD       hDevice;                                        // TAPI v2.0
    DWORD       dwMessageID;                                    // TAPI v2.0
    DWORD       dwCallbackInstance;                             // TAPI v2.0
    DWORD       dwParam1;                                       // TAPI v2.0
    DWORD       dwParam2;                                       // TAPI v2.0
    DWORD       dwParam3;                                       // TAPI v2.0

} PHONEMESSAGE, FAR *LPPHONEMESSAGE;
#endif

typedef struct phonestatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwStatusFlags;
    DWORD       dwNumOwners;
    DWORD       dwNumMonitors;
    DWORD       dwRingMode;
    DWORD       dwRingVolume;
    DWORD       dwHandsetHookSwitchMode;
    DWORD       dwHandsetVolume;
    DWORD       dwHandsetGain;
    DWORD       dwSpeakerHookSwitchMode;
    DWORD       dwSpeakerVolume;
    DWORD       dwSpeakerGain;
    DWORD       dwHeadsetHookSwitchMode;
    DWORD       dwHeadsetVolume;
    DWORD       dwHeadsetGain;
    DWORD       dwDisplaySize;
    DWORD       dwDisplayOffset;
    DWORD       dwLampModesSize;
    DWORD       dwLampModesOffset;
    DWORD       dwOwnerNameSize;
    DWORD       dwOwnerNameOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwPhoneFeatures;                                // TAPI v2.0
#endif

} PHONESTATUS, FAR *LPPHONESTATUS;

typedef struct varstring_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwStringFormat;
    DWORD       dwStringSize;
    DWORD       dwStringOffset;

} VARSTRING, FAR *LPVARSTRING;



LONG
WINAPI
lineAccept(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineAddProvider(                                                // TAPI v1.4
    LPCSTR              lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    );

#if WIN32
LONG
WINAPI
lineAddProviderW(
    LPCSTR            lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineAddProvider lineAddProviderW
#endif

#define lineAddProviderA lineAddProvider
#endif
#endif


LONG
WINAPI
lineAddToConference(
    HCALL               hConfCall,
    HCALL               hConsultCall
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineAgentSpecific(                                              // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentExtensionIDIndex,
    LPVOID              lpParams,
    DWORD               dwSize
    );
#endif

LONG
WINAPI
lineAnswer(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineBlindTransfer(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

#if WIN32
LONG
WINAPI
lineBlindTransferW(
    HCALL               hCall,
    LPCSTR            lpszDestAddressW,
    DWORD               dwCountryCode
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineBlindTransfer lineBlineTransferW
#endif

#define lineBlindTransferA lineBlineTransfer
#endif
#endif


LONG
WINAPI
lineClose(
    HLINE               hLine
    );

LONG
WINAPI
lineCompleteCall(
    HCALL               hCall,
    LPDWORD             lpdwCompletionID,
    DWORD               dwCompletionMode,
    DWORD               dwMessageID
    );

LONG
WINAPI
lineCompleteTransfer(
    HCALL               hCall,
    HCALL               hConsultCall,
    LPHCALL             lphConfCall,
    DWORD               dwTransferMode
    );

LONG
WINAPI
lineConfigDialog(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineConfigDialogW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR            lpszDeviceClass
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineConfigDialog lineConfigDialogW
#endif

#define lineConfigDialogA lineConfigDialog
#endif
#endif


LONG
WINAPI
lineConfigDialogEdit(                                           // TAPI v1.4
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    );

#if WIN32
LONG
WINAPI
lineConfigDialogEditW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR            lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineConfigDialogEdit lineConfigDialogEditW
#endif

#define lineConfigDialogEditA lineConfigDialogEdit
#endif
#endif

LONG
WINAPI
lineConfigProvider(                                             // TAPI v1.4
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    );

LONG
WINAPI
lineDeallocateCall(
    HCALL               hCall
    );

LONG
WINAPI
lineDevSpecific(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
lineDevSpecificFeature(
    HLINE               hLine,
    DWORD               dwFeature,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
lineDial(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

#if WIN32
LONG
WINAPI
lineDialW(
    HCALL               hCall,
    LPCSTR            lpszDestAddress,
    DWORD               dwCountryCode
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineDial lineDialW
#endif

#define lineDialA lineDial
#endif
#endif

LONG
WINAPI
lineDrop(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineForward(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineForwardW(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineForward lineForwardW
#endif

#define lineForwardA lineForward
#endif
#endif

LONG
WINAPI
lineGatherDigits(
    HCALL               hCall,
    DWORD               dwDigitModes,
    LPSTR               lpsDigits,
    DWORD               dwNumDigits,
    LPCSTR              lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    );

#if WIN32
LONG
WINAPI
lineGatherDigitsW(
    HCALL               hCall,
    DWORD               dwDigitModes,
    LPWSTR              lpsDigits,
    DWORD               dwNumDigits,
    LPCSTR            lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGatherDigits lineGatherDigitsW
#endif

#define lineGatherDigitsW lineGatherDigits
#endif
#endif

LONG
WINAPI
lineGenerateDigits(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCSTR              lpszDigits,
    DWORD               dwDuration
    );

#if WIN32
LONG
WINAPI
lineGenerateDigitsW(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCSTR            lpszDigits,
    DWORD               dwDuration
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGenerateDigits lineGenerateDigitsW
#endif

#define lineGenerateDigitsA lineGenerateDigits
#endif
#endif

LONG
WINAPI
lineGenerateTone(
    HCALL               hCall,
    DWORD               dwToneMode,
    DWORD               dwDuration,
    DWORD               dwNumTones,
    LPLINEGENERATETONE  const lpTones
    );

LONG
WINAPI
lineGetAddressCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    );

#if WIN32
LONG
WINAPI
lineGetAddressCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetAddressCaps lineGetAddressCapsW
#endif

#define lineGetAddressCapsA lineGetAddressCaps
#endif
#endif

LONG
WINAPI
lineGetAddressID(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCSTR              lpsAddress,
    DWORD               dwSize
    );

#if WIN32
LONG
WINAPI
lineGetAddressIDW(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCSTR            lpsAddress,
    DWORD               dwSize
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetAddressID lineGetAddressIDW
#endif

#define lineGetAddressIDA lineGetAddressID
#endif
#endif

LONG
WINAPI
lineGetAddressStatus(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    );

#if WIN32
LONG
WINAPI
lineGetAddressStatusW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetAddressStatus lineGetAddressStatusW
#endif

#define lineGetAddressStatusA lineGetAddressStatus
#endif
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineGetAgentActivityList(                                       // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    );

LONG
WINAPI
lineGetAgentActivityListW(                                       // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetAgentActivityList lineGetAgentActivityListW
#endif

#define lineGetAgentActivityListA lineGetAgentActivityList
#endif

LONG
WINAPI
lineGetAgentCaps(                                               // TAPI v2.0
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     lpAgentCaps
    );

LONG
WINAPI
lineGetAgentGroupList(                                          // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    );

LONG
WINAPI
lineGetAgentStatus(                                             // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    );
#endif

LONG
WINAPI
lineGetAppPriority(                                             // TAPI v1.4
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    );

#if WIN32
LONG
WINAPI
lineGetAppPriorityW(                                             // TAPI v1.4
    LPCSTR            lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetAppPriority lineGetAppPriorityW
#endif

#define lineGetAppPriorityA lineGetAppPriority
#endif
#endif

LONG
WINAPI
lineGetCallInfo(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    );

#if WIN32
LONG
WINAPI
lineGetCallInfoW(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetCallInfo lineGetCallInfoW
#endif

#define lineGetCallInfoA lineGetCallInfo
#endif
#endif

LONG
WINAPI
lineGetCallStatus(
    HCALL               hCall,
    LPLINECALLSTATUS    lpCallStatus
    );

LONG
WINAPI
lineGetConfRelatedCalls(
    HCALL               hCall,
    LPLINECALLLIST      lpCallList
    );
    
LONG
WINAPI
lineGetCountry(                                                 // TAPI v1.4
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    );

#if WIN32
LONG
WINAPI
lineGetCountryW(                                                // TAPI v1.4
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetCountry lineGetCountryW
#endif

#define lineGetCountryA lineGetCountry
#endif
#endif


LONG
WINAPI
lineGetDevCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    );

#if WIN32
LONG
WINAPI
lineGetDevCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetDevCaps lineGetDevCapsW
#endif

#define lineGetDevCapsA lineGetDevCaps
#endif
#endif

LONG
WINAPI
lineGetDevConfig(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineGetDevConfigW(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCSTR            lpszDeviceClass
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetDevConfig lineGetDevConfigW
#endif

#define lineGetDevConfigA lineGetDevConfig
#endif
#endif

LONG
WINAPI
lineGetNewCalls(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwSelect,
    LPLINECALLLIST      lpCallList
    );

LONG
WINAPI
lineGetIcon(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    );

#if WIN32
LONG
WINAPI
lineGetIconW(
    DWORD               dwDeviceID,
    LPCSTR            lpszDeviceClass,
    LPHICON             lphIcon
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetIcon lineGetIconW
#endif

#define lineGetIconA lineGetIcon
#endif
#endif
    
LONG
WINAPI
lineGetID(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineGetIDW(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCSTR            lpszDeviceClass
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetID lineGetIDW
#endif

#define lineGetIDA lineGetID
#endif
#endif

LONG
WINAPI
lineGetLineDevStatus(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    );

#if WIN32
LONG
WINAPI
lineGetLineDevStatusW(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetDevStatus lineGetDevStatusW
#endif

#define lineGetDevStatusA lineGetDevStatus
#endif
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineGetMessage(                                                 // TAPI v2.0
    HLINEAPP        hLineApp,
    LPLINEMESSAGE   lpMessage,
    DWORD           dwTimeout
    );
#endif

LONG
WINAPI
lineGetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPDWORD             lpdwNumRings
    );

LONG
WINAPI
lineGetProviderList(                                            // TAPI v1.4
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    );

#if WIN32
LONG
WINAPI
lineGetProviderListW(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetProviderList lineGetProviderListW
#endif

#define lineGetProviderListA lineGetProviderList
#endif
#endif

LONG
WINAPI
lineGetRequest(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    );

#if WIN32
LONG
WINAPI
lineGetRequestW(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetRequest lineGetRequestW
#endif

#define lineGetRequestA lineGetRequest
#endif
#endif

LONG
WINAPI
lineGetStatusMessages(
    HLINE               hLine,
    LPDWORD             lpdwLineStates,
    LPDWORD             lpdwAddressStates
    );

LONG
WINAPI
lineGetTranslateCaps(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    );

#if WIN32
LONG
WINAPI
lineGetTranslateCapsW(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetTranslateCaps lineGetTranslateCapsW
#endif

#define lineGetTranslateCapsA lineGetTranslateCaps
#endif
#endif


LONG
WINAPI
lineHandoff(
    HCALL               hCall,
    LPCSTR              lpszFileName,
    DWORD               dwMediaMode
    );

#if WIN32
LONG
WINAPI
lineHandoffW(
    HCALL               hCall,
    LPCSTR            lpszFileName,
    DWORD               dwMediaMode
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineHandoff lineHandoffW
#endif

#define lineHandoffA lineHandoff
#endif
#endif

LONG
WINAPI
lineHold(
    HCALL               hCall
    );

LONG
WINAPI
lineInitialize(
    LPHLINEAPP          lphLineApp,
    HINSTANCE           hInstance,
    LINECALLBACK        lpfnCallback,
    LPCSTR              lpszAppName,
    LPDWORD             lpdwNumDevs
    );

#if WIN32
LONG
WINAPI
lineInitializeW(
    LPHLINEAPP          lphLineApp,
    HINSTANCE           hInstance,
    LINECALLBACK        lpfnCallback,
    LPCSTR            lpszAppNameW,
    LPDWORD             lpdwNumDevs
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineInitialize lineInitializeW
#endif

#define lineInitializeA lineInitialize
#endif
#endif


#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineInitializeEx(                                               // TAPI v2.0
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    );

LONG
WINAPI
lineInitializeExW(                                               // TAPI v2.0
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCSTR                    lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    );

#ifdef UNICODE
#define lineInitializeEx lineInitializeExW
#endif

#define lineInitializeExA lineInitializeEx
#endif


LONG
WINAPI
lineMakeCall(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineMakeCallW(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCSTR            lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineMakeCall lineMakeCallW
#endif

#define lineMakeCallA lineMakeCall
#endif
#endif

LONG
WINAPI
lineMonitorDigits(
    HCALL               hCall,
    DWORD               dwDigitModes
    );

LONG
WINAPI
lineMonitorMedia(
    HCALL               hCall,
    DWORD               dwMediaModes
    );

LONG
WINAPI
lineMonitorTones(
    HCALL               hCall,
    LPLINEMONITORTONE   const lpToneList,
    DWORD               dwNumEntries
    );

LONG
WINAPI
lineNegotiateAPIVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    );

LONG
WINAPI
lineNegotiateExtVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
WINAPI
lineOpen(
    HLINEAPP hLineApp, 
    DWORD dwDeviceID,
    LPHLINE lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineOpenW(
    HLINEAPP hLineApp, 
    DWORD dwDeviceID,
    LPHLINE lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineOpen lineOpenW
#endif

#define lineOpenA lineOpen
#endif
#endif

LONG
WINAPI
linePark(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCSTR              lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    );

#if WIN32
LONG
WINAPI
lineParkW(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCSTR            lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define linePark lineParkW
#endif

#define lineParkA linePark
#endif
#endif

LONG
WINAPI
linePickup(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszGroupID
    );

#if WIN32
LONG
WINAPI
linePickupW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR            lpszDestAddress,
    LPCSTR            lpszGroupID
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define linePickup linePickupW
#endif

#define linePickupA linePickup
#endif
#endif

LONG
WINAPI
linePrepareAddToConference(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
linePrepareAddToConferenceW(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define linePrepareAddToConference linePrepareAddToConferenceW
#endif

#define linePrepareAddToConferenceA linePrepareAddToConference
#endif
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineProxyMessage(                                               // TAPI v2.0
    HLINE               hLine,
    HCALL               hCall,
    DWORD               dwMsg,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    );

LONG
WINAPI
lineProxyResponse(                                              // TAPI v2.0
    HLINE               hLine,
    LPLINEPROXYREQUEST  lpProxyRequest,
    DWORD               dwResult
    );
#endif

LONG
WINAPI
lineRedirect(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

#if WIN32
LONG
WINAPI
lineRedirectW(
    HCALL               hCall,
    LPCSTR            lpszDestAddress,
    DWORD               dwCountryCode
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineRedirect lineRedirectW
#endif

#define lineRedirectA lineRedirect
#endif
#endif

LONG
WINAPI
lineRegisterRequestRecipient(
    HLINEAPP            hLineApp,
    DWORD               dwRegistrationInstance,
    DWORD               dwRequestMode,
    DWORD               bEnable
    );

LONG
WINAPI
lineReleaseUserUserInfo(                                        // TAPI v1.4
    HCALL               hCall
    );

LONG
WINAPI
lineRemoveFromConference(
    HCALL               hCall
    );

LONG
WINAPI
lineRemoveProvider(                                             // TAPI v1.4
    DWORD               dwPermanentProviderID,
    HWND                hwndOwner
    );

LONG
WINAPI
lineSecureCall(
    HCALL               hCall
    );

LONG
WINAPI
lineSendUserUserInfo(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetAgentActivity(                                           // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwActivityID
    );

LONG
WINAPI
lineSetAgentGroup(                                              // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    );

LONG
WINAPI
lineSetAgentState(                                              // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentState,
    DWORD               dwNextAgentState
    );
#endif

LONG
WINAPI
lineSetAppPriority(                                             // TAPI v1.4
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCSTR              lpszExtensionName,
    DWORD               dwPriority
    );

#if WIN32
LONG
WINAPI
lineSetAppPriorityW(                                             // TAPI v1.4
    LPCSTR            lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCSTR            lpszExtensionName,
    DWORD               dwPriority
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineSetAppPriority lineSetAppPriorityW
#endif

#define lineSetAppPriorityA lineSetAppPriority
#endif
#endif

LONG
WINAPI
lineSetAppSpecific(
    HCALL               hCall,
    DWORD               dwAppSpecific
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetCallData(                                                // TAPI v2.0
    HCALL               hCall,
    LPVOID              lpCallData,
    DWORD               dwSize
    );
#endif

LONG
WINAPI
lineSetCallParams(
    HCALL               hCall,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    const lpDialParams
    );

LONG
WINAPI
lineSetCallPrivilege(
    HCALL               hCall,
    DWORD               dwCallPrivilege
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetCallQualityOfService(                                    // TAPI v2.0
    HCALL               hCall,
    LPVOID              lpSendingFlowspec,
    DWORD               dwSendingFlowspecSize,
    LPVOID              lpReceivingFlowspec,
    DWORD               dwReceivingFlowspecSize
    );

LONG
WINAPI
lineSetCallTreatment(                                           // TAPI v2.0
    HCALL               hCall,
    DWORD               dwTreatment
    );
#endif

LONG
WINAPI
lineSetCurrentLocation(
    HLINEAPP            hLineApp,
    DWORD               dwLocation
    );

LONG
WINAPI
lineSetDevConfig(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineSetDevConfigW(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCSTR            lpszDeviceClass
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineSetDevConfig lineSetDevConfigW
#endif

#define lineSetDevConfigA lineSetDevConfig
#endif
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetLineDevStatus(                                           // TAPI v2.0
    HLINE               hLine,
    DWORD               dwStatusToChange,
    DWORD               fStatus
    );
#endif

LONG
WINAPI
lineSetMediaControl(
    HLINE                       hLine,
    DWORD                       dwAddressID,
    HCALL                       hCall,
    DWORD                       dwSelect,
    LPLINEMEDIACONTROLDIGIT     const lpDigitList,
    DWORD                       dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA     const lpMediaList,
    DWORD                       dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE      const lpToneList,
    DWORD                       dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallStateList, 
    DWORD                       dwCallStateNumEntries
    );

LONG
WINAPI
lineSetMediaMode(
    HCALL               hCall,
    DWORD               dwMediaModes
    );

LONG
WINAPI
lineSetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwNumRings
    );

LONG
WINAPI
lineSetStatusMessages(
    HLINE               hLine,
    DWORD               dwLineStates,
    DWORD               dwAddressStates
    );

LONG
WINAPI
lineSetTerminal(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    DWORD               dwTerminalModes,
    DWORD               dwTerminalID,
    DWORD               bEnable
    );

LONG
WINAPI
lineSetTollList(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCSTR              lpszAddressIn,
    DWORD               dwTollListOption
    );

#if WIN32
LONG
WINAPI
lineSetTollListW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCSTR            lpszAddressInW,
    DWORD               dwTollListOption
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineSetTollList lineSetTollListW
#endif

#define lineSetTollListA lineSetTollList
#endif
#endif


LONG
WINAPI
lineSetupConference(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineSetupConferenceW(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineSetupConference lineSetupConferenceW
#endif

#define lineSetupConferenceA lineSetupConference
#endif
#endif

LONG
WINAPI
lineSetupTransfer(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineSetupTransferW(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineSetupTransfer lineSetupTransferW
#endif

#define lineSetupTransferA lineSetupTransfer
#endif
#endif

LONG
WINAPI
lineShutdown(
    HLINEAPP            hLineApp
    );

LONG
WINAPI
lineSwapHold(
    HCALL               hActiveCall,
    HCALL               hHeldCall
    );

LONG
WINAPI
lineTranslateAddress(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                  lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    );

#if WIN32
LONG
WINAPI
lineTranslateAddressW(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineTranslateAddress lineTranslateAddressW
#endif

#define lineTranslateAddressA  lineTranslateAddress
#endif
#endif

LONG
WINAPI
lineTranslateDialog(                                            // TAPI v1.4
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCSTR              lpszAddressIn
    );

#if WIN32
LONG
WINAPI
lineTranslateDialogW(                                            // TAPI v2.0
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCSTR            lpszAddressIn
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineTranslateDialog lineTranslateDialogW
#endif

#define lineTranslateDialogA  lineTranslateDialog
#endif
#endif

LONG
WINAPI
lineUncompleteCall(
    HLINE               hLine,
    DWORD               dwCompletionID
    );

LONG
WINAPI
lineUnhold(
    HCALL               hCall
    );

LONG
WINAPI
lineUnpark(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress
    );

#if WIN32
LONG
WINAPI
lineUnparkW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR            lpszDestAddress
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineUnpark lineUnparkW
#endif

#define lineUnparkA lineUnpark
#endif
#endif



LONG
WINAPI
phoneClose(
    HPHONE              hPhone
    );

LONG
WINAPI
phoneConfigDialog(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
phoneConfigDialogW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR            lpszDeviceClass
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneConfigDialog phoneConfigDialogW
#endif

#define phoneConfigDialogA phoneConfigDialog
#endif
#endif

LONG
WINAPI
phoneDevSpecific(
    HPHONE              hPhone,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
phoneGetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    );

#if WIN32
LONG
WINAPI
phoneGetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneGetButtonInfo phoneGetButtonInfoW
#endif

#define phoneGetButtonInfoA phoneGetButtonInfo
#endif
#endif

LONG
WINAPI
phoneGetData(
    HPHONE              hPhone,
    DWORD               dwDataID,
    LPVOID              lpData,
    DWORD               dwSize
    );

LONG
WINAPI
phoneGetDevCaps(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    );

#if WIN32
LONG
WINAPI
phoneGetDevCapsW(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneGetDevCaps phoneGetDevCapsW
#endif

#define phoneGetDevCapsA phoneGetDevCaps
#endif
#endif

LONG
WINAPI
phoneGetDisplay(
    HPHONE              hPhone,
    LPVARSTRING         lpDisplay
    );

LONG
WINAPI
phoneGetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwGain
    );

LONG
WINAPI
phoneGetHookSwitch(
    HPHONE              hPhone,
    LPDWORD             lpdwHookSwitchDevs
    );

LONG
WINAPI
phoneGetIcon(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    );

#if WIN32
LONG
WINAPI
phoneGetIconW(
    DWORD               dwDeviceID,
    LPCSTR            lpszDeviceClass,
    LPHICON             lphIcon
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneGetIcon phoneGetIconW
#endif

#define phoneGetIconA phoneGetIcon
#endif
#endif

LONG
WINAPI
phoneGetID(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
phoneGetIDW(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCSTR            lpszDeviceClass
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneGetID phoneGetIDW
#endif

#define phoneGetIDA phoneGetID
#endif
#endif

LONG
WINAPI
phoneGetLamp(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPDWORD             lpdwLampMode
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
phoneGetMessage(                                                // TAPI v2.0
    HPHONEAPP       hPhoneApp,
    LPPHONEMESSAGE  lpMessage,
    DWORD           dwTimeout
    );
#endif

LONG
WINAPI
phoneGetRing(
    HPHONE              hPhone,
    LPDWORD             lpdwRingMode,
    LPDWORD             lpdwVolume
    );

LONG
WINAPI
phoneGetStatus(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    );

#if WIN32
LONG
WINAPI
phoneGetStatusW(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    );


#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneGetStatus phoneGetStatusW
#endif

#define phoneGetStatusA phoneGetStatus
#endif
#endif

LONG
WINAPI
phoneGetStatusMessages(
    HPHONE              hPhone,
    LPDWORD             lpdwPhoneStates,
    LPDWORD             lpdwButtonModes,
    LPDWORD             lpdwButtonStates
    );

LONG
WINAPI
phoneGetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwVolume
    );

LONG
WINAPI
phoneInitialize(
    LPHPHONEAPP         lphPhoneApp,
    HINSTANCE           hInstance,
    PHONECALLBACK       lpfnCallback,
    LPCSTR              lpszAppName,
    LPDWORD             lpdwNumDevs
    );

#if WIN32
LONG
WINAPI
phoneInitializeW(
    LPHPHONEAPP         lphPhoneApp,
    HINSTANCE           hInstance,
    PHONECALLBACK       lpfnCallback,
    LPCSTR            lpszAppNameW,
    LPDWORD             lpdwNumDevs
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneInitialize phoneInitializeW
#endif

#define phoneInitializeA phoneInitialize
#endif
#endif


#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
phoneInitializeEx(                                              // TAPI v2.0
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    );

LONG
WINAPI
phoneInitializeExW(                                              // TAPI v2.0
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCSTR                    lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    );

#ifdef UNICODE
#define phoneInitializeEx phoneInitializeExW
#endif

#define phoneInitializeExA phoneInitializeEx
#endif

LONG
WINAPI
phoneNegotiateAPIVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    );

LONG
WINAPI
phoneNegotiateExtVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
WINAPI
phoneOpen(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    LPHPHONE            lphPhone,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwCallbackInstance,
    DWORD               dwPrivilege
    );

LONG
WINAPI
phoneSetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    );

#if WIN32
LONG
WINAPI
phoneSetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneSetButtonInfo phoneSetButtonInfoW
#endif

#define phoneSetButtonInfoA phoneSetButtonInfo
#endif
#endif

LONG
WINAPI
phoneSetData(
    HPHONE              hPhone,
    DWORD               dwDataID,
    LPVOID              const lpData,
    DWORD               dwSize
    );

LONG
WINAPI
phoneSetDisplay(
    HPHONE              hPhone,
    DWORD               dwRow,
    DWORD               dwColumn,
    LPCSTR              lpsDisplay,
    DWORD               dwSize
    );

LONG
WINAPI
phoneSetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwGain
    );

LONG
WINAPI
phoneSetHookSwitch(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDevs,
    DWORD               dwHookSwitchMode
    );

LONG
WINAPI
phoneSetLamp(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    DWORD               dwLampMode
    );

LONG
WINAPI
phoneSetRing(
    HPHONE              hPhone,
    DWORD               dwRingMode,
    DWORD               dwVolume
    );

LONG
WINAPI
phoneSetStatusMessages(
    HPHONE              hPhone,
    DWORD               dwPhoneStates,
    DWORD               dwButtonModes,
    DWORD               dwButtonStates
    );

LONG
WINAPI
phoneSetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwVolume
    );

LONG
WINAPI
phoneShutdown(
    HPHONEAPP           hPhoneApp
    );



LONG
WINAPI
tapiGetLocationInfo(
    LPSTR               lpszCountryCode,
    LPSTR               lpszCityCode
    );
    
#if WIN32
LONG
WINAPI
tapiGetLocationInfoW(
    LPWSTR               lpszCountryCodeW,
    LPWSTR               lpszCityCodeW
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define tapiGetLocationInfo tapiGetLocationInfoW
#endif

#define tapiGetLocationInfoA tapiGetLocationInfo
#endif
#endif
    

LONG
WINAPI
tapiRequestDrop(
    HWND                hwnd,
    WPARAM              wRequestID
    );

LONG
WINAPI
tapiRequestMakeCall(
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    );

#if WIN32
LONG
WINAPI
tapiRequestMakeCallW(
    LPCSTR             lpszDestAddress,
    LPCSTR             lpszAppName,
    LPCSTR             lpszCalledParty,
    LPCSTR             lpszComment
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define tapiRequestMakeCall tapiRequestMakeCallW
#endif

#define tapiRequestMakeCallA tapiRequestMakeCall
#endif
#endif
    
LONG
WINAPI
tapiRequestMediaCall(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCSTR              lpszDeviceClass,
    LPCSTR              lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    );

#if WIN32
LONG
WINAPI
tapiRequestMediaCallW(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCSTR            lpszDeviceClass,
    LPCSTR            lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCSTR            lpszDestAddress,
    LPCSTR            lpszAppName,
    LPCSTR            lpszCalledParty,
    LPCSTR            lpszComment
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define tapiRequestMediaCall tapiRequestMediaCallW
#endif

#define tapiRequestMediaCallA tapiRequestMediaCall
#endif
#endif
    



#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#pragma pack()

#endif // TAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\userinfo.h ===
//+----------------------------------------------------------------------------
//
// File:     userinfo.h
//
// Module:   CMCFG32.DLL and CMDIAL32.DLL
//
// Synopsis: UserInfo constants
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   quintinb/nickball      Created      08/06/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_USERINFO_H_
#define _CM_USERINFO_H_


///////////////////////////////////////////////////////////////////////////////////
// define's
///////////////////////////////////////////////////////////////////////////////////

// UserInfo Identifiers 

#define UD_ID_USERNAME                  0x00000001
#define UD_ID_INET_USERNAME             0x00000002
#define UD_ID_DOMAIN                    0x00000004
#define UD_ID_PASSWORD                  0x00000008
#define UD_ID_INET_PASSWORD             0x00000010
#define UD_ID_NOPROMPT                  0x00000020
#define UD_ID_REMEMBER_PWD              0x00000040
#define UD_ID_REMEMBER_INET_PASSWORD    0x00000080
#define UD_ID_PCS                       0x00000100
#define UD_ID_ACCESSPOINTENABLED        0x00000200
#define UD_ID_CURRENTACCESSPOINT        0x00000400


//
//  Tells CM what kind of upgrade is needed.  See NeedToUpgradeUserInfo and 
//  UpgradeUserInfo below for more details
//
const int c_iNoUpgradeRequired = 0;
const int c_iUpgradeFromCmp = 1;
const int c_iUpgradeFromRegToRas = 2;

#endif // _CM_USERINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\wizdebug.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

// debugging macros

#undef ASSERT
#undef DEBUGMSG

#ifdef DEBUG

// component name define
#ifndef SZ_COMPNAME
#define SZ_COMPNAME
#endif  // SZ_COMPNAME

static void _AssertFailedSz(LPCSTR pszText,LPCSTR pszFile, int line)
{
    LPCSTR psz;
    char ach[256];
    static char szAssertFailed[] = SZ_COMPNAME "%s (%s,line %d)\r\n";

    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
    {
	if ((AnsiPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
	    break;
    }
    wsprintf(ach, szAssertFailed, pszText,psz, line);
    OutputDebugString(ach);
}

static void _AssertFailed(LPCSTR pszFile, int line)
{
    static char szAssertFailed[] = "Assertion failed";
	_AssertFailedSz(szAssertFailed,pszFile,line);

}

static void cdecl _DebugMsg(LPCSTR pszMsg, ...)
{
    char ach[2*MAX_PATH+40];  
    va_list args;

    va_start(args,pszMsg);
    wvsprintf(ach, pszMsg, args);
    //wvsprintf(ach, pszMsg, (LPSTR)(&pszMsg + 1));
	OutputDebugString(SZ_COMPNAME);
    OutputDebugString(ach);
    OutputDebugString("\r\n");
}

static void cdecl _DebugTrap(LPCSTR pszMsg, ...)
{
	_DebugMsg(pszMsg);
	DebugBreak();
	//_asm {int 3};
}

//#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  DebugBreak(); } }
//#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  DebugBreak(); } }
#define DEBUGMSG    _DebugMsg
#define DEBUGTRAP       _DebugTrap

#else // DEBUG

#define ASSERT(f)
#define ASSERTSZ(f,s)
#define DEBUGMSG    1 ? (void)0 : (void)
#define DEBUGTRAP   1 ? (void)0 : (void)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\inc\wizglob.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
// WIZGLOB.H - 	global data structures and defines for all wizard components
// 				(32-bit exe, 32-bit dll, 16-bit dll)

//	HISTORY:
//	
//	11/20/94	jeremys		Created.
//

#ifndef _WIZGLOB_H_
#define _WIZGLOB_H_

#ifndef SETUPX_INC
typedef UINT RETERR;             // setupx Return Error code type.
#endif	// SETUPX_INC

// structure to hold information about client software configuration
#include <struct.h> // separated out so thunk compiler can get at

typedef CLIENTCONFIG FAR * LPCLIENTCONFIG;
typedef char CHAR;
typedef BOOL FAR * LPBOOL;

// component defines for InstallComponent

#define IC_PPPMAC			0x0001		// install PPPMAC
#define IC_TCPIP			0x0002		// install TCP/IP
#define IC_INSTALLFILES		0x0003		// install files, etc from INF

// dwParam bits for IC_INSTALLFILES
#define ICIF_MAIL			0x0001		// install mail files
#define ICIF_RNA			0x0002		// install RNA files
#define ICIF_MSN			0x0004		// install Microsoft Network files
#define ICIF_MSN105			0x0008		// install MSN 1.05 (Rome) files
#define ICIF_INET_MAIL		0x0010		// install Internet mail files

// INSTANCE_ defines for TCP/IP configuration apis
#define INSTANCE_NETDRIVER		0x0001
#define INSTANCE_PPPDRIVER		0x0002
#define INSTANCE_ALL	   		(INSTANCE_NETDRIVER | INSTANCE_PPPDRIVER)

// PROT_ defines for protocol types
#define PROT_TCPIP				0x0001
#define PROT_IPX				0x0002
#define PROT_NETBEUI			0x0004

#define NEED_RESTART			((WORD) -1)

#endif // _WIZGLOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\allowaccess.cpp ===
//+----------------------------------------------------------------------------
//
// File:     allowaccess.cpp
//
// Module:   Common Code
//
// Synopsis: Implements the function AllowAccessToWorld.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb    Created   12/04/01
//
//+----------------------------------------------------------------------------

LPCSTR apszAdvapi32[] = {
    "GetSidLengthRequired",
    "InitializeSid",
    "GetSidSubAuthority",
    "InitializeAcl",
    "AddAccessAllowedAceEx",
    "InitializeSecurityDescriptor",
    "SetSecurityDescriptorDacl",
    "SetSecurityDescriptorOwner",
    "SetSecurityDescriptorGroup",
    "GetSecurityDescriptorDacl",
#ifdef UNICODE
    "SetNamedSecurityInfoW",
#else
    "SetNamedSecurityInfoA",
#endif
    NULL
};

//+----------------------------------------------------------------------------
//
// Function:  LinkToAdavapi32
//
// Synopsis:  This function links to advapi32.dll and loads the entry points
//            specified in the above array of function name strings.  If it returns
//            success (TRUE) then the array has all of the requested function
//            pointers in it.  If it returns failure (FALSE), it zeros the structure.
//
// Arguments: AdvapiLinkageStruct* pAdvapiLink - Pointer struct to fill in
//
// Returns:   BOOL - returns TRUE if successfull
//
// History:   12/05/01    quintinb  created
//
//+----------------------------------------------------------------------------
BOOL LinkToAdavapi32(AdvapiLinkageStruct* pAdvapiLink)
{
    BOOL bReturn = FALSE;

    if (pAdvapiLink)
    {
        ZeroMemory(pAdvapiLink, sizeof(*pAdvapiLink));

        //
        // Do the link, but make it obvious if it fails
        //
        if (LinkToDll(&(pAdvapiLink->hAdvapi32), "advapi32.dll", apszAdvapi32, pAdvapiLink->apvPfnAdvapi32))
        {
            bReturn = TRUE;
        }
        else
        {
            if (pAdvapiLink->hAdvapi32)
            {
                FreeLibrary(pAdvapiLink->hAdvapi32);
            }

            ZeroMemory(pAdvapiLink, sizeof(*pAdvapiLink));
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  UnlinkFromAdvapi32
//
// Synopsis:  This function frees the link to advapi32.dll and zeros the passed
//            in linkage struct.
//
// Arguments: AdvapiLinkageStruct* pAdvapiLink - Pointer struct to free
//
// Returns:   Nothing
//
// History:   12/05/01    quintinb  created
//
//+----------------------------------------------------------------------------
void UnlinkFromAdvapi32(AdvapiLinkageStruct* pAdvapiLink)
{
    if (pAdvapiLink)
    {
        if (pAdvapiLink->hAdvapi32)
        {
            FreeLibrary(pAdvapiLink->hAdvapi32);
        }

        ZeroMemory(pAdvapiLink, sizeof(*pAdvapiLink));
    }
}

//+----------------------------------------------------------------------------
//
// Function:  AllocateSecurityDescriptorAllowAccessToWorld
//
// Synopsis:  This function allocates a security descriptor for all users.
//            This function was taken directly from RAS when they create their
//            phonebook. This has to be before GetPhoneBookPath otherwise it 
//            causes compile errors in other components since we don't have a
//            function prototype anywhere and cmcfg just includes this (getpbk.cpp)
//            file. This function is also in common\source\getpbk.cpp
//
// Arguments: PSECURITY_DESCRIPTOR *ppSd - Pointer to a pointer to the SD struct
//
// Returns:   DWORD - returns ERROR_SUCCESS if successfull
//
// History:   06/27/2001    tomkel  Taken from RAS ui\common\pbk\file.c
//
//+----------------------------------------------------------------------------
#define SIZE_ALIGNED_FOR_TYPE(_size, _type) \
    (((_size) + sizeof(_type)-1) & ~(sizeof(_type)-1))

DWORD AllocateSecurityDescriptorAllowAccessToWorld(PSECURITY_DESCRIPTOR *ppSd, AdvapiLinkageStruct* pAdvapiLink)
{
    PSECURITY_DESCRIPTOR    pSd;
    PSID                    pSid;
    PACL                    pDacl;
    DWORD                   dwErr = ERROR_SUCCESS;
    DWORD                   dwAlignSdSize;
    DWORD                   dwAlignDaclSize;
    DWORD                   dwSidSize;
    PVOID                   pvBuffer;
    DWORD                   dwAcls = 0;

    // Here is the buffer we are building.
    //
    //   |<- a ->|<- b ->|<- c ->|
    //   +-------+--------+------+
    //   |      p|      p|       |
    //   | SD   a| DACL a| SID   |
    //   |      d|      d|       |
    //   +-------+-------+-------+
    //   ^       ^       ^
    //   |       |       |
    //   |       |       +--pSid
    //   |       |
    //   |       +--pDacl
    //   |
    //   +--pSd (this is returned via *ppSd)
    //
    //   pad is so that pDacl and pSid are aligned properly.
    //
    //   a = dwAlignSdSize
    //   b = dwAlignDaclSize
    //   c = dwSidSize
    //

    if (NULL == ppSd)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Initialize output parameter.
    //
    *ppSd = NULL;

    // Compute the size of the SID.  The SID is the well-known SID for World
    // (S-1-1-0).
    //
    dwSidSize = pAdvapiLink->pfnGetSidLengthRequired(1);

    // Compute the size of the DACL.  It has an inherent copy of SID within
    // it so add enough room for it.  It also must sized properly so that
    // a pointer to a SID structure can come after it.  Hence, we use
    // SIZE_ALIGNED_FOR_TYPE.
    //
    dwAlignDaclSize = SIZE_ALIGNED_FOR_TYPE(
                        sizeof(ACCESS_ALLOWED_ACE) + sizeof(ACL) + dwSidSize,
                        PSID);

    // Compute the size of the SD.  It must be sized propertly so that a
    // pointer to a DACL structure can come after it.  Hence, we use
    // SIZE_ALIGNED_FOR_TYPE.
    //
    dwAlignSdSize   = SIZE_ALIGNED_FOR_TYPE(
                        sizeof(SECURITY_DESCRIPTOR),
                        PACL);

    // Allocate the buffer big enough for all.
    //
    dwErr = ERROR_OUTOFMEMORY;
    pvBuffer = CmMalloc(dwSidSize + dwAlignDaclSize + dwAlignSdSize);
    if (pvBuffer)
    {
        SID_IDENTIFIER_AUTHORITY SidIdentifierWorldAuth
                                    = SECURITY_WORLD_SID_AUTHORITY;
        PULONG  pSubAuthority;

        dwErr = NOERROR;

        // Setup the pointers into the buffer.
        //
        pSd   = pvBuffer;
        pDacl = (PACL)((PBYTE)pvBuffer + dwAlignSdSize);
        pSid  = (PSID)((PBYTE)pDacl + dwAlignDaclSize);

        // Initialize pSid as S-1-1-0.
        //
        if (!pAdvapiLink->pfnInitializeSid(
                pSid,
                &SidIdentifierWorldAuth,
                1))  // 1 sub-authority
        {
            dwErr = GetLastError();
            goto finish;
        }

        pSubAuthority = pAdvapiLink->pfnGetSidSubAuthority(pSid, 0);
        *pSubAuthority = SECURITY_WORLD_RID;

        // Initialize pDacl.
        //
        if (!pAdvapiLink->pfnInitializeAcl(
                pDacl,
                dwAlignDaclSize,
                ACL_REVISION))
        {
            dwErr = GetLastError();
            goto finish;
        }

        dwAcls = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;

        dwAcls &= ~(WRITE_DAC | WRITE_OWNER);
        
        if(!pAdvapiLink->pfnAddAccessAllowedAceEx(
                pDacl,
                ACL_REVISION,
                CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                dwAcls,
                pSid))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Initialize pSd.
        //
        if (!pAdvapiLink->pfnInitializeSecurityDescriptor(
                pSd,
                SECURITY_DESCRIPTOR_REVISION))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set pSd to use pDacl.
        //
        if (!pAdvapiLink->pfnSetSecurityDescriptorDacl(
                pSd,
                TRUE,
                pDacl,
                FALSE))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set the owner for pSd.
        //
        if (!pAdvapiLink->pfnSetSecurityDescriptorOwner(
                pSd,
                NULL,
                TRUE))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set the group for pSd.
        //
        if (!pAdvapiLink->pfnSetSecurityDescriptorGroup(
                pSd,
                NULL,
                FALSE))
        {
            dwErr = GetLastError();
            goto finish;
        }

finish:
        if (!dwErr)
        {
            *ppSd = pSd;
        }
        else
        {
            CmFree(pvBuffer);
        }
    }

    return dwErr;
}

//+----------------------------------------------------------------------------
//
// Function:  AllowAccessToWorld
//
// Synopsis:  Assigns world access to the directory or filename passed in.
//
// Arguments: LPCTSTR pszDirOrFile - Directory or file to assign AllowAccessToWorld permissions
//
// Returns:   BOOL - FALSE on Falure, non-zero on Success.
//
// History:   koryg Created    12/03/2001
//
//+----------------------------------------------------------------------------
BOOL AllowAccessToWorld(LPTSTR pszDirOrFile)
{
    AdvapiLinkageStruct AdvapiLink;
    BOOL bReturn = FALSE;

    if (pszDirOrFile && pszDirOrFile[0])
    {
        if (LinkToAdavapi32(&AdvapiLink))
        {
            PSECURITY_DESCRIPTOR pSd = NULL;

            DWORD dwErr = AllocateSecurityDescriptorAllowAccessToWorld(&pSd, &AdvapiLink);

            if ((ERROR_SUCCESS == dwErr) && (NULL != pSd))
            {
                BOOL fDaclPresent;
                BOOL fDaclDefaulted;
                PACL pDacl = NULL;

                if (AdvapiLink.pfnGetSecurityDescriptorDacl(pSd, &fDaclPresent, &pDacl, &fDaclDefaulted))
                {
                    dwErr = AdvapiLink.pfnSetNamedSecurityInfo(pszDirOrFile,
                                                               SE_FILE_OBJECT,
                                                               DACL_SECURITY_INFORMATION,
                                                               NULL,  // psidOwner
                                                               NULL,  // psidGroup
                                                               pDacl, // pDacl
                                                               NULL); // pSacl
                    if (ERROR_SUCCESS == dwErr)
                    {
                        bReturn = TRUE;
                    }
                }
            }

            CmFree(pSd);

            UnlinkFromAdvapi32(&AdvapiLink);
        }
    }
    
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\bmpimage.cpp ===
//+----------------------------------------------------------------------------
//
// File:     image.cpp
//
// Module:   CMDIAL and CMAK
//
// Synopsis: CMDIAL/CMAK specific imaging support routines
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball   Created Header          03/30/98
//           quintinb   moved to common\source  08/06/98
//
//+----------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Function:   CmGetBitmapInfo
//
//  Synopsis:   Helper function to retrieve the contents of a bitmap from an HBITMAP 
//                          
//  Arguments:  hbm - Hanhdle of the target bitmap
//
//  Returns:    A pointer to a LPBITMAPINFO that contains the INFOHEADER, 
//              ColorTable and bits for the bitmap.
//
//  Note:       When accessing this value, or passing it on to other BITMAP APIs
//              it is recommended that the value be cast as an (LPBYTE). 
//
//  History:    a-nichb - Cleaned-up and commented  - 3/21/97
//
//----------------------------------------------------------------------------

LPBITMAPINFO CmGetBitmapInfo(HBITMAP hbm) 
{
    LPBITMAPINFO pbmi = NULL;
    HDC hDC = NULL;
    int nNumColors = 0;
    int iRes;
    LPBITMAPINFO lpbmih = NULL;
    DWORD dwInfoSize = 0;
    WORD wbiBits = 0;

    if (!hbm) 
    {
        return NULL;
    }
    
    // Get the basic bmp object info 
    
    BITMAP BitMap;
    
    if (!GetObjectA(hbm, sizeof(BITMAP), &BitMap))
    {
        goto Cleanup;
    }

    // Calc the color bits and num colors
    
    wbiBits = BitMap.bmPlanes * BitMap.bmBitsPixel;

    if (wbiBits <= 8) 
    {
        nNumColors = 1 << wbiBits;
    }
        
    // Allocate a BITMAPINFO structure large enough to hold header + color palette
        
    dwInfoSize = sizeof(BITMAPINFOHEADER) + (nNumColors * sizeof(RGBQUAD));
     
    lpbmih = (LPBITMAPINFO) CmMalloc(dwInfoSize); 

    if (!lpbmih)
    {
        goto Cleanup;
    }
    
    // Pre-fill the info that we have about the bmp

    lpbmih->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    lpbmih->bmiHeader.biWidth = BitMap.bmWidth;
    lpbmih->bmiHeader.biHeight = BitMap.bmHeight;
    lpbmih->bmiHeader.biPlanes = 1; 
    lpbmih->bmiHeader.biBitCount = wbiBits;
        
    // Call GetDiBits() w/ 5th Param to NULL, this is treated by the system as
    // a query in which case it validates the lpbmih contents and fills in the
    // biSizeImage member of the structure
    
    hDC = GetDC(NULL);
    if (!hDC)
    {
        goto Cleanup;
    }

    iRes = GetDIBits(hDC,hbm,0,BitMap.bmHeight,NULL,(LPBITMAPINFO) lpbmih,DIB_RGB_COLORS);

#ifdef DEBUG
    if (!iRes)
    {
        CMTRACE(TEXT("CmGetBitmapInfo() GetDIBits() failed."));
    }
#endif

    if (iRes)
    {
        DWORD dwFullSize = dwInfoSize;
        
        // Create a complete DIB structure with room for bits and fill it

        if (lpbmih->bmiHeader.biSizeImage) 
        {
            dwFullSize += lpbmih->bmiHeader.biSizeImage;
        } 
        else 
        {
            dwFullSize += (((WORD) (lpbmih->bmiHeader.biWidth * lpbmih->bmiHeader.biBitCount) / 8) * (WORD) BitMap.bmHeight); 
        }
    
        pbmi = (LPBITMAPINFO) CmMalloc(dwFullSize + sizeof(DWORD));

#ifdef DEBUG
        *((DWORD *) (((PBYTE) pbmi)+dwFullSize)) = 0x12345678;
        *((DWORD *) (((PBYTE) pbmi)+dwFullSize-sizeof(DWORD))) = 0x23456789;
#endif

        if (pbmi)
        {
            // Load the new larger LPBITMAPINFO struct with existing info, 
            // and get the data bits. Release the existing LPBITMAPINFO.
            
            CopyMemory(pbmi, lpbmih, dwInfoSize);
             
            //
            // We have a handle, we want the exact bits.
            // 

            iRes = GetDIBits(hDC,
                             hbm,
                             0,
                             BitMap.bmHeight,
                             ((LPBYTE) pbmi) + dwInfoSize,
                             pbmi,
                             DIB_RGB_COLORS);

#ifdef DEBUG
            if (*((DWORD *) (((PBYTE) pbmi) + dwFullSize)) != 0x12345678)
            {
                CMTRACE(TEXT("CmGetBitmapInfo() GetDIBits() copied too much."));
            }

            if (*((DWORD *) (((PBYTE) pbmi) + dwFullSize - sizeof(DWORD))) == 0x23456789)
            {
                CMTRACE(TEXT("CmGetBitmapInfo() GetDIBits() didn't copy enough."));
            }
#endif    
            // If GetDiBits() failed, free the BITMAPINFO buffer
            
            if (!iRes) 
            {
                CmFree(pbmi);
                pbmi = NULL;
            }
        }
    }
          
    // Cleanup

Cleanup:
    if (lpbmih)
    {
        CmFree(lpbmih);
    }
    if (hDC)
    {
        ReleaseDC(NULL, hDC);       
    }
    
    return pbmi;
}

static HPALETTE CmCreateDIBPalette(LPBITMAPINFO pbmi) 
{
    WORD wNumColors = 0;
    HPALETTE hRes = NULL;

    if (!pbmi) 
    {
        return (NULL);
    }
    
    // Get num colors according to color depth
    // Note: 24-bit bitmaps have no color table

    if (pbmi->bmiHeader.biBitCount <= 8) 
    {
        wNumColors = 1 << pbmi->bmiHeader.biBitCount;
    } 

    // Fill logical palette based upon color table

    if (wNumColors) 
    {
        LPLOGPALETTE pLogPal;
        int idx;

        pLogPal = (LPLOGPALETTE) CmMalloc(sizeof(LOGPALETTE)+sizeof(PALETTEENTRY)*wNumColors);
        if (pLogPal)
        {
            pLogPal->palVersion = 0x300;
            pLogPal->palNumEntries = wNumColors;
            for (idx=0;idx<wNumColors;idx++) 
            {
                pLogPal->palPalEntry[idx].peRed = pbmi->bmiColors[idx].rgbRed;
                pLogPal->palPalEntry[idx].peGreen = pbmi->bmiColors[idx].rgbGreen;
                pLogPal->palPalEntry[idx].peBlue = pbmi->bmiColors[idx].rgbBlue;
                pLogPal->palPalEntry[idx].peFlags = 0;
            }
        
            // Create a new palette

            hRes = CreatePalette(pLogPal);

#ifdef DEBUG
            if (!hRes)
            {
                CMTRACE1(TEXT("CmCreateDIBPalette() CreatePalette() failed, GLE=%u."), GetLastError());
            }
#endif

            CmFree(pLogPal);
        }
    }
    return hRes;
}

HBITMAP CmLoadBitmap(HINSTANCE hInst, LPCTSTR pszSpec) 
{
    return ((HBITMAP) CmLoadImage(hInst, pszSpec, IMAGE_BITMAP, 0, 0));
}

//+----------------------------------------------------------------------------
//
// Function:  ReleaseBitmapData
//
// Synopsis:  Releases resources and memory acquired during CreateBitmapData.  Note
//            that if you are using this with the BmpWndProc function below, that you
//            should call an STM_SETIMAGE with a NULL image pointer param in order to
//            clear out the window procedures window long.  Otherwise, it could get
//            a WM_PAINT message and try to use the freed memory before you can
//            clear it out or have the window destroyed by the dialog manager.
//
// Arguments: LPBMPDATA pBmpData - Ptr to the BmpData to be released
//
// Returns:   Nothing
//
// History:   nickball    Created    3/27/98
//
//+----------------------------------------------------------------------------
void ReleaseBitmapData(LPBMPDATA pBmpData)
{  
    MYDBGASSERT(pBmpData);

    if (NULL == pBmpData)
    {
        return;
    }

    if (pBmpData->hDIBitmap) 
    {
        DeleteObject(pBmpData->hDIBitmap);
        pBmpData->hDIBitmap = NULL;
    }
    
    if (pBmpData->hDDBitmap) 
    {
        DeleteObject(pBmpData->hDDBitmap);
        pBmpData->hDDBitmap = NULL;
    }

    if (pBmpData->pBmi)
    {
        CmFree(pBmpData->pBmi);
        pBmpData->pBmi = NULL;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CreateBitmapData
//
// Synopsis:  Fills a BMPDATA struct with all data necessary to display a bitmap. 
//
// Arguments: HBITMAP hBmp - Handle of the source bitmap
//            LPBMPDATA lpBmpData - Ptr to the BmpData struct to be filled
//            HWND hwnd - The hwnd that the bitmap will be displayed in.
//            BOOL fCustomPalette - Indicates that the DDB should be created with a palette specific to the bitmap.
//
// Returns:   BOOL - TRUE on succes 
//
// History:   nickball    Created    3/27/98
//
//+----------------------------------------------------------------------------
BOOL CreateBitmapData(HBITMAP hDIBmp,
    LPBMPDATA lpBmpData,
    HWND hwnd,
    BOOL fCustomPalette)
{   
    MYDBGASSERT(hDIBmp);
    MYDBGASSERT(lpBmpData);
    MYDBGASSERT(lpBmpData->phMasterPalette);

    if (NULL == hDIBmp || NULL == lpBmpData)
    {
        return NULL;
    }

    //
    // Params look good, get busy
    //

    HPALETTE hPaletteNew = NULL;
    LPBITMAPINFO pBmi = NULL;
    HBITMAP hDDBmp = NULL;
    HDC hDC;
    int iRes = 0;

    //
    // If we already have a pBmi value, we will assume it is up to date, as 
    // both it and the DIB do not change throughout the life of the BMP.
    // Note: If BmpData is not zero initialized, you will have problems.
    //

    if (lpBmpData->pBmi)
    {
        pBmi = lpBmpData->pBmi;
    }
    else
    {   
        //
        // Use the bitmap handle to retrieve a BITMAPINFO ptr complete w/ data
        //
        
        pBmi = CmGetBitmapInfo(lpBmpData->hDIBitmap);
        
        if (NULL == pBmi) 
        {
            return FALSE;
        }
    }
    
    //
    // we need a DC
    //
    
    hDC = GetDC(hwnd);

    if (!hDC)
    {
        CMTRACE(TEXT("MyCreateDDBitmap() GetDC() failed."));
        return FALSE;
    }

    //
    //  If CM is localized so that it is RTL (Right to Left => arabic and Hebrew),
    //  then we need to call SetLayout on the hDC from above.  If we don't
    //  set the layout back to LTR, the bitmap will show up as all black instead of as
    //  an image.
    //
    HMODULE hLib = LoadLibrary(TEXT("gdi32.dll"));
    
    if (hLib)
    {
        #ifndef LAYOUT_RTL
        #define LAYOUT_RTL                         0x00000001 // Right to left
        #endif

        typedef DWORD (WINAPI* pfnSetLayoutType)(HDC, DWORD);
        typedef DWORD (WINAPI* pfnGetLayoutType)(HDC);

        pfnSetLayoutType pfnSetLayout = (pfnSetLayoutType)GetProcAddress(hLib, "SetLayout");
        pfnGetLayoutType pfnGetLayout = (pfnGetLayoutType)GetProcAddress(hLib, "GetLayout");

        if (pfnSetLayout && pfnGetLayout)
        {
            DWORD dwLayout = pfnGetLayout(hDC);
    
            if (LAYOUT_RTL & dwLayout)
            {
                dwLayout ^= LAYOUT_RTL; // toggle LAYOUT_RTL off
                pfnSetLayout(hDC, dwLayout);
                CMTRACE(TEXT("CreateBitmapData -- Toggling off LAYOUT_RTL on the device context"));
            }
        }

        FreeLibrary(hLib);
    }

    //
    // If fCustomPalette is set then create a palette based on our bits
    // and realize it in the current DC.
    //

    if (fCustomPalette) 
    {
        hPaletteNew = CmCreateDIBPalette(pBmi);
        
        if (hPaletteNew) 
        {                           
            //
            // Select and realize the new palette so that the DDB is created with it below
            //

            HPALETTE hPalettePrev = SelectPalette(hDC, 
                hPaletteNew, lpBmpData->bForceBackground); // FALSE == Foreground app behavior);
                                                               // TRUE == Background app behavior);

            if (hPalettePrev) 
            {
                iRes = RealizePalette(hDC);
#ifdef DEBUG
                if (GDI_ERROR == iRes)
                {
                    CMTRACE1(TEXT("MyCreateDDBitmap() RealizePalette() failed, GLE=%u."), GetLastError());                    
                }
            }
            else
            {
                CMTRACE1(TEXT("MyCreateDDBitmap() SelectPalette() failed, GLE=%u."), GetLastError());
#endif
            }

        }
    }

    //
    // Determine number of color entries based upon color depth
    //

    int nNumColors = 0;
    
    if (pBmi->bmiHeader.biBitCount <= 8)
    {
        nNumColors = (1 << pBmi->bmiHeader.biBitCount);
    }

    //
    // Create the DDB from the bits 
    //

    hDDBmp = CreateDIBitmap(hDC,
                          &pBmi->bmiHeader,                        
                          CBM_INIT,
                          ((LPBYTE) pBmi) + sizeof(BITMAPINFOHEADER) + (nNumColors * sizeof(RGBQUAD)), //dib.dsBm.bmBits,
                          pBmi,
                          DIB_RGB_COLORS);

#ifdef DEBUG
    if (!hDDBmp)
    {
        CMTRACE(TEXT("MyCreateDDBitmap() CreateDIBitmap() failed."));
    }
#endif

    ReleaseDC(NULL, hDC);

    //
    // Fill in the bitmap data
    //

    if (hDDBmp)
    {
        lpBmpData->hDIBitmap = hDIBmp;       
        lpBmpData->pBmi = pBmi;

        //
        // Delete existing DDB, if any
        //

        if (lpBmpData->hDDBitmap) 
        {
            DeleteObject(lpBmpData->hDDBitmap);
        } 

        lpBmpData->hDDBitmap = hDDBmp;

        if (hPaletteNew)
        {
            //
            // Delete existing Palette, if any
            //

            if (*lpBmpData->phMasterPalette)
            {
                DeleteObject(*lpBmpData->phMasterPalette);
            }

            *lpBmpData->phMasterPalette = hPaletteNew;
        }

        return TRUE;
    }

    //
    // Something went wrong, cleanup
    //

    CmFree(pBmi);

    return FALSE;
}

//
// Bitmap window procedure
//

LRESULT CALLBACK BmpWndProc(HWND hwndBmp, 
                            UINT uMsg, 
                            WPARAM wParam, 
                            LPARAM lParam) 
{
    LPBMPDATA pBmpData = (LPBMPDATA) GetWindowLongU(hwndBmp,0);   
    BOOL bRes;

    switch (uMsg) 
    {
        case WM_CREATE:
        {
            return FALSE;
        }

        case WM_DESTROY:
            SetWindowLongU(hwndBmp,sizeof(LPBMPDATA),(LONG_PTR) NULL);      
            break;

        case WM_PAINT:
            if (pBmpData && pBmpData->pBmi) 
            {
                LPBITMAPINFO pBmi = pBmpData->pBmi;

                RECT rWnd;
                RECT rSrc = {0,0,(int)pBmpData->pBmi->bmiHeader.biWidth,
                                 (int)pBmpData->pBmi->bmiHeader.biHeight};
                PAINTSTRUCT ps;
                HDC hdcBmp;
                HBITMAP hbmpPrev;
                int iPrevStretchMode;
                
                //
                // Start  painting
                //

                HDC hdc = BeginPaint(hwndBmp,&ps);

                if (hdc)
                {
                    //
                    // Select and realize our current palette in the current DC
                    //

                    //UnrealizeObject(*pBmpData->phMasterPalette);
                    SelectPalette(hdc, *pBmpData->phMasterPalette, pBmpData->bForceBackground);
                    RealizePalette(hdc);

                    //
                    // Create a compatible DC, we'll create the BMP here then BLT it to the real DC
                    //

                    hdcBmp = CreateCompatibleDC(hdc);

                    if (hdcBmp)
                    {
                        //
                        // Select and realize our current palette in the compatible DC
                        //

                        SelectPalette(hdcBmp, *pBmpData->phMasterPalette, pBmpData->bForceBackground);
                        RealizePalette(hdcBmp);

                        if (!hdcBmp)
                        {
                            CMTRACE(TEXT("BmpWndProc() CreateCompatibleDC() failed."));
                        }

                        if (!pBmpData->hDDBitmap)
                        {
                            CMTRACE(TEXT("BmpWndProc() - WM_PAINT - hDDBitmap is NULL."));
                        }

                        //
                        // Select the bitmap into the compatible DC
                        //

                        hbmpPrev = (HBITMAP) SelectObject(hdcBmp,pBmpData->hDDBitmap);
                        bRes = GetWindowRect(hwndBmp,&rWnd);

                        if (!bRes)
                        {
                            CMTRACE1(TEXT("BmpWndProc() GetWindowRect() failed, GLE=%u."), GetLastError());
                        }       

                        //
                        // Now set the mode, and StretchBlt the bitmap from the compatible DC to the active DC
                        //

                        CMTRACE(TEXT("BmpWndProc() : Changing stretch mode"));
                        iPrevStretchMode = SetStretchBltMode(hdc, STRETCH_DELETESCANS);

                        bRes = StretchBlt(hdc,
                                          rWnd.left-rWnd.left,
                                          rWnd.top-rWnd.top,
                                          rWnd.right-rWnd.left,
                                          rWnd.bottom-rWnd.top,
                                          hdcBmp,
                                          rSrc.left-rSrc.left,
                                          rSrc.top-rSrc.top,
                                          rSrc.right-rSrc.left,
                                          rSrc.bottom-rSrc.top,
                                          SRCCOPY);
                        if (!bRes)
                        {
                            CMTRACE1(TEXT("BmpWndProc() StretchBlt() failed, GLE=%u."), GetLastError());
                        }

                        //
                        // Restore the mode in the active DC
                        //
                        CMTRACE(TEXT("BmpWndProc() Restoring stretch mode"));
                        iPrevStretchMode = SetStretchBltMode(hdc, iPrevStretchMode);

                        //
                        // Restore the compatible DC and release it
                        //

                        SelectObject(hdcBmp,hbmpPrev);          
                        DeleteDC(hdcBmp);

                    }
                    else
                    {
                        CMTRACE1(TEXT("BmpWndProc() CreateCompatibleDC() failed, GLE=%u."), GetLastError());
                    }


                    bRes = EndPaint(hwndBmp,&ps);

                    if (!bRes)
                    {
                        CMTRACE(TEXT("BmpWndProc() EndPaint() failed."));
                    }
                }
                else
                {
                    CMTRACE1(TEXT("BmpWndProc() BeginPaint() failed, GLE=%u."), GetLastError());
                }

            }
            break;

        case STM_SETIMAGE:
            if (wParam == IMAGE_BITMAP) 
            {
                CMTRACE2(TEXT("STM_SETIMAGE: wParam=%u, lParam=%u"), wParam, lParam);

                //
                // lParam contains a handle to the bitmap data, store it in extra bytes
                // 

                SetWindowLongU(hwndBmp,0, lParam); // pBmpData

                CMTRACE2(TEXT("SetWindowLongU called with hwndBmp = %u, lParam=%u"), hwndBmp, lParam);

                //
                // Force a repaint
                //

                bRes = InvalidateRect(hwndBmp,NULL,TRUE);

                CMTRACE2(TEXT("InvalidateRect called with hwndBmp = %u, lParam=%u"), hwndBmp, lParam);

#ifdef DEBUG
                if (!bRes)
                {
                    CMTRACE(TEXT("BmpWndProc() InvalidateRect() failed."));
                }
#endif              
                if (pBmpData && pBmpData->hDDBitmap) 
                {
                    return ((LRESULT) pBmpData->hDDBitmap);
                }
                else
                {
                    return NULL;
                }
            }
            break;
    }
    return (DefWindowProcU(hwndBmp,uMsg,wParam,lParam));
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryNewPalette
//
//  Synopsis:   Helper function to encapsulate handling of WM_QUERYNEWPALETTE
//                          
//  Arguments:  hwndDlg     - Handle of the dialog receiving the message
//              lpBmpData   - Struct containing handles for bmp to display
//              iBmpCtrl    - Bitmap control ID
//
//  Returns:    Nothing
//
//  History:    a-nichb - Created - 7/14/97
//
//----------------------------------------------------------------------------
void QueryNewPalette(LPBMPDATA lpBmpData, HWND hwndDlg, int iBmpCtrl)
{
    MYDBGASSERT(lpBmpData);

    if (lpBmpData)
    {
        //
        // We just handle this as a standard palette change because we
        // want to ensure that we create a new DDB using a palette based
        // upon our bitmap.
        //
                
        PaletteChanged(lpBmpData, hwndDlg, iBmpCtrl);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   PaletteChanged
//
//  Synopsis:   Helper function to encapsulate handling of WM_PALETTECHANGED
//                          
//  Arguments:  hwndDlg     - Handle of the dialog receiving the message
//              lpBmpData   - Struct containing handles for bmp to display
//              iBmpCtrl    - Bitmap control ID
//
//  Returns:    Nothing
//
//  History:    a-nichb - Created - 7/14/97
//
//----------------------------------------------------------------------------
void PaletteChanged(LPBMPDATA lpBmpData, HWND hwndDlg, int iBmpCtrl)
{   
    MYDBGASSERT(lpBmpData);

    if (NULL == lpBmpData || NULL == lpBmpData->phMasterPalette)
    {
        return;
    }

    //
    // Unrealize the master palette if it exists
    //
       
    if (*lpBmpData->phMasterPalette)
    {
        UnrealizeObject(*lpBmpData->phMasterPalette);
    }

    //
    // Create a device dependent bitmap and appropriate palette
    //

    if (CreateBitmapData(lpBmpData->hDIBitmap, lpBmpData, hwndDlg, TRUE))
    {        
        //
        // SetImage to update handles for painting and force draw
        //

        HBITMAP hbmpTmp = (HBITMAP) SendDlgItemMessageA(hwndDlg, iBmpCtrl, STM_SETIMAGE,
                                               IMAGE_BITMAP,(LPARAM) lpBmpData);
#ifdef DEBUUG
                if (!hbmpTmp)
                {
                    CMTRACE(TEXT("PaletteChanged().WM_PALETTECHANGED - STM_SETIMAGE returned NULL."));
                }
#endif

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\cm_eap.cpp ===
#ifdef CM_CMAK
#define wsprintfU wsprintfW
#define GetPrivateProfileStringU GetPrivateProfileStringW
#define WritePrivateProfileStringU WritePrivateProfileStringW
#endif

//+----------------------------------------------------------------------------
//
// Function:  EraseDunSettingsEapData
//
// Synopsis:  This function erases the CustomAuthData key of the EAP settings
//            for the given section and CMS file
//
// Arguments: LPCTSTR pszSection - section name to erase the CustomAuthData from
//            LPCTSTR pszCmsFile - cms file to erase the data from
//
// Returns:   HRESULT - standard COM style error codes
//
// History:   quintinb Created     03/27/00
//            tomkel   Copied from profwiz project 08/09/2001
//
//+----------------------------------------------------------------------------
HRESULT EraseDunSettingsEapData(LPCTSTR pszSection, LPCTSTR pszCmsFile)
{
    if ((NULL == pszSection) || (NULL == pszCmsFile) || 
        (TEXT('\0') == pszSection[0]) || (TEXT('\0') == pszCmsFile[0]))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    int iLineNum = 0;
    DWORD dwRet = -1;
    TCHAR szKeyName[MAX_PATH+1];
    TCHAR szLine[MAX_PATH+1];

    while(0 != dwRet)
    {
        wsprintfU(szKeyName, TEXT("%S%d"), c_pszCmEntryDunServerCustomAuthData, iLineNum);
        dwRet = GetPrivateProfileStringU(pszSection, szKeyName, TEXT(""), szLine, MAX_PATH, pszCmsFile);

        if (dwRet)
        {
            if (0 == WritePrivateProfileStringU(pszSection, szKeyName, NULL, pszCmsFile))
            {
                DWORD dwGLE = GetLastError();
                hr = HRESULT_FROM_WIN32(dwGLE);
                break;
            }
        }
        iLineNum++;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\cmsafenet.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmsafenet.cpp     
//
// Module:   CMDIAL32.DLL AND CMSTP.EXE
//
// Synopsis: This module contains the functions to allow Connection Manager to
//           interact with the SafeNet downlevel L2TP/IPSec client.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   created		09/10/01
//
//+----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Function    IsSafeNetClientAvailable
//
//  Synopsis    Check to see if the SafeNet L2TP client is installed
//
//  Arguments   None
//
//  Returns     TRUE - SafeNet L2TP client has been installed
//              FALSE - otherwise
//
//  History     9/7/01     quintinb      Created
//
//-----------------------------------------------------------------------------
BOOL IsSafeNetClientAvailable(void)
{
    BOOL bReturn = FALSE;

    //
    //  More cmstp fixups...
    //
#ifndef OS_NT4
    CPlatform plat;
    if (plat.IsNT4() || plat.IsWin9x())
#else
    if (OS_NT4 || OS_W9X)
#endif
    {
        //
        //  If this isn't NT5+ then we need to look for the SafeNet
        //  client.  First look for the downlevel l2tp client version regkey.
        //

        HKEY hKey = NULL;
        LONG lResult = RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                                     TEXT("Software\\Microsoft\\Microsoft IPsec VPN"),
                                     0,
                                     KEY_READ,
                                     &hKey);

        if (ERROR_SUCCESS == lResult)
        {
            //
            //  Okay, we have the regkey that is good enough to tell us the client
            //  is available.  We should further try linking to the SnPolicy.dll and
            //  querying for a version of the API that we can live with, but this
            //  is enough to tell us it is available.
            //
            RegCloseKey(hKey);
            
            bReturn = TRUE;
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
//  Function    LinkToSafeNet
//
//  Synopsis    Loads the snpolicy.dll and calls the SnPolicyApiNegotiateVersion
//              API to get the SafeNet Config utility APIs.
//
//  Arguments   SafeNetLinkageStruct* pSnLinkage - struct to hold the SafeNet
//              function pointers.
//
//  Returns     TRUE - if the SafeNet L2TP config APIs were loaded
//              FALSE - otherwise
//
//  History     9/7/01     quintinb      Created
//
//-----------------------------------------------------------------------------
BOOL LinkToSafeNet(SafeNetLinkageStruct* pSnLinkage)
{
    if (NULL == pSnLinkage)
    {
        CMASSERTMSG(FALSE, TEXT("LinkToSafeNet -- NULL pointer passed for the SafeNetLinkageStruct"));
        return FALSE;
    }

    BOOL bReturn = FALSE;

    pSnLinkage->hSnPolicy = LoadLibraryA("snpolicy.dll");

    if (pSnLinkage->hSnPolicy)
    {
        pfnSnPolicyApiNegotiateVersionSpec pfnSnPolicyApiNegotiateVersion = (pfnSnPolicyApiNegotiateVersionSpec)GetProcAddress(pSnLinkage->hSnPolicy, "SnPolicyApiNegotiateVersion");

        if (pfnSnPolicyApiNegotiateVersion)
        {
            DWORD dwMajor = POLICY_MAJOR_VERSION;
            DWORD dwMinor = POLICY_MINOR_VERSION;
            POLICY_FUNCS_V1_0 PolicyFuncs = {0};
            if (pfnSnPolicyApiNegotiateVersion(&dwMajor, &dwMinor, &PolicyFuncs))
            {
                bReturn = (PolicyFuncs.SnPolicySet && PolicyFuncs.SnPolicyGet && PolicyFuncs.SnPolicyReload);

                if (bReturn)
                {
                    pSnLinkage->pfnSnPolicySet = PolicyFuncs.SnPolicySet;
                    pSnLinkage->pfnSnPolicyGet = PolicyFuncs.SnPolicyGet;
                    pSnLinkage->pfnSnPolicyReload = PolicyFuncs.SnPolicyReload;
                }
                else
                {
                     FreeLibrary(pSnLinkage->hSnPolicy);
                }
            }
        }
    }
    else
    {
        CMTRACE1(TEXT("LinkToSafeNet -- unable to load snpolicy.dll, GLE %d"), GetLastError());
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
//  Function    UnLinkFromSafeNet
//
//  Synopsis    Unloads the SafeNet configuration dll and zeros the 
//              passed in linkage structure.
//
//  Arguments   SafeNetLinkageStruct* pSnLinkage - struct to holding the SafeNet
//              linkage info.
//
//  Returns     Nothing
//
//  History     9/7/01     quintinb      Created
//
//-----------------------------------------------------------------------------
void UnLinkFromSafeNet(SafeNetLinkageStruct* pSnLinkage)
{
    if (pSnLinkage)
    {
        if (pSnLinkage->hSnPolicy)
        {
            FreeLibrary(pSnLinkage->hSnPolicy);
        }

        ZeroMemory(pSnLinkage, sizeof(SafeNetLinkageStruct));    
    }
}

//+----------------------------------------------------------------------------
//
//  Function    GetPathToSafeNetLogFile
//
//  Synopsis    Returns the full path to the SafeNet log file by looking up the
//              SafeNet directory in the registry and appending the fixed log
//              file name.  Note that this function allocates the memory for the
//              string which must be freed by the caller.
//
//  Arguments   None
//
//  Returns     Allocated buffer holding the full path to the SafeNet log file.
//
//  History     9/7/01     quintinb      Created
//
//-----------------------------------------------------------------------------
LPTSTR GetPathToSafeNetLogFile(void)
{
    HKEY hKey;
    LPTSTR pszLogFilePath = NULL;
    DWORD dwSize = 0;
    DWORD dwType;

    const TCHAR* const c_pszRegKeySafeNetProgramPaths = TEXT("SOFTWARE\\IRE\\SafeNet/Soft-PK\\ProgramPaths");
    const TCHAR* const c_pszRegValueCertMgrPath = TEXT("CERTMGRPATH");
    const TCHAR* const c_pszSafeNetLogFileName = TEXT("\\isakmp.log");

    LONG lResult = RegOpenKeyExU(HKEY_LOCAL_MACHINE, c_pszRegKeySafeNetProgramPaths, 0, NULL, &hKey);

    if (ERROR_SUCCESS == lResult)
    {
        //
        //  First let's figure out the size of the path buffer
        //
        lResult = RegQueryValueExU(hKey, c_pszRegValueCertMgrPath, NULL, &dwType, NULL, &dwSize);
        if ((ERROR_SUCCESS == lResult) && (dwSize > 0))
        {
            //
            //  Okay, we have the size of the path.  Now add the size of the file onto it and allocate
            //  the string buffer.
            //
            dwSize = dwSize + lstrlenU(c_pszSafeNetLogFileName); // dwSize already includes the NULL char
            dwSize *= sizeof(TCHAR);

            pszLogFilePath = (LPTSTR)CmMalloc(dwSize);

            if (pszLogFilePath)
            {
                lResult = RegQueryValueExU(hKey, c_pszRegValueCertMgrPath, NULL, &dwType, (BYTE*)pszLogFilePath, &dwSize);

                if (ERROR_SUCCESS == lResult)
                {
                    lstrcatU(pszLogFilePath, c_pszSafeNetLogFileName);
                }
                else
                {
                    CmFree(pszLogFilePath);
                    pszLogFilePath = NULL;
                }
            }
        }
        
        RegCloseKey(hKey);
    }

   return pszLogFilePath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\cmexitwin.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmexitwin.cpp
//
// Module:   Common Code
//
// Synopsis: Implements the function MyExitWindowsEx.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb    Created Heaser   08/19/99
//
//+----------------------------------------------------------------------------
#include <windows.h>

BOOL MyExitWindowsEx(UINT uFlags, 
                     DWORD dwRsvd) 
{
    BOOL bRes;

    //
    // If platform is NT, we will have to adjust privileges before rebooting
    //
    if (OS_NT)
    {
        HANDLE hToken;              // handle to process token 
        TOKEN_PRIVILEGES tkp;       // ptr. to token structure 
 

        //
        // Get the current process token handle 
        // so we can get shutdown privilege. 
        // 
        if (!OpenProcessToken(GetCurrentProcess(), 
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
                                &hToken)) 
        {
            CMTRACE1(TEXT("MyExitWindowsEx() OpenThreadToken() failed, GLE=%u."), GetLastError());
            return FALSE;
        }
 
    
        //
        // Get the LUID for shutdown privilege
        //
        bRes = LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, 
                                    &tkp.Privileges[0].Luid);
#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("MyExitWindowsEx() LookupPrivilegeValue() failed, GLE=%u."), GetLastError());
        }
#endif
        tkp.PrivilegeCount = 1;  
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 
 
        
        //
        //  Get shutdown privilege for this process
        //
        AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
                                        (PTOKEN_PRIVILEGES) NULL, 0); 
 
        //
        // Cannot reliably test the return value of AdjustTokenPrivileges
        //
        if (GetLastError() != ERROR_SUCCESS)
        {
            CMTRACE1(TEXT("MyExitWindowsEx() AdjustTokenPrivileges() failed, GLE=%u."), GetLastError());

            CloseHandle(hToken);
            return FALSE;
        }
        
        CloseHandle(hToken);
    }
    
    bRes = ExitWindowsEx(uFlags,dwRsvd);
#ifdef DEBUG
    if (!bRes)
    {
        CMTRACE1(TEXT("MyExitWindowsEx() ExitWindowsEx() failed, GLE=%u."), GetLastError());
    }
#endif

    return (bRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\allcmdir.cpp ===
//+----------------------------------------------------------------------------
//
// File:     allcmdir.cpp
//
// Module:   CMCFG32.DLL and CMSTP.EXE
//
// Synopsis: Implementation of GetAllUsersCmDir
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------



//+----------------------------------------------------------------------------
//
// Function:  GetAllUsersCmDir
//
// Synopsis:  This function fills in the string passed in with the path to the
//            path where CM should be installed.  For instance, it should return
//            c:\Documents and Settings\All Users\Application Data\Microsoft\Network\Connections\Cm
//
// Arguments: LPTSTR  pszDir - String to the Users Connection Manager Directory
//
// Returns:   LPTSTR - String to the Users Connection Manager Directory
//
// History:   quintinb Created Header    2/19/98
//
//+----------------------------------------------------------------------------
BOOL GetAllUsersCmDir(LPTSTR  pszDir, HINSTANCE hInstance)
{
    MYDBGASSERT(pszDir);
    pszDir[0] = TEXT('\0');

    LPMALLOC pMalloc;
    HRESULT hr = SHGetMalloc(&pMalloc);
    if (FAILED (hr))
    {
        CMASSERTMSG(FALSE, TEXT("Failed to get a Shell Malloc Pointer."));
        return FALSE;
    }

    TCHAR szCmSubFolder[MAX_PATH+1];
    TCHAR szAppData[MAX_PATH+1];
    TCHAR szDesktop[MAX_PATH+1];
    LPITEMIDLIST pidl;
    BOOL bReturn = FALSE;

    //
    //  We really want the Common App Data dir, but this CSIDL value is only supported on
    //  NT5 so far.  If this succeeds, we only need to append the path to it.
    //
    hr = SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_APPDATA, &pidl);
    if (SUCCEEDED(hr))
    {
        if (!SHGetPathFromIDList(pidl, pszDir))
        {
            CMASSERTMSG(FALSE, TEXT("GetAllUsersCmDir -- SHGetPathFromIDList Failed to retrieve CSIDL_COMMON_APPDATA"));
            goto exit;
        }
        
        pMalloc->Free(pidl);
        pidl = NULL;
    }
    else
    {
        //
        //  Of course, things aren't always that easy, lets try getting the regular
        //  Application Data dir.  We can hopefully combine the returns from two
        //  CSIDL's like CSIDL_APPDATA and CSIDL_COMMON_DESKTOPDIRECTORY to acheive the
        //  same affect on older machines.
        //

        hr = SHGetSpecialFolderLocation(NULL, CSIDL_APPDATA, &pidl);
        if (SUCCEEDED(hr))
        {
            if (!SHGetPathFromIDList(pidl, szAppData))
            {
                goto exit;
            }

            pMalloc->Free(pidl);
            pidl = NULL;
        }
        else
        {
            //
            //  CSIDL_APPDATA isn't even supported on win95 gold
            //
            MYVERIFY(0 != LoadString(hInstance, IDS_APPDATA, szAppData, MAX_PATH));
        }

        //
        //  Now lets try to get the Common Desktop Directory to combine the two
        //
        BOOL bCommonFound = FALSE;

        hr = SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_DESKTOPDIRECTORY, &pidl);
        if (SUCCEEDED(hr))
        {
            if (SHGetPathFromIDList(pidl, szDesktop))
            {
                bCommonFound = TRUE;
            }

            pMalloc->Free(pidl);
            pidl = NULL;
        }

        if (!bCommonFound)
        {
            //
            //  Okay, next lets try the Reg Key for the common desktop directory.
            //  (Win98 gold with profiling contains the reg key but the CSIDL fails)
            //
            const TCHAR* const c_pszRegShellFolders = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
            const TCHAR* const c_pszRegCommonDesktop = TEXT("Common Desktop");
            HKEY hKey;

            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegShellFolders, 
                0, KEY_READ, &hKey))
            {
                DWORD dwSize = MAX_PATH;
                DWORD dwType = REG_SZ;

                if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegCommonDesktop, 
                                                     NULL, &dwType, (LPBYTE)szDesktop, 
                                                     &dwSize))
                {
                    bCommonFound = TRUE;
                }
                RegCloseKey(hKey);
            }
        }

        if (!bCommonFound)
        {
            //
            //  As a fall back lets try the windows directory, NTRAID 374912
            //
            if (GetWindowsDirectory(szDesktop, MAX_PATH))
            {
                //
                //  Then we have the windows directory, but we need to append
                //  \\Desktop so that the parsing logic which follows parses
                //  this correctly.  It is expecting the path to the desktop dir
                //  not a path to the windows dir (if we didn't we would end up with
                //  c:\Application Data instead of c:\windows\Application data as we
                //  want and expect).  Note that there is no need to worry about 
                //  localization of Desktop because we are going to remove it anyway.
                //
                lstrcat(szDesktop, TEXT("\\Desktop"));
            }
        }

        CFileNameParts AppData(szAppData);
        CFileNameParts CommonDesktop(szDesktop);

        wsprintf(pszDir, TEXT("%s%s%s%s"), CommonDesktop.m_Drive, CommonDesktop.m_Dir, 
            AppData.m_FileName, AppData.m_Extension);
    }

    //
    //  Now append the CM sub directory structure
    //
    if (!LoadString(hInstance, IDS_CMSUBFOLDER, szCmSubFolder, MAX_PATH))
    {
        goto exit;
    }

    MYVERIFY(NULL != lstrcat(pszDir, szCmSubFolder));    

    bReturn = TRUE;

exit:
    //
    //  Free the allocated pidl if necessary
    //
    if (pidl)
    {
        pMalloc->Free(pidl);
    }

    //
    // release the shell's IMalloc ptr
    //
    pMalloc->Release();

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\comparestring.cpp ===
//+----------------------------------------------------------------------------
//
// File:     CompareString.cpp
//
// Module:   as required
//
// Synopsis: Using lstrcmpi to do a case-insensitive comparison of two strings
//           can have unexpected result on certain locales if one of the strings
//           is a constant.  The 2 functions here are the preferred replacements.
//
//           Note that these functions are also present in CMUTIL.dll.  However,
//           a dependency on cmutil is a Bad Thing (TM) for modules that do not
//           sim-ship with it (this includes customactions and CMAK).
//
// Copyright (c) 1998-2002 Microsoft Corporation
//
// Author:   SumitC     Created     12-Sep-2001
//
//+----------------------------------------------------------------------------

#include "windows.h"
#include "CompareString.h"

//
//  The following is to ensure that we don't try to use U functions (i.e. CMutoa
//  functions) in a module that doesn't support it.
//
#ifndef _CMUTIL_STRINGS_CPP_
    #ifndef CompareStringU
        #ifdef UNICODE
        #define CompareStringU CompareStringW
        #else
        #define CompareStringU CompareStringA
        #endif
    #endif
#endif


//+----------------------------------------------------------------------------
//
// Function:  SafeCompareStringA
//
// Synopsis:  implementation of lstrcmpi that is sensitive to locale variations
//
// Arguments: LPCTSTR lpString1, lpString2 - strings to compare
//
// Returns:   int (-1, 0 or +1).  In case of error, -1 is returned.
//
//+----------------------------------------------------------------------------
int SafeCompareStringA(LPCSTR lpString1, LPCSTR lpString2)
{
    int iReturn = -1;

    DWORD lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
    iReturn = CompareStringA(lcid, NORM_IGNORECASE, lpString1, -1, lpString2, -1);

    if (iReturn == 0)
    {
        iReturn = -1;
    }
    else
    {
        iReturn -= CSTR_EQUAL;  // to make the return values -1 or 0 or 1
    }
    
    return iReturn;
}

#if defined(UNICODE) || defined(_CMUTIL_STRINGS_CPP_)

//+----------------------------------------------------------------------------
//
// Function:  SafeCompareStringW
//
// Synopsis:  implementation of lstrcmpi that is sensitive to locale variations
//
// Arguments: LPCTSTR lpString1, lpString2 - strings to compare
//
// Returns:   int (-1, 0 or +1).  In case of error, -1 is returned.
//
//+----------------------------------------------------------------------------
int SafeCompareStringW(LPCWSTR lpString1, LPCWSTR lpString2)
{
    int iReturn = -1;

    if (OS_NT51)
    {
        iReturn = CompareStringU(LOCALE_INVARIANT, NORM_IGNORECASE, lpString1, -1, lpString2, -1); 
    }
    else
    {
        DWORD lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
        iReturn = CompareStringU(lcid, NORM_IGNORECASE, lpString1, -1, lpString2, -1);
    }

    if (iReturn == 0)
    {
        iReturn = -1;
    }
    else
    {
        iReturn -= CSTR_EQUAL;  // to make the return values -1 or 0 or 1
    }
    
    return iReturn;
}
#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\getmodulever.cpp ===
//+----------------------------------------------------------------------------
//
// File:     getmodulever.cpp
//
// Module:   CMSETUP.LIB, CMUTIL.DLL
//
// Synopsis: Implementation of the GetModuleVersionAndLCID function.
//
// Copyright (c) 1998-2001 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/19/99
//
//+----------------------------------------------------------------------------

#include "cmutil.h"

//+----------------------------------------------------------------------------
//
// Function:  GetModuleVersionAndLCID
//
// Synopsis:  Gets the version information and LCID from the specified module
//
// Arguments: LPTSTR pszFile - Full path to the file to get the version number of
//            LPDWORD pdwVersion - version number (Hiword Major, Loword Minor)
//            LPDWORD pdwBuild - build number (Hiword Major, Loword Minor)
//            LPDWORD pdwLCID - returns the Locale ID that the module was localized too
//
// Returns:   HRESULT -- S_OK if successful, an error code otherwise
//
// History:   quintinb -- Code borrowed from Yoshifumi "Vogue" Inoue 
//                        from (private\admin\wsh\host\verutil.cpp).
//                        Rewritten to match our coding style.      9/14/98
//            17-Oct-2000 SumitC    cleanup, fixed leaks, moved to common\source
//
// Notes:     There are 2 versions of this function, which take ANSI and Unicode
//            versions of the pszFile argument.
//
//+----------------------------------------------------------------------------
HRESULT GetModuleVersionAndLCID (LPSTR pszFile, LPDWORD pdwVersion, LPDWORD pdwBuild, LPDWORD pdwLCID)
{
    HRESULT hr = S_OK;
    HANDLE  hHeap = NULL;
    LPVOID  pData = NULL;
    DWORD   dwHandle;
    DWORD   dwLen;
    
    if ((NULL == pdwVersion) || (NULL == pdwBuild) || (NULL == pdwLCID) ||
        (NULL == pszFile) || (TEXT('\0') == pszFile))
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pdwVersion = 0;
    *pdwBuild = 0;
    *pdwLCID = 0;

    dwLen = GetFileVersionInfoSizeA(pszFile, &dwHandle);
    if (0 == dwLen)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }
    
    hHeap = GetProcessHeap();
    if (NULL == hHeap)
    {
        hr = E_POINTER;
        CMASSERTMSG(FALSE, TEXT("GetModuleVersionAndLCID -- couldn't get a handle to the process heap."));
        goto Cleanup;
    }
    
    pData = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwLen);   

    if (!pData)
    {
        hr = E_OUTOFMEMORY;
        CMASSERTMSG(FALSE, TEXT("GetModuleVersionAndLCID -- couldn't alloc on the process heap."));
        goto Cleanup;
    }

    if (!GetFileVersionInfoA(pszFile, dwHandle, dwLen, pData))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    VS_FIXEDFILEINFO* pVerInfo;
    LPVOID pInfo;
    UINT nLen;

    if (!VerQueryValueA(pData, "\\", &pInfo, &nLen))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    pVerInfo = (VS_FIXEDFILEINFO*) pInfo;

    *pdwVersion = pVerInfo->dwProductVersionMS;
    *pdwBuild = pVerInfo->dwProductVersionLS;

    //
    //  Now get the language the binary was compiled for
    //
    typedef struct _LANGANDCODEPAGE
    {
      WORD wLanguage;
      WORD wCodePage;
    } LangAndCodePage;

    nLen = 0;
    LangAndCodePage* pTranslate = NULL;

    if (!VerQueryValueA(pData, "\\VarFileInfo\\Translation", (PVOID*)&pTranslate, &nLen))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    //
    //  Let's assert that we only got one LangAndCodePage struct back.  We technically
    //  could get more than one back but we certainly aren't expecting more than one.  If we
    //  get more than one, use the first one as the language of the dll.
    //
    MYDBGASSERT(1 == (nLen/sizeof(LangAndCodePage)));

    if ((nLen/sizeof(LangAndCodePage)) >= 1)
    {
        *pdwLCID = pTranslate[0].wLanguage;
    }

Cleanup:
    if (hHeap)
    {
        HeapFree(hHeap, 0, pData);
    }

    return hr;
}


//+----------------------------------------------------------------------------
//  This is the Unicode version of GetModuleVersionAndLCID (the first arg is LPWSTR)
//  and it just calls the Ansi version above.
//+----------------------------------------------------------------------------
HRESULT GetModuleVersionAndLCID (LPWSTR pszFile, LPDWORD pdwVersion, LPDWORD pdwBuild, LPDWORD pdwLCID)
{
    CHAR pszAnsiFileName[MAX_PATH + 1];

    if (WideCharToMultiByte(CP_ACP, 0, pszFile, -1, pszAnsiFileName, MAX_PATH, NULL, NULL))
    {
        return GetModuleVersionAndLCID(pszAnsiFileName, pdwVersion, pdwBuild, pdwLCID);
    }

    return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\dumpsecinfo.cpp ===
//+----------------------------------------------------------------------------
//
// File:     DumpSecInfo.cpp
//
// Module:   as required
//
// Synopsis: Functions to help figure out Permissions issues.  To fix "NULL DACL"
//           security issues, or try and figure out permissions bugs, this module
//           may be useful.  Entry point is DumpAclInfo.
//
// Copyright (c) 1998-2001 Microsoft Corporation
//
// Author:   SumitC     Created     18-Dec-2000
//
//+----------------------------------------------------------------------------

#include "winbase.h"
#include "sddl.h"

//
//  support for dynamically loading Advapi32 Security functions
//

HMODULE g_hAdvapi32 = NULL;

typedef BOOL (WINAPI *pfnLookupAccountSid) (LPCWSTR, PSID, LPWSTR, LPDWORD, LPWSTR, LPDWORD, PSID_NAME_USE);
typedef BOOL (WINAPI *pfnGetUserObjectSecurity) (HANDLE, PSECURITY_INFORMATION, PSECURITY_DESCRIPTOR, DWORD, LPDWORD);
typedef BOOL (WINAPI *pfnConvertSidToStringSid) (PSID, LPWSTR*);
typedef BOOL (WINAPI *pfnGetSecurityDescriptorOwner) (PSECURITY_DESCRIPTOR, PSID *, LPBOOL);
typedef BOOL (WINAPI *pfnGetSecurityDescriptorSacl) (PSECURITY_DESCRIPTOR, LPBOOL, PACL *, LPBOOL);
typedef BOOL (WINAPI *pfnGetSecurityDescriptorDacl) (PSECURITY_DESCRIPTOR, LPBOOL, PACL *, LPBOOL);
typedef BOOL (WINAPI *pfnGetAce) (PACL, DWORD, LPVOID *);

pfnLookupAccountSid             g_pfnLookupAccountSid = NULL;
pfnGetUserObjectSecurity        g_pfnGetUserObjectSecurity = NULL;
pfnConvertSidToStringSid        g_pfnConvertSidToStringSid = NULL;
pfnGetSecurityDescriptorOwner   g_pfnGetSecurityDescriptorOwner = NULL;
pfnGetSecurityDescriptorSacl    g_pfnGetSecurityDescriptorSacl = NULL;
pfnGetSecurityDescriptorDacl    g_pfnGetSecurityDescriptorDacl = NULL;
pfnGetAce                       g_pfnGetAce = NULL;

//+----------------------------------------------------------------------------
//
// Function:  GetSidType
//
// Synopsis:  Returns the string corresponding to a given SID type
//
// Arguments: [i] -- index representing the SID
//
// Returns:   LPTSTR - static string containing a displayable Sid type
//
// Notes:
//
//-----------------------------------------------------------------------------
LPTSTR GetSidType(int i)
{
    static LPTSTR szMap[] =
        {
            TEXT("User"),
            TEXT("Group"),
            TEXT("Domain"),
            TEXT("Alias"),
            TEXT("WellKnownGroup"),
            TEXT("DeletedAccount"),
            TEXT("Invalid"),
            TEXT("Unknown"),
            TEXT("Computer")
        };

    if (i >= 1 && i <= 9)
    {
        return szMap[i - 1];
    }
    else
    {
        return TEXT("");
    }

}


//+----------------------------------------------------------------------------
//
// Function:  DumpSid
//
// Synopsis:  returns information for a give SID
//
// Arguments: [psid]      -- ptr to SecurityID
//            [pszBuffer] -- where to return SID string (caller must free)
//
// Returns:   LPTSTR - ptr to pszBuffer if success, NULL if failure
//
// Notes:
//
//-----------------------------------------------------------------------------
LPTSTR DumpSid(PSID psid, LPTSTR pszBuffer)
{
    LPTSTR          pszSID = NULL;
    TCHAR           szName[MAX_PATH + 1];
    DWORD           cbName = MAX_PATH;
    TCHAR           szDomain[MAX_PATH + 1];
    DWORD           cbDomain = MAX_PATH;
    SID_NAME_USE    snu;
    BOOL            fDone = FALSE;

    CMASSERTMSG(pszBuffer, TEXT("DumpSid - pszBuffer must be allocated by caller"));

    if (g_pfnConvertSidToStringSid(psid, &pszSID) &&
        g_pfnLookupAccountSid(NULL, psid, szName, &cbName, szDomain, &cbDomain, &snu))
    {
        wsprintf(pszBuffer, TEXT("%s\\%s %s %s"), szDomain, szName, GetSidType(snu), pszSID);
        // looks like NTDEV\sumitc User xxxx-xxx-xxx-xxx
        fDone = TRUE;
    }

    if (pszSID)
    {
        LocalFree(pszSID);
    }

    return fDone ? pszBuffer : NULL;
}


//+----------------------------------------------------------------------------
//
// Function:  DumpAclInfo
//
// Synopsis:  Dumps out all ACL info for a given object
//
// Arguments: [h] -- handle to object about which info is needed
//
// Returns:   (void)
//
// Notes:
//
//-----------------------------------------------------------------------------
void DumpAclInfo(HANDLE h)
{
    if (!OS_NT)
    {
        CMTRACE(TEXT("DumpAclInfo will not work on 9x systems"));
        return;
    }

    TCHAR szBuf[MAX_PATH];
    SECURITY_INFORMATION si = 0;

    //
    //  dynamically pick up the DLLs we need
    //
    g_hAdvapi32 = LoadLibrary(TEXT("ADVAPI32.DLL"));

    if (NULL == g_hAdvapi32)
    {
        CMTRACE(TEXT("DumpAclInfo: failed to load advapi32.dll"));
        return;
    }

    g_pfnLookupAccountSid =             (pfnLookupAccountSid) GetProcAddress(g_hAdvapi32, "LookupAccountSidW");
    g_pfnGetUserObjectSecurity =        (pfnGetUserObjectSecurity) GetProcAddress(g_hAdvapi32, "GetUserObjectSecurity");
    g_pfnConvertSidToStringSid =        (pfnConvertSidToStringSid) GetProcAddress(g_hAdvapi32, "ConvertSidToStringSidW");
    g_pfnGetSecurityDescriptorOwner =   (pfnGetSecurityDescriptorOwner) GetProcAddress(g_hAdvapi32, "GetSecurityDescriptorOwner");
    g_pfnGetSecurityDescriptorSacl =    (pfnGetSecurityDescriptorSacl) GetProcAddress(g_hAdvapi32, "GetSecurityDescriptorSacl");
    g_pfnGetSecurityDescriptorDacl =    (pfnGetSecurityDescriptorDacl) GetProcAddress(g_hAdvapi32, "GetSecurityDescriptorDacl");
    g_pfnGetAce =                       (pfnGetAce) GetProcAddress(g_hAdvapi32, "GetAce");
    
    if (!(g_pfnLookupAccountSid && g_pfnGetUserObjectSecurity &&
          g_pfnConvertSidToStringSid && g_pfnGetSecurityDescriptorOwner &&
          g_pfnGetSecurityDescriptorSacl && g_pfnGetSecurityDescriptorDacl &&
          g_pfnGetAce))
    {
        CMTRACE(TEXT("DumpAclInfo: failed to load required functions in advapi32.dll"));
        goto Cleanup;        
    }

    //
    // dump information on the ACL
    //
    DWORD dw;

    si |= OWNER_SECURITY_INFORMATION;
    si |= DACL_SECURITY_INFORMATION;

    if (!g_pfnGetUserObjectSecurity(h, &si, NULL, 0, &dw) &&
        ERROR_INSUFFICIENT_BUFFER == GetLastError())
    {
        PSECURITY_DESCRIPTOR pSD = NULL;

        pSD = (PSECURITY_DESCRIPTOR) CmMalloc(dw);

        if (g_pfnGetUserObjectSecurity(h, &si, pSD, dw, &dw))
        {
            // get the owner
            PSID psidOwner;
            BOOL fDefaulted;

            if (g_pfnGetSecurityDescriptorOwner(pSD, &psidOwner, &fDefaulted))
            {
                CMTRACE1(TEXT("SIDINFO: Owner is: %s"), DumpSid(psidOwner, szBuf));
            }

            PACL pacl;
            BOOL fPresent;
            int i;

            g_pfnGetSecurityDescriptorSacl(pSD, &fPresent, &pacl, &fDefaulted);
            CMTRACE1(TEXT("sacl gle=%d"), GetLastError());
            if (fPresent)
            {
                CMTRACE(TEXT("SIDINFO: found a SACL"));
                // has a SACL
                void * pv;
                for (i = 0 ; i < 15; ++i)
                {
                    if (g_pfnGetAce(pacl, i, &pv))
                    {
                        // try access allowed ace
                        //
                        ACCESS_ALLOWED_ACE * pACE = (ACCESS_ALLOWED_ACE *)pv;
                        if (pACE->Header.AceType == ACCESS_ALLOWED_ACE_TYPE)
                        {
                            CMTRACE1(TEXT("SIDINFO: allowed is: %s"), DumpSid(&(pACE->SidStart), szBuf));
                        }
                        else
                        {
                            ACCESS_DENIED_ACE * pACE = (ACCESS_DENIED_ACE *)pv;
                            if (pACE->Header.AceType == ACCESS_DENIED_ACE_TYPE)
                            {
                                CMTRACE1(TEXT("SIDINFO: denied is: %s"), DumpSid(&(pACE->SidStart), szBuf));
                            }
                        }
                    }
                }
            }

            g_pfnGetSecurityDescriptorDacl(pSD, &fPresent, &pacl, &fDefaulted);
            CMTRACE1(TEXT("dacl gle=%d"), GetLastError());
            if (fPresent)
            {
                CMTRACE(TEXT("SIDINFO: found a DACL"));
                // has a DACL
                void * pv;
                for (i = 0 ; i < 15; ++i)
                {
                    if (g_pfnGetAce(pacl, i, &pv))
                    {
                        // try access allowed ace
                        //
                        ACCESS_ALLOWED_ACE * pACE = (ACCESS_ALLOWED_ACE *)pv;
                        if (pACE->Header.AceType == ACCESS_ALLOWED_ACE_TYPE)
                        {
                            CMTRACE1(TEXT("SIDINFO: allowed is: %s"), DumpSid(&(pACE->SidStart), szBuf));
                        }
                        else
                        {
                            ACCESS_DENIED_ACE * pACE = (ACCESS_DENIED_ACE *)pv;
                            if (pACE->Header.AceType == ACCESS_DENIED_ACE_TYPE)
                            {
                                CMTRACE1(TEXT("SIDINFO: denied is: %s"), DumpSid(&(pACE->SidStart), szBuf));
                            }
                        }
                    }
                }
            }
        }
        CmFree(pSD);
    }

Cleanup:

    if (g_hAdvapi32)
    {
        FreeLibrary(g_hAdvapi32);
        g_hAdvapi32 = NULL;
        
        g_pfnLookupAccountSid = NULL;
        g_pfnGetUserObjectSecurity = NULL;
        g_pfnConvertSidToStringSid = NULL;
        g_pfnGetSecurityDescriptorOwner = NULL;
        g_pfnGetSecurityDescriptorSacl = NULL;
        g_pfnGetSecurityDescriptorDacl = NULL;
        g_pfnGetAce = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\hasfileaccess.cpp ===
//+----------------------------------------------------------------------------
//
// Function:  HasSpecifiedAccessToFileOrDir
//
// Synopsis:  This function checks to see if the current user (or any of the groups
//            that the user belongs to) has the requested access to the given 
//            file or directory  object.  If the user has access then the function 
//            returns TRUE, otherwise FALSE.
//
// Arguments: LPTSTR pszFile - full path to the file or dir to check permissions for 
//            DWORD dwDesiredAccess - the desired access to check for
//
// Returns:   BOOL - TRUE if access is granted, FALSE otherwise
//
// History:   quintinb Created                                  7/21/99
//            quintinb Rewrote to use AccessCheck (389246)      08/18/99
//            quintinb made common to cmak and cmdial           03/03/00
//            quintinb Rewrote using CreateFile                 05/19/00
//
//+----------------------------------------------------------------------------
BOOL HasSpecifiedAccessToFileOrDir(LPTSTR pszFile, DWORD dwDesiredAccess)
{
    BOOL bReturn = FALSE;

    if (pszFile && (TEXT('\0') != pszFile[0]))
    {
        if (OS_NT)
        {
            //
            //  Use FILE_FLAG_BACKUP_SEMANTICS so that we can open directories as well as files.
            //
            HANDLE hFileOrDir = CreateFileU(pszFile, dwDesiredAccess, 
                                            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
                                            OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
        
            if (INVALID_HANDLE_VALUE != hFileOrDir)
            {
                bReturn = TRUE;
                CloseHandle(hFileOrDir);
            }
        }
        else
        {
            //
            //  There is no NTFS on win9x and thus all users will have access.  Furthermore, FILE_FLAG_BACKUP_SEMANTICS
            //  isn't supported on win9x and thus CreateFile will return INVALID_HANDLE_VALUE.
            //

            LPSTR pszAnsiFile = WzToSzWithAlloc(pszFile);

            if (pszAnsiFile)
            {
                DWORD dwAttrib = GetFileAttributesA(pszAnsiFile);

                //
                //  Note that we are only checking for failure of the API (-1) and that the
                //  file is not marked Read only (+r).  I checked +s, +h, etc.  and found that
                //  only the read only attribute prevented CM from writing to the cmp.
                //
                bReturn = ((-1 != dwAttrib) && (0 == (FILE_ATTRIBUTE_READONLY & dwAttrib)));
            
                CmFree(pszAnsiFile);
            }
        }
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\getpbk.cpp ===
//+----------------------------------------------------------------------------
//
// File:     getpbk.cpp
//
// Module:   Common Code
//
// Synopsis: Implements the function GetPhoneBookPath.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb    Created Heaser   08/19/99
//
//+----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
// Function:  GetPhoneBookPath
//
// Synopsis:  This function will return the proper path to the phonebook.  If
//            used on a legacy platform this is NULL.  On NT5, the function
//            depends on the proper Install Directory being inputted so that
//            the function can use this as a base to determine the phonebook path.
//            If the inputted pointer to a string buffer is filled with a path,
//            then the directory path will be created as will the pbk file itself.
//            The caller should always call CmFree on the pointer passed into this
//            API when done with the path, because it will either free the memory 
//            or do nothing (NULL case).
//
// Arguments: LPCTSTR pszInstallDir - path to the CM profile dir
//            LPTSTR* ppszPhoneBook - pointer to accept a newly allocated and filled pbk string
//            BOOL fAllUser         - TRUE if this an All-User profile
//
// Returns:   BOOL - returns TRUE if successful
//
// History:   quintinb Created    11/12/98
//            tomkel   06/28/2001   Changed the ACLs when the phonebook gets 
//                                  createdfor an All-User profile
//
//+----------------------------------------------------------------------------
BOOL GetPhoneBookPath(LPCTSTR pszInstallDir, LPTSTR* ppszPhonebook, BOOL fAllUser)
{

    if (NULL == ppszPhonebook)
    {
        CMASSERTMSG(FALSE, TEXT("GetPhoneBookPath -- Invalid Parameter"));
        return FALSE;
    }

    CPlatform plat;

    if (plat.IsAtLeastNT5())
    {
        if ((NULL == pszInstallDir) || (TEXT('\0') == pszInstallDir[0]))
        {
            CMASSERTMSG(FALSE, TEXT("GetPhoneBookPath -- Invalid Install Dir parameter."));
            return FALSE;
        }

        //
        //  Now Create the path to the phonebook.
        //
        LPTSTR pszPhonebook;
        TCHAR szInstallDir[MAX_PATH+1];
        ZeroMemory(szInstallDir, CELEMS(szInstallDir));

        if (TEXT('\\') == pszInstallDir[lstrlen(pszInstallDir) - 1])
        {
            //
            //  Then the path ends in a backslash.  Thus we won't properly
            //  remove CM from the path.  Remove the backslash.
            //
            
            lstrcpyn(szInstallDir, pszInstallDir, lstrlen(pszInstallDir));
        }
        else
        {
            lstrcpy(szInstallDir, pszInstallDir);
        }

        CFileNameParts InstallDirPath(szInstallDir);

        pszPhonebook = (LPTSTR)CmMalloc(lstrlen(InstallDirPath.m_Drive) + 
                                        lstrlen(InstallDirPath.m_Dir) + 
                                        lstrlen(c_pszPbk) + lstrlen(c_pszRasPhonePbk) + 1);

        if (NULL != pszPhonebook)
        {
            wsprintf(pszPhonebook, TEXT("%s%s%s"), InstallDirPath.m_Drive, 
                InstallDirPath.m_Dir, c_pszPbk);

            //
            //  Use CreateLayerDirectory to recursively create the directory structure as
            //  necessary (will create all the directories in a full path if necessary).
            //

            MYVERIFY(FALSE != CreateLayerDirectory(pszPhonebook));

            MYVERIFY(NULL != lstrcat(pszPhonebook, c_pszRasPhonePbk));
            
            HANDLE hPbk = INVALID_HANDLE_VALUE;

            hPbk = CreateFile(pszPhonebook, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ, NULL, CREATE_NEW,
                              FILE_ATTRIBUTE_NORMAL, NULL);

            if (hPbk != INVALID_HANDLE_VALUE)
            {
                MYVERIFY(0 != CloseHandle(hPbk));

                //
                //  Give everyone read and write permissions to the phonebook
                //
                if (fAllUser)
                {
                    AllowAccessToWorld(pszPhonebook);
                }
            }

            *ppszPhonebook = pszPhonebook;
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("CmMalloc returned NULL"));
            return FALSE;
        }    
    }
    else
    {
        *ppszPhonebook = NULL;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\inetopt.cpp ===
//+----------------------------------------------------------------------------
//
// File:     inetopt.cpp
//
// Module:   CMDL32.EXE and CMROUTE.DLL
//
// Synopsis: Source file for shared APIs to set WinInet options
//
// Copyright (c) 2001 Microsoft Corporation
//
// Author:   quintinb   Created     08/22/01
//
//+----------------------------------------------------------------------------
#ifndef _INETOPT_CPP_
#define _INETOPT_CPP_

//+----------------------------------------------------------------------------
//
// Function:  SuppressInetAutoDial
//
// Synopsis:  Sets Inet Option to turn off auto-dial for requests made by this
//            process. This prevents multiple instances of CM popping up to 
//            service CMDL initiated requests if the user disconnects CM 
//            immediately after getting connected.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   nickball    Created Header    6/3/99
//
//+----------------------------------------------------------------------------
void SuppressInetAutoDial(HINTERNET hInternet)
{
    DWORD dwTurnOff = 1;
        
    //
    // The flag only exists for IE5, this call 
    // will have no effect if IE5 is not present.
    //
    
    BOOL bTmp = InternetSetOption(hInternet, INTERNET_OPTION_DISABLE_AUTODIAL, &dwTurnOff, sizeof(DWORD));

    MYDBGTST(FALSE == bTmp, ("InternetSetOption() returned %d, GLE=%u.", bTmp, GetLastError()));
}

//+----------------------------------------------------------------------------
//
// Function:  SetInetStateConnected
//
// Synopsis:  Sets the Inet Option to tell wininet that we are connected.
//            Normally this isn't an issue but if the user has IE set to offline
//            mode, then cmdl cannot get use the wininet APIs to make a
//            phonebook request.  Thus, we will tell Wininet we are connected.
//
// Arguments: HINTERNET hInternet - inet handle to call InternetSetOption on.
//
// Returns:   Nothing
//
// History:   quintinb    Created    08/21/01
//
//+----------------------------------------------------------------------------
BOOL SetInetStateConnected(HINTERNET hInternet)
{
    //
    //  First query wininet to see if we are in offline mode
    //
    DWORD dwConnectedState = 0;
    DWORD dwSize = sizeof(dwConnectedState);

    BOOL bSuccess = InternetQueryOption(hInternet, INTERNET_OPTION_CONNECTED_STATE, &dwConnectedState, &dwSize);

    if (bSuccess)
    {
        if (INTERNET_STATE_DISCONNECTED_BY_USER & dwConnectedState)
        {
            //
            //  Okay, we are in offline mode.  Let's go ahead and set ourselves to connected.
            //
            INTERNET_CONNECTED_INFO ConnInfo = {0};
            ConnInfo.dwConnectedState = INTERNET_STATE_CONNECTED;
            dwSize = sizeof(ConnInfo);

            bSuccess = InternetSetOption(hInternet, INTERNET_OPTION_CONNECTED_STATE, &ConnInfo, dwSize);
            MYDBGTST(FALSE == bSuccess, ("InternetSetOption() returned %d, GLE=%u.", bSuccess, GetLastError()));
        }
    }

    return bSuccess;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\gppswithalloc.cpp ===
//+----------------------------------------------------------------------------
//
// File:     gppswithalloc.cpp
//
// Module:   CMDIAL32.DLL, CMAK.EXE
//
// Synopsis: GetPrivateProfileStringWithAlloc and AddAllKeysInCurrentSectionToCombo
//           are implemented here
//
// Copyright (c) 2000-2001 Microsoft Corporation
//
// Author:   quintinb   Created    11/01/00
//
//+----------------------------------------------------------------------------

#ifndef _CMUTOA

#ifndef GetPrivateProfileStringU
    #ifdef UNICODE
    #define GetPrivateProfileStringU GetPrivateProfileStringW
    #else
    #define GetPrivateProfileStringU GetPrivateProfileStringA
    #endif
#endif

#ifndef lstrlenU
    #ifdef UNICODE
    #define lstrlenU lstrlenW
    #else
    #define lstrlenU lstrlenA
    #endif
#endif

#ifndef SendDlgItemMessageU
    #ifdef UNICODE
    #define SendDlgItemMessageU SendDlgItemMessageW
    #else
    #define SendDlgItemMessageU SendDlgItemMessageA
    #endif
#endif

#endif
//+---------------------------------------------------------------------------
//
//  Function:   GetPrivateProfileStringWithAlloc
//
//  Synopsis:   A wrapper function to encapsulate calling GetPrivateProfileString
//              with string allocation code so the caller doesn't have to worry
//              about buffer sizing.
//
//  Arguments:  LPCTSTR pszSection - section to retrieve the key from
//              LPCTSTR pszKey - keyname to retrieve the value of
//              LPCTSTR pszDefault - default value to use if the key isn't there
//              LPCTSTR pszFile - file to get the data from
//
//  Returns:    LPTSTR - string retrieved from the file or NULL on failure
//
//  History:    quintinb - Created - 11/01/00
//----------------------------------------------------------------------------
LPTSTR GetPrivateProfileStringWithAlloc(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszDefault, LPCTSTR pszFile)
{
    if ((NULL == pszDefault) || (NULL == pszFile))
    {
        CMASSERTMSG(FALSE, TEXT("GetPrivateProfileStringWithAlloc -- null default or pszFile passed"));
        return NULL;
    }

    BOOL bExitLoop = FALSE;
    DWORD dwSize = MAX_PATH;
    DWORD dwReturnedSize;
    LPTSTR pszStringToReturn = NULL;

    pszStringToReturn = (TCHAR*)CmMalloc(dwSize*sizeof(TCHAR));

    do
    {
        MYDBGASSERT(pszStringToReturn);

        if (pszStringToReturn)
        {
            dwReturnedSize = GetPrivateProfileStringU(pszSection, pszKey, pszDefault, pszStringToReturn, 
                                                     dwSize, pszFile);

            if (((dwReturnedSize == (dwSize - 2)) && ((NULL == pszSection) || (NULL == pszKey))) ||
                ((dwReturnedSize == (dwSize - 1)) && ((NULL != pszSection) && (NULL != pszKey))))
            {
                //
                //  The buffer is too small, lets allocate a bigger one
                //
                dwSize = 2*dwSize;
                if (dwSize > 1024*1024)
                {
                    CMASSERTMSG(FALSE, TEXT("GetPrivateProfileStringWithAlloc -- Allocation above 1MB, bailing out."));
                    goto exit;
                }

                pszStringToReturn = (TCHAR*)CmRealloc(pszStringToReturn, dwSize*sizeof(TCHAR));

            }
            else if (0 == dwReturnedSize)
            {
                //
                //  Either we got an error, or more likely there was no data to get
                //
                CmFree(pszStringToReturn);
                pszStringToReturn = NULL;
                goto exit;
            }
            else
            {
                bExitLoop = TRUE;
            }
        }
        else
        {
           goto exit; 
        }

    } while (!bExitLoop);

exit:
    return pszStringToReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddAllKeysInCurrentSectionToCombo
//
//  Synopsis:   This function reads in all the keynames from the given section
//              and file name and populates them into the combo box specified
//              by the hDlg and uComboId params.
//
//  Arguments:  HWND hDlg - window handle of the dialog containing the combobox
//              UINT uComboId - control ID of the combobox
//              LPCTSTR pszSection - section to get the key names from
//              LPCTSTR pszFile - file to pull the key names from
//
//  Returns:    Nothing
//
//  History:    quintinb - Created - 11/01/00
//----------------------------------------------------------------------------
void AddAllKeysInCurrentSectionToCombo(HWND hDlg, UINT uComboId, LPCTSTR pszSection, LPCTSTR pszFile)
{
    if ((NULL == hDlg) || (0 == uComboId) || (NULL == pszFile))
    {
        CMASSERTMSG(FALSE, TEXT("AddAllKeysInCurrentSectionToCombo -- Invalid Parameter passed."));
        return;
    }

    //
    //  Reset the combobox contents
    //
    SendDlgItemMessageU(hDlg, uComboId, CB_RESETCONTENT, 0, 0); //lint !e534 CB_RESETCONTENT doesn't return anything useful

    //
    //  If the section is NULL, just reset the combobox contents and exit
    //
    if (NULL != pszSection)
    {
        //
        //  Lets get all of the keys in the current section
        //
        LPTSTR pszAllKeysInCurrentSection = GetPrivateProfileStringWithAlloc(pszSection, NULL, TEXT(""), pszFile);

        //
        //  Now process all of the keys in the current section
        //
        LPTSTR pszCurrentKey = pszAllKeysInCurrentSection;

        while (pszCurrentKey && TEXT('\0') != pszCurrentKey[0])
        {
            //
            //  Okay, lets add all of the keys that we found
            //

            MYVERIFY(CB_ERR!= SendDlgItemMessageU(hDlg, uComboId, CB_ADDSTRING, 0, (LPARAM)pszCurrentKey));

            //
            //  Advance to the next key in pszAllKeysInCurrentSection
            //
            pszCurrentKey = pszCurrentKey + lstrlenU(pszCurrentKey) + 1;
        }

        CmFree(pszAllKeysInCurrentSection);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\linkdll.cpp ===
//+----------------------------------------------------------------------------
//
// File:     linkdll.cpp
//
// Module:   Common Code
//
// Synopsis: Implementation of linkage functions LinkToDll and BindLinkage
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb       created header      08/19/99
//
//+----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
// Function:  LinkToDll
//
// Synopsis:  Helper function to manage the process of linking to a DLL and 
//            settings up a function table for later use.
//
// Arguments: HINSTANCE *phInst - A ptr to an hInst to be filled with the hInst of the DLL to be linked.
//            LPCTSTR pszDll - Ptr to the name of the DLL to be linked.
//            LPCSTR *ppszPfn - Ptr to a table of function names to be retrieved.
//            void **ppvPfn - Ptr to table for storage of pointers to DLL functions used.
//
// Returns:   BOOL - TRUE if fully loaded and linked.
//
// History:   nickball    Created Header    1/5/98
//
//+----------------------------------------------------------------------------
BOOL LinkToDll(HINSTANCE *phInst, LPCSTR pszDll, LPCSTR *ppszPfn, void **ppvPfn) 
{
    MYDBGASSERT(phInst);
    MYDBGASSERT(pszDll);
    MYDBGASSERT(ppszPfn);
    MYDBGASSERT(ppvPfn);

    CMTRACE1A("LinkToDll - Loading library - %s", pszDll);

    *phInst = LoadLibraryExA(pszDll, NULL, 0);

    if (!*phInst)
    {
        CMTRACE3A("LinkToDll[phInst=%p, *pszDll=%s, ppszPfn=%p,", phInst, MYDBGSTRA(pszDll), ppszPfn);
        CMTRACE1A("\tppvPfn=%p] LoadLibrary() failed.", ppvPfn);
        return FALSE;
    }

    //
    // Link succeeded now setup function addresses
    //
    
    return BindLinkage(*phInst, ppszPfn, ppvPfn);
} 

//+----------------------------------------------------------------------------
//
// Function:  BindLinkage
//
// Synopsis:  Helper function to fill in the given function pointer table with 
//            the addresses of the functions specified in the given string table.
//            Function addresses are retrieved from the DLL specified by hInst.
//
// Arguments: HINSTANCE hInstDll - The hInst of the DLL.
//            LPCSTR *ppszPfn   - Ptr to a table of function names.
//            void **ppvPfn      - Ptr to a table of function pointers to be filled in.
//
// Returns:   BOOL - TRUE if all addresses were successfully retrieved.
//
// History:   nickball    Created    1/5/98
//
//+----------------------------------------------------------------------------
BOOL BindLinkage(HINSTANCE hInstDll, LPCSTR *ppszPfn, void **ppvPfn) 
{   
    MYDBGASSERT(ppszPfn);
    MYDBGASSERT(ppvPfn);

    UINT nIdxPfn;
	BOOL bAllLoaded = TRUE;

    for (nIdxPfn=0;ppszPfn[nIdxPfn];nIdxPfn++) 
    {
	if (!ppvPfn[nIdxPfn]) 
        {
            ppvPfn[nIdxPfn] = GetProcAddress(hInstDll, ppszPfn[nIdxPfn]);

            if (!ppvPfn[nIdxPfn]) 
            {
                CMTRACE3(TEXT("BindLinkage(hInstDll=%d,ppszPfn=%p,ppvPfn=%p)"), hInstDll, ppszPfn, ppvPfn);
                CMTRACE3(TEXT("\tGetProcAddress(hInstDll=%d,*pszProc=%S) failed, GLE=%u."), hInstDll, ppszPfn[nIdxPfn], GetLastError()); 

                bAllLoaded = FALSE;
 	    }
        }
    }
	
    return (bAllLoaded);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\memberofgroup.cpp ===
//+----------------------------------------------------------------------------
//
// File:     MemberOfGroup.cpp
//
// Module:   Common Code
//
// Synopsis: Implements the function IsMemberOfGroup (plus accessor functions).
//
// Copyright (c) 2002 Microsoft Corporation
//
// Author:   SumitC     Created     26-Jan-2002
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
// Function:  IsMemberOfGroup
//
// Synopsis:  This function return TRUE if the current user is a member of 
//            the passed and FALSE passed in Group RID.
//
// Arguments: DWORD dwGroupRID -- the RID of the group to check membership of
//            BOOL bUseBuiltinDomainRid -- whether the SECURITY_BUILTIN_DOMAIN_RID
//                                         RID should be used to build the Group
//                                         SID
//
// Returns:   BOOL - TRUE if the user is a member of the specified group
//
// History:   quintinb  Shamelessly stolen from MSDN            02/19/98
//            quintinb  Reworked and renamed                    06/18/99
//                      to apply to more than just Admins 
//            quintinb  Rewrote to use CheckTokenMemberShip     08/18/99
//                      since the MSDN method was no longer
//                      correct on NT5 -- 389229
//            tomkel    Taken from cmstp and modified for use   05/09/2001
//                      in cmdial
//            sumitc    Made common code                        01/26/2002 
//
//+----------------------------------------------------------------------------
BOOL IsMemberOfGroup(DWORD dwGroupRID, BOOL bUseBuiltinDomainRid)
{
    PSID psidGroup = NULL;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    BOOL bSuccess = FALSE;

    if (OS_NT5)
    {
        //
        //  Make a SID for the Group we are checking for, Note that we if we need the Built 
        //  in Domain RID (for Groups like Administrators, PowerUsers, Users, etc)
        //  then we will have two entries to pass to AllocateAndInitializeSid.  Otherwise,
        //  (for groups like Authenticated Users) we will only have one.
        //
        BYTE byNum;
        DWORD dwFirstRID;
        DWORD dwSecondRID;

        if (bUseBuiltinDomainRid)
        {
            byNum = 2;
            dwFirstRID = SECURITY_BUILTIN_DOMAIN_RID;
            dwSecondRID = dwGroupRID;
        }
        else
        {
            byNum = 1;
            dwFirstRID = dwGroupRID;
            dwSecondRID = 0;
        }

        if (AllocateAndInitializeSid(&siaNtAuthority, byNum, dwFirstRID, dwSecondRID,
                                     0, 0, 0, 0, 0, 0, &psidGroup))

        {
            //
            //  Now we need to dynamically load the CheckTokenMemberShip API from 
            //  advapi32.dll since it is a Win2k only API.
            //

            // some modules using this may have advapi32 loaded already...
            HMODULE hAdvapi = GetModuleHandleA("advapi32.dll");

            if (NULL == hAdvapi)
            {
                // ... if they don't, load it.
                hAdvapi = LoadLibraryExA("advapi32.dll", NULL, 0);
            }

            if (hAdvapi)
            {
                typedef BOOL (WINAPI *pfnCheckTokenMembershipSpec)(HANDLE, PSID, PBOOL);
                pfnCheckTokenMembershipSpec pfnCheckTokenMembership;

                pfnCheckTokenMembership = (pfnCheckTokenMembershipSpec)GetProcAddress(hAdvapi, "CheckTokenMembership");

                if (pfnCheckTokenMembership)
                {
                    //
                    //  Check to see if the user is actually a member of the group in question
                    //
                    if (!(pfnCheckTokenMembership)(NULL, psidGroup, &bSuccess))
                    {
                        bSuccess = FALSE;
                        CMASSERTMSG(FALSE, TEXT("CheckTokenMemberShip Failed."));
                    }            
                }   
                else
                {
                    CMASSERTMSG(FALSE, TEXT("IsMemberOfGroup -- GetProcAddress failed for CheckTokenMemberShip"));
                }
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("IsMemberOfGroup -- Unable to get the module handle for advapi32.dll"));            
            }

            FreeSid (psidGroup);

            if (hAdvapi)
            {
                FreeLibrary(hAdvapi);
            }
        }
    }

    return bSuccess;
}



//+----------------------------------------------------------------------------
//
// Function:  IsAdmin
//
// Synopsis:  Check to see if the user is a member of the Administrators group
//            or not.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current user is an Administrator
//
// History:   quintinb Created Header    8/18/99
//            tomkel    Taken from cmstp 05/09/2001
//            sumitc    Made common code 01/26/2002 
//
//+----------------------------------------------------------------------------
BOOL IsAdmin(VOID)
{
    return IsMemberOfGroup(DOMAIN_ALIAS_RID_ADMINS, TRUE); // TRUE == bUseBuiltinDomainRid
}

//+----------------------------------------------------------------------------
//
// Function:  IsAuthenticatedUser
//
// Synopsis:  Check to see if the current user is a member of the 
//            Authenticated Users group.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current user is a member of the
//                   Authenticated Users group. 
//
// History:   quintinb Created Header    8/18/99
//            sumitc    Made common code 01/26/2002 
//
//+----------------------------------------------------------------------------
BOOL IsAuthenticatedUser(void)
{
      return IsMemberOfGroup(SECURITY_AUTHENTICATED_USER_RID, FALSE); // FALSE == bUseBuiltinDomainRid
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\modelessdlg.cpp ===
//+----------------------------------------------------------------------------
//
// File:     modlessdlg.cpp
//
// Module:   CMDIAL32.DLL and CMMON32.EXE
//
// Synopsis: Implementation of the class CModelessDlg
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:   nickball    Created    03/22/00
//
//+----------------------------------------------------------------------------

#include "CmDebug.h"
#include "modelessdlg.h"

//
// Flash info.
//

typedef struct {
    UINT  cbSize;
    HWND  hwnd;
    DWORD dwFlags;
    UINT  uCount;
    DWORD dwTimeout;
} FLASHWINFO, *PFLASHWINFO;

#define FLASHW_STOP         0
#define FLASHW_CAPTION      0x00000001
#define FLASHW_TRAY         0x00000002
#define FLASHW_ALL          (FLASHW_CAPTION | FLASHW_TRAY)
#define FLASHW_TIMER        0x00000004
#define FLASHW_TIMERNOFG    0x0000000C

//+----------------------------------------------------------------------------
//
// Function:  CModelessDlg::Flash
//
// Synopsis:  Helper method to flash the modeless dialog. Currently 
//            hardwired to flash taskbar until window is in foreground.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   nickball      Created     03/22/00
//
//+----------------------------------------------------------------------------
void CModelessDlg::Flash()
{
    //
    // Do the flash window thing, because SetForeGround window has 
    // been emasculated. We want the user to know something is up.
    //

    if (OS_NT5 || OS_W98) // no support on NT4 and 95
    {
        HINSTANCE hInst = LoadLibrary(TEXT("USER32"));

        if (hInst)
        {
            typedef BOOL (WINAPI* FlashWindowExFUNC) (PFLASHWINFO pfwi);
            
            FlashWindowExFUNC pfnFlashWindowEx = 
                (FlashWindowExFUNC) GetProcAddress(hInst, "FlashWindowEx");

            MYDBGASSERT(pfnFlashWindowEx);

            if (pfnFlashWindowEx)
            {
                FLASHWINFO fi;

                fi.cbSize = sizeof(fi);
                fi.hwnd   = m_hWnd;
                fi.dwFlags = FLASHW_TRAY | FLASHW_TIMERNOFG;
                fi.uCount  = -1;
                fi.dwTimeout = 0;

                pfnFlashWindowEx(&fi);
            }
            
            FreeLibrary(hInst);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CModelessDlg::Create
//
// Synopsis:  Same as CreateDialog
//
// Arguments: HINSTANCE hInstance - Same as CreateDialog
//            LPCTSTR lpTemplateName - 
//            HWND hWndParent - 
//
// Returns:   HWND - Same as CreateDialog
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
HWND CModelessDlg::Create(HINSTANCE hInstance, 
                    LPCTSTR lpTemplateName,
                    HWND hWndParent)
{
    m_hWnd = ::CreateDialogParamU(hInstance, lpTemplateName, hWndParent, 
                                  ModalDialogProc, (LPARAM)this);

#ifdef DEBUG
    if (!m_hWnd)
    {
        CMTRACE1(TEXT("CreateDialogParam failed. LastError %d"), GetLastError());
    }
#endif
    MYDBGASSERT(m_hWnd);

    return m_hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\modaldlg.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ModalDlg.cpp	 
//
// Module:   Connection manager
//
// Synopsis: Implementation of the classes CWindowWithHelp, CModalDlg
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun Created    02/17/98
//
//+----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
// Function:  CWindowWithHelp::CWindowWithHelp
//
// Synopsis:  Constructor
//
// Arguments: const DWORD* pHelpPairs - The pairs of control-ID/Help-ID
//            const TCHAR* lpszHelpFile - The help file name, default is NULL
//                 Call also call SetHelpFileName() to provide help file
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
CWindowWithHelp::CWindowWithHelp(const DWORD* pHelpPairs, const TCHAR* lpszHelpFile) 
{
    m_lpszHelpFile = NULL;
    m_hWnd = NULL;
    m_pHelpPairs = pHelpPairs; 
    
    if (lpszHelpFile)
    {
        SetHelpFileName(lpszHelpFile);
    }
}



//+----------------------------------------------------------------------------
//
// Function:  CWindowWithHelp::~CWindowWithHelp
//
// Synopsis:  Destructor
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/20/98
//
//+----------------------------------------------------------------------------
CWindowWithHelp::~CWindowWithHelp()
{
    CmFree(m_lpszHelpFile);
}



//+----------------------------------------------------------------------------
//
// Function:  CWindowWithHelp::SetHelpFileName
//
// Synopsis:  Set the help file name of the window
//
// Arguments: const TCHAR* lpszHelpFile - the help file name to set
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CWindowWithHelp::SetHelpFileName(const TCHAR* lpszHelpFile)
{
    MYDBGASSERT(m_lpszHelpFile == NULL);
    MYDBGASSERT(lpszHelpFile);

    CmFree(m_lpszHelpFile);
    m_lpszHelpFile = NULL;

    if (lpszHelpFile && lpszHelpFile[0])
    {
        m_lpszHelpFile = CmStrCpyAlloc(lpszHelpFile);
        MYDBGASSERT(m_lpszHelpFile);
    }
}


//+----------------------------------------------------------------------------
//
// Function:  CWindowWithHelp::HasContextHelp
//
// Synopsis:  Whether a control has context help
//
// Arguments: HWND hWndCtrl - The window handle of the control
//
// Returns:   BOOL - TRUE , if the control has context help
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
BOOL CWindowWithHelp::HasContextHelp(HWND hWndCtrl) const
{
    if (hWndCtrl == NULL || m_pHelpPairs == NULL)
    {
        return FALSE;
    }

    //
    // looks through the help pairs for the control 
    //
    for (int i=0; m_pHelpPairs[i]!=0; i+=2)
    {
        if (m_pHelpPairs[i] == (DWORD)GetDlgCtrlID(hWndCtrl))
        {
            CMTRACE3(TEXT("HasContextHelp() - hwndCtrl %d has Ctrl ID %d and context help ID %d"), hWndCtrl, m_pHelpPairs[i], m_pHelpPairs[i+1]);
            return TRUE;
        }
    }

    CMTRACE1(TEXT("HasContextHelp() - hwndCtrl %d has no context help"), hWndCtrl);

    return FALSE;
}


//+----------------------------------------------------------------------------
//
// Function:  CWindowWithHelp::OnHelp
//
// Synopsis:  Call on WM_HELP message. Which means F1 is pressed
//
// Arguments: const HELPINFO* pHelpInfo - lParam of WM_HELP
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CWindowWithHelp::OnHelp(const HELPINFO* pHelpInfo)
{
    //
    // If help file exist and the help id exist WinHelp
    //
    if (m_lpszHelpFile && m_lpszHelpFile[0] && HasContextHelp((HWND) pHelpInfo->hItemHandle))
    {
		CmWinHelp((HWND)pHelpInfo->hItemHandle, (HWND)pHelpInfo->hItemHandle, m_lpszHelpFile, HELP_WM_HELP, 
                (ULONG_PTR)(LPSTR)m_pHelpPairs);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CWindowWithHelp::OnContextMenu
//
// Synopsis:  called upon WM_CONTEXTMENU message (Right click or '?')
//
// Arguments:  HWND hWnd - Handle to the window in which the user right clicked 
//                          the mouse 
//            POINT& pos - position of the cursor 
//
// Returns:   BOOL, TRUE if the message is processed
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
BOOL CWindowWithHelp::OnContextMenu(HWND hWnd, POINT& pos)
{
    
    ScreenToClient(m_hWnd, &pos);

    //
    // If more than one child window contains the specified point, ChildWindowFromPoint() 
    // returns a handle to the first window in the list that contains the point. 
    // This becomes a problem if we have controls inside groupbox
    //
    HWND hWndChild = ChildWindowFromPointEx(m_hWnd, pos, CWP_SKIPINVISIBLE);

    if (m_lpszHelpFile && m_lpszHelpFile[0] && hWndChild && HasContextHelp(hWndChild))
    {
        CMTRACE2(TEXT("OnContextMenu() - Calling WinHelp hWnd is %d, m_hWnd is %d"), hWnd, m_hWnd);
        CmWinHelp(hWnd, hWndChild, m_lpszHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)m_pHelpPairs);
        return TRUE;
    }

    return FALSE; // Return FALSE, DefaultWindowProc will handle this message then.
}

//+----------------------------------------------------------------------------
//
// Function:  CModalDlg::DoDialogBox
//
// Synopsis:  Same as DialogBox
//
// Arguments: HINSTANCE hInstance - Same as ::DialogBox
//            LPCTSTR lpTemplateName - 
//            HWND hWndParent - 
//
// Returns:   int - Same as DialogBox
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
INT_PTR CModalDlg::DoDialogBox(HINSTANCE hInstance, 
                    LPCTSTR lpTemplateName,
                    HWND hWndParent)
{
    INT_PTR iRet = ::DialogBoxParamU(hInstance, lpTemplateName, hWndParent, 
        ModalDialogProc, (LPARAM)this);

    m_hWnd = NULL;

    return iRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CModalDlg::ModalDialogProc
//
// Synopsis:  The dialog window procedure for all dialogbox derived
//
// Arguments: HWND hwndDlg - 
//            UINT uMsg - 
//            WPARAM wParam - 
//            LPARAM lParam - 
//
// Returns:   BOOL CALLBACK - 
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
INT_PTR CALLBACK CModalDlg::ModalDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    CModalDlg* pDlg;

    //
    // Save the object pointer on  WM_INITDIALOG
    // lParam is the pointer
    //
    if (uMsg == WM_INITDIALOG)
    {
        pDlg = (CModalDlg*) lParam;

        MYDBGASSERT(lParam);
        MYDBGASSERT(((CModalDlg*)lParam)->m_hWnd == NULL);

        //
        // Save the object pointer, this is implementation detail
        // The user of this class should not be aware of this
        //
        ::SetWindowLongU(hwndDlg, DWLP_USER, (LONG_PTR)lParam);

        pDlg->m_hWnd = hwndDlg;
    }
    else
    {
        pDlg = (CModalDlg*)GetWindowLongU(hwndDlg, DWLP_USER);

        //
        // some msgs can come before WM_INITDIALOG
        //
        if (pDlg == NULL)
        {
            return FALSE;
        }

    }

    MYDBGASSERT(pDlg->m_hWnd == hwndDlg);
    ASSERT_VALID(pDlg);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        return pDlg->OnInitDialog();

    case WM_HELP:
        pDlg->OnHelp((LPHELPINFO)lParam);
        return TRUE;

	case WM_CONTEXTMENU:
        {
            POINT   pos = {LOWORD(lParam), HIWORD(lParam)};
            return pDlg->OnContextMenu((HWND) wParam, pos);
        }

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            pDlg->OnOK();
            return FALSE;

        case IDCANCEL:
            pDlg->OnCancel();
            return FALSE;

        default:
            return pDlg->OnOtherCommand(wParam,lParam);
        }

     default:
         return pDlg->OnOtherMessage(uMsg, wParam, lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\mutex.cpp ===
//+----------------------------------------------------------------------------
//
// File:     mutex.cpp
//
// Module:   Common Code
//
// Synopsis: Implementation of the class CNamedMutex
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun Created    02/26/98
//
//+----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
// Function:  CNamedMutex::Lock
//
// Synopsis:  
//
// Arguments: LPCTSTR lpName - Name of the mutex
//            BOOL fWait - Whether caller want to wait, if mutex is not available
//                         Default is FALSE
//            DWORD dwMilliseconds - Timeout for wait, default is INFINITE
//            BOOL fNoAbandon - Don't acquire an abandoned mutex
//
// Returns:   BOOL - Whether the mutex is acquired, if TRUE, caller should call
//                   Unlock to release the lock.  Otherwise, the lock will be
//                   released in destructor
//
// History:   fengsun   Created Header    02/26/98
//            nickball  Added fNoAbandon  03/32/99
//
//+----------------------------------------------------------------------------
BOOL CNamedMutex::Lock(LPCTSTR lpName, BOOL fWait, DWORD dwMilliseconds, BOOL fNoAbandon)
{
    MYDBGASSERT(m_hMutex == NULL);
    MYDBGASSERT(lpName);

    m_fOwn = FALSE;

    CMTRACE1(TEXT("CNamedMutex::Lock() - Attempting to acquire mutex - %s"), lpName);

    m_hMutex = CreateMutexU(NULL,TRUE,lpName);
    MYDBGASSERT(m_hMutex);

    if (m_hMutex == NULL)
    {
        return FALSE;
    }

    DWORD dwRet = GetLastError();
    if (dwRet != ERROR_ALREADY_EXISTS) 
    {
        //
        // We got the mutex
        //
        m_fOwn = TRUE;
        return TRUE;
    }

    CMTRACE1(TEXT("CNamedMutex::Lock() - Mutex already exists - %s"), lpName);

    //
    // Someone else own the mutex
    //
    if (!fWait)  // caller does not want to wait
    {       
        CMTRACE1(TEXT("CNamedMutex::Lock() - Not waiting for mutex - %s"), lpName);
        CloseHandle(m_hMutex);
        m_hMutex = NULL;
        return FALSE;
    }

    //
    // Caller want to wait until the mutex is released
    //

    CMTRACE(TEXT("CNamedMutex::Lock() - Entering Mutex wait"));

    dwRet = WaitForSingleObject(m_hMutex, dwMilliseconds);

    switch (dwRet)
    {
        case WAIT_ABANDONED:
        
            CMTRACE1(TEXT("CNamedMutex::Lock() - Mutex was abandoned by previous owner - %s"), lpName);
            
            //
            // If the thread that owns a mutex is blown away, the wait will 
            // release with a return of WAIT_ABANDON. This typically happens
            // if the thread is dumped from memory, or someone doesn't clean 
            // up before terminating. Either way, the caller may not want to 
            // acquire an abandoned mutex, so just release it if that is what 
            // the caller specified and the wait returned.
            //

            if (fNoAbandon)
            {
                CMTRACE1(TEXT("CNamedMutex::Lock() - Releasing abandoned mutex- %s"), lpName);
                ReleaseMutex(m_hMutex);
                break;
            }
            
            //
            // Fall through to standard mutex acquisition
            //

        case WAIT_OBJECT_0:
    
            //
            // We get the mutex
            //

            m_fOwn = TRUE;
            CMTRACE1(TEXT("CNamedMutex::Lock() - Mutex acquired - %s"), lpName);
            return TRUE;
   
        default:       
            CMTRACE1(TEXT("CNamedMutex::Lock() - Mutex wait timed out - %s"), lpName);
            break;
    }

    CloseHandle(m_hMutex);
    m_hMutex = NULL;

    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CNamedMutex::Unlock
//
// Synopsis:  Release the mutex
//
// Arguments: 
//
// Returns:   NONE
//
// History:   fengsun Created Header    2/19/98
//
//+----------------------------------------------------------------------------
void CNamedMutex::Unlock()
{
    if (m_hMutex != NULL)
    {
        if (m_fOwn)
        {
	        ReleaseMutex(m_hMutex);
            m_fOwn = FALSE;
        }
    
        CloseHandle(m_hMutex);
        m_hMutex = NULL;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\pwutil.cpp ===
//+----------------------------------------------------------------------------
//
// File:     pwutil.cpp
//
// Module:   Common Source
//
// Synopsis: Simple encryption funcs - borrowed from RAS
//
// Copyright (c) 1994-1999 Microsoft Corporation
//
// Author:   nickball    Created    08/03/99
//
//+----------------------------------------------------------------------------

#define PASSWORDMAGIC 0xA5



VOID
ReverseSzA(
    CHAR* psz )

    /* Reverses order of characters in 'psz'.
    */
{
    CHAR* pszBegin;
    CHAR* pszEnd;

    for (pszBegin = psz, pszEnd = psz + lstrlenA( psz ) - 1;
         pszBegin < pszEnd;
         ++pszBegin, --pszEnd)
    {
        CHAR ch = *pszBegin;
        *pszBegin = *pszEnd;
        *pszEnd = ch;
    }
}


VOID
ReverseSzW(
    WCHAR* psz )

    /* Reverses order of characters in 'psz'.
    */
{
    WCHAR* pszBegin;
    WCHAR* pszEnd;

    for (pszBegin = psz, pszEnd = psz + lstrlenW( psz ) - 1;
         pszBegin < pszEnd;
         ++pszBegin, --pszEnd)
    {
        WCHAR ch = *pszBegin;
        *pszBegin = *pszEnd;
        *pszEnd = ch;
    }
}


VOID
CmDecodePasswordA(
    IN OUT CHAR* pszPassword )

    /* Un-obfuscate 'pszPassword' in place.
    **
    ** Returns Nothing
    */
{
    CmEncodePasswordA( pszPassword );
}


VOID
CmDecodePasswordW(
    IN OUT WCHAR* pszPassword )

    /* Un-obfuscate 'pszPassword' in place.
    **
    ** Returns the address of 'pszPassword'.
    */
{
    CmEncodePasswordW( pszPassword );
}


VOID
CmEncodePasswordA(
    IN OUT CHAR* pszPassword )

    /* Obfuscate 'pszPassword' in place to foil memory scans for passwords.
    **
    ** Returns Nothing
    */
{
    if (pszPassword)
    {
        CHAR* psz;

        ReverseSzA( pszPassword );

        for (psz = pszPassword; *psz != '\0'; ++psz)
        {
            if (*psz != PASSWORDMAGIC)
                *psz ^= PASSWORDMAGIC;
        }
    }
}


VOID
CmEncodePasswordW(
    IN OUT WCHAR* pszPassword )

    /* Obfuscate 'pszPassword' in place to foil memory scans for passwords.
    **
    ** Returns Nothing
    */
{
    if (pszPassword)
    {
        WCHAR* psz;

        ReverseSzW( pszPassword );

        for (psz = pszPassword; *psz != L'\0'; ++psz)
        {
            if (*psz != PASSWORDMAGIC)
                *psz ^= PASSWORDMAGIC;
        }
    }
}


VOID
CmWipePasswordA(
    IN OUT CHAR* pszPassword )

    /* Zero out the memory occupied by a password.
    **
    ** Returns Nothing
    */
{
    if (pszPassword)
    {
        CHAR* psz = pszPassword;

        // 
        // We are assuming the string is NULL terminated, thus we just need to pass 
        // the actual string length (converted to bytes) to be wiped. The is no need 
        // to include the NULL character in the count.
        //
        psz = (CHAR*)CmSecureZeroMemory((PVOID)psz, lstrlenA(psz) * sizeof(CHAR));
    }
}


VOID
CmWipePasswordW(
    IN OUT WCHAR* pszPassword )

    /* Zero out the memory occupied by a password.
    **
    ** Returns Nothing
    */
{
    if (pszPassword)
    {
        WCHAR* psz = pszPassword;

        // 
        // We are assuming the string is NULL terminated, thus we just need to pass 
        // the actual string length (converted to bytes) to be wiped. The is no need 
        // to include the NULL character in the count.
        //
        psz = (WCHAR*)CmSecureZeroMemory((PVOID)psz, lstrlenW(psz) * sizeof(WCHAR));

    }
}


//+----------------------------------------------------------------------------
//
// Function:  CmSecureZeroMemory
//
// Synopsis:  RtlSecureZeroMemory isn't available on all platforms so we took 
//            its implementation. 
//
// Arguments: ptr - memory pointer
//            cnt - size in bytes of memory to clear
//
// Returns:   poniter to beginning of memory
//
//+----------------------------------------------------------------------------
PVOID CmSecureZeroMemory(IN PVOID ptr, IN SIZE_T cnt)
{
    if (ptr)
    {
        volatile char *vptr = (volatile char *)ptr;
        while (cnt) 
        {
            *vptr = 0;
            vptr++;
            cnt--;
        }
    }
    return ptr;
}


// Only include this code in CMDial32.dll
#ifdef _ICM_INC

//+----------------------------------------------------------------------------
// Class:     CSecurePassword
//
// Function:  CSecurePassword
//
// Synopsis:  Constructor
//
// Arguments: none
//
// Returns:   Nothing
//
// History:   11/05/2002    tomkel    Created
//
//+----------------------------------------------------------------------------
CSecurePassword::CSecurePassword()
{
    this->Init();
}

//+----------------------------------------------------------------------------
//
// Function:  ~CSecurePassword
//
// Synopsis:  Destructor. Unloads DLL, tries to clear memory & free memory.
//            Makes sure we don't have a memory leak.
//
// Arguments: none
//
// Returns:   Nothing
//
//+----------------------------------------------------------------------------
CSecurePassword::~CSecurePassword()
{
    this->UnInit();

    //
    // Assert if m_iAllocAndFreeCounter isn't zero. It means we are leaking memory.
    // Each GetPasswordWithAlloc call increments this
    // Each ClearAndFree call decrements this. 
    //
    MYDBGASSERT(0 == m_iAllocAndFreeCounter);
}

//+----------------------------------------------------------------------------
//
// Function:  Init
//
// Synopsis:  Initializes member variables.
//
// Arguments: none
//
// Returns:   Nothing
//
//+----------------------------------------------------------------------------
VOID CSecurePassword::Init()
{
    m_iAllocAndFreeCounter = 0;
    m_fIsLibAndFuncPtrsAvail = FALSE;
    m_pEncryptedPW = NULL;
    
    fnCryptProtectData = NULL;
    fnCryptUnprotectData = NULL;
    
    m_fIsEmptyString = TRUE;
    m_fIsHandleToPassword = FALSE;
    
    // By default just set it to PWLEN
    m_dwMaxDataLen = PWLEN;

    this->ClearMemberVars();
}



//+----------------------------------------------------------------------------
//
// Function:  SetPassword
//
// Synopsis:  We take this string that is passed in and store it
//            internally. Based on the OS it encrypts
//            or encodes it, thus we don't store it in clear. This method handles
//            0 length strings, which can be used to clear the member
//            variable. If a RAS password handle (consists of 16 '*'),
//            there is no need for us to encrypt it. To optimize this
//            we set an member flag specifying that currently this 
//            instance just hold a handle to a password. On downlevel
//            platforms we don't use expensive encryption calls, thus 
//            the logic doesn't distinguish between a normal password 
//            and a password handle.
//
// Arguments: szPassword - password in clear text. 
//
// Returns: TRUE - if everything succeeded
//          FALSE - if something failed
//
//+----------------------------------------------------------------------------
BOOL CSecurePassword::SetPassword(IN LPWSTR pszPassword)
{    
    BOOL fRetCode = FALSE;
    DWORD dwRetCode = ERROR_SUCCESS;
    DWORD dwPwLen = 0;
    //
    // OS_NT5 expands to a few function calls, so just cache the result and reuse it below
    //
    BOOL fIsNT5OrAbove = OS_NT5;

    //
    // If there is an allocated blob then free it first so we don't leak memory.
    //
    this->ClearMemberVars();

    m_fIsEmptyString = ((NULL == pszPassword) || (TEXT('\0') == pszPassword[0]));

    if (m_fIsEmptyString)
    {
        //
        // No need to continue, since password can be NULL the code below that compares
        // it to a handle (16 *s) would be dereferencing a NULL
        //
        m_fIsHandleToPassword = FALSE;
        return TRUE;
    }

    //
    // Check whether this is a handle to a password (****************)
    //
    m_fIsHandleToPassword = (fIsNT5OrAbove && (0 == lstrcmpW(c_pszSavedPasswordToken, pszPassword)));

    //
    // If the internal flag is set, there is no need to encrypt or decrypt this string.
    //
    if (m_fIsHandleToPassword)
    {
        return TRUE;
    }

    // 
    // Make sure the password that is being encrypted is shorter than the allowed maximum
    //
    dwPwLen = lstrlenU(pszPassword);
    if (m_dwMaxDataLen < dwPwLen)
    {
        return FALSE;
    }

    if (fIsNT5OrAbove)
    {
        m_pEncryptedPW = (DATA_BLOB*)CmMalloc(sizeof(DATA_BLOB));

        if (m_pEncryptedPW)
        {
            dwRetCode = this->EncodePassword((dwPwLen + 1) * sizeof(WCHAR), (PBYTE)pszPassword, m_pEncryptedPW);

            if (ERROR_SUCCESS == dwRetCode)
            {
                fRetCode = TRUE;
            }
            else
            {
                //
                // Free the allocated DATA_BLOB so that decryption doesn't cause issue in case caller 
                // ends up calling it. And reset internal flags.
                //
                this->ClearMemberVars();
                m_fIsEmptyString = TRUE;
                m_fIsHandleToPassword = FALSE;
                CMTRACE1(TEXT("CSecurePassword::SetPassword - this->EncodePassword failed. 0x%x"), dwRetCode);
            }
        }
    }
    else
    {
        // 
        // Downlevel (Win9x, NT4) we don't support encryption
        //
        lstrcpynU(m_tszPassword, pszPassword, CELEMS(m_tszPassword));
        CmEncodePassword(m_tszPassword);
        fRetCode = TRUE;
    }

    MYDBGASSERT(fRetCode);
    return fRetCode;
}

//+----------------------------------------------------------------------------
//
// Function:  GetPasswordWithAlloc
//
// Synopsis:  Allocates a buffer and copies the clear-text password into it. 
//            Based on the OS it decrypts or decodes it since it's not stored 
//            in clear. If the internal password is an empty string we allocate 
//            an empty string buffer. This is done for consistency since the caller
//            needs to call our free method so memory isn't leaked. If we are storing 
//            a RAS password handle (consists of 16 '*') we actually didn't store it,
//            but only set our internal flag. In this case we need to allocate a buffer
//            with 16 * and return it. On downlevel platforms we don't use expensive 
//            decryption calls, thus the logic doesn't distinguish between a 
//            normal password and a password handle.
//
// Arguments: pszClearPw - holds a pointer to a buffer that was allocated by this
//                          class. 
//            pcbClearPw - hold the size of the allocated buffer in bytes    
//
// Returns: TRUE - if everything succeeded
//          FALSE - if something failed
//
//+----------------------------------------------------------------------------
BOOL CSecurePassword::GetPasswordWithAlloc(OUT LPWSTR* pszClearPw, OUT DWORD* pcbClearPw)
{
    BOOL fRetCode = FALSE;
    DWORD dwRetCode = ERROR_SUCCESS;
    DWORD cbData = 0;
    PBYTE pbData = NULL;

    if ((NULL == pszClearPw) || (NULL == pcbClearPw)) 
    {
        MYDBGASSERT(FALSE);
        return FALSE;
    }

    *pszClearPw = NULL;
    *pcbClearPw = 0;

    if (OS_NT5)
    {
        if (m_fIsEmptyString)
        {
            // 
            // In case there is nothing saved in this class, just allocate an empty string
            // and return it back. This at least doesn't have to decrypt and empty string.
            //
            DWORD cbLen = sizeof(WCHAR);

            LPWSTR szTemp = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, cbLen);
            if (szTemp)
            {
                *pszClearPw = szTemp;
                *pcbClearPw = cbLen;
                fRetCode = TRUE;
                m_iAllocAndFreeCounter++;
            }
        }
        else
        {
            //
            // Check if this instance is just a handle to a RAS password (16 *)
            // If so, then just allocate that string and return it to the caller,
            // otherwise proceed normally and decrypt our blob.
            //
            if (m_fIsHandleToPassword)
            {
                size_t nLen = lstrlenW(c_pszSavedPasswordToken) + 1;
                DWORD cbLen = nLen * sizeof(WCHAR);

                LPWSTR szTemp = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, cbLen);
                if (szTemp)
                {
                    lstrcpynW(szTemp, c_pszSavedPasswordToken, nLen);

                    *pszClearPw = szTemp;
                    *pcbClearPw = cbLen;
                    fRetCode = TRUE;
                    m_iAllocAndFreeCounter++;
                }
            }
            else
            {
                if (m_pEncryptedPW)
                {
                    dwRetCode = this->DecodePassword(m_pEncryptedPW, &cbData, &pbData);
                    if ((NO_ERROR == dwRetCode) && pbData && cbData)
                    {
                        *pszClearPw = (LPWSTR)pbData;
                        *pcbClearPw = cbData;
                        fRetCode = TRUE;
                        m_iAllocAndFreeCounter++;
                    }
                }
            }
        }
    }
    else
    {
        // 
        // Downlevel (Win9x, NT4) doesn't support 16 *
        //

        size_t nLen = lstrlenU(m_tszPassword) + 1;

        LPTSTR pszBuffer = (LPWSTR)CmMalloc(nLen * sizeof(TCHAR));

        if (pszBuffer) 
        {
            //
            // Copy our encoded buffer to the newly allocated buffer
            // We can do this because d/encoding is done in place
            //
            lstrcpynU(pszBuffer, m_tszPassword, nLen);

            //
            // Decode the outgoing buffer
            //
            CmDecodePassword(pszBuffer);

            *pszClearPw = (LPWSTR)pszBuffer;
            *pcbClearPw = nLen * sizeof(TCHAR);

            fRetCode = TRUE;
            m_iAllocAndFreeCounter++;
        }
    }

    MYDBGASSERT(fRetCode);
    return fRetCode;
}

//+----------------------------------------------------------------------------
//
// Function:  ClearAndFree
//
// Synopsis:  Clear then free a buffer that was allocated by this class. Notice that 
//            on downlevel platforms the way a buffer is freed differs. That
//            is because encrypting and decrypting needs us to free it 
//            using LocalFree. For downlevel platforms we chose CM's standard
//            way of allocating memory (CmMalloc) and it now needs to be 
//            freed using CmFree. 
//
// Arguments: pszClearPw - holds a pointer to a buffer that was allocated by this
//                          class. 
//            cbClearPw - size of the allocated buffer in bytes    
//
// Returns: TRUE - if everything succeeded
//          FALSE - if something failed
//
//+----------------------------------------------------------------------------
VOID CSecurePassword::ClearAndFree(IN OUT LPWSTR* pszClearPw, IN DWORD cbClearPw)
{
    if ((NULL == pszClearPw) || (0 == cbClearPw))
    {
        return;
    }
    
    if (NULL == *pszClearPw)
    {
        return;
    }

    CmSecureZeroMemory(*pszClearPw, cbClearPw);

    if (OS_NT5)
    {
        //
        // Uses LocalFree because CryptProtectData requires this way
        // to free its memory
        //

        LocalFree(*pszClearPw);
    }
    else
    {
        //
        // We used CmMalloc to allocate so we need to call CmFree
        //

        CmFree(*pszClearPw);
    }

    *pszClearPw = NULL;
    m_iAllocAndFreeCounter--;

    return;
}

//+----------------------------------------------------------------------------
//
// Function:  ClearMemberVars
//
// Synopsis:  Clears our member variables. Notice that we only clear the 
//            passwords & member variables. This doesn't mean that m_fIsEmptyString 
//            should be set. This needs to be a private method
//            because it doesn't reset the empty or password handle flags. Thus
//            outside callers should NOT use this, because it would create an invalid
//            state.
//
// Arguments: none
//
// Returns: none
//
//+----------------------------------------------------------------------------
VOID CSecurePassword::ClearMemberVars()
{
    if (OS_NT5)
    {
        if (m_pEncryptedPW)
        {
            this->FreePassword(m_pEncryptedPW);
            CmFree(m_pEncryptedPW);
            m_pEncryptedPW = NULL;
        }
    }
    else
    {
        //
        // Zero out the password buffer
        //
        CmSecureZeroMemory((PVOID)m_tszPassword, sizeof(m_tszPassword));
    }
}

//+----------------------------------------------------------------------------
//
// Function:  UnInit
//
// Synopsis:  Unloads DLL, clear and frees memory.
//
// Arguments: none
//
// Returns: none
//
//+----------------------------------------------------------------------------
VOID CSecurePassword::UnInit()
{
    this->UnloadCrypt32();
    this->ClearMemberVars();
    m_fIsHandleToPassword = FALSE;
    m_fIsEmptyString = FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  UnloadCrypt32
//
// Synopsis:  Unloads DLL
//
// Arguments: none
//
// Returns: none
//
//+----------------------------------------------------------------------------
VOID CSecurePassword::UnloadCrypt32()
{
    fnCryptProtectData = NULL;
    fnCryptUnprotectData = NULL;
    m_dllCrypt32.Unload();
    m_fIsLibAndFuncPtrsAvail = FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  EncodePassword
//
// Synopsis:  Encrypts data using CryptProtectData
//
// Arguments: cbPassword - size of buffer in bytes
//            pbPassword - pointer to a buffer to encrypt
//            pDataBlobPassword - pointer to an allocated DATA_BLOB structure
//
// Returns: none
//
//+----------------------------------------------------------------------------
DWORD CSecurePassword::EncodePassword(IN DWORD       cbPassword,  
                                      IN PBYTE       pbPassword, 
                                      OUT DATA_BLOB* pDataBlobPassword)
{
    DWORD dwErr = NO_ERROR;
    DATA_BLOB DataBlobIn;

    if(NULL == pDataBlobPassword)
    {
        dwErr = E_INVALIDARG;
        CMTRACE(TEXT("CSecurePassword::EncodePassword - NULL == pDataBlobPassword"));
        goto done;
    }

    if(     (0 == cbPassword)
        ||  (NULL == pbPassword))
    {
        //
        // nothing to encrypt.
        //
        dwErr = E_INVALIDARG;
        CMTRACE(TEXT("CSecurePassword::EncodePassword - E_INVALIDARG"));
        goto done;
    }


    //
    // If Crypt32.DLL is not loaded, try to loaded and get the
    // function pointers.
    //
    if (FALSE == m_fIsLibAndFuncPtrsAvail)
    {
        if (FALSE == this->LoadCrypt32AndGetFuncPtrs())
        {
            //
            // This failed, thus we can't continue. We should free memory.
            //
            this->ClearMemberVars();
            m_fIsEmptyString = TRUE;
            m_fIsHandleToPassword = FALSE;

            dwErr = ERROR_DLL_INIT_FAILED;
            CMTRACE(TEXT("CSecurePassword::EncodePassword - this-> LoadCrypt32AndGetFuncPtrs failed."));

            goto done;
        }
    }



    ZeroMemory(pDataBlobPassword, sizeof(DATA_BLOB));
    
    DataBlobIn.cbData = cbPassword;
    DataBlobIn.pbData = pbPassword;

    if (fnCryptProtectData)
    {
        LPCWSTR wszDesc[] = {TEXT("Readable description of data.")};
        LPWSTR pszDesc = NULL;

        if (OS_W2K)
        {
            //
            // The crypto API needs this, but only on Win2K
            //
            pszDesc = (LPWSTR)wszDesc;
        }

        if(!fnCryptProtectData(
                &DataBlobIn,
                (LPCWSTR)pszDesc,
                NULL,
                NULL,
                NULL,
                CRYPTPROTECT_UI_FORBIDDEN, 
                pDataBlobPassword))
        {
            dwErr = GetLastError();
            CMTRACE1(TEXT("CSecurePassword::EncodePassword - fnCryptProtectData failed. 0x%x"), dwErr);

            goto done;
        }
    }
    else
    {
        CMTRACE(TEXT("CSecurePassword::EncodePassword - ERROR_FUNCTION_NOT_CALLED"));
        dwErr = ERROR_FUNCTION_NOT_CALLED;
    }

done:

    MYDBGASSERT(NO_ERROR == dwErr);
    return dwErr;    
}

//+----------------------------------------------------------------------------
//
// Function:  DecodePassword
//
// Synopsis:  Decrypts data using CryptUnprotectData
//
// Arguments: pDataBlobPassword - pointer to a DATA_BLOB structure to be decrypted
//            cbPassword - pointer that holds the size of buffer in bytes
//            pbPassword - pointer to a buffer to encrypt
//            
//
// Returns: none
//
//+----------------------------------------------------------------------------
DWORD CSecurePassword::DecodePassword(IN  DATA_BLOB*  pDataBlobPassword, 
                                      OUT DWORD*      pcbPassword, 
                                      OUT PBYTE*      ppbPassword)
{
    DWORD dwErr = NO_ERROR;
    DATA_BLOB DataOut;
    
    if(     (NULL == pDataBlobPassword)
        ||  (NULL == pcbPassword)
        ||  (NULL == ppbPassword))
    {   
        dwErr = E_INVALIDARG;
        goto done;
    }

    *pcbPassword = 0;
    *ppbPassword = NULL;

     if(    (NULL == pDataBlobPassword->pbData)
        ||  (0 == pDataBlobPassword->cbData))
    {
        //
        // nothing to decrypt. Just return success.
        //
        goto done;
    }
    

    //
    // If Crypt32.DLL is not loaded, try to loaded and get the
    // function pointers.
    //
    if (FALSE == m_fIsLibAndFuncPtrsAvail)
    {
        if (FALSE == this->LoadCrypt32AndGetFuncPtrs())
        {
            //
            // This failed, thus we can't continue. We should free memory.
            //
            this->ClearMemberVars();
            m_fIsEmptyString = TRUE;
            m_fIsHandleToPassword = FALSE;

            dwErr = ERROR_DLL_INIT_FAILED;
            goto done;
        }
    }


    ZeroMemory(&DataOut, sizeof(DATA_BLOB));

    if (fnCryptUnprotectData)
    {
        if(!fnCryptUnprotectData(
                    pDataBlobPassword,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    CRYPTPROTECT_UI_FORBIDDEN, 
                    &DataOut))
        {
            dwErr = GetLastError();
            goto done;
        }

        dwErr = NO_ERROR;
        *pcbPassword = DataOut.cbData;
        *ppbPassword = DataOut.pbData;
    }
    else
    {
        dwErr = ERROR_FUNCTION_NOT_CALLED;
    }


done:
    MYDBGASSERT(NO_ERROR == dwErr);

    return dwErr;
}

//+----------------------------------------------------------------------------
//
// Function:  FreePassword
//
// Synopsis:  Frees data in DATA_BLOB structure
//
// Arguments: pDBPassword - pointer to a DATA_BLOB structure 
//
// Returns: none
//
//+----------------------------------------------------------------------------
VOID CSecurePassword::FreePassword(IN DATA_BLOB *pDBPassword)
{
    if(NULL == pDBPassword)
    {
        return;
    }

    if(NULL != pDBPassword->pbData)
    {
        CmSecureZeroMemory(pDBPassword->pbData, pDBPassword->cbData);
        LocalFree(pDBPassword->pbData);
    }

    //        
    // Clear sensitive data. 
    //
    CmSecureZeroMemory(pDBPassword, sizeof(DATA_BLOB));
}


//+----------------------------------------------------------------------------
//
// Function:  LoadCrypt32AndGetFuncPtrs
//
// Synopsis:  Loads crypt32.dll and gets function pointer to needed methods
//
// Arguments: none
//
// Returns: TRUE - if .DLL was loaded and function pointers were retrieved
//          FALSE - when an error was encountered
//
//+----------------------------------------------------------------------------
BOOL CSecurePassword::LoadCrypt32AndGetFuncPtrs()
{
    BOOL fRetVal = FALSE;

    if (OS_NT5)
    {
        if (FALSE == m_fIsLibAndFuncPtrsAvail)
        {
            fRetVal = m_dllCrypt32.Load(TEXT("crypt32.dll"));

            if (fRetVal)
            {
                fnCryptProtectData = (fnCryptProtectDataFunc)m_dllCrypt32.GetProcAddress("CryptProtectData");
                fnCryptUnprotectData = (fnCryptUnprotectDataFunc)m_dllCrypt32.GetProcAddress("CryptUnprotectData");

                if (fnCryptProtectData && fnCryptUnprotectData)
                {
                    CMTRACE(TEXT("CSecurePassword::LoadCrypt32AndGetFuncPtrs - success"));
                    m_fIsLibAndFuncPtrsAvail = TRUE;
                    fRetVal = TRUE;
                }
                else
                {
                    CMTRACE(TEXT("CSecurePassword::LoadCrypt32AndGetFuncPtrs - missing function pointers"));

                    this->UnloadCrypt32();
                }
            }
            else
            {
                CMTRACE(TEXT("CSecurePassword::LoadCrypt32AndGetFuncPtrs - m_dllCrypt32.Load failed"));
            }
        }
        else
        {
            fRetVal = m_fIsLibAndFuncPtrsAvail;
        }
    }

    MYDBGASSERT(fRetVal);

    return fRetVal;
}

//+----------------------------------------------------------------------------
//
// Function:  IsEmptyString
//
// Synopsis:  Used as a shortcut so we don't have to encrypt/decrypt in case 
//            we stored an empty string.
//
// Arguments: none
//
// Returns: TRUE - if instance is suppose to be holding an empty string
//          FALSE - if currenttly saved string is not empty
//
//+----------------------------------------------------------------------------
BOOL CSecurePassword::IsEmptyString()
{
    return m_fIsEmptyString;
}

//+----------------------------------------------------------------------------
//
// Function:  IsHandleToPassword
//
// Synopsis:  Used as a shortcut so we don't have to encrypt/decrypt in case 
//            we stored a handle to a RAS password (16 *).
//
// Arguments: none
//
// Returns: TRUE - if instance is suppose to be holding ****************
//          FALSE - if currenttly saved string is a normal password
//
//+----------------------------------------------------------------------------
BOOL CSecurePassword::IsHandleToPassword()
{
    return m_fIsHandleToPassword;
}


//+----------------------------------------------------------------------------
//
// Function:  SetMaxDataLenToProtect
//
// Synopsis:  Set the maximum length password to protect. This value will be
//            checked when encrypting a password. 
//
// Arguments: dwMaxDataLen - maximum password length in characters
//
// Returns:   Nothing
//
//+----------------------------------------------------------------------------
VOID CSecurePassword::SetMaxDataLenToProtect(DWORD dwMaxDataLen)
{
    m_dwMaxDataLen = dwMaxDataLen;
}

//+----------------------------------------------------------------------------
//
// Function:  GetMaxDataLenToProtect
//
// Synopsis:  Get the maximum length password that this class can protect. 
//
// Arguments: none
//
// Returns:   DWORD - maximum password length
//
//+----------------------------------------------------------------------------
DWORD CSecurePassword::GetMaxDataLenToProtect()
{
    return m_dwMaxDataLen;
}


#endif // _ICM_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\needsmig.cpp ===
//+----------------------------------------------------------------------------
//
// File:     needsmig.cpp
//
// Module:   CMCFG32.DLL AND CMSTP.EXE
//
// Synopsis: Implementation of the ProfileNeedsMigration function.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
// Function:  ProfileNeedsMigration
//
// Synopsis:  This function determines if we need to migrate a profile or not.
//            Profiles that have the current Profile version format or greater
//            are not migrated.  Profiles that have an older version format that
//            have already been migrated (we look to see if the GUID is missing on
//            NT5 or if the Delete Entry exists on Down Level) don't need to
//            be migrated.
//
// Arguments: LPCTSTR pszPathToCmp - full path to the CMP file
//
// Returns:   BOOL - TRUE if the profile should be migrated or not
//
// History:   quintinb Created    11/20/98
//
//+----------------------------------------------------------------------------
BOOL ProfileNeedsMigration(LPCTSTR pszServiceName, LPCTSTR pszPathToCmp)
{
	//
	//	Open the CMP and check the version number.  If the profile format version
	//  is old then we need to migrate it.  
	//

	if ((NULL == pszServiceName) || (NULL == pszPathToCmp) || 
		(TEXT('\0') == pszServiceName[0]) || (TEXT('\0') == pszPathToCmp[0]))
	{
		return FALSE;
	}

	CPlatform plat;
	CFileNameParts FileParts(pszPathToCmp);

	int iCurrentCmpVersion = GetPrivateProfileInt(c_pszCmSectionProfileFormat, c_pszVersion, 
		0, pszPathToCmp);
	
	if (PROFILEVERSION > iCurrentCmpVersion)
	{
		//
		//  Now construct the path to the INF file (1.0 and 1.1 profiles kept the infs in 
		//  the system dir)
		//
		TCHAR szTemp[MAX_PATH+1];
		TCHAR szInfFile[MAX_PATH+1];
		TCHAR szGUID[MAX_PATH+1];
		HKEY hKey;

		MYVERIFY(0 != GetSystemDirectory(szTemp, MAX_PATH));

		MYVERIFY(CELEMS(szInfFile) > (UINT)wsprintf(szInfFile, TEXT("%s\\%s%s"), szTemp, 
			FileParts.m_FileName, TEXT(".inf")));

		if (!FileExists(szInfFile))
		{
			return FALSE;
		}

		//
		//  Get the GUID from the inf file.
		//
		ZeroMemory(szGUID, sizeof(szGUID));
		MYVERIFY(0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszDesktopGuid, TEXT(""), szGUID, 
			MAX_PATH, szInfFile));

		if (0 != szGUID[0])
		{
			MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, 
				TEXT("CLSID\\%s"), szGUID));

			if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szTemp, 0, 
				KEY_READ, &hKey))
			{
				//
				//	If this is NT5, then we need to migrate.  On Legacy we need to try to
				//  open the delete subkey.
				//
				RegCloseKey(hKey);
				if (plat.IsAtLeastNT5())
				{
					return TRUE;
				}
				else
				{
					MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, 
						TEXT("CLSID\\%s\\Shell\\Delete"), szGUID));
				
					if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szTemp, 0, 
						KEY_READ, &hKey))
					{
						//
						//	Already been migrated
						//
						RegCloseKey(hKey);
						return FALSE;
					}
					else
					{
						//
						//	Must Migrate the profile.
						//
						return TRUE;
					}
				}			
			}
			else
			{
				return FALSE;
			}
		}
		else
		{
			//
			//	This affects MSN, as long as we have true here their 1.0 stuff will
			//  get migrated.  If we don't want it to, change this.
			//
			return TRUE;
		}
	}
	else
	{
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\raslink.cpp ===
//+----------------------------------------------------------------------------
//
// File:     raslink.cpp
//
// Module:   CMDIAL32.DLL AND CMUTOA.DLL
//
// Synopsis: Declaration of the function name lists that are used for RAS
//           linkage.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------

// The RAS linkage system in CM is somewhat complicated.  Unfortunately, RAS is different
// on pretty much every version of the OS we have ever shipped.  There are APIs on the NT
// family that don't exist on the Win9x side and vice versa.  In order for CM to dynamically
// allocate the correct functions without too much work, we have created the following
// arrays of function names used by LinkToRas.  To further complicate matters, we have
// the ANSI versus Unicode problem.  Thus you will notice that we have three sets of
// function lists.  The c_ArrayOfRasFuncsA is actually used by Cmutoa.dll to load the
// real ANSI RAS functions that it calls after converting the parameters from Unicode to
// ANSI in its UA functions, which is why we have the c_ArrayOfRasFuncsUA list.  These
// functions are the wrappers exported by cmutoa.dll that cmdial32.dll links to on Win9x
// instead of the W APIs located in c_ArrayOfRasFuncsW that it uses on NT.  Please look
// at LinkToRas in cmdial\ras.cpp and InitCmRasUtoA in uapi\cmutoa.cpp.  If you change
// anything here you will probably have to change the structs in raslink.h and probably
// even the code in the two functions above.  Changer Beware!

#ifdef _CMUTOA_MODULE
    static LPCSTR c_ArrayOfRasFuncsA[] = {    "RasDeleteEntryA",
                                                "RasGetEntryPropertiesA",
                                                "RasSetEntryPropertiesA",
                                                "RasGetEntryDialParamsA",
                                                "RasSetEntryDialParamsA",
                                                "RasEnumDevicesA",
                                                "RasDialA",
                                                "RasHangUpA",
                                                "RasGetErrorStringA",
                                                "RasGetConnectStatusA",
                                                "RasGetProjectionInfoA",
                                                "RasSetSubEntryPropertiesA",
                                                "RasDeleteSubEntryA",
                                                NULL, //"RasSetCustomAuthDataA",
                                                NULL, //"RasGetEapUserIdentityA",
                                                NULL, //"RasFreeEapUserIdentityA",
                                                NULL, //"RasInvokeEapUI",
                                                NULL, //"RasGetCredentials",
                                                NULL, //"RasSetCredentials",
                                                NULL, //"GetCustomAuthData",
                                                NULL
    };

#else
    static LPCSTR c_ArrayOfRasFuncsUA[] = {   "RasDeleteEntryUA",
                                                "RasGetEntryPropertiesUA",
                                                "RasSetEntryPropertiesUA",
                                                "RasGetEntryDialParamsUA",
                                                "RasSetEntryDialParamsUA",
                                                "RasEnumDevicesUA",
                                                "RasDialUA",
                                                "RasHangUpUA",
                                                "RasGetErrorStringUA",
                                                "RasGetConnectStatusUA",
                                                "RasGetProjectionInfoUA",
                                                "RasSetSubEntryPropertiesUA",  
                                                "RasDeleteSubEntryUA",
                                                NULL, //"RasSetCustomAuthDataUA",
                                                NULL, //"RasGetEapUserIdentityUA",
                                                NULL, //"RasFreeEapUserIdentityUA",
                                                NULL, //"RasInvokeEapUI",
                                                NULL, //"RasGetCredentials",
                                                NULL, //"RasSetCredentials",
                                                NULL, //"GetCustomAuthData",
                                                NULL
    };

    static LPCSTR c_ArrayOfRasFuncsW[] = {    "RasDeleteEntryW",
                                                "RasGetEntryPropertiesW",
                                                "RasSetEntryPropertiesW",
                                                "RasGetEntryDialParamsW",
                                                "RasSetEntryDialParamsW",
                                                "RasEnumDevicesW",
                                                "RasDialW",
                                                "RasHangUpW",
                                                "RasGetErrorStringW",
                                                "RasGetConnectStatusW",
                                                "RasGetProjectionInfoW",
                                                "RasSetSubEntryPropertiesW",  
                                                "RasDeleteSubEntryW",
                                                "RasSetCustomAuthDataW",
                                                "RasGetEapUserIdentityW",
                                                "RasFreeEapUserIdentityW",
                                                "RasInvokeEapUI",
                                                "RasGetCredentialsW",
                                                "RasSetCredentialsW",
                                                "RasGetCustomAuthDataW",
                                                NULL
    };
#endif

// Regarding DwDeleteSubEntry and RasDeleteSubEntry - NT5 shipped first
// with DwDeleteSubEntry, a private API.  Millennium shipped next, by
// which time it looked like this was going to have to be made public,
// so it was prefixed with Ras.  NT5.1 made the corresponding name change
// on the NT side, which we handle within LinkToRas (along with all other such
// cases).
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\shelldll.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ShellDll.cpp
//
// Module:   Common Code
//
// Synopsis: Implements the class CShellDll, a shell32.dll wrapper.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   fengsun    Created    01/12/98
//
//+----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
// Function:  CShellDll::CShellDll
//
// Synopsis:  Constructor
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
CShellDll::CShellDll(BOOL fKeepDllLoaded)
{
    m_hInstShell = NULL;
    m_fnShellExecuteEx = NULL;
    m_fnShell_NotifyIcon = NULL;
    m_pfnSHGetSpecialFolderLocation = NULL;
    m_pfnSHGetPathFromIDList = NULL;
    m_pfnSHGetMalloc = NULL;   
    m_KeepDllLoaded = fKeepDllLoaded;
}

//+----------------------------------------------------------------------------
//
// Function:  CShellDll::~CShellDl
//
// Synopsis:  Destructor
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
CShellDll::~CShellDll()
{
    Unload();
}


//+----------------------------------------------------------------------------
//
// Function:  CShellDll::Load
//
// Synopsis:  Load shell32.dll
//            It works even if the dll is already loaded, but we do not keep a referrence
//            count here, any unload call will unload the dll
//
// Arguments: None
//
// Returns:   BOOL - Whether the dll is successfully loaded
//
// History:   fengsun Created Header    1/12/98
//
//+----------------------------------------------------------------------------
BOOL CShellDll::Load()
{
    //
    // Simply return, if already loaded
    //
    LPSTR pszShellExecuteEx;
    LPSTR pszShellNotifyIcon;
    LPSTR pszSHGetPathFromIDList;
    LPSTR pszSHGetSpecialFolderLocation;
    LPSTR pszSHGetMalloc;

    if (m_hInstShell == NULL)
    {
        if (OS_NT)
        {
            m_hInstShell = LoadLibraryExA("Shell32.dll", NULL, 0);
            pszShellExecuteEx = "ShellExecuteExW";
            pszShellNotifyIcon = "Shell_NotifyIconW";
            pszSHGetPathFromIDList = "SHGetPathFromIDListW";
            pszSHGetSpecialFolderLocation = "SHGetSpecialFolderLocation"; // no A or W version
            pszSHGetMalloc = "SHGetMalloc"; // no A or W version
        }
        else
        {
            m_hInstShell = LoadLibraryExA("cmutoa.dll", NULL, 0);
            pszShellExecuteEx = "ShellExecuteExUA";
            pszShellNotifyIcon = "Shell_NotifyIconUA"; 
            pszSHGetPathFromIDList = "SHGetPathFromIDListUA";
            pszSHGetSpecialFolderLocation = "SHGetSpecialFolderLocationUA"; // no actual A or W version
            pszSHGetMalloc = "SHGetMallocUA";                               // but this class only 
                                                                            // allows one dll       
        }

        if (m_hInstShell == NULL)
        {
            return FALSE;
        }

        m_pfnSHGetMalloc = (SHGetMallocSpec)GetProcAddress(m_hInstShell, pszSHGetMalloc);
        m_pfnSHGetSpecialFolderLocation = (SHGetSpecialFolderLocationSpec)GetProcAddress(m_hInstShell, pszSHGetSpecialFolderLocation);
        m_pfnSHGetPathFromIDList = (SHGetPathFromIDListSpec)GetProcAddress(m_hInstShell, pszSHGetPathFromIDList);
        m_fnShellExecuteEx = (SHELLEXECUTEEXPROC)GetProcAddress(m_hInstShell, pszShellExecuteEx);
        m_fnShell_NotifyIcon = (SHELL_NOTIFYICONPROC)GetProcAddress(m_hInstShell, pszShellNotifyIcon);

        if (NULL == m_fnShellExecuteEx || NULL == m_fnShell_NotifyIcon || 
            NULL == m_pfnSHGetSpecialFolderLocation || NULL == m_pfnSHGetPathFromIDList ||
            NULL == m_pfnSHGetMalloc)
        {
            FreeLibrary(m_hInstShell);
            m_hInstShell = NULL;
            return FALSE;
        }
    }

    return TRUE;
}



//+----------------------------------------------------------------------------
//
// Function:  CShellDll::Unload
//
// Synopsis:  Unload the shell32.dll
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    1/12/98
//
//+----------------------------------------------------------------------------
void CShellDll::Unload()
{
    if (m_hInstShell == NULL)
    {
        return;
    }
   
    //
    // Don't release library because of shell bug #289463 + #371836
    // ShellExecute fires a thread which wakes up after the release 
    // of the library and crashes us. Ugly but real, we have no choice 
    // but to stay linked to the Shell DLL.
    //

    if (!m_KeepDllLoaded)
    {
        FreeLibrary(m_hInstShell);
        m_hInstShell = NULL;
    }
}



//+----------------------------------------------------------------------------
//
// Function:  CShellDll::ShellGetSpecialFolderLocation
//
// Synopsis:  Wrapper function for SHGetSpecialFolderLocation.  Please note the
//            returned pidl must be freed with the Shell's Malloc pointer (use SHGetMalloc).
//
// Arguments: Please see the api definition for SHGetSpecialFolderLocation
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created    5/21/99
//
//+----------------------------------------------------------------------------
HRESULT CShellDll::ShellGetSpecialFolderLocation(HWND hwnd, int csidl, LPITEMIDLIST *ppidl)
{
    if (!Load())
    {
        return E_FAIL;
    }

    return m_pfnSHGetSpecialFolderLocation(hwnd, csidl, ppidl);
}

//+----------------------------------------------------------------------------
//
// Function:  CShellDll::ShellGetPathFromIDList
//
// Synopsis:  Wrapper function for SHGetPathFromIDList.
//
// Arguments: Please see the api definition for SHGetPathFromIDList
//
// Returns:   BOOL - TRUE on success
//
// History:   quintinb Created    5/21/99
//
//+----------------------------------------------------------------------------
BOOL CShellDll::ShellGetPathFromIDList(LPCITEMIDLIST pidl, LPTSTR pszPath)
{
    if (!Load())
    {
        return FALSE;
    }

    return m_pfnSHGetPathFromIDList(pidl, pszPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CShellDll::ShellGetMalloc
//
// Synopsis:  Wrapper function for SHGetMalloc.
//
// Arguments: Please see the api definition for SHGetMalloc
//
// Returns:   HRESULT - Standard COM Error Codes
//
// History:   quintinb Created    5/21/99
//
//+----------------------------------------------------------------------------
HRESULT CShellDll::ShellGetMalloc(LPMALLOC * ppMalloc)
{
    if (!Load())
    {
        return E_FAIL;
    }

    return m_pfnSHGetMalloc(ppMalloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\base_str.h ===
//+----------------------------------------------------------------------------
//
// File:     base_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for basic string constants used throughout such as 
//               "Connection Manager"
//           
// NOTE:     This header should be kept as lightweight as possible because it 
//           is included some very lightweight classes. Its purpose is to 
//           eliminate excessive repetition of key identifiers such 
//           as "Connection Manager"
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball   Created         10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_BASE_STR
#define _CM_BASE_STR

//
// c_pszCmSection defines the application section in the .CMS file.
//

const TCHAR* const c_pszCmSection   = TEXT("Connection Manager");
const TCHAR* const c_pszVersion     = TEXT("Version");
const TCHAR* const c_pszPbk         = TEXT("PBK");

#endif // _CM_BASE_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\ver.cpp ===
//+----------------------------------------------------------------------------
// defines
//+----------------------------------------------------------------------------
#define WIN95_OSR2_BUILD_NUMBER             1111
#define LOADSTRING_BUFSIZE                  24
#define FAREAST_WIN95_LOADSTRING_BUFSIZE    512

//
// platform ID for WINDOWS98
//
#define VER_PLATFORM_WIN32_WINDOWS98    100 

//
// platform ID for WINDOWS Millennium
//
#define VER_PLATFORM_WIN32_MILLENNIUM   200 



//+----------------------------------------------------------------------------
//
//  Function    GetOSVersion
//
//  Synopsis    returns the OS version(platform ID)
//
//  Arguments   NONE
//
// Returns:     DWORD - VER_PLATFORM_WIN32_WINDOWS or
//                      VER_PLATFORM_WIN32_WINDOWS98 or
//                      VER_PLATFORM_WIN32_NT
//
// History:   Created Header    2/13/98
//
//+----------------------------------------------------------------------------

DWORD WINAPI GetOSVersion()
{
    static dwPlatformID = 0;

    //
    // If this function is called before, reture the saved value
    //
    if (dwPlatformID != 0)
    {
        return dwPlatformID;
    }

    OSVERSIONINFO oviVersion;

    ZeroMemory(&oviVersion,sizeof(oviVersion));
    oviVersion.dwOSVersionInfoSize = sizeof(oviVersion);
    GetVersionEx(&oviVersion);

    if (oviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
        //
        //  If this is Win95 then leave it as VER_PLATFORM_WIN32_WINDOWS, however if this
        //  is Millennium, Win98 SE, or Win98 Gold we want to modify the returned value
        //  as follows:  VER_PLATFORM_WIN32_MILLENNIUM -> Millennium
        //               VER_PLATFORM_WIN32_WINDOWS98 -> Win98 SE and Win98 Gold
        //
        if (oviVersion.dwMajorVersion == 4)
        {
            if (LOWORD(oviVersion.dwBuildNumber) > 2222)
            {
                //
                //  Millennium
                //
                oviVersion.dwPlatformId = VER_PLATFORM_WIN32_MILLENNIUM;
            }
            else if (LOWORD(oviVersion.dwBuildNumber) >= 1998)
            {
                //
                // Win98 Gold and Win98 SE
                //

                oviVersion.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS98; 
            }
        }
    }

    dwPlatformID = oviVersion.dwPlatformId;
    return(dwPlatformID);
}



//+----------------------------------------------------------------------------
//
//  Function    GetOSBuildNumber
//
//  Synopsis    Get the build number of Operating system
//
//  Arguments   None
//
//  Returns     Build Number of OS
//
//  History     3/5/97      VetriV      Created
//
//-----------------------------------------------------------------------------
DWORD WINAPI GetOSBuildNumber()
{
    static dwBuildNumber = 0;
    OSVERSIONINFO oviVersion;

    if (0 != dwBuildNumber)
    {
        return dwBuildNumber;
    }

    ZeroMemory(&oviVersion,sizeof(oviVersion));
    oviVersion.dwOSVersionInfoSize = sizeof(oviVersion);
    GetVersionEx(&oviVersion);
    dwBuildNumber = oviVersion.dwBuildNumber;
    return dwBuildNumber;
}


//+----------------------------------------------------------------------------
//
//  Function    GetOSMajorVersion
//
//  Synopsis    Get the Major version number of Operating system
//
//  Arguments   None
//
//  Returns     Major version Number of OS
//
//  History     2/19/98     VetriV      Created
//
//-----------------------------------------------------------------------------
DWORD WINAPI GetOSMajorVersion(void)
{
    static dwMajorVersion = 0;
    OSVERSIONINFO oviVersion;

    if (0 != dwMajorVersion)
    {
        return dwMajorVersion;
    }

    ZeroMemory(&oviVersion,sizeof(oviVersion));
    oviVersion.dwOSVersionInfoSize = sizeof(oviVersion);
    GetVersionEx(&oviVersion);
    dwMajorVersion = oviVersion.dwMajorVersion;
    return dwMajorVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\source\parseca.cpp ===
//
//  Profwiz.cpp doesn't use cmutoa but does include this function.  Thus we want the W versions instead of the
//  U versions for profwiz.
//
#ifndef _CMUTOA
#define CharNextU CharNextW
#define CharPrevU CharPrevW
#define lstrlenU lstrlenW
#define lstrcpyU lstrcpyW
#define lstrcpynU lstrcpynW
#endif

/*
//+----------------------------------------------------------------------------
//
// Function:  HrParseCustomActionString
//
// Synopsis:  This function takes a custom action string retrieved from a 
//            cms file and parses it into the various parts of a custom
//            action (program, parameters, function name)
//
// Arguments: LPTSTR pszStringToParse - custom action buffer to be parsed into
//                                      the various parts of a custom action
//            LPTSTR pszProgram - output buffer to hold the program string
//            LPTSTR pszParameters - output buffer to hold the parameters string
//            LPTSTR pszFunctionName - output buffer to hold the function name, if any
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT HrParseCustomActionString(LPTSTR pszStringToParse, LPTSTR pszProgram, LPTSTR pszParameters, LPTSTR pszFunctionName)
{
    if ((NULL == pszStringToParse) || (TEXT('\0') == pszStringToParse[0]) || (NULL == pszProgram) || 
        (NULL == pszParameters) || (NULL == pszFunctionName))
    {
        return E_INVALIDARG;
    }

    //
    //  Make sure the strings are blank in case we don't touch them (szFunctionName and szParameters especially)
    //
    pszProgram[0] = TEXT('\0');
    pszParameters[0] = TEXT('\0');
    pszFunctionName[0] = TEXT('\0');

    //
    // Here are the cases we need to handle:
    // 1) +longfilename+
    // 2) +longfilename+ params
    // 3) +longfilename+,dllfuncname
    // 4) +longfilename+,dllfuncname params
    // 5) filename
    // 6) filename params
    // 7) filename,dllfuncname
    // 8) filename,dllfuncname params

    //
    //  Walk the string to find the seperator chars
    //
    LPTSTR pszCurrent = pszStringToParse;
    LPTSTR pszFirstPlus = NULL;
    LPTSTR pszSecondPlus = NULL;
    LPTSTR pszFirstSpace = NULL;
    LPTSTR pszFirstComma = NULL;

    while (pszCurrent && (TEXT('\0') != *pszCurrent))
    {
        if ((TEXT('+') == *pszCurrent) && (NULL == pszFirstComma) && (NULL == pszFirstSpace))
        {
            //
            //  Keep track of the plus signs, unless we have already seen a space
            //  or a comma.  In which case these chars are in the parameters and
            //  meaningless to us.
            //
            if (NULL == pszFirstPlus)
            {
                pszFirstPlus = pszCurrent;
            }
            else if (NULL == pszSecondPlus)
            {
                pszSecondPlus = pszCurrent;
            }
        }
        else if ((TEXT(',') == *pszCurrent) && (NULL == pszFirstSpace))
        {
            //
            //  If we have already seen a space, then the comma is part of
            //  the parameters and meaningless to us.
            //
            pszFirstComma = pszCurrent;

        }
        else if ((TEXT(' ') == *pszCurrent))
        {
            if ((NULL == pszFirstPlus) && (NULL == pszFirstSpace))
            {
                //
                //  Then we have no plus signs and no previous space, save the space as
                //  it is the start of the parameters.
                //
                pszFirstSpace = pszCurrent;
            }
            else if (pszFirstPlus && pszSecondPlus && (NULL == pszFirstSpace))
            {
                //
                //  Then we have both plus signs but no space yet, grab it
                //  because this is the start of the parameters
                //
                pszFirstSpace = pszCurrent;
            }
        }
        pszCurrent = CharNextU(pszCurrent);

    }

    //
    //  From the markers we have, figure out the beginning and end of the program string
    //
    
    LPTSTR pszStartOfProgram = NULL;
    LPTSTR pszEndOfProgram = NULL;

    if (pszFirstPlus)
    {
        if (pszSecondPlus)
        {
            pszStartOfProgram = CharNextU(pszFirstPlus);
            pszEndOfProgram = CharPrevU(pszStringToParse, pszSecondPlus);
        }
        else
        {
            //
            //  We have a string with the first char as a plus sign but no second +.
            //  The format isn't correct.
            //
            CMASSERTMSG(FALSE, TEXT("CustomActionList::ParseCustomActionString - Incorrect format in the passed in string to parse, missing + sign."));
            return E_UNEXPECTED;
        }
    }
    else
    {
        pszStartOfProgram = pszStringToParse;

        if (pszFirstComma)
        {
            pszEndOfProgram = CharPrevU(pszStringToParse, pszFirstComma);
        }
        else if (pszFirstSpace)
        {
            pszEndOfProgram = CharPrevU(pszStringToParse, pszFirstSpace);
        }
        else
        {
            //
            //  Nothing in the string but the program
            //
            pszEndOfProgram = pszStringToParse + lstrlenU(pszStringToParse) - 1;
        }
    }

    //
    //  Now copy out the necessary parts
    //
 
    int iSize = (int)(pszEndOfProgram - pszStartOfProgram + 2);

    lstrcpynU(pszProgram, pszStartOfProgram, iSize);

    if (pszFirstComma)
    {
        if (pszFirstSpace)
        {
            iSize = (int)(pszFirstSpace - pszFirstComma);
            lstrcpynU(pszFunctionName, CharNextU(pszFirstComma), iSize);
        }
        else
        {
            lstrcpyU(pszFunctionName, CharNextU(pszFirstComma));
        }
    }
    
    if (pszFirstSpace)
    {
        lstrcpyU(pszParameters, CharNextU(pszFirstSpace));
    }

    return S_OK;
}
*/

//+----------------------------------------------------------------------------
//
// Function:  HrParseCustomActionString
//
// Synopsis:  This function takes a custom action string retrieved from a 
//            cms file and parses it into the various parts of a custom
//            action (program, parameters, function name)
//
// Arguments: LPTSTR pszStringToParse - custom action buffer to be parsed into
//                                      the various parts of a custom action
//            LPTSTR pszProgram - output buffer to hold the program string
//            LPTSTR pszParameters - output buffer to hold the parameters string
//            LPTSTR pszFunctionName - output buffer to hold the function name, if any
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT HrParseCustomActionString(LPTSTR pszStringToParse, LPTSTR* ppszProgram, LPTSTR* ppszParameters, LPTSTR* ppszFunctionName)
{
    if ((NULL == pszStringToParse) || (TEXT('\0') == pszStringToParse[0]) || (NULL == ppszProgram) || 
        (NULL == ppszParameters) || (NULL == ppszFunctionName))
    {
        return E_INVALIDARG;
    }

    //
    //  NULL out the string pointers to start with
    //
    *ppszProgram = NULL;
    *ppszParameters = NULL;
    *ppszFunctionName = NULL;

    //
    // Here are the cases we need to handle:
    // 1) +longfilename+
    // 2) +longfilename+ params
    // 3) +longfilename+,dllfuncname
    // 4) +longfilename+,dllfuncname params
    // 5) filename
    // 6) filename params
    // 7) filename,dllfuncname
    // 8) filename,dllfuncname params

    //
    //  Walk the string to find the seperator chars
    //
    LPTSTR pszCurrent = pszStringToParse;
    LPTSTR pszFirstPlus = NULL;
    LPTSTR pszSecondPlus = NULL;
    LPTSTR pszFirstSpace = NULL;
    LPTSTR pszFirstComma = NULL;

    while (pszCurrent && (TEXT('\0') != *pszCurrent))
    {
        if ((TEXT('+') == *pszCurrent) && (NULL == pszFirstComma) && (NULL == pszFirstSpace))
        {
            //
            //  Keep track of the plus signs, unless we have already seen a space
            //  or a comma.  In which case these chars are in the parameters and
            //  meaningless to us.
            //
            if (NULL == pszFirstPlus)
            {
                pszFirstPlus = pszCurrent;
            }
            else if (NULL == pszSecondPlus)
            {
                pszSecondPlus = pszCurrent;
            }
        }
        else if ((TEXT(',') == *pszCurrent) && (NULL == pszFirstSpace))
        {
            //
            //  If we have already seen a space, then the comma is part of
            //  the parameters and meaningless to us.
            //
            pszFirstComma = pszCurrent;

        }
        else if ((TEXT(' ') == *pszCurrent))
        {
            if ((NULL == pszFirstPlus) && (NULL == pszFirstSpace))
            {
                //
                //  Then we have no plus signs and no previous space, save the space as
                //  it is the start of the parameters.
                //
                pszFirstSpace = pszCurrent;
            }
            else if (pszFirstPlus && pszSecondPlus && (NULL == pszFirstSpace))
            {
                //
                //  Then we have both plus signs but no space yet, grab it
                //  because this is the start of the parameters
                //
                pszFirstSpace = pszCurrent;
            }
        }
        pszCurrent = CharNextU(pszCurrent);

    }

    //
    //  From the markers we have, figure out the beginning and end of the program string
    //
    
    LPTSTR pszStartOfProgram = NULL;
    LPTSTR pszEndOfProgram = NULL;

    if (pszFirstPlus)
    {
        if (pszSecondPlus)
        {
            pszStartOfProgram = CharNextU(pszFirstPlus);
            pszEndOfProgram = CharPrevU(pszStringToParse, pszSecondPlus);
        }
        else
        {
            //
            //  We have a string with the first char as a plus sign but no second +.
            //  The format isn't correct.
            //
            CMASSERTMSG(FALSE, TEXT("CustomActionList::ParseCustomActionString - Incorrect format in the passed in string to parse, missing + sign."));
            return E_UNEXPECTED;
        }
    }
    else
    {
        pszStartOfProgram = pszStringToParse;

        if (pszFirstComma)
        {
            pszEndOfProgram = CharPrevU(pszStringToParse, pszFirstComma);
        }
        else if (pszFirstSpace)
        {
            pszEndOfProgram = CharPrevU(pszStringToParse, pszFirstSpace);
        }
        else
        {
            //
            //  Nothing in the string but the program
            //
            pszEndOfProgram = pszStringToParse + lstrlenU(pszStringToParse) - 1;
        }
    }

    //
    //  Now copy out the necessary parts
    //
    HRESULT hr = E_OUTOFMEMORY; 
    int iSize = (int)(pszEndOfProgram - pszStartOfProgram + 2);

    *ppszProgram = (LPTSTR)CmMalloc(sizeof(TCHAR)*iSize);

    if (*ppszProgram)
    {
        lstrcpynU(*ppszProgram, pszStartOfProgram, iSize);

        if (pszFirstComma)
        {
            if (pszFirstSpace)
            {
                iSize = (int)(pszFirstSpace - pszFirstComma);
                *ppszFunctionName = (LPTSTR)CmMalloc(sizeof(TCHAR)*iSize);

                if (*ppszFunctionName)
                {
                    lstrcpynU(*ppszFunctionName, CharNextU(pszFirstComma), iSize);
                }
                else
                {
                    goto exit;
                }
            }
            else
            {
                iSize = lstrlen(CharNextU(pszFirstComma)) + 1;
                *ppszFunctionName = (LPTSTR)CmMalloc(sizeof(TCHAR)*iSize);

                if (*ppszFunctionName)
                {
                    lstrcpyU(*ppszFunctionName, CharNextU(pszFirstComma));
                }
                else
                {
                    goto exit;
                }
            }
        }
        else
        {
            *ppszFunctionName = CmStrCpyAlloc(TEXT(""));
        }
    
        if (pszFirstSpace)
        {
            iSize = lstrlen(CharNextU(pszFirstSpace)) + 1;
            *ppszParameters = (LPTSTR)CmMalloc(sizeof(TCHAR)*iSize);

            if (*ppszParameters)
            {
                lstrcpyU(*ppszParameters, CharNextU(pszFirstSpace));
            }
            else
            {
                goto exit;
            }
        }
        else
        {
            *ppszParameters = CmStrCpyAlloc(TEXT(""));
        }

        if (*ppszParameters && *ppszFunctionName && *ppszProgram)
        {
            hr = S_OK;
        }
    }
    else
    {
        goto exit;
    }

exit:
    MYDBGASSERT(SUCCEEDED(hr));

    if (FAILED(hr))
    {
        CMTRACE1(TEXT("HrParseCustomActionString failed, hr = 0x%x"), hr);
        CmFree(*ppszFunctionName);
        CmFree(*ppszProgram);
        CmFree(*ppszParameters);
        *ppszProgram = NULL;
        *ppszParameters = NULL;
        *ppszFunctionName = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\cmakreg.h ===
//+----------------------------------------------------------------------------
//
// File:     cmakreg.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMAK related Registry keys and values.
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/19/99
//
//+----------------------------------------------------------------------------

const TCHAR* const c_pszRegCmak             = TEXT("Software\\Microsoft\\Connection Manager Administration Kit");
const TCHAR* const c_pszCmakAppPath         = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMAK.EXE");
const TCHAR* const c_pszRegOutput           = TEXT("Output");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\mgr_str.h ===
//+----------------------------------------------------------------------------
//
// File:     mgr_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS flags, optimized for CMMGR32.EXE
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_MGR_STR
#define _CM_MGR_STR

const TCHAR* const c_pszCmEntryCmsFile      = TEXT("CMSFile");
const TCHAR* const c_pszCmEntryServiceName  = TEXT("ServiceName");

#endif // _CM_MGR_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\dl_str.h ===
//+----------------------------------------------------------------------------
//
// File:     dl_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS and .CMP flags.  Contents of this header 
//           should be optimized for CMDL usage.
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_DL_STR
#define _CM_DL_STR

const TCHAR* const c_pszCmEntryBigIcon   = TEXT("Icon");
const TCHAR* const c_pszCmEntrySmallIcon = TEXT("SmallIcon");

#endif // _CM_DL_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\conact_str.h ===
//+----------------------------------------------------------------------------
//
// File:     conact_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS and .CMP flags.  Contents of this header 
//           should be limited to shared Connect Action flags.
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/15/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_CONACT_STR
#define _CM_CONACT_STR

const TCHAR* const c_pszCmSectionPreConnect     = TEXT("Pre-Connect Actions"); 
const TCHAR* const c_pszCmSectionOnConnect      = TEXT("Connect Actions");
const TCHAR* const c_pszCmSectionOnDisconnect   = TEXT("Disconnect Actions"); 
const TCHAR* const c_pszCmSectionPreTunnel      = TEXT("Pre-Tunnel Actions"); 
const TCHAR* const c_pszCmSectionPreDial        = TEXT("Pre-Dial Actions");
const TCHAR* const c_pszCmSectionOnCancel       = TEXT("On-Cancel Actions");
const TCHAR* const c_pszCmSectionOnError        = TEXT("On-Error Actions");
const TCHAR* const c_pszCmSectionCustom         = TEXT("CustomButton Actions");
const TCHAR* const c_pszCmSectionPreInit         = TEXT("Pre-Init Actions");
const TCHAR* const c_pszCmSectionOnIntConnect   = TEXT("Auto Applications");

const TCHAR* const c_pszCmEntryConactFlags      = TEXT("%u&Flags");       
const TCHAR* const c_pszCmEntryConactDesc       = TEXT("%u&Description"); 

#endif // _CM_CONACT_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\inf_str.h ===
//+----------------------------------------------------------------------------
//
// File:     inf_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file INF flags used by CM and CMAK
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------
#ifndef _CM_INF_STR
#define _CM_INF_STR

const TCHAR* const c_pszDesktopGuid         = TEXT("DesktopGUID");
const TCHAR* const c_pszInfSectionStrings   = TEXT("Strings");
const TCHAR* const c_pszShortSvcName        = TEXT("ShortSvcName"); 
const TCHAR* const c_pszCmakStatus          = TEXT("CMAK Status");

#endif // _CM_INF_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\log_str.h ===
//+----------------------------------------------------------------------------
//
// File:     log_str.h
//
// Module:   Strings for logging modules to utilize
//
// Synopsis: Header file containing common strings optimized for cmlog.
//			 
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   sumitc         Created       25/07/2000
//
//+----------------------------------------------------------------------------

#ifndef _CM_LOG_STR
#define _CM_LOG_STR

const TCHAR* const c_pszCmEntryEnableLogging    = TEXT("EnableLogging");
const TCHAR* const c_pszCmSectionLogging        = TEXT("Logging");
const TCHAR* const c_pszCmEntryMaxLogFileSize   = TEXT("MaxFileSize");
const TCHAR* const c_pszCmEntryLogFileDirectory = TEXT("FileDirectory");

#endif // _CM_LOG_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\mon_str.h ===
//+----------------------------------------------------------------------------
//
// File:     mon_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS flags, optimized for use by CMMON32.EXE
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_MON_STR
#define _CM_MON_STR

const TCHAR* const c_pszCmEntryHelpFile         = TEXT("HelpFile");
const TCHAR* const c_pszCmSectionMenuOptions    = TEXT("Menu Options");
const TCHAR* const c_pszCmEntryIdleTimeout      = TEXT("IdleTimeout");
const TCHAR* const c_pszCmEntryAutoReconnect     = TEXT("AutoReconnect");
const TCHAR* const c_pszCmEntryTrayIcon         = TEXT("TrayIcon");
const TCHAR* const c_pszDefaultHelpFile         = TEXT("cmmgr32.hlp");

#endif // _CM_MON_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\pbk_str.h ===
//+----------------------------------------------------------------------------
//
// File:     pbk_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS flags, optimized for use by CMPBK32.DLL
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_PBK_STR
#define _CM_PBK_STR

const TCHAR* const c_pszCmSectionIsp            = TEXT("ISP");
const TCHAR* const c_pszCmEntryIspUrl           = TEXT("PBURL");
const TCHAR* const c_pszCmEntryIspFilterA       = TEXT("FilterA&");
const TCHAR* const c_pszCmEntryIspFilterB       = TEXT("FilterB&");
const TCHAR* const c_pszCmEntryIspReferences    = TEXT("References");
const TCHAR* const c_pszCmEntryIspCmsFile       = TEXT("CMSFile&");
const TCHAR* const c_pszCmEntryIspPbFile        = TEXT("PBFile");
const TCHAR* const c_pszCmEntryIspRegionFile    = TEXT("RegionFile");

#endif // _CM_PBK_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\ras_str.h ===
//+----------------------------------------------------------------------------
//
// File:     ras_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for shared ras strings.  Note that the contents 
//           of this file should be limited to ras specific string constants.
//			 
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball       Created       10/14/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_RAS_STR
#define _CM_RAS_STR

const TCHAR* const c_pszRasDirRas = TEXT("\\RAS");
const TCHAR* const c_pszRasPhonePbk = TEXT("\\rasphone.pbk");
const TCHAR* const c_pszRasHiddenPhonePbk = TEXT("\\_CMPhone");
const TCHAR* const c_pszInetDialHandler = TEXT("InetDialHandler");
const TCHAR* const c_pszCmDialPath = TEXT("%windir%\\system32\\cmdial32.dll");

#endif // _CM_RAS_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\perf_str.h ===
//+----------------------------------------------------------------------------
//
// File:     perf_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for DUN 1.2 perf stat strings.  Note that the 
//           contents of this header should be specific to perf stats.
//			 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/14/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_PERF_STR
#define _CM_PERF_STR

//
// the following reg key and values are where Dialup 1.2 store the perfmon data
// for Windows 95/98Dial-Up Networking
// Win9x support upto two PPP/PPTP sessions, the reg key is first come first serve
//
const TCHAR* const c_pszDialupPerfKey           = TEXT("PerfStats\\StatData");
const TCHAR* const c_pszDialupTotalBytesRcvd    = TEXT("\\TotalBytesRecvd");
const TCHAR* const c_pszDialupTotalBytesXmit    = TEXT("\\TotalBytesXmit");
const TCHAR* const c_pszDialupConnectSpeed 	    = TEXT("\\ConnectSpeed");
const TCHAR* const c_pszDialup_2_TotalBytesRcvd = TEXT(" #2\\TotalBytesRecvd");
const TCHAR* const c_pszDialup_2_TotalBytesXmit = TEXT(" #2\\TotalBytesXmit");
const TCHAR* const c_pszDialup_2_ConnectSpeed 	= TEXT(" #2\\ConnectSpeed");

#endif // _CM_PERF_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\profile_str.h ===
//+----------------------------------------------------------------------------
//
// File:     profile_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS and .CMP flags shared between cmdial and profwiz.
//           Note that the contents of this header should be limited to .CMS 
//           and .CMP flags.
//			 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_PROFILE_STR
#define _CM_PROFILE_STR

const TCHAR* const c_pszCmEntryPbMessage         = TEXT("PBMessage");    
const TCHAR* const c_pszCmEntryPbLogo            = TEXT("PBLogo");                    
const TCHAR* const c_pszCmEntryLogo              = TEXT("Logo");                      

const TCHAR* const c_pszCmEntryHideDomain        = TEXT("HideDomain");    

        
const TCHAR* const c_pszCmEntryServiceMessage    = TEXT("ServiceMessage");        
const TCHAR* const c_pszCmEntryUserPrefix        = TEXT("UserNamePrefix");           
const TCHAR* const c_pszCmEntryUserSuffix        = TEXT("UserNameSuffix");           
        
const TCHAR* const c_pszCmEntryTapiLocation      = TEXT("TapiLocation");

const TCHAR* const c_pszRegKeyAccessPoints       = TEXT("Access Points");

const TCHAR* const c_pszCmEntryEnableICF         = TEXT("EnableICF");
const TCHAR* const c_pszCmEntryDisableICS        = TEXT("DisableICS");
const TCHAR* const c_pszCmEntryUseWinLogonCredentials   = TEXT("UseWinLogonCredentials");

#endif // _CM_PROFILE_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\pwd_str.h ===
//+----------------------------------------------------------------------------
//
// File:     pwd_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS flags used in password management
//           Note that the contents of this header should be 
//           limited to password related CMS/CMP flags that are shared by
//           the modules that include this file.
//			 
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_PWD_STR
#define _CM_PWD_STR

const TCHAR* const c_pszCmEntryRememberPwd      = TEXT("RememberPassword");
const TCHAR* const c_pszCmEntryRememberInetPwd  = TEXT("RememberInternetPassword");
const TCHAR* const c_pszCmEntryPcs              = TEXT("PCS");
const TCHAR* const c_pszCmEntryPassword         = TEXT("Password");
const TCHAR* const c_pszCmEntryInetPassword     = TEXT("InternetPassword");

const TCHAR* const c_pszRegCmEncryptOption      = TEXT("EncryptOption");

const TCHAR* const c_pszCmEntryUseSameUserName  = TEXT("UseSameUserName");  

//
// Password token. Used for comparison in order not to re-save the password
//

const TCHAR* const c_pszSavedPasswordToken = TEXT("****************");

#endif // _CM_PWD_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\reg_str.h ===
//+----------------------------------------------------------------------------
//
// File:     reg_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for shared reg strings.  Note that the contents 
//           of this file should be limited to reg specific string constants.
//			 
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball       Created       10/16/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_REG_STR
#define _CM_REG_STR

//
// Commonly used reg key constants
//

const TCHAR* const c_pszRegCmRoot = TEXT("SOFTWARE\\Microsoft\\Connection Manager\\");
const TCHAR* const c_pszRegCmAppPaths = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMMGR32.EXE");
const TCHAR* const c_pszRegCmMappings = TEXT("SOFTWARE\\Microsoft\\Connection Manager\\Mappings");
const TCHAR* const c_pszRegPath = TEXT("Path"); 

#endif // _CM_REG_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\dun_str.h ===
//+----------------------------------------------------------------------------
//
// File:     dun_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Shard .CMS Dun flags
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_DUN_STR
#define _CM_DUN_STR

// TCP/IP section flags
const TCHAR* const c_pszCmSectionDunTcpIp                           = TEXT("TCP/IP");
const TCHAR* const c_pszCmEntryDunTcpIpSpecifyIpAddress	            = TEXT("Specify_IP_Address");
const TCHAR* const c_pszCmEntryDunTcpIpIpAddress                    = TEXT("IP_Address");
const TCHAR* const c_pszCmEntryDunTcpIpSpecifyServerAddress         = TEXT("Specify_Server_Address");
const TCHAR* const c_pszCmEntryDunTcpIpDnsAddress                   = TEXT("DNS_Address");
const TCHAR* const c_pszCmEntryDunTcpIpDnsAltAddress                = TEXT("DNS_Alt_Address");
const TCHAR* const c_pszCmEntryDunTcpIpWinsAddress                  = TEXT("WINS_Address");
const TCHAR* const c_pszCmEntryDunTcpIpWinsAltAddress               = TEXT("WINS_Alt_Address");
const TCHAR* const c_pszCmEntryDunTcpIpIpHeaderCompress             = TEXT("IP_Header_Compress");
const TCHAR* const c_pszCmEntryDunTcpIpGatewayOnRemote              = TEXT("Gateway_On_Remote");
const TCHAR* const c_pszCmEntryDunTcpIpDnsSuffix                    = TEXT("DnsSuffix");
const TCHAR* const c_pszCmEntryDunTcpIpTcpWindowSize	            = TEXT("TcpWindowSize");

// Scripting section flags
const TCHAR* const c_pszCmSectionDunScripting                       = TEXT("Scripting");
const TCHAR* const c_pszCmEntryDunScriptingUseRasCustomScriptDll    = TEXT("UseRasCustomScriptDll");
const TCHAR* const c_pszCmEntryDunScriptingUseTerminalWindow        = TEXT("UseTerminalWindow");
const TCHAR* const c_pszCmEntryDunScriptingName                     = TEXT("Name");

// Server section flags
const TCHAR* const c_pszCmSectionDunServer                          = TEXT("Server");
const TCHAR* const c_pszCmEntryDunServerNetworkLogon                = TEXT("NetworkLogon");
const TCHAR* const c_pszCmEntryDunServerSwCompress                  = TEXT("SW_Compress");
const TCHAR* const c_pszCmEntryDunServerDisableLcp                  = TEXT("Disable_LCP");
const TCHAR* const c_pszCmEntryDunServerDisableNbtOverIP            = TEXT("DisableNbtOverIP");
const TCHAR* const c_pszCmEntryDunPrependDialupDomain               = TEXT("PrependDialupDomain");
const TCHAR* const c_pszCmEntryDunServerNegotiateTcpIp              = TEXT("Negotiate_TCP/IP");
const TCHAR* const c_pszCmEntryDunServerNegotiateIpx                = TEXT("Negotiate_IPX");
const TCHAR* const c_pszCmEntryDunServerNegotiateNetBeui            = TEXT("Negotiate_Netbeui");
const TCHAR* const c_pszCmEntryDunServerPwEncryptMs                 = TEXT("PW_EncryptMS");
const TCHAR* const c_pszCmEntryDunServerPwEncrypt                   = TEXT("PW_Encrypt");
const TCHAR* const c_pszCmEntryDunServerRequirePap                  = TEXT("Require_PAP");
const TCHAR* const c_pszCmEntryDunServerRequireSpap                 = TEXT("Require_SPAP");
const TCHAR* const c_pszCmEntryDunServerRequireEap                  = TEXT("Require_EAP");
const TCHAR* const c_pszCmEntryDunServerRequireChap                 = TEXT("Require_CHAP");
const TCHAR* const c_pszCmEntryDunServerRequireMsChap               = TEXT("Require_MSCHAP");
const TCHAR* const c_pszCmEntryDunServerRequireMsChap2              = TEXT("Require_MSCHAP2");
const TCHAR* const c_pszCmEntryDunServerRequireW95MsChap            = TEXT("Require_W95MSCHAP");
const TCHAR* const c_pszCmEntryDunServerCustomSecurity              = TEXT("Custom_Security");
const TCHAR* const c_pszCmEntryDunServerEncryptionType              = TEXT("EncryptionType");
const TCHAR* const c_pszCmEntryDunServerDataEncrypt                 = TEXT("DataEncrypt");
const TCHAR* const c_pszCmEntryDunServerCustomAuthKey               = TEXT("CustomAuthKey");
const TCHAR* const c_pszCmEntryDunServerSecureLocalFiles            = TEXT("SecureLocalFiles");
const TCHAR* const c_pszCmEntryDunServerSecureClientForMSNet        = TEXT("SecureClientForMSNet");
const TCHAR* const c_pszCmEntryDunServerSecureFileAndPrint          = TEXT("SecureFileAndPrint");
const TCHAR* const c_pszCmEntryDunServerDontNegotiateMultilink      = TEXT("DontNegotiateMultilink");
const TCHAR* const c_pszCmEntryDunServerDontUseRasCredentials       = TEXT("DontUseRasCredentials");
const TCHAR* const c_pszCmEntryDunServerEnforceCustomSecurity       = TEXT("EnforceCustomSecurity");
const TCHAR* const c_pszCmEntryDunServerType                        = TEXT("Type");
const TCHAR* const c_pszDunPpp                                      = TEXT("ppp");
const TCHAR* const c_pszDunSlip                                     = TEXT("slip");
const TCHAR* const c_pszDunCslip                                    = TEXT("cslip");
// c_pszCmEntryDunServerCustomAuthData => see below under the CHAR constants.

// Networking section flags
const TCHAR* const c_pszCmSectionDunNetworking                      = TEXT("Networking");
const TCHAR* const c_pszCmEntryDunNetworkingVpnStrategy             = TEXT("VpnStrategy");
const TCHAR* const c_pszCmEntryDunNetworkingVpnEntry                = TEXT("VpnEntry");
const TCHAR* const c_pszCmEntryDunNetworkingUsePreSharedKey         = TEXT("UsePreSharedKey");
const TCHAR* const c_pszCmEntryDunNetworkingUseDownLevelL2TP        = TEXT("UseDownLevelL2TP");
const TCHAR* const c_pszCmEntryDunNetworkingUsePskDownLevel         = TEXT("UsePskDownLevel");

//
//  These constants are explicitly CHAR consts
//
const CHAR* const c_pszCmEntryDunServerCustomAuthData       = "CustomAuthData";


#endif //  _CM_DUN_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\tunl_str.h ===
//+----------------------------------------------------------------------------
//
// File:     tunl_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS tunnel flags.  Note that the contents 
//           of this header should be limited to .CMS tunnel flags.
//                       
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball       Created       10/15/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_TUNL_STR
#define _CM_TUNL_STR

const TCHAR* const c_pszCmEntryTunnelPrimary    = TEXT("Tunnel");           
const TCHAR* const c_pszCmEntryTunnelReferences = TEXT("TunnelReferences"); 
const TCHAR* const c_pszCmEntryTunnelAddress    = TEXT("TunnelAddress");        
const TCHAR* const c_pszCmEntryTunnelDun        = TEXT("TunnelDUN");
const TCHAR* const c_pszCmEntryTunnelFile       = TEXT("TunnelFile");
const TCHAR* const c_pszCmEntryTunnelDesc       = TEXT("TunnelDesc");
const TCHAR* const c_pszCmEntryPresharedKey     = TEXT("PresharedKey");
const TCHAR* const c_pszCmEntryKeyIsEncrypted   = TEXT("PresharedKeyIsEncrypted");

const TCHAR* const c_pszCmSectionVpnServers     = TEXT("VPN Servers");
const TCHAR* const c_pszCmSectionSettings       = TEXT("Settings");
const TCHAR* const c_pszCmEntryVpnDefault       = TEXT("Default");
const TCHAR* const c_pszCmEntryVpnUpdateUrl     = TEXT("UpdateUrl");
const TCHAR* const c_pszCmEntryVpnMessage       = TEXT("Message");

#endif // _CM_TUNL_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\stp_str.h ===
//+----------------------------------------------------------------------------
//
// File:     stp_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file containing common strings optimized for cmstp. 
//			 
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_STP_STR
#define _CM_STP_STR

const TCHAR* const c_pszCmSectionProfileFormat  = TEXT("Profile Format");
const TCHAR* const c_pszCmEntryDun          	= TEXT("DUN");
const TCHAR* const c_pszCmEntryDialup           = TEXT("Dialup");
const TCHAR* const c_pszCmEntryDirect           = TEXT("Direct");
const TCHAR* const c_pszCmEntryConnectionType   = TEXT("ConnectionType");
const TCHAR* const c_pszCmpExt                  = TEXT(".cmp");

#endif // _CM_STP_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\ver_str.h ===
//+----------------------------------------------------------------------------
//
// File:     ver_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for Profile Versioning Inf Values/Keys
//				 		 
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/19/99
//
//+----------------------------------------------------------------------------
const TCHAR* const c_pszSectionCmDial32 = TEXT("CmDial32.Dll");
const TCHAR* const c_pszVerBuild = TEXT("Build");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\customactions\cmproxy\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     main.cpp
//      
// Module:   CMPROXY.DLL (TOOL)
//
// Synopsis: Main entry point for cmproxy.dll
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb   Created   10/27/99
//
//+----------------------------------------------------------------------------

#include "pch.h"

extern "C" BOOL WINAPI DllMain(
    HINSTANCE   hinstDLL,	    // handle to DLL module 
    DWORD       fdwReason,		// reason for calling function 
    LPVOID      lpvReserved 	// reserved 
)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        MYVERIFY(DisableThreadLibraryCalls(hinstDLL));
    }

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\customactions\cmproxy\pch.h ===
//+----------------------------------------------------------------------------
//
// File:     pch.h
//      
// Module:   CMPROXY.DLL (TOOL)
//
// Synopsis: Precompiled header for IE proxy setting connect action.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb   Created   10/27/99
//
//+----------------------------------------------------------------------------

#include <windows.h>
#include <shlwapi.h>
#include <wininet.h>
#include <ras.h>
#include "cmutil.h"
#include "cmdebug.h"

//
//  Function Headers from util.cpp
//

HRESULT GetBrowserVersion(DLLVERSIONINFO* pDllVersionInfo);
LPTSTR *GetCmArgV(LPTSTR pszCmdLine);
BOOL UseVpnName(LPSTR pszAltName);
void GetString (LPCSTR pszSection, LPCSTR pszKey, LPSTR* ppString, LPCSTR pszFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\userinfo_str.h ===
//+----------------------------------------------------------------------------
//
// File:     userinfo_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Reg keys for user info
//			 
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------

const TCHAR* const c_pszRegCmUserInfo = TEXT("SOFTWARE\\Microsoft\\Connection Manager\\UserInfo\\");
const TCHAR* const c_pszRegCmSingleUserInfo = TEXT("SOFTWARE\\Microsoft\\Connection Manager\\SingleUserInfo\\");

const TCHAR* const c_pszCmEntryUserName     = TEXT("UserName");      
const TCHAR* const c_pszCmEntryInetUserName = TEXT("InternetUserName"); 
const TCHAR* const c_pszCmEntryDomain       = TEXT("Domain");        
const TCHAR* const c_pszCmEntryNoPrompt     = TEXT("DialAutomatically"); 
const TCHAR* const c_pszCmEntryCurrentAccessPoint = TEXT("CurrentAccessPoint");
const TCHAR* const c_pszCmEntryAccessPointsEnabled = TEXT("AccessPointsEnabled");
const TCHAR* const c_pszCmEntryBalloonTipsDisplayed = TEXT("BalloonTipsDisplayed");

//
// Used to store the encrypted random key for password encryption and decryption
// UserBlob - main password, UserBlob2 - Internet password
//
const TCHAR* const c_pszCmRegKeyEncryptedPasswordKey              = TEXT("UserBlob");
const TCHAR* const c_pszCmRegKeyEncryptedInternetPasswordKey      = TEXT("UserBlob2");

//
// Reg key used to store ICS user setting
//
const TCHAR* const c_pszCmRegKeyICSDataKey      = TEXT("ICSData");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\common\strings\uninstcm_str.h ===
//+----------------------------------------------------------------------------
//
// File:     uninstcm_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Cm Uninstall Reg Key location
//			 
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------

const TCHAR* const c_pszRegCmUninstallKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Connection Manager");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\customactions\cmproxy\cmproxy.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmproxy.cpp
//      
// Module:   CMPROXY.DLL (TOOL)
//
// Synopsis: Main source for IE proxy setting connect action
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb   Created   10/27/99
//
//+----------------------------------------------------------------------------
#include "pch.h"

//
//  Include the locale-safe replacement for lstrcmpi
//
#include "CompareString.cpp"

const CHAR* const c_pszInternetSettingsPath = "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings";
const CHAR* const c_pszProxyEnable = "ProxyEnable";
const CHAR* const c_pszProxyServer = "ProxyServer";
const CHAR* const c_pszProxyOverride = "ProxyOverride";
const CHAR* const c_pszManualProxySection = "Manual Proxy";
const CHAR* const c_pszAutoProxySection = "Automatic Proxy";
const CHAR* const c_pszAutoConfigScript = "AutoConfigScript";
const CHAR* const c_pszAutoProxyEnable = "AutoProxyEnable";
const CHAR* const c_pszAutoConfigScriptEnable = "AutoConfigScriptEnable";
const CHAR* const c_pszUseVpnName = "UseVpnName";
const CHAR* const c_pszEmpty = "";

//
//  Typedefs and Function Pointers for the Wininet APIs that we use.
//

typedef BOOL (WINAPI* pfnInternetQueryOptionSpec)(HINTERNET, DWORD, LPVOID, LPDWORD);
typedef BOOL (WINAPI* pfnInternetSetOptionSpec)(HINTERNET, DWORD, LPVOID, DWORD);
pfnInternetQueryOptionSpec g_pfnInternetQueryOption = NULL;
pfnInternetSetOptionSpec g_pfnInternetSetOption = NULL;


//+----------------------------------------------------------------------------
//
// Function:  SetIE5ProxySettings
//
// Synopsis:  This function sets the IE5, per connection proxy settings using
//            the given connection, enabled value, proxy server, and override
//            settings.
//
// Arguments: LPSTR pszConnection - Connection name to set the proxy settings for
//            BOOL bManualProxy - whether the manual proxy is enabled or not
//            BOOL bAutomaticProxy  - whether the auto proxy detection is enabled
//            BOOL bAutoConfigScript - whether an auto config script should be used
//            LPSTR pszProxyServer - proxy server name in the proxyserver:port format
//            LPSTR pszProxyOverride - a semi-colon seperated list of 
//                                     realms to bypass the proxy for
//            LPSTR pszAutoConfigScript - auto config URL
//
// Returns:   HRESULT  - Standard COM return codes
//
// History:   quintinb Created  10/27/99
//
//+----------------------------------------------------------------------------
HRESULT SetIE5ProxySettings(LPSTR pszConnection, BOOL bManualProxy, BOOL bAutomaticProxy, BOOL bAutoConfigScript,
                            LPSTR pszProxyServer, LPSTR pszProxyOverride, LPSTR pszAutoConfigScript)
{
    //
    //  Check Inputs, note allow pszConnection to be NULL (to set the LAN connection)
    //
    if ((NULL == g_pfnInternetSetOption) || (NULL == pszProxyServer) || 
        (NULL == pszProxyOverride) || (NULL == pszAutoConfigScript))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;    
    INTERNET_PER_CONN_OPTION_LIST PerConnOptionList;
    DWORD dwSize = sizeof(PerConnOptionList);

    PerConnOptionList.dwSize = sizeof(PerConnOptionList);
    PerConnOptionList.pszConnection = pszConnection;
    PerConnOptionList.dwOptionCount = 4;
    PerConnOptionList.dwOptionError = 0;    

    PerConnOptionList.pOptions = (INTERNET_PER_CONN_OPTION*)CmMalloc(4*sizeof(INTERNET_PER_CONN_OPTION));
    if(NULL == PerConnOptionList.pOptions)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // set flags
    //
    PerConnOptionList.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    PerConnOptionList.pOptions[0].Value.dwValue = PROXY_TYPE_DIRECT;

    if (bManualProxy)
    {
        PerConnOptionList.pOptions[0].Value.dwValue |= PROXY_TYPE_PROXY;
    }

    if (bAutomaticProxy)
    {
        PerConnOptionList.pOptions[0].Value.dwValue |= PROXY_TYPE_AUTO_DETECT;
    }

    if (bAutoConfigScript)
    {
        PerConnOptionList.pOptions[0].Value.dwValue |= PROXY_TYPE_AUTO_PROXY_URL;
    }

    //
    // set proxy name
    //
    PerConnOptionList.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    PerConnOptionList.pOptions[1].Value.pszValue = pszProxyServer;

    //
    // set proxy override
    //
    PerConnOptionList.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    PerConnOptionList.pOptions[2].Value.pszValue = pszProxyOverride;

    //
    // set auto config URL
    //
    PerConnOptionList.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
    PerConnOptionList.pOptions[3].Value.pszValue = pszAutoConfigScript;

    //
    // tell wininet
    //
    if (!g_pfnInternetSetOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &PerConnOptionList, dwSize))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    CmFree(PerConnOptionList.pOptions);

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  SetIE4ProxySettings
//
// Synopsis:  This function sets the IE4 proxy settings (global to a machine) using
//            the given connection, enabled value, proxy server, and override
//            settings.
//
// Arguments: LPSTR pszConnection - ignored (exists to have same prototype as IE5 version)
//            BOOL bManualProxy - whether the manual proxy is enabled or not
//            BOOL bAutomaticProxy  - ignored (exists to have same prototype as IE5 version)
//            BOOL bAutoConfigScript - ignored (exists to have same prototype as IE5 version)
//            LPSTR pszProxyServer - proxy server name in the proxyserver:port format
//            LPSTR pszProxyOverride - a semi-colon seperated list of 
//                                     realms to bypass the proxy for
//            LPSTR pszAutoConfigScript - ignored (exists to have same prototype as IE5 version)
//
// Returns:   HRESULT  - Standard COM return codes
//
// History:   quintinb Created  10/27/99
//
//+----------------------------------------------------------------------------
HRESULT SetIE4ProxySettings(LPSTR pszConnection, BOOL bManualProxy, BOOL bAutomaticProxy, BOOL bAutoConfigScript,
                            LPSTR pszProxyServer, LPSTR pszProxyOverride, LPSTR pszAutoConfigScript)
{
    //
    //  Check Inputs, note that we don't allow the strings to be NULL but they could
    //  be empty.  Also note that pszConnection is ignored because IE4 proxy settings are global.
    //
    if ((NULL == pszProxyServer) || (NULL == pszProxyOverride))
    {
        return E_INVALIDARG;
    }

    DWORD dwTemp;
    HKEY hKey = NULL;
    HRESULT hr = S_OK;

    //
    //  Now Create/Open the Internet Settings key
    //
    LONG lResult = RegCreateKeyEx(HKEY_CURRENT_USER, c_pszInternetSettingsPath, 0, NULL, 
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwTemp);

    hr = HRESULT_FROM_WIN32(lResult);

    if (SUCCEEDED(hr))
    {
        //
        //  Set the proxy values
        //
        dwTemp = bManualProxy ? 1 : 0; // use a true 1 or 0 value.
        lResult = RegSetValueEx(hKey, c_pszProxyEnable, 0, REG_DWORD, (CONST BYTE*)&dwTemp, sizeof(DWORD));
        hr = HRESULT_FROM_WIN32(lResult);
        
        if (SUCCEEDED(hr))
        {            
            lResult = RegSetValueEx(hKey, c_pszProxyServer, 0, REG_SZ, (CONST BYTE*)pszProxyServer, lstrlen(pszProxyServer)+1);
            hr = HRESULT_FROM_WIN32(lResult);
        
            if (SUCCEEDED(hr))
            {            
                lResult = RegSetValueEx(hKey, c_pszProxyOverride, 0, REG_SZ, (CONST BYTE*)pszProxyOverride, lstrlen(pszProxyOverride)+1);
                hr = HRESULT_FROM_WIN32(lResult);
            }            
        }
        (VOID)RegCloseKey(hKey);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  GetIE5ProxySettings
//
// Synopsis:  Gets the IE5, per connection, proxy settings for the given connection.
//            Please note that the strings allocated for the proxy server and the
//            proxy override values must be freed by the caller.
//
// Arguments: LPSTR pszConnection - connection name to get the proxy settings for
//            LPBOOL pbManualProxy - bool pointer to hold whether the manual 
//                                   proxy is enabled or not
//            LPBOOL pbAutomaticProxy - bool pointer to hold whether automatic 
//                                      proxy detection is enabled or not
//            LPBOOL pbAutoConfigScript - bool pointer to hold whether an auto
//                                        config script should be used or not
//            LPSTR* ppszProxyServer - string pointer to hold the retrieved 
//                                     proxy server string
//            LPSTR* ppszProxyOverride - string pointer to hold the retrieved
//                                       proxy server string
//            LPSTR* ppszAutoConfigScript - string pointer to hold the retrieved
//                                          auto config script
//
// Returns:   HRESULT - Standard COM return codes
//
// History:   quintinb  Created    10/27/99
//
//+----------------------------------------------------------------------------
HRESULT GetIE5ProxySettings(LPSTR pszConnection, LPBOOL pbManualProxy, LPBOOL pbAutomaticProxy, LPBOOL pbAutoConfigScript,
                            LPSTR* ppszProxyServer, LPSTR* ppszProxyOverride, LPSTR* ppszAutoConfigScript)
{

    //
    //  Check Inputs, note that pszConnection can be NULL.  It will set the LAN connection in that case.
    //
    if ((NULL == pbManualProxy) || (NULL == pbAutomaticProxy) || (NULL == pbAutoConfigScript) || 
        (NULL == ppszProxyServer) || (NULL == ppszProxyOverride) || (NULL == ppszAutoConfigScript) ||
        (NULL == g_pfnInternetQueryOption))
    {
        return E_INVALIDARG;
    }

    //
    //  Zero the output params
    //
    *pbManualProxy = FALSE;
    *pbAutomaticProxy = FALSE;
    *pbAutoConfigScript = FALSE;
    *ppszProxyServer = CmStrCpyAlloc(c_pszEmpty);
    *ppszProxyOverride = CmStrCpyAlloc(c_pszEmpty);
    *ppszAutoConfigScript = CmStrCpyAlloc(c_pszEmpty);
    //
    //  Setup the Option List Struct
    //
    HRESULT hr = S_OK;

    INTERNET_PER_CONN_OPTION_LIST PerConnOptionList;
    PerConnOptionList.dwSize = sizeof(PerConnOptionList);
    PerConnOptionList.pszConnection = pszConnection;
    PerConnOptionList.dwOptionError = 0;
    PerConnOptionList.dwOptionCount = 4;

    PerConnOptionList.pOptions = (INTERNET_PER_CONN_OPTION*)CmMalloc(4*sizeof(INTERNET_PER_CONN_OPTION));
    if(NULL == PerConnOptionList.pOptions)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // set flags we want info about
    //
    PerConnOptionList.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    PerConnOptionList.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    PerConnOptionList.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    PerConnOptionList.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;

    
    DWORD dwSize = sizeof(PerConnOptionList);
    
    //
    //  Get the Options
    //
    if (!g_pfnInternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &PerConnOptionList, &dwSize))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (SUCCEEDED(hr))
    {
        //
        //  Parse the returned options to find the options we are interested in
        //

        for (DWORD dwIndex=0; dwIndex < PerConnOptionList.dwOptionCount; dwIndex++)
        {
            switch(PerConnOptionList.pOptions[dwIndex].dwOption)
            {
            case INTERNET_PER_CONN_FLAGS:
                if (PROXY_TYPE_PROXY & PerConnOptionList.pOptions[dwIndex].Value.dwValue)
                {
                    *pbManualProxy = TRUE;
                }

                if (PROXY_TYPE_AUTO_PROXY_URL & PerConnOptionList.pOptions[dwIndex].Value.dwValue)
                {
                    *pbAutoConfigScript = TRUE;
                }

                if (PROXY_TYPE_AUTO_DETECT & PerConnOptionList.pOptions[dwIndex].Value.dwValue)
                {
                    *pbAutomaticProxy = TRUE;
                }

                break;

            case INTERNET_PER_CONN_PROXY_SERVER:
                if (NULL != PerConnOptionList.pOptions[dwIndex].Value.pszValue)
                {
                    CmFree(*ppszProxyServer);
                    *ppszProxyServer = CmStrCpyAlloc(PerConnOptionList.pOptions[dwIndex].Value.pszValue);
                    LocalFree(PerConnOptionList.pOptions[dwIndex].Value.pszValue);
                }
                break;

            case INTERNET_PER_CONN_PROXY_BYPASS:
                if (NULL != PerConnOptionList.pOptions[dwIndex].Value.pszValue)
                {
                    CmFree(*ppszProxyOverride);
                    *ppszProxyOverride = CmStrCpyAlloc(PerConnOptionList.pOptions[dwIndex].Value.pszValue);
                    LocalFree(PerConnOptionList.pOptions[dwIndex].Value.pszValue);
                }
                break;

            case INTERNET_PER_CONN_AUTOCONFIG_URL:
                if (NULL != PerConnOptionList.pOptions[dwIndex].Value.pszValue)
                {
                    CmFree(*ppszAutoConfigScript);
                    *ppszAutoConfigScript = CmStrCpyAlloc(PerConnOptionList.pOptions[dwIndex].Value.pszValue);
                    LocalFree(PerConnOptionList.pOptions[dwIndex].Value.pszValue);
                }
                break;

            default:
                break;
            }
        }
        CmFree(PerConnOptionList.pOptions);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  GetIE4ProxySettings
//
// Synopsis:  Gets the IE4, per machine, proxy settings.
//            Please note that the strings allocated for the proxy server and the
//            proxy override values must be freed by the caller.
//
// Arguments: LPSTR pszConnection - ignored (exists for prototype consistency with the IE5 version)
//            LPBOOL pbManualProxy - bool pointer to hold whether the manual 
//                                   proxy is enabled or not
//            LPBOOL pbAutomaticProxy - ignored (not supported by IE4)
//            LPBOOL pbAutoConfigScript - ignored (not supported by IE4)
//            LPSTR* ppszProxyServer - string pointer to hold the retrieved 
//                                     proxy server string
//            LPSTR* ppszProxyOverride - string pointer to hold the retrieved
//                                       proxy server string
//            LPSTR* ppszAutoConfigScript - ignored (not supported by IE4)
//
// Returns:   HRESULT - Standard COM return codes
//
// History:   quintinb  Created    10/27/99
//
//+----------------------------------------------------------------------------
HRESULT GetIE4ProxySettings(LPSTR pszConnection, LPBOOL pbManualProxy, LPBOOL pbAutomaticProxy, LPBOOL pbAutoConfigScript,
                            LPSTR* ppszProxyServer, LPSTR* ppszProxyOverride, LPSTR* ppszAutoConfigScript)
{
    //
    //  Check Inputs, note that we don't allow the pointers to be NULL but they could
    //  be empty.    Also note that pszConnection is ignored because IE4 proxy settings are global.
    //
    if ((NULL == pbManualProxy) || (NULL == ppszProxyServer) || (NULL == ppszProxyOverride))
    {
        return E_INVALIDARG;
    }

    DWORD dwTemp;
    DWORD dwSize;
    DWORD dwType;
    HKEY hKey = NULL;
    HRESULT hr = S_OK;

    //
    //  Zero the output params
    //
    *pbManualProxy = FALSE;
    *pbAutomaticProxy = FALSE;
    *pbAutoConfigScript = FALSE;
    *ppszProxyServer = CmStrCpyAlloc(c_pszEmpty);
    *ppszProxyOverride = CmStrCpyAlloc(c_pszEmpty);
    *ppszAutoConfigScript = CmStrCpyAlloc(c_pszEmpty);

    //
    //  Now Create/Open the Internet Settings key
    //
    LONG lResult = RegOpenKeyEx(HKEY_CURRENT_USER, c_pszInternetSettingsPath, 0, KEY_READ, &hKey);
    
    hr = HRESULT_FROM_WIN32(lResult);

    if (SUCCEEDED(hr))
    {
        //
        //  get whether the proxy is enabled or not
        //
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hKey, c_pszProxyEnable, 0, &dwType, (LPBYTE)pbManualProxy, &dwSize);
        hr = HRESULT_FROM_WIN32(lResult);
        
        if (SUCCEEDED(hr))
        {   
            //
            //  get the proxy server value
            //

            lResult = ERROR_INSUFFICIENT_BUFFER;
            dwSize = MAX_PATH;

            do 
            {
                //
                //  Alloc a Buffer
                //
                CmFree(*ppszProxyServer);
                *ppszProxyServer = (CHAR*)CmMalloc(dwSize);

                if (*ppszProxyServer)
                {
                    lResult = RegQueryValueEx(hKey, c_pszProxyServer, 0, &dwType, 
                                          (LPBYTE)*ppszProxyServer, &dwSize);
                }
                else
                {
                    lResult = ERROR_NOT_ENOUGH_MEMORY;    
                }

                hr = HRESULT_FROM_WIN32(lResult);
                dwSize = 2*dwSize;

            } while ((ERROR_INSUFFICIENT_BUFFER == lResult) && (dwSize < 1024*1024));
        
            if (SUCCEEDED(hr))
            {
                //
                //  get the proxy override value
                //
                
                lResult = ERROR_INSUFFICIENT_BUFFER;
                dwSize = MAX_PATH;

                do 
                {
                    //
                    //  Alloc a Buffer
                    //
                    CmFree(*ppszProxyOverride);
                    *ppszProxyOverride = (CHAR*)CmMalloc(dwSize);

                    if (*ppszProxyOverride)
                    {
                        lResult = RegQueryValueEx(hKey, c_pszProxyOverride, 0, &dwType, 
                                              (LPBYTE)*ppszProxyOverride, &dwSize);
                    }
                    else
                    {
                        lResult = ERROR_NOT_ENOUGH_MEMORY;    
                    }

                    hr = HRESULT_FROM_WIN32(lResult);
                    dwSize = 2*dwSize;

                } while ((ERROR_INSUFFICIENT_BUFFER == lResult) && (dwSize < 1024*1024));
            }
        }
    }
    else
    {
        if (ERROR_FILE_NOT_FOUND == lResult)
        {
            //
            //  No Proxy settings to get.
            //
            hr = S_FALSE;
        }
    }

    if (hKey)
    {
        (VOID)RegCloseKey(hKey);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  ReadProxySettingsFromFile
//
// Synopsis:  Reads the proxy settings from the given proxy file and stores them
//            in the provided pointers.  Please note that the buffers allocated
//            by GetString and stored in ppszProxyOverride, ppszProxyServer, and
//            ppszAutoConfigScript must be freed by the caller.  Please see the above
//            format guide for specifics.
//
// Arguments: LPCSTR pszSourceFile - file to read the proxy settings from.
//            LPBOOL pbManualProxy - determines if the manual proxy is enabled or not
//            LPBOOL pbAutomaticProxy - determines if automatic proxy detection is enabled or not
//            LPBOOL pbAutoConfigScript - determines if an automatic config script should be used
//            LPSTR* ppszProxyServer - string pointer to hold the Proxy server value 
//                                     (in server:port format)
//            LPSTR* ppszProxyOverride - string pointer to hold the Proxy override values
//                                     (a semi-colon seperated list)
//            LPSTR* ppszAutoConfigScript - URL for an automatic config script
//            LPBOOL pbUseVpnName - whether the alternate connectoid name should 
//                                  be used (the VPN connectoid name)
//
// Returns:   BOOL - TRUE if the settings were successfully read
//
// History:   quintinb   Created    10/27/99
//
//+----------------------------------------------------------------------------
BOOL ReadProxySettingsFromFile(LPCSTR pszSourceFile, LPBOOL pbManualProxy, LPBOOL pbAutomaticProxy, LPBOOL pbAutoConfigScript,
                               LPSTR* ppszProxyServer, LPSTR* ppszProxyOverride, LPSTR* ppszAutoConfigScript, LPBOOL pbUseVpnName)
{
    //
    //  Check input params
    //
    if ((NULL == ppszProxyOverride) || (NULL == ppszProxyServer) || (NULL == ppszAutoConfigScript) ||
        (NULL == pbAutomaticProxy) || (NULL == pbAutoConfigScript) || (NULL == pbManualProxy) ||
        (NULL == pbUseVpnName) || (NULL == pszSourceFile) || ('\0' == pszSourceFile[0]))
    {
        return FALSE;
    }

    //
    //  Get the Manual proxy settings
    //
    *pbManualProxy = GetPrivateProfileInt(c_pszManualProxySection, c_pszProxyEnable, 0, pszSourceFile);

    GetString(c_pszManualProxySection, c_pszProxyServer, ppszProxyServer, pszSourceFile);

    if (NULL == *ppszProxyServer)
    {
        return FALSE;
    }

    GetString(c_pszManualProxySection, c_pszProxyOverride, ppszProxyOverride, pszSourceFile);

    if (NULL == *ppszProxyOverride)
    {
        return FALSE;
    }

    //
    //  If this is a backup file, we will have the UseVpnName flag to tell us which connectoid name
    //  is appropriate.  Lets look it up.  Note that we default to using the standard connectoid.
    //
    *pbUseVpnName = GetPrivateProfileInt(c_pszManualProxySection, c_pszUseVpnName, 0, pszSourceFile);


    //
    //  Get the Auto proxy settings
    //

    *pbAutomaticProxy = GetPrivateProfileInt(c_pszAutoProxySection, c_pszAutoProxyEnable, 0, pszSourceFile); //"Automatically detect settings" checkbox

    *pbAutoConfigScript = GetPrivateProfileInt(c_pszAutoProxySection, c_pszAutoConfigScriptEnable, 0, pszSourceFile);//"Use automatic configuration script" checkbox

    GetString(c_pszAutoProxySection, c_pszAutoConfigScript, ppszAutoConfigScript, pszSourceFile);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteProxySettingsToFile
//
// Synopsis:  Writes the specified settings to the given backup proxy filename.
//            Please see the above format guide for specifics.
//
// Arguments: LPCSTR pszBackupFile - backup file to write the current settings to
//            BOOL bManualProxy -- bool to tell if the manual proxy is enabled.
//            BOOL bAutomaticProxy -- bool to tell if auto proxy detection is enabled.
//            BOOL bAutoConfigScript -- bool to tell if an auto config 
//                                      script should be used.
//            LPSTR pszProxyServer - proxy server string in server:port format
//            LPSTR pszProxyOverride - semi-colon seperated list of realms for
//                                     which the proxy server should be bypassed.
//            BOOL bUseVpnName - value to write to the UseVpnName file, see format doc above.
//
// Returns:   BOOL - TRUE if the values were written successfully
//
// History:   quintinb      Created    10/27/99
//
//+----------------------------------------------------------------------------
BOOL WriteProxySettingsToFile(LPCSTR pszBackupFile, BOOL bManualProxy, BOOL bAutomaticProxy, BOOL bAutoConfigScript,
                              LPSTR pszProxyServer, LPSTR pszProxyOverride, LPSTR pszAutoConfigScript, BOOL bUseVpnName)
{
    //
    //  Check inputs
    //
    if ((NULL == pszBackupFile) || ('\0' == pszBackupFile[0]) || (NULL == pszProxyServer) || 
        (NULL == pszProxyOverride) || (NULL == pszAutoConfigScript))
    {
        return FALSE;
    }

    BOOL bReturn = TRUE;
    CHAR szTemp[MAX_PATH];

    //
    //  Write the Manual Proxy Settings
    //
    wsprintf(szTemp, "%d", bManualProxy);
    if (!WritePrivateProfileString(c_pszManualProxySection, c_pszProxyEnable, szTemp, pszBackupFile))
    {
        CMTRACE1("CmProxy -- WriteProxySettingsToFile failed, GLE %d", GetLastError());
        bReturn = FALSE;
    }

    if (!WritePrivateProfileString(c_pszManualProxySection, c_pszProxyServer, pszProxyServer, pszBackupFile))
    {
        CMTRACE1("CmProxy -- WriteProxySettingsToFile failed, GLE %d", GetLastError());
        bReturn = FALSE;
    }

    if (!WritePrivateProfileString(c_pszManualProxySection, c_pszProxyOverride, pszProxyOverride, pszBackupFile))
    {
        CMTRACE1("CmProxy -- WriteProxySettingsToFile failed, GLE %d", GetLastError());
        bReturn = FALSE;
    }

    wsprintf(szTemp, "%d", bUseVpnName);
    if (!WritePrivateProfileString(c_pszManualProxySection, c_pszUseVpnName, szTemp, pszBackupFile))
    {
        CMTRACE1("CmProxy -- WriteProxySettingsToFile failed, GLE %d", GetLastError());
        bReturn = FALSE;
    }

    //
    //  Write the Automatic Proxy Settings
    //
    wsprintf(szTemp, "%d", bAutomaticProxy);
    if (!WritePrivateProfileString(c_pszAutoProxySection, c_pszAutoProxyEnable, szTemp, pszBackupFile))
    {
        CMTRACE1("CmProxy -- WriteProxySettingsToFile failed, GLE %d", GetLastError());
        bReturn = FALSE;
    }

    wsprintf(szTemp, "%d", bAutoConfigScript);
    if (!WritePrivateProfileString(c_pszAutoProxySection, c_pszAutoConfigScriptEnable, szTemp, pszBackupFile))
    {
        CMTRACE1("CmProxy -- WriteProxySettingsToFile failed, GLE %d", GetLastError());
        bReturn = FALSE;
    }

    if (!WritePrivateProfileString(c_pszAutoProxySection, c_pszAutoConfigScript, pszAutoConfigScript, pszBackupFile))
    {
        CMTRACE1("CmProxy -- WriteProxySettingsToFile failed, GLE %d", GetLastError());
        bReturn = FALSE;
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  SetProxy
//
// Synopsis:  Proxy entry point for setting the IE4 and IE5 style proxies.  Since
//            this is a Connection Manager connect action it uses the CM connect
//            action format (see CMAK docs for more info).  Thus the parameters
//            to the dll are passed via a string which contains parameters (see the
//            cmproxy spec for a list of the parameter values).
//
// Arguments: HWND hWnd         - Window handle of caller
//            HINSTANCE hInst   - Instance handle of caller
//            LPSTR pszArgs     - Argument string
//            int nShow         - Unused
//
// Returns:   DWORD WINAPI - Error code
//
// History:   quintinb    Created    10/27/99
//
//+----------------------------------------------------------------------------
HRESULT WINAPI SetProxy(HWND hWnd, HINSTANCE hInst, LPSTR pszArgs, int nShow)
{

    //
    //  First figure out if we have IE4 or IE5 available.
    //
    typedef HRESULT (WINAPI *pfnSetProxySettings)(LPSTR, BOOL, BOOL, BOOL, LPSTR, LPSTR, LPSTR);
    typedef HRESULT (WINAPI *pfnGetProxySettings)(LPSTR, LPBOOL, LPBOOL, LPBOOL, LPSTR*, LPSTR*, LPSTR*);
    pfnSetProxySettings SetProxySettings = NULL;
    pfnGetProxySettings GetProxySettings = NULL;

    BOOL bIE5 = FALSE;
    BOOL bManualProxy;
    BOOL bAutomaticProxy;
    BOOL bAutoConfigScript;
    BOOL bUseVpnName = FALSE;
    DLLVERSIONINFO VersionInfo;
    HINSTANCE hWinInet = NULL;
    LPSTR pszProxyServer = NULL;
    LPSTR pszProxyOverride = NULL;
    LPSTR pszAutoConfigScript = NULL;
    LPSTR pszSourceFile = NULL;
    LPSTR pszBackupFile = NULL;
    LPSTR pszConnectionName = NULL;
    LPSTR pszProfileDirPath = NULL;
    LPSTR pszAltName = NULL;
    LPSTR* CmArgV = NULL;

    if (SUCCEEDED(GetBrowserVersion(&VersionInfo)))
    {
        if (5 <= VersionInfo.dwMajorVersion)
        {
            //
            //  Set the function pointers to use the IE5 versions of the functions
            //
            SetProxySettings = SetIE5ProxySettings;
            GetProxySettings = GetIE5ProxySettings;
            bIE5 = TRUE;
        }
        else if ((4 == VersionInfo.dwMajorVersion) && 
            ((71 == VersionInfo.dwMinorVersion) || (72 == VersionInfo.dwMinorVersion)))
        {
            //
            //  Use the IE4 version of the proxy functions
            //
            SetProxySettings = SetIE4ProxySettings;
            GetProxySettings = GetIE4ProxySettings;
        }
        else
        {
            //
            //  We don't work with IE versions less than 4 so lets return right here
            //  without setting anything.
            //
            CMTRACE("CMPROXY--Unable to set the proxy settings because of insufficient IE version.");
            return TRUE;
        }

        //
        //  If we have IE5, then we need to load wininet.dll.
        //
        if (bIE5)
        {
            hWinInet = LoadLibrary("wininet.dll");

            if (hWinInet)
            {
                //
                //  Okay, lets get the procedure addresses for InternetSetOption and InternetQueryOption
                //
                g_pfnInternetQueryOption = (pfnInternetQueryOptionSpec)GetProcAddress(hWinInet, "InternetQueryOptionA");
                g_pfnInternetSetOption = (pfnInternetSetOptionSpec)GetProcAddress(hWinInet, "InternetSetOptionA");

                if ((NULL == g_pfnInternetQueryOption) || (NULL == g_pfnInternetSetOption))
                {
                    FreeLibrary(hWinInet);
                    return FALSE;
                }
            }
        }

        //
        //  Parse out the command line parameters
        //  
        //  command line is of the form: /profile %PROFILE% /DialRasEntry %DIALRASENTRY% /TunnelRasEntry %TUNNELRASENTRYNAME% /source_filename Proxy.txt /backup_filename backup.txt

        CmArgV = GetCmArgV(pszArgs);
        int i = 0;

        if (!CmArgV)
        {
            goto exit;
        }

        while (CmArgV[i])
        {
            if (0 == SafeCompareString(CmArgV[i], "/source_filename") && CmArgV[i+1])
            {
                pszSourceFile = CmStrCpyAlloc(CmArgV[i+1]);
                i = i+2;
            }
            else if (0 == SafeCompareString(CmArgV[i], "/backup_filename") && CmArgV[i+1])
            {
                pszBackupFile = CmStrCpyAlloc(CmArgV[i+1]);
                i = i+2;            
            }
            else if (0 == SafeCompareString(CmArgV[i], "/DialRasEntry") && CmArgV[i+1])
            {
                pszConnectionName = (CmArgV[i+1]);
                i = i+2;            
            }
            else if (0 == SafeCompareString(CmArgV[i], "/TunnelRasEntry") && CmArgV[i+1])
            {
                pszAltName = (CmArgV[i+1]);
                i = i+2;            
            }
            else if (0 == SafeCompareString(CmArgV[i], "/profile") && CmArgV[i+1])
            {
                pszProfileDirPath = (CmArgV[i+1]);
                i = i+2;            
            }
            else
            {
                //
                //  Unknown option.  Lets trace it out and try to continue.  We will do param
                //  verification next so if we don't have enough info to operate correctly we will work there.
                //
                CMTRACE1("Unknown option: %s", CmArgV[i]);
                i++;
            }
        }

        //
        //  Verify that we have at least a source file and a name.
        //
        if ((pszSourceFile) && (pszConnectionName))
        {
            //
            //  Lets parse the cmp path into the profile dir and append it to the filename.
            //
            if (pszProfileDirPath)
            {
                LPSTR pszTemp = CmStrrchr(pszProfileDirPath, '.');
                if (pszTemp)
                {
                    *pszTemp = '\\';
                    *(pszTemp+1) = '\0';
                    
                    pszTemp = CmStrCpyAlloc(pszProfileDirPath);
                    CmStrCatAlloc(&pszTemp, pszSourceFile);
                    CmFree(pszSourceFile);
                    pszSourceFile = pszTemp;

                    if (pszBackupFile)
                    {
                        pszTemp = CmStrCpyAlloc(pszProfileDirPath);
                        CmStrCatAlloc(&pszTemp, pszBackupFile);
                        CmFree(pszBackupFile);
                        pszBackupFile = pszTemp;
                    }
                }
            }

            //
            //  If we have a direct connection or if this is a double dial connection on Win9x then we
            //  will want to use pszAltName instead of pszConnectionName.  This is because in the Win9x case,
            //  the tunnel connectoid has "Tunnel" appended to it since all of the connectoids are stored in
            //  the registry and we cannot have two connectoids with the same name.  If this is a direct
            //  connection this is also important because pszConnectoid will come through as "NULL" and the
            //  Tunnel connectoid name will be the important one. Also, in these cases we need to set 
            //  bWriteOutUseVpnName to TRUE in order to write this flag out for the disconnect action.
            //
            BOOL bWriteOutUseVpnName = FALSE;
            if (pszConnectionName && pszAltName && bIE5)
            {
                if ((0 == SafeCompareString(pszConnectionName, TEXT("NULL"))) || OS_W9X)
                {
                    //
                    //  Then we have a direct connection or a double dial connection on 9x
                    //
                    if (UseVpnName(pszAltName))
                    {
                        pszConnectionName = pszAltName;
                        pszAltName = NULL;
                        bWriteOutUseVpnName = TRUE;
                    }
                }
            }

            //
            //  If we have a backup filename specified then we need to read the current Proxy settings
            //  and save them out to the given filename.
            //
            if (NULL != pszBackupFile)
            {
                if (SUCCEEDED(GetProxySettings(pszConnectionName, &bManualProxy, &bAutomaticProxy, &bAutoConfigScript,
                                               &pszProxyServer, &pszProxyOverride, &pszAutoConfigScript)))
                {
                    BOOL bSuccess = WriteProxySettingsToFile(pszBackupFile, bManualProxy, bAutomaticProxy, bAutoConfigScript, 
                                                             pszProxyServer, pszProxyOverride, pszAutoConfigScript,
                                                             bWriteOutUseVpnName);
                    if (!bSuccess)
                    {
                        CMTRACE("Unable to save settings to backup file, exiting!");
                        goto exit;
                    }

                    CmFree(pszProxyServer); pszProxyServer = NULL;
                    CmFree(pszProxyOverride);  pszProxyOverride = NULL;
                    CmFree(pszAutoConfigScript); pszAutoConfigScript = NULL;
                }            
            }

            //
            //  Now we need to read the proxy settings to apply out of the given file 
            //
            if (ReadProxySettingsFromFile(pszSourceFile, &bManualProxy, &bAutomaticProxy, &bAutoConfigScript, &pszProxyServer, 
                                          &pszProxyOverride, &pszAutoConfigScript, &bUseVpnName))
            {
                //
                //  Finally write the proxy settings.
                //
                if (SUCCEEDED(SetProxySettings(pszConnectionName, bManualProxy, bAutomaticProxy, bAutoConfigScript, 
                                               pszProxyServer, pszProxyOverride, pszAutoConfigScript)))
                {
                    CMTRACE1("CmProxy -- Set proxy settings successfully for %s.", pszConnectionName);
                }
            }            
        }
    }

exit:    

    CmFree(pszProxyServer);
    CmFree(pszProxyOverride);
    CmFree(pszAutoConfigScript);

    CmFree(pszSourceFile);
    CmFree(pszBackupFile);
    CmFree(CmArgV);

    if (hWinInet)
    {
        FreeLibrary(hWinInet);
    }

    //
    //  Always return S_OK because failing to set the proxy shouldn't stop the connection
    //  process.
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\customactions\cmroute\cmroute.cpp ===
//+----------------------------------------------------------------------------
//
// File:    cmroute.cpp
//
// Module:  CMROUTE.DLL
//
// Synopsis: Route Plumbing implementation for CM, as a post-connect action
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  12-Mar-2000 SumitC  Created
//
// Note:
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "iphlpapi.h"
#include "cmdebug.h"

//
//  Include the shared source code for SuppressInetAutoDial and SetInetStateConnected
//
#include "inetopt.cpp"

//
//  Include the locale-safe replacement for lstrcmpi
//
#include "CompareString.cpp"

//
//  Function declarations  
//


HRESULT ParseArgs(LPSTR pszArgList,
                  BOOL * pfUseFile,
                  LPSTR pszRoutesFile,
                  BOOL * pfUseURL,
                  LPSTR pszRoutesURL,
                  BOOL * pfProfile,
                  LPSTR pszProfile,
                  BOOL * pfURLNotFoundIgnorable,
                  BOOL * pfStayAliveOnAccessDenied,
                  BOOL * pfKeepTempFiles);
#if 0
// see note below
HRESULT CheckIPForwarding();
#endif
HRESULT Initialize(PMIB_IPFORWARDTABLE * pRouteTable, PMIB_IPFORWARDROW * pGateway);
HRESULT GetRoutesFromFile(LPSTR pszFileName,
                          LPSTR pszProfile,
                          LPSTR * ppszRouteInfo,
                          DWORD * pcbRouteInfo);
HRESULT GetRoutesFromURL(LPSTR pszURL,
                         BOOL fKeepTempFiles,
                         LPSTR * ppszRouteInfo,
                         DWORD * pcbRouteInfo);
HRESULT ProcessRouteInfo(const LPSTR pszNewRouteInfo,
                         DWORD cbNewRouteInfo,
                         PMIB_IPFORWARDTABLE pmibRouteTable,
                         PMIB_IPFORWARDROW pGateway,
                         BOOL * pfDeleteDefaultGateway);
HRESULT DeleteDefaultGateway(PMIB_IPFORWARDROW pGateway);

//
//  Route Table functions
//
HRESULT GetRouteTable(PMIB_IPFORWARDTABLE * pTable);
DWORD GetIf(const MIB_IPFORWARDROW& route, const MIB_IPFORWARDTABLE& RouteTable);
PMIB_IPFORWARDROW GetDefaultGateway(PMIB_IPFORWARDTABLE pRouteTable);

//
//  Helper functions
//
BOOL ConvertSzToIP(LPSTR sz, DWORD& dwIP);
LPTSTR IPtoTsz(DWORD dw);
LPSTR IPtosz(DWORD dwIP, char *psz);
LPSTR StrCpyWithoutQuotes(LPSTR pszDest, LPCSTR pszSrc);
BOOL VerifyProfileAndGetServiceDir(LPSTR pszProfile);

//
//  IP Helper function prototypes
//
typedef DWORD (WINAPI *pfnCreateIpForwardEntrySpec)(PMIB_IPFORWARDROW);
typedef DWORD (WINAPI *pfnDeleteIpForwardEntrySpec)(PMIB_IPFORWARDROW);
typedef DWORD (WINAPI *pfnGetIpForwardTableSpec)(PMIB_IPFORWARDTABLE, PULONG, BOOL);

pfnCreateIpForwardEntrySpec g_pfnCreateIpForwardEntry = NULL;
pfnDeleteIpForwardEntrySpec g_pfnDeleteIpForwardEntry = NULL;
pfnGetIpForwardTableSpec g_pfnGetIpForwardTable = NULL;
HMODULE g_hIpHlpApi = NULL;

#if DBG
void PrintRouteTable();
#endif

//+----------------------------------------------------------------------------
//
// Func:    FreeIpHlpApis
//
// Desc:    This function frees the instance of iphlpapi.dll loaded through
//          LoadIpHelpApis.  Note that it also sets the module handle and all
//          of the function pointers loaded from this module to NULL.
//
// Args:    None
//
// Return:  Nothing
//
// Notes:   
//
// History: 14-Dec-2000   quintinb      Created
//
//-----------------------------------------------------------------------------
void FreeIpHlpApis(void)
{
    if (g_hIpHlpApi)
    {
        FreeLibrary(g_hIpHlpApi);
        g_hIpHlpApi = NULL;
        g_pfnCreateIpForwardEntry = NULL;
        g_pfnDeleteIpForwardEntry = NULL;
        g_pfnGetIpForwardTable = NULL;
    }
}

//+----------------------------------------------------------------------------
//
// Func:    LoadIpHelpApis
//
// Desc:    This functions loads a copy of the iphlpapi.dll and then retrieves
//          function pointers for CreateIpForwardEntry, DeleteIpForwardEntry,
//          and GetIpForwardTable.  The module handle and the function pointers
//          are stored in globals vars.
//
// Args:    None
//
// Return:  HRESULT - S_OK on success, S_FALSE on failure.  This prevents cmroute
//                    from returning an error value (which would stop the connection)
//                    but allows cmroute to exit cleanly.
//
// Notes:   
//
// History: 14-Dec-2000   quintinb      Created
//
//-----------------------------------------------------------------------------
HRESULT LoadIpHelpApis(void)
{
    HRESULT hr = S_FALSE; // we want the connection to continue but cmroute to not do anything...
    g_hIpHlpApi = LoadLibrary(TEXT("IPHLPAPI.DLL"));

    if (g_hIpHlpApi)
    {
        g_pfnCreateIpForwardEntry = (pfnCreateIpForwardEntrySpec)GetProcAddress(g_hIpHlpApi, "CreateIpForwardEntry");
        g_pfnDeleteIpForwardEntry = (pfnDeleteIpForwardEntrySpec)GetProcAddress(g_hIpHlpApi, "DeleteIpForwardEntry");
        g_pfnGetIpForwardTable = (pfnGetIpForwardTableSpec)GetProcAddress(g_hIpHlpApi, "GetIpForwardTable");

        if (g_pfnCreateIpForwardEntry && g_pfnDeleteIpForwardEntry && g_pfnGetIpForwardTable)
        {
            hr = S_OK;
        }
        else
        {
            FreeIpHlpApis();
        }
    }

    CMTRACEHR("LoadIpHelpApis", hr);
    return hr;
}

//+----------------------------------------------------------------------------
//
// Func:    SetRoutes
//
// Desc:    The entry point for handling route munging for VPN connections.
//          This is a Connection Manager connect action and uses the CM connect
//          action format (see CMAK docs for more info).  Thus the parameters
//          to the dll are passed via a string which contains parameters (see the
//          cmproxy spec for a list of the parameter values).
//
// Args:    [hWnd]    - window handle of caller
//          [hInst]   - instance handle of caller
//          [pszArgs] - argument string for connect action
//          [nShow]   - unused
//
// Return:  HRESULT
//
// Notes:   
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------

HRESULT WINAPI SetRoutes(HWND hWnd, HINSTANCE hInst, LPSTR pszArgs, int nShow)
{
    HRESULT             hr = S_OK;
    PMIB_IPFORWARDTABLE pRouteTable        = NULL;
    PMIB_IPFORWARDROW   pGateway           = NULL;
    LPSTR               pszRoutesFromFile  = NULL;
    DWORD               cbRoutesFromFile   = 0;
    LPSTR               pszRoutesFromURL   = NULL;
    DWORD               cbRoutesFromURL    = 0;
    // results of parsing the commandline
    BOOL                fUseFile = FALSE;
    BOOL                fUseURL = FALSE;
    BOOL                fProfile = FALSE;
    BOOL                fURLNotFoundIsNotFatal = FALSE;
    BOOL                fStayAliveOnAccessDenied = FALSE;
    BOOL                fDeleteDefaultGatewayViaFile = FALSE;
    BOOL                fDeleteDefaultGatewayViaURL = FALSE;
    BOOL                fKeepTempFiles = FALSE;
    char                szRoutesFile[MAX_PATH + 1];
    char                szRoutesURL[MAX_PATH + 1];
    char                szProfile[MAX_PATH + 1];

#if 0
/*
    // start security check to block unauthorized users
    // REVIEW: remove before shipping!

    //
    // Quick and dirty security test. See if we can open hard-coded file first.
    // If file is not available, then bail out completely.
    // 
    
    lstrcpy(szRoutesFile, "\\\\sherpa\\route-plumb\\msroutes.txt");

    HANDLE hFile = CreateFile(szRoutesFile,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    if (INVALID_HANDLE_VALUE == hFile)
    {
        CMTRACE1("Unable to access file %s\n", szRoutesFile);
        MessageBox(NULL, "You are not authorized to use this tool.",
                   "CMROUTE.DLL Custom Action", MB_OK);
        CloseHandle(hFile);
        return E_ACCESSDENIED;
    }
    
    CloseHandle(hFile);

    // end security check
*/
#endif

    //
    //  See if we can get the function pointers we need in IP helper?
    //

    hr = LoadIpHelpApis();

    if (S_OK != hr)
    {
        goto Cleanup;
    }

    //
    //  parse args
    //
    hr = ParseArgs(pszArgs,
                   &fUseFile,
                   szRoutesFile,
                   &fUseURL,
                   szRoutesURL,
                   &fProfile,
                   szProfile,
                   &fURLNotFoundIsNotFatal,
                   &fStayAliveOnAccessDenied,
                   &fKeepTempFiles);
    if (S_OK != hr)
    {
        goto Cleanup;
    }

#if 0
// see note below
    hr = CheckIPForwarding();
    if (S_FALSE == hr)
    {
        CMTRACE("SetRoutes: IP forwarding is enabled - cmroute won't do anything");
        hr = S_OK;
        goto Cleanup;
    }
    if (S_OK != hr)
    {
        goto Cleanup;
    }
#endif

#if DBG
    PrintRouteTable();
#endif

    //
    //  Get the routetable and default gateway
    //
    hr = Initialize(&pRouteTable, &pGateway);
    if (S_OK != hr)
    {
        goto Cleanup;
    }

    //
    //  Get the routes out of the file if asked
    //
    if (fUseFile)
    {
        hr = GetRoutesFromFile(szRoutesFile,
                               (fProfile ? szProfile : NULL),
                               &pszRoutesFromFile,
                               &cbRoutesFromFile);
        if (S_OK != hr)
        {
            goto Cleanup;
        }

#if DBG
        OutputDebugString(pszRoutesFromFile);
#endif
    }

    //
    //  Get the routes out of the URL if asked
    //
    if (fUseURL)
    {
        hr = GetRoutesFromURL(szRoutesURL,
                              fKeepTempFiles,
                              &pszRoutesFromURL,
                              &cbRoutesFromURL);
        if (S_OK != hr)
        {
            //
            //  It might have been worth adding a clause below to restrict this
            //  to "failures to access the URL", but this list of errorcodes is
            //  likely to be large (and if the system is really hosed, we'll find
            //  out soon enough).  So, bypass *all* errors if /DONT_REQUIRE_URL
            //  is set.
            //
            if (fURLNotFoundIsNotFatal)
            {
                //
                //  If URL_Access_Failure_Not_Fatal is set, don't return an error.
                //  However, we unset the flag so that we stop processing the URL.
                //
                CMTRACE("SetRoutes: dont_require_url is set, bypassing error");
                fUseURL = FALSE;
                hr = S_OK;
            }
            else
            {
                goto Cleanup;
            }
        }
        
#if DBG
        OutputDebugString(pszRoutesFromURL);
#endif
    }

    //
    //  Now set the routes
    //
    MYDBGASSERT(S_OK == hr);
    if (fUseFile)
    {
        hr = ProcessRouteInfo(pszRoutesFromFile, cbRoutesFromFile, pRouteTable, pGateway, &fDeleteDefaultGatewayViaFile);
        if (S_OK != hr)
        {
            CMTRACE1("SetRoutes: adding routes from FILE failed with %x", hr);
            goto Cleanup;
        }
    }

    MYDBGASSERT(S_OK == hr);
    if (fUseURL)
    {
        hr = ProcessRouteInfo(pszRoutesFromURL, cbRoutesFromURL, pRouteTable, pGateway, &fDeleteDefaultGatewayViaURL);
        if (S_OK != hr)
        {
            if ((E_UNEXPECTED == hr) && fURLNotFoundIsNotFatal)
            {
                // we use E_UNEXPECTED to indicate that the URL points to a .htm file
                // instead of the file containing just routes which is what we're
                // expecting.  In this case, we ignore this error.
                //
                CMTRACE("html string found error ignored because Dont_Require_URL is set");
                hr = S_OK;
            }
            else
            {
                CMTRACE1("SetRoutes: adding routes from URL failed with %x", hr);
                goto Cleanup;
            }
        }
    }

    //
    //  Delete default gateway
    //
    MYDBGASSERT(S_OK == hr);
    if (fDeleteDefaultGatewayViaFile || fDeleteDefaultGatewayViaURL)
    {
        hr = DeleteDefaultGateway(pGateway);
    }

Cleanup:
    //
    //  cleanup and leave
    //
    if (pRouteTable)
    {
        VirtualFree(pRouteTable, 0, MEM_RELEASE);
    }

    FreeIpHlpApis();

    //
    //  If we failed because of an access denied error from iphlpapi, but the admin
    //  has set the flag to keep the connection alive anyway, mask the error.
    //
    if ((HRESULT_FROM_WIN32(ERROR_NETWORK_ACCESS_DENIED) == hr) &&
        fStayAliveOnAccessDenied)
    {
        CMTRACE("SetRoutes: masking ERROR_NETWORK_ACCESS_DENIED because of StayAlive flag");
        hr = S_FALSE;
    }

    CMTRACEHR("SetRoutes", hr);
    return hr;
}

//+----------------------------------------------------------------------------
//
// Func:    GetNextToken
//
// Desc:    utility function for parsing the argument string.  Goes past leading
//          whitespace and extracts a string
//
// Args:    [pszStart] - IN  the argument string
//          [ppszEnd]  - OUT where parsing for this arg ended
//          [pszOut]   - INOUT array of size MAX_PATH to hold arg if found
//
// Return:  BOOL, TRUE if another arg found, FALSE if not
//
// Notes:   
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
GetNextToken(LPSTR pszStart, LPSTR * ppszEnd, LPSTR pszOut)
{
    MYDBGASSERT(pszStart);
    MYDBGASSERT(ppszEnd);

    LPSTR pszEnd = NULL;

    // clear leading white space
    while (isspace(*pszStart))
    {
        pszStart++;
    }

    if (NULL == *pszStart)
    {
        // just white space, no arg
        return FALSE;
    }

    //
    //  If this character is ", this is probably a quoted string, containing spaces.
    //  In this case, the termination character is another ".  Otherwise, assume
    //  it is a regular string terminated by a space.
    //
    if ('"' == *pszStart)
    {
        // may be a string containing spaces.
        pszEnd = strchr(pszStart + 1, '"');
    }

    if (NULL == pszEnd)
    {
        //
        //  Either it's a regular string, or we couldn't find a terminating " char
        //  so we fall back on space-delimited handling.
        //
        pszEnd = pszStart + 1;
        while (*pszEnd && !isspace(*pszEnd))
        {
            pszEnd++;
        }
        pszEnd--;
    }

    UINT cLen = (UINT)(pszEnd - pszStart + 1);

    if (cLen + 1 > MAX_PATH)
    {
        return FALSE;
    }
    else
    {
        lstrcpyn(pszOut, pszStart, cLen + 1);
        *ppszEnd = ++pszEnd;
        return TRUE;
    }
}


//+----------------------------------------------------------------------------
//
// Func:    Initialize
//
// Desc:    Initialization function, gets the route table and default gateway
//
// Args:    [ppmibRouteTable] - return location for route table
//          [ppGateway] - return location for default gateway
//
// Return:  HRESULT
//
// Notes:   
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
Initialize(
    OUT PMIB_IPFORWARDTABLE * ppmibRouteTable,
    OUT PMIB_IPFORWARDROW * ppGateway)
{
    HRESULT hr = S_OK;

    MYDBGASSERT(ppmibRouteTable);
    MYDBGASSERT(ppGateway);

    if (NULL == ppmibRouteTable || NULL == ppGateway)
    {
        return E_INVALIDARG;
    }

    hr = GetRouteTable(ppmibRouteTable);

    if (S_OK == hr)
    {
        MYDBGASSERT(*ppmibRouteTable);
        *ppGateway = GetDefaultGateway(*ppmibRouteTable);
    }

    CMTRACEHR("Initialize", hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    ParseArgs
//
// Desc:    convert the argument list into flags for our use.
//
// Args:    [pszArgList] - IN, the argument list
//          [the rest]   - OUT, all the arg values returned
//
// Return:  HRESULT
//
// Notes:   
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
ParseArgs(
    LPSTR pszArgList,
    BOOL * pfUseFile,
    LPSTR pszRoutesFile,
    BOOL * pfUseURL,
    LPSTR pszRoutesURL,
    BOOL * pfProfile,
    LPSTR pszProfile,
    BOOL * pfURLNotFoundIgnorable,
    BOOL * pfStayAliveOnAccessDenied,
    BOOL * pfKeepTempFiles)
{
    HRESULT hr = S_OK;
    char    szArg[MAX_PATH];

    //
    //  verify arguments
    //
    if (NULL == pszArgList || 0 == lstrlen(pszArgList) ||
        !pfUseFile || !pszRoutesFile || !pfUseURL || !pszRoutesURL ||
        !pfProfile || !pszProfile ||
        !pfURLNotFoundIgnorable ||
        !pfKeepTempFiles)

    {
        return E_INVALIDARG;
    }

    CMTRACE1("ParseArgs: arg list is %s", pszArgList);

    //
    //  set the defaults
    //
    *pfUseFile = *pfUseURL = *pfProfile = *pfURLNotFoundIgnorable = FALSE;

    //
    //  process the Arglist
    //
    while (GetNextToken(pszArgList, &pszArgList, szArg))
    {
         if (0 == SafeCompareString("/Static_File_Name", szArg))
        {
            *pfUseFile = TRUE;

            if (!GetNextToken(pszArgList, &pszArgList, szArg))
            {
                return E_INVALIDARG;
            }

            if (lstrlen(szArg) > MAX_PATH)
            {
                CMTRACE("ParseArgs: file name is bigger than MAX_PATH!!");
                return E_INVALIDARG;
            }

            StrCpyWithoutQuotes(pszRoutesFile, szArg);
        }
        else if (0 == SafeCompareString("/Dont_Require_URL", szArg))
        {
            *pfURLNotFoundIgnorable = TRUE;
        }
        else if (0 == SafeCompareString("/URL_Update_Path", szArg))
        {
            *pfUseURL = TRUE;

            if (!GetNextToken(pszArgList, &pszArgList, szArg))
            {
                return E_INVALIDARG;
            }
            if (lstrlen(szArg) > MAX_PATH)
            {
                CMTRACE("ParseArgs: URL name is bigger than MAX_PATH!!");
                return E_INVALIDARG;
            }

            lstrcpy(pszRoutesURL, szArg);
        }
        else if (0 == SafeCompareString("/Profile", szArg))
        {
            *pfProfile = TRUE;

            if (!GetNextToken(pszArgList, &pszArgList, szArg))
            {
                return E_INVALIDARG;
            }
            if (lstrlen(szArg) > MAX_PATH)
            {
                CMTRACE("ParseArgs: Profile filename is bigger than MAX_PATH!!");
                return E_INVALIDARG;
            }

            StrCpyWithoutQuotes(pszProfile, szArg);
        }
        else if (0 == SafeCompareString("/IPHlpApi_Access_Denied_OK", szArg))
        {
            *pfStayAliveOnAccessDenied = TRUE;
        }
        else if (0 == SafeCompareString("/No_Delete", szArg))
        {
            *pfKeepTempFiles = TRUE;
        }
        else
        {
            CMTRACE1("Cmroute: unrecognized parameter - %s", szArg);
            MYDBGASSERT("Cmroute - unrecognized parameter!!");
        }
    }

    CMTRACEHR("ParseArgs", hr);
    return hr;
}


#if 0

//  2000/11/28 SumitC
//  It wasn't clear what the required action should be when IP forwarding was
//  detected (should the connection be dropped or not) and it is a little late
//  to add UI to Whistler.  The 'Check IP forwarding' feature is thus removed.
//
// see Windows Db bug # 216558 for more details.

//+----------------------------------------------------------------------------
//
// Func:    CheckIPForwarding
//
// Desc:    checks to see if anything is enabled on the client machine that would
//          make us want to have cmroute not do anything
//
// Args:    none
//
// Return:  HRESULT
//
// Notes:   
//
// History: 01-Nov-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
CheckIPForwarding()
{
    HRESULT     hr = S_OK;
    MIB_IPSTATS stats;

    if (NO_ERROR != GetIpStatistics(&stats))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        if (stats.dwForwarding)
        {
            hr = S_FALSE;
        }
    }

    CMTRACEHR("CheckIPForwarding", hr);
    return hr;
}
#endif

//+----------------------------------------------------------------------------
//
// Func:    GetRoutesFromFile
//
// Desc:    extracts the contents of the given file
//
// Args:    [pszFileName]          - IN, filename
//          [pszProfile]           - IN, profile if available
//          [ppszRouteInfo]        - OUT, the route table bytes
//          [pcbRouteInfo]         - OUT, the route table size
//
// Return:  HRESULT
//
// Notes:   
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
GetRoutesFromFile(
    LPSTR pszFileName,
    LPSTR pszProfile,
    LPSTR * ppszRouteInfo,
    DWORD * pcbRouteInfo)
{
    HRESULT hr = S_OK;
    HANDLE  hFile = NULL;
    LPSTR   psz = NULL;
    DWORD   cb = 0;
    BOOL    fRet;
    BY_HANDLE_FILE_INFORMATION info;

    MYDBGASSERT(pszFileName);
    MYDBGASSERT(ppszRouteInfo);
    MYDBGASSERT(pcbRouteInfo);

    if (NULL == pszFileName || NULL == ppszRouteInfo || NULL == pcbRouteInfo)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    CMTRACE1("GetRoutesFromFile: filename is %s", pszFileName);

    //
    //  open the file, and read its contents into a buffer
    //
    hFile = CreateFile(pszFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        //
        //  perhaps the full pathname for the routes file wasn't specified.  If
        //  a Profile was passed in, we extract the ServiceDir and try again,
        //  using the ServiceDir as the path.
        //
        if (VerifyProfileAndGetServiceDir(pszProfile))
        {
            char sz[2 * MAX_PATH + 1];

            lstrcpy(sz, pszProfile);
            lstrcat(sz, pszFileName);

            CMTRACE1("GetRoutesFromFile: retrying with %s", sz);

            hFile = CreateFile(sz, GENERIC_READ, FILE_SHARE_READ, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        }

        if (INVALID_HANDLE_VALUE == hFile)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }
    }

    if (FALSE == GetFileInformationByHandle(hFile, &info))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (0 == info.nFileSizeLow)
    {
        CMTRACE("Routes file is EMPTY!!");
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto Cleanup;
    }

    psz = (LPSTR) VirtualAlloc(NULL, info.nFileSizeLow, MEM_COMMIT, PAGE_READWRITE);
    if (NULL == psz)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    fRet = ReadFile(hFile, psz, info.nFileSizeLow, &cb, NULL);
    if (FALSE == fRet)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // success

    *ppszRouteInfo = psz;
    *pcbRouteInfo = cb;

Cleanup:
    if (hFile)
    {
        CloseHandle(hFile);
    }
    if (S_OK != hr)
    {
        VirtualFree(psz, 0, MEM_RELEASE);
    }

    CMTRACEHR("GetRoutesFromFile", hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    GetRoutesFromURL
//
// Desc:    extracts the contents of the given URL
//
// Args:    [pszURL]               - IN, the URL
//          [fKeepTempFiles]       - IN, do not delete temp buffer file(s)
//          [ppszRouteInfo]        - OUT, the route table bytes
//          [pcbRouteInfo]         - OUT, the route table size
//
// Return:  HRESULT
//
// Notes:   
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
GetRoutesFromURL(
    LPSTR pszURL,
    BOOL fKeepTempFiles,
    LPSTR * ppszRouteInfo,
    DWORD * pcbRouteInfo)
{
    HRESULT     hr = S_OK;
    HINTERNET   hInternet = NULL;
    HINTERNET   hPage = NULL;
    LPBYTE      pb = NULL;
    DWORD       cb = 0;
    TCHAR       szLocalBufferFile[MAX_PATH + 1];
    DWORD       cchLocalBuffer = 0;
    LPTSTR      pszLocalBuffer = NULL;
    FILE *      fp = NULL;
    BYTE        Buffer[1024];
    DWORD       dwRead;

    MYDBGASSERT(pszURL);
    MYDBGASSERT(ppszRouteInfo);
    MYDBGASSERT(pcbRouteInfo);

    if (NULL == pszURL || NULL == ppszRouteInfo || NULL == pcbRouteInfo)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    CMTRACE1("GetRoutesFromURL: URL is %s", pszURL);

    //
    //  Get the path to the temp dir, if there is one.
    //
    cchLocalBuffer = GetTempPath(0, NULL);
    if (0 == cchLocalBuffer)
    {
        DWORD dwErr = GetLastError();
        CMTRACE1(TEXT("GetTempPath failed, using current dir, GLE=%d"), dwErr);
    }
    else
    {
        cchLocalBuffer += (lstrlen(TEXT("\\")) + lstrlen(szLocalBufferFile) + 1);

        pszLocalBuffer = (LPTSTR) VirtualAlloc(NULL,
                                               cchLocalBuffer * sizeof(TCHAR),
                                               MEM_COMMIT,
                                               PAGE_READWRITE);
        if (NULL == pszLocalBuffer)
        {
            hr = E_OUTOFMEMORY;
            CMTRACE(TEXT("GetRoutesFromURL - VirtualAlloc failed"));
            goto Cleanup;
        }

        if (0 == GetTempPath(cchLocalBuffer, pszLocalBuffer))
        {
            DWORD dwErr = GetLastError();
            CMTRACE1(TEXT("GetTempPath 2nd call failed, GLE=%d"), GetLastError());
            hr = HRESULT_FROM_WIN32(dwErr);
            goto Cleanup;
        }
    }

    //
    //  Get a name for the temp file (using the temp path if there is one)
    //
    if (0 == GetTempFileName(pszLocalBuffer ? pszLocalBuffer : TEXT("."),
                             TEXT("CMR"),
                             0,
                             szLocalBufferFile))
    {
        DWORD dwErr = GetLastError();
        CMTRACE1(TEXT("GetTempFileName failed, GLE=%d"), dwErr);
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Cleanup;
    }

    //
    //  Open the temp file, and proceed.
    //
    fp = fopen(szLocalBufferFile, "w+b");
    if (NULL == fp)
    {
        CMTRACE1(TEXT("fopen failed(%s)"), szLocalBufferFile);
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Initialize WININET
    //
    hInternet = InternetOpen(TEXT("RouteMan"), INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (NULL == hInternet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CMTRACE1(TEXT("InternetOpen failed with 0x%x"), hr);
        goto Cleanup;
    }

    //
    // Supress auto-dial calls to CM from WININET now that we have a handle
    //
    SuppressInetAutoDial(hInternet);

    //
    //  Make sure that WinInet isn't in offline mode
    //
    (VOID)SetInetStateConnected(hInternet);

    //
    //  Open the URL
    //
    hPage = InternetOpenUrl(hInternet, pszURL, NULL, 0, 0, 0);

    if (NULL == hPage)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CMTRACE1(TEXT("InternetOpenUrl failed with 0x%x"), hr);
        goto Cleanup;
    }

    //
    //  Read the entire URL contents into the tempfile
    //
    do
    {
        if (!InternetReadFile(hPage, Buffer, sizeof(Buffer), &dwRead))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CMTRACE1(TEXT("InternetReadFile failed with 0x%x"), hr);
            goto Cleanup;
        }

        if (fwrite(Buffer, sizeof(BYTE), dwRead, fp) != dwRead)
        {
            CMTRACE1(TEXT("write failed to %s"), pszLocalBuffer);
            hr = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
            goto Cleanup;
        }

        cb += dwRead;

#if 0
        // ISSUE-2000/07/21-SumitC Code seems strange but might need it later
        //
        // Vijay/Andrew's original code has this, but is this correct?
        // The doc for InternetReadFile says this is just an EOF, if we
        // are to handle this case at all, we should just break;
        if (!dwRead)
            goto Cleanup;
#endif        
    }
    while (dwRead == 1024);

    hr = S_OK;

    if (fseek(fp, SEEK_SET, 0) != 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pb = (LPBYTE) VirtualAlloc(NULL, cb, MEM_COMMIT, PAGE_READWRITE);
    if (NULL == pb)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (fread(pb, sizeof(BYTE), cb, fp) != cb)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // success

    *ppszRouteInfo = (LPSTR) pb;
    *pcbRouteInfo = cb;

Cleanup:

    if (fp)
    {
        fclose(fp);
    }
    if (FALSE == fKeepTempFiles)
    {
        remove(szLocalBufferFile);
    }

    if (pszLocalBuffer && cchLocalBuffer)
    {
        VirtualFree(pszLocalBuffer, 0, MEM_RELEASE);
    }

    if (hPage)
    {
        InternetCloseHandle(hPage);
    }
    
    if (hInternet)
    {
        InternetCloseHandle(hInternet);
    }

    if (S_OK != hr)
    {
        VirtualFree(pb, 0, MEM_RELEASE);
    }

    CMTRACEHR("GetRoutesFromURL", hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    ProcessRouteInfo
//
// Desc:    Parses the given route table and modifies the real routetable accordingly
//
// Args:    [pszNewRouteInfo] - IN, bytes of route table to parse and add to the real one
//          [cbNewRouteInfo]  - IN, size of routetable
//          [pmibRouteTable]  - IN, real route table
//          [pGateway]        - IN, default gateway
//          [pfDeleteGateway] - OUT, does the route file say to delete default gateway?
//
// Return:  HRESULT (E_INVALIDARG, E_UNEXPECTED - for html file, etc)
//
// Notes:   
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
ProcessRouteInfo(
    const LPSTR pszNewRouteInfo,
    DWORD cbNewRouteInfo,
    PMIB_IPFORWARDTABLE pmibRouteTable,
    PMIB_IPFORWARDROW pGateway,
    BOOL * pfDeleteDefaultGateway)
{
    HRESULT hr = S_OK;
    DWORD   cLines = 0;
    char    szBuf[MAX_PATH];
    LPSTR   pszNextLineToProcess;

    MYDBGASSERT(pszNewRouteInfo);
    MYDBGASSERT(cbNewRouteInfo);
    MYDBGASSERT(pmibRouteTable);
    MYDBGASSERT(pGateway);
    MYDBGASSERT(pfDeleteDefaultGateway);

    if (!pszNewRouteInfo || !cbNewRouteInfo || !pmibRouteTable || !pGateway || !pfDeleteDefaultGateway)
    {
        return E_INVALIDARG;
    }

    if ((NULL == g_pfnCreateIpForwardEntry) || (NULL == g_pfnDeleteIpForwardEntry))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
    }

    *pfDeleteDefaultGateway = FALSE;

    // Make sure WININET zero terminates this....
    pszNewRouteInfo[cbNewRouteInfo] = '\0';

    //
    //  Convert string to lower
    //
    CharLowerA(pszNewRouteInfo);

    //
    //  sanity checks (in the URL case, if the route file isn't found the server
    //  is likely to return an HTML file to indicate 404 - file not found.)
    //
    if (strstr(pszNewRouteInfo, "<html"))
    {
        CMTRACE("html string found - invalid route file\n");
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    //  for each line
    //
    for (;;)
    {
        DWORD               ipDest, ipMask, ipGateway, ipMetric;
        DWORD               dwIf = -1;
        DWORD               dwParam;
        LPSTR               psz;        // temp var to hold each line as we process it
        MIB_IPFORWARDROW    route;

        enum { VERB_ADD, VERB_DELETE } eVerb;

        //
        //  Per strtok syntax, use pszNewRouteInfo the first time, and NULL thereafter
        //
        psz = strtok(((0 == cLines) ? pszNewRouteInfo : NULL), "\n\0");
        if (NULL == psz)
            break;

        ++cLines;

        //
        //  All errors within the for statement are due to bad data within the file
        //
        hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);

        //
        //  PART 1 : add/delete, followed by the IP address, or remove_gateway
        //
        if (FALSE == GetNextToken(psz, &psz, szBuf))
        {
            CMTRACE1("ProcessRouteInfo [%d] didn't find add/delete which is required", cLines);
            goto Cleanup;
        }

        if (0 == SafeCompareString(szBuf, "add"))
        {
            eVerb = VERB_ADD;
        }
        else if (0 == SafeCompareString(szBuf, "delete"))
        {
            eVerb = VERB_DELETE;
        }
        else if (0 == SafeCompareString(szBuf, "remove_gateway"))
        {
            *pfDeleteDefaultGateway = TRUE;
            hr = S_OK;
            // ignore the rest of the line
            continue;
        }
        else
        {
            CMTRACE2("ProcessRouteInfo [%d] found unexpected string %s instead of add/delete/remove_gateway", cLines, szBuf);
            goto Cleanup;
        }

        if (FALSE == GetNextToken(psz, &psz, szBuf))
        {
            CMTRACE1("ProcessRouteInfo [%d] dest ip required for add/delete, and is missing", cLines);
            goto Cleanup;
        }
        
        if (FALSE == ConvertSzToIP(szBuf, ipDest))
        {
            CMTRACE2("ProcessRouteInfo [%d] required ip address/mask %s has bad format", cLines, szBuf);
            goto Cleanup;
        }

        //
        //  PART 2 : mask, followed by the IP address (NOT REQUIRED)
        //
        if (FALSE == GetNextToken(psz, &psz, szBuf))
        {
            CMTRACE1("ProcessRouteInfo [%d] ends too early after add/delete", cLines);
            goto Cleanup;
        }

        if (0 == SafeCompareString(szBuf, "mask"))
        {
            if (FALSE == GetNextToken(psz, &psz, szBuf))
            {
                CMTRACE1("ProcessRouteInfo [%d] ip required for mask, and is missing", cLines);
                goto Cleanup;
            }

            if (FALSE == ConvertSzToIP(szBuf, ipMask))
            {
                CMTRACE2("ProcessRouteInfo [%d] required ip address/mask %s has bad format", cLines, szBuf);
                goto Cleanup;
            }

            if (FALSE == GetNextToken(psz, &psz, szBuf))
            {
                CMTRACE1("ProcessRouteInfo [%d] ends too early after mask", cLines);
                goto Cleanup;
            }
        }
        else
        {
            CMTRACE1("ProcessRouteInfo [%d] didn't find \"mask\", that's ok, continuing", cLines);
            ipMask = (DWORD)-1;
        }

        //
        //  PART 3 : gateway (or "default")
        //
        if (0 == SafeCompareString(szBuf, "default"))
        {
            ipGateway = pGateway->dwForwardNextHop;
        }
        else
        {
            if (FALSE == ConvertSzToIP(szBuf, ipGateway))
            {
                CMTRACE2("ProcessRouteInfo [%d] bad format for gateway %s", cLines, szBuf);
                goto Cleanup;
            }
        }

        //
        //  PART 4 : metric, followed by a number (REQUIRED)
        //
        if (FALSE == GetNextToken(psz, &psz, szBuf))
        {
            CMTRACE1("ProcessRouteInfo [%d] didn't find \"metric\" which is required", cLines);
            goto Cleanup;
        }

        if (0 == SafeCompareString(szBuf, "metric"))
        {
            if (FALSE == GetNextToken(psz, &psz, szBuf))
            {
                CMTRACE1("ProcessRouteInfo [%d] number value after \"metric\" missing", cLines);
                goto Cleanup;
            }

            if (0 == SafeCompareString(szBuf, "default"))
            {
                ipMetric = pGateway->dwForwardMetric1;
            }
            else
            {
                if (FALSE == ConvertSzToIP(szBuf, ipMetric))
                {
                    CMTRACE2("ProcessRouteInfo [%d] required ip metric %s has bad format", cLines, szBuf);
                    goto Cleanup;
                }

/*
#if 0
                dwParam = sscanf(szBuf, "%d", &ipMetric);
                if (0 == dwParam)
                {
                    CMTRACE2("ProcessRouteInfo [%d] bad format for metric value - %s", cLines, szBuf);
                    goto Cleanup;
                }
#endif
*/
            }
        }
        else
        {
            CMTRACE2("ProcessRouteInfo [%d] found unexpected string %s instead of \"metric\"", cLines, szBuf);
            goto Cleanup;
        }

        //
        //  PART 5 : if (the interface), followed by a number (REQUIRED)
        //
        if (FALSE == GetNextToken(psz, &psz, szBuf))
        {
            CMTRACE1("ProcessRouteInfo [%d] didn't find \"if\" which is required", cLines);
            goto Cleanup;
        }

        if (0 == SafeCompareString(szBuf, "if"))
        {
            if (FALSE == GetNextToken(psz, &psz, szBuf))
            {
                CMTRACE1("ProcessRouteInfo [%d] number value after \"if\" missing", cLines);
                goto Cleanup;
            }

            if (0 == SafeCompareString(szBuf, "default"))
            {
                dwIf = pGateway->dwForwardIfIndex;
            }
            else
            {
                dwParam = sscanf(szBuf, "%d", &dwIf);
                if (0 == dwParam)
                {
                    CMTRACE2("ProcessRouteInfo [%d] bad format for if value - %s", cLines, szBuf);
                    goto Cleanup;
                }
            }
        }
        else
        {
            CMTRACE2("ProcessRouteInfo [%d] found unexpected string %s instead of \"if\"", cLines, szBuf);
            goto Cleanup;
        }

        //
        //  Run the verb (add or delete)
        //
        ZeroMemory(&route, sizeof(route));

        route.dwForwardDest      = ipDest;
        route.dwForwardIfIndex   = dwIf;
        route.dwForwardMask      = ipMask;
        route.dwForwardMetric1   = ipMetric;
        route.dwForwardNextHop   = ipGateway;

        route.dwForwardPolicy    = 0;
        route.dwForwardNextHopAS = 0;
        route.dwForwardType      = 3;
        route.dwForwardProto     = 3;
        route.dwForwardAge       = INFINITE;
        route.dwForwardMetric2   = 0xFFFFFFFF;
        route.dwForwardMetric3   = 0xFFFFFFFF;
        route.dwForwardMetric4   = 0xFFFFFFFF;
        route.dwForwardMetric5   = 0xFFFFFFFF;

        // ISSUE-2000/07/21-SumitC Can we ever really get here in the code with dwIf == -1 ?
        //
        // Check that the interface was specified
        if (-1 == dwIf)
        {
            // Nope, lets go pick one
            dwIf = GetIf(route, *pmibRouteTable);
        }

        DWORD dwRet = 0;

        switch (eVerb)
        {
        case VERB_ADD:
            dwRet = g_pfnCreateIpForwardEntry(&route);
            if (ERROR_SUCCESS != dwRet)
            {
                // NETWORK_ACCESS_DENIED (0x41=65) is special-cased at the end of SetRoutes
                CMTRACE2("ProcessRouteInfo [%d] CreateIpForwardEntry failed with %d", cLines, dwRet);
                hr = HRESULT_FROM_WIN32(dwRet);
                goto Cleanup;
            }
            hr = S_OK;
            break;
        case VERB_DELETE:
            dwRet = g_pfnDeleteIpForwardEntry(&route);
            if (ERROR_SUCCESS != dwRet)
            {
                // NETWORK_ACCESS_DENIED (0x41=65) is special-cased at the end of SetRoutes
                CMTRACE2("ProcessRouteInfo [%d] DeleteIpForwardEntry failed with %d", cLines, dwRet);
                hr = HRESULT_FROM_WIN32(dwRet);
                goto Cleanup;
            }
            hr = S_OK;
            break;
        default:
            CMTRACE("ProcessRouteInfo [%d] Unsupported route command, add or delete only");
            MYDBGASSERT(0);
            hr = E_FAIL;
            break;
        }
    }

Cleanup:

    CMTRACEHR("ProcessRouteInfo", hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    DeleteDefaultGateway
//
// Desc:    Deletes the default routing gateway for this system
//
// Args:    [pGateway] - the gateway
//
// Return:  HRESULT
//
// Notes:   This should be the last function called within CMroute, and is called
//          only if all other processing succeeded.
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
DeleteDefaultGateway(PMIB_IPFORWARDROW pGateway)
{
    CMTRACE("DeleteDefaultGateway: entering");

    HRESULT hr = S_OK;
    DWORD dwErr = 0;

    if (NULL == g_pfnDeleteIpForwardEntry)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
        goto Cleanup;    
    }

    dwErr = g_pfnDeleteIpForwardEntry(pGateway);

    if (NO_ERROR != dwErr)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        CMTRACE1("DeleteDefaultGateway failed with error %x", dwErr);
    }

Cleanup:
    CMTRACEHR("DeleteDefaultGateway", hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    IsValidIPAddress
//
// Desc:    Checks to see if given string can be a valid IP address
//
// Args:    [sz] - IN, the string
//
// Return:  BOOL, FALSE means invalid chars were found
//
// History: 20-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
IsValidIPAddress(LPSTR sz)
{
    MYDBGASSERT(sz);

    while ((*sz) && (!isspace(*sz)))
    {
        if ((*sz >= '0') && (*sz <= '9'))
            ;
        else if ((*sz == '.') || (*sz == '*') || (*sz == '?'))
            ;
        else
        {
            CMTRACE1(TEXT("IsValidIPAddress failed on %s\n"), sz);
            MYDBGASSERT("IsValidIPAddress");
            return FALSE;
        }
        ++sz;
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Func:    ConvertSzToIP
//
// Desc:    Converts the given string into a DWORD representing an IP address
//
// Args:    [sz]   - IN, string to convert
//          [dwIP] - OUT BYREF, dword for IP address
//
// Return:  BOOL, FALSE if conversion failed (usually means bad format)
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
ConvertSzToIP(LPSTR sz, DWORD& dwIP)
{
    DWORD dwParams, d1, d2, d3, d4;

    if (FALSE == IsValidIPAddress(sz))
    {
        return FALSE;
    }

    dwParams = sscanf(sz, "%d.%d.%d.%d", &d1, &d2, &d3, &d4);

    if (0 == dwParams)
    {
        MYDBGASSERT("ConvertSzToIP - bad format for IP address");
        return FALSE;
    }
    else if (1 == dwParams)
    {
        dwIP = d1 | 0xffffff00;
    }
    else if (2 == dwParams)
    {
        dwIP = d1 | (d2 << 8) | 0xffff0000;
    }
    else if (3 == dwParams)
    {
        dwIP = d1 | (d2 << 8) | (d3 << 16) | 0xff000000;
    }
    else
    {
        dwIP = d1 | (d2 << 8) | (d3 << 16) | (d4 << 24);
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Func:    GetRouteTable
//
// Desc:    Same as GetIpForwardTable but alloc's the table for you.
//          VirtualFree() the buffer returned.
//
// Args:    [ppTable] - OUT, returned route table
//
// Return:  HRESULT
//
// Notes:   ppTable should be VirtualFree'd by caller.
//
// History: 24-Feb-1999   AnBrad      Created
//          22-Mar-2000   SumitC      Rewrote
//
//-----------------------------------------------------------------------------
HRESULT
GetRouteTable(PMIB_IPFORWARDTABLE * ppTable)
{
    DWORD               dwErr = NO_ERROR;
    DWORD               cbbuf = 0;
    PMIB_IPFORWARDTABLE p = NULL;
    HRESULT             hr = S_OK;

    MYDBGASSERT(ppTable);

    //
    //  Make sure we have a function pointer for GetIpForwardTable
    //
    if (NULL == g_pfnGetIpForwardTable)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
        goto Cleanup;
    }

    //
    //  Get the route table
    //
    dwErr = g_pfnGetIpForwardTable(NULL, &cbbuf, FALSE);

    if (ERROR_INSUFFICIENT_BUFFER != dwErr)
    {
        // hmm, a real error
        hr = HRESULT_FROM_WIN32(ERROR_UNEXP_NET_ERR);
        goto Cleanup;
    }
    else
    {
        p = (PMIB_IPFORWARDTABLE) VirtualAlloc(NULL, cbbuf, MEM_COMMIT, PAGE_READWRITE);

        if (!p)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        if (g_pfnGetIpForwardTable(p, &cbbuf, TRUE))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        *ppTable = p;
    }    

Cleanup:
    if (S_OK != hr)
    {
        if (p)
        {
            VirtualFree(p, 0, MEM_RELEASE);
        }
    }

    CMTRACEHR("GetRouteTable", hr);
    return hr;
}

//+----------------------------------------------------------------------------
//
// Func:    GetIf
//
// Desc:    Find the interface for a route
//
// Args:    [route]      - IN, route for which we need the Interface
//          [RouteTable] - IN, route table
//
// Return:  DWORD which is the IF
//
// Notes:   Logic stolen from \nt\private\net\sockets\strmtcp\route
//
// History: 24-Feb-1999   AnBrad      Created
//          22-Mar-2000   SumitC      Cleaned up
//
//-----------------------------------------------------------------------------
DWORD
GetIf(const MIB_IPFORWARDROW& route, const MIB_IPFORWARDTABLE& RouteTable)
{
    for(DWORD dwIndex = 0; dwIndex < RouteTable.dwNumEntries; dwIndex++)
    {
        const MIB_IPFORWARDROW& Row = RouteTable.table[dwIndex];
        
        if (Row.dwForwardMask && 
            (Row.dwForwardDest & Row.dwForwardMask) == 
            (route.dwForwardNextHop & Row.dwForwardMask))
        {
            return Row.dwForwardIfIndex;
        }         
    }

    return 0;
}


//+----------------------------------------------------------------------------
//
// Func:    GetDefaultGateway
//
// Desc:    Find the default gateway
//
// Args:    [pRouteTable] - IN, the route table (IP forward table)
//
// Return:  PMIB_IPFORWARDROW the row of the gateway (a ptr within pRouteTable)
//
// Notes:   Do not free returned value
//
// History: 24-Feb-1999   AnBrad      Created
//          22-Mar-2000   SumitC      Cleaned up
//
//-----------------------------------------------------------------------------
PMIB_IPFORWARDROW
GetDefaultGateway(PMIB_IPFORWARDTABLE pRouteTable)
{
    PMIB_IPFORWARDROW pRow, pDefGateway;

    // Cycle thru the entire table & find the gateway with the least metric
    pDefGateway = NULL;
    for(pRow = pRouteTable->table; pRow != pRouteTable->table + pRouteTable->dwNumEntries; ++pRow)
    {
        if (pRow->dwForwardDest == 0)
        {
            if (pDefGateway == NULL)
            {
                pDefGateway = pRow;
            }
            else
            {
                if (pRow->dwForwardMetric1 == pDefGateway->dwForwardMetric1 &&
                    pRow->dwForwardAge >= pDefGateway->dwForwardAge)
                {
                    pDefGateway = pRow;
                }
                
                if (pRow->dwForwardMetric1 < pDefGateway->dwForwardMetric1)
                {
                    pDefGateway = pRow;
                }
            }
        }
    }
    
    return pDefGateway;
}


//+----------------------------------------------------------------------------
//
// Func:    StrCpyWithoutQuotes
//
// Desc:    Wrapper for lstrcpy, which removes surrounding double quotes if necessary
//
// Args:    [pszDest] - OUT, destination for the copy
//          [pszSrc]  - OUT, source for the copy
//
// Return:  a ptr to pszDest, or NULL if failure.
//
// Notes:   
//
// History: 12-Apr-1999   SumitC    Created
//
//-----------------------------------------------------------------------------
LPSTR
StrCpyWithoutQuotes(LPSTR pszDest, LPCSTR pszSrc)
{
    MYDBGASSERT(pszDest);
    MYDBGASSERT(pszSrc);

    int len = lstrlen(pszSrc);

    if ((len > 2) && ('"' == pszSrc[0]) && ('"' == pszSrc[len - 1]))
    {
        return lstrcpyn(pszDest, &pszSrc[1], len - 1);
    }
    else
    {
        return lstrcpy(pszDest, pszSrc);
    }
}


//+----------------------------------------------------------------------------
//
// Func:    VerifyProfileAndGetServiceDir
//
// Desc:    Checks the given profile, and modifies it to produce the ServiceDir
//
// Args:    [pszProfile] - IN OUT, profile name, modified IN PLACE
//
// Return:  TRUE if modified pszProfile is now the ServiceDir, or FALSE if failure.
//
// Notes:   pszProfile is MODIFIED IN PLACE.
//
// History: 12-Apr-1999   SumitC    Created
//
//-----------------------------------------------------------------------------
BOOL
VerifyProfileAndGetServiceDir(IN OUT LPSTR pszProfile)
{
    HANDLE hFile = NULL;

    MYDBGASSERT(pszProfile);
    MYDBGASSERT(lstrlen(pszProfile));

    if ((NULL == pszProfile) || (lstrlen(pszProfile) < 4))
    {
        return FALSE;
    }

    //
    //  The profile string may be surrounded by double-quotes, if so remove them.
    //

    //
    //  First check to see if the profile really exists.  This also serves as
    //  verification for the existence of the directory.
    //
    hFile = CreateFile(pszProfile, GENERIC_READ, FILE_SHARE_READ, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        return FALSE;
    }
    else
    {
        CloseHandle(hFile);
    }

    //
    //  Now check to see that the file does indeed end in .CMP
    //

    LPSTR psz = pszProfile + lstrlen(pszProfile) - lstrlen(".CMP");

    if (0 != SafeCompareString(psz, ".CMP"))
    {
        return FALSE;
    }

    //
    //  The profile name is the same as the ServiceDir name, so we just terminate
    //  the string at the '.' and append a '\'
    //

    *psz = '\\';
    psz++;
    *psz = '\0';

    return TRUE;
}


#if DBG

LPTSTR aszMapType[] = {TEXT("Other"), 
                       TEXT("Invalid"),
                       TEXT("Direct"),
                       TEXT("Indirect")};

LPTSTR aszMapProto[] = {TEXT("Other"),                           // MIB_IPPROTO_OTHER    1
                        TEXT("Local"),                           // MIB_IPPROTO_LOCAL    2
                        TEXT("SNMP"),                            // MIB_IPPROTO_NETMGMT  3
                        TEXT("ICMP"),                            // MIB_IPPROTO_ICMP     4
                        TEXT("Exterior Gateway Protocol"),       // MIB_IPPROTO_EGP      5
                        TEXT("GGP"),                             // MIB_IPPROTO_GGP      6
                        TEXT("Hello"),                           // MIB_IPPROTO_HELLO    7
                        TEXT("Routing Information Protocol"),    // MIB_IPPROTO_RIP      8
                        TEXT("IS IS"),                           // MIB_IPPROTO_IS_IS    9
                        TEXT("ES IS"),                           // MIB_IPPROTO_ES_IS    10
                        TEXT("Cicso"),                           // MIB_IPPROTO_CISCO    11
                        TEXT("BBN"),                             // MIB_IPPROTO_BBN      12
                        TEXT("Open Shortest Path First"),        // MIB_IPPROTO_OSPF     13
                        TEXT("Border Gateway Protocol")};        // MIB_IPPROTO_BGP      14


//+----------------------------------------------------------------------
//
//  Function:   PrintRoute
//
//  Purpose:    Prints out a route from the IP forward table
//
//  Arguments:
//      pRow    [in]    the route
//
//  Returns:    zip
//
//  Author:     anbrad   24 Feb 1999
//
//  Notes:      
//
//-----------------------------------------------------------------------
void PrintRoute(PMIB_IPFORWARDROW pRow)
{
    TCHAR sz[MAX_PATH];

    wsprintf(sz, "dwDest = %s\n", IPtoTsz(pRow->dwForwardDest)); // IP addr of destination
    OutputDebugString(sz);
    wsprintf(sz, "dwMask = %s\n", IPtoTsz(pRow->dwForwardMask)); // subnetwork mask of destination
    OutputDebugString(sz);
    
    wsprintf(sz, "dwPolicy = %d\n"
            "dwNextHop = %s\n"
            "dwIfIndex = %d\n"
            "dwType = %s\n"
            "dwProto = %s\n"
            "dwAge = %d\n"
            "dwNextHopAS = %d\n",

    pRow->dwForwardPolicy,              // conditions for multi-path route
    IPtoTsz(pRow->dwForwardNextHop),    // IP address of next hop
    pRow->dwForwardIfIndex,             // index of interface
    aszMapType[pRow->dwForwardType-1],  // route type
    aszMapProto[pRow->dwForwardProto-1],// protocol that generated route
    pRow->dwForwardAge,                 // age of route
    pRow->dwForwardNextHopAS);          // autonomous system number 
                                        // of next hop
    OutputDebugString(sz);

    if (MIB_IPROUTE_METRIC_UNUSED != pRow->dwForwardMetric1)
    {
        wsprintf(sz, "dwMetric1 = %d\n", pRow->dwForwardMetric1);
        OutputDebugString(sz);
    }

    if (MIB_IPROUTE_METRIC_UNUSED != pRow->dwForwardMetric2)
    {
        wsprintf(sz, "dwMetric2 = %d\n", pRow->dwForwardMetric2);
        OutputDebugString(sz);
    }

    if (MIB_IPROUTE_METRIC_UNUSED != pRow->dwForwardMetric3)
    {
        wsprintf(sz, "dwMetric3 = %d\n", pRow->dwForwardMetric3);
        OutputDebugString(sz);
    }

    if (MIB_IPROUTE_METRIC_UNUSED != pRow->dwForwardMetric4)
    {
        wsprintf(sz, "dwMetric4 = %d\n", pRow->dwForwardMetric4);
        OutputDebugString(sz);
    }

    if (MIB_IPROUTE_METRIC_UNUSED != pRow->dwForwardMetric5)
    {
        wsprintf(sz, "dwMetric5 = %d\n", pRow->dwForwardMetric5);
        OutputDebugString(sz);
    }

    wsprintf(sz, "\n");
    OutputDebugString(sz);
}


#if DBG
//+----------------------------------------------------------------------
//
//  Function:   PrintRouteTable
//
//  Purpose:    Does a "ROUTE PRINT" using the iphlpapi's
//
//  Arguments:  none
//
//  Returns:    zip
//
//  Author:     anbrad   24 Feb 1999
//
//  Notes:      
//
//-----------------------------------------------------------------------
void PrintRouteTable()
{
#define PAGE 4096
    
    BYTE        buf[PAGE];
    DWORD       cbbuf = sizeof(buf);
    TCHAR       sz[MAX_PATH];

    if (g_pfnGetIpForwardTable)
    {
        PMIB_IPFORWARDTABLE table = (PMIB_IPFORWARDTABLE)buf;
    
        if (g_pfnGetIpForwardTable(table, &cbbuf, TRUE))
            return;

        wsprintf(sz, "\n\nFound %d routes\n", table->dwNumEntries);
        OutputDebugString(sz);

        for (DWORD d=0; d < table->dwNumEntries; ++d)
        {
            PrintRoute(table->table+d);
        }
    }
}
#endif


//+----------------------------------------------------------------------
//
//  Function:   IPtoTsz
//
//  Purpose:    Changes a dword to a "dotted string" notation
//
//  Arguments:
//      dw       [in]   IP address
//
//  Returns:    LPTSTR which is a static string
//
//  Author:     anbrad   24 Feb 1999
//
//  Notes:      Global makes this NOT thread safe, and it is not needed 
//              for cmroute.exe
//
//-----------------------------------------------------------------------

TCHAR tsz[20];


LPTSTR IPtoTsz(DWORD dw)
{
    wsprintf(tsz, TEXT("%03d.%03d.%03d.%03d"), 
                   (DWORD)LOBYTE(LOWORD(dw)),
                   (DWORD)HIBYTE(LOWORD(dw)),
                   (DWORD)LOBYTE(HIWORD(dw)),
                   (DWORD)HIBYTE(HIWORD(dw)));
    
    return tsz;
}

LPSTR IPtosz(DWORD dwIP, char *psz)
{
    wsprintfA(psz, ("%d.%d.%d.%d"), 
                   (DWORD)LOBYTE(LOWORD(dwIP)),
                   (DWORD)HIBYTE(LOWORD(dwIP)),
                   (DWORD)LOBYTE(HIWORD(dwIP)),
                   (DWORD)HIBYTE(HIWORD(dwIP)));
    
    return psz;
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\customactions\cmroute\pch.h ===
//+----------------------------------------------------------------------------
//
// File:     PCH.H
//
// Module:   CMROUTE.EXE
//
// Synopsis: Precompiled header
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:	 anbrad   created   02/24/99
//
//+----------------------------------------------------------------------------

#include "windows.h"
#include "winsock.h"
#include "wininet.h"
#include "tchar.h"

#include "iphlpapi.h"   // random IP helper functions

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>

#include "cmutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\customactions\cmsample\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     main.cpp
//      
// Module:   CMSAMPLE.DLL 
//
// Synopsis: Main entry point for cmsample.dll 
//
// Copyright (c) 2000 Microsoft Corporation
//
//+----------------------------------------------------------------------------

#include <windows.h>

extern "C" BOOL WINAPI DllMain(
    HINSTANCE   hinstDLL,	    // handle to DLL module 
    DWORD       fdwReason,		// reason for calling function 
    LPVOID      lpvReserved 	// reserved 
)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
		//
		// Disable the DLL_THREAD_ATTACH notification calls.
		//
        if (DisableThreadLibraryCalls(hinstDLL) == 0)
		{
			return FALSE;
		}
    }

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\customactions\cmproxy\util.cpp ===
//+----------------------------------------------------------------------------
//
// File:     util.cpp
//      
// Module:   CMPROXY.DLL (TOOL)
//
// Synopsis: Utility functions for IE proxy setting connect action.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb   Created   10/27/99
//
//+----------------------------------------------------------------------------

#include "pch.h"


//+----------------------------------------------------------------------------
//
// Function:  GetBrowserVersion
//
// Synopsis:  This function returns the version of IE currently installed by
//            using the DllGetVersion function of shdocvw.dll.  This is the
//            IE team recommended way of determining the current version of
//            Internet Explorer.
//
// Arguments: DLLVERSIONINFO* pDllVersionInfo - structure for determining the
//                            version of shdocvw.dll.
//
// Returns:   HRESULT - Standard COM error codes
//
// History:   quintinb  Created    10/27/99
//
//+----------------------------------------------------------------------------
HRESULT GetBrowserVersion(DLLVERSIONINFO* pDllVersionInfo)
{
    HINSTANCE   hBrowser;
    HRESULT hr = E_FAIL;
    
    //
    //  Load the DLL
    //

    hBrowser = LoadLibrary("shdocvw.dll");
    
    if (hBrowser)   
    {
        DLLGETVERSIONPROC pDllGetVersion;      
        
        //
        //  Load the version proc
        //

        pDllGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hBrowser, "DllGetVersion");
        
        if (pDllGetVersion)      
        {      
            ZeroMemory(pDllVersionInfo, sizeof(DLLVERSIONINFO));      
            pDllVersionInfo->cbSize = sizeof(DLLVERSIONINFO); 
            hr = (*pDllGetVersion)(pDllVersionInfo);            
        }   

        FreeLibrary(hBrowser);
    }

    return hr;
}

//
//  Borrowed from cmdl32.exe
//

#define MAX_CMD_ARGS            15

typedef enum _CMDLN_STATE
{
    CS_END_SPACE,   // done handling a space
    CS_BEGIN_QUOTE, // we've encountered a begin quote
    CS_END_QUOTE,   // we've encountered a end quote
    CS_CHAR,        // we're scanning chars
    CS_DONE
} CMDLN_STATE;

//+----------------------------------------------------------------------------
//
// Function:  GetCmArgV
//
// Synopsis:  Simulates ArgV using GetCommandLine
//
// Arguments: LPTSTR pszCmdLine - Ptr to a copy of the command line to be processed
//
// Returns:   LPTSTR * - Ptr to a ptr array containing the arguments. Caller is
//                       responsible for releasing memory.
//
// History:   nickball    Created     4/9/98
//
//+----------------------------------------------------------------------------
LPTSTR *GetCmArgV(LPTSTR pszCmdLine)
{   
    MYDBGASSERT(pszCmdLine);

    if (NULL == pszCmdLine || NULL == pszCmdLine[0])
    {
        return NULL;
    }

    //
    // Allocate Ptr array, up to MAX_CMD_ARGS ptrs
    //
    
    LPTSTR *ppCmArgV = (LPTSTR *) CmMalloc(sizeof(LPTSTR) * MAX_CMD_ARGS);

    if (NULL == ppCmArgV)
    {
        return NULL;
    }

    //
    // Declare locals
    //

    LPTSTR pszCurr;
    LPTSTR pszNext;
    LPTSTR pszToken;
    CMDLN_STATE state;
    state = CS_CHAR;
    int ndx = 0;  

    //
    // Parse out pszCmdLine and store pointers in ppCmArgV
    //

    pszCurr = pszToken = pszCmdLine;

    do
    {
        switch (*pszCurr)
        {
            case TEXT(' '):
                if (state == CS_CHAR)
                {
                    //
                    // We found a token                
                    //

                    pszNext = CharNext(pszCurr);
                    *pszCurr = TEXT('\0');

                    ppCmArgV[ndx] = pszToken;
                    ndx++;

                    pszCurr = pszToken = pszNext;
                    state = CS_END_SPACE;
                    continue;
                }
				else 
                {
                    if (state == CS_END_SPACE || state == CS_END_QUOTE)
				    {
					    pszToken = CharNext(pszToken);
				    }
                }
                
                break;

            case TEXT('\"'):
                if (state == CS_BEGIN_QUOTE)
                {
                    //
                    // We found a token
                    //
                    pszNext = CharNext(pszCurr);
                    *pszCurr = TEXT('\0');

                    //
                    // skip the opening quote
                    //
                    pszToken = CharNext(pszToken);
                    
                    ppCmArgV[ndx] = pszToken;
                    ndx++;
                    
                    pszCurr = pszToken = pszNext;
                    
                    state = CS_END_QUOTE;
                    continue;
                }
                else
                {
                    state = CS_BEGIN_QUOTE;
                }
                break;

            case TEXT('\0'):
                if (state != CS_END_QUOTE)
                {
                    //
                    // End of the line, set last token
                    //

                    ppCmArgV[ndx] = pszToken;
                }
                state = CS_DONE;
                break;

            default:
                if (state == CS_END_SPACE || state == CS_END_QUOTE)
                {
                    state = CS_CHAR;
                }
                break;
        }

        pszCurr = CharNext(pszCurr);
    } while (state != CS_DONE);

    return ppCmArgV;
}



//+----------------------------------------------------------------------------
//
// Function:  UseVpnName
//
// Synopsis:  This function loads rasapi32.dll and enumerates the active
//            RAS connections using RasEnumConnections to see if the given
//            connectoid name is found.  If it is then it returns TRUE, implying
//            that the alternate name passed in should be used instead of the
//            regular connectoid name (ie.  the tunnel connectoid name exists,
//            therefore you are tunneling).
//
// Arguments: LPSTR pszAltName - 
//
// Returns:   BOOL - return TRUE if the VPN connectoid should be used instead
//                   of the regular dialup connectoid.
//
// History:   quintinb  Created    10/28/99
//
//+----------------------------------------------------------------------------
BOOL UseVpnName(LPSTR pszAltName)
{
    BOOL bReturn = FALSE;

    //
    //  Load RAS
    //
    HINSTANCE hRas = LoadLibrary("rasapi32.dll");

    if (hRas)
    {

        //
        //  Load RasEnumConnections
        //
        typedef DWORD (WINAPI* pfnRasEnumConnectionsSpec)(LPRASCONNA, LPDWORD, LPDWORD);

        pfnRasEnumConnectionsSpec pfnRasEnumConnections = NULL;
        pfnRasEnumConnections = (pfnRasEnumConnectionsSpec)GetProcAddress(hRas, "RasEnumConnectionsA");

        if (pfnRasEnumConnections)
        {
            LPRASCONN pRasConn = NULL;
            DWORD dwSize = 2*sizeof(RASCONN);
            DWORD dwNum = 0;
            DWORD dwResult = 0;

            //
            //  Get a list of Active Connections
            //
            do
            {
                CmFree(pRasConn);
                pRasConn = (LPRASCONN)CmMalloc(dwSize);

                if (pRasConn)
                {
                    pRasConn[0].dwSize = sizeof(RASCONN);
                    dwResult = (pfnRasEnumConnections)(pRasConn, &dwSize, &dwNum);
                }

            } while (ERROR_INSUFFICIENT_BUFFER == dwResult);

            //
            //  Search for the name passed in
            //
            if (ERROR_SUCCESS == dwResult)
            {
                for (DWORD dwIndex = 0; dwIndex < dwNum; dwIndex++)
                {
                    if (0 == lstrcmpi(pszAltName, pRasConn[dwIndex].szEntryName))
                    {
                        //
                        //  Then the Tunnel Name is active and that should be used for
                        //  the proxy
                        //
                        bReturn = TRUE;
                        break;
                    }
                }
            }

            CmFree(pRasConn);
        }

        FreeLibrary (hRas);
    }

    return bReturn;
}



//+----------------------------------------------------------------------------
//
// Function:  GetString
//
// Synopsis:  Wrapper for GetPrivateProfileString that takes care of allocating
//            memory (using CmMalloc) correctly.  GetString will max sure to 
//            allocate enough memory for the string (1MB is used as a sanity
//            check, no string should be that large and GetString will stop
//            trying to allocate memory at that point).  Please note that it is
//            the callers responsibility to free the allocated memory.
//
// Arguments: LPCSTR pszSection - Section name
//            LPCSTR pszKey - Key name
//            LPSTR* ppString - string pointer to fill with the memory 
//                              containing the requested string
//            LPCSTR pszFile - File to retrieve info from
//
// Returns:   Nothing
//
// History:   quintinb  Created    10/28/99
//
//+----------------------------------------------------------------------------
void GetString(LPCSTR pszSection, LPCSTR pszKey, LPSTR* ppString, LPCSTR pszFile)
{
    DWORD dwTemp;
    DWORD dwSize = MAX_PATH;
    BOOL bExit = FALSE;

    do
    {
        CmFree(*ppString);
        *ppString = (CHAR*)CmMalloc(dwSize);

        if (*ppString)
        {
            dwTemp = GetPrivateProfileString(pszSection, pszKey, "", 
                                            *ppString, dwSize, pszFile);
            
            if (((dwSize - 1) == dwTemp) && (1024*1024 > dwSize))
            {
                //
                //  Buffer too small, lets try again.
                //
                dwSize = 2*dwSize;
            }
            else
            {
                bExit = TRUE;
            }
        }
        else
        {
            bExit = TRUE;
        }

    } while (!bExit);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\customactions\cmroute\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     MAIN.CPP
//
// Module:   CMROUTE.DLL
//
// Synopsis: Start of CMROUTE.DLL
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:       anbrad   created   02/24/99
//
//+----------------------------------------------------------------------------
#include "pch.h"
#include "cmdebug.h"

extern "C" BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    if (DLL_PROCESS_ATTACH == fdwReason)
    {
        MYVERIFY(DisableThreadLibraryCalls(hinstDLL));
    }

    // NOTE: Do we need to disable double loading?  We aren't using Thread local
    //       storage, just static variables.

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\customactions\cmsample\util.cpp ===
//+----------------------------------------------------------------------------
//
// File:     util.cpp
//      
// Module:   CMSAMPLE.DLL 
//
// Synopsis: Utility functions for parsing command line arguments
//
// Copyright (c) 2000 Microsoft Corporation
//
//+----------------------------------------------------------------------------

#include <windows.h>

#define MAX_CMD_ARGS        15	// Maximum number of arguments expected

//
// Enumerations to keep pointer state for parsing command line arguments
//
typedef enum _CMDLN_STATE
{
    CS_END_SPACE,   // done handling a space
    CS_BEGIN_QUOTE, // we've encountered a begin quote
    CS_END_QUOTE,   // we've encountered a end quote
    CS_CHAR,        // we're scanning chars
    CS_DONE
} CMDLN_STATE;

//+----------------------------------------------------------------------------
//
// Function:  GetArgV
//
// Synopsis:  Simulates ArgV using GetCommandLine
//
// Arguments: LPSTR pszCmdLine - Ptr to a copy of the command line to be processed
//
// Returns:   LPSTR * - Ptr to a ptr array containing the arguments. Caller is
//                       responsible for releasing memory.
//
//				
//+----------------------------------------------------------------------------
LPSTR *GetArgV(LPSTR pszCmdLine)
{   
    if (NULL == pszCmdLine || NULL == pszCmdLine[0])
    {
        return NULL;
    }

    //
    // Allocate Ptr array, up to MAX_CMD_ARGS ptrs
    //
    
	LPSTR *ppArgV = (LPSTR *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(LPSTR) * MAX_CMD_ARGS);

    if (NULL == ppArgV)
    {
        return NULL;
    }

    //
    // Declare locals
    //

    LPSTR pszCurr;
    LPSTR pszNext;
    LPSTR pszToken;
    CMDLN_STATE state;
    state = CS_CHAR;
    int ndx = 0;  

    //
    // Parse out pszCmdLine and store pointers in ppArgV
    //

    pszCurr = pszToken = pszCmdLine;

    do
    {
        switch (*pszCurr)
        {
            case TEXT(' '):
                if (state == CS_CHAR)
                {
                    //
                    // We found a token                
                    //

                    pszNext = CharNext(pszCurr);
                    *pszCurr = TEXT('\0');

                    ppArgV[ndx] = pszToken;
                    ndx++;

                    pszCurr = pszToken = pszNext;
                    state = CS_END_SPACE;
                    continue;
                }
				else 
                {
                    if (state == CS_END_SPACE || state == CS_END_QUOTE)
				    {
					    pszToken = CharNext(pszToken);
				    }
                }
                
                break;

            case TEXT('\"'):
                if (state == CS_BEGIN_QUOTE)
                {
                    //
                    // We found a token
                    //
                    pszNext = CharNext(pszCurr);
                    *pszCurr = TEXT('\0');

                    //
                    // skip the opening quote
                    //
                    pszToken = CharNext(pszToken);
                    
                    ppArgV[ndx] = pszToken;
                    ndx++;
                    
                    pszCurr = pszToken = pszNext;
                    
                    state = CS_END_QUOTE;
                    continue;
                }
                else
                {
                    state = CS_BEGIN_QUOTE;
                }
                break;

            case TEXT('\0'):
                if (state != CS_END_QUOTE)
                {
                    //
                    // End of the line, set last token
                    //

                    ppArgV[ndx] = pszToken;
                }
                state = CS_DONE;
                break;

            default:
                if (state == CS_END_SPACE || state == CS_END_QUOTE)
                {
                    state = CS_CHAR;
                }
                break;
        }

        pszCurr = CharNext(pszCurr);
    } while (state != CS_DONE);

    return ppArgV;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\customactions\cmsample\cmsample.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmsample.cpp 
//      
// Module:   CMSAMPLE.DLL 
//
// Synopsis: Main source for changing proxy file setting using a Tunnel Address
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   tomkel   Created   11/02/2000
//
//+----------------------------------------------------------------------------
#include <windows.h>

//
// Function prototypes
//
LPSTR *GetArgV(LPTSTR pszCmdLine);
BOOL ReadProxyServerByTunnelAddressFromFile(LPCSTR pszSourceFile, LPSTR pszTunnelAddress, LPSTR *ppszProxyServer);
BOOL WriteProxyServerSettingToFile(LPCSTR pszSourceFile, LPSTR pszProxyServer);
HRESULT WINAPI SetProxyUsingTunnelAddress(HWND hWnd, HINSTANCE hInst, LPSTR pszArgs, int nShow);


#define CMSAMPLE_STARTING_BUF_SIZE 256	// Starting size of the string buffer

const CHAR* const c_pszManualProxySection = "Manual Proxy";	// Section to update
const CHAR* const c_pszProxyServer = "ProxyServer";		// Key to update
const CHAR* const c_pszTunnelAddressSection = "Tunnel Address";	// Section to read


//+----------------------------------------------------------------------------
//
// Function:  SetProxyUsingTunnelAddress
//
// Synopsis:  Entry point for changing the proxy file settings using a tunnel
//            address. The parameters to the dll are passed via a string which 
//			  contains parameters.
//
// Arguments: HWND hWnd         - Window handle of caller
//            HINSTANCE hInst   - Instance handle of caller
//            LPSTR pszArgs     - Argument string
//            int nShow         - Unused
//
// Returns:   DWORD WINAPI - Error code
//
// History:   tomkel    Created    11/02/2000
//
//+----------------------------------------------------------------------------
HRESULT WINAPI SetProxyUsingTunnelAddress(HWND hWnd, HINSTANCE hInst, LPSTR pszArgs, int nShow)
{
    HRESULT hr = S_FALSE;		
    LPSTR* ArgV = NULL;
    LPSTR pszServiceDir = NULL;
    LPSTR pszTunnelAddress = NULL;
    LPSTR pszProxyFile = NULL;
    LPSTR pszTunnelFile = NULL;
    LPSTR pszTunnelSettingFilePath = NULL;
    LPSTR pszProxyFilePath = NULL;
    LPSTR pszProxyServer = NULL;
    DWORD dwTunnelPathLen = 0;
    DWORD dwProxyPathLen = 0;
    DWORD dwProxyServerLen = 0;
    HANDLE hCurrentHeap = GetProcessHeap();
    int i = 0;

    //
    //  Parse out the command line parameters
    //  
    //  command line is of the form: /ServiceDir %SERVICEDIR% /TunnelServerAddress %TUNNELSERVERADDRESS% /ProxyFile <PROXYFILE> /TunnelFile <TUNNELFILE>

    //
    // Check if we have any arguments
    //
    if (!pszArgs)
    {
        goto exit;
    }

    // 
    // Separate each argument in the string by '\0' and return a list of pointers
    // to each argument
    //
    ArgV = GetArgV(pszArgs);

    //
    // Check if we have any valid parsed arguments
    //

    if (!ArgV)
    {
        goto exit;
    }

    // 
    // Search the command line arguments for the following switches and their
    // corresponding values
    //
    while (ArgV[i])
    {
        if (0 == lstrcmpi(ArgV[i], "/ServiceDir") && ArgV[i+1])
        {
            pszServiceDir = (ArgV[i+1]);
            i = i+2;
        }
        else if (0 == lstrcmpi(ArgV[i], "/TunnelServerAddress") && ArgV[i+1])
        {
            pszTunnelAddress = ArgV[i+1];
            i = i+2;            
        }
        else if (0 == lstrcmpi(ArgV[i], "/ProxyFile") && ArgV[i+1])
        {
            pszProxyFile = ArgV[i+1];
            i = i+2;            
        }
        else if (0 == lstrcmpi(ArgV[i], "/TunnelFile") && ArgV[i+1])
        {
            pszTunnelFile = ArgV[i+1];
            i = i+2;            
        }
        else
        {
            //
            //  Unknown option.  
            //
            i++;
        }
    }

    //
    // Make sure we have values for the arguments
    //
    if (!pszServiceDir || !pszTunnelAddress || !pszProxyFile || !pszTunnelFile)
    {
        goto exit;
    }

    //
    // Check to see if we got zero length string values from the command line arguments.
    // Exit if that is the case
    //
    if (!(*pszServiceDir) || !(*pszTunnelAddress) ||	
        !(*pszProxyFile) || !(*pszTunnelFile))
    {
        goto exit;
    }

    //
    // Calculate the string size for the two paths that need to be created
    //
    dwTunnelPathLen = lstrlen(pszServiceDir) +  lstrlen(pszTunnelFile) + 2; // 1 space for NULL, 1 for backslash
    dwProxyPathLen = lstrlen(pszServiceDir) +  lstrlen(pszProxyFile) + 2; // 1 space for NULL, 1 for backslash

    //
    // Allocate the memory
    //
    pszTunnelSettingFilePath = (LPSTR)HeapAlloc(hCurrentHeap, HEAP_ZERO_MEMORY, dwTunnelPathLen); // ANSI - char == byte
    if (!pszTunnelSettingFilePath)
    {
        goto exit;
    }

    pszProxyFilePath = (LPSTR)HeapAlloc(hCurrentHeap, HEAP_ZERO_MEMORY, dwProxyPathLen); // ANSI - char == byte
    if (!pszProxyFilePath)
    {
        goto exit;
    }

    //
    // Create the full path to the Tunnel Address file 
    //

    if ( wsprintf(pszTunnelSettingFilePath, "%s\\%s", pszServiceDir, pszTunnelFile) < (int)(dwTunnelPathLen - 1))
    {
        goto exit;
    }

    //
    // Create the full path to the Proxy file
    //

    if (wsprintf(pszProxyFilePath, "%s\\%s", pszServiceDir, pszProxyFile) < (int)(dwProxyPathLen - 1))
    {
        goto exit;
    }

    if (ReadProxyServerByTunnelAddressFromFile(pszTunnelSettingFilePath, pszTunnelAddress, &pszProxyServer))
    {
        //
        // Call WriteProxyServerSettingToFile - the function checks for empty strings
        //
        if(WriteProxyServerSettingToFile(pszProxyFilePath, pszProxyServer))
        {
            hr = S_OK;
        }
    }

	
exit:
    //
    // Clean up allocated memory
    // Delete the argument pointers, Tunnel Server path, Proxy file path and ProxyServer name pointers
    //
    if (ArgV)
    {
        HeapFree(hCurrentHeap, 0, ArgV);
    }

    if (pszTunnelSettingFilePath)
    {
        HeapFree(hCurrentHeap, 0, pszTunnelSettingFilePath);
    }
    
    if (pszProxyFilePath)
    {
        HeapFree(hCurrentHeap, 0, pszProxyFilePath);
    }

    if (pszProxyServer)
    {
        HeapFree(hCurrentHeap, 0, pszProxyServer);
    }

    return hr;
}



//+----------------------------------------------------------------------------
//
// Function:  ReadProxyServerByTunnelAddressFromFile
//
// Synopsis:  Reads the proxy settings from the given proxy file and stores them
//            in the provided pointers.  Please note that the buffers allocated
//            here and stored in ppszProxyServer must be freed by the caller.  
//			  If the TunnelAddress doesn't exist in the pszSourceFile this
//			  function still allocates memory and returns an empty string.
//
// Arguments: LPCSTR pszSourceFile - file to read the proxy settings from.
//            LPSTR  pszTunnelAddress - string containing the TunnelAddress used 
//										to look up the ProxyServer value
//            LPSTR  *ppszProxyServer - string pointer that will have the Proxy server value 
//                                     (in server:port format)
//
// Returns:   BOOL - TRUE if the settings were successfully read
//
//+----------------------------------------------------------------------------
BOOL ReadProxyServerByTunnelAddressFromFile(LPCSTR pszSourceFile, LPSTR pszTunnelAddress, LPSTR *ppszProxyServer)
{
    BOOL bReturn = FALSE;
    BOOL bExit = FALSE;
    DWORD dwReturnedSize = 0;
    DWORD dwSize = CMSAMPLE_STARTING_BUF_SIZE;		

    //
    //  Check input parameters
    //
    if ((NULL == ppszProxyServer) || (NULL == pszSourceFile) || (NULL == pszTunnelAddress))
    {
        return FALSE;
    }

    //
    // Check for empty strings
    //
    if (!(*pszSourceFile) || !(*pszTunnelAddress) || !(*c_pszTunnelAddressSection))
    {
        return FALSE;
    }

    // 
    // Set the incoming pointer to NULL
    //
    *ppszProxyServer = NULL;

    //
    // In case the original buffer size is too small, the loop will try to allocate 
    // more buffer space and try to read the value until. The loop will exist if the 
    // value properly fits into the buffer or the size exceeds 1024*1024. 
    //
    do
    {
        //
        // Free allocated memory
        //

        if (*ppszProxyServer)
        {
            HeapFree(GetProcessHeap(), 0, *ppszProxyServer);
            *ppszProxyServer = NULL;
        }

        //
        // Allocate space for the ProxyServer name
        //

        *ppszProxyServer = (LPSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize); //ANSI - char == byte

        if (*ppszProxyServer)
        {
            // Since memory allocation succeeded, read the value from the settings file
            dwReturnedSize = GetPrivateProfileString(c_pszTunnelAddressSection, pszTunnelAddress, "", *ppszProxyServer, dwSize, pszSourceFile);

            //
            // Check if the value fits into the buffer
            //
            if ((dwReturnedSize == (dwSize - 2))  || (dwReturnedSize == (dwSize - 1)))
            {
                //
                //  The buffer is too small, lets allocate a bigger one
                //
                dwSize = 2*dwSize;
                if (dwSize > 1024*1024)
                {
                    //
                    // Allocation above 1MB, need to exit
                    //
                    if (*ppszProxyServer)
                    {
                        HeapFree(GetProcessHeap(), 0, *ppszProxyServer);
                        *ppszProxyServer = NULL;
                    }
                    goto exit;
                }
            }
            else if (0 == dwReturnedSize)
            {
                //
                //  Either we got an error, or more likely there was no data to get
                //
                if (*ppszProxyServer)
                {
                    HeapFree(GetProcessHeap(), 0, *ppszProxyServer);
                    *ppszProxyServer = NULL;
                }
                goto exit;
            }
            else
            {
                //
                // The function read in the data correctly
                //
                bExit = TRUE;
                bReturn = TRUE;
            }
        }
        else
        {
            bExit = TRUE;
        }

    } while (!bExit);

exit:
    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteProxyServerSettingToFile
//
// Synopsis:  Writes the specified settings to the given backup proxy filename.
//            Please see the above format guide for specifics.
//
// Arguments: LPCSTR pszSourceFile - file to write the current settings to
//            LPSTR pszProxyServer - proxy server string in server:port format
//
// Returns:   BOOL - TRUE if the values were written successfully
//
// History:   tomkel      Created    11/02/2000
//
//+----------------------------------------------------------------------------
BOOL WriteProxyServerSettingToFile(LPCSTR pszSourceFile, LPSTR pszProxyServer)
{
    BOOL bReturn = FALSE;

    //
    //  Check input params
    //
    if ( (NULL == pszSourceFile) || (NULL == pszProxyServer))
    {
        return bReturn;
    }

    //
    // Check for empty strings
    //
    if (!(*pszSourceFile) || !(*pszProxyServer))
    {
        return bReturn;
    }

    //
    //  Save the Proxy Server name to the Proxy setting file
    //
    if (WritePrivateProfileString(c_pszManualProxySection, c_pszProxyServer, pszProxyServer, pszSourceFile))
    {
        bReturn = TRUE;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\pbasetup\mutexclass.cpp ===
//+----------------------------------------------------------------------------
//
// File:     mutexclass.cpp
//
// Module:   PBASETUP.EXE
//
// Synopsis: Mutex Class Implementation
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   v-vijayb   Created    06/10/99
//
//+----------------------------------------------------------------------------
#include "pbamaster.h"

#ifndef UNICODE
#define CreateMutexU CreateMutexA
#else
#define CreateMutexU CreateMutexW
#endif

//
//	Please see pnpu\common\source for the actual source here.
//
#include "mutex.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\migrate\makefile.inc ===
$(O)\msg.mc: $(BASE_INC_PATH)\vendinfo.mc
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\migrate\pwfuncs.cpp ===
//+----------------------------------------------------------------------------
//
// File:     pwfuncs.cpp
//      
// Module:   MIGRATE.DLL 
//
// Synopsis: Simple password encryption routines
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   nickball   created     08/04/99
//
//+----------------------------------------------------------------------------
#include "migrate.h"

//
//	Please see pnpu\cm\common\source for the actual source here.
//

#include "pwutil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\pbasetup\pbamaster.h ===
//+----------------------------------------------------------------------------
//
// File:     pbamaster.h
//
// Module:   PBASETUP.EXE
//
// Synopsis: Precompiled header for the stand alone PBA installation program.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   v-vijayb   Created    06/04/99
//
//+----------------------------------------------------------------------------

#include "pbasetup.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\migrate\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     main.cpp
//      
// Module:   MIGRATE.DLL 
//
// Synopsis: Main entry point for Migrate.DLL
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   created     08/21/98
//
//+----------------------------------------------------------------------------

#include "migrate.h"

#include "linkdll.h" // LinkToDll and BindLinkage for cmsecure.lib
#include "linkdll.cpp" // LinkToDll and BindLinkage for cmsecure.lib

const int c_NumFiles = 28;
char OriginalNames[c_NumFiles][MAX_PATH+1] = {
    "\\showicon.exe",
    "\\swflash.ocx",
    "\\urlmon.dll",
    "\\iexpress.exe",
    "\\oleaut32.dll",
    "\\wextract.exe",
    "\\cm32\\enu\\advapi32.dll",
    "\\cm32\\enu\\advpack.dll",
    "\\cm32\\enu\\cmdial32.dll",
    "\\cm32\\enu\\cmdl32.exe",
    "\\cm32\\enu\\cmmgr32.exe",
    "\\cm32\\enu\\cmmgr32.hlp",
    "\\cm32\\enu\\cmpbk32.dll",
    "\\cm32\\enu\\cmstats.dll",
    "\\cm32\\enu\\comctl32.dll",
    "\\cm32\\enu\\ccfg95.dll",
    "\\cm32\\enu\\ccfgnt.dll",
    "\\cm32\\enu\\icwscrpt.exe",
    "\\cm32\\enu\\cnet16.dll",
    "\\cm32\\enu\\cnetcfg.dll",
    "\\cm32\\enu\\mbslgn32.dll",
    "\\cm32\\enu\\readme.txt",
    "\\cm32\\enu\\rnaph.dll",
    "\\cm32\\enu\\w95inf16.dll",
    "\\cm32\\enu\\w95inf32.dll",
    "\\cm32\\enu\\wininet.dll",
    "\\cm32\\enu\\wintrust.dll",
    "\\cm32\\enu\\cmcfg32.dll",
};

char TempNames[c_NumFiles][MAX_PATH+1] = {
    "\\showicon.tmp",
    "\\swflash.tmp",
    "\\urlmon.tmp",
    "\\iexpress.tmp",
    "\\oleaut32.tmp",
    "\\wextract.tmp",
    "\\advapi32.tmp",
    "\\advpack.tmp",
    "\\cmdial32.tmp",
    "\\cmdl32.tmp",
    "\\cmmgr32.001",
    "\\cmmgr32.002",
    "\\cmpbk32.tmp",
    "\\cmstats.tmp",
    "\\comctl32.tmp",
    "\\ccfg95.tmp",
    "\\ccfgnt.tmp",
    "\\icwscrpt.tmp",
    "\\cnet16.tmp",
    "\\cnetcfg.tmp",
    "\\mbslgn32.tmp",
    "\\readme.tmp",
    "\\rnaph.tmp",
    "\\w95inf16.tmp",
    "\\w95inf32.tmp",
    "\\wininet.tmp",
    "\\wintrust.tmp",
    "\\cmcfg32.tmp",
};

//
//  Global Vars
//
BOOL g_bMigrateCmak10;
BOOL g_bMigrateCmak121;
BOOL g_bMigrateCm;
BOOL g_fInitSecureCalled;
DWORD g_dwNumValues;
DWORD  g_dwTlsIndex; // thread local storage index
HINSTANCE g_hInstance;
TCHAR g_szWorkingDir[MAX_PATH+1];
TCHAR g_szCmakPath[MAX_PATH+1];
VENDORINFO g_VendorInfo;
           
//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Main initialization function for this dll.  Called whenever
//              a new instance of this dll is loaded or a new thread created.
//
//  Arguments:  HINSTANCE hinstDLL - handle to DLL module 
//              DWORD fdwReason - reason for calling function 
//              LPVOID lpvReserved - reserved 
//
//  Returns:    BOOL - TRUE if initialization was successful, FALSE otherwise
//
//  History:    quintinb    Created Header      01/13/2000
//
//----------------------------------------------------------------------------
extern "C" BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        //
        //  Init Globals
        //

        g_hInstance = hinstDLL;
        g_fInitSecureCalled = FALSE;
        g_bMigrateCmak10 = FALSE;
        g_bMigrateCmak121 = FALSE;

        ZeroMemory(g_szCmakPath, sizeof(g_szCmakPath));

        //
        // alloc tls index
        //
        g_dwTlsIndex = TlsAlloc();
        if (g_dwTlsIndex == TLS_OUT_OF_INDEXES)
        {
            return FALSE;
        }

        MYVERIFY(DisableThreadLibraryCalls(hinstDLL));
    }

    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        //
        // free the tls index
        //
        if (g_dwTlsIndex != TLS_OUT_OF_INDEXES)
        {
            TlsFree(g_dwTlsIndex);
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  QueryVersion
//
// Synopsis:  Supplies the Dll's version and identification information.
//
// Arguments: OUT LPCSTR  *ProductID - buffer to hold a string that uniquely 
//                                     identifies the migration dll
//            OUT LPUINT DllVersion - Pointer to an Integer to hold the version 
//                                    number of the migration DLL
//            OUT LPINT *CodePageArray - pointer to an array of code pages that
//                                       the migration dll supports
//            OUT LPCSTR  *ExeNamesBuf - a pointer to a multi-sz string.  The
//                                       buffer contains a null separated list
//                                       of executable file names that the
//                                       migration engine should search for.
//                                       Full paths to all occurences of these
//                                       executables will be copied to the
//                                       [Migration Paths] section of migrate.inf.
//            OUT PVENDORINFO  *VendorInfo - pointer to a VENDORINFO structure
//
// Returns:   LONG -  ERROR_NOT_INSTALLED if the component that this dll is to 
//                    migrate isn't installed.  The migration dll won't be called
//                    in any of the other stages if this is the return value.
//                    ERROR_SUCCESS if the component that this dll is to migrate
//                    is installed and requires migration.  This will allow the
//                    migration dll to be called again for further migration.
//
// History:   quintinb  Created Header    8/27/98
//
//+----------------------------------------------------------------------------
LONG CALLBACK QueryVersion(OUT LPCSTR  *ProductID, OUT LPUINT DllVersion, 
                               OUT LPINT *CodePageArray, OUT LPCSTR  *ExeNamesBuf, 
                               OUT PVENDORINFO  *VendorInfo)
{
    //
    //  Record our version information.
    //
    if (NULL != ProductID)
    {
        *ProductID = c_pszProductIdString;
    }

    if (NULL != DllVersion)
    {
        *DllVersion = uCmMigrationVersion;
    }    

    if (NULL != CodePageArray)
    {
        *CodePageArray = NULL; // no code page dependencies, language neutral
    }

    if (NULL != ExeNamesBuf)
    {
        *ExeNamesBuf = NULL; // 
    }

    if (NULL != VendorInfo)
    {
        *VendorInfo= &g_VendorInfo;
        ZeroMemory(&g_VendorInfo, sizeof(VENDORINFO));

        //
        //  Use the standard MS vendor info from vendinfo.mc
        //
        FormatMessage( 
            FORMAT_MESSAGE_FROM_HMODULE,
            g_hInstance,
            MSG_VI_COMPANY_NAME,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            &g_VendorInfo.CompanyName[0],
            sizeof(g_VendorInfo.CompanyName),
            NULL
            );
    
        FormatMessage( 
            FORMAT_MESSAGE_FROM_HMODULE,
            g_hInstance,
            MSG_VI_SUPPORT_NUMBER,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            &g_VendorInfo.SupportNumber[0],
            sizeof(g_VendorInfo.SupportNumber),
            NULL
            );
    
        FormatMessage( 
            FORMAT_MESSAGE_FROM_HMODULE,
            g_hInstance,
            MSG_VI_SUPPORT_URL,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            &g_VendorInfo.SupportUrl[0],
            sizeof(g_VendorInfo.SupportUrl),
            NULL
            );
    
        FormatMessage( 
            FORMAT_MESSAGE_FROM_HMODULE,
            g_hInstance,
            MSG_VI_INSTRUCTIONS,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            &g_VendorInfo.InstructionsToUser[0],
            sizeof(g_VendorInfo.InstructionsToUser),
            NULL
            );
    }
        
    //
    //  Now try to detect if CMAK or CM are installed.  If they are and the versions
    //  are such that they need to be migrated, then return ERROR_SUCCESS.  Otherwise
    //  we don't need to do any migration, so return ERROR_NOT_INSTALLED.
    //

    LONG lReturnValue = ERROR_NOT_INSTALLED;
    CmVersion CmVer;
    if (CmVer.IsPresent())
    {
        lReturnValue = ERROR_SUCCESS;
    }
    else
    {
        CmakVersion CmakVer;
        //
        //  Okay, CM wasn't installed so look for CMAK.
        //
        if (CmakVer.IsPresent())
        {
            //
            //  Okay, CMAK exists
            //
            lReturnValue = ERROR_SUCCESS;
        }
    }

    return lReturnValue;
}

//+----------------------------------------------------------------------------
//
// Function:  Initialize9x
//
// Synopsis:  This function is called so that the migration dll can initialize
//            itself on the Win9x side of the migration.  The migration dll
//            should not make any modifications to the system in this call, as
//            it is only for initialization and searching to see if your component
//            is installed.
//
// Arguments: IN LPCSTR WorkingDirectory - path of the temporary storage dir for
//                                         the migration dll.
//            IN LPCSTR SourceDirectories - a multi-sz list of the Win2k source
//                                          directory or directories
//            IN LPCSTR MediaDirectory - specifies the path to the original media
//                                       directory
//
// Returns:   LONG -  ERROR_NOT_INSTALLED if the component that this dll is to 
//                    migrate isn't installed.  The migration dll won't be called
//                    in any of the other stages if this is the return value.
//                    ERROR_SUCCESS if the component that this dll is to migrate
//                    is installed and requires migration.  This will allow the
//                    migration dll to be called again for further migration.
//
// History:   quintinb  Created Header    8/27/98
//
//+----------------------------------------------------------------------------
LONG CALLBACK Initialize9x(IN LPCSTR WorkingDirectory, IN LPCSTR SourceDirectories, 
                           IN LPCSTR MediaDirectory)
{
    HKEY hKey;
    //
    //  Check to see if we need to Migrate CMAK
    //

    CmakVersion CmakVer;

    lstrcpy(g_szWorkingDir, WorkingDirectory);

    if (CmakVer.IsPresent())
    {
        if (CmakVer.GetInstallLocation(g_szCmakPath))
        {
                        //
                        //  Then we have a CMAK path.  Write this to the handled key so that
                        //  they won't mess with our files.
                        //

            TCHAR szTemp[MAX_PATH+1];
                        wsprintf(szTemp, "%s\\migrate.inf", WorkingDirectory);
                        MYVERIFY(0 != WritePrivateProfileString(c_pszSectionHandled, g_szCmakPath, 
                        c_pszDirectory, szTemp));

            //
            //  Now try to figure out what version of CMAK we have to see if we need
            //  to run the migration DLL or not.  If the CMAK.exe version is 6.00.613.0 (1.0)
            //  then we should migrate it.  If it is higher than that, 1.1 or 1.2 it is 
            //  beta and we shouldn't support the upgrade anyway (I purposely am not
            //  going to run the migration on it).  If it is IE5 IEAK CMAK, then it should
            //  survive upgrade without a problem.
            //
            
            if (CmakVer.Is10Cmak())
            {
                g_bMigrateCmak10 = TRUE;
            }
            else if (CmakVer.Is121Cmak())
            {
                g_bMigrateCmak121 = TRUE;
            }
        }   
    }

    //
    //  Check to see if we need to migrate CM Profiles
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, 
        KEY_READ, &hKey))
    {
        if ((ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, 
            &g_dwNumValues, NULL, NULL, NULL, NULL)) && (g_dwNumValues > 0))
        {
            //
            //  Then we have mappings values, so we need to migrate them.
            //
            g_bMigrateCm = TRUE;

        }
        RegCloseKey(hKey);
    }

    if (g_bMigrateCmak10 || g_bMigrateCmak121 || g_bMigrateCm)
    {
        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_NOT_INSTALLED;
    }
}



//+----------------------------------------------------------------------------
//
// Function:  MigrateUser9x
//
// Synopsis:  Called once for each Win9x user being migrated.  Its purpose is to
//            allow migration of per user settings.
//
// Arguments: IN HWND ParentWnd - Window handle of the parent window, used if
//                                the migration dll needs to display UI.  If NULL,
//                                running in unattended mode and no UI should be
//                                displayed.
//            IN LPCSTR AnswerFile - Supplies the path to the answer file.
//            IN HKEY UserRegKey - reg key for the HKEY_CURRENT_USER key of the
//                                 user currently being migrated.
//            IN LPCSTR UserName - username of the user being migrated
//            LPVOID Reserved - reserved
//
// Returns:   LONG - ERROR_NOT_INSTALLED - if no per user processing is required.
//                   ERROR_CANCELLED - if the user wants to exit setup
//                   ERROR_SUCCESS - the migration dll processed this user successfully
//
// History:   quintinb  Created Header    8/27/98
//
//+----------------------------------------------------------------------------
LONG
CALLBACK MigrateUser9x(IN HWND ParentWnd, IN LPCSTR AnswerFile, 
                           IN HKEY UserRegKey, IN LPCSTR UserName, LPVOID Reserved)
{
    return ERROR_NOT_INSTALLED; 
}


//+----------------------------------------------------------------------------
//
// Function:  MigrateSystem9x
//
// Synopsis:  Allows migration of system wide settings on the Windows 9x side.
//
// Arguments: IN HWND ParentWnd - parent window handle for the display of UI, 
//                                NULL if in unattended mode
//            IN LPCSTR AnswerFile - full path to the answer file
//            LPVOID Reserved - reserved
//
// Returns:   LONG -  ERROR_NOT_INSTALLED if the component that this dll is to 
//                    migrate isn't installed.  The migration dll won't be called
//                    in any of the other stages if this is the return value.
//                    ERROR_SUCCESS if the component that this dll is to migrate
//                    is installed and requires migration.  This will allow the
//                    migration dll to be called again for further migration.
//
// History:   quintinb  Created Header    8/27/98
//
//+----------------------------------------------------------------------------
LONG
CALLBACK MigrateSystem9x(IN HWND ParentWnd, IN LPCSTR AnswerFile, LPVOID Reserved)
{
    LONG lReturn = ERROR_NOT_INSTALLED;
    TCHAR szSystemDir[MAX_PATH+1];

    if (0 == GetSystemDirectory(szSystemDir, MAX_PATH))
    {
        return GetLastError();
    }

    //
    //  Setup deletes a bunch of the files that 1.0 CMAK or IEAK5 CMAK need to function.
    //  Since we currently don't support NT5 CMAK on WKS, we need to copy these files
    //  to the setup provided working directory, so that we can copy them bak once
    //  we boot into NT.
    //
    if (g_bMigrateCmak10 && (TEXT('\0') != g_szCmakPath[0]) && (TEXT('\0') != g_szWorkingDir[0]))
    {
        TCHAR szDest[MAX_PATH+1];
        TCHAR szSrc[MAX_PATH+1];
        for (int i=0; i < c_NumFiles; i++)
        {
            MYVERIFY(CELEMS(szSrc) > (UINT)wsprintf(szSrc, TEXT("%s%s"), g_szCmakPath, OriginalNames[i]));
            MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s%s"), g_szWorkingDir, TempNames[i]));
            if (FileExists(szSrc))
            {
                MYVERIFY(FALSE != CopyFile(szSrc, szDest, FALSE));
            }
        }

        lReturn &= ERROR_SUCCESS;    
    }
    else if (g_bMigrateCmak121 && (TEXT('\0') != szSystemDir[0]) && 
             (TEXT('\0') != g_szWorkingDir[0]))
    {
        TCHAR szDest[MAX_PATH+1];
        TCHAR szSrc[MAX_PATH+1];

        //
        //  Copy w95inf16.dll to the working directory and rename it w95inf16.tmp
        //
        MYVERIFY(CELEMS(szSrc) > (UINT)wsprintf(szSrc, TEXT("%s\\%s%s"), szSystemDir, c_pszW95Inf16, c_pszDll));
        MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s\\%s%s"), g_szWorkingDir, c_pszW95Inf16, c_pszTmp));
        if (FileExists(szSrc))
        {
            MYVERIFY(FALSE != CopyFile(szSrc, szDest, FALSE));
        }

        //
        //  Copy w95inf32.dll to the working directory and rename it w95inf32.tmp
        //
        MYVERIFY(CELEMS(szSrc) > (UINT)wsprintf(szSrc, TEXT("%s\\%s%s"), szSystemDir, c_pszW95Inf32, c_pszDll));
        MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s\\%s%s"), g_szWorkingDir, c_pszW95Inf32, c_pszTmp));
        if (FileExists(szSrc))
        {
            MYVERIFY(FALSE != CopyFile(szSrc, szDest, FALSE));
        }

        lReturn &= ERROR_SUCCESS;   
    }

    if (g_bMigrateCm)
    {
        //
        //  Enumerate all the installed profiles on the machine.  For each profile check
        //  for a UserInfo\<CurrentServiceNameKey>.  If this key exists, then go to the next
        //  profile or user.  If it doesn't exist, then read the data from the cmp file.  If
        //  the cmp has data marked as being stored then we need to save the password.  If
        //  the password isn't in the cmp then it is in the wnet cache.  We must then
        //  retrieve it.
        //
        HKEY hKey;
        HKEY hTempKey;
        TCHAR szTemp[MAX_PATH+1];
        TCHAR szLongServiceName[MAX_PATH+1];
        TCHAR szCmpPath[MAX_PATH+1];

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, KEY_READ, 
        &hKey))
        {
            DWORD dwIndex = 0;
            DWORD dwValueSize = MAX_PATH;
            DWORD dwDataSize = MAX_PATH;
            DWORD dwType;
                
            while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szLongServiceName, 
                &dwValueSize, NULL, &dwType, (LPBYTE)szCmpPath, &dwDataSize))
            {
                if (REG_SZ == dwType)
                {
                    MYDBGASSERT(TEXT('\0') != szLongServiceName[0]);
                    MYDBGASSERT(TEXT('\0') != szCmpPath[0]);

                    //
                    //  If the user saved their password or their Internet password,
                    //  then we must make sure that it exists in the cmp (in encrypted form)
                    //  so that when the user runs CM on the NT5 side of the migration,
                    //  CM will move the settings to the new format.  Note, that if the 
                    //  cmp doesn't specify that the password(s) be saved, then this
                    //  function just returns as there is no password to ensure is in the
                    //  cmp.
                    MYVERIFY(EnsureEncryptedPasswordInCmpIfSaved(szLongServiceName, szCmpPath));
                }

                dwValueSize = MAX_PATH;
                dwDataSize = MAX_PATH;
                dwIndex++;
            
                if (dwIndex == g_dwNumValues)
                {
                    break;
                }
            }
            MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
        }

        lReturn &= ERROR_SUCCESS;    
    }

    return lReturn;
}



//+----------------------------------------------------------------------------
//
// Function:  InitializeNT
//
// Synopsis:  First function called on the Win2k side of the migration, used to
//            setup the Win2k migration.  Similar to Initialize9x but on the Win2k
//            side.  No changes to the system should be made in this function.
//
// Arguments: IN LPCWSTR WorkingDirectory - temporary storage, same as path given
//                                          on the Win9x side
//            IN LPCWSTR SourceDirectories - a multi-sz list of the Win2k source
//                                           directory or directories
//            LPVOID Reserved - reserved
//
// Returns:   LONG - ERROR_SUCCESS unless an init error occurs.
//
// History:   quintinb  Created Header    8/27/98
//
//+----------------------------------------------------------------------------
LONG
CALLBACK InitializeNT(IN LPCWSTR WorkingDirectory, IN LPCWSTR SourceDirectories, LPVOID Reserved)
{
    HKEY hKey;
    //
    //  Convert the WorkingDirectory to MultiByte
    //
    MYVERIFY (0 != WideCharToMultiByte(CP_THREAD_ACP, WC_COMPOSITECHECK, WorkingDirectory, -1, 
        g_szWorkingDir, MAX_PATH, NULL, NULL));

    //
    //  Check to see if we need to Migrate CMAK
    //
    CmakVersion CmakVer;

    if (CmakVer.IsPresent())
    {
        if (CmakVer.GetInstallLocation(g_szCmakPath))
        {
            //
            //  Now try to figure out what version of CMAK we have to see if we need
            //  to run the migration DLL or not.  If the CMAK.exe version is 6.00.613.0 (1.0)
            //  then we should migrate it.  If it is higher than that, 1.1 or 1.2 it is 
            //  beta and we shouldn't support the upgrade anyway (I purposely am not
            //  going to run the migration on it).  If it is IE5 IEAK CMAK, then it should
            //  survive upgrade without a problem.
            //
            
            if (CmakVer.Is10Cmak())
            {
                g_bMigrateCmak10 = TRUE;
            }
            else if (CmakVer.Is121Cmak())
            {
                g_bMigrateCmak121 = TRUE;
            }
        }   
    }

    //
    //  Check to see if we need to migrate CM Profiles
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, 
        KEY_READ, &hKey))
    {
        if ((ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, 
            &g_dwNumValues, NULL, NULL, NULL, NULL)) && (g_dwNumValues > 0))
        {
            //
            //  Then we have mappings values, so we need to migrate them.
            //
            g_bMigrateCm = TRUE;

        }
        RegCloseKey(hKey);
    }

    if (g_bMigrateCmak10 || g_bMigrateCmak121 || g_bMigrateCm)
    {
        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_NOT_INSTALLED;
    }
}



//+----------------------------------------------------------------------------
//
// Function:  MigrateUserNT
//
// Synopsis:  Called once per migrated user on win2k.  Used to migrated any
//            per user settings saved from MigrateUser9x.
//
// Arguments: IN HINF UnattendInfHandle - valid inf handle to unattend.txt, 
//                                        for use with the setup API's
//            IN HKEY UserRegHandle - HKEY_CURRENT_USER of the user currently
//                                    being migrated
//            IN LPCWSTR UserName - username of the user currently being migrated
//            LPVOID Reserved - reserved
//
// Returns:   LONG - ERROR_SUCCESS or a win32 error code (will abort migration dll
//                   processing)
//
// History:   quintinb  Created Header    8/27/98
//
//+----------------------------------------------------------------------------
LONG
CALLBACK MigrateUserNT(IN HINF UnattendInfHandle, IN HKEY UserRegHandle, 
                            IN LPCWSTR UserName, LPVOID Reserved)
{
    return ERROR_SUCCESS;
}



//+----------------------------------------------------------------------------
//
// Function:  MigrateSystemNT
//
// Synopsis:  Called to allow system wide migration changes to be made on the
//            Win2k side.
//
// Arguments: IN HINF UnattendInfHandle - handle to the unattend.txt file
//            LPVOID Reserved - reserved
//
// Returns:   LONG - ERROR_SUCCESS or a win32 error code (will abort migration dll
//                   processing)
//
// History:   quintinb  Created Header    8/27/98
//
//+----------------------------------------------------------------------------
LONG
CALLBACK MigrateSystemNT(IN HINF UnattendInfHandle, LPVOID Reserved)
{

    LONG lReturn = ERROR_NOT_INSTALLED;
    DWORD dwDisposition;
    TCHAR szSystemDir[MAX_PATH+1];

    if (0 == GetSystemDirectory(szSystemDir, MAX_PATH))
    {
        return GetLastError();
    }

    const TCHAR* const c_pszSystemFmt = TEXT("%s\\system\\%s.inf");
    const TCHAR* const c_pszValueString = TEXT("Connection Manager Profiles Upgrade");
    const TCHAR* const c_pszRegRunKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run");
    const TCHAR* const c_pszCmdLine = TEXT("cmstp.exe /m");

    if (g_bMigrateCmak10 && (TEXT('\0') != g_szCmakPath[0]) && (TEXT('\0') != g_szWorkingDir[0]))
    {
        TCHAR szDest[MAX_PATH+1];
        TCHAR szSrc[MAX_PATH+1];
        for (int i=0; i < c_NumFiles; i++)
        {
            MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s%s"), g_szCmakPath, 
                OriginalNames[i]));

            MYVERIFY(CELEMS(szSrc) > (UINT)wsprintf(szSrc, TEXT("%s%s"), g_szWorkingDir, 
                TempNames[i]));

            if (FileExists(szSrc))
            {
                MYVERIFY(FALSE != CopyFile(szSrc, szDest, FALSE));
            }
        }

        lReturn &= ERROR_SUCCESS;    
    }
    else if (g_bMigrateCmak121 && (TEXT('\0') != g_szCmakPath[0]) && 
             (TEXT('\0') != szSystemDir[0]))
    {
        TCHAR szDest[MAX_PATH+1];
        TCHAR szSrc[MAX_PATH+1];

        //
        //  Copy w95inf16.tmp in the working dir back to the systemdir and rename it .dll
        //
        MYVERIFY(CELEMS(szSrc) > (UINT)wsprintf(szSrc, TEXT("%s\\%s%s"), g_szWorkingDir, 
            c_pszW95Inf16, c_pszTmp));

        MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s\\%s%s"), szSystemDir, 
            c_pszW95Inf16, c_pszDll));

        if (FileExists(szSrc))
        {
            MYVERIFY(FALSE != CopyFile(szSrc, szDest, FALSE));
        }

        //
        //  Copy w95inf32.tmp in the working dir back to the systemdir and rename it .dll
        //
        MYVERIFY(CELEMS(szSrc) > (UINT)wsprintf(szSrc, TEXT("%s\\%s%s"), g_szWorkingDir, 
            c_pszW95Inf32, c_pszTmp));

        MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s\\%s%s"), szSystemDir, 
            c_pszW95Inf32, c_pszDll));

        if (FileExists(szSrc))
        {
            MYVERIFY(FALSE != CopyFile(szSrc, szDest, FALSE));
        }

        lReturn &= ERROR_SUCCESS;   
    }


    if (g_bMigrateCm)
    {
        //
        //  Enumerate all the installed profiles on the machine.  For each profile check to
        //  see if the profile inf is located in the system (that's system not system32) dir.
        //  If it is, then we need to move it to system32 so that our code will know where to
        //  find it.
        //
        HKEY hKey;
        HKEY hTempKey;
        TCHAR szSource[MAX_PATH+1];
        TCHAR szDest[MAX_PATH+1];
        TCHAR szLongServiceName[MAX_PATH+1];
        TCHAR szWindowsDir[MAX_PATH+1];
        TCHAR szCmpPath[MAX_PATH+1];

        //
        //  Get the Windows directory and the system directory
        //
        if (0 == GetWindowsDirectory(szWindowsDir, MAX_PATH))
        {
            return GetLastError();
        }

        if (0 == GetSystemDirectory(szSystemDir, MAX_PATH))
        {
            return GetLastError();
        }

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 
            0, KEY_READ, &hKey))
        {
            DWORD dwIndex = 0;
            DWORD dwValueSize = MAX_PATH;
            DWORD dwDataSize = MAX_PATH;
            DWORD dwType;
                
            while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szLongServiceName, 
                &dwValueSize, NULL, &dwType, (LPBYTE)szCmpPath, &dwDataSize))
            {
                if (REG_SZ == dwType)
                {
                    MYDBGASSERT(TEXT('\0') != szLongServiceName[0]);
                    MYDBGASSERT(TEXT('\0') != szCmpPath[0]);
                    CFileNameParts CmpPath(szCmpPath);

                    MYVERIFY(CELEMS(szSource) > (UINT)wsprintf(szSource, c_pszSystemFmt, szWindowsDir, CmpPath.m_FileName));
                    MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s\\%s.inf"), szSystemDir, CmpPath.m_FileName));

                    if (CopyFile(szSource, szDest, FALSE))
                    {
                        DeleteFile(szSource);
                    }
                }

                dwValueSize = MAX_PATH;
                dwDataSize = MAX_PATH;
                dwIndex++;
            
                if (dwIndex == g_dwNumValues)
                {
                    break;
                }
            }
            MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
        }

        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_pszRegRunKey, 0, NULL,
            REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL, &hKey, &dwDisposition))
        {
            RegSetValueEx(hKey, c_pszValueString, 0, REG_SZ, (CONST BYTE*)c_pszCmdLine, 
                sizeof(TCHAR)*(lstrlen(c_pszCmdLine)+1));

            RegCloseKey(hKey);
        }

        lReturn &= ERROR_SUCCESS;    
    }

    return lReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  EnsureEncryptedPasswordInCmpIfSaved
//
// Synopsis:  This function is called on the Win9x side of the migration so
//            that if a password is in the Win9x password cache (which only
//            happens if the user has profiling enabled), it will be retrieved,
//            encrypted, and written to the cmp.  This enables CM to populate
//            a users registry with the starting password whenever they first
//            launch the CM profile.  This no functionality is lost from the
//            shared password feature that win9x had.
//
// Arguments: szLongServiceName - Service name of the profile to retrieve 
//                                the password for
//            szCmpPath - full path to the cmp to write the password too
//
// Returns:   BOOL - returns TRUE if successful
//
// History:   quintinb      Created             08/27/98
//            nickball      CmWipePassword      08/04/99
//
//+----------------------------------------------------------------------------
BOOL EnsureEncryptedPasswordInCmpIfSaved(LPCTSTR pszLongServiceName, LPCTSTR pszCmpPath)
{
    TCHAR szPassword[MAX_PATH+1] = TEXT("");
    TCHAR szCacheEntryName[MAX_PATH+1];
    TCHAR szEncryptedPassword[MAX_PATH+1];
    DWORD dwSize;
    DWORD dwCryptType = 0;
    GetCachedPassword pfnGetCachedPassword = NULL;
    int iTemp=0;

    CDynamicLibrary MprDll(TEXT("mpr.dll"));
   
    iTemp = GetPrivateProfileInt(c_pszCmSection, c_pszCmEntryRememberPwd, 0, pszCmpPath);
    if (iTemp)
    {
        GetPrivateProfileString(c_pszCmSection, c_pszCmEntryPassword, TEXT(""), szPassword, MAX_PATH, pszCmpPath);

        if (TEXT('\0') == szPassword[0])
        {
            //
            //  The string must be in the password cache.  Build the key string
            //  for the cache.
            //
            MYVERIFY(CELEMS(szCacheEntryName) > (UINT)wsprintf(szCacheEntryName, 
            TEXT("%s - Sign-In (Connection Manager)"), pszLongServiceName));
            
            pfnGetCachedPassword = (GetCachedPassword)MprDll.GetProcAddress(TEXT("WNetGetCachedPassword"));

            if (NULL == pfnGetCachedPassword)
            {
                CmWipePassword(szPassword);
                return FALSE;
            }
            else
            {
                WORD wStr = (WORD)256;

                if (ERROR_SUCCESS == pfnGetCachedPassword(szCacheEntryName, 
                    (WORD)lstrlen(szCacheEntryName), szPassword, &wStr, 80))
                {
                    //
                    //  Okay, we retrived the password, now lets encrypt it and write it 
                    //  to the cmp
                    //

                    if (EncryptPassword(szPassword, szEncryptedPassword, &dwSize, &dwCryptType))
                    {
                        //
                        //  Write the encrypted password
                        //
                        WritePrivateProfileString(c_pszCmSection, c_pszCmEntryPassword, szEncryptedPassword, 
                            pszCmpPath);

                        //
                        //  Write the encryption type
                        //
                        wsprintf(szPassword, TEXT("%u"), dwCryptType);
                        WritePrivateProfileString(c_pszCmSection, c_pszCmEntryPcs, szPassword, 
                            pszCmpPath);
                    }
                }
                
            }
           
        }
    }

    //
    //  Now do the same for the Internet Password
    //
    
    iTemp = GetPrivateProfileInt(c_pszCmSection, c_pszCmEntryRememberInetPwd, 0, pszCmpPath);

    if (iTemp)
    {
        GetPrivateProfileString(c_pszCmSection, c_pszCmEntryInetPassword, TEXT(""), szPassword, MAX_PATH, pszCmpPath);

        if (TEXT('\0') == szPassword[0])
        {
            //
            //  The string must be in the password cache.  Build the key string
            //  for the cache.
            //
            MYVERIFY(CELEMS(szCacheEntryName) > (UINT)wsprintf(szCacheEntryName, 
            TEXT("%s - Sign-In (Connection Manager)-tunnel"), pszLongServiceName));
            
            pfnGetCachedPassword = (GetCachedPassword)MprDll.GetProcAddress(TEXT("WNetGetCachedPassword"));

            if (NULL == pfnGetCachedPassword)
            {
                CmWipePassword(szPassword);
                return FALSE;
            }
            else
            {
                WORD wStr = (WORD)256;

                if (ERROR_SUCCESS == pfnGetCachedPassword(szCacheEntryName, 
                    (WORD)lstrlen(szCacheEntryName), szPassword, &wStr, 80))
                {
                    //
                    //  Okay, we retrived the password, now lets encrypt it and write it 
                    //  to the cmp
                    //
                    
                    dwCryptType = 0;

                    if (EncryptPassword(szPassword, szEncryptedPassword, &dwSize, &dwCryptType))
                    {
                        //
                        //  Write the encrypted password
                        //
                        WritePrivateProfileString(c_pszCmSection, c_pszCmEntryInetPassword, szEncryptedPassword, 
                            pszCmpPath);

                        //
                        //  Write the encryption type
                        //
                        wsprintf(szPassword, TEXT("%u"), dwCryptType);
                        WritePrivateProfileString(c_pszCmSection, c_pszCmEntryPcs, szPassword, 
                            pszCmpPath);
                    }
                }
                
            }
           
        }
    }
    
    CmWipePassword(szPassword);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  EncryptPassword
//
// Synopsis:  
//
// Arguments: IN LPCTSTR pszPassword - 
//            OUT LPTSTR pszEncryptedPassword - 
//            OUT LPDWORD lpdwBufSize - 
//            OUT LPDWORD lpdwCryptType - 
//
// Returns:   BOOL - 
//
// History:   quintinb      Created Header      8/27/98
//            nickball      CmWipePassword      08/04/99
//
//+----------------------------------------------------------------------------
BOOL EncryptPassword(IN LPCTSTR pszPassword, OUT LPTSTR pszEncryptedPassword, OUT LPDWORD lpdwBufSize, OUT LPDWORD lpdwCryptType)
{
    MYDBGASSERT(pszPassword);
    MYDBGASSERT(pszEncryptedPassword);
    MYDBGASSERT(lpdwBufSize);

    MYDBGASSERT(lpdwCryptType);
    DWORD dwEncryptedBufferLen;
    DWORD dwSize = 0;

    LPTSTR pszEncryptedData = NULL;

    TCHAR szSourceData[PWLEN + sizeof(TCHAR)];

    if ((NULL == pszPassword) || (NULL == pszEncryptedPassword) || (NULL == lpdwBufSize))
    { 
        return NULL;
    }

    //
    // Standard encryption, copy the password
    //

    lstrcpy(szSourceData, pszPassword);
   
    //
    // It is not safe to call InitSecure more than once
    //
    if (!g_fInitSecureCalled)
    {
        BOOL bFastEncryption = FALSE;
        MYVERIFY(FALSE != ReadEncryptionOption(&bFastEncryption));
        InitSecure(bFastEncryption);
        g_fInitSecureCalled = TRUE;
    }

    //
    // Encrypt the provided password
    //

    if (EncryptData((LPBYTE)szSourceData, (lstrlen(szSourceData)+1) * sizeof(TCHAR),
            (LPBYTE*)&pszEncryptedData, &dwEncryptedBufferLen, lpdwCryptType, NULL, NULL, NULL))
    {
        if (lpdwBufSize)
        {
            *lpdwBufSize = dwEncryptedBufferLen;
        }

        if (pszEncryptedData)
        {
            _tcscpy(pszEncryptedPassword, pszEncryptedData);
            HeapFree(GetProcessHeap(), 0, pszEncryptedData);
            pszEncryptedData = NULL;
            CmWipePassword(szSourceData);
            return TRUE;
        }        
    }
    
    CmWipePassword(szSourceData);
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  ReadEncryptionOption
//
// Synopsis:  
//
// Arguments: BOOL* pfFastEncryption - boolean to fill in with fast encryption flag
//
// Returns:   BOOL - TRUE if successful
//
// History:   quintinb  Created Header    8/27/98
//            copied from the version written by Fengsun in cmdial\connect.cpp
//
//+----------------------------------------------------------------------------
BOOL ReadEncryptionOption(BOOL* pfFastEncryption)
{
    HKEY hKeyCm;
    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);

    MYDBGASSERT(pfFastEncryption != NULL);

    *pfFastEncryption = FALSE;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmRoot, 0, 
        KEY_QUERY_VALUE ,&hKeyCm))
    {
        RegQueryValueEx(hKeyCm, c_pszRegCmEncryptOption, NULL, &dwType, 
            (BYTE*)pfFastEncryption, &dwSize);

        RegCloseKey(hKeyCm);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\migrate\migrate.h ===
//+----------------------------------------------------------------------------
//
// File:     migrate.h
//      
// Module:   MIGRATE.DLL 
//
// Synopsis: Definitions for the Connection Manager Win9x Migration Dll
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   created     08/20/98
//
//+----------------------------------------------------------------------------
#define _MBCS // for dbcs compatibility
#ifndef _CM_MIGRATE_H
#define _CM_MIGRATE_H

#include <windows.h>
#include <setupapi.h>
#include <stdlib.h>
#include <tchar.h>
#include <lmcons.h>

#include "cmdebug.h"
#include "cmakreg.h"
#include "cmsetup.h"
#include "cmsecure.h"
#include "dynamiclib.h"
#include "pwutil.h"

#include "base_str.h"
#include "pwd_str.h"
#include "reg_str.h"
#include "uninstcm_str.h"

#include "msg.h"

//
//  Constants
//

const TCHAR* const c_pszProductIdString = "Microsoft Connection Manager";
const TCHAR* const c_pszDirectory = "Directory";
const TCHAR* const c_pszSectionHandled = "Handled";
const TCHAR* const c_pszW95Inf16 = "w95inf16";
const TCHAR* const c_pszW95Inf32 = "w95inf32";
const TCHAR* const c_pszDll = ".dll";
const TCHAR* const c_pszTmp = ".tmp";

const UINT uCmMigrationVersion = 1;


//
//  Types
//
typedef struct {
    CHAR CompanyName[256];
    CHAR SupportNumber[256];
    CHAR SupportUrl[256];
    CHAR InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO; 

typedef WORD (WINAPI *GetCachedPassword)(LPSTR, WORD, LPSTR, LPWORD, BYTE);

//
//  Utility Function Headers
//

BOOL ReadEncryptionOption(BOOL* pfFastEncryption);
BOOL EncryptPassword(IN LPCTSTR pszPassword, OUT LPTSTR pszEncryptedPassword, 
                     OUT LPDWORD lpdwBufSize, OUT LPDWORD lpdwCryptType);
BOOL EnsureEncryptedPasswordInCmpIfSaved(LPCTSTR pszLongServiceName, LPCTSTR szCmpPath);

//
//  Migration Dll Function Headers
//
LONG
CALLBACK 
QueryVersion (
	OUT LPCSTR  *ProductID,
	OUT LPUINT DllVersion,
	OUT LPINT *CodePageArray,	//OPTIONAL
	OUT LPCSTR  *ExeNamesBuf,	//OPTIONAL
	OUT PVENDORINFO  *VendorInfo
	);

LONG
CALLBACK 
Initialize9x (
	IN LPCSTR WorkingDirectory,
	IN LPCSTR SourceDirectories,
	IN LPCSTR MediaDirectory
	);

LONG
CALLBACK 
MigrateUser9x (
	IN HWND ParentWnd, 
	IN LPCSTR AnswerFile,
	IN HKEY UserRegKey, 
	IN LPCSTR UserName, 
	LPVOID Reserved
	);

LONG
CALLBACK 
MigrateSystem9x (
	IN HWND ParentWnd, 
	IN LPCSTR AnswerFile,
	LPVOID Reserved
	);

LONG
CALLBACK 
InitializeNT (
	IN LPCWSTR WorkingDirectory,
	IN LPCWSTR SourceDirectories,
	LPVOID Reserved
	);

LONG
CALLBACK 
MigrateUserNT (
	IN HINF UnattendInfHandle,
	IN HKEY UserRegHandle,
	IN LPCWSTR UserName,
	LPVOID Reserved 
	);

LONG
CALLBACK 
MigrateSystemNT (
	IN HINF UnattendInfHandle,
	LPVOID Reserved
	);

#endif //_CM_MIGRATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\profwiz\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h
//
// Module:   CMAK.EXE
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/24/99
//
//+----------------------------------------------------------------------------

#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include "profwiz.h"

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\profwiz\cmakui.h ===
//+----------------------------------------------------------------------------
//
// File:     cmakui.h
//
// Module:   CMAK.EXE
//
// Synopsis: This header file contains the help ID's for html help button on
//		     each wizard page.
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   a-lwells   Updated so code and docs match      06/29/99
//
//+----------------------------------------------------------------------------
 
#define IDH_WELCOME		3010
#define IDH_STARTCUST   3020
#define IDH_NAMES		3030
#define IDH_MERGE		3040
#define IDH_SUPPINFO    3050
#define IDH_REALM		3060
#define IDH_DENTRY 		3070
#define IDH_SECURE		3080
#define IDH_CONNECT		3090
#define IDH_AUTOAPP		3100
#define IDH_BITMAPS		3110
#define IDH_PHONEBK		3120
#define IDH_ICONS		3130
#define IDH_MENU		3140
#define IDH_CMHELP		3150
#define IDH_CMSW		3160
#define IDH_PRESHARED   3170
#define IDH_LICENSE		3180
#define IDH_ADDITION    3190
#define IDH_CREATE		3200
#define IDH_FINISH 		3210
#define IDH_ADVANCED    3220
#define IDH_APCONFIG    3230
#define IDH_RTPLUMB     3240
#define IDH_VENTRY      3250
#define IDH_LCID_POPUP  3260
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\pbasetup\resource.h ===
//+----------------------------------------------------------------------------
//
// File:     resource.h
//
// Module:   PBASETUP.EXE
//
// Synopsis: Resource ID definitions
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   v-vijayb   Created    06/04/99
//
//+----------------------------------------------------------------------------

#define IDS_UNSUCCESSFULUPGRADE         101
//#define IDS_CMAKSTPTITLE                102
#define IDS_DISKFULL                    103
#define IDS_NOACCESS                    104
//#define IDS_NTOPTITLE                   105
//#define IDS_PWSTITLE                    106
#define IDS_ICSTITLE                    107
#define IDS_HELPDIR                     108
#define IDS_APP_TITLE                   109
#define IDS_FOUNDNEWERINSTALL           110
#define IDS_NOT_NT5                     111
#define IDS_SUCCESSFUL                  112
#define IDS_INUSE_MSG                   113
#define IDS_USAGE_MSG                   114
#define IDS_BINARY_NOT_ALPHA            115
#define IDS_NO_NT5_SRV_INST             116
#define IDS_CM_TOO_NEW                  117
#define IDS_REMOVEPBA                   118
#define IDS_REMOVESUCCESSFUL            119
#define IDS_NOPERMS_MSG                 120

#define EXE_ICON            200
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\pbasetup\pbasetup.h ===
//+----------------------------------------------------------------------------
//
// File:     pbamaster.h
//
// Module:   PBASETUP.EXE
//
// Synopsis: Main header for the stand alone PBA installation program.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   v-vijayb   Created    06/04/99
//
//+----------------------------------------------------------------------------
#ifndef _PBASETUP_H
#define _PBASETUP_H

#define _MBCS

//
//  Standard Windows Includes
//
#include <windows.h>
#include <shlobj.h>
#include <shellapi.h>
#include <advpub.h>

//
//  Our includes
//
#include "resource.h"
#include "cmsetup.h"
#include "dynamiclib.h"
#include "cmakreg.h"
#include "reg_str.h"
#include "setupmem.h"
#include "processcmdln.h"


//
//  Constants
//

//
// Function Prototypes
//
BOOL InstallPBA(HINSTANCE hInstance, LPCSTR szInfPath);

#endif //_CMAKSTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\profwiz\customaction.cpp ===
//+----------------------------------------------------------------------------
//
// File:     customaction.cpp
//
// Module:   CMAK.EXE
//
// Synopsis: Implemenation of the CustomActionList and CustomActionListEnumerator
//           classes used by CMAK to handle its custom actions.
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created                         02/26/00
//
//+----------------------------------------------------------------------------

#include <cmmaster.h>

//
//  Include the shared custom action parsing code between CM and CMAK
//
#include "parseca.cpp"

//
//  Include the locale-safe replacement for lstrcmpi
//
#include "CompareString.h"


//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::CustomActionList
//
// Synopsis:  Constructor for the CustomActionList class.  Initializes the
//            m_ActionSectionStrings array with all of the section strings and
//            zeros all of the other parameters of the class.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
CustomActionList::CustomActionList()
{

    //
    //  First set the m_ActionSectionStrings so that we can read the actions
    //  from the appropriate sections in the cms file.
    //    
    m_ActionSectionStrings[PREINIT] = (TCHAR*)c_pszCmSectionPreInit;
    m_ActionSectionStrings[PRECONNECT] = (TCHAR*)c_pszCmSectionPreConnect;
    m_ActionSectionStrings[PREDIAL] = (TCHAR*)c_pszCmSectionPreDial;
    m_ActionSectionStrings[PRETUNNEL] = (TCHAR*)c_pszCmSectionPreTunnel;
    m_ActionSectionStrings[ONCONNECT] = (TCHAR*)c_pszCmSectionOnConnect;
    m_ActionSectionStrings[ONINTCONNECT] = (TCHAR*)c_pszCmSectionOnIntConnect;
    m_ActionSectionStrings[ONDISCONNECT] = (TCHAR*)c_pszCmSectionOnDisconnect;
    m_ActionSectionStrings[ONCANCEL] = (TCHAR*)c_pszCmSectionOnCancel;
    m_ActionSectionStrings[ONERROR] = (TCHAR*)c_pszCmSectionOnError;

    //
    //  Zero m_CustomActionHash
    //
    ZeroMemory(&m_CustomActionHash, c_iNumCustomActionTypes*sizeof(CustomActionListItem*));

    //
    //  Zero the Display strings array
    //
    ZeroMemory(&m_ActionTypeStrings, (c_iNumCustomActionTypes)*sizeof(TCHAR*));
    m_pszAllTypeString = NULL;

    //
    //  Zero the Execution Strings
    //
    ZeroMemory(&m_ExecutionStrings, (c_iNumCustomActionExecutionStates)*sizeof(TCHAR*));
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::~CustomActionList
//
// Synopsis:  Destructor for the CustomActionList class.  Frees all memory
//            allocated by the class including the CustomActionListItem
//            structures stored in the array of linked lists (the true data
//            of the class).
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
CustomActionList::~CustomActionList()
{
    //
    //  Free the memory we allocated
    //

    for (int i = 0; i < c_iNumCustomActionTypes; i++)
    {
        //
        //  Free each CustomAction List
        //
        CustomActionListItem* pCurrent = m_CustomActionHash[i];

        while (NULL != pCurrent)
        {
            CustomActionListItem* pNext = pCurrent->Next;

            CmFree(pCurrent->pszParameters);
            CmFree(pCurrent);
            
            pCurrent = pNext;
        }

        //
        //  Free the Action Type display strings
        //
        CmFree(m_ActionTypeStrings[i]);
    }

    //
    //  Free the All Action display string
    //
    CmFree(m_pszAllTypeString);

    //
    //  Free the execution strings
    //
    for (int i = 0; i < c_iNumCustomActionExecutionStates; i++)
    {
        CmFree(m_ExecutionStrings[i]);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::ReadCustomActionsFromCms
//
// Synopsis:  Reads all custom actions in from the given cms file and stores
//            them in the classes custom action hash table by the type of
//            custom action.  This function relies on ParseCustomActionString
//            to do the actual parsing of the custom action string.  Given the
//            current architecture of CM this function should really only be 
//            called once per class object as there is no way to reset the class object
//            (other than explicitly calling the destructor).  However, there is
//            no code to prevent the caller from pulling connect actions from more than
//            one source.  Thus let the caller beware.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            TCHAR* pszCmsFile - full path to the cms file to get
//                                the custom actions from
//            TCHAR* pszShortServiceName - short service name of the profile
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::ReadCustomActionsFromCms(HINSTANCE hInstance, TCHAR* pszCmsFile, TCHAR* pszShortServiceName)
{
    MYDBGASSERT(hInstance);
    MYDBGASSERT(pszCmsFile);
    MYDBGASSERT(pszShortServiceName);

    if ((NULL == hInstance) || (NULL == pszCmsFile) || (NULL == pszShortServiceName))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    int iFileNum = 0;

    for (int i = 0; i < c_iNumCustomActionTypes; i++)
    {
        TCHAR szNum[MAX_PATH+1];
        LPTSTR pszTemp = NULL;
        CustomActionListItem CustomAction;
        iFileNum = 0;

        do
        {
            CmFree(pszTemp);

            MYVERIFY(CELEMS(szNum) > (UINT)wsprintf(szNum, TEXT("%d"), iFileNum));

            pszTemp = GetPrivateProfileStringWithAlloc(m_ActionSectionStrings[i], szNum, TEXT(""), pszCmsFile);

            if (pszTemp)
            {
                MYDBGASSERT(pszTemp[0]);

                hr = ParseCustomActionString(pszTemp, &CustomAction, pszShortServiceName);

                if (SUCCEEDED(hr))
                {
                    //
                    //  We have parsed the string, now we need to get the Flags and the description
                    //
                    CustomAction.Type = (CustomActionTypes)i;
                    MYVERIFY(CELEMS(szNum) > (UINT)wsprintf(szNum, c_pszCmEntryConactDesc, iFileNum));

                    GetPrivateProfileString(m_ActionSectionStrings[i], szNum, TEXT(""), CustomAction.szDescription, CELEMS(CustomAction.szDescription), pszCmsFile); //lint !e534
                    
                    MYVERIFY(CELEMS(szNum) > (UINT)wsprintf(szNum, c_pszCmEntryConactFlags, iFileNum));

                    CustomAction.dwFlags = (DWORD)GetPrivateProfileInt(m_ActionSectionStrings[i], szNum, 0, pszCmsFile);

                    hr = Add(hInstance, &CustomAction, pszShortServiceName);

                    if (FAILED(hr))
                    {
                        CMASSERTMSG(FALSE, TEXT("CustomActionList::ReadCustomActionsFromCms -- Unable to add a custom action to the list, Add failed."));
                    }

                    CmFree(CustomAction.pszParameters);
                    CustomAction.pszParameters = NULL;
                }
                else
                {
                    CMTRACE2(TEXT("ReadCustomActionsFromCms -- Unable to parse %s, hr=%d"), pszTemp, hr);
                }
            }

            iFileNum++;

        } while(pszTemp);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::ParseCustomActionString
//
// Synopsis:  This function takes a custom action string retrieved from a 
//            cms file and parses it into the various parts of a custom
//            action (program, parameters, function name, etc.)
//
// Arguments: LPTSTR pszStringToParse - custom action buffer to be parsed into
//                                      the various parts of a custom action
//            CustomActionListItem* pCustomAction - pointer to a custom action
//                                                  structure to be filled in
//            TCHAR* pszShortServiceName - short service name of the profile
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::ParseCustomActionString(LPTSTR pszStringToParse, CustomActionListItem* pCustomAction, TCHAR* pszShortServiceName)
{
    MYDBGASSERT(pszStringToParse);
    MYDBGASSERT(TEXT('\0') != pszStringToParse[0]);
    MYDBGASSERT(pCustomAction);
    MYDBGASSERT(pszShortServiceName);

    if ((NULL == pszStringToParse) || (TEXT('\0') == pszStringToParse[0]) || 
        (NULL == pCustomAction) || (NULL == pszShortServiceName))
    {
        return E_INVALIDARG;
    }    

    //
    //  Zero the CustomAction struct
    //
    ZeroMemory(pCustomAction, sizeof(CustomActionListItem));
    CmStrTrim(pszStringToParse);    

    LPTSTR pszProgram = NULL;
    LPTSTR pszFunctionName = NULL;

    HRESULT hr = HrParseCustomActionString(pszStringToParse, &pszProgram,
                                           &(pCustomAction->pszParameters), &pszFunctionName);

    if (SUCCEEDED(hr))
    {
        lstrcpyn(pCustomAction->szProgram, pszProgram, CELEMS(pCustomAction->szProgram));
        lstrcpyn(pCustomAction->szFunctionName, pszFunctionName, CELEMS(pCustomAction->szFunctionName));

        //
        //  Now we have the filename string, but we need to check to see if
        //  it includes the relative path.  If so, then we need to set 
        //  bIncludeBinary to TRUE;
        //
        TCHAR szTemp[MAX_PATH+1];

        if (MAX_PATH >= (lstrlen(g_szOsdir) + lstrlen(pCustomAction->szProgram)))
        {
            MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s"), g_szOsdir, pCustomAction->szProgram));

            pCustomAction->bIncludeBinary = FileExists(szTemp);
        }
        else
        {
            pCustomAction->bIncludeBinary = FALSE;
        }
    }

    CmFree(pszProgram);
    CmFree(pszFunctionName);

    return hr;
}
//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::WriteCustomActionsToCms
//
// Synopsis:  This function takes a custom action string retrieved from a 
//            cms file and parses it into the various parts of a custom
//            action (program, parameters, function name, etc.)
//
// Arguments: TCHAR* pszCmsFile - Cms file to write the custom action to
//            TCHAR* pszShortServiceName - short service name of the profile
//            BOOL bUseTunneling - whether this a tunneling profile or not,
//                                 controls whether Pre-Tunnel actions should be
//                                 written and whether the Flags parameter for
//                                 each action should be written (since they are
//                                 only needed if tunneling is an option).
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::WriteCustomActionsToCms(TCHAR* pszCmsFile, TCHAR* pszShortServiceName, BOOL bUseTunneling)
{
    HRESULT hr = S_OK;

    for (int i = 0; i < c_iNumCustomActionTypes; i++)
    {
        //
        //  Clear out the section
        //
        MYVERIFY(0 != WritePrivateProfileSection(m_ActionSectionStrings[i], TEXT("\0\0"), pszCmsFile));

        //
        //  Make sure that we have a linked list of actions to process and that if we
        //  are writing PRETUNNEL actions that we are actually tunneling.
        //
        if (m_CustomActionHash[i] && (i != PRETUNNEL || (i == PRETUNNEL && bUseTunneling)))
        {
            int iFileNum = 0;

            CustomActionListItem* pItem = m_CustomActionHash[i];

            while (pItem)
            {
                if (pItem->szProgram[0])
                {
                    //
                    //  Get just the filename of the program
                    //
                    TCHAR szName[MAX_PATH+1];
                    if (pItem->bIncludeBinary)
                    {
                        wsprintf(szName, TEXT("%s\\%s"), pszShortServiceName, GetName(pItem->szProgram));
                    }
                    else
                    {                    
                        lstrcpyn(szName, pItem->szProgram, CELEMS(szName));
                    }

                    UINT uSizeNeeded = lstrlen(szName);

                    LPTSTR pszSpace = CmStrchr(szName, TEXT(' '));
                    BOOL bLongName = (NULL != pszSpace);

                    if (bLongName)
                    {
                        uSizeNeeded = uSizeNeeded + 2; // for the two plus signs
                    }

                    if (pItem->szFunctionName[0])
                    {
                        uSizeNeeded = uSizeNeeded + lstrlen(pItem->szFunctionName) + 1;// add one for the comma
                    }

                    if (pItem->pszParameters && pItem->pszParameters[0])
                    {
                        uSizeNeeded = uSizeNeeded + lstrlen(pItem->pszParameters) + 1;// add one for the space
                    }

                    uSizeNeeded = (uSizeNeeded + 1) * sizeof(TCHAR);

                    LPTSTR pszBuffer = (LPTSTR)CmMalloc(uSizeNeeded);

                    if (pszBuffer)
                    {
                        if (bLongName)
                        {
                            pszBuffer[0] = TEXT('+');
                        }

                        lstrcat(pszBuffer, szName);

                        if (bLongName)
                        {
                            lstrcat(pszBuffer, TEXT("+"));
                        }

                        if (pItem->szFunctionName[0])
                        {
                            lstrcat(pszBuffer, TEXT(","));
                            lstrcat(pszBuffer, pItem->szFunctionName);
                        }

                        if (pItem->pszParameters && pItem->pszParameters[0])
                        {
                            lstrcat(pszBuffer, TEXT(" "));
                            lstrcat(pszBuffer, pItem->pszParameters);
                        }
                        //
                        //  Now write the buffer string out to the cms file
                        //
                        TCHAR szNum[MAX_PATH+1];
                        MYVERIFY(CELEMS(szNum) > (UINT)wsprintf(szNum, TEXT("%d"), iFileNum));

                        if (0 != WritePrivateProfileString(m_ActionSectionStrings[i], szNum, pszBuffer, pszCmsFile))
                        {
                            //
                            //  if dwFlags == 0 or bUseTunneling is FALSE (and the NonInteractive flag isn't set)
                            //  then delete the flags line instead of setting it.  We only need the flags to 
                            //  tell us when to run a connect action if we have the option of tunneling unless the
                            //  Admin has specified that this connect action can run non-interactively (without 
                            //  showing UI).
                            //
                            LPTSTR pszFlagsValue = NULL;

                            if (0 != pItem->dwFlags)
                            {
                                if (bUseTunneling)
                                {
                                    MYVERIFY(CELEMS(szName) > (UINT)wsprintf(szName, TEXT("%u"), pItem->dwFlags));
                                    pszFlagsValue = szName;
                                }
                                else if (pItem->dwFlags & NONINTERACTIVE)
                                {
                                    MYVERIFY(CELEMS(szName) > (UINT)wsprintf(szName, TEXT("%u"), NONINTERACTIVE));
                                    pszFlagsValue = szName;
                                }
                            }

                            MYVERIFY(CELEMS(szNum) > (UINT)wsprintf(szNum, c_pszCmEntryConactFlags, iFileNum));

                            if (0 == WritePrivateProfileString(m_ActionSectionStrings[i], szNum, pszFlagsValue, pszCmsFile))
                            {
                                hr = HRESULT_FROM_WIN32(GetLastError());
                                CMTRACE1(TEXT("CustomActionList::WriteCustomActionsToCms -- unable to write flags, hr is 0x%x"), hr);
                            }

                            //
                            //  If description parameter is null or is only a temporary description, then delete the
                            //  description instead of writing it.
                            //
                            LPTSTR pszDescValue = NULL;

                            if (pItem->szDescription[0]  && !pItem->bTempDescription)
                            {
                                pszDescValue = pItem->szDescription;
                            }

                            MYVERIFY(CELEMS(szNum) > (UINT)wsprintf(szNum, c_pszCmEntryConactDesc, iFileNum));

                            if (0 == WritePrivateProfileString(m_ActionSectionStrings[i], szNum, pszDescValue, pszCmsFile))
                            {
                                hr = HRESULT_FROM_WIN32(GetLastError());
                                CMTRACE1(TEXT("CustomActionList::WriteCustomActionsToCms -- unable to write description, hr is 0x%x"), hr);
                            }
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                            CMTRACE1(TEXT("CustomActionList::WriteCustomActionsToCms -- unable to write connect action, hr is 0x%x"), hr);
                        }

                        CmFree(pszBuffer);
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("CustomActionList::WriteCustomActionsToCms -- Unable to allocate pszBuffer!"));
                    }
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("WriteCustomActionsToCms -- custom action with empty program field!"));
                }

                pItem = pItem->Next;
                iFileNum++;
            }
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::AddOrRemoveCmdl
//
// Synopsis:  This function is designed ensure that the builtin custom action
//            cmdl is either in the custom action list or is removed from the
//            custom action list depending on the bAddCmdl flag.  Thus if the
//            Flag is TRUE the connect action is added if it doesn't exist
//            already.  If the bAddCmdl flag is FALSE then the custom action is
//            removed from the list.  Also note that there is now two cmdl
//            variations that could exist in a profile.  One for downloading
//            VPN updates and one for PBK updates.  Thus we also have the 
//            bForVpn flag that controls which version of the custom action
//            we are adding or removing.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            BOOL bAddCmdl - whether cmdl should be added or deleted
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::AddOrRemoveCmdl(HINSTANCE hInstance, BOOL bAddCmdl, BOOL bForVpn)
{

    HRESULT hr;
    CustomActionListItem* pItem = NULL;
    CustomActionListItem* pCurrent;
    CustomActionListItem* pFollower;

    if ((NULL == hInstance))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    //
    //  cmdl32.exe
    //
    pItem = (CustomActionListItem*)CmMalloc(sizeof(CustomActionListItem));

    MYDBGASSERT(pItem);
    if (pItem)
    {
        UINT uDescId;

        if (bForVpn)
        {
            uDescId = IDS_CMDL_VPN_DESC;
            pItem->pszParameters = CmStrCpyAlloc(TEXT("/VPN %PROFILE%"));
        }
        else
        {
            uDescId = IDS_CMDL_DESC;
            pItem->pszParameters = CmStrCpyAlloc(TEXT("%PROFILE%"));
        }

        MYVERIFY(LoadString(hInstance, uDescId, pItem->szDescription, CELEMS(pItem->szDescription)));
        lstrcpy(pItem->szProgram, TEXT("cmdl32.exe"));

        pItem->Type = ONCONNECT;
        pItem->bBuiltInAction = TRUE;
        pItem->bTempDescription = TRUE;
        pItem->dwFlags = NONINTERACTIVE;

        MYDBGASSERT(pItem->pszParameters);

        if (pItem->pszParameters)
        {
            hr = Find(hInstance, pItem->szDescription, pItem->Type, &pCurrent, &pFollower);

            if (FAILED(hr))
            {
                //
                //  No cmdl32.exe.  If bAddCmdl is TRUE then we need to add it, otherwise our job here is done.
                //  If we are going to add it, lets make it the first in the list.  The user can move it later
                //  if they wish.
                //
                if (bAddCmdl)
                {
                    pItem->Next = m_CustomActionHash[pItem->Type];
                    m_CustomActionHash[pItem->Type] = pItem;
                    pItem = NULL; // don't free pItem
                }

                hr = S_OK;
            }
            else
            {
                //
                //  cmdl32.exe already exists and bAddCmdl is TRUE, nothing to do.  If bAddCmdl is FALSE
                //  and it already exists then we need to delete it.
                //
                if (bAddCmdl)
                {
                    hr = S_FALSE;

                    //
                    //  Make sure to set the dwFlags to NONINTERACTIVE since this might be an upgrade.
                    //
                    if (pCurrent)
                    {
                        pCurrent->dwFlags = pCurrent->dwFlags | NONINTERACTIVE;
                    }
                }
                else
                {
                    hr = Delete(hInstance, pItem->szDescription, pItem->Type);
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto exit;        
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

exit:

    if (pItem)
    {
        CmFree(pItem->pszParameters);
        CmFree(pItem);
    }

    return hr;
}

HRESULT DuplicateCustomActionListItem(CustomActionListItem* pCustomAction, CustomActionListItem** ppNewItem)
{
    HRESULT hr = S_OK;

    if (pCustomAction && ppNewItem)
    {
        *ppNewItem = (CustomActionListItem*)CmMalloc(sizeof(CustomActionListItem));

        if (*ppNewItem)
        {
            //
            //  Duplicate the existing item
            //
            CopyMemory(*ppNewItem, pCustomAction, sizeof(CustomActionListItem));

            //
            //  NULL out the Next pointer
            //
            (*ppNewItem)->Next = NULL;

            //
            //  If we have a param string, that must also be duplicated since
            //  it is an allocated string.
            //
            if (pCustomAction->pszParameters)
            {
                (*ppNewItem)->pszParameters = CmStrCpyAlloc(pCustomAction->pszParameters);

                if (NULL == (*ppNewItem)->pszParameters)
                {
                    hr = E_OUTOFMEMORY;
                    CmFree(*ppNewItem);
                    *ppNewItem = NULL;
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
        *ppNewItem = NULL;
        CMASSERTMSG(FALSE, TEXT("DuplicateCustomActionListItem"));
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::Add
//
// Synopsis:  This function adds the given custom action to the custom action
//            hash table.  Note that add is for new items and returns an error
//            if an existing custom action of the same description and type
//            already exists.  Also note that the CustomActionListItem passed in
//            is not just added to the hash table.  Add creates its own memory
//            for the custom action objects and the caller should not expect
//            add to free the past in memory.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            CustomActionListItem* pCustomAction - custom action structure to
//                                                  add to the list of existing
//                                                  custom actions
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::Add(HINSTANCE hInstance, CustomActionListItem* pCustomAction, LPCTSTR pszShortServiceName)
{
    HRESULT hr = S_OK;

    MYDBGASSERT(hInstance);
    MYDBGASSERT(pCustomAction);
    MYDBGASSERT(pCustomAction->szProgram[0]);

    if ((NULL == hInstance) || (NULL == pCustomAction) || (TEXT('\0') == pCustomAction->szProgram[0]))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    //
    //  First make sure that we have a description parameter because the description
    //  and the Type uniquely identify a custom action
    //

    TCHAR szCmProxy[MAX_PATH+1];
    TCHAR szCmRoute[MAX_PATH+1];

    wsprintf(szCmRoute, TEXT("%s\\cmroute.dll"), pszShortServiceName);
    wsprintf(szCmProxy, TEXT("%s\\cmproxy.dll"), pszShortServiceName);

    if (TEXT('\0') == pCustomAction->szDescription[0])
    {
        if (IsCmDl(pCustomAction))
        {
            //
            //  Cmdl32.exe as a post built-in custom action normally gets added through  
            //  AddOrRemoveCmdl.  However, to allow the user to move the custom actions
            //  around in the list, we want to add it here.  Note, that we must distinguish
            //  between the VPN download and the PBK download so that we get the description correct on each.
            //
            LPTSTR pszVpnSwitch = CmStrStr(pCustomAction->pszParameters, TEXT("/v"));
            UINT uDescStringId;

            if (NULL == pszVpnSwitch)
            {
                pszVpnSwitch = CmStrStr(pCustomAction->pszParameters, TEXT("/V"));
            }

            if (pszVpnSwitch)
            {
                uDescStringId = IDS_CMDL_VPN_DESC;
            }
            else
            {
                uDescStringId = IDS_CMDL_DESC;
            }

            pCustomAction->bBuiltInAction = TRUE;
            pCustomAction->bTempDescription = TRUE;
            MYVERIFY(LoadString(hInstance, uDescStringId, pCustomAction->szDescription, CELEMS(pCustomAction->szDescription)));
        }
        else
        {
            hr = FillInTempDescription(pCustomAction);
            MYDBGASSERT(SUCCEEDED(hr));
        }
    }
    else if (0 == lstrcmpi(pCustomAction->szProgram, szCmProxy))
    {
        if (ONCONNECT == pCustomAction->Type)
        {
            pCustomAction->bBuiltInAction = TRUE;
            MYVERIFY(LoadString(hInstance, IDS_CMPROXY_CON_DESC, pCustomAction->szDescription, CELEMS(pCustomAction->szDescription)));
        }
        else if (ONDISCONNECT == pCustomAction->Type)
        {
            pCustomAction->bBuiltInAction = TRUE;
            MYVERIFY(LoadString(hInstance, IDS_CMPROXY_DIS_DESC, pCustomAction->szDescription, CELEMS(pCustomAction->szDescription)));
        }
    }
    else if (0 == lstrcmpi(pCustomAction->szProgram, szCmRoute))
    {
        if (ONCONNECT == pCustomAction->Type)
        {
            pCustomAction->bBuiltInAction = TRUE;
            MYVERIFY(LoadString(hInstance, IDS_CMROUTE_DESC, pCustomAction->szDescription, CELEMS(pCustomAction->szDescription)));
        }    
    }

    //
    //  First figure out if we already have a list of connect actions for
    //  the type specified.  If not, then create one.
    //
    if (NULL == m_CustomActionHash[pCustomAction->Type])
    {
        hr = DuplicateCustomActionListItem(pCustomAction, &(m_CustomActionHash[pCustomAction->Type]));
        goto exit;
    }
    else
    {
        CustomActionListItem* pCurrent = NULL;
        CustomActionListItem* pFollower = NULL;

        //
        //  Search for an existing record with the same description.  If one exists return
        //  an error that it already exists.
        //
        hr = Find(hInstance, pCustomAction->szDescription, pCustomAction->Type, &pCurrent, &pFollower);

        if (SUCCEEDED(hr))
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);

            goto exit;        
        }

        //
        //  If we got here, then we have a list but we don't have a matching entry.  Thus
        //  we must add a new entry to the end of the list
        //
        if (pFollower && (NULL == pFollower->Next))
        {
            hr = DuplicateCustomActionListItem(pCustomAction, &(pFollower->Next));
            goto exit;
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("CustomActionList::Add -- couldn't find place to add the new element!"));
            hr = E_UNEXPECTED;
            goto exit;
        }
    }

exit:
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::Edit
//
// Synopsis:  This function is used to edit an existing action.  The function
//            tries to replace the old action with the new one, keeping the
//            same place in the respective custom action list.  However, since
//            the new item could be of a different type than the old item, this
//            isn't always possible.  When the item changes type, it is deleted
//            from the old list and appended to the new custom action type list.
//            Also note, that when the caller is attempting to rename or re-type
//            an item, the function checks for collisions with existing items
//            of that name/type.  If the caller tries to rename an item
//            to the same name/type as another existing item then the function returns
//            an error.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            CustomActionListItem* pOldCustomAction - a custom action struct
//                                                     containing at least the 
//                                                     description and type of
//                                                     the item that is to be
//                                                     editted.
//            CustomActionListItem* pNewCustomAction - the new data for the 
//                                                     custom action.
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::Edit(HINSTANCE hInstance, CustomActionListItem* pOldCustomAction, CustomActionListItem* pNewCustomAction, LPCTSTR pszShortServiceName)
{
    MYDBGASSERT(hInstance);
    MYDBGASSERT(pOldCustomAction);
    MYDBGASSERT(pNewCustomAction);
    MYDBGASSERT(pNewCustomAction->szDescription[0]);
    MYDBGASSERT(pOldCustomAction->szDescription[0]);

    if ((NULL == hInstance) || (NULL == pOldCustomAction) || (NULL == pNewCustomAction) || 
        (TEXT('\0') == pOldCustomAction->szDescription[0]) || (TEXT('\0') == pNewCustomAction->szDescription[0]))
    {
        return E_INVALIDARG;
    }

    //
    //  First try to find the old custom action
    //
    CustomActionListItem* pTemp = NULL;
    CustomActionListItem* pTempFollower = NULL;
    CustomActionListItem* pExistingItem = NULL;
    CustomActionListItem* pFollower = NULL;
    CustomActionListItem** ppPointerToFillIn = NULL;

    HRESULT hr = Find (hInstance, pOldCustomAction->szDescription, pOldCustomAction->Type, &pExistingItem, &pFollower);

    if (SUCCEEDED(hr))
    {
        //
        //  Okay, we found the old custom action.  If the type and desc are the same between the two actions, 
        //  then all we need to do is copy over the data and be done with it.  However, if the user changed 
        //  the type or description then we need to double check that an action with the description and type
        //  of the new action doesn't already exist (editting action XYZ of type Post-Connect
        //  into action XYZ of type Pre-Connect when there already exists XYZ of type Pre-Connect).
        //
        if ((pOldCustomAction->Type == pNewCustomAction->Type) &&
            (0 == lstrcmpi(pExistingItem->szDescription, pNewCustomAction->szDescription)))
        {
            if (NULL == pFollower)
            {
                ppPointerToFillIn = &(m_CustomActionHash[pNewCustomAction->Type]);
            }
            else
            {
                ppPointerToFillIn = &(pFollower->Next);
            }

            hr = DuplicateCustomActionListItem(pNewCustomAction, ppPointerToFillIn);
        
            if (SUCCEEDED(hr))
            {
                (*ppPointerToFillIn)->Next = pExistingItem->Next;
                CmFree(pExistingItem->pszParameters);
                CmFree(pExistingItem);
                pExistingItem = NULL;
            }
        }
        else
        {
            hr = Find (hInstance, pNewCustomAction->szDescription, pNewCustomAction->Type, &pTemp, &pTempFollower);

            if (SUCCEEDED(hr))
            {
                //
                //  If the caller really wants to do this, then have them delete the old custom action
                //  and then call edit with the new custom action as both old and new.
                //
                hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);                
            }
            else
            {
                //
                //  If the types are different then it needs to go on a different sub list.  If
                //  only the name is different then we just need to copy it over.
                //
                if(pOldCustomAction->Type != pNewCustomAction->Type)
                {
                    //
                    //  Delete the old action of type X
                    //
                    hr = Delete(hInstance, pOldCustomAction->szDescription, pOldCustomAction->Type);
                    MYDBGASSERT(SUCCEEDED(hr));

                    //
                    //  Add the new action of type Y
                    //
                    if (SUCCEEDED(hr))
                    {
                        hr = Add(hInstance, pNewCustomAction, pszShortServiceName);
                        MYDBGASSERT(SUCCEEDED(hr));
                    }
                }
                else
                {
                    if (NULL == pFollower)
                    {
                        ppPointerToFillIn = &(m_CustomActionHash[pNewCustomAction->Type]);
                    }
                    else
                    {
                        ppPointerToFillIn = &(pFollower->Next);
                    }

                    hr = DuplicateCustomActionListItem(pNewCustomAction, ppPointerToFillIn);
        
                    if (SUCCEEDED(hr))
                    {
                        (*ppPointerToFillIn)->Next = pExistingItem->Next;
                        CmFree(pExistingItem->pszParameters);
                        CmFree(pExistingItem);
                        pExistingItem = NULL;
                    }
                }
            }            
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::Find
//
// Synopsis:  This function searches the array of linked lists for an item with
//            the given type and description.  If it finds the the item it returns
//            successfully and fills in the ppItem and ppFollower pointers with
//            pointers to the item itself and the item before the requested item,
//            respectively.  If the item is the first item in the list, then
//            *ppFollower will be NULL.  Note that this function is internal to the
//            class because it returns pointers to the classes internal data.
//            Also note, that if we have a list, but don't find the desired item
//            then *ppFollower returns the last item in the list.  This is desired
//            behavior since it allows Add to use *ppFollower to directly add a new
//            item to the list.
//
// Arguments: HINSTANCE hInstance - instance handle for resources
//            LPCTSTR pszDescription - description of the item to look for
//            CustomActionTypes Type - type of the item to look for
//            CustomActionListItem** ppItem - an OUT param that is filled in with
//                                            a pointer to the item on a successful find
//            CustomActionListItem** ppFollower - an OUT param that is filled in with
//                                                a pointer to the item before the
//                                                item in the list on a successful find
//                                                (note that this is useful since it
//                                                is a singly linked list).  This
//                                                param will be NULL if the item is the
//                                                first item in the list on a successful
//                                                find.
//                                                 
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::Find(HINSTANCE hInstance, LPCTSTR pszDescription, CustomActionTypes Type, CustomActionListItem** ppItem, CustomActionListItem** ppFollower)
{
    if ((NULL == hInstance) || (NULL == pszDescription) || (TEXT('\0') == pszDescription[0]) || (NULL == ppItem) || (NULL == ppFollower))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    CustomActionListItem* pCurrent = m_CustomActionHash[Type];
    TCHAR szDescWithBuiltInSuffix[MAX_PATH+1];
    
    *ppFollower = NULL;
    *ppItem = NULL;

    LPTSTR pszBuiltInSuffix = CmLoadString(hInstance, IDS_BUILT_IN); // if we got a NULL pointer then just don't do the extra compare
    MYDBGASSERT(pszBuiltInSuffix);

    //
    //  Search the list to find the item
    //
    while (pCurrent)
    {
        if (0 == lstrcmpi(pCurrent->szDescription, pszDescription))
        {
            //
            //  We found the item
            //
            *ppItem = pCurrent;

            hr = S_OK;
            break;
        }
        else if (pszBuiltInSuffix && pCurrent->bBuiltInAction)
        {
            //
            //  This is a built in action, lets try adding the builtin string to the description
            //  and try the comparision again
            //
            wsprintf(szDescWithBuiltInSuffix, TEXT("%s%s"), pCurrent->szDescription, pszBuiltInSuffix);

            if (0 == lstrcmpi(szDescWithBuiltInSuffix, pszDescription))
            {
                *ppItem = pCurrent;

                hr = S_OK;
                break;            
            }
            else
            {
                *ppFollower = pCurrent;
                pCurrent = pCurrent->Next;
            }
        }
        else
        {
            *ppFollower = pCurrent;
            pCurrent = pCurrent->Next;
        }
    }

    CmFree(pszBuiltInSuffix);

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::Delete
//
// Synopsis:  This function searches through the array of custom action lists
//            to find an item with the given description and type.  If it finds
//            the item it deletes it from the list.  If the item cannot be found
//            an error is returned.
//
// Arguments: TCHAR* pszDescription - description of the item to look for
//            CustomActionTypes Type - type of the item to look for
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::Delete(HINSTANCE hInstance, TCHAR* pszDescription, CustomActionTypes Type)
{
    HRESULT hr = S_OK;

    if ((NULL == pszDescription) || (TEXT('\0') == pszDescription[0]))
    {
        return E_INVALIDARG;
    }

    CustomActionListItem* pCurrent = NULL;
    CustomActionListItem* pFollower = NULL;

    hr = Find(hInstance, pszDescription, Type, &pCurrent, &pFollower);

    if (SUCCEEDED(hr))
    {
        //
        //  We found the item to delete
        //
        if (pFollower)
        {
            pFollower->Next = pCurrent->Next;
        }
        else
        {
            //
            //  It is the first item in the list
            //
            m_CustomActionHash[Type] = pCurrent->Next;
        }

        CmFree(pCurrent->pszParameters);
        CmFree(pCurrent);       
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::MoveUp
//
// Synopsis:  Moves the custom action specified by the given description and type
//            up one place in the linked list for the given type.  Note that if
//            the custom action is already at the top of its list, we return
//            S_FALSE;
//
// Arguments: TCHAR* pszDescription - description of the custom action to move
//            CustomActionTypes Type - type of the custom action to move
//
// Returns:   HRESULT - standard COM error codes.  Note that S_FALSE denotes that
//                      MoveUp succeeded but that the item was already at the
//                      head of its list and thus couldn't be moved.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::MoveUp(HINSTANCE hInstance, TCHAR* pszDescription, CustomActionTypes Type)
{
    if ((NULL == pszDescription) || (TEXT('\0') == pszDescription[0]))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = E_UNEXPECTED;
    CustomActionListItem* pCurrent = NULL;
    CustomActionListItem* pFollower = NULL;
    CustomActionListItem* pBeforeFollower = NULL;

    hr = Find(hInstance, pszDescription, Type, &pCurrent, &pFollower);

    if (SUCCEEDED(hr))
    {
        //
        //  We found the item to move up
        //
        if (pFollower)
        {
            //
            //  Now Find the item in front of pFollower
            //
            hr = Find(hInstance, pFollower->szDescription, pFollower->Type, &pFollower, &pBeforeFollower);

            if (SUCCEEDED(hr))
            {
                if (pBeforeFollower)
                {
                    pBeforeFollower->Next = pCurrent;
                }
                else
                {
                    //
                    //  pFollower is first in the list
                    //
                    m_CustomActionHash[Type] = pCurrent;
                }

                pFollower->Next = pCurrent->Next;
                pCurrent->Next = pFollower;

                hr = S_OK;
            }            
        }
        else
        {
            //
            //  It is the first item in the list, we cannot move it up
            //
            hr = S_FALSE;
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::MoveDown
//
// Synopsis:  Moves the custom action specified by the given description and type
//            down one place in the linked list for the given type.  Note that if
//            the custom action is already at the bottom of its list, we return
//            S_FALSE;
//
// Arguments: TCHAR* pszDescription - description of the custom action to move
//            CustomActionTypes Type - type of the custom action to move
//
// Returns:   HRESULT - standard COM error codes.  Note that S_FALSE denotes that
//                      MoveDown succeeded but that the item was already at the
//                      tail of its list and thus couldn't be moved.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::MoveDown(HINSTANCE hInstance, TCHAR* pszDescription, CustomActionTypes Type)
{
    if ((NULL == pszDescription) || (TEXT('\0') == pszDescription[0]))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = E_UNEXPECTED;
    CustomActionListItem* pCurrent = NULL;
    CustomActionListItem* pFollower = NULL;

    hr = Find(hInstance, pszDescription, Type, &pCurrent, &pFollower);

    if (SUCCEEDED(hr))
    {
        //
        //  We found the item to move down
        //

        if (NULL == pCurrent->Next)
        {
            //
            //  The item is already last in its list
            //
            hr = S_FALSE;
        }
        else if (pFollower)
        {
            pFollower->Next = pCurrent->Next;
            pCurrent->Next = pFollower->Next->Next;
            pFollower->Next->Next = pCurrent;
        }
        else
        {
            //
            //  Then the item is first in the list
            //
            m_CustomActionHash[Type] = pCurrent->Next;
            pCurrent->Next = m_CustomActionHash[Type]->Next;
            m_CustomActionHash[Type]->Next = pCurrent;        
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::AddCustomActionTypesToComboBox
//
// Synopsis:  This function adds the custom action type strings (Pre-Connect,
//            Post-Connect, etc.) to the given combo box.  Note that whether
//            tunneling is enabled or not and whether the All string is asked for
//            or not affects the strings added to the combo.
//
// Arguments: HWND hDlg - Window handle of the dialog that contains the combobox
//            UINT uCtrlId - combo box control ID to add the strings too
//            HINSTANCE hInstance - instance handle used to load resource strings
//            BOOL bUseTunneling - is this a tunneling profile?
//            BOOL bAddAll - should we include the <All> selection in the list?
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::AddCustomActionTypesToComboBox(HWND hDlg, UINT uCtrlId, HINSTANCE hInstance, BOOL bUseTunneling, BOOL bAddAll)
{

    if ((0 == hDlg) || (0 == uCtrlId))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    //  Clear the combo list
    //
    SendDlgItemMessage(hDlg, uCtrlId, CB_RESETCONTENT, 0, (LPARAM)0); //lint !e534 CB_RESETCONTENT doesn't return anything useful

    //
    //  Ensure the type strings are loaded
    //

    hr = EnsureActionTypeStringsLoaded(hInstance);

    if (SUCCEEDED(hr))
    {
        //
        //  Setup the all display string, if needed
        //
        if (bAddAll)
        {
            SendDlgItemMessage(hDlg, uCtrlId, CB_ADDSTRING, 0, (LPARAM)m_pszAllTypeString);
        }

        //
        //  Setup the rest of the display strings
        //
        for (int i = 0; i < c_iNumCustomActionTypes; i++)
        {
            //
            //  Don't Add the PreTunnel String unless we are tunneling
            //  
            if (i != PRETUNNEL || (i == PRETUNNEL && bUseTunneling))
            {
                SendDlgItemMessage(hDlg, uCtrlId, CB_ADDSTRING, 0, (LPARAM)m_ActionTypeStrings[i]);
            }
        }    
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("CustomActionList::AddCustomActionTypesToComboBox -- Failed to load type strings"));
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::AddCustomActionsToListView
//
// Synopsis:  This function adds actions of the given type to the given
//            list view control.  After adding the actions it sets the
//            selection mark and highlight to the given value (defaulting
//            to the first item in the list).
//
// Arguments: HWND hListView - window handle of the list view control
//            HINSTANCE hInstance - instance handle of the exe, used for resources
//            CustomActionTypes Type - type of custom action to add to the list
//                                     view control, see the CustomActionTypes
//                                     definition for more info
//            BOOL bUseTunneling - whether the tunneling is enabled or not for
//                                 the current profile.  Determines whether 
//                                 PreTunnel actions should be shown in the
//                                 ALL action view (and raises an error if 
//                                 PreTunnel is specified but FALSE is passed).
//            int iItemToSelect - after the items are added to the list, the
//                                selection mark is set.  This defaults to 0, but
//                                if the caller wants a specific index selected
//                                they can pass it in here.  If the index is
//                                invalid then 0 is selected.
//            BOOL bTypeInSecondCol - when TRUE the second column is filled with
//                                    the type string instead of the program.
//
// Returns:   HRESULT - standard COM error codes.  Note that S_FALSE denotes that
//                      the function could not set the requested item index (iItemToSelect)
//                      as the selected item.  Thus it set 0 as the selected item.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::AddCustomActionsToListView(HWND hListView, HINSTANCE hInstance, CustomActionTypes Type, BOOL bUseTunneling, int iItemToSelect, BOOL bTypeInSecondCol)
{
    if ((NULL == hListView) || (-1 > Type) || (c_iNumCustomActionTypes < Type) || (!bUseTunneling && PRETUNNEL == Type))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    LVITEM lvItem = {0};
    TCHAR szTemp[MAX_PATH+1];
    CustomActionListItem* pCurrent;

    //
    //  Clear all of the items in the list view
    //
    MYVERIFY(FALSE != ListView_DeleteAllItems(hListView));

    hr = EnsureActionTypeStringsLoaded(hInstance);

    if (FAILED(hr))
    {
        CMASSERTMSG(FALSE, TEXT("CustomActionList::AddCustomActionsToListView -- Failed to load type strings."));
        return E_UNEXPECTED;
    }

    //
    //  Figure out what type of items to add to the list view
    //
    int iStart;
    int iEnd;
    int iTotalCount = 0;

    if (ALL == Type)
    {
        iStart = 0;
        iEnd = c_iNumCustomActionTypes;
    }
    else
    {
        iStart = Type;
        iEnd = iStart + 1;
    }

    //
    //  Load the built in string suffix just in case we have some built in actions to display
    //
    LPTSTR pszBuiltInSuffix = CmLoadString(hInstance, IDS_BUILT_IN); // if we have a NULL then just don't append anything
    MYDBGASSERT(pszBuiltInSuffix);

    //
    //  Now add the items
    //
    for (int i = iStart; i < iEnd; i++)
    {
        //
        //  Don't display PreTunnel actions unless we are tunneling
        //
        if (!bUseTunneling && (PRETUNNEL == i))
        {
            pCurrent = NULL;
        }
        else
        {
            pCurrent = m_CustomActionHash[i];        
        }
        
        while(pCurrent)
        {
            //
            //  Add the initial item
            //
            LPTSTR pszDescription;
            TCHAR szDescription[MAX_PATH+1];

            if (pszBuiltInSuffix && pCurrent->bBuiltInAction)
            {
                lstrcpy(szDescription, pCurrent->szDescription);
                lstrcat(szDescription, pszBuiltInSuffix);

                pszDescription = szDescription;
            }
            else
            {
                pszDescription = pCurrent->szDescription;
            }

            lvItem.mask = LVIF_TEXT;
            lvItem.pszText = pszDescription;
            lvItem.iItem = iTotalCount;
            lvItem.iSubItem = 0;

            if (-1 == ListView_InsertItem(hListView,  &lvItem))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CMTRACE2(TEXT("CustomActionList::AddCustomActionsToListView -- unable to add %s, hr 0x%x"), pCurrent->szDescription, hr);
            }

            //
            //  Now add the type of the item
            //
            lvItem.iSubItem = 1;

            if (bTypeInSecondCol)
            {
                lvItem.pszText = m_ActionTypeStrings[pCurrent->Type];
            }
            else
            {
                if (pCurrent->bIncludeBinary)
                {
                    lvItem.pszText = CmStrrchr(pCurrent->szProgram, TEXT('\\'));

                    if (lvItem.pszText)
                    {
                        //
                        //  Advance past the slash
                        //
                        lvItem.pszText = CharNext(lvItem.pszText);
                    }
                    else
                    {
                        //
                        //  We couldn't take out the shortservicename\
                        //  Instead of erroring, lets show them the whole string, better than nothing.
                        //
                        lvItem.pszText = pCurrent->szProgram;
                    }
                }
                else
                {
                    lvItem.pszText = pCurrent->szProgram;                
                }
            }

            if (0 == ListView_SetItem(hListView,  &lvItem))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CMTRACE2(TEXT("CustomActionList::AddCustomActionsToListView -- unable to add type for %s, hr 0x%x"), pCurrent->szDescription, hr);
            }
            
            pCurrent = pCurrent->Next;
            iTotalCount++;
        }
    }

    CmFree(pszBuiltInSuffix);

    //
    //  Now that we have added everything to the list, set the cursor selection to the
    //  desired item in the list, if we have any.
    //

    int iCurrentCount = ListView_GetItemCount(hListView);
    if (iCurrentCount)
    {
        //
        //  If we have enough items to satisfy iItemToSelect, then
        //  select the first item in the list.
        //
        if (iCurrentCount < iItemToSelect)
        {
            hr = S_FALSE;
            iItemToSelect = 0;
        }
        
        //
        //  Select the item
        //
        SetListViewSelection(hListView, iItemToSelect);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::GetExistingActionData
//
// Synopsis:  This function looks up an action of the given type and
//            description and then duplicates the item into the provided pointer.
//            The function returns an error if it cannot find the requested item.
//
// Arguments: HINSTANCE hInstance - instance handle for resources
//            LPCTSTR pszDescription - description of the item to look up
//            CustomActionTypes Type - type of the item to lookup
//            CustomActionListItem** ppCustomAction - pointer to hold the 
//                                                    returned item, note
//                                                    it is the user responsibility
//                                                    to free this item
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::GetExistingActionData(HINSTANCE hInstance, LPCTSTR pszDescription, CustomActionTypes Type, CustomActionListItem** ppCustomAction)
{
    if ((NULL == pszDescription) || (TEXT('\0') == pszDescription[0]) || (NULL == ppCustomAction))
    {
        return E_INVALIDARG;
    }

    //
    //  Find the existing entry
    //
    CustomActionListItem* pCurrent = NULL;
    CustomActionListItem* pFollower = NULL;

    HRESULT hr = Find(hInstance, pszDescription, Type, &pCurrent, &pFollower);

    if (SUCCEEDED(hr))
    {
        hr = DuplicateCustomActionListItem(pCurrent, ppCustomAction);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::GetTypeFromTypeString
//
// Synopsis:  This function takes the inputted type string and compares it
//            against the type strings it has loaded to tell the caller the
//            numerical value of the type.
//            
//
// Arguments: HINSTANCE hInstance - instance handle used to load strings
//            TCHAR* pszTypeString - type string that the caller is looking for
//                                   the numerical type of.
//            CustomActionTypes* pType - pointer to recieve the type on success
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::GetTypeFromTypeString(HINSTANCE hInstance, TCHAR* pszTypeString, CustomActionTypes* pType)
{
    if (NULL == pszTypeString || NULL == pType)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = EnsureActionTypeStringsLoaded(hInstance);

    if (SUCCEEDED(hr))
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        for (int i = 0; i < c_iNumCustomActionTypes; i++)
        {
            if (0 == lstrcmpi(m_ActionTypeStrings[i], pszTypeString))
            {
                hr = S_OK;
                *pType = (CustomActionTypes)i;
            }
        }

        //
        //  Check for all
        //
        if (FAILED(hr))
        {
            if (0 == lstrcmpi(m_pszAllTypeString, pszTypeString))
            {
                hr = S_OK;
                *pType = (CustomActionTypes)i;
            }    
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::GetTypeStringFromType
//
// Synopsis:  This function returns the type string of the given numerical
//            type.  Note that the returned string is an allocated string that
//            is the caller's responsibility to free.  The function will not
//            return a NULL string if the function succeeds.
//            
//
// Arguments: HINSTANCE hInstance - instance handle used to load strings
//            TCHAR* pszTypeString - type string that the caller is looking for
//                                   the numerical type of.
//            CustomActionTypes* pType - pointer to recieve the type on success
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::GetTypeStringFromType(HINSTANCE hInstance, CustomActionTypes Type, TCHAR** ppszTypeString)
{
    if (NULL == ppszTypeString || (-1 > Type) || (c_iNumCustomActionTypes <= Type))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = EnsureActionTypeStringsLoaded(hInstance);

    if (SUCCEEDED(hr))
    {
        if (ALL == Type)
        {
            *ppszTypeString = CmStrCpyAlloc(m_pszAllTypeString);
        }
        else
        {
            *ppszTypeString = CmStrCpyAlloc(m_ActionTypeStrings[Type]);
        }

        if (NULL == ppszTypeString)
        {
            hr = E_OUTOFMEMORY;
        }
    }    

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::EnsureActionTypeStringsLoaded
//
// Synopsis:  This function ensures that all of the action type strings have
//            been loaded from string resources.  If any of the action type
//            strings are NULL the function will try to load them.  If the
//            any of the loads fail, the function fails.  Thus the caller is
//            gauranteed to have all of the type strings available for use
//            if this function succeeds.  The loaded strings are freed by the
//            class destructor.  If the CmLoadString call fails, the function
//            will try to use a copy of the Action Section strings instead.
//            
//
// Arguments: HINSTANCE hInstance - instance handle used to load strings
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::EnsureActionTypeStringsLoaded(HINSTANCE hInstance)
{

    HRESULT hr = E_OUTOFMEMORY;

    //
    //  First load the All type string
    //
    if (NULL == m_pszAllTypeString)
    {
        //
        //  LoadString the string we will display to the user in
        //  the action type combo box for the current type.
        //
        m_pszAllTypeString = CmLoadString(hInstance, IDS_ALLCONACT);

        if (NULL == m_pszAllTypeString)
        {
            CMASSERTMSG(FALSE, TEXT("EnsureActionTypeStringsLoaded -- Failed to load a all action display string."));

            //
            //  Special case the all string because we don't have a section string for it
            //
            m_pszAllTypeString = CmStrCpyAlloc(TEXT("All"));

            if (NULL == m_pszAllTypeString)
            {
                goto exit;
            }            
        }
    }

    //
    //  Load the rest of the type display strings
    //
    for (int i = 0; i < c_iNumCustomActionTypes; i++)
    {
        if (NULL == m_ActionTypeStrings[i])
        {
            //
            //  LoadString the string we will display to the user in
            //  the action type combo box for the current type.
            //
            m_ActionTypeStrings[i] = CmLoadString(hInstance, BASE_ACTION_STRING_ID + i);
            if (NULL == m_ActionTypeStrings[i])
            {
                CMASSERTMSG(FALSE, TEXT("EnsureActionTypeStringsLoaded -- Failed to load a custom action type display string."));

                //
                //  Try to use the section name instead of the localized version, if that fails then bail
                //
                m_ActionTypeStrings[i] = CmStrCpyAlloc(m_ActionSectionStrings[i]);

                if (NULL == m_ActionTypeStrings[i])
                {
                    goto exit;
                }            
            }
        }
    }

    //
    //  If we got this far everything should be peachy
    //
    hr = S_OK;

exit:
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::AddExecutionTypesToComboBox
//
// Synopsis:  This function adds the execution type strings (Direct connections only,
//            Dialup connections only, etc.) to the given combobox.  Note that if
//            tunneling is disabled then the combo box is disabled after being
//            filled in.  This is because this choice is only relevant to tunneling
//            profiles.
//
// Arguments: HWND hDlg - window handle of the dialog containing the combo box
//            UINT uCtrlId - combo box control ID
//            HINSTANCE hInstance - instance handle for loading string resources
//            BOOL bUseTunneling - is this a tunneling profile?
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::AddExecutionTypesToComboBox(HWND hDlg, UINT uCtrlId, HINSTANCE hInstance, BOOL bUseTunneling)
{
    HRESULT hr = E_OUTOFMEMORY;
    INT_PTR nResult;
    //
    //  Clear the combo list
    //
    SendDlgItemMessage(hDlg, uCtrlId, CB_RESETCONTENT, 0, (LPARAM)0); //lint !e534 CB_RESETCONTENT doesn't return anything useful

    //
    //  Load the of the execution display strings
    //

    for (int i = 0; i < c_iNumCustomActionExecutionStates; i++)
    {
        if (NULL == m_ExecutionStrings[i])
        {
            //
            //  LoadString the string we will display to the user in
            //  the execution combo box on the custom action popup dialog
            //
            m_ExecutionStrings[i] = CmLoadString(hInstance, BASE_EXECUTION_STRING_ID + i);
            if (NULL == m_ExecutionStrings[i])
            {
                CMASSERTMSG(FALSE, TEXT("AddExecutionTypesToComboBox -- Failed to load a custom action execution display string."));
                goto exit;
            }
        }

        //
        //  Add the string to the combo box
        //
        SendDlgItemMessage(hDlg, uCtrlId, CB_ADDSTRING, 0, (LPARAM)m_ExecutionStrings[i]);            
    }    

    //
    //  Pick the first item in the list by default
    //
    nResult = SendDlgItemMessage(hDlg, uCtrlId, CB_GETCOUNT, (WPARAM)0, (LPARAM)0);
    if ((CB_ERR != nResult) && (nResult > 0))
    {
        MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, uCtrlId, CB_SETCURSEL, (WPARAM)0, (LPARAM)0));
    }


    //
    //  If we aren't tunneling, then the control should be disabled since we only
    //  have one type of connection available to the user ... dialup connections.
    //  However, we will set the flags to 0 at this point, indicating connect for
    //  all connections (to fit in with legacy behavior).
    //
    if (!bUseTunneling)
    {
        EnableWindow(GetDlgItem(hDlg, uCtrlId), FALSE);
    }

    //
    //  If we got this far everything should be peachy
    //
    hr = S_OK;

exit:
    return hr;

}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::FillInTempDescription
//
// Synopsis:  This function creates the temporary description used for a custom
//            action if the user didn't specify one.  The temporary description
//            is the Program concatenated with the displayed parameters string
//            (namely the function name and the parameters together).
//
// Arguments: HWND hDlg - window handle of the dialog containing the combo box
//            UINT uCtrlId - combo box control ID
//            HINSTANCE hInstance - instance handle for loading string resources
//            BOOL bUseTunneling - is this a tunneling profile?
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::FillInTempDescription(CustomActionListItem* pCustomAction)
{
    MYDBGASSERT(pCustomAction);
    MYDBGASSERT(TEXT('\0') == pCustomAction->szDescription[0]);

    if ((NULL == pCustomAction) || (TEXT('\0') != pCustomAction->szDescription[0]))
    {
        return E_INVALIDARG;
    }

    TCHAR* pszFileName;
    pCustomAction->bTempDescription = TRUE;

    if (pCustomAction->bIncludeBinary)
    {
        //
        //  We want just the filename (not the entire path) associated with the
        //  item if the user is including the binary.
        //
        pszFileName = CmStrrchr(pCustomAction->szProgram, TEXT('\\'));

        if (pszFileName)
        {
            pszFileName = CharNext(pszFileName);
        }
        else
        {
            pszFileName = pCustomAction->szProgram;
        }
    }
    else
    {
        pszFileName = pCustomAction->szProgram;
    }

    lstrcpyn(pCustomAction->szDescription, pszFileName, CELEMS(pCustomAction->szDescription));
    UINT uNumCharsLeftInDesc = CELEMS(pCustomAction->szDescription) - lstrlen(pCustomAction->szDescription);
    LPTSTR pszCurrent = pCustomAction->szDescription + lstrlen(pCustomAction->szDescription);

    if (pCustomAction->szFunctionName[0] && uNumCharsLeftInDesc)
    {
        //
        //  If we have space left in the description add a space and the function name next
        //
        *pszCurrent = TEXT(' ');
        uNumCharsLeftInDesc--;
        pszCurrent++;

        lstrcpyn(pszCurrent, pCustomAction->szFunctionName, uNumCharsLeftInDesc);

        pszCurrent = pCustomAction->szDescription + lstrlen(pCustomAction->szDescription);
        uNumCharsLeftInDesc = (UINT)(CELEMS(pCustomAction->szDescription) - (pszCurrent - pCustomAction->szDescription) - 1);// one for the NULL char
    }

    if (pCustomAction->pszParameters && pCustomAction->pszParameters[0] && uNumCharsLeftInDesc)
    {
        *pszCurrent = TEXT(' ');
        uNumCharsLeftInDesc--;
        pszCurrent++;

        lstrcpyn(pszCurrent, pCustomAction->pszParameters, uNumCharsLeftInDesc);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::MapIndexToFlags
//
// Synopsis:  This function gives the caller the Flags value for the given
//            combobox index.  Note that the flags value does not include
//            the NonInteractive flag which is OR-ed on later.
//
// Arguments: int iIndex - combo index to retrieve the flags for
//            DWORD* pdwFlags - DWORD pointer to receive the flags value
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::MapIndexToFlags(int iIndex, DWORD* pdwFlags)
{
    if ((NULL == pdwFlags) || (c_iNumCustomActionExecutionStates <= iIndex) || (0 > iIndex))
    {
        return E_INVALIDARG;
    }

    *pdwFlags = (CustomActionExecutionStates)c_iExecutionIndexToFlagsMap[iIndex];

    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::MapFlagsToIndex
//
// Synopsis:  This function gives the caller the index value of the given flags
//            value.  Thus if you have a flags value, this function will tell you
//            which combobox index to pick to get the string for that flags value.
//
// Arguments: DWORD dwFlags - flags value to lookup the index for
//            int* piIndex - pointer to recieve the index value
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::MapFlagsToIndex(DWORD dwFlags, int* piIndex)
{
    //
    //  Make sure the pointer to the index isn't NULL and that the flags are within bounds.
    //  Note that we know have the NonInteractive flag which we need to filter out of the mapping.
    //
    if ((NULL == piIndex) || (c_dwLargestExecutionState < (dwFlags & ~NONINTERACTIVE)))
    {
        return E_INVALIDARG;
    }

    //
    //  The flags are based on a bit mask.  First look for all connections (since its
    //  zero) and then start looking for the most specific connection types first 
    //  (direct/dialup only before all dialup/tunnel).  Also note that we give precedent
    //  to tunnel connections and that we ingnore the NONINTERACTIVE flag except in the first
    //  if case.
    //
    DWORD dwArrayIndex;

    if ((ALL_CONNECTIONS == dwFlags) || (NONINTERACTIVE == dwFlags))
    {
        dwArrayIndex = 0;    
    }
    else if (dwFlags & DIRECT_ONLY)
    {
        dwArrayIndex = 1;
    }
    else if (dwFlags & DIALUP_ONLY)
    {
        dwArrayIndex = 3;
    }
    else if (dwFlags & ALL_TUNNEL)
    {
        dwArrayIndex = 4;
    }
    else if (dwFlags & ALL_DIALUP)
    {
        dwArrayIndex = 2;
    }
    else
    {
        return E_INVALIDARG;
    }

    *piIndex = c_iExecutionFlagsToIndexMap[dwArrayIndex];

    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::GetListPositionAndBuiltInState
//
// Synopsis:  This function searches for the item in question and returns to the
//            caller whether the item has the following boolean properties:
//              First in its custom action list
//              Last in its custom action list
//              A built in custom action
//            Note that -1 (0xFFFFFFFF) is returned for a true value
//                       0 for a false value
//
//
// Arguments: CustomActionListItem* pItem - item to look for (only desc and 
//                                          type are needed)
//            int* piFirstInList - pointer to store whether this is the first
//                                 item in the list or not
//            int* piLastInList - pointer to store whether this is the last
//                                 item in the list or not
//            int* piIsBuiltIn - pointer to store whether this item is a built
//                               in custom action or not
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::GetListPositionAndBuiltInState(HINSTANCE hInstance, CustomActionListItem* pItem, int* piFirstInList, 
                                                         int* piLastInList, int *piIsBuiltIn)
{
    MYDBGASSERT(pItem);
    MYDBGASSERT(piFirstInList);
    MYDBGASSERT(piLastInList);
    MYDBGASSERT(piIsBuiltIn);

    if ((NULL == pItem) || (NULL == piFirstInList) || (NULL == piLastInList) || (NULL == piIsBuiltIn))
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    CustomActionListItem* pCurrent = NULL;
    CustomActionListItem* pFollower = NULL;

    //
    //  Search for the item
    //
    hr = Find(hInstance, pItem->szDescription, pItem->Type, &pCurrent, &pFollower);

    if (SUCCEEDED(hr))
    {
        *piFirstInList = (m_CustomActionHash[pItem->Type] == pCurrent) ? -1 : 0;

        *piLastInList = (pCurrent && (NULL == pCurrent->Next)) ? -1 : 0;

        *piIsBuiltIn = (pCurrent->bBuiltInAction) ? -1 : 0;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::IsCmDl
//
// Synopsis:  Checks to see if the passed in filename cmdl32.exe
//
// Arguments: LPTSTR szFileName - filename to check
//
// Returns:   BOOL - returns TRUE if the dll is one of the cmdl dll's
//
// History:   quintinb  Created    11/24/97
//
//+----------------------------------------------------------------------------
BOOL CustomActionList::IsCmDl(CustomActionListItem* pItem)
{
    MYDBGASSERT(pItem);

    BOOL bRet = FALSE;

    if (pItem && (ONCONNECT == pItem->Type))
    {
        LPTSTR pszFileName = CmStrrchr(pItem->szProgram, TEXT('\\'));

        if (pszFileName)
        {
            pszFileName = CharNext(pszFileName);
        }
        else
        {
            pszFileName = pItem->szProgram;
        }

        if (0 == SafeCompareString(pszFileName, TEXT("cmdl32.exe")))
        {
            bRet = TRUE;
        }
    }
    return bRet;
}


//+----------------------------------------------------------------------------
//
// Function:  CustomActionListEnumerator::CustomActionListEnumerator
//
// Synopsis:  Constructor for the CustomActionListEnumerator class.  This function
//            requires a CustomActionList to enumerate from.
//
// Arguments: CustomActionList* pActionListToWorkFrom - custom action list class
//                                                      to enumerate
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
CustomActionListEnumerator::CustomActionListEnumerator(CustomActionList* pActionListToWorkFrom)
{
    MYDBGASSERT(pActionListToWorkFrom);
    m_pActionList = pActionListToWorkFrom;

    Reset();
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionListEnumerator::Reset
//
// Synopsis:  Resets the CustomActionListEnumerator class.  Thus the user can
//            restart the enumeration by resetting the class.
//
// Arguments: None
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
void CustomActionListEnumerator::Reset()
{
    m_iCurrentList = 0;
    m_pCurrentListItem = NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionListEnumerator::GetNextIncludedProgram
//
// Synopsis:  This function is the work horse of the enumerator.  It gets the
//            next item in the enumeration with an included program.  This
//            enumerator is useful for getting all of the files that need to be
//            included in the profile.
//
// Arguments: TCHAR* pszProgram - string buffer to hold the next program
//            DWORD dwBufferSize - size of the passed in buffer
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionListEnumerator::GetNextIncludedProgram(TCHAR* pszProgram, DWORD dwBufferSize)
{
    HRESULT hr = S_FALSE;
    CustomActionListItem* pItem;

    if (pszProgram && dwBufferSize)
    {
        if (m_pActionList)
        {
            while (m_iCurrentList < c_iNumCustomActionTypes)
            {
                if (m_pCurrentListItem)
                {
                    //
                    //  We are in the middle of an enumeration, use pCurrentProgramFileNameItem
                    //  as the next item to examine.
                    //
                    pItem = m_pCurrentListItem;
                }
                else
                {
                    //
                    //  We are just starting or we have exhausted the current list
                    //
                    pItem = m_pActionList->m_CustomActionHash[m_iCurrentList];
                }

                while (pItem)
                {

                    if (pItem->bIncludeBinary)
                    {
                        //
                        //  We have the next item to pass back
                        //
                        lstrcpyn(pszProgram, pItem->szProgram, dwBufferSize);
                        
                        //
                        //  Next time we look for an item, start with the next in the list
                        //
                        m_pCurrentListItem = pItem->Next;

                        //
                        //  If m_pCurrentListItem is NULL, we are at the end of the list now
                        //  and we want to increment m_iCurrentList so that we start at the
                        //  next list for the next item or terminate properly if we are
                        //  on the last list
                        //
                        if (NULL == m_pCurrentListItem)
                        {
                            m_iCurrentList++;
                        }
                        
                        hr = S_OK;
                        goto exit;
                    }

                    pItem = pItem->Next;
                }
                
                m_pCurrentListItem = NULL;
                m_iCurrentList++;
            }
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\pbasetup\pbasetup.cpp ===
//+----------------------------------------------------------------------------
//
// File:     pbasetup.cpp
//
// Module:   PBASETUP.EXE
//
// Synopsis: PBA stand alone installer for ValueAdd
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   v-vijayb   Created    05/25/99
//
//+----------------------------------------------------------------------------

#include "pbamaster.h"
#include "cmplat.h"

//  This is really ugly, we need to consolidate our platform detection code between CM and
//  the setup components.
BOOL IsAtLeastNT5()
{
    CPlatform plat;
    return plat.IsAtLeastNT5();
}
#define OS_NT5 (IsAtLeastNT5())

#include "MemberOfGroup.cpp"


TCHAR g_szAppTitle[MAX_PATH]; // global buffer for app. title

const TCHAR* const c_pszPBAStpMutex = TEXT("Phone Book Administration Installer");

HRESULT UnregisterAndDeleteDll(PCSTR pszFile);;
HRESULT RegisterDll(PCSTR pszFile);
BOOL UninstallPBA(HINSTANCE hInstance, LPCSTR szInfPath);
BOOL IsAdmin(void);


int WINAPI WinMain (HINSTANCE, // hInstance 
                    HINSTANCE,  //hPrevInstance
                    PSTR, // szCmdLine
                    int) //iCmdShow
{
    HINSTANCE   hInstance = GetModuleHandleA(NULL);
    TCHAR       szMsg[MAX_PATH+1];
    TCHAR       szTemp[MAX_PATH+1];
    TCHAR       szInfPath[MAX_PATH+1];
    TCHAR       szCurrentDir[MAX_PATH+1];
    DWORD       idMsgEnd;
    DWORD       dwFlags;
    CPlatform   pPlatForm;
    LPTSTR      pszCommandLine;
    const DWORD c_dwNormal = 0;
    TCHAR c_pszUninstallMode[] = TEXT("/u");
    const DWORD c_dwUninstallMode = 0x1;
    BOOL        bUsageError = FALSE;
    BOOL        bAnotherInstanceRunning = FALSE;
    
    const int   c_NumArgs = 1;

    MYVERIFY(0 != LoadString(hInstance, IDS_APP_TITLE, g_szAppTitle, MAX_PATH));

    if (!pPlatForm.IsAtLeastNT5())
    {
        MYVERIFY(0 != LoadString(hInstance, IDS_NOT_NT5, szMsg, MAX_PATH));
        
        MessageBox(NULL, szMsg, g_szAppTitle, MB_OK);            
        return (-1);
    }
    
    //
    // check that the user has sufficient permissions
    //

    if (!IsAdmin())
    {
        MYVERIFY(0 != LoadString(hInstance, IDS_NOPERMS_MSG, szMsg, MAX_PATH));
        
        MessageBox(NULL, szMsg, g_szAppTitle, MB_OK);    
        return (-1);
    }

    //
    //  Get the Command Line
    //
    
    pszCommandLine = GetCommandLine();

    //
    //  Setup the Class to process the command line args
    //

    ZeroMemory(szTemp, sizeof(szTemp));
    ZeroMemory(szInfPath, sizeof(szInfPath));

    ArgStruct Args[c_NumArgs];

    Args[0].pszArgString = c_pszUninstallMode;
    Args[0].dwFlagModifier = c_dwUninstallMode;

    {   // Make sure ArgProcessor gets destructed properly and we don't leak mem

        CProcessCmdLn ArgProcessor(c_NumArgs, (ArgStruct*)Args, TRUE, 
            TRUE); //bSkipFirstToken == TRUE, bBlankCmdLnOkay == TRUE

        if (ArgProcessor.GetCmdLineArgs(pszCommandLine, &dwFlags, szTemp, MAX_PATH))
        {
            CNamedMutex CmPBAMutex;
        
            if (CmPBAMutex.Lock(c_pszPBAStpMutex, FALSE, 0))
            {
                //
                //  We got the mutex lock, so Construct the Inf Paths and continue.
                //  Note that we don't use any file arguments passed into cmakstp.
                //  It is setup to do so, but we don't need it.
                //

                MYVERIFY(0 != GetCurrentDirectory(MAX_PATH, szCurrentDir));
                MYVERIFY(CELEMS(szInfPath) > (UINT)wsprintf(szInfPath, TEXT("%s\\pbasetup.inf"), szCurrentDir));
                
                if (c_dwNormal == dwFlags)
                {
                    if (InstallPBA(hInstance, szInfPath))
                    {
                        MYVERIFY(0 != LoadString(hInstance, IDS_SUCCESSFUL, szMsg, MAX_PATH));
                        
                        MessageBox(NULL, szMsg, g_szAppTitle, MB_OK | MB_APPLMODAL | MB_TOPMOST | MB_SETFOREGROUND);            
                    }
                }
                else if (c_dwUninstallMode & dwFlags)
                {
                    // Confirm if the user wants to remove the program
                    MYVERIFY(0 != LoadString(hInstance, IDS_REMOVEPBA, szMsg, MAX_PATH));
                    if (MessageBox(NULL, szMsg, g_szAppTitle, MB_YESNO | MB_APPLMODAL | MB_TOPMOST | MB_SETFOREGROUND) != IDYES)
                    {
                        ExitProcess(0);
                        return (0);
                    }
                    
                    if (UninstallPBA(hInstance, szTemp))
                    {
                        MYVERIFY(0 != LoadString(hInstance, IDS_REMOVESUCCESSFUL, szMsg, MAX_PATH));
                        
                        MessageBox(NULL, szMsg, g_szAppTitle, MB_OK | MB_APPLMODAL | MB_TOPMOST | MB_SETFOREGROUND);            
                    }
                }
                else
                {
                    //
                    //  unsupported switch
                    //
                    bUsageError = TRUE;    
                }
            }
            else
            {
                bAnotherInstanceRunning = TRUE;
            }        
        }
        else
        {
            bUsageError = TRUE;    
        }
    }
    
    if (bUsageError)
    {        
        MYVERIFY(0 != LoadString(hInstance, IDS_USAGE_MSG, szMsg, MAX_PATH));
        
        MessageBox(NULL, szMsg, g_szAppTitle, MB_OK);        
    }
    else if (bAnotherInstanceRunning)
    {
        MYVERIFY(0 != LoadString(hInstance, IDS_INUSE_MSG, szMsg, MAX_PATH));
        
        MessageBox(NULL, szMsg, g_szAppTitle, MB_OK);    
    }
    
    ExitProcess(0); 
    return (0);
}


const TCHAR* const c_szDaoClientsPath = TEXT("SOFTWARE\\Microsoft\\Shared Tools\\DAO\\Clients");
const TCHAR* c_szMSSharedDAO360Path = TEXT("Microsoft Shared\\DAO");
const TCHAR* c_szCommonFilesDir = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion");

//+---------------------------------------------------------------------------
//
//  Function:   HrGetPbaInstallPath
//
//  Purpose:    Get the install path for pbadmin.exe.
//
//  Arguments:  pszCpaPath -- buffer to hold the install path of PBA.
//              dwNumChars -- the number of characters that the buffer can hold.
//
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 19 OCT 1998
//
//  Notes:
//

HRESULT HrGetPbaInstallPath(PTCHAR pszCpaPath, DWORD dwNumChars)
{
    HRESULT hr = E_FAIL;
    HKEY hKey;
    BOOL bFound = FALSE;
    DWORD   lError;
    
    //  We need to setup the custom DIRID so that CPA will install
    //  to the correct location.  First get the path from the system.
    //

    ZeroMemory(pszCpaPath, sizeof(TCHAR)*dwNumChars);
    lError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szDaoClientsPath, 0, KEY_READ, &hKey);

    if (lError == ERROR_SUCCESS)
    {
        TCHAR szCurrentValue[MAX_PATH+1];
        TCHAR szCurrentData[MAX_PATH+1];
        DWORD dwValueSize = MAX_PATH;
        DWORD dwDataSize = MAX_PATH;
        DWORD dwType;
        DWORD dwIndex = 0;

        hr = S_OK;
        while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szCurrentValue, &dwValueSize, NULL, &dwType,
               (LPBYTE)szCurrentData, &dwDataSize))
        {
            _strlwr(szCurrentValue);
            if (NULL != strstr(szCurrentValue, TEXT("pbadmin.exe")))
            {
                //
                //  Then we have found the PBA path
                //

                TCHAR* pszTemp = strrchr(szCurrentValue, '\\');
                if (NULL != pszTemp)
                {
                    *pszTemp = L'\0';
                    lstrcpy(pszCpaPath, szCurrentValue);
                    bFound = TRUE;
                    break;
                }
            }
            dwValueSize = MAX_PATH;
            dwDataSize = MAX_PATH;
            dwIndex++;
        }

        RegCloseKey(hKey);
    }

    if (!bFound)
    {
        BOOL    bTmp;

        //  This is  a fresh install of PBA, don't return an error
        //
        bTmp = SHGetSpecialFolderPath(NULL, pszCpaPath, CSIDL_PROGRAM_FILES, FALSE);

        if (bTmp)
        {
            lstrcat(pszCpaPath, TEXT("\\PBA"));
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RefCountPbaSharedDlls
//
//  Purpose:    Reference count and register/unregister all of the PBAdmin
//              shared components.
//
//  Arguments:  BOOL bIncrement -- if TRUE, then increment the ref count,
//                                 else decrement it
//
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 9 OCT 1998
//
//  Notes:
//
HRESULT RefCountPbaSharedDlls(BOOL bIncrement)
{
    HRESULT hr = S_OK;
    HKEY hKey;
    TCHAR szSystemDir[MAX_PATH+1];
    TCHAR szDaoPath[MAX_PATH+1], szCommonFilesPath[MAX_PATH+1];
    DWORD dwSize;
    DWORD dwCount;
    LONG lResult;
    const UINT uNumDlls = 5;
    const UINT uStringLen = 12 + 1;
    const TCHAR* const c_szSsFmt = TEXT("%s\\%s");
    const TCHAR* const c_szSharedDllsPath = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDlls");
    TCHAR mszDlls[uNumDlls][uStringLen] = {  "comctl32.ocx",
                                                 "comdlg32.ocx",
                                                 "msinet.ocx",
                                                 "tabctl32.ocx",
                                                 "dao360.dll"
                                                 };

    TCHAR mszDllPaths[uNumDlls][MAX_PATH];


    //
    //  All of the Dlls that we ref count are in the system directory, except for Dao350.dll.
    //  Thus we want to append the system directory path to our filenames and handle dao last.
    //

    if (0 == GetSystemDirectory(szSystemDir, MAX_PATH))
    {
        return E_UNEXPECTED;
    }

    for (int i = 0; i < (uNumDlls-1) ; i++)
    {
        wsprintf(mszDllPaths[i], c_szSsFmt, szSystemDir, mszDlls[i]);
    }

    //
    //  Now write out the dao360.dll path.
    //
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szCommonFilesDir, 0, NULL, 
                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwSize))
    {
        dwSize = sizeof(szCommonFilesPath);
        lResult = RegQueryValueEx(hKey, TEXT("CommonFilesDir"), NULL, NULL,(LPBYTE)szCommonFilesPath, &dwSize);
        RegCloseKey(hKey);
    }
    
    if (ERROR_SUCCESS != lResult)
    {
        _tcscpy(szCommonFilesPath, TEXT("c:\\Program Files\\Common Files"));
    }
    
    wsprintf(szDaoPath, TEXT("%s\\%s"), szCommonFilesPath, c_szMSSharedDAO360Path);
    wsprintf(mszDllPaths[i], c_szSsFmt, szDaoPath, mszDlls[i]);

    //
    //  Open the shared DLL key and start enumerating our multi-sz with all of our dll's
    //  to add.
    //
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szSharedDllsPath,
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwSize)) // using dwSize as a temp to hold the disposition value
    {
        for (int i=0; i < uNumDlls; i++)
        {
            dwSize = sizeof(DWORD);

            lResult = RegQueryValueEx(hKey, mszDllPaths[i], NULL, NULL,(LPBYTE)&dwCount, &dwSize);

            if (ERROR_SUCCESS == lResult)
            {
                //
                //  Increment or decrement as appropriate.  Make sure not to decrement 0
                //

                if (0 != dwCount || bIncrement)
                {
                    dwCount = dwCount + (bIncrement ? 1 : -1);
                }
            }
            else if (ERROR_FILE_NOT_FOUND == lResult)
            {
                if (bIncrement)
                {
                    //
                    //  The the value doesn't yet exist.  Set the count to 1.
                    //
                    dwCount = 1;
                }
                else
                {
                    //
                    //  We are decrementing and we couldn't find the DLL, nothing to
                    //  change for the count but we should still delete the dll.
                    //
                    dwCount = 0;
                }
            }
            else
            {
                hr = S_FALSE;
                continue;
            }

            //
            //  Not that we have determined the ref count, do something about it.
            //
            if (dwCount == 0)
            {
                //
                //  We don't want to delete dao350.dll, but otherwise we need to delete
                //  the file if it has a zero refcount.
                //

                if (CSTR_EQUAL == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, mszDlls[i], -1, TEXT("dao360.dll"), -1))
                {
                    hr = UnregisterAndDeleteDll(mszDllPaths[i]);
                    if (FAILED(hr))
                    {
                        //
                        //  Don't fail the setup over a file that we couldn't unregister or
                        //  couldn't delete
                        //
                        hr = S_FALSE;
                    }
                }
                RegDeleteValue(hKey, mszDllPaths[i]);
            }
            else
            {
                //
                //  Set the value to its new count.
                //
                if (ERROR_SUCCESS != RegSetValueEx(hKey, mszDllPaths[i], 0, REG_DWORD,
                    (LPBYTE)&dwCount, sizeof(DWORD)))
                {
                    hr = S_FALSE;
                }

                //
                //  If we are incrementing the count then we should register the dll.
                //
                if (bIncrement)
                {
                    hr = RegisterDll(mszDllPaths[i]);
                }
            }
        }

        RegCloseKey(hKey);
    }

///    TraceError("RefCountPbaSharedDlls", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   UnregisterAndDeleteDll
//
//  Purpose:    Unregister and delete the given COM component
//
//  Arguments:  pszFile -- The full path to the file to unregister and delete
//
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 9 OCT 1998
//
//  Notes:
//

HRESULT UnregisterAndDeleteDll(PCSTR pszFile)
{
    HINSTANCE hLib = NULL;
    FARPROC pfncUnRegister;
    HRESULT hr = S_OK;

    if ((NULL == pszFile) || (L'\0' == pszFile[0]))
    {
        return E_INVALIDARG;
    }

    hLib = LoadLibrary(pszFile);
    if (NULL != hLib)
    {
        pfncUnRegister = GetProcAddress(hLib, "DllUnregisterServer");
        if (NULL != pfncUnRegister)
        {
            hr = (HRESULT)(pfncUnRegister)();
            if (SUCCEEDED(hr))
            {
                FreeLibrary(hLib);
                hLib = NULL;
//  You can add this back in as long as you are sure that we copied the file down and thus
//  should be deleting it when the ref count is Zero.

//  This was removed because PBA setup is moving to Value Add and because of bug 323231
//                if (!DeleteFile(pszFile))
//                {
//                    hr = S_FALSE;
//                }
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    if (NULL != hLib)
    {
        FreeLibrary(hLib);
    }


///    TraceError("UnregisterAndDeleteDll", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterDll
//
//  Purpose:    Register the given COM component
//
//  Arguments:  pszFile -- The full path to the file to register
//
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 9 OCT 1998
//
//  Notes:
//

HRESULT RegisterDll(PCSTR pszFile)
{
    HINSTANCE hLib = NULL;
    FARPROC pfncRegister;
    HRESULT hr = S_OK;

    if ((NULL == pszFile) || (L'\0' == pszFile[0]))
    {
        return E_INVALIDARG;
    }

    hLib = LoadLibrary(pszFile);
    if (NULL != hLib)
    {
        pfncRegister = GetProcAddress(hLib, "DllRegisterServer");
        if (NULL != pfncRegister)
        {
            hr = (HRESULT)(pfncRegister)();
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    if (NULL != hLib)
    {
        FreeLibrary(hLib);
    }


///    TraceError("RegisterDll", hr);
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  InstallPBA
//
// Synopsis:  This function is responsible for installing PBA
//
// Arguments: HINSTANCE hInstance - Exe Instance handle for resources
//            LPCTSTR szInfPath - Path of the INF to install from
//
// Returns:   BOOL - returns TRUE if successful.
//
// History:   v-vijayb Created Header    5/25/99
//
//+----------------------------------------------------------------------------

BOOL InstallPBA(HINSTANCE hInstance, LPCSTR szInfPath)
{
    BOOL        fInstalled = FALSE;
    TCHAR       szTemp[MAX_PATH+1];

    //
    //  Check to see that these files exist
    //
    if (!FileExists(szInfPath))
    {
        wsprintf(szTemp, TEXT("InstallPBA, unable to find %s"), szInfPath);
        MessageBox(NULL, szTemp, g_szAppTitle, MB_OK);
        return (FALSE);
    }


    if (HrGetPbaInstallPath(szTemp, sizeof(szTemp)) == S_OK)
    {
        HKEY        hKey;
        
        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szDaoClientsPath, 0, "", 
                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
        {
            RegSetValueEx(hKey, "PBAPath", 0, REG_SZ, (PBYTE) szTemp, lstrlen(szTemp) + sizeof(TCHAR));
            RegCloseKey(hKey);  
        }
    }

    
    MYVERIFY(SUCCEEDED(LaunchInfSection(szInfPath, TEXT("DefaultInstall"), g_szAppTitle, 0)));

    RefCountPbaSharedDlls(TRUE);
    
    fInstalled = TRUE;
    
    return (fInstalled);
} // InstallPBA()


//+----------------------------------------------------------------------------
//
// Function:  UnInstallPBA
//
// Synopsis:  This function is responsible for uninstalling PBA
//
// Arguments: HINSTANCE hInstance - Exe Instance handle for resources
//            LPCTSTR szInfPath - Path of the INF to install from
//
// Returns:   BOOL - returns TRUE if successful.
//
// History:   v-vijayb Created Header    5/25/99
//
//+----------------------------------------------------------------------------

BOOL UninstallPBA(HINSTANCE hInstance, LPCSTR szInfPath)
{
    BOOL        fUninstalled = FALSE;
    TCHAR       szTemp[MAX_PATH+1];

    //
    //  Check to see that these files exist
    //
    if (!FileExists(szInfPath))
    {
        wsprintf(szTemp, TEXT("UninstallPBA, unable to find %s"), szInfPath);
        MessageBox(NULL, szTemp, g_szAppTitle, MB_OK);
        return (FALSE);
    }


    MYVERIFY(SUCCEEDED(LaunchInfSection(szInfPath, TEXT("Uninstall"), g_szAppTitle, 0)));

    RefCountPbaSharedDlls(FALSE);
    
    fUninstalled = TRUE;
    
    return (fUninstalled);
} // UninstallPBA()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\profwiz\listview.h ===
//+----------------------------------------------------------------------------
//
// File:     listview.h
//
// Module:   CMAK.EXE
//
// Synopsis: Function definitions of the helper functions used by CMAK to deal
//           with the custom action list view control.
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created                         02/26/00
//
//+----------------------------------------------------------------------------

BOOL UpdateListViewColumnHeadings(HINSTANCE hInstance, HWND hListView, UINT uStringID, int iColumnIndex);
BOOL AddListViewColumnHeadings(HINSTANCE hInstance, HWND hListView);

HRESULT MapComboSelectionToType(HWND hDlg, UINT uCtrlID, BOOL bIncludesAll, BOOL bUseTunneling, CustomActionTypes* pType);
HRESULT GetDescriptionAndTypeOfItem(HINSTANCE hInstance, HWND hDlg, HWND hListView, UINT uComboBoxId, CustomActionListItem* pItem, int* piItemIndex, BOOL bUseTunneling);
HRESULT GetItemTypeByListViewIndex(HINSTANCE hInstance, HWND hListView, CustomActionTypes* pType, int* piIndex);
void SetListViewSelection(HWND hListView, int iIndex);

void RefreshEditDeleteMoveButtonStates(HINSTANCE hInstance, HWND hDlg, HWND hListView, UINT uComboCtrlId, int* piIndex, BOOL bUseTunneling);
void RefreshListView(HINSTANCE hInstance, HWND hDlg, UINT uComboCtrlId, HWND hListView, int iItemToSelect, BOOL bUseTunneling);
void OnProcessCustomActionsAdd(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling);
void OnProcessCustomActionsDelete(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling);
void OnProcessCustomActionsEdit(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling);
void OnProcessCustomActionsMoveUp(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling);
void OnProcessCustomActionsMoveDown(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling);
void OnProcessCustomActionsContextMenu(HINSTANCE hInstance, HWND hDlg, HWND hListView, 
                                       NMITEMACTIVATE* pItemActivate, BOOL bUseTunneling, UINT uComboCtrlId);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\profwiz\customaction.h ===
//+----------------------------------------------------------------------------
//
// File:     customaction.h
//
// Module:   CMAK.EXE
//
// Synopsis: Header file for the CustomActionList and CustomActionListEnumerator
//           classes used by CMAK to handle its custom actions.
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created                         02/26/00
//
//+----------------------------------------------------------------------------

#include "conact.h"

//
//  We display the flags to the user in a different order than the flags were created.  Thus we have to arrays to
//  map between the display order and the actual order and vice versa.
//
const int c_iExecutionIndexToFlagsMap[c_iNumCustomActionExecutionStates] = {ALL_CONNECTIONS, ALL_DIALUP, ALL_TUNNEL, DIRECT_ONLY, DIALUP_ONLY};
const int c_iExecutionFlagsToIndexMap[c_iNumCustomActionExecutionStates] = {0, 3, 1, 4, 2};

//
//  Enum for Connect Action Types
//
const int c_iNumCustomActionTypes = 9;
enum CustomActionTypes
{
    PREINIT = 0,
    PRECONNECT = 1,
    PREDIAL = 2,
    PRETUNNEL = 3,
    ONCONNECT = 4,
    ONINTCONNECT = 5,
    ONDISCONNECT = 6,
    ONCANCEL = 7,
    ONERROR = 8,
    ALL = -1
};

struct CustomActionListItem
{
    TCHAR szDescription[MAX_PATH+1];
    TCHAR szProgram[MAX_PATH+1];
    TCHAR szFunctionName[MAX_PATH+1];
    LPTSTR pszParameters;
    BOOL bIncludeBinary;
    BOOL bBuiltInAction;
    BOOL bTempDescription;
    CustomActionTypes Type;
    DWORD dwFlags;
    CustomActionListItem* Next;
};

class CustomActionList
{

    //
    //  This enumerator class is used to enumerate
    //  the data in the Custom Action List class.
    //  This allows the enumerator to have access to
    //  the private data of CustomActionList but
    //  controls how the user of this class accesses
    //  that data.
    //
    friend class CustomActionListEnumerator;

private:

    //
    //  Array of Linked lists to hold the custom actions
    //
    CustomActionListItem* m_CustomActionHash[c_iNumCustomActionTypes];

    //
    //  Array of string pointers to hold the custom action type strings, plus
    //  the special All type string pointer.
    //
    TCHAR* m_ActionTypeStrings[c_iNumCustomActionTypes];
    TCHAR* m_pszAllTypeString;

    //
    //  Array of string pointers to hold the CMS section names for each type
    //  of custom action.  Note that these strings are const TCHAR* const and
    //  shouldn't be free-ed.
    //
    TCHAR* m_ActionSectionStrings[c_iNumCustomActionTypes];
    
    //
    //  Array of string pointers to hold the custom action execution state
    //  strings.  These are added to the combo box on the Add/Edit custom
    //  action dialog to allow the user to pick when a custom action is
    //  executed
    //
    TCHAR* m_ExecutionStrings[c_iNumCustomActionExecutionStates];

    //
    //  Functions internal to the class
    //
    HRESULT ParseCustomActionString(LPTSTR pszStringToParse, CustomActionListItem* pCustomAction, TCHAR* pszShortServiceName);
    HRESULT Find(HINSTANCE hInstance, LPCTSTR pszDescription, CustomActionTypes Type, CustomActionListItem** ppItem, CustomActionListItem** ppFollower);
    HRESULT EnsureActionTypeStringsLoaded(HINSTANCE hInstance);
    BOOL IsCmDl(CustomActionListItem* pItem);


public:
    CustomActionList();
    ~CustomActionList();
    HRESULT ReadCustomActionsFromCms(HINSTANCE hInstance, TCHAR* pszCmsFile, TCHAR* pszShortServiceName);
    HRESULT WriteCustomActionsToCms(TCHAR* pszCmsFile, TCHAR* pszShortServiceName, BOOL bUseTunneling);
    HRESULT Add(HINSTANCE hInstance, CustomActionListItem* pCustomAction, LPCTSTR pszShortServiceName);
    HRESULT Edit(HINSTANCE hInstance, CustomActionListItem* pOldCustomAction, CustomActionListItem* pNewCustomAction, LPCTSTR pszShortServiceName);
    HRESULT GetExistingActionData(HINSTANCE hInstance, LPCTSTR pszDescription, CustomActionTypes Type, CustomActionListItem** ppCustomAction);
    HRESULT Delete(HINSTANCE hInstance, TCHAR* pszDescription, CustomActionTypes Type);
    HRESULT MoveUp(HINSTANCE hInstance, TCHAR* pszDescription, CustomActionTypes Type);
    HRESULT MoveDown(HINSTANCE hInstance, TCHAR* pszDescription, CustomActionTypes Type);
    HRESULT AddCustomActionTypesToComboBox(HWND hDlg, UINT uCtrlId, HINSTANCE hInstance, BOOL bUseTunneling, BOOL bAddAll);
    HRESULT AddCustomActionsToListView(HWND hListView, HINSTANCE hInstance, CustomActionTypes Type, BOOL bUseTunneling, int iItemToSelect, BOOL bTypeInSecondCol);
    HRESULT GetTypeFromTypeString(HINSTANCE hInstance, TCHAR* pszTypeString, CustomActionTypes* pType);
    HRESULT GetTypeStringFromType(HINSTANCE hInstance, CustomActionTypes Type, TCHAR** ppszTypeString);
    HRESULT AddExecutionTypesToComboBox(HWND hDlg, UINT uCtrlId, HINSTANCE hInstance, BOOL bUseTunneling);
    HRESULT MapIndexToFlags(int iIndex, DWORD* pdwFlags);
    HRESULT MapFlagsToIndex(DWORD dwFlags, int* piIndex);
    HRESULT FillInTempDescription(CustomActionListItem* pCustomAction);
    HRESULT GetListPositionAndBuiltInState(HINSTANCE hInstance, CustomActionListItem* pItem, BOOL* pbFirstInList, BOOL* pbLastInList, BOOL *pIsBuiltIn);
    HRESULT AddOrRemoveCmdl(HINSTANCE hInstance, BOOL bAddCmdl, BOOL bForVpn);
};

class CustomActionListEnumerator
{
private:
    int m_iCurrentList;
    CustomActionListItem* m_pCurrentListItem;
    CustomActionList* m_pActionList;

public:
    CustomActionListEnumerator(CustomActionList* pActionListToWorkFrom);
//    ~CustomActionListEnumerator(); // currently not needed
    void Reset();
    HRESULT GetNextIncludedProgram(TCHAR* pszProgram, DWORD dwBufferSize);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\profwiz\netsettings.h ===
//+----------------------------------------------------------------------------
//
// File:     netsettings.h
//
// Module:   CMAK.EXE
//
// Synopsis: Function headers and structures dealing with network 
//           settings (DUN settings)
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created     03/22/00
//
//+----------------------------------------------------------------------------

#define SAME_ON_ALL_PLATFORMS           0
#define SEPARATE_FOR_LEGACY_AND_WIN2K   1
#define FORCE_WIN2K_AND_ABOVE           2

class CDunSetting
{
public:
    //
    //  Functions
    //
    CDunSetting(BOOL bTunnel = FALSE);
    ~CDunSetting();

    //
    //  Basic Settings
    //
    BOOL bNetworkLogon; // defaults to zero on Dialup but 1 on Tunnel
    BOOL bPppSoftwareCompression;
    BOOL bDisableLCP;

    TCHAR szScript[MAX_PATH+1];
    DWORD dwVpnStrategy;
    BOOL bTunnelDunSetting;
    BOOL bUseDownLevelL2TP;

    //
    //  TCP/IP Settings
    //
    DWORD dwPrimaryDns;
    DWORD dwSecondaryDns;
    DWORD dwPrimaryWins;
    DWORD dwSecondaryWins;
    BOOL bIpHeaderCompression;
    BOOL bGatewayOnRemote;

    //
    //  Security Settings
    //
    BOOL bPWEncrypt;
    BOOL bPWEncrypt_MS;
    BOOL bDataEncrypt;
    DWORD dwEncryptionType;
    BOOL bAllowPap;
    BOOL bAllowSpap;
    BOOL bAllowEap;
    BOOL bAllowChap;
    BOOL bAllowMsChap;
    BOOL bAllowMsChap2;
    BOOL bAllowW95MsChap;
    BOOL bSecureLocalFiles;
    int iHowToHandleSecuritySettings;

    //
    //  EAP Data
    //
    DWORD dwCustomAuthKey;
    LPBYTE pCustomAuthData;
    DWORD dwCustomAuthDataSize;

    //
    //  Pre-shared Key
    //
    BOOL bUsePskOnWin2kPlus;
    BOOL bUsePskDownLevel;
};

//
// From RAS\UI\COMMON\PBK\UTIL.C
//

#ifndef EAP_CUSTOM_DATA

#define EAP_CUSTOM_KEY      0x43424431

typedef struct _EAP_CUSTOM_DATA
{
    DWORD dwSignature;
    DWORD dwCustomAuthKey;
    DWORD dwSize;
    BYTE  abdata[1];
} EAP_CUSTOM_DATA;

#endif

typedef struct EAPDataStruct
{
    DWORD dwCustomAuthKey;
    LPBYTE pCustomAuthData;
    DWORD dwCustomAuthDataSize;
    LPTSTR pszFriendlyName;
    LPTSTR pszConfigDllPath;
    BOOL bSupportsEncryption;
    BOOL bMustConfig;
    BOOL bNotInstalled;
}EAPData;

typedef struct GetBoolSettingsStruct
{
    LPCTSTR pszKeyName;
    LPBOOL pbValue;
    BOOL bDefault;
}GetBoolSettings;

typedef struct SetBoolSettingsStruct
{
    LPTSTR pszSectionName;
    LPCTSTR pszKeyName;
    BOOL bValue;
}SetBoolSettings;

BOOL ReadDunServerSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszCmsFile, BOOL bTunnelDunSetting);
BOOL ReadDunNetworkingSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszCmsFile, BOOL bTunnel);
DWORD ConvertIpStringToDword(LPTSTR pszIpAddress);
int ConvertIpDwordToString(DWORD dwIpAddress, LPTSTR pszIpAddress);
BOOL ReadDunTcpIpSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszCmsFile);
BOOL ReadDunScriptingSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszOsDir, LPCTSTR pszCmsFile);
BOOL AddDunNameToListIfDoesNotExist(LPCTSTR pszDunName, ListBxList **pHeadDns, ListBxList** pTailDns, BOOL bTunnelDunName);
BOOL GetDunEntryNamesFromPbk(LPCTSTR pszPhoneBook, ListBxList **pHeadDns, ListBxList** pTailDns);
BOOL ReadNetworkSettings(LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName, LPCTSTR pszPhoneBook, 
                         ListBxList **pHeadDns, ListBxList** pTailDns, LPCTSTR pszOsDir, BOOL bLookingForVpnEntries);
void WriteOutNetworkingEntry(LPCTSTR pszDunName, CDunSetting* pDunSetting, LPCTSTR pszShortServiceName, LPCTSTR pszCmsFile);
void EraseNetworkingSections(LPCTSTR pszDunName, LPCTSTR pszCmsFile);
void WriteNetworkingEntries(LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName, LPCTSTR pszShortServiceName, ListBxList *pHeadDns);
void EnableAppropriateSecurityControls(HWND hDlg);
void EnableDisableSecurityButtons(HWND hDlg);
INT_PTR CreateNetworkingEntryPropertySheet(HINSTANCE hInstance, HWND hWizard, LPARAM lParam, BOOL bEdit);
void OnProcessDunEntriesAdd(HINSTANCE hInstance, HWND hDlg, UINT uListCtrlId, ListBxStruct** pHeadDns, ListBxStruct** pTailDns, BOOL bCreateTunnelEntry, LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile);
void OnProcessDunEntriesEdit(HINSTANCE hInstance, HWND hDlg, UINT uListCtrlId, ListBxStruct** pHeadDns, ListBxStruct** pTailDns, LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile);
void OnProcessDunEntriesDelete(HINSTANCE hInstance, HWND hDlg, UINT uListCtrlId, ListBxStruct** pHeadDns, ListBxStruct** pTailDns, LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile);
void EnableDisableIpAddressControls(HWND hDlg);
INT_PTR APIENTRY ProcessSecurityPopup(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ProcessWin2kSecurityPopup(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY GeneralPropSheetProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY TcpIpPropSheetProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY SecurityPropSheetProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void RefreshDnsList(HINSTANCE hInstance, HWND hDlg, UINT uCtrlId, ListBxList * pHead, LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile, LPTSTR pszItemToSelect);

HRESULT HrAddAvailableEAPsToCombo(HWND hDlg, UINT uCtrlId, CDunSetting* pDunSetting);
HRESULT HrQueryRegStringWithAlloc(HKEY hKey, LPCTSTR pszValueName, TCHAR** ppszReturnString);
void SelectAppropriateEAP(HWND hDlg, UINT uCtrlId, CDunSetting* pDunSetting);
void FreeEapData(HWND hDlg, UINT uCtrlId);
BOOL ReadDunSettingsEapData(LPCTSTR pszSection, LPBYTE* ppbEapData, LPDWORD pdwEapSize, const DWORD dwCustomAuthKey, LPCTSTR pszCmsFile);
HRESULT WriteDunSettingsEapData(LPCTSTR pszSection, CDunSetting* pDunSetting, LPCTSTR pszCmsFile);
//HRESULT EraseDunSettingsEapData(LPCTSTR pszSection, LPCTSTR pszCmsFile);
BYTE HexValue(IN CHAR ch);
CHAR HexChar(IN BYTE byte);
void FreeDnsList(ListBxList ** pHeadPtr, ListBxList ** pTailPtr);
void EnableDisableDunEntryButtons(HINSTANCE hInstance, HWND hDlg, LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName);
int MapEncryptionTypeToComboId(DWORD dwEncryptionType);
DWORD MapComboIdToEncryptionType(INT_PTR iComboIndex);
BOOL VerifyVpnFile(LPCTSTR pszVpnFile);
BOOL CheckForDUNversusVPNNameConflicts(HWND hDlg, ListBxList * pHeadDunEntry, ListBxList * pHeadVpnEntry);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\profwiz\netsettings.cpp ===
//+----------------------------------------------------------------------------
//
// File:     netsettings.cpp
//
// Module:   CMAK.EXE
//
// Synopsis: Code dealing with network settings (DUN settings).
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created     03/22/00
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include <windowsx.h>
extern BOOL g_bNewProfile;

#define CM_CMAK 1
#include "cm_eap.cpp"

//+----------------------------------------------------------------------------
//
// Function:  ReadDunServerSettings
//
// Synopsis:  Reads in all of the settings from the Server DUN setting section
//            specified.
//
// Arguments: LPCTSTR pszSectionName - full name of the server section to read
//                                     (Server&Fred or whatever)
//            CDunSetting* pDunSetting - Dun Settings data structure to store 
//                                       the read in values to
//            LPCTSTR pszCmsFile - Cms file to read the settings from
//            BOOL bTunnelDunSetting - whether this is a tunnel dun setting or not
//
// Returns:   BOOL - TRUE if the settings were read in correctly
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
BOOL ReadDunServerSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszCmsFile, BOOL bTunnelDunSetting)
{
    if ((NULL == pszSectionName) || (NULL == pDunSetting) || (NULL == pszCmsFile) ||
        (TEXT('\0') == pszSectionName[0]) || (TEXT('\0') == pszCmsFile[0]))
    {
        CMASSERTMSG(FALSE, TEXT("ReadDunServerSettings -- invalid parameter"));
        return FALSE;
    }

    GetBoolSettings ArrayOfServerSettings[] = {
        {c_pszCmEntryDunServerNetworkLogon, &(pDunSetting->bNetworkLogon), bTunnelDunSetting},
        {c_pszCmEntryDunServerSwCompress, &(pDunSetting->bPppSoftwareCompression), 1},
        {c_pszCmEntryDunServerDisableLcp, &(pDunSetting->bDisableLCP), 0},
        {c_pszCmEntryDunServerPwEncrypt, &(pDunSetting->bPWEncrypt), 0},
        {c_pszCmEntryDunServerPwEncryptMs, &(pDunSetting->bPWEncrypt_MS), 0},
        {c_pszCmEntryDunServerSecureLocalFiles, &(pDunSetting->bSecureLocalFiles), 0},
        {c_pszCmEntryDunServerRequirePap, &(pDunSetting->bAllowPap), 0},
        {c_pszCmEntryDunServerRequireSpap, &(pDunSetting->bAllowSpap), 0},
        {c_pszCmEntryDunServerRequireEap, &(pDunSetting->bAllowEap), 0},
        {c_pszCmEntryDunServerRequireChap, &(pDunSetting->bAllowChap), 0},
        {c_pszCmEntryDunServerRequireMsChap, &(pDunSetting->bAllowMsChap), 0},
        {c_pszCmEntryDunServerRequireMsChap2, &(pDunSetting->bAllowMsChap2), 0},
        {c_pszCmEntryDunServerRequireW95MsChap, &(pDunSetting->bAllowW95MsChap), 0},
        {c_pszCmEntryDunServerDataEncrypt, &(pDunSetting->bDataEncrypt), 0},
    };

    const int c_iNumDunServerBools = sizeof(ArrayOfServerSettings)/sizeof(ArrayOfServerSettings[0]);

    for (int i = 0; i < c_iNumDunServerBools; i++)
    {
        *(ArrayOfServerSettings[i].pbValue) = GetPrivateProfileInt(pszSectionName, ArrayOfServerSettings[i].pszKeyName, 
                                                                   ArrayOfServerSettings[i].bDefault, pszCmsFile);
    }

    //
    //  Now get the EAP settings if necessary
    //

    pDunSetting->dwCustomAuthKey = GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunServerCustomAuthKey, 0, pszCmsFile);

    if (pDunSetting->dwCustomAuthKey)
    {
        if (!ReadDunSettingsEapData(pszSectionName, &(pDunSetting->pCustomAuthData), &(pDunSetting->dwCustomAuthDataSize), pDunSetting->dwCustomAuthKey, pszCmsFile))
        {
            CMASSERTMSG(FALSE, TEXT("ReadDunServerSettings -- Failed to read in EAP Data."));
            pDunSetting->dwCustomAuthDataSize = 0;
            CmFree(pDunSetting->pCustomAuthData);
            pDunSetting->pCustomAuthData = NULL;
        }
    }

    //
    //  Now get the Encryption type
    //
    pDunSetting->dwEncryptionType = (DWORD)GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunServerEncryptionType, 
                                                                (bTunnelDunSetting ? ET_Require : ET_Optional), pszCmsFile);

    //
    //  Figure out what type of security model we are using
    //
    if (GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunServerEnforceCustomSecurity, 0, pszCmsFile))
    {
        pDunSetting->iHowToHandleSecuritySettings = FORCE_WIN2K_AND_ABOVE;
    }
    else
    {
        int iWin2kSecSettings = pDunSetting->bAllowPap | pDunSetting->bAllowSpap | pDunSetting->bAllowEap | 
                                pDunSetting->bAllowChap | pDunSetting->bAllowMsChap | pDunSetting->bAllowMsChap2 | 
                                pDunSetting->bAllowW95MsChap;

        if (iWin2kSecSettings)
        {
            pDunSetting->iHowToHandleSecuritySettings = SEPARATE_FOR_LEGACY_AND_WIN2K;
        }
        else
        {
            pDunSetting->iHowToHandleSecuritySettings = SAME_ON_ALL_PLATFORMS;

            //
            //  In case the user chooses the advanced tab without configuring settings, lets
            //  set some reasonable defaults for them.  If they have already configured their
            //  Win2k settings we don't want to mess with them.  Also note that if the user
            //  doesn't change the iHowToHandleSecuritySettings value, we won't write out
            //  the advanced security settings anyway.
            //
            pDunSetting->bAllowChap = !bTunnelDunSetting;
            pDunSetting->bAllowMsChap = 1;
            pDunSetting->bAllowMsChap2 = 1;
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  ReadDunNetworkingSettings
//
// Synopsis:  Reads in all of the settings from the DUN Networking section
//            specified.
//
// Arguments: LPCTSTR pszSectionName - full name of the networking section to read
//                                     (Networking&Fred or whatever)
//            CDunSetting* pDunSetting - Dun Settings data structure to store 
//                                       the read in values to
//            LPCTSTR pszCmsFile - Cms file to read the settings from
//            BOOL bTunnel - is this a tunnel DUN setting or not
//
// Returns:   BOOL - TRUE if the settings were read in correctly
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
BOOL ReadDunNetworkingSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszCmsFile, BOOL bTunnel)
{
    if ((NULL == pszSectionName) || (NULL == pDunSetting) || (NULL == pszCmsFile) ||
        (TEXT('\0') == pszSectionName[0]) || (TEXT('\0') == pszCmsFile[0]))
    {
        CMASSERTMSG(FALSE, TEXT("ReadDunNetworkingSettings -- invalid parameter"));
        return FALSE;
    }

    pDunSetting->dwVpnStrategy = (DWORD)GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunNetworkingVpnStrategy, 
                                                             (bTunnel ? VS_PptpFirst : 0), pszCmsFile);

    //
    //  If the profile had automatic, then set it to VS_PptpFirst instead.
    //

    if (bTunnel && ((VS_PptpOnly > pDunSetting->dwVpnStrategy) || (VS_L2tpFirst < pDunSetting->dwVpnStrategy)))
    {
        pDunSetting->dwVpnStrategy = VS_PptpFirst;
    }

    //
    //  Get the value for UseDownLevelL2TP
    //
    pDunSetting->bUseDownLevelL2TP = (BOOL)GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunNetworkingUseDownLevelL2TP, 
                                                                FALSE, pszCmsFile);


    pDunSetting->bUsePskOnWin2kPlus = (BOOL)GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunNetworkingUsePreSharedKey, 
                                                               FALSE, pszCmsFile);

    pDunSetting->bUsePskDownLevel = (BOOL)GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunNetworkingUsePskDownLevel, 
                                                               FALSE, pszCmsFile);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  ConvertIpStringToDword
//
// Synopsis:  This function takes the given string containing an IP address and
//            converts it to a packed DWORD.  The first octet of the IP address
//            going in the most significant byte of the DWORD, the next octet in
//            the second most significant byte of the DWORD, etc.  The packed
//            DWORD format is used by the IP address common controls and is a much
//            easier format to store the data in than a string.
//
// Arguments: LPTSTR pszIpAddress - string containing the ip address, each octet
//                                  seperated by a period.
//
// Returns:   DWORD - the ip address specified by the inputted string in
//                    packed byte format (first octet in the most significant)
//                    Note that zero is returned if there is a problem with the
//                    IP address format (one of the numbers is out of bounds or
//                    there are too many or too few octets).
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
DWORD ConvertIpStringToDword(LPTSTR pszIpAddress)
{
    DWORD dwIpAddress = 0;

    if (pszIpAddress && pszIpAddress[0])
    {
        CmStrTrim(pszIpAddress);

        LPTSTR pszCurrent = pszIpAddress;
        DWORD dwOctetCounter = 0;
        DWORD dwCurrentOctetValue = 0;
        const int c_iCharBase = TEXT('0');
        BOOL bExitLoop = FALSE;

        while (pszCurrent && !bExitLoop)
        {        
            switch(*pszCurrent)
            {

                case TEXT('.'):                

                    if (3 > dwOctetCounter)
                    {
                        dwIpAddress = (dwIpAddress << 8) + dwCurrentOctetValue;

                        dwOctetCounter++;
                        dwCurrentOctetValue = 0;
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("ConvertIpStringToDword -- Too many octets"));
                        return 0;                
                    }
                    break;

                case TEXT('\0'):

                        if (3 == dwOctetCounter)
                        {
                            dwIpAddress = (dwIpAddress << 8) + dwCurrentOctetValue;
                            bExitLoop = TRUE;
                        }
                        else
                        {
                            CMASSERTMSG(FALSE, TEXT("ConvertIpStringToDword -- Incorrect number of octets"));
                            return 0;
                        }
                    break;

                default:
                
                    dwCurrentOctetValue = dwCurrentOctetValue*10 + (int(*pszCurrent) - c_iCharBase);
                
                    if (255 < dwCurrentOctetValue)
                    {
                        CMASSERTMSG(FALSE, TEXT("ConvertIpStringToDword -- Octet value out of range"));
                        return 0;
                    }
                    break;
                }

            pszCurrent = CharNext(pszCurrent);
        }
    }

    return dwIpAddress;
}

//+----------------------------------------------------------------------------
//
// Function:  ConvertIpDwordToString
//
// Synopsis:  This function takes the given Packed DWORD and returns an IP
//            address string for it, making sure to print the octets so that
//            the most significant bits are printed in the string first.
//
// Arguments: DWORD dwIpAddress - packed DWORD containing the Ip address to convert
//            LPTSTR pszIpAddress - string to write the IP address too
//
// Returns:   int - the number of chars written to the string buffer.  Zero signifies
//                  failure.
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
int ConvertIpDwordToString(DWORD dwIpAddress, LPTSTR pszIpAddress)
{
    int iReturn = 0;

    if (pszIpAddress)
    {
        iReturn = wsprintf(pszIpAddress, TEXT("%d.%d.%d.%d"), FIRST_IPADDRESS(dwIpAddress), SECOND_IPADDRESS(dwIpAddress), 
                           THIRD_IPADDRESS(dwIpAddress), FOURTH_IPADDRESS(dwIpAddress));
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("ConvertIpDwordToString -- Null pointer passed for pszIpAddress"));
    }

    return iReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  ReadDunTcpIpSettings
//
// Synopsis:  This function reads the TCP/IP DUN settings from the specified
//            section and stores them in the given pDunSetting structure.
//
// Arguments: LPCTSTR pszSectionName - complete section name to read the TCP/IP
//                                     settings from, ie. Networking&Fred
//            CDunSetting* pDunSetting - pointer to a DUN setting structure to hold
//                                       the read in data
//            LPCTSTR pszCmsFile - cms file to read the settings from
//
// Returns:   BOOL - TRUE on success
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
BOOL ReadDunTcpIpSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszCmsFile)
{
    if ((NULL == pszSectionName) || (NULL == pDunSetting) || (NULL == pszCmsFile) ||
        (TEXT('\0') == pszSectionName[0]) || (TEXT('\0') == pszCmsFile[0]))
    {
        CMASSERTMSG(FALSE, TEXT("ReadDunTcpIpSettings -- invalid parameter"));
        return FALSE;
    }

    TCHAR szTemp[MAX_PATH];

    //
    //  Are we using Admin specified DNS and WINS settings or is the server going to assign them
    //
    if (GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunTcpIpSpecifyServerAddress, 0, pszCmsFile))
    {
        //
        //  Get the DNS and WINS configurations that were specified
        //
        GetPrivateProfileString(pszSectionName, c_pszCmEntryDunTcpIpDnsAddress, TEXT(""), szTemp, CELEMS(szTemp), pszCmsFile);
        pDunSetting->dwPrimaryDns = ConvertIpStringToDword (szTemp);
        
        GetPrivateProfileString(pszSectionName, c_pszCmEntryDunTcpIpDnsAltAddress, TEXT(""), szTemp, CELEMS(szTemp), pszCmsFile);
        pDunSetting->dwSecondaryDns = ConvertIpStringToDword (szTemp);
        
        GetPrivateProfileString(pszSectionName, c_pszCmEntryDunTcpIpWinsAddress, TEXT(""), szTemp, CELEMS(szTemp), pszCmsFile);
        pDunSetting->dwPrimaryWins = ConvertIpStringToDword (szTemp);

        GetPrivateProfileString(pszSectionName, c_pszCmEntryDunTcpIpWinsAltAddress, TEXT(""), szTemp, CELEMS(szTemp), pszCmsFile);
        pDunSetting->dwSecondaryWins = ConvertIpStringToDword (szTemp);

    }
    else
    {
        pDunSetting->dwPrimaryDns = 0;        
        pDunSetting->dwSecondaryDns = 0;        
        pDunSetting->dwPrimaryWins = 0;
        pDunSetting->dwSecondaryWins = 0;
    }

    //
    //  Now Read in IP Header Compress and whether to use the Remote Gateway or not
    //
    pDunSetting->bIpHeaderCompression = GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunTcpIpIpHeaderCompress, 1, pszCmsFile);
    pDunSetting->bGatewayOnRemote = GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunTcpIpGatewayOnRemote, 1, pszCmsFile);

    return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  ReadDunScriptingSettings
//
// Synopsis:  This function reads in the script name from the passed in scripting
//            section name and stores it in the passed in DUN setting struct.
//
// Arguments: LPCTSTR pszSectionName - complete section name to read the scripting
//                                     settings from, ie. Scripting&Fred
//            CDunSetting* pDunSetting - pointer to a DUN setting structure to hold
//                                       the read in data
//            LPCTSTR pszCmsFile - cms file to read the settings from
//
// Returns:   BOOL - TRUE on success
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
BOOL ReadDunScriptingSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszOsDir, LPCTSTR pszCmsFile)
{
    if ((NULL == pszSectionName) || (NULL == pDunSetting) || (NULL == pszCmsFile) || (NULL == pszOsDir) ||
        (TEXT('\0') == pszSectionName[0]) || (TEXT('\0') == pszCmsFile[0]) || (TEXT('\0') == pszOsDir[0]))
    {
        CMASSERTMSG(FALSE, TEXT("ReadDunScriptingSettings -- invalid parameter"));
        return FALSE;
    }

    TCHAR szTemp[MAX_PATH+1] = TEXT("");

    if (GetPrivateProfileString(pszSectionName, c_pszCmEntryDunScriptingName, TEXT(""), 
         szTemp, CELEMS(szTemp), pszCmsFile))
    {
        MYVERIFY(CELEMS(pDunSetting->szScript) > (UINT)wsprintf(pDunSetting->szScript, TEXT("%s%s"), pszOsDir, szTemp));
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  AddDunNameToListIfDoesNotExist
//
// Synopsis:  This function walks through the list of existing DUN settings
//            to see if it can find a setting with the name pszDunName.  If it
//            finds the entry, then fine it returns TRUE.  If it cannot find the
//            entry then it creates an otherwise blank entry and adds it to the list.
//
// Arguments: LPCTSTR pszDunName - name of the item to add to the list if 
//                                 it doesn't already exist
//            ListBxList **pHeadDns - head of the list of DUN entries
//            ListBxList** pTailDns - tail of the list of DUN entries
//            BOOL bTunnelDunName - whether this is a tunnel DUN name or not
//
// Returns:   BOOL - TRUE if the item was added or if it already existed in the list
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
BOOL AddDunNameToListIfDoesNotExist(LPCTSTR pszDunName, ListBxList **pHeadDns, ListBxList** pTailDns, BOOL bTunnelDunName)
{
    if ((NULL == pszDunName) || (NULL == pHeadDns) || (NULL == pTailDns) || (TEXT('\0') == pszDunName[0]))
    {
        CMASSERTMSG(FALSE, TEXT("AddDunNameToListIfDoesNotExist -- Invalid Parameter"));
        return FALSE;
    }

    ListBxList* pCurrent = *pHeadDns;
    BOOL bReturn = TRUE;

    while (pCurrent)
    {    
        if (0 == lstrcmpi(pszDunName, pCurrent->szName))
        {
            //
            //  We already have this item, nothing to do
            //
            goto exit;
        }

        pCurrent = pCurrent->next;
    }

    //
    //  If we are here then either we didn't find the item or the list
    //  is empty.  Either way, add the item.
    //
    pCurrent = (ListBxList*)CmMalloc(sizeof(ListBxList));

    if (pCurrent)
    {
        pCurrent->ListBxData = new CDunSetting(bTunnelDunName);

        if (NULL == pCurrent->ListBxData)
        {
            CmFree(pCurrent);
            CMASSERTMSG(FALSE, TEXT("AddDunNameToListIfDoesNotExist -- Failed to allocate a new CDunSetting"));
            return FALSE;
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("ReadDunServerSettings -- Failed to allocate a new ListBxList struct"));
        return FALSE;
    }

    //
    //  Now that we have allocated a pCurrent, we need to add it to the list
    //
    if (NULL == *pHeadDns)
    {
        *pHeadDns = pCurrent;
    }
    else
    {
        (*pTailDns)->next = pCurrent;
    }

    *pTailDns = pCurrent;

    //
    //  Finally copy the name over
    //
    lstrcpy(pCurrent->szName, pszDunName);

exit:
    return bReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  GetVpnEntryNamesFromFile
//
// Synopsis:  This function parses through the tunnel server address entries within
//            the given VPN file.  For each entry that contains a VPN setting,
//            if calls AddDunNameToListIfDoesNotExist.
//
// Arguments: LPCTSTR pszPhoneBook - VPN file to search for VPN entry names
//            ListBxList **pHeadDns - head of the VPN entry list
//            ListBxList** pTailDns - tail of the VPN entry list
//
// Returns:   BOOL - TRUE if the phonebook was successfully parsed.
//
// History:   quintinb Created     10/28/00
//
//+----------------------------------------------------------------------------
BOOL GetVpnEntryNamesFromFile(LPCTSTR pszVpnFile, ListBxList **pHeadDns, ListBxList** pTailDns)
{
    if ((NULL == pszVpnFile) || (NULL == pHeadDns) || (NULL == pTailDns))
    {
        CMASSERTMSG(FALSE, TEXT("GetVpnEntryNamesFromFile -- invalid params passed."));
        return FALSE;
    }

    //
    //  Note that the vpn file string passed in may be empty.  That is okay because the profile
    //  may be a tunneling profile using only one tunnel address.
    //
    if ((TEXT('\0') != pszVpnFile[0]))
    {
        LPTSTR pszVpnServersSection = GetPrivateProfileSectionWithAlloc(c_pszCmSectionVpnServers, pszVpnFile);

        if (pszVpnServersSection)
        {
            LPTSTR pszCurrentLine = pszVpnServersSection;
            LPTSTR pszVpnSetting = NULL;

            while (TEXT('\0') != (*pszCurrentLine))
            {
                //
                //  First look for the equal sign
                //
                pszVpnSetting = CmStrchr(pszCurrentLine, TEXT('='));

                if (pszVpnSetting)
                {
                    //
                    //  Now look for the last comma
                    //
                    pszVpnSetting = CmStrrchr(pszVpnSetting, TEXT(','));
                    if (pszVpnSetting)
                    {
                        pszVpnSetting = CharNext(pszVpnSetting);
                        MYVERIFY(AddDunNameToListIfDoesNotExist(pszVpnSetting, pHeadDns, pTailDns, TRUE)); // TRUE == bTunnelDunName
                    }
                }

                //
                //  Find the next string by going to the end of the string
                //  and then going one more char.  Note that we cannot use
                //  CharNext here but must use just ++.
                //
                pszCurrentLine = CmEndOfStr(pszCurrentLine);
                pszCurrentLine++;
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("GetVpnEntryNamesFromFile -- GetPrivateProfileSectionWithAlloc return NULL."));
            return FALSE;
        }

        CmFree(pszVpnServersSection);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  VerifyVpnFile
//
// Synopsis:  This function examines the VPN servers section of a VPN file
//            to ensure that at least one line of a valid format is found.  While
//            this doesn't guarantee that the entry is valid (it could be a bogus
//            server name), it does at least mean the Admin didn't give the user a
//            junk file.  This is important because the user cannot enter their own
//            tunnel server destination.
//
// Arguments: LPCTSTR pszPhoneBook - VPN file to search for VPN entry names
//
// Returns:   BOOL - TRUE if the VPN file contains at least one tunnel server
//                   entry in a valid format
//
// History:   quintinb Created     10/28/00
//
//+----------------------------------------------------------------------------
BOOL VerifyVpnFile(LPCTSTR pszVpnFile)
{
    if (NULL == pszVpnFile)
    {
        CMASSERTMSG(FALSE, TEXT("VerifyVpnFile -- invalid params passed."));
        return FALSE;
    }

    BOOL bReturn = FALSE;

    //
    //  Note that the vpn file string passed in may be empty.  That is okay because the profile
    //  may be a tunneling profile using only one tunnel address.
    //
    if ((TEXT('\0') != pszVpnFile[0]))
    {
        LPTSTR pszVpnServersSection = GetPrivateProfileSectionWithAlloc(c_pszCmSectionVpnServers, pszVpnFile);

        if (pszVpnServersSection)
        {
            LPTSTR pszCurrentLine = pszVpnServersSection;
            LPTSTR pszEqualSign = NULL;

            while ((TEXT('\0') != (*pszCurrentLine)) && !bReturn)
            {
                //
                //  To be considered a "valid" line, all we need is to have
                //  an equal sign (=) surrounded by text.  Not that stringent of a test
                //  but better than nothing.
                //
                pszEqualSign = CmStrchr(pszCurrentLine, TEXT('='));

                if (pszEqualSign && (pszEqualSign != pszCurrentLine)) // line cannot start with an equal sign to count
                {
                    pszCurrentLine = CharNext(pszEqualSign);
                    CmStrTrim(pszCurrentLine);

                    if (*pszCurrentLine)
                    {
                        bReturn = TRUE;
                    }
                }

                //
                //  Find the next string by going to the end of the string
                //  and then going one more char.  Note that we cannot use
                //  CharNext here but must use just ++.
                //
                pszCurrentLine = CmEndOfStr(pszCurrentLine);
                pszCurrentLine++;
            }
            CmFree(pszVpnServersSection);
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetDunEntryNamesFromPbk
//
// Synopsis:  This function memory maps the given phonebook into memory and
//            then walks through it as one big string.  The function is searching
//            the phonebook for DUN entry names.  If it finds a DUN entry name then
//            it uses AddDunNameToListIfDoesNotExist to add the entry name if
//            it doesn't already exist.
//
// Arguments: LPCTSTR pszPhoneBook - phonebook to search for DUN entry names
//            ListBxList **pHeadDns - head of the DUN entry list
//            ListBxList** pTailDns - tail of the DUN entry list
//
// Returns:   BOOL - TRUE if the phonebook was successfully parsed.
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
BOOL GetDunEntryNamesFromPbk(LPCTSTR pszPhoneBook, ListBxList **pHeadDns, ListBxList** pTailDns)
{
    if ((NULL == pszPhoneBook) || (NULL == pHeadDns) || (NULL == pTailDns))
    {
        CMASSERTMSG(FALSE, TEXT("GetDunEntryNamesFromPbk -- Invalid Parameter"));
        return FALSE;
    }

    BOOL bReturn = TRUE;

    if ((TEXT('\0') != pszPhoneBook[0]))
    {
        HANDLE hPhoneBookFile = CreateFile(pszPhoneBook, GENERIC_READ, FILE_SHARE_READ, NULL, 
                                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

        if (INVALID_HANDLE_VALUE != hPhoneBookFile)
        {
            //
            //  Get the size of the file
            //
            DWORD dwFileSize = GetFileSize(hPhoneBookFile, NULL);
            if (-1 != dwFileSize)
            {
                //
                //  Create a file mapping
                //
                HANDLE hFileMapping = CreateFileMapping(hPhoneBookFile, NULL, PAGE_READONLY, 0, 0, NULL);

                if (NULL != hFileMapping)
                {
                    CHAR* pszPhoneBookContents = (CHAR*)MapViewOfFileEx(hFileMapping, FILE_MAP_READ, 0, 0, 0, NULL);

                    CHAR* pszCurrent = pszPhoneBookContents;
                    LPSTR pszLastComma = NULL;

                    //
                    //  We want to walk through the file character by character.  Whenever we encounter
                    //  a '\n', we know that is the end of a line.  If we hit EOF then we are done with the file.
                    //  We are looking for all of the DUN entry names in the phonebook file.
                    //

                    while (pszCurrent && ((dwFileSize + pszPhoneBookContents) > pszCurrent))
                    {
                        CHAR szTemp[MAX_PATH+1];
                        int iNumChars;

                        switch (*pszCurrent)
                        {
                        case ',':
                            pszLastComma = pszCurrent;
                            break;

                        case '\r':
                            //
                            //  End of a line, remember we have a \r\n <CRLF> to end a line in a file.
                            //
                            if (pszLastComma)
                            {
                                iNumChars = (int)(pszCurrent - pszLastComma);

                                if (iNumChars - 1)
                                {
                                    lstrcpynA(szTemp, CharNextA(pszLastComma), iNumChars);
                                    LPTSTR pszUnicodeDunName = SzToWzWithAlloc(szTemp);
                                    MYDBGASSERT(pszUnicodeDunName);

                                    if (pszUnicodeDunName)
                                    {
                                        MYVERIFY(AddDunNameToListIfDoesNotExist(pszUnicodeDunName, pHeadDns, pTailDns, FALSE)); // FALSE == bTunnelDunName
                                        CmFree(pszUnicodeDunName);
                                    }
                                }

                                //
                                //  Reset the last comma
                                //
                                pszLastComma = NULL;
                            }
                            break;

                        case '\0':
                        case EOF:

                            //
                            //  We shouldn't hit an EOF or a zero byte in a memory mapped text file.
                            //                            
                            
                            bReturn = FALSE;
                            CMASSERTMSG(FALSE, TEXT("GetDunEntryNamesFromPbk -- phonebook file format incorrect!"));

                            break;
                        }

                        //
                        //  Advance to the next line assuming we still have some of the file
                        //  to parse
                        //
                        if (pszCurrent && ((EOF == *pszCurrent) || ('\0' == *pszCurrent)))
                        {
                            //
                            //  Then we have an invalid file and it is time to exit...
                            //
                            pszCurrent = NULL;
                        }
                        else if (pszCurrent)
                        {
                            pszCurrent = CharNextA(pszCurrent);
                        }
                    }

                    MYVERIFY(UnmapViewOfFile(pszPhoneBookContents));
                    CloseHandle(hFileMapping);
                }
            }

            CloseHandle(hPhoneBookFile);
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  CDunSetting::CDunSetting
//
// Synopsis:  Constructor for the CDunSetting data structure.  Note that all
//            default values should be changed here and not imposed anywhere
//            else.  All the DUN setting UI is setup to read from a DUN setting
//            structure, either a newly constructed one (thus setting up the defaults)
//            or one read in from the cms.
//
// Arguments: BOOL bTunnel - tells whether this is a Tunnel DUN setting or not
//                           note that this value defaults to FALSE.
//
// Returns:   Nothing
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
CDunSetting::CDunSetting(BOOL bTunnel)
{
    //
    //  Note that bTunnelDunSetting has a default value of FALSE.
    //  Init the class params.
    //
    bNetworkLogon = bTunnel ? 1 : 0;
    bPppSoftwareCompression = 1;
    bDisableLCP = 0;
    bPWEncrypt = bTunnel ? 0 : 1; // if we are not tunneling, default to secure password
    bPWEncrypt_MS = bTunnel ? 1 : 0; // if we are tunneling, default to MS secure password

    szScript[0] = TEXT('\0');
    dwVpnStrategy = bTunnel ? VS_PptpFirst : 0;
    bTunnelDunSetting = bTunnel;
    bUseDownLevelL2TP = 0;

    //
    //  TCP/IP Settings
    //
    dwPrimaryDns = 0;
    dwSecondaryDns = 0;
    dwPrimaryWins = 0;
    dwSecondaryWins = 0;
    bIpHeaderCompression = 1;
    bGatewayOnRemote = 1;

    //
    //  Security Settings
    //
    dwEncryptionType = bTunnel ? ET_Require : ET_Optional;
    bDataEncrypt = bTunnel ? 1 : 0; // if we are tunneling, default to data encryption
    bAllowPap = 0;
    bAllowSpap = 0;
    bAllowEap = 0;
    bAllowChap = bTunnel ? 0 : 1;
    bAllowMsChap = 1;
    bAllowMsChap2 = 1;
    bAllowW95MsChap = 0;
    bSecureLocalFiles = 0;

    //
    // Due to RASEO_RequireMsEncryptPw & MSCAHPv2 bug in RAS API on Win2K & XP
    // we want a default profile to correctly work on Win2k and above. Thus
    // CMAK needs to default to lagacy and Win2k settings. That way the correct Win2K+ RASEO_ flags
    // are written out.
    //
    iHowToHandleSecuritySettings = SEPARATE_FOR_LEGACY_AND_WIN2K; 
    
    
    dwCustomAuthKey = 0;
    pCustomAuthData = NULL;
    dwCustomAuthDataSize = 0;

    bUsePskOnWin2kPlus = 0;
    bUsePskDownLevel = 0;

}

//+----------------------------------------------------------------------------
//
// Function:  CDunSetting::~CDunSetting
//
// Synopsis:  Destructor for the CDunSetting data structure.  Frees the EAP
//            blob if one exists
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
CDunSetting::~CDunSetting()
{
    CmFree(pCustomAuthData);
}

//+----------------------------------------------------------------------------
//
// Function:  ReadNetworkSettings
//
// Synopsis:  Constructor for the CDunSetting data structure.  Note that all
//            default values should be changed here and not imposed anywhere
//            else.  All the DUN setting UI is setup to read from a DUN setting
//            structure, either a newly constructed one (thus setting up the defaults)
//            or one read in from the cms.
//
// Arguments: LPCTSTR pszCmsFile - Cms file to read the network settings from
//            LPCTSTR pszLongServiceName - Long service name of the profile
//            LPCTSTR pszPhoneBook - phonebook of the current service profile,
//                                   if the profile doesn't have a phonebook
//                                   then "" should be passed
//            ListBxList **pHeadDns - pointer to the head of the DUN settings list
//            ListBxList** pTailDns - pointer to the tail of the DUN settings list
//            LPCTSTR pszOsDir - full path of the profiles directory
//
// Returns:   BOOL - TRUE if successful
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
BOOL ReadNetworkSettings(LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName, LPCTSTR pszPhoneBook, 
                         ListBxList **pHeadDns, ListBxList** pTailDns, LPCTSTR pszOsDir, BOOL bLookingForVpnEntries)
{
    //
    //  Check inputs, note that the phonebook could be ""
    //
    if ((NULL == pszCmsFile) || (NULL == pszLongServiceName) || (NULL == pszPhoneBook) || (NULL == pszOsDir) || (NULL == pHeadDns) ||
        (NULL == pTailDns) || (TEXT('\0') == pszCmsFile[0]) || (TEXT('\0') == pszLongServiceName[0]) || (TEXT('\0') == pszOsDir[0]) ||
        ((NULL == *pHeadDns) ^ (NULL == *pTailDns)))
    {
        CMASSERTMSG(FALSE, TEXT("ReadNetworkSettings -- invalid parameter"));
        return FALSE;
    }

    BOOL bReturn = TRUE;
    LPTSTR pszCurrentSectionName = NULL;
    TCHAR szDefaultDunName[MAX_PATH+1] = TEXT("");
    TCHAR szTunnelDunName[MAX_PATH+1] = TEXT("");

    //
    //  First we want to call GetPrivateProfileString with a NULL AppName and a NULL KeyName.  This will
    //  Return all of the Section Names in the file in a buffer.  We can then go through the buffer and
    //  get the section information that interests us.
    //
    LPTSTR pszSectionNames = GetPrivateProfileStringWithAlloc(NULL, NULL, TEXT(""), pszCmsFile);

    if ((NULL == pszSectionNames) || (TEXT('\0') == pszSectionNames[0]))
    {
        CMTRACE(TEXT("ReadNetworkSettings -- GetPrivateProfileStringWithAlloc failed"));
        bReturn = FALSE;
        goto exit;
    }


    //
    //  At this point we have a list of section names, they are all NULL terminated with the last one double
    //  NULL terminated.  We need to walk through the list and see if any of them start with "[TCP/IP&" if
    //  so then we have a DUN section and we want to read it in.
    //

    LPTSTR pszAmpersand;
    LPTSTR pszDunName;
    TCHAR szTemp[MAX_PATH+1];
    BOOL bTunnelDunSetting;
    pszCurrentSectionName = pszSectionNames;

    //
    //  Get the name of the Tunnel Dun setting
    //
    MYVERIFY(0 != GetTunnelDunSettingName(pszCmsFile, pszLongServiceName, szTunnelDunName, CELEMS(szTunnelDunName)));    

    //
    //  Get the name of the default Dun setting
    //
    MYVERIFY(0 != GetDefaultDunSettingName(pszCmsFile, pszLongServiceName, szDefaultDunName, CELEMS(szDefaultDunName)));    

    while (TEXT('\0') != (*pszCurrentSectionName))
    {
        pszAmpersand = CmStrchr(pszCurrentSectionName, TEXT('&'));

        if (pszAmpersand)
        {
            //
            //  Then we have a DUN or VPN section name.
            //
            pszDunName = CharNext(pszAmpersand);

            //
            //  Next we need to see if the entry that we have is of the type we
            //  are looking for ... a VPN entry if bLookingForVpnEntries is TRUE
            //  or a DUN entry if bLookingForVpnEntries is FALSE.  We can tell the
            //  DUN and VPN entries apart by the existence of a Networking&<name>
            //  section or because it is the VPN default entryname.
            //
            wsprintf(szTemp, TEXT("%s&%s"), c_pszCmSectionDunNetworking, pszDunName);
            
            BOOL bIsVpnEntry = GetPrivateProfileInt(szTemp, c_pszCmEntryDunNetworkingVpnEntry, 0, pszCmsFile);

            bTunnelDunSetting = (bIsVpnEntry || (0 == lstrcmpi(szTunnelDunName, pszDunName)));

            //
            //  If we have a VPN entry and are looking for VPN entries or we have a DUN entry and are looking for
            //  DUN entries, then go ahead and process it.
            //
            if ((bTunnelDunSetting && bLookingForVpnEntries) || (!bTunnelDunSetting && !bLookingForVpnEntries))
            {
                ListBxList * pCurrent = *pHeadDns;

                while (pCurrent)
                {
                    if(0 == lstrcmpi(pCurrent->szName, pszDunName))
                    {
                        //
                        //  Then we already have a DUN setting of this name
                        //
                        break;
                    }

                    pCurrent = pCurrent->next;
                }

                //
                //  We didn't find the item we were looking for, lets create one.
                //

                if (NULL == pCurrent)
                {
                    pCurrent = (ListBxList*)CmMalloc(sizeof(ListBxList));

                    if (pCurrent)
                    {
                        pCurrent->ListBxData = new CDunSetting(bTunnelDunSetting);

                        if (NULL == pCurrent->ListBxData)
                        {
                            CmFree(pCurrent);
                            CMASSERTMSG(FALSE, TEXT("ReadDunServerSettings -- Failed to allocate a new DunSettingData struct"));
                            bReturn = FALSE;
                            goto exit;
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("ReadDunServerSettings -- Failed to allocate a new ListBxList struct"));
                        bReturn = FALSE;
                        goto exit;
                    }

                    //
                    //  Now that we have allocated a pCurrent, we need to add it to the list
                    //
                    if (NULL == *pHeadDns)
                    {
                        *pHeadDns = pCurrent;
                    }
                    else
                    {
                        (*pTailDns)->next = pCurrent;
                    }

                    *pTailDns = pCurrent;

                    //
                    //  Finally copy the name over
                    //
                    lstrcpy(pCurrent->szName, pszDunName);
                    ((CDunSetting*)(pCurrent->ListBxData))->bTunnelDunSetting = bTunnelDunSetting;
                }

                //
                //  Now lets figure out which section type we have
                //
                DWORD dwSize = (DWORD)(pszAmpersand - pszCurrentSectionName + 1);
                lstrcpyn(szTemp, pszCurrentSectionName, dwSize);

                if (0 == lstrcmpi(szTemp, c_pszCmSectionDunServer))
                {
                    ReadDunServerSettings(pszCurrentSectionName, (CDunSetting*)pCurrent->ListBxData, pszCmsFile, bTunnelDunSetting);
                }
                else if (0 == lstrcmpi(szTemp, c_pszCmSectionDunNetworking))
                {
                    ReadDunNetworkingSettings(pszCurrentSectionName, (CDunSetting*)pCurrent->ListBxData, pszCmsFile, bTunnelDunSetting);
                }
                else if (0 == lstrcmpi(szTemp, c_pszCmSectionDunTcpIp))
                {
                    ReadDunTcpIpSettings(pszCurrentSectionName, (CDunSetting*)pCurrent->ListBxData, pszCmsFile);
                }
                else if (0 == lstrcmpi(szTemp, c_pszCmSectionDunScripting))
                {
                    ReadDunScriptingSettings(pszCurrentSectionName, (CDunSetting*)pCurrent->ListBxData, pszOsDir, pszCmsFile);
                }
            }
        }
        //
        //  Find the next string by going to the end of the string
        //  and then going one more char.  Note that we cannot use
        //  CharNext here but must use just ++.
        //
        pszCurrentSectionName = CmEndOfStr(pszCurrentSectionName);
        pszCurrentSectionName++;
    }

    //
    //  Now we have processed all of the settings that the user has, how about
    //  the settings that they could have.  Lets add the default setting, the
    //  default Tunnel setting, and all of the settings from the
    //  current phonebook if there is one.  Note that everyone has a tunnel setting,
    //  but we won't show it in the listbox if the user isn't tunneling.
    //

    if (bLookingForVpnEntries)
    {
        MYVERIFY(GetVpnEntryNamesFromFile(pszPhoneBook, pHeadDns, pTailDns));
        MYVERIFY(AddDunNameToListIfDoesNotExist(szTunnelDunName, pHeadDns, pTailDns, TRUE)); // TRUE == bTunnelDunName    
    }
    else
    {
        MYVERIFY(GetDunEntryNamesFromPbk(pszPhoneBook, pHeadDns, pTailDns));
        MYVERIFY(AddDunNameToListIfDoesNotExist(szDefaultDunName, pHeadDns, pTailDns, FALSE)); // FALSE == bTunnelDunName        
    }

exit:
    CmFree(pszSectionNames);

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteOutNetworkingEntry
//
// Synopsis:  This function writes out the given networking entry to the
//            appropriate DUN sections in the given cms file.
//
// Arguments: LPCTSTR pszDunName - name of the DUN setting
//            CDunSetting* pDunSetting - settings data to output
//            LPCTSTR pszShortServiceName - short service name of the profile
//            LPCTSTR pszCmsFile - Cms file to write the settings too
//
// Returns:   Nothing
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
void WriteOutNetworkingEntry(LPCTSTR pszDunName, CDunSetting* pDunSetting, LPCTSTR pszShortServiceName, LPCTSTR pszCmsFile)
{
    if ((NULL == pszDunName) || (NULL == pDunSetting) || (NULL == pszCmsFile) || (NULL == pszShortServiceName) ||
        (TEXT('\0') == pszCmsFile[0]) || (TEXT('\0') == pszDunName[0]) || (TEXT('\0') == pszShortServiceName[0]))
    {
        CMASSERTMSG(FALSE, TEXT("WriteOutNetworkingEntry -- Invalid input parameter"));
        return;
    }

    //
    //  Lets build our four section headers
    //
    TCHAR szServerSection[MAX_PATH+1];
    TCHAR szNetworkingSection[MAX_PATH+1];
    TCHAR szTcpIpSection[MAX_PATH+1];
    TCHAR szScriptingSection[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1] = {0};
    TCHAR szEncryptionType[2] = {0};
    TCHAR szVpnStrategy[2] = {0};
    TCHAR szCustomAuthKey[32] = {0};

    MYVERIFY(CELEMS(szServerSection) > (UINT)wsprintf(szServerSection, TEXT("%s&%s"), c_pszCmSectionDunServer, pszDunName));
    MYVERIFY(CELEMS(szNetworkingSection) > (UINT)wsprintf(szNetworkingSection, TEXT("%s&%s"), c_pszCmSectionDunNetworking, pszDunName));
    MYVERIFY(CELEMS(szTcpIpSection) > (UINT)wsprintf(szTcpIpSection, TEXT("%s&%s"), c_pszCmSectionDunTcpIp, pszDunName));
    MYVERIFY(CELEMS(szScriptingSection) > (UINT)wsprintf(szScriptingSection, TEXT("%s&%s"), c_pszCmSectionDunScripting, pszDunName));

    //
    //  Now setup a list of all of the Booleans we need to set.
    //

    SetBoolSettings SetBoolSettingsStruct[] = {
        {szServerSection, c_pszCmEntryDunServerNetworkLogon, pDunSetting->bNetworkLogon},
        {szServerSection, c_pszCmEntryDunServerSwCompress, pDunSetting->bPppSoftwareCompression},
        {szServerSection, c_pszCmEntryDunServerDisableLcp, pDunSetting->bDisableLCP},
        {szServerSection, c_pszCmEntryDunServerNegotiateTcpIp, 1}, // always negotiate TCP/IP
        {szServerSection, c_pszCmEntryDunServerSecureLocalFiles, pDunSetting->bSecureLocalFiles},
        {szTcpIpSection, c_pszCmEntryDunTcpIpIpHeaderCompress, pDunSetting->bIpHeaderCompression},
        {szTcpIpSection, c_pszCmEntryDunTcpIpGatewayOnRemote, pDunSetting->bGatewayOnRemote}
    };

    const int c_iNumBools = sizeof(SetBoolSettingsStruct)/sizeof(SetBoolSettingsStruct[0]);

    //
    //  Write out the boolean values
    //

    for (int i = 0; i < c_iNumBools; i++)
    {
        MYVERIFY(0 != WritePrivateProfileString(SetBoolSettingsStruct[i].pszSectionName, 
                                                SetBoolSettingsStruct[i].pszKeyName,
                                                ((SetBoolSettingsStruct[i].bValue) ? c_pszOne : c_pszZero),
                                                pszCmsFile));
    }

    //
    //  Write out the security settings.  If the user choose to use the same settings everywhere, then we
    //  only want to write out the legacy security flags.  If the user choose to have separate settings
    //  then we need to write out both sets of settings.  Or if the user choose to force win2k and above,
    //  we want to write out only the newer settings and set the EnforceCustomSecurity flag to TRUE
    //
    LPTSTR pszCustomSecurity = NULL;
    LPTSTR pszEnforceCustomSecurity = NULL;
    LPTSTR pszAllowPap = NULL;
    LPTSTR pszAllowSpap = NULL;
    LPTSTR pszAllowChap = NULL;
    LPTSTR pszAllowMsChap = NULL;
    LPTSTR pszAllowW95MsChap = NULL;
    LPTSTR pszAllowMsChap2 = NULL;
    LPTSTR pszAllowEAP = NULL;
    LPTSTR pszEncryptionType = NULL;
    LPTSTR pszVpnStrategy = NULL;
    LPTSTR pszUseDownLevelL2TP = NULL;
    LPTSTR pszCustomAuthKey = NULL;
    LPTSTR pszUsePresharedKey = NULL;
    LPTSTR pszUsePskDownLevel = NULL;

    LPTSTR pszPwEncrypt = NULL;
    LPTSTR pszPwEncryptMs = NULL;
    LPTSTR pszDataEncrypt = NULL;

    //
    //  Set the legacy security settings if we aren't forcing Win2k+
    //
    if ((SAME_ON_ALL_PLATFORMS == pDunSetting->iHowToHandleSecuritySettings) || 
        (SEPARATE_FOR_LEGACY_AND_WIN2K == pDunSetting->iHowToHandleSecuritySettings))
    {
        pszPwEncrypt = (LPTSTR)(pDunSetting->bPWEncrypt ? c_pszOne : c_pszZero);
        pszPwEncryptMs = (LPTSTR)(pDunSetting->bPWEncrypt_MS ? c_pszOne : c_pszZero);
        pszDataEncrypt = (LPTSTR)((pDunSetting->bPWEncrypt_MS & pDunSetting->bDataEncrypt) ? c_pszOne : c_pszZero);
    }

    //
    //  Set the Win2k specific settings if we aren't using the same settings everywhere
    //
    if ((FORCE_WIN2K_AND_ABOVE == pDunSetting->iHowToHandleSecuritySettings) ||
        (SEPARATE_FOR_LEGACY_AND_WIN2K == pDunSetting->iHowToHandleSecuritySettings))
    {
        if (FORCE_WIN2K_AND_ABOVE == pDunSetting->iHowToHandleSecuritySettings)
        {
            pszEnforceCustomSecurity = (LPTSTR)c_pszOne;
        }
        else
        {
            pszEnforceCustomSecurity = (LPTSTR)c_pszZero;        
        }

        pszCustomSecurity = (LPTSTR)c_pszOne;

        if (pDunSetting->bAllowEap)
        {
            pszAllowEAP = (LPTSTR)c_pszOne;

            wsprintf(szCustomAuthKey, TEXT("%d"), pDunSetting->dwCustomAuthKey);
            pszCustomAuthKey = szCustomAuthKey;
        }
        else
        {
            pszAllowPap = (LPTSTR)(pDunSetting->bAllowPap ? c_pszOne : c_pszZero);
            pszAllowSpap = (LPTSTR)(pDunSetting->bAllowSpap ? c_pszOne : c_pszZero);
            pszAllowChap = (LPTSTR)(pDunSetting->bAllowChap ? c_pszOne : c_pszZero);
            pszAllowMsChap = (LPTSTR)(pDunSetting->bAllowMsChap ? c_pszOne : c_pszZero);
            pszAllowMsChap2 = (LPTSTR)(pDunSetting->bAllowMsChap2 ? c_pszOne : c_pszZero);
            pszAllowW95MsChap = (LPTSTR)(pDunSetting->bAllowW95MsChap ? c_pszOne : c_pszZero);
        }

        wsprintf(szEncryptionType, TEXT("%d"), pDunSetting->dwEncryptionType);
        pszEncryptionType = szEncryptionType;
    }

    //
    //  Now write out the Win2k security settings
    //
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerEnforceCustomSecurity, pszEnforceCustomSecurity, pszCmsFile);    
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerCustomSecurity, pszCustomSecurity, pszCmsFile);

    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerRequireEap, pszAllowEAP, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerCustomAuthKey, pszCustomAuthKey, pszCmsFile);

    if (pszAllowEAP)
    {
        MYVERIFY(SUCCEEDED(WriteDunSettingsEapData(szServerSection, pDunSetting, pszCmsFile)));
    }
    else
    {
        MYVERIFY(SUCCEEDED(EraseDunSettingsEapData(szServerSection, pszCmsFile)));    
    }

    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerRequirePap, pszAllowPap, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerRequireSpap, pszAllowSpap, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerRequireChap, pszAllowChap, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerRequireMsChap, pszAllowMsChap, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerRequireMsChap2, pszAllowMsChap2, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerRequireW95MsChap, pszAllowW95MsChap, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerEncryptionType, pszEncryptionType, pszCmsFile);

    //
    //  Write out the Networking section if this is a VPN entry, otherwise blank the section.  Don't forget to 
    //  mark the entry as a VPN entry.
    //
    if (pDunSetting->bTunnelDunSetting)
    {
        //
        //  Okay, first let's figure out what the VPN settings need to be.
        //
        if (FORCE_WIN2K_AND_ABOVE == pDunSetting->iHowToHandleSecuritySettings)
        {
            pszUseDownLevelL2TP = NULL;
            pszUsePskDownLevel = NULL;

            wsprintf(szVpnStrategy, TEXT("%d"), pDunSetting->dwVpnStrategy);
            pszVpnStrategy = szVpnStrategy;

            pszUsePresharedKey = (LPTSTR)(pDunSetting->bUsePskOnWin2kPlus ? c_pszOne : NULL); // only write UsePreSharedKey if it is 1
        }
        else if (SEPARATE_FOR_LEGACY_AND_WIN2K == pDunSetting->iHowToHandleSecuritySettings)
        {
            wsprintf(szVpnStrategy, TEXT("%d"), pDunSetting->dwVpnStrategy);
            pszVpnStrategy = szVpnStrategy;

            //
            //  Only write out the PSK keys and the Downlevel L2TP key if they are 1
            //
            pszUseDownLevelL2TP = (LPTSTR)(pDunSetting->bUseDownLevelL2TP ? c_pszOne : NULL);
            pszUsePskDownLevel = (LPTSTR)(pDunSetting->bUsePskDownLevel ? c_pszOne : NULL);
            pszUsePresharedKey = (LPTSTR)(pDunSetting->bUsePskOnWin2kPlus ? c_pszOne : NULL);
        }
        else
        {   
            //
            // Using common settings for both Win2k+ and downlevel.  Note that we are
            // basing VpnStrategy and UsePreSharedKey (for XP) off of the downlevel values.
            //
            if (pDunSetting->bUsePskDownLevel)
            {
                pszUsePresharedKey = (LPTSTR)c_pszOne;
                pszUsePskDownLevel = (LPTSTR)c_pszOne;
            }
            else
            {
                pszUsePresharedKey = NULL;
                pszUsePskDownLevel = NULL;
            }

            if (pDunSetting->bUseDownLevelL2TP)
            {
                pszUseDownLevelL2TP = (LPTSTR)c_pszOne;
                wsprintf(szVpnStrategy, TEXT("%d"), VS_L2tpFirst);
                pszVpnStrategy = szVpnStrategy;
            }
            else
            {
                pszUseDownLevelL2TP = NULL;
                wsprintf(szVpnStrategy, TEXT("%d"), VS_PptpFirst);
                pszVpnStrategy = szVpnStrategy;
            }
        }

        //
        //  Okay, now write them out
        //
        WritePrivateProfileString(szNetworkingSection, c_pszCmEntryDunNetworkingVpnStrategy, pszVpnStrategy, pszCmsFile);
        WritePrivateProfileString(szNetworkingSection, c_pszCmEntryDunNetworkingUseDownLevelL2TP, pszUseDownLevelL2TP, pszCmsFile);
        WritePrivateProfileString(szNetworkingSection, c_pszCmEntryDunNetworkingUsePreSharedKey, pszUsePresharedKey, pszCmsFile);
        WritePrivateProfileString(szNetworkingSection, c_pszCmEntryDunNetworkingUsePskDownLevel, pszUsePskDownLevel, pszCmsFile);
        WritePrivateProfileString(szNetworkingSection, c_pszCmEntryDunNetworkingVpnEntry, c_pszOne, pszCmsFile);
    }
    else
    {
        WritePrivateProfileString(szNetworkingSection, NULL, NULL, pszCmsFile);    
    }

    //
    //  Write the legacy security settings
    //
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerPwEncrypt, pszPwEncrypt, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerPwEncryptMs, pszPwEncryptMs, pszCmsFile);        
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerDataEncrypt, pszDataEncrypt, pszCmsFile);

    //
    //  Now write out the script section if we have one
    //
    if (pDunSetting->szScript[0])
    {
        TCHAR szScriptFile[MAX_PATH+1];
        GetFileName(pDunSetting->szScript, szTemp);
        MYVERIFY(CELEMS(szScriptFile) > (UINT)wsprintf(szScriptFile, TEXT("%s\\%s"), pszShortServiceName, szTemp));

        MYVERIFY(0 != WritePrivateProfileString(szScriptingSection, c_pszCmEntryDunScriptingName, szScriptFile, pszCmsFile));
    }
    else
    {
        MYVERIFY(0 != WritePrivateProfileString(szScriptingSection, c_pszCmEntryDunScriptingName, NULL, pszCmsFile));
    }

    //
    //  Did the admin specify Wins and Dns addresses or is the server going to set them
    //
    if ((pDunSetting->dwPrimaryDns) || (pDunSetting->dwSecondaryDns) || (pDunSetting->dwPrimaryWins) || (pDunSetting->dwSecondaryWins))
    {
        MYVERIFY(ConvertIpDwordToString(pDunSetting->dwPrimaryDns, szTemp));
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpDnsAddress, szTemp, pszCmsFile));

        MYVERIFY(ConvertIpDwordToString(pDunSetting->dwSecondaryDns, szTemp));
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpDnsAltAddress, szTemp, pszCmsFile));

        MYVERIFY(ConvertIpDwordToString(pDunSetting->dwPrimaryWins, szTemp));
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpWinsAddress, szTemp, pszCmsFile));

        MYVERIFY(ConvertIpDwordToString(pDunSetting->dwSecondaryWins, szTemp));
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpWinsAltAddress, szTemp, pszCmsFile));

        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpSpecifyServerAddress, c_pszOne, pszCmsFile));
    }
    else
    {
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpSpecifyServerAddress, c_pszZero, pszCmsFile));

        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpDnsAddress, NULL, pszCmsFile));
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpDnsAltAddress, NULL, pszCmsFile));
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpWinsAddress, NULL, pszCmsFile));
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpWinsAltAddress, NULL, pszCmsFile));
    }
}

//+----------------------------------------------------------------------------
//
// Function:  EraseNetworkingSections
//
// Synopsis:  This function erases all the networking sections for the given
//            DUN name.  Thus if you give it a DUN name of Fred, it will 
//            erase Server&Fred, Networking&Fred, etc.
//
// Arguments: LPCTSTR pszDunName - base dun name to erase all of the settings for
//            LPCTSTR pszCmsFile - cms file to erase the setting from
//
// Returns:   Nothing
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
void EraseNetworkingSections(LPCTSTR pszDunName, LPCTSTR pszCmsFile)
{
    TCHAR szSection[MAX_PATH+1];
    const int c_iNumDunSubSections = 4;
    const TCHAR* const ArrayOfSubSections[c_iNumDunSubSections] = 
    {
        c_pszCmSectionDunServer, 
        c_pszCmSectionDunNetworking, 
        c_pszCmSectionDunTcpIp, 
        c_pszCmSectionDunScripting
    };

    if (pszDunName)
    {
        for (int i = 0; i < c_iNumDunSubSections; i++)
        {
            MYVERIFY(CELEMS(szSection) > (UINT)wsprintf(szSection, TEXT("%s&%s"), ArrayOfSubSections[i], pszDunName));
            MYVERIFY(0 != WritePrivateProfileString(szSection, NULL, NULL, pszCmsFile));        
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  WriteNetworkingEntries
//
// Synopsis:  This function walks through the list of networking entries and
//            either adds the networking entry to the given CMS file or
//            if the entry is a VPN entry and the user turned off VPN's then
//            it erases the VPN sections.
//
// Arguments: LPCTSTR pszCmsFile - Cms File to write the networking entries too
//            LPCTSTR pszLongServiceName - long service name of the profile
//            LPCTSTR pszShortServiceName - short service name of the profile
//            ListBxList *g_pHeadDns - pointer to the head of the Dun entries list
//
// Returns:   Nothing
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
void WriteNetworkingEntries(LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName, LPCTSTR pszShortServiceName, ListBxList *pHeadDns)
{
    MYDBGASSERT(pszCmsFile);
    MYDBGASSERT(pszShortServiceName);
    MYDBGASSERT(pszLongServiceName);

    if (pszCmsFile && pszShortServiceName && pszLongServiceName && pHeadDns)
    {

        ListBxList * pCurrent = pHeadDns;
        TCHAR szTemp[MAX_PATH];
        TCHAR szTunnelDunName[MAX_PATH] = TEXT("");

        //
        //  Get the name of the Tunnel Dun setting
        //
        MYVERIFY(0 != GetTunnelDunSettingName(pszCmsFile, pszLongServiceName, szTunnelDunName, CELEMS(szTunnelDunName)));

        while  (pCurrent)
        {
            //
            //  If we don't have any data for the entry (it was a placeholder that the user choose not to fill in) or
            //  if the entry is the tunneling entry and we aren't actually Tunneling then erase the entry instead of actually
            //  writing it out.
            //
            if (NULL == pCurrent->ListBxData)
            {
                EraseNetworkingSections(pCurrent->szName, pszCmsFile);
            }
            else
            {
                WriteOutNetworkingEntry(pCurrent->szName, (CDunSetting*)pCurrent->ListBxData, pszShortServiceName, pszCmsFile);
            }

            pCurrent = pCurrent->next;
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  EnableDisableDataEncryptCheckbox
//
// Synopsis:  This function enables or disables the data encrypt checkbox
//            depending on whether the user has selected to allow MsChap or not.
//            For data encryption to be negotiated, the authentication protocol
//            must be MsChap.
//
// Arguments: HWND hDlg - window handle to the dialog
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void EnableDisableDataEncryptCheckbox(HWND hDlg)
{
    BOOL bMsChapEnabled = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_MS_ENCRYPTED_AUTH));

    HWND hControl = GetDlgItem(hDlg, IDC_CHECK1);

    if (hControl)
    {
        EnableWindow (hControl, bMsChapEnabled);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  EnableDisableUsePskCheckbox
//
// Synopsis:  This function enables or disables the use a pre-shared key checkbox
//            depending on whether the user has selected to allow L2TP or not.
//
// Arguments: HWND hDlg - window handle to the dialog
//
// Returns:   Nothing
//
// History:   quintinb Created     09/12/01
//
//+----------------------------------------------------------------------------
void EnableDisableUsePskCheckbox(HWND hDlg)
{
    BOOL bL2TPEnabled = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_USE_L2TP));

    HWND hControl = GetDlgItem(hDlg, IDC_CHECK2);

    if (hControl)
    {
        EnableWindow (hControl, bL2TPEnabled);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessSecurityPopup
//
// Synopsis:  This function processes messages for the simple security dialog.
//            This dialog only contains authorization protocols and encryption
//            settings supported on all platforms.
//
// Arguments: HWND hDlg - window handle to the dialog
//            UINT message - the current message to process
//            WPARAM wParam - wParam see individual message type for details
//            LPARAM lParam - lParam see individual message type for details
//
// Returns:   INT_PTR - TRUE if the message was completely handled
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessSecurityPopup(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static DWORD_PTR HelpId = 0;
    static CDunSetting* pDunSetting = NULL;

    if (ProcessHelp(hDlg, message, wParam, lParam, HelpId)) return TRUE;
    
    switch (message)
    {
        case WM_INITDIALOG:
            if (lParam)
            {
                pDunSetting = (CDunSetting*)lParam;

                //
                //  Setup the help ID appropriately
                //
                HelpId = ((pDunSetting->bTunnelDunSetting) ? IDH_VENTRY : IDH_DENTRY);

                //
                //  Set the radio button to the correct choice
                //
                UINT uRadioButtonToSet;

                if (pDunSetting->bPWEncrypt_MS)
                {
                    uRadioButtonToSet = IDC_MS_ENCRYPTED_AUTH;

                    //
                    //  Set the Data Encryption checkbox, note that data encryption requires MSChap
                    //
                    MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK1, pDunSetting->bDataEncrypt));
                }
                else if (pDunSetting->bPWEncrypt)
                {
                    uRadioButtonToSet = IDC_ENCRYPTED_AUTH;                
                }
                else
                {
                    uRadioButtonToSet = IDC_ANY_AUTH;
                }

                MYVERIFY(0 != CheckRadioButton(hDlg, IDC_ANY_AUTH, IDC_MS_ENCRYPTED_AUTH, uRadioButtonToSet));

                if (pDunSetting->bTunnelDunSetting)
                {
                    //
                    //  Set the radio buttons for using PPTP or using L2TP depending on the setting...
                    //
                    if (pDunSetting->bUseDownLevelL2TP)
                    {
                        uRadioButtonToSet = IDC_USE_L2TP;
                        MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK2, pDunSetting->bUsePskDownLevel));
                    }
                    else
                    {
                        uRadioButtonToSet = IDC_USE_PPTP;
                    }

                    MYVERIFY(0 != CheckRadioButton(hDlg, IDC_USE_PPTP, IDC_USE_L2TP, uRadioButtonToSet));                    
                }
            }
            else
            {
                pDunSetting = NULL;
                CMASSERTMSG(FALSE, TEXT("ProcessSecurityPopup -- NULL lParam passed to InitDialog.  Dialog controls will all be set to off."));            
            }

            EnableDisableDataEncryptCheckbox(hDlg);
            EnableDisableUsePskCheckbox(hDlg);

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_MS_ENCRYPTED_AUTH:
                case IDC_ENCRYPTED_AUTH:
                case IDC_ANY_AUTH:
                    EnableDisableDataEncryptCheckbox(hDlg);
                    break;

                case IDC_USE_L2TP:
                case IDC_USE_PPTP:
                    EnableDisableUsePskCheckbox(hDlg);
                    break;

                case IDOK:
                    
                    MYDBGASSERT(pDunSetting);
                    
                    if (pDunSetting)
                    {
                        pDunSetting->bDataEncrypt = IsDlgButtonChecked(hDlg, IDC_CHECK1); // if mschap isn't enabled we will write out zero for DataEncrypt

                        pDunSetting->bPWEncrypt_MS = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_MS_ENCRYPTED_AUTH));
                        pDunSetting->bPWEncrypt = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ENCRYPTED_AUTH));

                        pDunSetting->bUseDownLevelL2TP = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_USE_L2TP));

                        // IDC_CHECK2 can be disabled but still checked, thus if it's not enabled we need to 
                        // explicitly set bUsePskDownLevel to FALSE
                        if (pDunSetting->bUseDownLevelL2TP)
                        {
                            pDunSetting->bUsePskDownLevel = IsDlgButtonChecked(hDlg, IDC_CHECK2); // if L2TP isn't enabled we will write out zero for UsePskDownLevel
                        }
                        else
                        {
                            pDunSetting->bUsePskDownLevel = FALSE;
                        }
                    }

                    EndDialog(hDlg, IDOK);

                    break;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;

                default:
                    break;
            }

            break;
    }
    return FALSE;   
}

//+----------------------------------------------------------------------------
//
// Function:  EnableDisableEapPropertiesButton
//
// Synopsis:  This function enables or disables the EAP properties button found
//            on the Win2k specific security settings dialog.  If the currently
//            selected EAP has configuration UI then the properties button should
//            be enabled.  The function determines this by getting the EAPData
//            structure pointer that is cached in the ItemData of the combobox.
//            Note that the Properties button should also be disabled when EAP
//            is disabled but that this function doesn't deal with that case.
//
// Arguments: HWND hDlg - window handle to the win2k security dialog
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void EnableDisableEapPropertiesButton(HWND hDlg)
{
    BOOL bEnablePropButton = FALSE;

    LRESULT lResult = SendDlgItemMessage(hDlg, IDC_EAP_TYPES, CB_GETCURSEL, 0, 0);

    if (CB_ERR != lResult)
    {
        lResult = SendDlgItemMessage(hDlg, IDC_EAP_TYPES, CB_GETITEMDATA, (WPARAM)lResult, 0);
        EAPData* pEAPData = (EAPData*)lResult;

        if (pEAPData)
        {
            bEnablePropButton = (pEAPData->pszConfigDllPath && pEAPData->pszConfigDllPath[0]);
        }
    }

    EnableWindow(GetDlgItem(hDlg, IDC_EAP_PROPERTIES), bEnablePropButton);
}

//+----------------------------------------------------------------------------
//
// Function:  EnableAppropriateSecurityControls
//
// Synopsis:  This function enables or disables all of the authorization
//            protocol controls on the win2k security dialog.  If EAP
//            is selected then only the EAP combobox and potentially the
//            EAP properties button should be enabled (depending on if the
//            currently selected EAP supports configuration UI or not).
//            If EAP is NOT selected then the EAP controls should be disabled
//            and the other authorization checkboxes (PAP, SPAP, CHAP, etc.)
//            should be enabled.
//
// Arguments: HWND hDlg - window handle to the win2k security dialog
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void EnableAppropriateSecurityControls(HWND hDlg)
{
    BOOL bUseEAP = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_USE_EAP));

    //
    //  If EAP is enabled then we need to disable all of the
    //  other security authorization protocols.
    //
    EnableWindow(GetDlgItem(hDlg, IDC_ALLOW_PAP), !bUseEAP);
    EnableWindow(GetDlgItem(hDlg, IDC_ALLOW_SPAP), !bUseEAP);
    EnableWindow(GetDlgItem(hDlg, IDC_ALLOW_CHAP), !bUseEAP);
    EnableWindow(GetDlgItem(hDlg, IDC_ALLOW_MSCHAP), !bUseEAP);
    EnableWindow(GetDlgItem(hDlg, IDC_ALLOW_MSCHAP2), !bUseEAP);

    //
    //  If EAP is disabled then we need to enable the enable combobox
    //  and the EAP properties button.
    //
    EnableWindow(GetDlgItem(hDlg, IDC_EAP_TYPES), bUseEAP);

    if (bUseEAP)
    {
        EnableDisableEapPropertiesButton(hDlg);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_EAP_PROPERTIES), FALSE);    
    }
}

#define MAX_BLOB_CHARS_PER_LINE 128

//
// From ras\ui\common\nouiutil\noui.c
//
BYTE HexValue(IN CHAR ch)

    /* Returns the value 0 to 15 of hexadecimal character 'ch'.
    */
{
    if (ch >= '0' && ch <= '9')
        return (BYTE )(ch - '0');
    else if (ch >= 'A' && ch <= 'F')
        return (BYTE )((ch - 'A') + 10);
    else if (ch >= 'a' && ch <= 'f')
        return (BYTE )((ch - 'a') + 10);
    else
        return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  ReadDunSettingsEapData
//
// Synopsis:  Retrieves DUN setting for EAP config (opaque blob) data. The 
//            entry may span several lines and contain several EAP data blocks.
//
// Arguments: CIni *pIni - Ptr to ini object to be used.
//            LPBYTE* ppbEapData - Address of pointer to store EapData, allocated here.
//            LPDWORD pdwEapSize - Ptr to a DWORD to record the size of the data blob.
//            DWORD dwCustomAuthKey - The EAP type that we are interested in.
//
// Returns:   TRUE on success
//
// Note:      CM expects blob data to be provided in numbered entries such as:
//                    CustomAuthData0=, CustomAuthData1=, CustomAuthData2=, etc.
//
// History:   nickball    Created                                       08/24/98
//            nickball    Handle multiple EAP data blocks in blob.      09/11/99
//            quintinb    modified not to use CIni                      03/27/00
//
//+----------------------------------------------------------------------------
BOOL ReadDunSettingsEapData(LPCTSTR pszSection, LPBYTE* ppbEapData, LPDWORD pdwEapSize, const DWORD dwCustomAuthKey, LPCTSTR pszCmsFile)
{
    CHAR *pchBuf = NULL;
    CHAR szTmp[MAX_BLOB_CHARS_PER_LINE + 2]; 
    CHAR szEntry[128];
    int nLine = -1;
    int nRead = -1; 
    int nTotal = 0;

    LPBYTE pbEapBytes = NULL;

    MYDBGASSERT(pszSection);
    MYDBGASSERT(pszSection[0]);
    MYDBGASSERT(ppbEapData);
    MYDBGASSERT(pdwEapSize);

    if ((NULL == pszSection) || (NULL == ppbEapData) || (NULL == pdwEapSize) || (TEXT('\0') == pszSection[0]))
    {
        return FALSE;
    }

    //
    // Convert the Section and the CMS File to ANSI strings
    //
    BOOL bRet = FALSE;
    LPSTR pszAnsiSection = WzToSzWithAlloc(pszSection);       
    LPSTR pszAnsiCmsFile = WzToSzWithAlloc(pszCmsFile);

    if (!pszAnsiSection || !pszAnsiCmsFile)
    {
        bRet = FALSE;
        goto exit;
    }

    // 
    // Read numbered entries until there are no more. 
    // Note: RAS blob doesn't exceed 64 chars, but can wrap over multiple lines
    //

    while (nRead)
    {
        //
        // Read CustomAuthDataX where X is the number of entries
        // 

        nLine++;
        wsprintfA(szEntry, "%s%d", c_pszCmEntryDunServerCustomAuthData, nLine);

        nRead = GetPrivateProfileStringA(pszAnsiSection, szEntry, "", szTmp, sizeof(szTmp), pszAnsiCmsFile);

        if (nRead)
        {               
            //
            // If line exceeded 128 chars, it is considered corrupt
            // 

            if (MAX_BLOB_CHARS_PER_LINE < nRead)
            {                               
                nTotal = 0;
                break;
            }

            //
            // Update our local master buffer with the latest fragment
            //

            if (nLine)
            {
                pchBuf = CmStrCatAllocA(&pchBuf, szTmp);
            }
            else
            {
                pchBuf = CmStrCpyAllocA(szTmp);
            }

            if (!pchBuf)
            {
                bRet = FALSE;
                goto exit;
            }

            nTotal += nRead;
        }
    }

    //
    // At this point we should have the entire entry in pchBuf in HEX format
    // Convert the buffer to byte format and store in supplied EAP buffer.
    //

    if (nTotal && !(nTotal & 1))
    {
        nTotal /= 2; // Only need half the hex char size

        pbEapBytes = (BYTE *) CmMalloc(nTotal + 1);

        if (!pbEapBytes)
        {
            goto exit;
        }

        CHAR *pch = pchBuf;
        BYTE *pb = pbEapBytes;

        while (*pch != '\0')
        {
            *pb = HexValue( *pch++ ) * 16;
            *pb += HexValue( *pch++ );
            ++pb;
        }

        //
        // Now we have the bytes, locate and extract the data block that we
        // are after. Note: Multiple blocks are arrayed using the following 
        // header:
        //
        //  typedef struct _EAP_CUSTOM_DATA
        //  {
        //      DWORD dwSignature;
        //      DWORD dwCustomAuthKey;
        //      DWORD dwSize;
        //      BYTE  abdata[1];
        //  } EAP_CUSTOM_DATA;
        //

        EAP_CUSTOM_DATA *pCustomData = (EAP_CUSTOM_DATA *) pbEapBytes;

        while (((LPBYTE) pCustomData - pbEapBytes) < nTotal)
        {
            if (pCustomData->dwCustomAuthKey == dwCustomAuthKey)
            {
                //
                // Bingo! We have a match, first make sure that the indicated 
                // size isn't pointing out into space, then make a copy and 
                // run for the hills.
                //

                if (((LPBYTE) pCustomData - pbEapBytes) + sizeof(EAP_CUSTOM_DATA) + pCustomData->dwSize > (DWORD) nTotal)
                {
                    MYDBGASSERT(FALSE);
                    goto exit;
                }

                *ppbEapData = (BYTE *) CmMalloc(pCustomData->dwSize);        

                if (*ppbEapData)
                {   
                    CopyMemory(*ppbEapData, pCustomData->abdata, pCustomData->dwSize);                    

                    *pdwEapSize = pCustomData->dwSize;                                                     
                    bRet = TRUE;
                    goto exit;                                
                }
            }       

            //
            // Locate the next data block
            //

            pCustomData = (EAP_CUSTOM_DATA *) ((LPBYTE) pCustomData + sizeof(EAP_CUSTOM_DATA) + pCustomData->dwSize); 
        }
    }
    else if (0 == nTotal)
    {
        //
        //  No CustomAuthData, that is perfectly exceptable.  MD5 challenge for instance doesn't require any
        //
        *ppbEapData = NULL;
        *pdwEapSize = 0;
        bRet = TRUE;
    }

exit:

    CmFree(pchBuf);
    CmFree(pszAnsiSection);
    CmFree(pszAnsiCmsFile);
    CmFree(pbEapBytes);

    return bRet;
}

//
// From ras\ui\common\nouiutil\noui.c
//
CHAR HexChar(IN BYTE byte)

    /* Returns an ASCII hexidecimal character corresponding to 0 to 15 value,
    ** 'byte'.
    */
{
    const CHAR* pszHexDigits = "0123456789ABCDEF";

    if (byte >= 0 && byte < 16)
        return pszHexDigits[ byte ];
    else
        return '0';
}


//+----------------------------------------------------------------------------
//
// Function:  WriteDunSettingsEapData
//
// Synopsis:  This function writes out the CustomAuthData key of the EAP settings
//            to the given section and CMS file.  Since CM expects the EAP data
//            to have the RAS EAP header on it (the header that RAS adds when it
//            puts the EAP data in the phonebook) and thus we need to add this
//            to the EAP blob before writing it to the CMS.
//
// Arguments: LPCTSTR pszSection - section name to write the CustomAuthData to
//            CDunSetting* pDunSetting - Dun settings data
//            LPCTSTR pszCmsFile - cms file to write the data to
//
// Returns:   HRESULT - standard COM style error codes
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
HRESULT WriteDunSettingsEapData(LPCTSTR pszSection, CDunSetting* pDunSetting, LPCTSTR pszCmsFile)
{
    if ((NULL == pszSection) || (NULL == pDunSetting) || (NULL == pszCmsFile) || 
        (TEXT('\0') == pszSection[0]) || (TEXT('\0') == pszCmsFile[0]))
    {
        return E_INVALIDARG;
    }

    //
    //  Make sure to erase any existing lines just in case the existing data is longer
    //  than our current data.  If we leave lines around that don't need to be there then
    //  the EAP data will be invalid.
    //
    HRESULT hr = EraseDunSettingsEapData(pszSection, pszCmsFile);

    //
    //  Check to see if we need to do anything.  Not all EAP's require custom data so
    //  let's not try to write it out unless we have some.
    //
    if (pDunSetting->dwCustomAuthDataSize && pDunSetting->pCustomAuthData)
    {
        //
        //  We need to add the EAP_CUSTOM_DATA header to the
        //  data returned from the EAP because this is the format
        //  that CM expects to find it in (the format it would be in
        //  if an Admin copied it by hand).
        //
        hr = S_OK;
        DWORD dwSize = pDunSetting->dwCustomAuthDataSize + sizeof(EAP_CUSTOM_DATA);

        EAP_CUSTOM_DATA* pEAPCustomData = (EAP_CUSTOM_DATA*)CmMalloc(dwSize);
        LPSTR pszAnsiSection = WzToSzWithAlloc(pszSection);
        LPSTR pszAnsiCmsFile = WzToSzWithAlloc(pszCmsFile);

        if (pEAPCustomData && pszAnsiSection && pszAnsiCmsFile)
        {
            pEAPCustomData->dwSignature = EAP_CUSTOM_KEY;
            pEAPCustomData->dwCustomAuthKey = pDunSetting->dwCustomAuthKey;
            pEAPCustomData->dwSize = pDunSetting->dwCustomAuthDataSize;
            CopyMemory(pEAPCustomData->abdata, pDunSetting->pCustomAuthData, pDunSetting->dwCustomAuthDataSize);

            CHAR szOutput[MAX_BLOB_CHARS_PER_LINE+1];
            CHAR szAnsiKeyName[MAX_BLOB_CHARS_PER_LINE];
            CHAR* pszOutput;
            LPBYTE pCurrentByte = (LPBYTE)pEAPCustomData;
            int iCount = 0;
            int iLineNum = 0;
            pszOutput = szOutput;

            while (pCurrentByte < ((LPBYTE)pEAPCustomData + dwSize))
            {
                *pszOutput++ = HexChar( (BYTE )(*pCurrentByte / 16) );
                *pszOutput++ = HexChar( (BYTE )(*pCurrentByte % 16) );
                pCurrentByte++;
                iCount = iCount + 2; // keep track of number of chars in ansi output buffer

                if ((MAX_BLOB_CHARS_PER_LINE == iCount) || (pCurrentByte == ((LPBYTE)pEAPCustomData + dwSize)))
                {
                    *pszOutput = '\0';
                    wsprintfA(szAnsiKeyName, "%s%d", c_pszCmEntryDunServerCustomAuthData, iLineNum);

                    MYVERIFY(0 != WritePrivateProfileStringA(pszAnsiSection, szAnsiKeyName, szOutput, pszAnsiCmsFile));
                
                    pszOutput = szOutput;
                    iCount = 0;
                    iLineNum++;
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        CmFree(pEAPCustomData);
        CmFree(pszAnsiCmsFile);
        CmFree(pszAnsiSection);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  GetEAPDataFromUser
//
// Synopsis:  This function is called when the user hits the properties button
//            for EAP configuration.  This function gets the EAP configuration
//            UI path from the EAPData structure cached in the Combobox Item data
//            and tries to call the configuration UI.  If the user configures the
//            EAP then the new EAP data and data size are set in the EAPData
//            struct for the combobox.  If the user cancels then nothing is changed.
//            Note that when the user hits OK on the win2k security dialog the EAP
//            data will be retrieved from the EAPData struct and set in the
//            actual DUN setting.
//
// Arguments: HWND hDlg - dialog window handle
//            UINT uCtrlId - control ID of the EAP combobox
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void GetEAPDataFromUser(HWND hDlg, UINT uCtrlId)
{
    MYDBGASSERT(hDlg && uCtrlId);

    if (hDlg && uCtrlId)
    {
        LRESULT lResult = SendDlgItemMessage(hDlg, uCtrlId, CB_GETCURSEL, 0, 0);

        MYDBGASSERT(CB_ERR != lResult);

        if (CB_ERR != lResult)
        {
            lResult = SendDlgItemMessage(hDlg, uCtrlId, CB_GETITEMDATA, (WPARAM)lResult, 0);
            EAPData* pEAPData = (EAPData*)lResult;

            if (pEAPData && pEAPData->pszConfigDllPath && pEAPData->pszConfigDllPath[0])
            {
                HINSTANCE hEapConfigDll = LoadLibrary(pEAPData->pszConfigDllPath);

                if (hEapConfigDll)
                {
                    typedef DWORD (WINAPI *RasEapInvokeConfigUIProc)(DWORD, HWND, DWORD, BYTE*, DWORD, BYTE**, DWORD*);
                    typedef DWORD (WINAPI *RasEapFreeMemoryProc)(BYTE*);
                    const char* const c_pszRasEapFreeMemory = "RasEapFreeMemory";
                    const char* const c_pszRasEapInvokeConfigUI = "RasEapInvokeConfigUI";

                    RasEapFreeMemoryProc pfnRasEapFreeMemory = (RasEapFreeMemoryProc)GetProcAddress(hEapConfigDll, c_pszRasEapFreeMemory);
                    RasEapInvokeConfigUIProc pfnRasEapInvokeConfigUI = (RasEapInvokeConfigUIProc)GetProcAddress(hEapConfigDll, c_pszRasEapInvokeConfigUI);

                    if (pfnRasEapFreeMemory && pfnRasEapInvokeConfigUI)
                    {
                        DWORD dwNewSize = 0;
                        BYTE* pNewData = NULL;

                        DWORD dwReturn = pfnRasEapInvokeConfigUI(pEAPData->dwCustomAuthKey, hDlg, 0, pEAPData->pCustomAuthData, 
                                                                 pEAPData->dwCustomAuthDataSize, &pNewData, &dwNewSize);

                        if (NO_ERROR == dwReturn)
                        {
                            CmFree(pEAPData->pCustomAuthData);

                            pEAPData->pCustomAuthData = (LPBYTE)CmMalloc(dwNewSize);

                            if (pEAPData->pCustomAuthData)
                            {
                                pEAPData->dwCustomAuthDataSize = dwNewSize;

                                CopyMemory(pEAPData->pCustomAuthData, pNewData, dwNewSize);
                            }
                            else
                            {
                                pEAPData->dwCustomAuthDataSize = 0;
                                pEAPData->pCustomAuthData = NULL;
                                CMASSERTMSG(FALSE, TEXT("GetEAPDataFromUser -- CmMalloc failed."));
                            }

                            MYVERIFY(NO_ERROR == pfnRasEapFreeMemory(pNewData));
                        }
                        else if (ERROR_CANCELLED != dwReturn)
                        {
                            CMTRACE3(TEXT("EAP %d (%s) failed with return code %d"), pEAPData->dwCustomAuthKey, pEAPData->pszConfigDllPath, dwReturn);
                            CMASSERTMSG(FALSE, TEXT("GetEAPDataFromUser -- pfnRasEapInvokeConfigUI from EAP dll failed."));
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("GetEAPDataFromUser -- GetProcAddressFailed on the EAP dll."));                    
                    }
                }
                else
                {
                    CMTRACE2(TEXT("Failed to load EAP %d (%s)"), pEAPData->dwCustomAuthKey, pEAPData->pszConfigDllPath);
                    CMASSERTMSG(FALSE, TEXT("GetEAPDataFromUser -- Unable to load the specified EAP Dll."));                    
                }
            }
        }    
    }
}

int MapEncryptionTypeToComboId(DWORD dwEncryptionType)
{
    int iReturn;

    switch(dwEncryptionType)
    {
        case ET_None:
            iReturn = 0;
            break;

        case ET_RequireMax:
        case ET_Require:
            iReturn = 1;
            break;

        case ET_Optional:
        default:
            iReturn = 2;
            break;
    }

    return iReturn;

}

DWORD MapComboIdToEncryptionType(INT_PTR iComboIndex)
{
    DWORD dwReturn;

    switch(iComboIndex)
    {
        case 0:
            dwReturn = ET_None;
            break;

        case 1:
            dwReturn = ET_Require; // note that we never set require max
            break;

        case 2:
        default:
            dwReturn = ET_Optional;
            break;
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  EnablePskCheckboxForL2TP
//
// Synopsis:  This function enables the PSK checkbox
//
// Arguments: HWND hDlg - window handle
//
// Returns:   Nothing
//
// History:   quintinb Created     09/12/01
//
//+----------------------------------------------------------------------------
void EnablePskCheckboxForL2TP(HWND hDlg)
{
    BOOL bEnable = FALSE;

    DWORD dwVpnStrategy = (DWORD)SendDlgItemMessage(hDlg, IDC_VPN_TYPE, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);

    if (CB_ERR != dwVpnStrategy)
    {
        dwVpnStrategy += 1; // adjust for not having automatic in the list.

        if ((VS_L2tpFirst == dwVpnStrategy) || (VS_L2tpOnly == dwVpnStrategy))
        {
            bEnable = TRUE;
        }
    }

    //
    //  Enable the psk checkbox if an L2TP protocol is selected but disable it if
    //  PPTP is the primary protocol (PPTP first or PPTP only).
    //
    EnableWindow(GetDlgItem(hDlg, IDC_USE_PSK), bEnable);
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessWin2kSecurityPopup
//
// Synopsis:  This function processes messages for the Win2k+ security dialog.
//            This dialog contains configuration UI for all of the advanced
//            settings allowed by Win2k (EAP, PAP, SPAP, etc plus encryption
//            type and vpn strategy).
//
// Arguments: HWND hDlg - window handle to the dialog
//            UINT message - the current message to process
//            WPARAM wParam - wParam see individual message type for details
//            LPARAM lParam - lParam see individual message type for details
//
// Returns:   INT_PTR - TRUE if the message was completely handled
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessWin2kSecurityPopup(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static DWORD_PTR HelpId = 0;
    static CDunSetting* pDunSetting = NULL;

    SetDefaultGUIFont(hDlg, message, IDC_ENCRYPTION_TYPE);
    SetDefaultGUIFont(hDlg, message, IDC_EAP_TYPES);
    SetDefaultGUIFont(hDlg, message, IDC_VPN_TYPE);

    if (ProcessHelp(hDlg, message, wParam, lParam, HelpId)) return TRUE;
    
    switch (message)
    {
        case WM_INITDIALOG:
            if (lParam)
            {
                pDunSetting = (CDunSetting*)lParam;

                //
                //  Setup the help ID appropriately
                //
                HelpId = ((pDunSetting->bTunnelDunSetting) ? IDH_VENTRY : IDH_DENTRY);

                //
                //  Load and add the strings to the Data Encryption combobox
                //
                LPTSTR pszString;
                for (int i = BASE_ENCRYPT_TYPE_ID; i < (BASE_ENCRYPT_TYPE_ID + NUM_ENCRYPT_TYPES); i++)
                {
                    pszString = CmLoadString(g_hInstance, i);
                    MYDBGASSERT(pszString);

                    if (pszString)
                    {
                        SendDlgItemMessage(hDlg, IDC_ENCRYPTION_TYPE, CB_ADDSTRING, 0, (LPARAM)pszString);
                        CmFree(pszString);
                    }
                }

                //
                //  Now pick the type of encryption the user has selected
                //
                MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, IDC_ENCRYPTION_TYPE, CB_SETCURSEL, (WPARAM)MapEncryptionTypeToComboId(pDunSetting->dwEncryptionType), (LPARAM)0));

                //
                //  Enumerate all of the available EAP's on the machine
                //
                MYVERIFY(SUCCEEDED(HrAddAvailableEAPsToCombo(hDlg, IDC_EAP_TYPES, pDunSetting)));

                //
                //  Select the appropriate EAP as necessary
                //
                SelectAppropriateEAP(hDlg, IDC_EAP_TYPES, pDunSetting);

                //
                //  Figure out what authentication protocols the user wants to allow.
                //  Note that if we are doing EAP then that is all we allow them to do
                //  and the other settings will be ignored.  Also note that we don't have
                //  UI for w95CHAP but we won't touch the setting if it exists.
                //
                MYVERIFY(0 != CheckDlgButton(hDlg, IDC_ALLOW_PAP, pDunSetting->bAllowPap));
                MYVERIFY(0 != CheckDlgButton(hDlg, IDC_ALLOW_SPAP, pDunSetting->bAllowSpap));
                MYVERIFY(0 != CheckDlgButton(hDlg, IDC_ALLOW_CHAP, pDunSetting->bAllowChap));
                MYVERIFY(0 != CheckDlgButton(hDlg, IDC_ALLOW_MSCHAP, pDunSetting->bAllowMsChap));
                MYVERIFY(0 != CheckDlgButton(hDlg, IDC_ALLOW_MSCHAP2, pDunSetting->bAllowMsChap2));

                if (pDunSetting->bAllowEap)
                {
                    MYVERIFY(0 != CheckRadioButton(hDlg, IDC_USE_EAP, IDC_ALLOWED_PROTOCOLS, IDC_USE_EAP));
                }
                else
                {
                    MYVERIFY(0 != CheckRadioButton(hDlg, IDC_USE_EAP, IDC_ALLOWED_PROTOCOLS, IDC_ALLOWED_PROTOCOLS));                
                }

                //
                //  Note that the VPN controls do not exist unless we have a Tunnel Dun Setting and are
                //  thus using the tunnel dun setting dialog.
                //
                if (pDunSetting->bTunnelDunSetting)
                {
                    //
                    //  Load and add the Vpn type string to the vpn type combobox
                    //
                    for (int i = BASE_VPN_TYPE_ID; i < (BASE_VPN_TYPE_ID + NUM_VPN_TYPES); i++)
                    {
                        pszString = CmLoadString(g_hInstance, i);
                        MYDBGASSERT(pszString);

                        if (pszString)
                        {
                            SendDlgItemMessage(hDlg, IDC_VPN_TYPE, CB_ADDSTRING, 0, (LPARAM)pszString);
                            CmFree(pszString);
                        }
                    }

                    //
                    //  Pick the type of vpn strategy the user has selected
                    //
                    MYDBGASSERT(pDunSetting->dwVpnStrategy != 0);
                    MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, IDC_VPN_TYPE, CB_SETCURSEL, (WPARAM)(pDunSetting->dwVpnStrategy - 1), (LPARAM)0));

                    //
                    //  Fill in the PSK checkbox as needed
                    //
                    MYVERIFY(0 != CheckDlgButton(hDlg, IDC_USE_PSK, pDunSetting->bUsePskOnWin2kPlus));
                }

                //
                //  We only want either the EAP controls or the non-EAP auth controls
                //  enabled at once.  Thus figure out which to enable/disable
                //
                EnableAppropriateSecurityControls(hDlg);
                EnablePskCheckboxForL2TP(hDlg);
            }
            else
            {
                pDunSetting = NULL;
                CMASSERTMSG(FALSE, TEXT("ProcessWin2kSecurityPopup -- NULL lParam passed to InitDialog.  Dialog controls will all be set to off."));            
            }

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_EAP_PROPERTIES:
                    GetEAPDataFromUser(hDlg, IDC_EAP_TYPES);
                    break;

                case IDOK:
                    MYDBGASSERT(pDunSetting);
                    
                    if (pDunSetting)
                    {
                        //
                        //  Since we are storing the settings directly in the data struct given to us, first 
                        //  verify that the authentication protocol and the encryption type match up properly.
                        //  Otherwise a user could modify settings, hit OK, we tell them the settings are
                        //  inappropriate and they hit cancel.  Any settings we modifed before we did the 
                        //  verification would then actually be modified.  To avoid that check to make sure
                        //  we have at least one security protocol checked before continuing.
                        //
                        BOOL bHasAuthProtocol = FALSE;

                        for (int i = BASE_AUTH_CONTROL_ID; i < (BASE_AUTH_CONTROL_ID + NUM_AUTH_TYPES); i++)
                        {
                            if (BST_CHECKED == IsDlgButtonChecked(hDlg, i))
                            {
                                bHasAuthProtocol = TRUE;
                                break;
                            }
                        }

                        if ((FALSE == bHasAuthProtocol) && (BST_UNCHECKED == IsDlgButtonChecked(hDlg, IDC_USE_EAP)))
                        {
                            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NEED_AUTH_PROTOCOL, MB_OK | MB_ICONSTOP));
                            return TRUE;
                        }

                        //
                        //  Next we need to decide whether the user is using EAP or not.  Retrieving the data
                        //  for the EAP they have picked from the combo (if any) will help us decide whether the
                        //  auth protocol they choose matches up with the encryption settings they asked for.
                        //
                        EAPData* pEAPData = NULL;

                        if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_USE_EAP))
                        {
                            //
                            //  Get the EAP Type and the data associated with it.
                            //
                            LRESULT lResult = SendDlgItemMessage(hDlg, IDC_EAP_TYPES, CB_GETCURSEL, 0, 0);

                            MYDBGASSERT(CB_ERR != lResult);

                            if (CB_ERR != lResult)
                            {
                                lResult = SendDlgItemMessage(hDlg, IDC_EAP_TYPES, CB_GETITEMDATA, (WPARAM)lResult, 0);
                                pEAPData = (EAPData*)lResult;

                                if (pEAPData && pEAPData->bMustConfig && (NULL == pEAPData->pCustomAuthData))
                                {
                                    LPTSTR pszMsg = CmFmtMsg(g_hInstance, IDS_EAP_NEEDS_CONFIG, pEAPData->pszFriendlyName);

                                    if (pszMsg)
                                    {
                                        MessageBox(hDlg, pszMsg, g_szAppTitle, MB_OK | MB_ICONSTOP);

                                        CmFree(pszMsg);
                                    }
                                    else
                                    {
                                        CMASSERTMSG(FALSE, TEXT("ProcessWin2kSecurityPopup -- CmMalloc failed!"));
                                    }

                                    HWND hButton = GetDlgItem(hDlg, IDC_EAP_PROPERTIES);

                                    if (hButton && IsWindowEnabled(hButton))
                                    {
                                        SetFocus(hButton);
                                    }
                                    
                                    return TRUE;       
                                }
                            }
                        }

                        //
                        //  Now get the encryption type that the user selected.  Note that in order to negotiate
                        //  encryption we must have EAP or some sort of MSCHAP.
                        //
                        LRESULT lResult = (DWORD)SendDlgItemMessage(hDlg, IDC_ENCRYPTION_TYPE, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);

                        DWORD dwTemp = MapComboIdToEncryptionType(lResult);

                        MYDBGASSERT(ET_RequireMax != dwTemp); // we should never be setting require max

                        if ((ET_Require == dwTemp) || (ET_Optional == dwTemp))
                        {
                            //
                            //  If the user is using EAP, then the EAP type they picked must support
                            //  encryption.  Otherwise, the user must not be using EAP and they must
                            //  be using some sort of MSChap.  The following could be expressed more
                            //  succintly, but there is no sense in confusing the issue.
                            //
                            BOOL bEncryptionAllowed = FALSE;

                            if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_USE_EAP))
                            {
                                if (pEAPData)
                                {
                                    bEncryptionAllowed = pEAPData->bSupportsEncryption;
                                }
                            }
                            else
                            {
                                bEncryptionAllowed = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_MSCHAP)) ||
                                                    (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_MSCHAP2));
                            }

                            //
                            // Warn the user if he selected one of these three authentication methods, 
                            // he needs to make a correction since he requires encryption, but we don't 
                            // want to show a warning when using 'L2TP Only'.
                            //
                            if ((BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOWED_PROTOCOLS)) && 
                                ((BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_PAP)) ||
                                (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_SPAP)) ||
                                (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_CHAP))))
                            {
                                DWORD dwVpnStrategyTemp =  (DWORD)SendDlgItemMessage(hDlg, IDC_VPN_TYPE, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
                                if (CB_ERR == dwVpnStrategyTemp)
                                {
                                    CMASSERTMSG(FALSE, TEXT("ProcessWin2kSecurityPopup -- CB_ERR returned for VPN strategy."));
                                    dwVpnStrategyTemp = VS_PptpFirst;
                                }
                                else
                                {
                                    //
                                    //  Adjust Vpn Strategy because we no longer offer Automatic as a choice
                                    //
                                    dwVpnStrategyTemp +=1;
                                }

                                if (VS_L2tpOnly != dwVpnStrategyTemp)
                                {
                                    if (IDNO == ShowMessage(hDlg, IDS_NEED_EAP_OR_MSCHAP, MB_YESNO | MB_ICONSTOP))
                                    {
                                        CheckDlgButton(hDlg, IDC_ALLOW_PAP, FALSE);
                                        CheckDlgButton(hDlg, IDC_ALLOW_SPAP, FALSE);
                                        CheckDlgButton(hDlg, IDC_ALLOW_CHAP, FALSE);
                                        return TRUE;
                                    }
                                }
                            }
                            else
                            {
                                if (FALSE == bEncryptionAllowed)
                                {
                                    MYVERIFY(IDOK == ShowMessage(hDlg, IDS_EAP_HAS_NO_ECRYPTION, MB_OK | MB_ICONSTOP));
                                    return TRUE;
                                }
                            }
                        }

                        //
                        //  Now save the actual settings
                        //
                        pDunSetting->dwEncryptionType = dwTemp;

                        if (pEAPData)
                        {
                            //
                            //  Now lets update pDunSetting with the actual data.  Note that we are past the
                            //  last place we could throw an error to the user and thus it is okay to touch
                            //  the pDunSetting data (even if the user got an error and then hit cancel we will
                            //  leave their previous data untouched). Note that we don't want to touch the existing
                            //  data if we don't have the EAP installed because we know that we couldn't have
                            //  actually changed the data.
                            //
                            pDunSetting->bAllowEap = TRUE;

                            if (FALSE == pEAPData->bNotInstalled)
                            {
                                CmFree(pDunSetting->pCustomAuthData);

                                pDunSetting->dwCustomAuthKey = pEAPData->dwCustomAuthKey;
                                pDunSetting->pCustomAuthData = pEAPData->pCustomAuthData;
                                pDunSetting->dwCustomAuthDataSize = pEAPData->dwCustomAuthDataSize;

                                //
                                //  Now NULL out the pEapData entry, this saves us from having to
                                //  allocate mem and copy to pDunSetting but keeps the code
                                //  that cleans up the EapData structs from freeing our data
                                //
                                pEAPData->pCustomAuthData = NULL;
                                pEAPData->dwCustomAuthDataSize = 0;
                            }                        
                        }
                        else
                        {
                            pDunSetting->bAllowEap = FALSE;
                        }

                        //
                        //  Get the non-EAP protocols.  Note that if the user selected EAP we will clear
                        //  these before writing them out.
                        //
                        pDunSetting->bAllowPap = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_PAP));
                        pDunSetting->bAllowSpap = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_SPAP));
                        pDunSetting->bAllowChap = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_CHAP));
                        pDunSetting->bAllowMsChap = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_MSCHAP));
                        pDunSetting->bAllowMsChap2 = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_MSCHAP2));

                        if (pDunSetting->bTunnelDunSetting)
                        {
                            pDunSetting->dwVpnStrategy = (DWORD)SendDlgItemMessage(hDlg, IDC_VPN_TYPE, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
                            if (CB_ERR == pDunSetting->dwVpnStrategy)
                            {
                                CMASSERTMSG(FALSE, TEXT("ProcessWin2kSecurityPopup -- CB_ERR returned for VPN strategy."));
                                pDunSetting->dwVpnStrategy = VS_PptpFirst;
                            }
                            else
                            {
                                //
                                //  Adjust Vpn Strategy because we no longer offer Automatic as a choice
                                //
                                pDunSetting->dwVpnStrategy += 1;
                                MYDBGASSERT((pDunSetting->dwVpnStrategy >= VS_PptpOnly) && (pDunSetting->dwVpnStrategy <= VS_L2tpFirst));
                            }

                            if ((VS_L2tpFirst == pDunSetting->dwVpnStrategy) || (VS_L2tpOnly == pDunSetting->dwVpnStrategy))
                            {
                                pDunSetting->bUsePskOnWin2kPlus = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_USE_PSK));
                            }
                            else
                            {
                                pDunSetting->bUsePskOnWin2kPlus = FALSE;
                            }
                        }

                    }

                    FreeEapData(hDlg, IDC_EAP_TYPES);

                    EndDialog(hDlg, IDOK);

                    break;
                case IDCANCEL:
                    FreeEapData(hDlg, IDC_EAP_TYPES);

                    EndDialog(hDlg, IDCANCEL);
                    break;

                case IDC_USE_EAP:
                    MYDBGASSERT(pDunSetting);

                    if (pDunSetting)
                    {
                        SelectAppropriateEAP(hDlg, IDC_EAP_TYPES, pDunSetting);
                    }

                case IDC_ALLOWED_PROTOCOLS:
                    EnableAppropriateSecurityControls(hDlg);
                    break;

                case IDC_EAP_TYPES:
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        EnableDisableEapPropertiesButton(hDlg);
                    }
                    break;

                case IDC_VPN_TYPE:
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        EnablePskCheckboxForL2TP(hDlg);
                    }
                    break;

                default:
                    break;
            }

            break;
    }
    return FALSE;   
}

//+----------------------------------------------------------------------------
//
// Function:  EnableDisableSecurityButtons
//
// Synopsis:  This function determines which of the two configure buttons
//            should be enabled.  The configure buttons allow the user to
//            configure the security settings of the DUN settings.  There is
//            one button for platform independent security settings and one for
//            win2k+ security settings.
//
// Arguments: HWND hDlg - window handle to the general property sheet
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void EnableDisableSecurityButtons(HWND hDlg)
{
    INT_PTR nResult = SendDlgItemMessage(hDlg, IDC_COMBO1, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);

    if (CB_ERR == nResult)
    {
        nResult = 0;
    }

    //
    //  Disable the Win2k config button if the first selection is chosen
    //
    EnableWindow(GetDlgItem(hDlg, IDC_CONFIG_WIN2K), (0 != nResult));

    //
    //  Disable the standard config button if the last selection is chosen
    //
    EnableWindow(GetDlgItem(hDlg, IDC_CONFIG_ALL), (2 != nResult));
}

//+----------------------------------------------------------------------------
//
// Function:  GeneralPropSheetProc
//
// Synopsis:  This function processes messages for General property sheet of
//            the DUN settings UI.  This property sheet holds UI for configuring
//            the name of the DUN setting and dialup scripting.
//
// Arguments: HWND hDlg - window handle to the dialog
//            UINT message - the current message to process
//            WPARAM wParam - wParam see individual message type for details
//            LPARAM lParam - lParam see individual message type for details
//
// Returns:   INT_PTR - TRUE if the message was completely handled
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY GeneralPropSheetProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR* pnmHeader = (NMHDR*)lParam;
    INT_PTR nResult;
    static DWORD_PTR HelpId = 0;
    static ListBxList* pListEntry = NULL;
    static CDunSetting* pDunSetting = NULL;

    SetDefaultGUIFont(hDlg, message, IDC_EDIT1);
    SetDefaultGUIFont(hDlg, message, IDC_EDIT2);

    if (ProcessHelp(hDlg, message, wParam, lParam, HelpId)) return TRUE;

    switch (message)
    {
        case WM_INITDIALOG:
            if (lParam)
            {
                PROPSHEETPAGE* pPropSheetPage = (PROPSHEETPAGE*)lParam;

                if (pPropSheetPage->lParam)
                {
                    pListEntry = (ListBxList*)pPropSheetPage->lParam;
                    pDunSetting = (CDunSetting*)pListEntry->ListBxData;

                    if (pListEntry && pDunSetting)
                    {
                        //
                        //  Setup the help ID appropriately...
                        //
                        HelpId = ((pDunSetting->bTunnelDunSetting) ? IDH_VENTRY : IDH_DENTRY);

                        if (pListEntry->szName[0])
                        {
                            MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT1), WM_SETTEXT, 0, (LPARAM)pListEntry->szName));
                            EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), FALSE); // don't allow the user to edit the name
                        }

                        //
                        //  Now lets set the disable file and printer sharing checkbox and the network logon checkbox
                        //
                        MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK1, pDunSetting->bSecureLocalFiles));
                        MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK2, pDunSetting->bNetworkLogon));

                        if (pDunSetting->szScript[0])
                        {
                            MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT2), WM_SETTEXT, 0, (LPARAM)GetName(pDunSetting->szScript)));
                        }

                        //
                        //  If this is a VPN DUN setting, then hide the script controls
                        //
                        if (pDunSetting->bTunnelDunSetting)
                        {
                            ShowWindow(GetDlgItem(hDlg, IDC_SCRIPT_LABEL), SW_HIDE);
                            ShowWindow(GetDlgItem(hDlg, IDC_EDIT2), SW_HIDE);
                            ShowWindow(GetDlgItem(hDlg, IDC_BUTTON1), SW_HIDE);
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("GeneralPropSheetProc -- pListEntry or pDunSetting are NULL"));
                    }
                }
                else
                {
                    pListEntry = NULL;
                    pDunSetting = NULL;
                    CMASSERTMSG(FALSE, TEXT("GeneralPropSheetProc -- NULL lParam passed to InitDialog.  Dialog controls will all be set to off."));
                }
            }
            else
            {
                pListEntry = NULL;
                pDunSetting = NULL;
                CMASSERTMSG(FALSE, TEXT("GeneralPropSheetProc -- NULL PropSheetPage pointer passed for lParam."));
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_BUTTON1: // browse button

                    if (pDunSetting)
                    {
                        UINT uScpFilter = IDS_SCPFILTER;
                        TCHAR* szScpMask = TEXT("*.scp");

                        MYVERIFY(0 != DoBrowse(hDlg, &uScpFilter, &szScpMask, 1, IDC_EDIT2,
                            TEXT("scp"), pDunSetting->szScript));
                    }

                    break;
            }

            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {
                case PSN_APPLY:
                if (pListEntry && pDunSetting)
                {
                    //
                    //  Get the name of the entry
                    //
                    nResult = GetTextFromControl(hDlg, IDC_EDIT1, pListEntry->szName, MAX_PATH, TRUE); // bDisplayError == TRUE

                    if (-1 == nResult)
                    {
                        //
                        //  If we read in a string we cannot convert from the cms file and then the user editted the entry
                        //  then the edit control may contain "bad" data but the user won't be able to edit it.  Since this
                        //  is extremely unlikely we won't add special handling for it other than to prevent the focus from
                        //  being set to a disabled control.
                        //
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_EDIT1)))
                        {
                            SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                        }
                        
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }

                    //
                    //  Now, let's trim the name and make sure it isn't empty
                    //
                    CmStrTrim(pListEntry->szName);

                    if ((TEXT('\0') == pListEntry->szName[0]) || (0 == nResult))
                    {
                        ShowMessage(hDlg, IDS_NEED_DUN_NAME, MB_OK);
                        
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_EDIT1)))
                        {
                            SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                        }

                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;                    
                    }

                    //
                    //  Get the values for the Secure local files and the network logon checkboxes
                    //
                    pDunSetting->bSecureLocalFiles = IsDlgButtonChecked(hDlg, IDC_CHECK1);
                    pDunSetting->bNetworkLogon = IsDlgButtonChecked(hDlg, IDC_CHECK2);

                    //
                    //  Get and verify the script
                    //
                    if (FALSE == pDunSetting->bTunnelDunSetting)
                    {
                        if (!VerifyFile(hDlg, IDC_EDIT2, pDunSetting->szScript, TRUE))
                        {
                            SetFocus(GetDlgItem(hDlg, IDC_EDIT2));
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                            return TRUE;
                        }
                    }
                    break;
                }
            }

            break;
        default:
            return FALSE;
    }
    return FALSE;   
}

//+----------------------------------------------------------------------------
//
// Function:  SecurityPropSheetProc
//
// Synopsis:  This function processes messages for Security property sheet of
//            the DUN settings UI.  This property sheet holds UI for configuring
//            how the user wants their security settings applied.
//
// Arguments: HWND hDlg - window handle to the dialog
//            UINT message - the current message to process
//            WPARAM wParam - wParam see individual message type for details
//            LPARAM lParam - lParam see individual message type for details
//
// Returns:   INT_PTR - TRUE if the message was completely handled
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY SecurityPropSheetProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR* pnmHeader = (NMHDR*)lParam;
    INT_PTR nResult;
    static DWORD_PTR HelpId = 0;
    static ListBxList* pListEntry = NULL;
    static CDunSetting* pDunSetting = NULL;
    static fUpdateVPNStrategy = TRUE;

    SetDefaultGUIFont(hDlg, message, IDC_COMBO1);

    if (ProcessHelp(hDlg, message, wParam, lParam, HelpId)) return TRUE;

    switch (message)
    {
        case WM_INITDIALOG:
            if (lParam)
            {
                PROPSHEETPAGE* pPropSheetPage = (PROPSHEETPAGE*)lParam;
                fUpdateVPNStrategy = TRUE;

                if (pPropSheetPage->lParam)
                {
                    pListEntry = (ListBxList*)pPropSheetPage->lParam;
                    pDunSetting = (CDunSetting*)pListEntry->ListBxData;

                    if (pListEntry && pDunSetting) // this will give a big visual clue that something is wrong
                    {
                        //
                        //  Setup the help ID appropriately
                        //
                        HelpId = ((pDunSetting->bTunnelDunSetting) ? IDH_VENTRY : IDH_DENTRY);

                        //
                        //  Load and set the strings for the combo box
                        //
                        LPTSTR pszString;

                        for (int i = BASE_SECURITY_SCENARIO_ID; i < (BASE_SECURITY_SCENARIO_ID + NUM_SECURITY_SCENARIOS); i++)
                        {
                            pszString = CmLoadString(g_hInstance, i);
                            MYDBGASSERT(pszString);

                            if (pszString)
                            {
                                SendDlgItemMessage(hDlg, IDC_COMBO1, CB_ADDSTRING, 0, (LPARAM)pszString);
                                CmFree(pszString);
                            }
                        }

                        //
                        //  Now figure out which selection to pick
                        //
                        MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, IDC_COMBO1, CB_SETCURSEL, (WPARAM)(pDunSetting->iHowToHandleSecuritySettings), (LPARAM)0));

                        EnableDisableSecurityButtons(hDlg);
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("SecurityPropSheetProc -- pListEntry or pDunSetting is NULL"));
                    }
                }
                else
                {
                    pListEntry = NULL;
                    pDunSetting = NULL;
                    CMASSERTMSG(FALSE, TEXT("SecurityPropSheetProc -- NULL lParam passed to InitDialog.  Dialog controls will all be set to off."));
                }
            }
            else
            {
                pListEntry = NULL;
                pDunSetting = NULL;
                CMASSERTMSG(FALSE, TEXT("SecurityPropSheetProc -- NULL PropSheetPage pointer passed for lParam."));
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_CONFIG_ALL:
                    {
                        UINT uDialogId = pDunSetting->bTunnelDunSetting ? IDD_VPN_SECURITY_POPUP: IDD_DUN_SECURITY_POPUP;

                        nResult = DialogBoxParam(NULL, MAKEINTRESOURCE(uDialogId), hDlg, ProcessSecurityPopup, (LPARAM)pDunSetting);
                    }
                    break;

                case IDC_CONFIG_WIN2K:
                    if (pDunSetting)
                    {                       
                        UINT uDialogId = pDunSetting->bTunnelDunSetting ? IDD_WIN2K_SECURITY_TUNNEL_POPUP: IDD_WIN2K_SECURITY_POPUP;
                        nResult = DialogBoxParam(NULL, MAKEINTRESOURCE(uDialogId), hDlg, ProcessWin2kSecurityPopup, (LPARAM)pDunSetting);
                        if (IDOK == nResult)
                        {
                            fUpdateVPNStrategy = FALSE;
                        }
                    }
                    
                    break;

                case IDC_COMBO1: // how does the user want the security settings applied
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        EnableDisableSecurityButtons(hDlg);
                    }

                    break;
            }

            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {
                case PSN_APPLY:
                if (pListEntry && pDunSetting)
                {
                    //
                    //  Figure out if the Admin wanted us to enforce the Win2k custom security flags or not
                    //
                    pDunSetting->iHowToHandleSecuritySettings = (int)SendDlgItemMessage(hDlg, IDC_COMBO1, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
                    break;
                }
            }

            break;
        default:
            return FALSE;
    }
    return FALSE;   
}

//+----------------------------------------------------------------------------
//
// Function:  CreateNetworkingEntryPropertySheet
//
// Synopsis:  This function creates and launches the Networking DUN entry
//            property sheet which allows networking entry configuration.
//
// Arguments: HINSTANCE hInstance - instance handle for resources
//            HWND hWizard - window handle of the current CMAK wizard page
//            LPARAM lParam - initialization parameter passed to each propsheet page
//            BOOL bEdit - whether we are launching the property sheet to edit
//                         an existing entry or add a new one (affects the title).
//
// Returns:   int - returns a positive value if successful, -1 on error
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
INT_PTR CreateNetworkingEntryPropertySheet(HINSTANCE hInstance, HWND hWizard, LPARAM lParam, BOOL bEdit, BOOL bUseVpnTitle)
{

    PROPSHEETPAGE psp[3]; 
    PROPSHEETHEADER psh = {0};
    LPTSTR pszCaption = NULL;
    INT_PTR iReturn = -1;
    UINT uTitleStringId;

    //
    //  Check the params, note that lParam could be NULL
    //
    if ((NULL == hInstance) || (NULL == hWizard))
    {
        CMASSERTMSG(FALSE, TEXT("CreateNetworkingEntryPropertySheet -- Invalid Parameter passed."));
        goto exit;
    }

    //
    //  Fill in the property page structures
    //

    for (int i = 0; i < 3; i++)
    {
        psp[i].dwSize = sizeof(psp[0]);
        psp[i].dwFlags = PSP_HASHELP;
        psp[i].hInstance = hInstance;
        psp[i].lParam = lParam;
    }

    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_GENERAL);
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_TCPIP_SETTINGS);
    psp[2].pszTemplate = MAKEINTRESOURCE(IDD_SECURITY);
    psp[0].pfnDlgProc = GeneralPropSheetProc;
    psp[1].pfnDlgProc = TcpIpPropSheetProc;
    psp[2].pfnDlgProc = SecurityPropSheetProc;

    //
    //  Load the caption
    //

    uTitleStringId = bUseVpnTitle ? BASE_VPN_ENTRY_TITLE : BASE_DUN_ENTRY_TITLE;

    if (bEdit)
    {
        uTitleStringId = uTitleStringId + EDIT_INCREMENT;
    }
    else
    {
        uTitleStringId = uTitleStringId + NEW_INCREMENT;
    }

    pszCaption = CmLoadString(hInstance, uTitleStringId);

    if (NULL == pszCaption)
    {
        CMASSERTMSG(FALSE, TEXT("CreateNetworkingEntryPropertySheet -- CmLoadString failed trying to load the prop sheet title."));
        goto exit;
    }

    //
    //  Fill in the property sheet header
    //
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_HASHELP | PSH_NOCONTEXTHELP;
    psh.hwndParent = hWizard;
    psh.pszCaption = pszCaption;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp = (LPCPROPSHEETPAGE) &psp[0];

    //
    //  Launch the property sheet
    //
    iReturn = PropertySheet(&psh);

    if (-1 == iReturn)
    {
        CMTRACE1(TEXT("CreateNetworkingEntryPropertySheet -- PropertySheet called failed, GLE %d"), GetLastError());
    }

exit:

    CmFree(pszCaption);

    return iReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  OnProcessDunEntriesAdd
//
// Synopsis:  This function is called when the Add button on the DUN entries
//            page is pressed.  It's job is to create a new CDunSetting
//            structure and a new ListBox record and then launch the networking
//            entries property page with this newly created DUN entry.  If the
//            user hits OK on the property sheet then this newly created entry
//            is added to the DUN entry linked list.  If the user hits cancel
//            the entry is freed and never added to the list.
//
// Arguments: HINSTANCE hInstance - instance handle to load resources
//            HWND hDlg - window handle of the DUN entries wizard page
//            UINT uListCtrlId - control ID of the list containing the DUN entries
//            ListBxStruct** pHeadDns - head of the dun entry list
//            ListBxStruct** pTailDns - tail of the dun entry list
//            BOOL bCreateTunnelEntry - whether we are adding a tunnel entry or not
//            LPCTSTR pszLongServiceName - the long service name of the profile
//            LPCTSTR pszCmsFile - CMS file to get the default/VPN DUN entry names from
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void OnProcessDunEntriesAdd(HINSTANCE hInstance, HWND hDlg, UINT uListCtrlId, ListBxStruct** pHeadDns, ListBxStruct** pTailDns, 
                            BOOL bCreateTunnelEntry, LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile)
{
    //
    //  Check the input params, make sure that *pHeadDns / *pTailDns are both NULL or both non-NULL
    //
    if (hInstance && hDlg && pHeadDns && pTailDns && (FALSE == ((NULL == *pHeadDns) ^ (NULL == *pTailDns))))
    {
        //
        //  We want to create an empty ListBxStruct and an new CDunSetting.  This keeps all of the initialization
        //  logic in the CDunSetting constructor and keeps the dialog procedures very simple.
        //
        ListBxStruct* pLinkedListItem = (ListBxStruct*)CmMalloc(sizeof(ListBxStruct));
        CDunSetting* pDunSetting = new CDunSetting(bCreateTunnelEntry);
        INT_PTR iPropSheetReturnValue = -1;

        if ((NULL == pDunSetting) || (NULL == pLinkedListItem))
        {
            CMASSERTMSG(FALSE, TEXT("OnProcessDunEntriesAdd -- CmMalloc and/or new failed."));
            CmFree(pDunSetting);
            CmFree(pLinkedListItem);
            return;
        }

        //
        //  Now call the property sheet
        //
        BOOL bExitLoop = FALSE;

        do
        {
            pLinkedListItem->ListBxData = (void*)pDunSetting;
            iPropSheetReturnValue = CreateNetworkingEntryPropertySheet(hInstance, hDlg, (LPARAM)pLinkedListItem, FALSE, pDunSetting->bTunnelDunSetting); // bEdit == FALSE

            if (IDOK == iPropSheetReturnValue)
            {
                //
                //  Search the list to make sure that the user didn't give us the name of an existing
                //  DUN entry.  If they did, then we should prompt them for overwrite.
                //
                ListBxStruct* pCurrent = *pHeadDns;

                while (pCurrent)
                {
                    if (0 == lstrcmpi(pCurrent->szName, pLinkedListItem->szName))
                    {
                        //
                        //  Then we have a dup, lets prompt the user
                        //
                        LPTSTR pszMsg = CmFmtMsg(hInstance, IDS_DUN_NAME_EXISTS, pLinkedListItem->szName);

                        //
                        //  Make sure to blank out the name.  Two things can happen here.  Either, the name
                        //  wasn't what the user wanted and they want to change it.  In that case, we blank the
                        //  name so that when the dialog comes back up to edit, we won't gray out the name control
                        //  as we normally do for an edit.  Since the name was invalid this is an additional clue
                        //  to the user as to what was wrong.  If the name was valid and the user means to do a rename,
                        //  then we are going to free pLinkedListItem anyway and blanking the name means nothing.  However,
                        //  if we fail to allocate pszMsg, then blanking the name will at least allow the dialog to come back
                        //  up with a edittable name and the user may be able to fix the problem ... unlikely 
                        //  if mem allocs are failing but better than leaving the user truly hosed.
                        //
                        pLinkedListItem->szName[0] = TEXT('\0');                                


                        if (pszMsg)
                        {
                            int iResult = MessageBox(hDlg, pszMsg, g_szAppTitle, MB_YESNO);
                            CmFree(pszMsg);

                            //
                            //  If the user said yes, lets replace the existing entry and get out of here, otherwise
                            //  we want to loop again.
                            //
                            if (IDYES == iResult)
                            {
                                CDunSetting* pOldDunSetting = (CDunSetting*)pCurrent->ListBxData;
                                delete pOldDunSetting;

                                pCurrent->ListBxData = pDunSetting;
                                CmFree(pLinkedListItem);                                
                                
                                RefreshDnsList(hInstance, hDlg, uListCtrlId, *pHeadDns, pszLongServiceName, pszCmsFile, pCurrent->szName);
                                bExitLoop = TRUE;
                            }

                            break;
                        }
                    }

                    pCurrent = pCurrent->next;
                }

                //
                //  If we didn't find a duplicate, then add the item to the list as usual,
                //  making sure that pLinkedListItem->next is NULL so that the list is terminated.
                //
                if (NULL == pCurrent)
                {
                    pLinkedListItem->next = NULL;   // make sure our list is terminated

                    if (*pHeadDns)
                    {
                        (*pTailDns)->next = pLinkedListItem;
                    }
                    else
                    {
                        *pHeadDns = pLinkedListItem;
                    }

                    *pTailDns = pLinkedListItem;

                    RefreshDnsList(hInstance, hDlg, uListCtrlId, *pHeadDns, pszLongServiceName, pszCmsFile, pLinkedListItem->szName);
                    bExitLoop = TRUE;
                }
            }
            else
            {
                bExitLoop = TRUE;
                CmFree(pLinkedListItem);
                delete pDunSetting;
            }

        } while (!bExitLoop);
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("OnProcessDunEntriesAdd -- Invalid parameter passed."));
    }
}

//+----------------------------------------------------------------------------
//
// Function:  OnProcessDunEntriesEdit
//
// Synopsis:  This function is called when the Edit button on the DUN entries
//            page is pressed.  It's job is to find the ListBox and CDunSetting
//            structures for the item currently selected in the listbox and then
//            launch the networking entries property page with this DUN entry.
//            The property sheet itself takes care of only changing the Dun Entry
//            if Okay is pressed.  Canceling should leave the entry unchanged.
//
// Arguments: HINSTANCE hInstance - instance handle to load resources
//            HWND hDlg - window handle of the DUN entries wizard page
//            UINT uListCtrlId - control ID of the list containing the DUN entries
//            ListBxStruct** pHeadDns - head of the dun entry list
//            ListBxStruct** pTailDns - tail of the dun entry list
//            LPCTSTR pszLongServiceName - the long service name of the profile
//            LPCTSTR pszCmsFile - CMS file to get the default/VPN DUN entry names from
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void OnProcessDunEntriesEdit(HINSTANCE hInstance, HWND hDlg, UINT uListCtrlId, ListBxStruct** pHeadDns, 
                             ListBxStruct** pTailDns, LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile)
{
    LPTSTR pszTunnelDunDisplayString = NULL;
    LPTSTR pszDefaultDunDisplayString = NULL;
    TCHAR szTunnelDunName[MAX_PATH+1] = TEXT("");
    TCHAR szDefaultDunName[MAX_PATH+1] = TEXT("");
    LPTSTR pszNameOfItemToEdit = NULL;

    //
    //  Check the input params, make sure that *pHeadDns / *pTailDns are both NULL or both non-NULL
    //

    if (hInstance && hDlg && pHeadDns && pTailDns && (FALSE == ((NULL == *pHeadDns) ^ (NULL == *pTailDns))))
    {
        INT_PTR iPropSheetReturnValue = -1;
        TCHAR szNameOfItemToEdit[MAX_PATH+1];
        ListBxStruct* pItemToEdit = NULL;

        //
        //  Lets get the current selection from the listbox
        //
        INT_PTR nResult = SendDlgItemMessage(hDlg, uListCtrlId, LB_GETCURSEL, 0, (LPARAM)0);

        if (LB_ERR == nResult)
        {
            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOSELECTION, MB_OK));
        }
        else
        {        
            if (LB_ERR != SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETTEXT, (WPARAM)nResult, (LPARAM)szNameOfItemToEdit))
            {
                //
                //  Get the name of the Tunnel Dun setting
                //
                MYVERIFY(0 != GetTunnelDunSettingName(pszCmsFile, pszLongServiceName, szTunnelDunName, CELEMS(szTunnelDunName)));

                //
                //  Get the name of the default Dun setting
                //
                MYVERIFY(0 != GetDefaultDunSettingName(pszCmsFile, pszLongServiceName, szDefaultDunName, CELEMS(szDefaultDunName)));

                //
                //  If we have the default DUN entry text or the default VPN entry text then we want
                //  to use the real item names for these instead of the text we inserted for
                //  the user to read.
                //
                pszTunnelDunDisplayString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, szTunnelDunName);
                pszDefaultDunDisplayString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, szDefaultDunName);

                MYDBGASSERT(pszTunnelDunDisplayString && pszDefaultDunDisplayString);

                if (pszTunnelDunDisplayString && pszDefaultDunDisplayString)
                {
                    if (0 == lstrcmpi(pszTunnelDunDisplayString, szNameOfItemToEdit))
                    {
                        pszNameOfItemToEdit = szTunnelDunName;
                    }
                    else if (0 == lstrcmpi(pszDefaultDunDisplayString, szNameOfItemToEdit))
                    {
                        pszNameOfItemToEdit = szDefaultDunName;
                    }
                    else
                    {
                        pszNameOfItemToEdit = szNameOfItemToEdit;
                    }

                    //
                    //  Now find the entry in the list
                    //
                    if (FindListItemByName(pszNameOfItemToEdit, *pHeadDns, &pItemToEdit))
                    {
                        //
                        //  Finally call the property sheet
                        //

                        CDunSetting* pDunSetting = ((CDunSetting*)(pItemToEdit->ListBxData));
                        BOOL bTunnelSetting = FALSE;

                        if (pDunSetting)
                        {
                            bTunnelSetting = pDunSetting->bTunnelDunSetting;
                        }

                        iPropSheetReturnValue = CreateNetworkingEntryPropertySheet(hInstance, hDlg, (LPARAM)pItemToEdit, TRUE, bTunnelSetting); // bEdit == TRUE

                        if (IDOK == iPropSheetReturnValue)
                        {
                            RefreshDnsList(hInstance, hDlg, uListCtrlId, *pHeadDns, pszLongServiceName, pszCmsFile, pItemToEdit->szName);
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("OnProcessDunEntriesEdit -- FindListItemByName couldn't find the item in the list."));            
                    }
                }
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("OnProcessDunEntriesEdit -- LB_GETTEXT returned an error."));           
            }
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("OnProcessDunEntriesEdit -- Invalid parameter passed."));
    }

    CmFree(pszDefaultDunDisplayString);
    CmFree(pszTunnelDunDisplayString);
}

//+----------------------------------------------------------------------------
//
// Function:  OnProcessDunEntriesDelete
//
// Synopsis:  This function is called when the Delete button on the DUN entries
//            page is pressed.  It's job is to find the ListBox and CDunSetting
//            structures for the item currently selected in the listbox and then
//            remove this item from the DUN entries linked list.
//
// Arguments: HINSTANCE hInstance - instance handle to load resources
//            HWND hDlg - window handle of the DUN entries wizard page
//            UINT uListCtrlId - control ID of the list containing the DUN entries
//            ListBxStruct** pHeadDns - head of the dun entry list
//            ListBxStruct** pTailDns - tail of the dun entry list
//            LPCTSTR pszLongServiceName - the long service name of the profile
//            LPCTSTR pszCmsFile - CMS file to get the default/VPN DUN entry names from
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void OnProcessDunEntriesDelete(HINSTANCE hInstance, HWND hDlg, UINT uListCtrlId, ListBxStruct** pHeadDns, 
                               ListBxStruct** pTailDns, LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile)
{
    //
    //  Check the input params, make sure that *pHeadDns / *pTailDns are both NULL or both non-NULL
    //
    if (hInstance && hDlg && pHeadDns && pTailDns && (FALSE == ((NULL == *pHeadDns) ^ (NULL == *pTailDns))))
    {
        TCHAR szNameOfItemToDelete[MAX_PATH+1];

        //
        //  Lets get the current selection from the listbox
        //
        INT_PTR nResult = SendDlgItemMessage(hDlg, uListCtrlId, LB_GETCURSEL, 0, (LPARAM)0);

        if (LB_ERR == nResult)
        {
            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOSELECTION, MB_OK));
        }
        else
        {
            if (LB_ERR != SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETTEXT, (WPARAM)nResult, (LPARAM)szNameOfItemToDelete))
            {
                //
                //  Now find the entry in the list
                //
                ListBxStruct* pCurrent = *pHeadDns;
                ListBxStruct* pFollower = NULL;

                while (pCurrent)
                {
                    if (0 == lstrcmpi(szNameOfItemToDelete, pCurrent->szName))
                    {
                        //
                        //  We found the item to delete
                        //
                        if (pFollower)
                        {
                            pFollower->next = pCurrent->next;
                            CDunSetting* pDunSetting = (CDunSetting*)pCurrent->ListBxData;
                            CmFree(pDunSetting);
                            CmFree(pCurrent);
                            

                            //
                            //  We want to continue to the end of the list so that
                            //  we can set the tail pointer appropriately.  Thus
                            //  leave pFollower on the item it was on and update
                            //  pCurrent to the next item in the list, if it is NULL
                            //  then we will stop here.
                            //
                            pCurrent = pFollower->next;
                        }
                        else
                        {
                            //
                            //  It is the first item in the list
                            //
                            *pHeadDns = (*pHeadDns)->next;
                            CDunSetting* pDunSetting = (CDunSetting*)pCurrent->ListBxData;
                            CmFree(pDunSetting);
                            CmFree(pCurrent);

                            //
                            //  We want to go to the end of the list to find the tail pointer
                            //  so reset pCurrent to the beginning of the list.
                            //
                            pCurrent = *pHeadDns;
                        }

                        //
                        //  Don't forget to delete it from the CMS file itself
                        //
                        EraseNetworkingSections(szNameOfItemToDelete, pszCmsFile);

                        //
                        //  Refresh the Dns list
                        //
                        RefreshDnsList(hInstance, hDlg, uListCtrlId, *pHeadDns, pszLongServiceName, pszCmsFile, NULL);                        
                    }
                    else
                    {
                        pFollower = pCurrent;
                        pCurrent = pCurrent->next;                    
                    }
                }

                //
                //  Reset the tail pointer to the last item in the list
                //
                *pTailDns = pFollower;
            }
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("OnProcessDunEntriesDelete -- Invalid parameter passed."));
    }
}

//+----------------------------------------------------------------------------
//
// Function:  EnableDisableIpAddressControls
//
// Synopsis:  This function enables or disables the IP address controls for
//            the static IP address and for the Wins and DNS server addresses
//            depending on the state of the enable/disable radio buttons.
//
// Arguments: HWND hDlg - window handle of the TCP/IP settings dialog
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void EnableDisableIpAddressControls(HWND hDlg)
{
    //
    //  Next Enable/Disable the Wins and DNS address controls
    //
    BOOL bCheckedState = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO2));

    EnableWindow(GetDlgItem(hDlg, IDC_PRIMARY_DNS), bCheckedState);
    EnableWindow(GetDlgItem(hDlg, IDC_LABEL_DNS), bCheckedState);

    EnableWindow(GetDlgItem(hDlg, IDC_SECONDARY_DNS), bCheckedState);
    EnableWindow(GetDlgItem(hDlg, IDC_LABEL_DNS2), bCheckedState);

    EnableWindow(GetDlgItem(hDlg, IDC_PRIMARY_WINS), bCheckedState);
    EnableWindow(GetDlgItem(hDlg, IDC_LABEL_WINS), bCheckedState);

    EnableWindow(GetDlgItem(hDlg, IDC_SECONDARY_WINS), bCheckedState);
    EnableWindow(GetDlgItem(hDlg, IDC_LABEL_WINS2), bCheckedState);
}

//+----------------------------------------------------------------------------
//
// Function:  TcpIpPropSheetProc
//
// Synopsis:  This function processes messages for TCP/IP Settings property sheet.
//
// Arguments: HWND hDlg - window handle to the dialog
//            UINT message - the current message to process
//            WPARAM wParam - wParam see individual message type for details
//            LPARAM lParam - lParam see individual message type for details
//
// Returns:   INT_PTR - TRUE if the message was completely handled
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY TcpIpPropSheetProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR* pnmHeader = (NMHDR*)lParam;
    static DWORD_PTR HelpId = 0;
    static ListBxList* pListEntry = NULL;
    static CDunSetting* pDunSetting = NULL;

    if (ProcessHelp(hDlg, message, wParam, lParam, HelpId)) return TRUE;
    
    switch (message)
    {
        case WM_INITDIALOG:

            if (lParam)
            {
                PROPSHEETPAGE* pPropSheetPage = (PROPSHEETPAGE*)lParam;

                if (pPropSheetPage->lParam)
                {
                    pListEntry = (ListBxList*)pPropSheetPage->lParam;
                    pDunSetting = (CDunSetting*)pListEntry->ListBxData;

                    UINT uCrtlToSet;

                    if (pListEntry && pDunSetting)
                    {
                        //
                        //  Setup the help ID appropriately
                        //
                        HelpId = ((pDunSetting->bTunnelDunSetting) ? IDH_VENTRY : IDH_DENTRY);

                        //
                        //  Init the WINS and DNS IP address controls and the radio buttons specifying
                        //  whether the user chose to give us addresses or not.
                        //
                        if (pDunSetting->dwPrimaryDns || pDunSetting->dwSecondaryDns || pDunSetting->dwPrimaryWins || pDunSetting->dwSecondaryWins)
                        {
                            uCrtlToSet = IDC_RADIO2;
                            SendDlgItemMessage(hDlg, IDC_PRIMARY_DNS, IPM_SETADDRESS, (WPARAM)0, (LPARAM)(pDunSetting->dwPrimaryDns));
                            SendDlgItemMessage(hDlg, IDC_SECONDARY_DNS, IPM_SETADDRESS, (WPARAM)0, (LPARAM)(pDunSetting->dwSecondaryDns));
                            SendDlgItemMessage(hDlg, IDC_PRIMARY_WINS, IPM_SETADDRESS, (WPARAM)0, (LPARAM)(pDunSetting->dwPrimaryWins));
                            SendDlgItemMessage(hDlg, IDC_SECONDARY_WINS, IPM_SETADDRESS, (WPARAM)0, (LPARAM)(pDunSetting->dwSecondaryWins));
                        }
                        else
                        {
                            uCrtlToSet = IDC_RADIO1;
                            SendDlgItemMessage(hDlg, IDC_PRIMARY_DNS, IPM_CLEARADDRESS, (WPARAM)0, (LPARAM)0);
                            SendDlgItemMessage(hDlg, IDC_SECONDARY_DNS, IPM_CLEARADDRESS, (WPARAM)0, (LPARAM)0);
                            SendDlgItemMessage(hDlg, IDC_PRIMARY_WINS, IPM_CLEARADDRESS, (WPARAM)0, (LPARAM)0);
                            SendDlgItemMessage(hDlg, IDC_SECONDARY_WINS, IPM_CLEARADDRESS, (WPARAM)0, (LPARAM)0);
                        }

                        MYVERIFY(0 != CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, uCrtlToSet));

                        //
                        //  Finally set the checkboxes for IP header compression and whether to use
                        //  the remote gateway or not.
                        //
                        MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK1, pDunSetting->bGatewayOnRemote));
                        MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK2, pDunSetting->bIpHeaderCompression));

                        EnableDisableIpAddressControls(hDlg);
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("TcpIpPropSheetProc -- pListEntry or pDunSetting are NULL"));
                    }
                }
                else
                {
                    pListEntry = NULL;
                    pDunSetting = NULL;
                    CMASSERTMSG(FALSE, TEXT("TcpIpPropSheetProc -- NULL lParam passed to InitDialog.  Dialog controls will all be set to off."));
                }
            }
            else
            {
                pListEntry = NULL;
                pDunSetting = NULL;
                CMASSERTMSG(FALSE, TEXT("TcpIpPropSheetProc -- NULL PropSheetPage pointer passed for lParam."));
            }

            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {
                case PSN_APPLY:
                    if (pListEntry && pDunSetting)
                    {
                        //
                        //  Okay, lets read in the settings and save them to the passed
                        //  in CDunSetting pointer.
                        //
                        if (IsDlgButtonChecked(hDlg, IDC_RADIO2))
                        {
                            SendDlgItemMessage(hDlg, IDC_PRIMARY_DNS, IPM_GETADDRESS, (WPARAM)0, (LPARAM)&(pDunSetting->dwPrimaryDns));
                            SendDlgItemMessage(hDlg, IDC_SECONDARY_DNS, IPM_GETADDRESS, (WPARAM)0, (LPARAM)&(pDunSetting->dwSecondaryDns));
                            SendDlgItemMessage(hDlg, IDC_PRIMARY_WINS, IPM_GETADDRESS, (WPARAM)0, (LPARAM)&(pDunSetting->dwPrimaryWins));
                            SendDlgItemMessage(hDlg, IDC_SECONDARY_WINS, IPM_GETADDRESS, (WPARAM)0, (LPARAM)&(pDunSetting->dwSecondaryWins));
                        }
                        else
                        {
                            pDunSetting->dwPrimaryDns = 0;
                            pDunSetting->dwSecondaryDns = 0;
                            pDunSetting->dwPrimaryWins = 0;
                            pDunSetting->dwSecondaryWins = 0;
                        }

                        pDunSetting->bGatewayOnRemote = IsDlgButtonChecked(hDlg, IDC_CHECK1);
                        pDunSetting->bIpHeaderCompression = IsDlgButtonChecked(hDlg, IDC_CHECK2);

                    }
                    break;
                default:
                    break;
            }

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_RADIO1:
                case IDC_RADIO2:
                    EnableDisableIpAddressControls(hDlg);
                    break;

                default:
                    break;
            }
            break;

        default:
            return FALSE;
    }
    return FALSE;   
}   //lint !e715 we don't reference lParam

//+----------------------------------------------------------------------------
//
// Function:  RefreshDnsList
//
// Synopsis:  This function clears the contents of the listbox specified by
//            hDlg and uCrtlId.  Then it adds each of the items in the DUN
//            entries linked list specified by pHead to the listbox.  The
//            passed in CMS file is used to figure out which entries to special
//            with the default entry and VPN entry text.
//
// Arguments: HINSTANCE hInstance - instance handle for loading resources
//            HWND hDlg - window handle for the DUN entries dialog
//            UINT uCtrlId - control ID of the Listbox to write the entries to
//            ListBxList * pHead - head of the linked list of DUN entries
//            LPCTSTR pszLongServiceName - long service name of the profile
//            LPCTSTR pszCmsFile - CMS file to get the DUN and TunnelDUN entries from
//            LPTSTR pszItemToSelect - Item in the list to select after the refresh, 
//                                     NULL chooses the first in the list
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void RefreshDnsList(HINSTANCE hInstance, HWND hDlg, UINT uCtrlId, ListBxList * pHead,
                    LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile, LPTSTR pszItemToSelect)
{
    if (hDlg && pHead)
    {    
        TCHAR szTunnelSettingName[MAX_PATH+1] = TEXT("");
        TCHAR szDefaultSettingName[MAX_PATH+1] = TEXT("");

        //
        //  Get the name of the Tunnel Dun setting
        //
        MYVERIFY(0 != GetTunnelDunSettingName(pszCmsFile, pszLongServiceName, szTunnelSettingName, CELEMS(szTunnelSettingName)));

        //
        //  Get the name of the default Dun setting
        //
        MYVERIFY(0 != GetDefaultDunSettingName(pszCmsFile, pszLongServiceName, szDefaultSettingName, CELEMS(szDefaultSettingName)));

        //
        //  Reset the listbox contents
        //
        SendDlgItemMessage(hDlg, uCtrlId, LB_RESETCONTENT, 0, (LPARAM)0); //lint !e534 LB_RESETCONTENT doesn't return anything
        
        //
        //  Now loop through the Network settings, adding them to the listbox
        //
        ListBxList * pCurrent = pHead;
        LPTSTR pszDisplayString;
        BOOL bFreeString;
        BOOL bAddDefaultFmtStr = TRUE;
    
        while(pCurrent)
        {
            if ((0 == lstrcmpi(szTunnelSettingName, pCurrent->szName)) && bAddDefaultFmtStr)
            {
                pszDisplayString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, pCurrent->szName);
                MYDBGASSERT(pszDisplayString);
                bFreeString = TRUE;
                bAddDefaultFmtStr = FALSE;
            }
            else if ((0 == lstrcmpi(szDefaultSettingName, pCurrent->szName)) && bAddDefaultFmtStr)
            {
                pszDisplayString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, pCurrent->szName);
                MYDBGASSERT(pszDisplayString);
                bFreeString = TRUE;
                bAddDefaultFmtStr = FALSE;
            }
            else
            {
                pszDisplayString = pCurrent->szName;
                bFreeString = FALSE;
            }

            if (pszDisplayString)
            {
                MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg, uCtrlId, LB_ADDSTRING, 0, (LPARAM)pszDisplayString));

                if (bFreeString)
                {
                    CmFree(pszDisplayString);
                }
            }

            pCurrent = pCurrent->next;
        }

        //
        //  Now Select the requested item in the list.  If the requested name is NULL, just select the
        //  first item in the list.
        //
        LRESULT lResult = 0;

        if (pszItemToSelect)
        {
            LPTSTR pszSearchString;

            if (0 == lstrcmpi(szTunnelSettingName, pszItemToSelect))
            {
                pszSearchString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, pszItemToSelect);
            }
            else if (0 == lstrcmpi(szDefaultSettingName, pszItemToSelect))
            {
                pszSearchString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, pszItemToSelect);
            }
            else
            {
                pszSearchString = CmStrCpyAlloc(pszItemToSelect);
            }

            if (pszSearchString)
            {
                lResult = SendDlgItemMessage(hDlg, uCtrlId, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pszSearchString);

                if (LB_ERR == lResult)
                {
                    lResult = 0;
                }

                CmFree(pszSearchString);
            }
        }
        
        SendDlgItemMessage(hDlg, uCtrlId, LB_SETCURSEL, (WPARAM)lResult, (LPARAM)0); // don't assert we may not have any items
        EnableDisableDunEntryButtons(hInstance, hDlg, pszCmsFile, pszLongServiceName);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  SelectAppropriateEAP
//
// Synopsis:  This functions walks through the list of EAPData structures held
//            by the item data pointers of the EAP names in the combobox specified
//            by hDlg and uCtrlId.  For each EAPData structure it compares
//            the dwCustomAuthKey field with that of the pDunSetting->dwCustomAuthKey.
//            When it finds a match it selects that item in the list.  Note there
//            is a special case for pDunSetting->dwCustomAuthKey == 0, in that
//            since the dun setting doesn't specify and EAP we pick the first
//            one in the list.  If the EAP specified in pDunSetting isn't found
//            then nothing is selected.  However, this should never happen because
//            if the profile specifies an EAP type not found on the machine it will
//            add a special entry for it.
//
// Arguments: HWND hDlg - window handle of the win2k security dialog
//            UINT uCtrlId - control ID of the combo containing the EAP types
//            CDunSetting* pDunSetting - dun setting for which to locate the EAP
//                                       for, contains the dwCustomAuthKey to try
//                                       to match.
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void SelectAppropriateEAP(HWND hDlg, UINT uCtrlId, CDunSetting* pDunSetting)
{
    MYDBGASSERT(hDlg && uCtrlId && pDunSetting);

    if (hDlg && uCtrlId && pDunSetting)
    {
        WPARAM wpIndex = 0;
        INT_PTR nResult;
        BOOL bEapSelected = FALSE;

        if (0 == pDunSetting->dwCustomAuthKey)
        {
            //
            //  Select the first EAP in the list
            //
            SendDlgItemMessage(hDlg, uCtrlId, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);
        }
        else
        {
            do
            {
                nResult = SendDlgItemMessage(hDlg, uCtrlId, CB_GETITEMDATA, wpIndex, (LPARAM)0);

                if (CB_ERR != nResult)
                {
                    EAPData* pEapData = (EAPData*)nResult;

                    if (pEapData && (pEapData->dwCustomAuthKey == pDunSetting->dwCustomAuthKey))
                    {
                        SendDlgItemMessage(hDlg, uCtrlId, CB_SETCURSEL, wpIndex, (LPARAM)0);
                        bEapSelected = TRUE;
                        break;
                    }

                    wpIndex++;
                }

            } while (CB_ERR != nResult);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  FreeEapData
//
// Synopsis:  This functions walks through the list of EAPData structures held
//            by the item data pointers of the EAP names in the combobox specified
//            by hDlg and uCtrlId.  For each EAPData structure it releases the
//            memory held by the EAPData structure, including the pszFriendlyName,
//            the config dll path, and any custom auth data blobs that exist.
//
// Arguments: HWND hDlg - window handle of the win2k security dialog
//            UINT uCtrlId - control ID of the combo containing the EAP types
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void FreeEapData(HWND hDlg, UINT uCtrlId)
{
    MYDBGASSERT(hDlg && uCtrlId);

    if (hDlg && uCtrlId)
    {
        WPARAM wpIndex = 0;
        INT_PTR nResult;
        EAPData* pEapData;
    
        do
        {
            nResult = SendDlgItemMessage(hDlg, uCtrlId, CB_GETITEMDATA, wpIndex, (LPARAM)0);

            if (CB_ERR != nResult)
            {
                pEapData = (EAPData*)nResult;

                if (pEapData)
                {
                    CmFree(pEapData->pszFriendlyName);
                    CmFree(pEapData->pszConfigDllPath);
                    CmFree(pEapData->pCustomAuthData);
                    CmFree(pEapData);
                }

                wpIndex++;
            }

        } while (CB_ERR != nResult);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  HrQueryRegStringWithAlloc
//
// Synopsis:  This functions retrieves the string value specified by hKey and
//            pszValueName.  Note that the function queries the value to find
//            out how much memory is needed to retrieve the data and then
//            allocates the correct amount and retrieves the data itself.  The
//            returned buffer must be freed by the caller.
//
// Arguments: HKEY hKey - open handle to the regkey to get the value from
//            LPCTSTR pszValueName - name of the value to retrieve data for
//            TCHAR** ppszReturnString - pointer to hold the allocated string
//                                       data retrieved from the registry value.
//
// Returns:   HRESULT - standard COM style return codes
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
HRESULT HrQueryRegStringWithAlloc(HKEY hKey, LPCTSTR pszValueName, TCHAR** ppszReturnString)
{
    if ((NULL == hKey) || (NULL == pszValueName) || (NULL == ppszReturnString) || (TEXT('\0') == pszValueName[0]))
    {
        CMASSERTMSG(FALSE, TEXT("HrQueryRegStringWithAlloc -- invalid parameter"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    DWORD dwType;
    DWORD dwSize = 2;
    TCHAR szTwo[2];
    LPTSTR pszTemp = NULL;

    LONG lReturn = RegQueryValueEx(hKey, pszValueName, NULL, &dwType, (LPBYTE)szTwo, &dwSize);

    if (ERROR_MORE_DATA == lReturn)
    {
        *ppszReturnString = (LPTSTR)CmMalloc(dwSize);

        if (*ppszReturnString)
        {
            lReturn = RegQueryValueEx(hKey, pszValueName, NULL, &dwType, (LPBYTE)*ppszReturnString, &dwSize);

            hr = HRESULT_FROM_WIN32(lReturn);

            if (SUCCEEDED(hr))
            {
                if (REG_EXPAND_SZ == dwType)
                {
                    DWORD dwExpandedSize = sizeof(TCHAR)*(ExpandEnvironmentStrings(*ppszReturnString, NULL, 0));

                    if (dwExpandedSize && (dwSize != dwExpandedSize))
                    {
                        pszTemp = *ppszReturnString;
                        *ppszReturnString = (LPTSTR)CmMalloc(dwExpandedSize);

                        if (*ppszReturnString)
                        {
                            ExpandEnvironmentStrings(pszTemp, *ppszReturnString, dwExpandedSize);
                        }
                        else
                        {
                            CMASSERTMSG(FALSE, TEXT("HrQueryRegStringWithAlloc -- CmMalloc returned a NULL pointer."));
                            hr = E_OUTOFMEMORY;
                        }

                        CmFree(pszTemp);
                    }
                }
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("HrQueryRegStringWithAlloc -- CmMalloc returned a NULL pointer."));
            hr = E_OUTOFMEMORY;        
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  ComboBox_GetPsz
//
// Synopsis:  This function automatically allocates and returns the string with
//            the given index from the given combobox.  Happily stolen from Rasdlg.
//
// Arguments: HWND hDlg - window handle to the combobox
//
// Returns:   Nothing
//
// History:   quintinb Created header     04/02/2002
//
//+----------------------------------------------------------------------------
TCHAR* ComboBox_GetPsz(IN HWND hwnd, IN INT  nIndex)

    //
    // Returns heap block containing the text contents of the 'nIndex'th item
    // of combo box 'hwnd' or NULL.  It is caller's responsibility to Free the
    // returned string.
    //
{
    INT    cch;
    TCHAR* psz;

    cch = ComboBox_GetLBTextLen( hwnd, nIndex );
    if (cch < 0)
    {
        return NULL;
    }

    psz = (TCHAR*)CmMalloc( (cch + 1) * sizeof(TCHAR) );

    if (psz)
    {
        *psz = TEXT('\0');
        ComboBox_GetLBText( hwnd, nIndex, psz );
    }

    return psz;
}

//+----------------------------------------------------------------------------
//
// Function:  ComboBox_AutoSizeDroppedWidth
//
// Synopsis:  This function automatically sizes the combobox dropdown based on
//            the strings already in the combobox.  Happily stolen from Rasdlg.
//
// Arguments: HWND hDlg - window handle to the combobox
//
// Returns:   Nothing
//
// History:   quintinb Created header     04/02/2002
//
//+----------------------------------------------------------------------------
VOID ComboBox_AutoSizeDroppedWidth(IN HWND hwndLb)

    // Set the width of the drop-down list 'hwndLb' to the width of the
    // longest item (or the width of the list box if that's wider).
    //
{
    HDC    hdc;
    HFONT  hfont;
    TCHAR* psz;
    SIZE   size;
    DWORD  cch;
    DWORD  dxNew;
    DWORD  i;

    hfont = (HFONT )SendMessage(hwndLb, WM_GETFONT, 0, 0);

    if (!hfont)
    {
        return;
    }

    hdc = GetDC(hwndLb);
    if (!hdc)
    {
        return;
    }

    SelectObject(hdc, hfont);

    dxNew = 0;
    for (i = 0; psz = ComboBox_GetPsz(hwndLb, i); ++i)
    {
        cch = lstrlen( psz );
        if (GetTextExtentPoint32(hdc, psz, cch, &size))
        {
            if (dxNew < (DWORD )size.cx)
                dxNew = (DWORD )size.cx;
        }

        CmFree(psz);
    }

    ReleaseDC(hwndLb, hdc);

    //
    // Allow for the spacing on left and right added by the control.
    //
    dxNew += 6;

    // Figure out if the vertical scrollbar will be displayed and, if so,
    // allow for it's width.
    //
    RECT  rectD;
    RECT  rectU;
    DWORD dyItem;
    DWORD cItemsInDrop;
    DWORD cItemsInList;

    GetWindowRect(hwndLb, &rectU);
    SendMessage(hwndLb, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM )&rectD);
    dyItem = (DWORD)SendMessage(hwndLb, CB_GETITEMHEIGHT, 0, 0);
    cItemsInDrop = (rectD.bottom - rectU.bottom) / dyItem;
    cItemsInList = ComboBox_GetCount(hwndLb);
    if (cItemsInDrop < cItemsInList)
    {
        dxNew += GetSystemMetrics(SM_CXVSCROLL);
    }

    SendMessage(hwndLb, CB_SETDROPPEDWIDTH, dxNew, 0);
}


//+----------------------------------------------------------------------------
//
// Function:  ShowEapToUser
//
// Synopsis:  This function examines the roles value of the given registry key
//            represented by the passed in registry handle and decides whether
//            the role tells us to show it to the user or not.
//
// Arguments: HKEY hKeyPackage - handle to the reg key of the EAP package
//
// Returns:   BOOL - TRUE shows it to the user, FALSE skips the package
//
// History:   quintinb Created     11/12/02
//
//+----------------------------------------------------------------------------
BOOL ShowEapToUser(HKEY hKeyPackage)
{
    DWORD dwRolesSupported = 0;
    DWORD dwSize = sizeof(dwRolesSupported);
    DWORD dwType = REG_DWORD;
                         
    DWORD dwReturn = RegQueryValueEx(hKeyPackage, RAS_EAP_VALUENAME_ROLES_SUPPORTED, NULL, 
                                     &dwType, (LPBYTE)(&dwRolesSupported), &dwSize);

    //
    //  If we couldn't access the key, assume it is okay to show it to the user.  This
    //  will generally mean the key didn't exist... (which is okay it supports all roles). 
    //
    if (ERROR_SUCCESS == dwReturn)
    {
        //
        // This value is a set of flags that tell what roles the EAP
        // supports.  Whether the EAP can be used in server (authenticator) or client
        // (authenticatee) and whether it is supported for RAS connections (VPN) or
        // in PEAP.  For our purposes, we only want to show EAP's that can be used by the
        // client for EAP and VPN.  If the EAP supports all of that show it, otherwise don't.
        //
        if (0 != dwRolesSupported)
        {    
            if (!(RAS_EAP_ROLE_AUTHENTICATEE & dwRolesSupported))
            {
                return FALSE;
            }

            if (RAS_EAP_ROLE_EXCLUDE_IN_EAP & dwRolesSupported)
            {
                return FALSE;
            }
      
            if (RAS_EAP_ROLE_EXCLUDE_IN_VPN & dwRolesSupported)
            {
                return FALSE;
            }
        }
   }

   return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  HrAddAvailableEAPsToCombo
//
// Synopsis:  This functions enumerates the EAP types listed in the registry
//            and adds them to the EAP types combo.  For each type of EAP the
//            dwCustomAuthKey (numerical type of the EAP), the description string,
//            the configuration UI dll path, and whether configuration is
//            required is recorded in an EAPData structure and stored in the
//            item data pointer of the combobox item.  The passed in CDunSetting
//            structure is used for two purposes.  First this function checks to
//            make sure that the EAP of the type that is specified in the
//            CDunSetting structure is actually installed on the machine.  If it
//            isn't the user is presented with a warning message and the type is
//            added as "EAP Type %d <not installed>".  This is a choice in the UI
//            but the user is unable to configure it unless they install the EAP.
//            Also, if the EAP of the type specified in the CDunSetting is installed
//            then the dwCustomAuthData and dwCustomAuthDataSize elements of the
//            CDunSetting are copied over.  Thus maintains the simplicity of letting
//            the user configure any EAP they wish and then only picking up that
//            data in the DUN setting when they hit okay.  Thus allowing Cancel
//            to work as one would expect.
//
// Arguments: HWND hDlg - window handle to the win2k security dialog
//            UINT uCtrlId - EAP types combo box ID
//            CDunSetting* pDunSetting - DUN setting data that we are currently
//                                       adding/editing
//
// Returns:   HRESULT - standard COM style return codes
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
HRESULT HrAddAvailableEAPsToCombo(HWND hDlg, UINT uCtrlId, CDunSetting* pDunSetting)
{
    if ((NULL == hDlg) || (0 == uCtrlId) || (NULL == pDunSetting))
    {
        CMASSERTMSG(FALSE, TEXT("HrAddAvailableEAPsToCombo -- Invalid parameter passed."));
        return E_INVALIDARG;
    }

    HKEY hKey = NULL;
    HRESULT hr = S_OK;
    LONG lReturn;
    LPTSTR pszPath;
    BOOL bEapTypeFound = FALSE;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, RAS_EAP_REGISTRY_LOCATION, 0, KEY_READ, &hKey))
    {
        //
        // Now begin enumerating the EAPs
        // 
        TCHAR szSubKeyName[MAX_PATH+1]; // the key names are numbers representing the type of EAP, thus MAX_PATH is probably overkill
        DWORD dwIndex = 0;
        HKEY hTempKey = NULL;

        do
        {
            lReturn = RegEnumKey(hKey, dwIndex, szSubKeyName, CELEMS(szSubKeyName));

            if (ERROR_SUCCESS == lReturn)
            {
                //
                //  We potentially have an EAP reg key.  Thus lets open a handle to this
                //  key and see if it has the values we are looking for.
                //
                if (ERROR_SUCCESS == RegOpenKeyEx(hKey, szSubKeyName, 0, KEY_READ, &hTempKey))
                {
                    //
                    //  Check to see if we need to filter out PEAP and EAP-MsChapV2.  That means checking the
                    //  checking the roles value of each EAP package.
                   //
                    if (FALSE == ShowEapToUser(hTempKey))
                    {
                        RegCloseKey(hTempKey);
                        dwIndex++; // bump the index
                        continue;     
                    }

                    //
                    //  Get the path value, if we don't have a path value then just ignore the entry and move on
                    //
                    hr = HrQueryRegStringWithAlloc(hTempKey, RAS_EAP_VALUENAME_PATH, &pszPath);

                    if (SUCCEEDED(hr))
                    {
                        //
                        //  Free the path, we don't really need to keep this value.
                        //
                        CmFree(pszPath);
                        EAPData* pEapData = (EAPData*)CmMalloc(sizeof(EAPData));

                        if (pEapData)
                        {
                            //
                            //  Now get the Friendly name of the EAP to add to the combobox
                            //
                            HrQueryRegStringWithAlloc(hTempKey, RAS_EAP_VALUENAME_FRIENDLY_NAME, &(pEapData->pszFriendlyName));
                        
                            //
                            //  Next check to see if we have configuration UI for this EAP, thus requiring we store the 
                            //
                            HrQueryRegStringWithAlloc(hTempKey, RAS_EAP_VALUENAME_CONFIGUI, &(pEapData->pszConfigDllPath));
                           
                            //
                            //  We also need to save the type value
                            //
                            pEapData->dwCustomAuthKey = _ttoi(szSubKeyName);

                            //
                            //  If the pDunSetting has pCustomAuthData and it is the same type as the current EAP we are
                            //  processing then we need to add the copy the EAP blob to the EAPData structure.
                            //
                            if (pDunSetting->dwCustomAuthKey == pEapData->dwCustomAuthKey)
                            {
                                if (pDunSetting->pCustomAuthData && pDunSetting->dwCustomAuthDataSize)
                                {
                                     pEapData->pCustomAuthData = (LPBYTE)CmMalloc(pDunSetting->dwCustomAuthDataSize);
                                     if (pEapData->pCustomAuthData)
                                     {
                                         pEapData->dwCustomAuthDataSize = pDunSetting->dwCustomAuthDataSize;
                                         CopyMemory(pEapData->pCustomAuthData, pDunSetting->pCustomAuthData, pEapData->dwCustomAuthDataSize);
                                     }
                                }
                                
                                bEapTypeFound = TRUE;
                            }

                            //
                            //  Get whether we must require configuration or not
                            //
                            DWORD dwSize = sizeof(pEapData->bMustConfig);
                            DWORD dwType = REG_DWORD;
                            
                            if (ERROR_SUCCESS != RegQueryValueEx(hTempKey, RAS_EAP_VALUENAME_REQUIRE_CONFIGUI, NULL, &dwType, (LPBYTE)&(pEapData->bMustConfig), &dwSize))
                            {
                                pEapData->bMustConfig = FALSE;
                            }

                            dwSize = sizeof(pEapData->bSupportsEncryption);
                            
                            if (ERROR_SUCCESS != RegQueryValueEx(hTempKey, RAS_EAP_VALUENAME_ENCRYPTION, NULL, &dwType, (LPBYTE)&(pEapData->bSupportsEncryption), &dwSize))
                            {
                                pEapData->bSupportsEncryption = FALSE;
                            }

                            //
                            //  Finally add the EAP to the combobox
                            //
                            LPTSTR pszDisplayString = NULL;
                            TCHAR szDisplayString[MAX_PATH+1];

                            if (pEapData->bSupportsEncryption)
                            {
                                LPTSTR pszSuffix = CmLoadString(g_hInstance, IDS_SUPPORTS_ENCRYPT);

                                if (pszSuffix)
                                {
                                    wsprintf(szDisplayString, TEXT("%s %s"), pEapData->pszFriendlyName, pszSuffix);
                                    pszDisplayString = szDisplayString;
                                    CmFree(pszSuffix);
                                }
                            }

                            if (NULL == pszDisplayString)
                            {
                                pszDisplayString = pEapData->pszFriendlyName;
                            }

                            INT_PTR nResult = SendDlgItemMessage(hDlg, uCtrlId, CB_ADDSTRING, (WPARAM)0, (LPARAM)pszDisplayString);
                            if (CB_ERR != nResult)
                            {
                                SendDlgItemMessage(hDlg, uCtrlId, CB_SETITEMDATA, (WPARAM)nResult, (LPARAM)pEapData);
                            }
                            else
                            {
                                CMASSERTMSG(FALSE, TEXT("HrAddAvailableEAPsToCombo -- unable to set item data."));
                                hr = HRESULT_FROM_WIN32(GetLastError());
                            }
                        }
                        else
                        {
                            CMASSERTMSG(FALSE, TEXT("HrAddAvailableEAPsToCombo -- CmMalloc returned a NULL pointer."));
                            hr = E_OUTOFMEMORY;                        
                        }
                    }
                    else
                    {
                        CMTRACE2(TEXT("HrAddAvailableEAPsToCombo -- Unable to find Path value for EAP regkey %s, hr %d"), szSubKeyName, hr);
                    }
                }
                else
                {
                    CMTRACE2(TEXT("HrAddAvailableEAPsToCombo -- Unable to Open EAP regkey %s, GLE %d"), szSubKeyName, GetLastError());
                }
            }

            dwIndex++;
            
        } while (ERROR_SUCCESS == lReturn);

        if (hTempKey)
        {
            (VOID)RegCloseKey(hTempKey);
            hTempKey = NULL;
        }

        //
        //  Auto size the combo box drop down
        //
        HWND hCombo = GetDlgItem(hDlg, uCtrlId);
        if (hCombo)
        {
            ComboBox_AutoSizeDroppedWidth(hCombo);
        }

        //
        //  If the Dun setting contains an EAP that isn't on the system
        //  we need to prompt the user.
        //
        if (pDunSetting->dwCustomAuthKey && (FALSE == bEapTypeFound))
        {
            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_EAP_NOT_FOUND, MB_OK | MB_ICONINFORMATION));

            EAPData* pEapData = (EAPData*)CmMalloc(sizeof(EAPData));
            if (pEapData)
            {
                pEapData->pszFriendlyName = CmFmtMsg(g_hInstance, IDS_EAP_NOT_FOUND_TYPE, pDunSetting->dwCustomAuthKey);
                pEapData->dwCustomAuthKey = pDunSetting->dwCustomAuthKey;
                pEapData->bNotInstalled = TRUE;
                
                INT_PTR nResult = SendDlgItemMessage(hDlg, uCtrlId, CB_ADDSTRING, (WPARAM)0, (LPARAM)(pEapData->pszFriendlyName));
                
                if (CB_ERR != nResult)
                {
                    SendDlgItemMessage(hDlg, uCtrlId, CB_SETITEMDATA, (WPARAM)nResult, (LPARAM)pEapData);
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("HrAddAvailableEAPsToCombo -- CmMalloc returned a NULL pointer."));
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (hKey)
    {
        (VOID)RegCloseKey(hKey);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  FreeDnsList
//
// Synopsis:  Since the ListBxData in the list box items of the DNS
//            list are actually CDunSetting class pointers we must
//            properly cast the pointer so that they are destructed
//            corretly.
//
// Arguments: ListBxList ** HeadPtr - head of the DUN setting list
//
// Returns:   nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void FreeDnsList(ListBxList ** pHeadPtr, ListBxList ** pTailPtr)
{
    CDunSetting* pDunSetting;
    ListBxList* pCurrent = *pHeadPtr;
    ListBxList* pTemp;

    while (NULL != pCurrent)
    {
        pTemp = pCurrent;

        //
        //  Free the DunSetting
        //
        pDunSetting = (CDunSetting*)pCurrent->ListBxData;
        delete pDunSetting;

        pCurrent = pCurrent->next;

        CmFree(pTemp);
    }

    *pHeadPtr = NULL;
    *pTailPtr = NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  EnableDisableDunEntryButtons
//
// Synopsis:  This function enables or disables the Add and Edit buttons on
//            the Dun entries screen.  It also enables or disables the delete
//            button depending on whether the current selection is a built in
//            entry or not.
//
// Arguments: HINSTANCE hInstance - instance handle to load resources with
//            HWND hDlg - window handle to the dun entries dialog
//            LPCTSTR pszCmsFile - full path to the cms file
//            LPCTSTR pszLongServiceName - long service name of the profile
//
// Returns:   Nothing
//
// History:   quintinb Created    9/11/98
//
//+----------------------------------------------------------------------------
void EnableDisableDunEntryButtons(HINSTANCE hInstance, HWND hDlg, LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName)
{
    
    LRESULT lResult;
    BOOL bEnableEdit = FALSE;
    BOOL bEnableDelete = FALSE;

    lResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETCOUNT, 0, 0);
    
    if (LB_ERR != lResult)
    {
        if (0 == lResult)
        {
            //
            //  Zero Items, set focus to the Add Button
            //
            SetFocus(GetDlgItem(hDlg, IDC_BUTTON1));            
        }
        else
        {
            //
            //  Enable the Edit Button because we have at least 1 item.
            //
            bEnableEdit = TRUE;

            //
            //  Now lets figure out if the delete button should be enabled or not.
            //  If we have at least one item then we normally want to enable the
            //  delete button.  However, if the current selection is on the VPN
            //  connection or the default connection then we don't want the user to
            //  delete these and we will have to disable the delete button (note that
            //  even if the user hit the delete button on one of these items we wouldn't
            //  delete it).  So, lets get the Cursor selection to see if we need to 
            //  disable the delete button.
            //
            LRESULT lCurrentIndex = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

            if (LB_ERR == lCurrentIndex)
            {
                MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg, IDC_LIST1, LB_SETCURSEL, 0, (LPARAM)0));
                lCurrentIndex = 0;
            }

            TCHAR szTunnelDunName[MAX_PATH+1] = TEXT("");
            TCHAR szDefaultDunName[MAX_PATH+1] = TEXT("");
            //
            //  Get the name of the Tunnel Dun setting
            //
            MYVERIFY(0 != GetTunnelDunSettingName(pszCmsFile, pszLongServiceName, szTunnelDunName, CELEMS(szTunnelDunName)));

            //
            //  Get the name of the default Dun setting
            //
            MYVERIFY(0 != GetDefaultDunSettingName(pszCmsFile, pszLongServiceName, szDefaultDunName, CELEMS(szDefaultDunName)));

            //
            //  If we have the default entry text or the tunnel entry text then we want
            //  to use the real item names for these instead of the text we inserted for
            //  the user to read.
            //
            LPTSTR pszTunnelDunDisplayString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, szTunnelDunName);
            LPTSTR pszDefaultDunDisplayString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, szDefaultDunName);
            LPTSTR pszCurrentSelection = NULL;

            MYDBGASSERT(pszTunnelDunDisplayString && pszDefaultDunDisplayString);

            if (pszTunnelDunDisplayString && pszDefaultDunDisplayString)
            {           
                lResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETTEXTLEN, lCurrentIndex, (LPARAM)0);

                if (LB_ERR != lResult)
                {
                    pszCurrentSelection = (LPTSTR)CmMalloc((lResult + 1) * sizeof(TCHAR));

                    if (pszCurrentSelection)
                    {
                        lResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETTEXT, lCurrentIndex, (LPARAM)pszCurrentSelection);

                        if ((0 != lstrcmpi(pszCurrentSelection, pszTunnelDunDisplayString)) && 
                            (0 != lstrcmpi(pszCurrentSelection, pszDefaultDunDisplayString)))
                        {
                           bEnableDelete = TRUE; 
                        }
                    }
                }

                CmFree(pszTunnelDunDisplayString);
                CmFree(pszDefaultDunDisplayString);
                CmFree(pszCurrentSelection);
            }            
        }
    }

    HWND hDeleteButton = GetDlgItem(hDlg, IDC_BUTTON3);
    HWND hCurrentFocus = GetFocus();
    HWND hControl = GetDlgItem(hDlg, IDC_BUTTON2);   // Edit button == IDC_BUTTON2

    if (hControl)   // Edit
    {
        EnableWindow(hControl, bEnableEdit);
    }            

    if (hDeleteButton)   // Delete
    {
        EnableWindow(hDeleteButton, bEnableDelete);
    }

    if (hCurrentFocus && (FALSE == IsWindowEnabled(hCurrentFocus)))
    {
        if (hDeleteButton == hCurrentFocus)
        {
            //
            //  If delete is disabled and contained the focus, shift it to the Add button
            //
            SendMessage(hDlg, DM_SETDEFID, IDC_BUTTON1, (LPARAM)0L); //lint !e534 DM_SETDEFID doesn't return error info
            hControl = GetDlgItem(hDlg, IDC_BUTTON1);

            if (hControl)
            {
                SetFocus(hControl);
            }
        }
        else
        {
            //
            //  If all else fails set the focus to the list control
            //
            hControl = GetDlgItem(hDlg, IDC_LIST1);

            if (hControl)
            {
                SetFocus(hControl);
            }
        }    
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CheckForDUNversusVPNNameConflicts
//
// Synopsis:  This function checks the names of all of the entries in the DUN
//            entry list to make sure that no entries of the same name exist
//            on the VPN list since the namespace that the two types of entries
//            share (ie the cms file) is a flat namespace.  If an identical entry
//            name exists in both lists then one will overwrite the over in the cms.
//
// Arguments: HWND hDlg - window handle of the parent window
//            ListBxList * pHeadDunEntry - head of the DUN settings list
//            ListBxList * pHeadVpnEntry - head of the VPN settings list
//
// Returns:   BOOL - TRUE if no collision was detected, FALSE if a collision was detected
//
// History:   quintinb Created     11/01/00
//
//+----------------------------------------------------------------------------
BOOL CheckForDUNversusVPNNameConflicts(HWND hDlg, ListBxList * pHeadDunEntry, ListBxList * pHeadVpnEntry)
{
    if (pHeadDunEntry && pHeadVpnEntry)
    {
        ListBxList * pCurrentDUN = pHeadDunEntry;

        while (pCurrentDUN)
        {
            ListBxList * pCurrentVPN = pHeadVpnEntry;
    
            while (pCurrentVPN)
            {
                CMTRACE2(TEXT("Comparing %s with %s"), pCurrentVPN->szName, pCurrentDUN->szName);
                if (0 == lstrcmpi(pCurrentVPN->szName, pCurrentDUN->szName))
                {
                    //
                    //  Collision detected
                    //
                    LPTSTR pszMsg = CmFmtMsg(g_hInstance, IDS_DUN_NAME_CONFLICT, pCurrentDUN->szName);

                    if (pszMsg)
                    {
                        MessageBox(hDlg, pszMsg, g_szAppTitle, MB_OK);
                        CmFree (pszMsg);
                    }

                    return FALSE;
                }
                pCurrentVPN = pCurrentVPN->next;
            }

            pCurrentDUN = pCurrentDUN->next;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\profwiz\image.cpp ===
//+----------------------------------------------------------------------------
//
// File:     image.cpp
//
// Module:   CMAK.EXE
//
// Synopsis: Image support routines for displaying the custom graphics
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball   Created Header      03/30/98
//           quintinb   copied from cmdial  08/04/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

#ifndef UNICODE
#define GetWindowLongU GetWindowLongPtrA
#define SetWindowLongU SetWindowLongPtrA
#define DefWindowProcU DefWindowProcA
#else
#define GetWindowLongU GetWindowLongPtrW
#define SetWindowLongU SetWindowLongPtrW
#define DefWindowProcU DefWindowProcW
#endif

const TCHAR* const c_pszCmakBmpClass = TEXT("Connection Manager Administration Kit Bitmap Window Class");

//
//  Include the shared bitmap handling code.
//
#include "bmpimage.cpp"

//+----------------------------------------------------------------------------
//
// Function:  RegisterBitmapClass
//
// Synopsis:  Helper function to encapsulate registration of our bitmap class
//
// Arguments: HINSTANCE hInst - HINSTANCE to associate registration with
//
// Returns:   DWORD - error code 
//
// History:   nickball    Created Header    2/9/98
//
//+----------------------------------------------------------------------------
DWORD RegisterBitmapClass(HINSTANCE hInst) 
{
    //
    // Register Bitmap class
    //

    WNDCLASS wcClass;

	ZeroMemory(&wcClass,sizeof(wcClass));
	wcClass.lpfnWndProc = BmpWndProc;
	wcClass.cbWndExtra = sizeof(HBITMAP) + sizeof(LPBITMAPINFO);
	wcClass.hInstance = hInst;
    wcClass.lpszClassName = c_pszCmakBmpClass;
	
    if (!RegisterClass(&wcClass)) 
	{
        DWORD dwError = GetLastError();

        CMTRACE1(TEXT("RegisterBitmapClass() RegisterClass() failed, GLE=%u."), dwError);
        //
        // Only fail if the class does not already exist
        //

        if (ERROR_CLASS_ALREADY_EXISTS != dwError)
        {
            return dwError;
        }
	}      

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\profwiz\listview.cpp ===
//+----------------------------------------------------------------------------
//
// File:     listview.cpp
//
// Module:   CMAK.EXE
//
// Synopsis: Implemenation of the helper functions used by CMAK to deal with the
//           custom action list view control.
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created                         02/26/00
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//+----------------------------------------------------------------------------
//
// Function:  UpdateListViewColumnHeadings
//
// Synopsis:  This function sets the column heading text specified by the given
//            column index and list view control window handle to the string
//            resource specified by the given instance handle and string Id.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hListView - window handle of the list view control
//            UINT uStringID - string id of the desired text
//            int iColumnIndex - desired column to update the text of
//
// Returns:   BOOL - TRUE on success, FALSE otherwise
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
BOOL UpdateListViewColumnHeadings(HINSTANCE hInstance, HWND hListView, UINT uStringID, int iColumnIndex)
{
    BOOL bReturn = FALSE;

    MYDBGASSERT(hInstance);
    MYDBGASSERT(hListView);
    MYDBGASSERT(uStringID);

    if (hInstance && hListView && uStringID)
    {
        //
        //  First get the requested string
        //
        LVCOLUMN lvColumn = {0};

        lvColumn.mask = LVCF_TEXT;
        lvColumn.pszText = CmLoadString(hInstance, uStringID);

        MYDBGASSERT(lvColumn.pszText);
        if (lvColumn.pszText)
        {
            bReturn = ListView_SetColumn(hListView, iColumnIndex, &lvColumn);
            CmFree(lvColumn.pszText);
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  AddListViewColumnHeadings
//
// Synopsis:  This function creates the description and type columns
//            used by the default view of the custom action page.  Once this
//            function has been called, UpdateListViewColumnHeadings should
//            be used to change the column headings as necessary.  This function
//            will need to be modified if more columns are deemed necessary.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hListView - window handle of the list view control
//
// Returns:   BOOL - TRUE on success, FALSE otherwise
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
BOOL AddListViewColumnHeadings(HINSTANCE hInstance, HWND hListView)
{
    //
    //  Add the column headings
    //
    LVCOLUMN lvColumn = {0};

    lvColumn.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.pszText = CmLoadString(hInstance, IDS_DESC_COL_TITLE);
    lvColumn.iSubItem = 0;

    MYDBGASSERT(lvColumn.pszText);
    if (lvColumn.pszText)
    {
        ListView_InsertColumn(hListView, 0, &lvColumn);
        CmFree(lvColumn.pszText);
    }
    else
    {
        return FALSE;
    }
    
    lvColumn.pszText = CmLoadString(hInstance, IDS_TYPE_COL_TITLE);
    lvColumn.iSubItem = 1;

    MYDBGASSERT(lvColumn.pszText);
    if (lvColumn.pszText)
    {
        ListView_InsertColumn(hListView, 1, &lvColumn);
        CmFree(lvColumn.pszText);
    }
    else
    {
        return FALSE;
    }

    //
    //  Now lets size the columns so that the text is visible.  Since we
    //  only have two columns of text, lets call GetWindowRect on the
    //  list view control and then set the column widths to each take
    //  up about half of the space available.
    //
    RECT Rect = {0};
    LONG lColumnWidth;

    if (GetWindowRect(hListView, &Rect))
    {
        //
        //  Subtract 5 from each to keep a scroll bar from appearing
        //
        lColumnWidth = (Rect.right - Rect.left)/2 - 5;

        if (0 < lColumnWidth)
        {
            for (int i=0; i < 2; i++)
            {
                MYVERIFY(ListView_SetColumnWidth(hListView, i, lColumnWidth));
            }
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  MapComboSelectionToType
//
// Synopsis:  This function gets the current selection from the given
//            combobox and maps the index to a custom action type.
//
// Arguments: HWND hDlg - window handle to the dialog that contains the combobox
//            UINT uCtrlID - control id of the combobox
//            BOOL bIncludesAll - when TRUE
//            BOOL bUseTunneling - whether this is a tunneling profile or not
//            CustomActionTypes* pType
//
// Returns:   HRESULT - Standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT MapComboSelectionToType(HWND hDlg, UINT uCtrlID, BOOL bIncludesAll, BOOL bUseTunneling, CustomActionTypes* pType)
{
    //
    //  Check Params
    //
    if ((NULL == hDlg) || (0 == uCtrlID) || (NULL == pType))
    {
        CMASSERTMSG(FALSE, TEXT("MapComboSelectionToType -- invalid parameter passed"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    INT_PTR nResult = SendDlgItemMessage(hDlg, uCtrlID, CB_GETCURSEL, 0, (LPARAM)0);

    if (nResult != LB_ERR)
    {
        //
        //  If the combobox contains the All choice, we need to correct
        //  the type depending on what the user chose.
        //

        if (bIncludesAll)
        {
            if (0 == nResult)
            {
                *pType = ALL;
                goto exit;
            }
            else
            {
                nResult--;
            }                    
        }

        //
        //  We need to make a correction if we aren't Tunneling because the 
        //  tunneling type won't be in the combobox
        //
        if (FALSE == bUseTunneling)
        {
            if (PRETUNNEL <= (CustomActionTypes)nResult)
            {
                nResult++;            
            }
        }

        *pType = (CustomActionTypes)nResult;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

exit:
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  GetItemTypeByListViewIndex
//
// Synopsis:  This function gets the current selection index of the list view
//            control and gets the type string.  The type string is then
//            converted into a numeric type and returned via the pType
//            pointer.
//
// Arguments: HINSTANCE hInstance - instance handle for string resources
//            HWND hListView - window handle of the list view control
//            CustomActionTypes* pType - pointer to hold the type of the item
//
// Returns:   HRESULT - Standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT GetItemTypeByListViewIndex(HINSTANCE hInstance, HWND hListView, CustomActionTypes* pType, int *piIndex)
{
    //
    //  Check params
    //
    if ((NULL == hListView) || (NULL == pType) || (NULL == g_pCustomActionList))
    {
        CMASSERTMSG(FALSE, TEXT("GetItemTypeByListViewIndex -- invalid parameter passed"));
        return E_INVALIDARG;
    }

    //
    //  The user has the All view selected, further work is needed to select the
    //  appropriate type.
    //
    HRESULT hr = S_OK;

    if (-1 == *piIndex)
    {
        *piIndex = ListView_GetSelectionMark(hListView);
    }

    int iTemp = *piIndex;

    if (-1 != iTemp)
    {
        LVITEM lvItem = {0};
        TCHAR szTemp[MAX_PATH+1];

        szTemp[0] = TEXT('\0');

        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = szTemp;
        lvItem.cchTextMax = MAX_PATH;
        lvItem.iItem = iTemp;
        lvItem.iSubItem = 1;

        if (ListView_GetItem(hListView,  &lvItem))
        {
            hr = g_pCustomActionList->GetTypeFromTypeString(hInstance, lvItem.pszText, pType);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);    
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  GetDescriptionAndTypeOfItem
//
// Synopsis:  This function gets the type and description of the item specified
//            by the passed in item index.  If the caller passes -1 for this index,
//            the currently selected item is used and the actual index is passed
//            back via this in/out pointer.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            HWND hListView - window handle to the list view control
//            UINT uComboBoxId - combo box id containing the type info
//            CustomActionListItem* pItem - pointer to a custom action struct to
//                                          hold the returned type and description
//            int* piItemIndex - index of the item to get the description and
//                               type of.  If -1, then the current selection mark
//                               is used and the actual index is returned in *piItemIndex
//            BOOL bUseTunneling - whether this profile uses tunneling or not
//
// Returns:   HRESULT - Standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT GetDescriptionAndTypeOfItem(HINSTANCE hInstance, HWND hDlg, HWND hListView, UINT uComboBoxId, 
                                    CustomActionListItem* pItem, int* piItemIndex, BOOL bUseTunneling)
{
    //
    //  Check Params
    //
    if (NULL == hDlg || NULL == hListView || 0 == uComboBoxId || NULL == pItem || NULL == piItemIndex)
    {
        CMASSERTMSG(FALSE, TEXT("GetDescriptionAndTypeOfSelection -- Invalid parameter passed."));
        return E_INVALIDARG;
    }

    HRESULT hr = E_UNEXPECTED;

    //
    //  If the user passed us a -1 in *piItemIndex then they want the Description and Type of the
    //  selected item.  Otherwise, they gave us a specific item index that they want data on.
    //
    int iTemp;

    if (-1 == *piItemIndex)
    {
        iTemp = ListView_GetSelectionMark(hListView);    
    }
    else
    {
        iTemp = ListView_GetItemCount(hListView);

        if ((0 > *piItemIndex) || (iTemp <= *piItemIndex))
        {
            iTemp = -1;
        }
        else
        {
            iTemp = *piItemIndex;
        }
    }

    if (-1 != iTemp)
    {
        //
        //  Figure out the type of the item
        //
        ZeroMemory(pItem, sizeof(CustomActionListItem));

        hr = MapComboSelectionToType(hDlg, uComboBoxId, TRUE, bUseTunneling, &(pItem->Type)); //bIncludesAll == TRUE

        if (SUCCEEDED(hr))
        {
            if (ALL == pItem->Type)
            {
                hr = GetItemTypeByListViewIndex(hInstance, hListView, &(pItem->Type), &iTemp);
            }
        }

        //
        //  Now Figure out the description of the item
        //
        if (SUCCEEDED(hr))
        {
            ListView_GetItemText(hListView, iTemp, 0, pItem->szDescription, CELEMS(pItem->szDescription));
        }

        *piItemIndex = iTemp;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  RefreshEditDeleteMoveButtonStates
//
// Synopsis:  This function sets the enabled/disabled state of the Edit, Delete,
//            Move up and Move Down buttons based on the custom action specified by
//            the list view index passed in through the piIndex param.  If this
//            parameter is -1 then the currently selected item is used and
//            the actual index is returned through the int pointer.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            HWND hListView - window handle to the list view control
//            UINT uComboBoxId - combo box id containing the type info
//            int* piIndex - index of the list view item to base the move up
//                           and move down button state on.  Again -1 will use
//                           the currently selected item.
//            BOOl bUseTunneling - whether this profile uses tunneling or not
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
void RefreshEditDeleteMoveButtonStates(HINSTANCE hInstance, HWND hDlg, HWND hListView, UINT uComboCtrlId, int* piIndex, BOOL bUseTunneling)
{
    if ((NULL == hInstance) || (NULL == hDlg) || (NULL == hListView) || 
        (0 == uComboCtrlId) || (NULL == piIndex) || (NULL == g_pCustomActionList))
    {
        CMASSERTMSG(FALSE, TEXT("RefreshEditDeleteMoveButtonStates -- invalid parameter passed."));
        return;
    }

    int iDisableMoveUp = -1;    // -1 is the true value for GetListPositionAndBuiltInState
    int iDisableMoveDown = -1;
    int iDisableDeleteAndEdit = -1;
    CustomActionListItem Item;

    if (ListView_GetItemCount(hListView))
    {
        //
        //  Get the description and type of the item *piIndex (if -1 then the currently selected item)
        //
        //

        ZeroMemory(&Item, sizeof(Item));
        HRESULT hr = GetDescriptionAndTypeOfItem(hInstance, hDlg, hListView, uComboCtrlId, &Item, piIndex, bUseTunneling);

        if (SUCCEEDED(hr))
        {
            hr = g_pCustomActionList->GetListPositionAndBuiltInState(hInstance, &Item, &iDisableMoveUp, &iDisableMoveDown, &iDisableDeleteAndEdit);
            MYDBGASSERT(SUCCEEDED(hr));
        }
    }

    HWND hCurrentFocus = GetFocus();
    HWND hEditButton = GetDlgItem(hDlg, IDC_BUTTON2);
    HWND hDeleteButton = GetDlgItem(hDlg, IDC_BUTTON3);
    HWND hMoveUpButton = GetDlgItem(hDlg, IDC_BUTTON4);
    HWND hMoveDownButton = GetDlgItem(hDlg, IDC_BUTTON5);

    if (hEditButton)
    {
        EnableWindow(hEditButton, (iDisableDeleteAndEdit ? 0 : 1));
    }            

    if (hDeleteButton)
    {
        EnableWindow(hDeleteButton, (iDisableDeleteAndEdit ? 0 : 1));
    }

    if (hMoveUpButton)
    {
        EnableWindow(hMoveUpButton, (iDisableMoveUp ? 0 : 1));
    }            

    if (hMoveDownButton)
    {
        EnableWindow(hMoveDownButton, (iDisableMoveDown ? 0 : 1));
    }

    
    if (hCurrentFocus && (FALSE == IsWindowEnabled(hCurrentFocus)))
    {
        if (hDeleteButton == hCurrentFocus)
        {
            //
            //  If delete is disabled and contained the focus, shift it to the Add button
            //
            SendMessage(hDlg, DM_SETDEFID, IDC_BUTTON1, (LPARAM)0L); //lint !e534 DM_SETDEFID doesn't return error info
            HWND hControl = GetDlgItem(hDlg, IDC_BUTTON1);

            if (hControl)
            {
                SetFocus(hControl);
            }
        }
        else if ((hMoveUpButton == hCurrentFocus) && IsWindowEnabled(hMoveDownButton))
        {
            SendMessage(hDlg, DM_SETDEFID, IDC_BUTTON5, (LPARAM)0L); //lint !e534 DM_SETDEFID doesn't return error info
            SetFocus(hMoveDownButton);
        }
        else if ((hMoveDownButton == hCurrentFocus) && IsWindowEnabled(hMoveUpButton))
        {
            SendMessage(hDlg, DM_SETDEFID, IDC_BUTTON4, (LPARAM)0L); //lint !e534 DM_SETDEFID doesn't return error info
            SetFocus(hMoveUpButton);                
        }
        else
        {
            //
            //  If all else fails set the focus to the listview control
            //
            SetFocus(hListView);
        }    
    }
}

//+----------------------------------------------------------------------------
//
// Function:  SelectListViewItem
//
// Synopsis:  This function trys to select a list view item with the given
//            type and description in the given listview control.  If the listview
//            doesn't contain the item we are looking for it returns FALSE and
//            doesn't change the selection.
//
// Arguments: HINSTANCE hInstance - instance handle for resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            UINT uComboBoxId - combo box id containing the type info
//            HWND hListView - window handle to the list view control
//            BOOL bUseTunneling - whether this is a tunneling profile or not, 
//                                 affects whether Pre-Tunnel actions are displayed
//                                 or not.
//            CustomActionTypes TypeToSelect - type of the item to select
//            LPCTSTR pszDescription - description of the item to select
//
// Returns:   TRUE if the required item was found and selected
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
/*
BOOL SelectListViewItem(HWND hDlg, UINT uComboCtrlId, HWND hListView, BOOL bUseTunneling, CustomActionTypes TypeToSelect, LPCTSTR pszDescription)
{
    CustomActionTypes Type;
    BOOL bReturn = FALSE;
    HRESULT hr = MapComboSelectionToType(hDlg, uComboCtrlId, TRUE, bUseTunneling, &Type); //bIncludesAll == TRUE

    if ((ALL == Type) || (TypeToSelect == Type))
    {
        LVFINDINFO lvFindInfo = {0};
        LVITEM lvItem = {0};
        
        lvFindInfo.flags = LVFI_STRING;
        lvFindInfo.psz = pszDescription;

        int iIndex = ListView_FindItem(hListView, -1, &lvFindInfo);

        if (-1 != iIndex)
        {
            //
            //  Select the item
            //
            ListView_SetSelectionMark(hListView, iIndex);

            //
            //  Now set the selection state so it shows up as selected in the UI.
            //
            lvItem.mask = LVIF_STATE;
            lvItem.state = LVIS_SELECTED;
            lvItem.stateMask = LVIS_SELECTED;
            lvItem.iItem = iIndex;
            lvItem.iSubItem = 0;

            MYVERIFY(ListView_SetItem(hListView,  &lvItem));

            //
            //  Now Verify that the selection is visible
            //
            MYVERIFY(ListView_EnsureVisible(hListView, iIndex, FALSE)); // FALSE = fPartialOK, we want full visibility

            bReturn = TRUE;
        }
    }

    return bReturn;
}
*/
void SetListViewSelection(HWND hListView, int iIndex)
{
    ListView_SetSelectionMark(hListView, iIndex);

    //
    //  Now set the selection state so it shows up as selected in the UI.
    //
    LVITEM lvItem = {0};

    lvItem.mask = LVIF_STATE;
    lvItem.state = LVIS_SELECTED;
    lvItem.stateMask = LVIS_SELECTED;
    lvItem.iItem = iIndex;
    lvItem.iSubItem = 0;

    MYVERIFY(ListView_SetItem(hListView,  &lvItem));

    //
    //  Now Verify that the selection is visible
    //
    MYVERIFY(ListView_EnsureVisible(hListView, iIndex, FALSE)); // FALSE = fPartialOK, we want full visibility
}

BOOL SelectListViewItem(HINSTANCE hInstance, HWND hDlg, UINT uComboCtrlId, HWND hListView, BOOL bUseTunneling, CustomActionTypes TypeToSelect, LPCTSTR pszDescription)
{
    if ((NULL == pszDescription) || (TEXT('\0') == pszDescription[0]) || (0 == uComboCtrlId) || (NULL == hDlg))
    {
        CMASSERTMSG(FALSE, TEXT("SelectListViewItem -- Invalid parameter passed."));
        return FALSE;
    }

    CustomActionTypes Type;
    CustomActionTypes TypeSelectedInCombo;
    BOOL bReturn = FALSE;

    //
    //  If the current view is ALL, then we may have multiple items with the same name but different types.  Thus
    //  we must check the type string of the item and search again if it isn't the correct item.  If we are viewing
    //  items only of the TypeToSelect then we are guarenteed that there is only one item of that name.  Finally if
    //  we are viewing a different item type we don't want to do anything to the selection as the item we want to
    //  select won't be visible.
    //

    HRESULT hr = MapComboSelectionToType(hDlg, uComboCtrlId, TRUE, bUseTunneling, &TypeSelectedInCombo); //bIncludesAll == TRUE

    if (SUCCEEDED(hr) && ((TypeToSelect == TypeSelectedInCombo) || (ALL == TypeSelectedInCombo)))
    {
        //
        //  Setup the find structure
        //
        LVFINDINFO lvFindInfo = {0};
        lvFindInfo.flags = LVFI_STRING;
        lvFindInfo.psz = pszDescription;

        //
        //  Setup the Item structure
        //
        LVITEM lvItem = {0};
        TCHAR szTemp[MAX_PATH+1];
        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = szTemp;
        lvItem.cchTextMax = MAX_PATH;
        lvItem.iSubItem = 1;

        BOOL bExitLoop;
        int iIndex = -1;

        do
        {
            bExitLoop = TRUE;
            iIndex = ListView_FindItem(hListView, iIndex, &lvFindInfo);

            if ((-1 != iIndex) && (ALL == TypeSelectedInCombo))
            {
                //
                //  Now check to see if this has the type we are looking for
                //
                szTemp[0] = TEXT('\0');
                lvItem.iItem = iIndex;

                if (ListView_GetItem(hListView,  &lvItem))
                {
                    hr = g_pCustomActionList->GetTypeFromTypeString(hInstance, lvItem.pszText, &Type);

                    if (SUCCEEDED(hr))
                    {
                        bExitLoop = (TypeToSelect == Type);
                    }
                }
            }

        } while(!bExitLoop);

        if (-1 != iIndex)
        {
            SetListViewSelection(hListView, iIndex);
            bReturn = TRUE;
        }
    }

    return bReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  RefreshListView
//
// Synopsis:  This function refreshes the list view data from that contained
//            in the global CustomActionList class.  Gets the type of data to
//            display from the combo box specified by the hDlg and uComboCtrlId
//            parameters
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            UINT uComboBoxId - combo box id containing the type info
//            HWND hListView - window handle to the list view control
//            int iItemToSelect - item the caller wants selected after the refresh
//            BOOL bUseTunneling - whether this is a tunneling profile or not, 
//                                 affects whether Pre-Tunnel actions are displayed
//                                 or not.
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
void RefreshListView(HINSTANCE hInstance, HWND hDlg, UINT uComboCtrlId, HWND hListView, 
                     int iItemToSelect, BOOL bUseTunneling)
{
    //
    //  Refresh the list view
    //
    CustomActionTypes Type;
    BOOL bEnableDeleteAndEdit = FALSE;

    CMASSERTMSG(hInstance && hDlg && uComboCtrlId && hListView && g_pCustomActionList, TEXT("RefreshListView -- Invalid Parameters passed, skipping refresh"));

    if (hDlg && uComboCtrlId && hListView && g_pCustomActionList)
    {
        HRESULT hr = MapComboSelectionToType(hDlg, uComboCtrlId, TRUE, bUseTunneling, &Type); //bIncludesAll == TRUE

        //
        //  Add the items to the list view and set the selection to iItemToSelect
        //
        if (SUCCEEDED(hr))
        {
            hr = g_pCustomActionList->AddCustomActionsToListView(hListView, hInstance, Type, bUseTunneling, iItemToSelect, (ALL == Type));

            MYDBGASSERT(SUCCEEDED(hr));
        }

        //
        //  If the caller asked for an item that we couldn't select, then the item selected would be the first item.  To avoid
        //  confusion we will just use the currently selected item by passing -1;
        //
        int iIndex = -1;
        RefreshEditDeleteMoveButtonStates(hInstance, hDlg, hListView, uComboCtrlId, &iIndex, bUseTunneling);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  OnProcessCustomActionsAdd
//
// Synopsis:  This function is called when the user presses the Add button
//            on the custom action pane of CMAK.  This function is basically a
//            wrapper for the add functionality so that context menus and other
//            commands can also call it with duplicate code.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            HWND hListView - window handle to the list view control
//            BOOL bUseTunneling - whether this profile uses tunneling or not
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
void OnProcessCustomActionsAdd(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling)
{
    MYDBGASSERT(hInstance);
    MYDBGASSERT(hDlg);
    MYDBGASSERT(hListView);

    if (hInstance && hDlg && hListView)
    {
        CustomActionListItem ListItem;
        CustomActionTypes Type;

        INT_PTR nResult = -1;  // get info on currently selected item

        //
        //  First figure out what type of connect action the list view is showing.  We
        //  want to preset the combo box on the add/edit dialog to the correct type
        //  of custom action, unless it is showing all and then just set it to the first
        //  item in the list.
        //
        HRESULT hr = MapComboSelectionToType(hDlg, IDC_COMBO1, TRUE, bUseTunneling, &Type); //bIncludesAll == TRUE
        ZeroMemory(&ListItem, sizeof(CustomActionListItem));

        if (SUCCEEDED(hr))
        {
            if (ALL != Type)
            {
                ListItem.Type = Type;
            }
        }

        //
        //  Still call the Add dialog even if we couldn't determine the type
        //
        nResult = DialogBoxParam(NULL, MAKEINTRESOURCE(IDD_CUSTOM_ACTIONS_POPUP), hDlg, 
            ProcessCustomActionPopup,(LPARAM)&ListItem);

        if (IDOK == nResult)
        {
            RefreshListView(hInstance, hDlg, IDC_COMBO1, hListView, 0, bUseTunneling);
            SelectListViewItem(hInstance, hDlg, IDC_COMBO1, hListView, bUseTunneling, ListItem.Type, ListItem.szDescription);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  OnProcessCustomActionsDelete
//
// Synopsis:  This function is called when the user presses the Delete button
//            on the custom action pane of CMAK.  This function is basically a
//            wrapper for the delete functionality so that context menus and other
//            commands can also call it with duplicate code.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            HWND hListView - window handle to the list view control
//            BOOL bUseTunneling - whether this profile uses tunneling or not
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
void OnProcessCustomActionsDelete(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling)
{
    MYDBGASSERT(hInstance);
    MYDBGASSERT(hDlg);
    MYDBGASSERT(hListView);
    MYDBGASSERT(g_pCustomActionList);

    if (hInstance && hDlg && hListView && g_pCustomActionList)
    {
        CustomActionListItem ListItem;

        int iTemp = -1;  // get info on currently selected item

        HRESULT hr = GetDescriptionAndTypeOfItem(hInstance, hDlg, hListView, IDC_COMBO1, &ListItem, &iTemp, bUseTunneling);

        if (SUCCEEDED(hr))
        {
            hr = g_pCu