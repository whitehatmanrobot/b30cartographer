                        ((_IH.pInputPDU->eventList[i].u.key.keyboardFlags &
                        (TS_KBDFLAGS_EXTENDED | TS_KBDFLAGS_EXTENDED1)) >> 7));
                if (_IH.pInputPDU->eventList[i].u.key.keyboardFlags &
                        TS_KBDFLAGS_RELEASE)
                    *pCurEncode |= TS_INPUT_FASTPATH_KBD_RELEASE;
    
                pCurEncode++;
                //
                // Need two bytes for the unicode character
                //
                memcpy(pCurEncode, &_IH.pInputPDU->eventList[i].u.key.keyCode,
                       sizeof(TSUINT16));
                pCurEncode+=2;
                PktLen += 3;
                break;

            case TS_INPUT_EVENT_MOUSE:
            case TS_INPUT_EVENT_MOUSEX:
                *pCurEncode++ = (BYTE)(_IH.pInputPDU->eventList[i].messageType ==
                        TS_INPUT_EVENT_MOUSE ? TS_INPUT_FASTPATH_EVENT_MOUSE :
                        TS_INPUT_FASTPATH_EVENT_MOUSEX);
                memcpy(pCurEncode, &_IH.pInputPDU->eventList[i].u.mouse,
                        sizeof(TS_POINTER_EVENT));
                pCurEncode += sizeof(TS_POINTER_EVENT);
                PktLen += 1 + sizeof(TS_POINTER_EVENT);
                break;

            case TS_INPUT_EVENT_SYNC:
                *pCurEncode++ = (BYTE)(TS_INPUT_FASTPATH_EVENT_SYNC |
                        (_IH.pInputPDU->eventList[i].u.sync.toggleFlags &
                        TS_INPUT_FASTPATH_FLAGS_MASK));
                PktLen++;
                break;
        }
    }

    DC_END_FN();
    return PktLen;
}


/****************************************************************************/
/* Name:      IHSync                                                        */
/*                                                                          */
/* Purpose:   Synchronize Input Handler                                     */
/*                                                                          */
/* Operation: Only sync if the packet is empty.                             */
/*            Query the keyboard and mouse state.                           */
/****************************************************************************/
DCVOID DCINTERNAL CIH::IHSync(DCVOID)
{
    TS_INPUT_EVENT * pEvent;
    MSG msg;
    POINT mousePos;

    DC_BEGIN_FN("IHSync");

    TRC_DBG((TB,_T("IHSync dwMod: 0x%x"), _IH.dwModifierKeyState));

    /************************************************************************/
    /* Only send a sync if the packet is empty (i.e.  any outstanding       */
    /* packet has been sent successfully).                                  */
    /************************************************************************/
    if (_IH.pInputPDU->numberEvents > 0)
    {
        TRC_NRM((TB, _T("Cannot sync as the packet is not empty")));
        _IH.syncRequired = TRUE;
        DC_QUIT;
    }

    //
    // Inject a Tab-up (the official clear-menu highlighting key because it
    // happens normally when alt-tabbing) before we sync. That way if
    // we thought the alt key was down when we sync, the server injected
    // alt up won't highlight the menu
    //

    IHInjectVKey(WM_SYSKEYUP, VK_TAB);

    /************************************************************************/
    /* Add the Sync event, setting toggles for CapsLock, NumLock and        */
    /* ScrollLock.                                                          */
    /************************************************************************/
    TRC_DBG((TB, _T("Add sync event")));
    pEvent = &(_IH.pInputPDU->eventList[_IH.pInputPDU->numberEvents]);
    DC_MEMSET(pEvent, 0, sizeof(TS_INPUT_EVENT));

    pEvent->messageType = TS_INPUT_EVENT_SYNC;
    pEvent->eventTime = _pUt->UT_GetCurrentTimeMS();

    pEvent->u.sync.toggleFlags = 0;
    if (GetKeyState(VK_CAPITAL) & IH_KEYSTATE_TOGGLED)
    {
        TRC_DBG((TB, _T("Sync Event: set CapsLock flag")));
        pEvent->u.sync.toggleFlags |= TS_SYNC_CAPS_LOCK;
    }

    _IH.NumLock = FALSE;
    if (GetKeyState(VK_NUMLOCK) & IH_KEYSTATE_TOGGLED)
    {
        TRC_DBG((TB, _T("Sync Event: set Numlock flag")));
        pEvent->u.sync.toggleFlags |= TS_SYNC_NUM_LOCK;
        _IH.NumLock = TRUE;
    }

    if (GetKeyState(VK_SCROLL) & IH_KEYSTATE_TOGGLED)
    {
        TRC_DBG((TB, _T("Sync Event: set ScrollLock flag")));
        pEvent->u.sync.toggleFlags |= TS_SYNC_SCROLL_LOCK;
    }

#if defined(OS_WIN32)
    if (JAPANESE_KBD_LAYOUT(_pCc->_ccCombinedCapabilities.inputCapabilitySet.keyboardLayout))
    {
        if (GetKeyState(VK_KANA) & IH_KEYSTATE_TOGGLED)
        {
            TRC_DBG((TB, _T("Sync Event: set KanaLock flag")));
            pEvent->u.sync.toggleFlags |= TS_SYNC_KANA_LOCK;
        }
    }
#endif // OS_WIN32

    _IH.pInputPDU->numberEvents++;
    TS_DATAPKT_LEN(_IH.pInputPDU) += sizeof(TS_INPUT_EVENT);
    TS_UNCOMP_LEN(_IH.pInputPDU) += sizeof(TS_INPUT_EVENT);

    /************************************************************************/
    /* Construct dummy message for IHAddEventToPDU.                         */
    /************************************************************************/
    msg.hwnd = NULL;
    msg.lParam = 0;
    msg.wParam = 0;

#ifdef OS_WINNT
    /************************************************************************/
    /* Initialize the state of the Shift, Win, Alt & Ctrl keys to up.       */
    /************************************************************************/
    TRC_DBG((TB,_T("IHSync reset modifier pre:0x%x"), _IH.dwModifierKeyState));
    _IH.dwModifierKeyState = 0;
#endif

    /************************************************************************/
    // Send the current state of left and right Ctrl, Alt, and Shift keys.
    // Because MapVirtualKey() returns the same scancode for right-Ctrl and
    // right-Alt as for the left keys, we map right-Ctrl and Alt keys using
    // the left-side key scancodes and set the Extended flag. Right-Shift
    // has a distinct scancode, 0x36, which we use directly since CE and
    // Win9x don't map that value. Win16 does not allow querying of
    // left and right states at all, so at the top of this file we define
    // the left-keys to be the "both" keys, and do not send distinct
    // codes to the server. We're stuck with a keystate bug for that client.
    //
    // Win9x doesn't support querying for L/Rkeys so we just check for
    // Ctrl,Alt,Shift wihtout distinguishing L/R versions
    // There is a single outer branch for the platform check...this means
    // the code is duplicated but the single branch is better for performance.
    //
    /************************************************************************/
    if(_pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_NT)
    {
#define IH_RSHIFT_SCANCODE 0x36

        if (GetKeyState(VK_LSHIFT) & IH_KEYSTATE_DOWN) {
            TRC_DBG((TB, _T("Add left-Shift down event")));
            IHInjectVKey(WM_KEYDOWN, VK_SHIFT);
            _IH.dwModifierKeyState |= IH_LSHIFT_DOWN;
        }

        if (GetKeyState(VK_RSHIFT) & IH_KEYSTATE_DOWN) {
            TRC_DBG((TB, _T("Add right-Shift down event")));
            IHInjectKey(WM_KEYDOWN, VK_RSHIFT, (UINT16)IH_RSHIFT_SCANCODE);
            _IH.dwModifierKeyState |= IH_RSHIFT_DOWN;
        }
    
        if (GetKeyState(VK_LCONTROL) & IH_KEYSTATE_DOWN) {
            TRC_DBG((TB, _T("Add left-Ctrl down event")));
            IHInjectVKey(WM_KEYDOWN, VK_CONTROL);
#ifdef OS_WINNT
            _IH.dwModifierKeyState |= IH_LCTRL_DOWN;
#endif
        }
    
        if (GetKeyState(VK_RCONTROL) & IH_KEYSTATE_DOWN) {
            TRC_DBG((TB, _T("Add right-Ctrl down event")));
            IHInjectKey(WM_KEYDOWN, VK_RCONTROL,
                    (UINT16)(MapVirtualKey(VK_CONTROL, 0) | KF_EXTENDED));
    
#ifdef OS_WINNT
            _IH.dwModifierKeyState |= IH_RCTRL_DOWN;
#endif
        }

        if (GetKeyState(VK_LMENU) & IH_KEYSTATE_DOWN) {
            TRC_DBG((TB, _T("Add left-ALT down event")));
            IHInjectVKey(WM_KEYDOWN, VK_MENU);
#ifdef OS_WINNT
            _IH.dwModifierKeyState |= IH_LALT_DOWN;
#endif
        }
    
        if (GetKeyState(VK_RMENU) & IH_KEYSTATE_DOWN) {
            TRC_DBG((TB, _T("Add right-ALT down event")));
            IHInjectKey(WM_KEYDOWN, VK_RMENU,
                    (UINT16)(MapVirtualKey(VK_MENU, 0) | KF_EXTENDED));
#ifdef OS_WINNT
            _IH.dwModifierKeyState |= IH_RALT_DOWN;
#endif
        }
    }
    else
    {
        //Win9X version
        if (GetKeyState(VK_SHIFT) & IH_KEYSTATE_DOWN) {
            TRC_DBG((TB, _T("Add Shift down event")));
            IHInjectVKey(WM_KEYDOWN, VK_SHIFT);
            _IH.dwModifierKeyState |= IH_LSHIFT_DOWN;
        }

        if (GetKeyState(VK_CONTROL) & IH_KEYSTATE_DOWN) {
            TRC_DBG((TB, _T("Add Ctrl down event")));
            IHInjectVKey(WM_KEYDOWN, VK_CONTROL);
#ifdef OS_WINNT
            //
            // Can't distinguish on 9x so assume left
            // logic keeps every self-consistent with
            // our assumption
            //
            _IH.dwModifierKeyState |= IH_LCTRL_DOWN;
#endif
        }

        if (GetKeyState(VK_MENU) & IH_KEYSTATE_DOWN) {
            TRC_DBG((TB, _T("Add ALT down event")));
            IHInjectVKey(WM_KEYDOWN, VK_MENU);
#ifdef OS_WINNT
            //
            // Can't distinguish on 9x so assume left
            // logic keeps every self-consistent with
            // our assumption
            //
            _IH.dwModifierKeyState |= IH_LALT_DOWN;
#endif
        }

    }
    // Inject a tab up to prevent menu highlighting
    // in case the user switches to mstsc with the key down and
    // immediately releases it
    TRC_DBG((TB, _T("Add Tab up event")));
    IHInjectVKey(WM_SYSKEYUP, VK_TAB);

#if defined(OS_WIN32)
    if (JAPANESE_KBD_LAYOUT(_pCc->_ccCombinedCapabilities.inputCapabilitySet.keyboardLayout))
    {
        if (GetKeyState(VK_KANA) & IH_KEYSTATE_TOGGLED)
        {
            TRC_DBG((TB, _T("Add Kana down event")));
            IHInjectVKey(WM_KEYDOWN, VK_KANA);
        }
    }
#endif // OS_WIN32

    /************************************************************************/
    /* Get the mouse position; convert to window coordinates.               */
    /************************************************************************/
    GetCursorPos(&mousePos);

#ifdef OS_WIN32
    if (!ScreenToClient(_IH.inputCaptureWindow, &mousePos))
    {
        TRC_ERR((TB, _T("Cannot convert mouse coordinates!")));
    }
#else
    ScreenToClient(_IH.inputCaptureWindow, &mousePos);
#endif /* OS_WIN32 */

    /************************************************************************/
    /* Get the mouse position.                                              */
    /* NOTE: do not send the mouse button state - when the focus is         */
    /* regained we will either get a mouse click message immediately after  */
    /* the focus change, or we do not want to send a down click.            */
    /************************************************************************/
    TRC_DBG((TB, _T("Add mouse move event")));
    msg.message = WM_MOUSEMOVE;
    msg.lParam = MAKELONG(mousePos.x, mousePos.y);
    IHAddEventToPDU(&msg);

    /************************************************************************/
    /* Sets the mouse to ignore the client handedness settings.             */
    /************************************************************************/
    IHSetMouseHandedness();

    /************************************************************************/
    /* Send them.  Ignore failure - this will be sent later.                */
    /************************************************************************/
    _IH.priorityEventsQueued = TRUE;
    IHMaybeSendPDU();

    _IH.syncRequired = FALSE;
    _IH.focusSyncRequired = FALSE;

DC_EXIT_POINT:
    DC_END_FN();
} /* IHSync */


/****************************************************************************/
/* Name:      IHInitPacket                                                  */
/*                                                                          */
/* Purpose:   Initialize an InputPDU packet                                 */
/****************************************************************************/
DCVOID DCINTERNAL CIH::IHInitPacket(DCVOID)
{
    DC_BEGIN_FN("IHInitPacket");

    /************************************************************************/
    /* Initialize the InputPDU packet header (with 0 events)                */
    /************************************************************************/
    DC_MEMSET(_IH.pInputPDU, 0, TS_INPUTPDU_SIZE);
    _IH.pInputPDU->shareDataHeader.shareControlHeader.pduType =
                                    TS_PROTOCOL_VERSION | TS_PDUTYPE_DATAPDU;
    _IH.pInputPDU->shareDataHeader.shareControlHeader.pduSource =
                                                       _pUi->UI_GetClientMCSID();

    /************************************************************************/
    /* Note: this packet contains zero input events.                        */
    /************************************************************************/
    TS_DATAPKT_LEN(_IH.pInputPDU)           = TS_INPUTPDU_SIZE;
    _IH.pInputPDU->shareDataHeader.shareID  = _pUi->UI_GetShareID();
    _IH.pInputPDU->shareDataHeader.streamID = TS_STREAM_LOW;
    TS_UNCOMP_LEN(_IH.pInputPDU)            = TS_INPUTPDU_UNCOMP_LEN;
    _IH.pInputPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_INPUT;

    _IH.pInputPDU->numberEvents = 0;

    DC_END_FN();
} /* IHInitPacket */


/****************************************************************************/
/* Name:      IHDiscardMsg                                                  */
/*                                                                          */
/* Purpose:   Discard an input event                                        */
/*                                                                          */
/* Params:    IN      pMsg   - input event                                  */
/*                                                                          */
/* Operation: Called either when the InputPDU is full, or when IH has not   */
/*            yet allocated an InputPDU.                                    */
/*            Beep and flash the window if a key/button press is discarded. */
/****************************************************************************/
DCVOID DCINTERNAL CIH::IHDiscardMsg(PMSG pMsg)
{
    DC_BEGIN_FN("IHDiscardMsg");

    if(!pMsg)
    {
        return;
    }

    switch (pMsg->message)
    {
        case WM_MOUSEMOVE:
        case WM_MOUSEWHEEL:
        {
            /****************************************************************/
            /* Don't set 'sync required' as the keyboard state is OK and    */
            /* the mouse position doesn't matter.                           */
            /****************************************************************/
            TRC_NRM((TB, _T("Discard mouse move (message %#x)"), pMsg->message));
        }
        break;

        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_KEYDOWN:
        case WM_SYSKEYDOWN:
        {
            /****************************************************************/
            /* Flash the window and Beep.  Set the sync required flag.      */
            /****************************************************************/
            TRC_ERR((TB, _T("Discard button/key press (message %#x)"),
                         pMsg->message));
#ifndef OS_WINCE
            FlashWindow(_pUi->UI_GetUIMainWindow(), TRUE);
#endif // OS_WINCE
            MessageBeep((UINT)-1);
#ifndef OS_WINCE
            FlashWindow(_pUi->UI_GetUIMainWindow(), FALSE);
#endif // OS_WINCE
            _IH.syncRequired = TRUE;
        }
        break;

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_MBUTTONUP:
        case WM_KEYUP:
        case WM_SYSKEYUP:
        {
            /****************************************************************/
            /* Don't beep, but set the sync required flag.                  */
            /****************************************************************/
            TRC_ERR((TB, _T("Discard button/key release (message %#x)"),
                         pMsg->message));
            _IH.syncRequired = TRUE;
        }
        break;

        case WM_TIMER:
        {
            // Ignore - no need to trace
        }
        break;

        default:
        {
            /****************************************************************/
            /* Should only get input and timer messages here.               */
            /****************************************************************/
            TRC_ASSERT(IH_IS_INPUTEVENT(pMsg->message),
                       (TB, _T("Internal Error: %#x should be an input message"),
                             pMsg->message));
        }
        break;
    }

    DC_END_FN();
} /* IHDiscardMsg */


/****************************************************************************/
/* Name:      IHSetMouseHandedness                                          */
/*                                                                          */
/* Purpose:   Ensures that mouse handedness is independent from client      */
/*            setting.                                                      */
/*                                                                          */
/* Operation: Calls GetSystemMetrics to see if  mouse buttons are "swapped" */
/*            and sets the values of leftButton and rightButton accordingly */
/****************************************************************************/
DCVOID DCINTERNAL CIH::IHSetMouseHandedness(DCVOID)
{
    DC_BEGIN_FN("IHSetMouseHandedness");

    TRC_NRM((TB, _T("Attempting to set mouse handedness")));

#ifndef OS_WINCE
    if ((GetSystemMetrics(SM_SWAPBUTTON)) != 0)
        {
            TRC_DBG((TB, _T("Mouse set to left handedness")));
            _IH.leftButton = TS_FLAG_MOUSE_BUTTON2;
            _IH.rightButton = TS_FLAG_MOUSE_BUTTON1;
        }
        else
#endif // OS_WINCE
        {
            TRC_DBG((TB, _T("Mouse set to right handedness")));
            _IH.leftButton = TS_FLAG_MOUSE_BUTTON1;
            _IH.rightButton = TS_FLAG_MOUSE_BUTTON2;
        }

    DC_END_FN();
} /* IHSetMouseHandeness */


/****************************************************************************/
/* Name:      IHCheckForHotkey                                              */
/*                                                                          */
/* Purpose:   Handle hotkey sequences                                       */
/*                                                                          */
/* Returns:   TRUE  - hotkey sequence found and processed                   */
/*            FALSE - not a hotkey sequence                                 */
/*                                                                          */
/* Params:    pMsg - the message received                                   */
/****************************************************************************/
DCBOOL DCINTERNAL CIH::IHCheckForHotkey(PMSG pMsg)
{
    DCBOOL rc = TRUE;
    DCBOOL isExtended;
    DC_BEGIN_FN("IHCheckForHotkey");

    //
    // Handle hotkeys.  On entry to this function
    //   - we have determined that
    //   - this is a SYSKEYDOWN message
    //   - the Alt key is down
    //   - an Alt-down message has been sent to the Server
    //

    TRC_DBG((TB, _T("Check VK %#x for hotkey"), pMsg->wParam));
    if (! _pUt->UT_IsNEC98platform())
    {
        isExtended = HIWORD(pMsg->lParam) & KF_EXTENDED;
    }
    else
    {
        isExtended = TRUE;
    }

    //
    // Always check for the Ctrl-Alt-Del sequence, even if keyboard hooking
    //
    if (isExtended && (GetKeyState(VK_CONTROL) & IH_KEYSTATE_DOWN) &&
            (pMsg->wParam == _IH.pHotkey->ctlrAltdel))
    {
        //
        // Ctrl-Alt-Del hotkey
        //
        DCUINT16 scancode;
        TRC_NRM((TB, _T("Ctrl-Alt-Del hotkey")));

        scancode  = (DCUINT16)MapVirtualKey(VK_DELETE, 0);
        if (_pUt->UT_IsNEC98platform() &&
            _pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_NT)
        {
            scancode |= KF_EXTENDED;
        }
        else if (_pUt->UT_IsNX98Key())
        {
            scancode |= KF_EXTENDED;
        }

        IHInjectKey(WM_KEYDOWN, VK_DELETE, scancode);
        IHInjectKey(WM_KEYUP, VK_DELETE, scancode);
        rc = TRUE;
        DC_QUIT;
    } else if (_fUseHookBypass) {

        //
        // Only continue processing other key substitutes if we're not using the
        // powerful keyboard hooking functionality
        //
    
        rc = FALSE;
        DC_QUIT;
    }

    if (isExtended && (pMsg->wParam == _IH.pHotkey->ctrlEsc))
    {
        //
        // Ctrl-Esc hotkey
        //
        TRC_NRM((TB, _T("Ctrl-Esc hotkey")));

        //
        // Add a Tab-Up to switch off the Alt-key
        //
        IHInjectVKey(WM_SYSKEYUP, VK_TAB);

        // First set the correct Alt key(s) up again.
        // because win9x doesn't support GetKeyState on left/right
        if (_IH.dwModifierKeyState & IH_LALT_DOWN)
        {
            IHInjectVKey(WM_KEYUP, VK_MENU);
        }

        if (_IH.dwModifierKeyState & IH_RALT_DOWN)
        {
            IHInjectKey(WM_KEYUP, VK_RMENU,
                    (UINT16)(MapVirtualKey(VK_MENU, 0) | KF_EXTENDED));
        }

        //
        // Keep the flags up to date
        //
        _IH.dwModifierKeyState &= ~IH_ALT_MASK;

        //
        // Now send the Ctrl-Esc sequence
        //
        IHInjectVKey(WM_KEYDOWN, VK_CONTROL);
        IHInjectVKey(WM_KEYDOWN, VK_ESCAPE);
        IHInjectVKey(WM_KEYUP, VK_ESCAPE);
        IHInjectVKey(WM_KEYUP, VK_CONTROL);

        //
        // Later, we'll received Home-up, Alt-up.  Set a flag here telling
        // us to discard them later.
        //
        _IH.fCtrlEscHotkey = TRUE;
    }

    else if (isExtended && (pMsg->wParam == _IH.pHotkey->altEsc))
    {
        //
        // Alt-Esc hotkey
        //
        TRC_NRM((TB, _T("Alt-Esc hotkey")));
        IHInjectVKey(WM_KEYDOWN, VK_ESCAPE);
        IHInjectVKey(WM_KEYUP, VK_ESCAPE);
    }

    else if (isExtended && (pMsg->wParam == _IH.pHotkey->altTab))
    {
        //
        // Alt-Tab hotkey
        //
        TRC_NRM((TB, _T("Alt-Tab hotkey")));
        IHInjectVKey(WM_KEYDOWN, VK_TAB);
        IHInjectVKey(WM_KEYUP, VK_TAB);
    }

    else if (isExtended && (pMsg->wParam == _IH.pHotkey->altShifttab))
    {
        //
        // Alt-Shift-Tab hotkey
        //
        TRC_NRM((TB, _T("Alt-Shift Tab hotkey")));

        IHInjectVKey(WM_KEYDOWN, VK_SHIFT);
        IHInjectVKey(WM_KEYDOWN, VK_TAB);
        IHInjectVKey(WM_KEYUP, VK_TAB);
        IHInjectVKey(WM_KEYUP, VK_SHIFT);
    }

    else if (isExtended && (pMsg->wParam == _IH.pHotkey->altSpace))
    {
        //
        // Alt-Space hotkey
        //
        TRC_NRM((TB, _T("Alt-Space hotkey")));
        IHInjectVKey(WM_KEYDOWN, VK_SPACE);
        IHInjectVKey(WM_KEYUP, VK_SPACE);
    }

    else if ((GetKeyState(VK_CONTROL) & IH_KEYSTATE_DOWN) &&
            (pMsg->wParam == VK_SUBTRACT))
    {
        BOOL bLeftCtrlDown = FALSE;
        BOOL bRightCtrlDown = FALSE;

        TRC_NRM((TB, _T("Alt-PrintScreen hotkey")));
        //
        // Alt print screen hotkey
        //

        // First set the correct Ctrl key(s) up again.
        if (_IH.dwModifierKeyState & IH_LCTRL_DOWN) {
            IHInjectVKey(WM_KEYUP, VK_CONTROL);
            bLeftCtrlDown = TRUE;
        }
        else {
            bLeftCtrlDown = FALSE;
        }
        
        if (_IH.dwModifierKeyState & IH_RCTRL_DOWN) {
            IHInjectKey(WM_KEYUP, VK_RCONTROL,
                    (UINT16)(MapVirtualKey(VK_CONTROL, 0) | KF_EXTENDED));
            bRightCtrlDown = TRUE;
        }
        else {
            bRightCtrlDown = FALSE;
        }

        //
        // Send the prntscreen key
        // Win16 doesn't seem to map this scancode correctly
        //
        if (_pUt->UT_IsNEC98platform() &&
            _pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95)
        {
            IHInjectKey(WM_SYSKEYDOWN, VK_SNAPSHOT, 0x61);
            IHInjectKey(WM_SYSKEYUP, VK_SNAPSHOT, 0x61);
        }
        else
        {
            IHInjectKey(WM_SYSKEYDOWN, VK_SNAPSHOT, 0x54);
            IHInjectKey(WM_SYSKEYUP, VK_SNAPSHOT, 0x54);
        }

        // Put the control key(s) back down (since they really are down)
        if (bLeftCtrlDown)
        {
            IHInjectVKey(WM_KEYDOWN, VK_CONTROL);
        }

        if (bRightCtrlDown)
        {
            IHInjectKey(WM_KEYDOWN, VK_RCONTROL,
                    (UINT16)(MapVirtualKey(VK_CONTROL, 0) | KF_EXTENDED));
        }

    }
    else if ((GetKeyState(VK_CONTROL) & IH_KEYSTATE_DOWN) &&
            (pMsg->wParam == VK_ADD))
    {
        BOOL bLeftCtrlDown = FALSE;
        BOOL bLeftAltDown  = FALSE;
        BOOL bRightCtrlDown = FALSE;
        BOOL bRightAltDown  = FALSE;

        TRC_NRM((TB, _T("PrintScreen hotkey")));

        //
        // print screen hotkey
        //

        // First set the Ctrl key(s) up.
        if (_IH.dwModifierKeyState & IH_LCTRL_DOWN) {
            IHInjectVKey(WM_KEYUP, VK_CONTROL);
            bLeftCtrlDown = TRUE;
        }
        else {
            bLeftCtrlDown = FALSE;
        }

        if (_IH.dwModifierKeyState & IH_RCTRL_DOWN) {
            IHInjectKey(WM_KEYUP, VK_RCONTROL,
                    (UINT16)(MapVirtualKey(VK_CONTROL, 0) | KF_EXTENDED));
            bRightCtrlDown = TRUE;
        }
        else {
            bRightCtrlDown = FALSE;
        }

        // Add a Tab-Up to switch off the Alt-key.
        IHInjectVKey(WM_SYSKEYUP, VK_TAB);

        // Set the Alt key(s) up.
        if (_IH.dwModifierKeyState & IH_LALT_DOWN) {
            IHInjectVKey(WM_KEYUP, VK_MENU);
            bLeftAltDown = TRUE;
        }
        else {
            bLeftAltDown = FALSE;
        }

        if (_IH.dwModifierKeyState & IH_RALT_DOWN) {
            IHInjectKey(WM_KEYUP, VK_RMENU,
                    (UINT16)(MapVirtualKey(VK_MENU, 0) | KF_EXTENDED));
            bRightAltDown = TRUE;
        }
        else {
            bRightAltDown = FALSE;
        }

        //
        // Send the prntscreen key
        // Win16 doesn't seem to map this scancode correctly
        //
        IHInjectKey(WM_SYSKEYDOWN, VK_SNAPSHOT, 0x54);
        IHInjectKey(WM_SYSKEYUP, VK_SNAPSHOT, 0x54);

        // Set the Alt key(s) down again
        if (bLeftAltDown)
        {
            IHInjectVKey(WM_KEYDOWN, VK_MENU);
        }
        if (bRightAltDown)
        {
            IHInjectKey(WM_KEYDOWN, VK_RMENU,
                    (UINT16)(MapVirtualKey(VK_MENU, 0) | KF_EXTENDED));
        }
    
        // Set the Ctrl key(s) down again.
        if (bLeftCtrlDown)
        {
            IHInjectVKey(WM_KEYDOWN, VK_CONTROL);
        }

        if (bRightCtrlDown)
        {
            IHInjectKey(WM_KEYDOWN, VK_RCONTROL,
                    (UINT16)(MapVirtualKey(VK_CONTROL, 0) | KF_EXTENDED));
        }
    }

    else
    {
        //
        // Not a hotkey we recognise
        //
        TRC_NRM((TB, _T("VK %x is not one of our hotkeys"), pMsg->wParam));
        rc = FALSE;
    }

DC_EXIT_POINT:

    //
    // If we've translated a hotkey, make sure the PDU is sent now.
    //
    if (rc)
    {
        TRC_NRM((TB, _T("Hotkey processed")));
        _IH.priorityEventsQueued = TRUE;
        IHMaybeSendPDU();
    }

    DC_END_FN();
    return rc;
} /* IHCheckForHotkey */

#if defined(OS_WIN32)
/****************************************************************************/
/* Name:      IHProcessKoreanVKHangulHanja                                  */
/*                                                                          */
/* Purpose:   Fixup right-Alt/Ctrl key for Korean keyboards                 */
/*                                                                          */
/* Returns:   TRUE  - event processed, continue with next event             */
/*            FALSE - do not continue wih next event                        */
/*                                                                          */
/* Params:    pMsg  - message from Windows                                  */
/****************************************************************************/
DCBOOL DCINTERNAL CIH::IHProcessKoreanVKHangulHanja(PWORD scancode, PWORD flags)
{
    DCBOOL rc = FALSE;

    if (KOREAN_KBD_LAYOUT(_pCc->_ccCombinedCapabilities.inputCapabilitySet.keyboardLayout))
    {
        if (_pUt->UT_IsKorean101LayoutForWin9x() &&
            ((*scancode == 0x20 && (*flags & KF_EXTENDED)) || *scancode == 0))
        {
            // Evil hack for KOR Win95, Win95 OSR2 and Win98.
            // These 101A/B/C keyboard driver have difference scan code by Right ALT key.
            // This generated code is replace scan code to Windows NT's Right ALT and make extended flag.
            *scancode = 0x38;
            *flags |= KF_EXTENDED;
            rc = TRUE;
        }
        else if (_pUt->UT_IsKorean101LayoutForNT351() &&
                 (*scancode == 0x38 || *scancode == 0x1d))
        {
            // Evil hack for KOR Windows NT ver 3.51
            // These 101A/B keyboard driver doen't have extended flag by Right ALT key.
            // This generated code make extended flag.
            *flags |= KF_EXTENDED;
            rc = TRUE;
        }
    }

    return rc;
}
#endif

/****************************************************************************/
/* Name:      IHProcessKeyboardEvent                                        */
/*                                                                          */
/* Purpose:   Handle keyboard input events from Windows                     */
/*                                                                          */
/* Returns:   TRUE  - event processed, continue with next event             */
/*            FALSE - do not continue wih next event                        */
/*                                                                          */
/* Params:    pMsg  - message from Windows                                  */
/****************************************************************************/
DCBOOL DCINTERNAL CIH::IHProcessKeyboardEvent(PMSG pMsg)                
{
    DCBOOL rc = FALSE;
    WORD lParamLo, lParamHi;
    WORD scancode, flags;
    DCBOOL fCtrlEscHotkey = FALSE;
    DCBOOL fLastKeyWasMenuDown = FALSE;

    DC_BEGIN_FN("IHProcessKeyboardEvent");

    /************************************************************************/
    /* First get some useful data                                           */
    /************************************************************************/
    lParamLo = LOWORD(pMsg->lParam);
    lParamHi = HIWORD(pMsg->lParam);
    scancode = (WORD)(lParamHi & 0x00FF);
    flags    = (WORD)(lParamHi & 0xFF00);


    TRC_DBG((TB, _T("%s (%#x), wParam 0x%x, lParam 0x%x Scan:0x%x A/E/U"),
            pMsg->message == WM_SYSKEYDOWN ? _T("WM_SYSKEYDOWN") :
            pMsg->message == WM_SYSKEYUP   ? _T("WM_SYSKEYUP") :
            pMsg->message == WM_KEYDOWN    ? _T("WM_KEYDOWN") :
            pMsg->message == WM_KEYUP      ? _T("WM_KEYUP") : _T("Unknown msg"),
            pMsg->message, pMsg->wParam, pMsg->lParam,
            scancode, (flags & KF_ALTDOWN) != 0,
            (flags & KF_EXTENDED) != 0,
            (flags & KF_UP) != 0));

    /************************************************************************/
    /* If NumLock is on, the numeric keypad keys return VK_NUMPADx.         */
    /* However, if shift is pressed, they return VK_LEFT etc.  Windows      */
    /* generates a Shift-Up and Shift-Down around these keys, so as to fake */
    /* the shift state to off.  Hence, if the user presses Shift-NumPad6,   */
    /* the following sequence is returned to the app:                       */
    /*                                                                      */
    /* - VK_SHIFT down                                                      */
    /* - VK_SHIFT up (generated by Windows)                                 */
    /* - VK_RIGHT down                                                      */
    /* - VK_RIGHT up                                                        */
    /* - VK_SHIFT down (generated by Windows)                               */
    /* - VK_SHIFT up                                                        */
    /*                                                                      */
    /* If we inject this sequence, the shift state is wrong at the point we */
    /* inject VK_RIGHT, so it is interpreted as a '6'.  In order to bypass  */
    /* this, we set the extended flag here.  This tells Windows that the    */
    /* regular arrow keys were pressed, so they are interpreted correctly.  */
    /*                                                                      */
    /* None of this is necessary if we're hooking the keyboard              */
    /*                                                                      */
    /************************************************************************/

    if (!_fUseHookBypass && _IH.NumLock)
    {
        if (((pMsg->wParam >= VK_PRIOR) && (pMsg->wParam <= VK_DOWN)) ||
            ((pMsg->wParam == VK_INSERT) || (pMsg->wParam == VK_DELETE)))
        {
            flags |= KF_EXTENDED;
            TRC_NRM((TB, _T("Set extended flag on VK %#x"), pMsg->wParam));
        }
    }

    //
    // I don't care what modifiers are down, we need to filter the "Speed
    // Racer" keys if we're not using the hook so they don't go to both
    // the client and the server
    //
    // Back, Forward, Stop, Refresh, Search, Favorites, Web/Home, Mail, Mute,
    // Volume +/-, Play/Pause, Stop, Prev Track, Next Track, Media, 
    // My Comuputer, Calculator, Sleep
    //

    //
    // I'm using a switch because I know these are consecutive numbers
    // and I want the compiler to make me a fast little jump table
    //

    #ifndef OS_WINCE
    switch (pMsg->wParam) {
    case VK_BROWSER_BACK:
    case VK_BROWSER_FORWARD:
    case VK_BROWSER_REFRESH:
    case VK_BROWSER_STOP:
    case VK_BROWSER_SEARCH:
    case VK_BROWSER_FAVORITES:
    case VK_BROWSER_HOME:
    case VK_VOLUME_MUTE:
    case VK_VOLUME_DOWN:
    case VK_VOLUME_UP:
    case VK_MEDIA_NEXT_TRACK:
    case VK_MEDIA_PREV_TRACK:
    case VK_MEDIA_STOP:
    case VK_MEDIA_PLAY_PAUSE:
    case VK_LAUNCH_MAIL:
    case VK_LAUNCH_MEDIA_SELECT:
    case VK_LAUNCH_APP1:
    case VK_LAUNCH_APP2:
    case VK_SLEEP:
        {
            //
            // This is the fix to discard speed
            // racer keys when not hooking
            // 
            if (!_fUseHookBypass) {
                TRC_NRM((TB,_T("Discard Speed Racer Key: 0x%02x"),
                         pMsg->wParam));
                DC_QUIT;
            }

            if (VK_SLEEP == pMsg->wParam)
            {
                //
                // EthanZ says we should never ever send
                // the sleep key to the server
                //
                TRC_NRM((TB, _T("Discard Sleep key")));
                DC_QUIT;
            }
        }
        break;
    }
    #endif OS_WINCE
    
#ifndef OS_WINCE    
	//
    // Toss keys we injected back into the console.
    //

    //
    // VK_IGNORE_VALUE is a very special hack case where we self inject
    // a key back to ourselves to force win32k to do an internal keystate
    // update after we regain focus. At the point we want to do a sync
    //

    if (pMsg->wParam == VK_IGNORE_VALUE) {

        if (pMsg->message == WM_KEYDOWN && _IH.fDiscardSyncDownKey) {

            // Clear the down key discard flag
            _IH.fDiscardSyncDownKey = FALSE;

            TRC_DBG((TB,
                     _T("Discarding self injected down key msg: 0x%x wP:0x%x lP:0x%x"),
                     pMsg->message, pMsg->wParam, pMsg->lParam));
            DC_QUIT;
        }
        else if (pMsg->message == WM_KEYUP && _IH.fDiscardSyncUpKey) {

            // Clear the UP key discard flag
            _IH.fDiscardSyncUpKey = FALSE;

            if (!_IH.allowBackgroundInput) {

                //
                // Do a modifier key fixup
                //

                TRC_DBG((TB,
                    _T("Doing modifier keystate update in response to keyhint")));
                IHMaintainModifierKeyState(pMsg->wParam);

                TRC_DBG((TB,
                         _T("Discarding self injected UP key msg: 0x%x wP:0x%x lP:0x%x"),
                         pMsg->message, pMsg->wParam, pMsg->lParam));
            }
            DC_QUIT;
        }
    }

    //
    // Toss keys we self-inject back into the console that are marked
    // with an ignorevalue in EXTRAINFO. This mechanism can't be used in general
    // because we attachthreadinput the UI and Input threads so the extrainfo
    // state won't always be consistent. However for certain keys (specific example)
    // is Windowskey+L we can get by doing it this way as we want the behavior
    // of the local system getting the key.
    //
    if (GetMessageExtraInfo() == IH_EXTRAINFO_IGNOREVALUE) {

        TRC_DBG((TB,
                 _T("Discarding self injected key msg: 0x%x wP:0x%x lP:0x%x"),
                 pMsg->message, pMsg->wParam, pMsg->lParam));
        DC_QUIT;
    }
#endif

    if (!_IH.allowBackgroundInput) {
        IHMaintainModifierKeyState(pMsg->wParam);
    }

    /************************************************************************/
    /* Handling for (SYS)KEYUP messages                                     */
    /************************************************************************/
    if ((pMsg->message == WM_KEYUP) || (pMsg->message == WM_SYSKEYUP))
    {
        /********************************************************************/
        /* Special processing for some keys                                 */
        /********************************************************************/
        switch (pMsg->wParam)
        {
            case VK_MENU:
            {
                TRC_DBG((TB, _T("VK_MENU")));
#ifdef OS_WINNT
                //
                // Track ALT state and fixup for possible
                // incorrect assumption in IHSync
                //
                DCUINT cancelKey = (flags & KF_EXTENDED) ?
                                   IH_RALT_DOWN : IH_LALT_DOWN;
                if (_IH.dwModifierKeyState & cancelKey)
                {
                    TRC_DBG((TB,_T("Cancel key: current: 0x%x cancel: 0x%X"),
                             _IH.dwModifierKeyState, cancelKey));
                    _IH.dwModifierKeyState &= (~cancelKey);
                }
                else if ((IH_RALT_DOWN == cancelKey &&
                    (_IH.dwModifierKeyState & IH_LALT_DOWN)))
                {
                    //
                    // Must have made a wrong assumption in
                    // IH_Sync on 9x. Switch this RALT up
                    // to a LALT up to properly sync with
                    // the server.
                    //
                    TRC_DBG((TB,_T("Switch LALT to RALT")));
                    flags &= ~KF_EXTENDED;
                    _IH.dwModifierKeyState &= (~IH_LALT_DOWN);
                }
                else
                {
                    // Current flags state is not consistent
                    // with the UP key we just received
                    TRC_ERR((TB,
                    _T("ALT up without previous down (E:%d,dwModifierKeyState:0x%x"),
                       (flags & KF_EXTENDED),_IH.dwModifierKeyState));
                }
#endif

                /************************************************************/
                /* If we've just processed a Ctrl-Esc hotkey, discard the   */
                /* trailing Alt-up                                          */
                /************************************************************/
                if (_IH.fCtrlEscHotkey)
                {
                    TRC_NRM((TB, _T("Discard Alt-up")));
                    DC_QUIT;
                }

                /************************************************************/
                /* When the user uses Alt-Tab on the client we may see an   */
                /* Alt-Down Alt-Up with nothing in between, but is distinct */
                /* because the Alt-Up is a WM_KEYUP not a WM_SYSKEY up.     */
                /* For this we inject an Tab-up similar to what is seen on  */
                /* the console for alt-tabbing to ensure the server doesn't */
                /* highlight the menu                                       */
                /************************************************************/
                if ((_IH.fLastKeyWasMenuDown) && (pMsg->message == WM_KEYUP))
                {
                    // Inject our Tab-up.
                    IHInjectVKey(WM_SYSKEYUP, VK_TAB);

                    // Fall through and send the original Alt-up now.
                }
            }
            break;

            case VK_PAUSE:
            {
                TRC_DBG((TB, _T("VK_PAUSE")));
                /************************************************************/
                /* If the user presses Pause, we see VK_PAUSE without the   */
                /* EXTENDED flag set.  Don't send this key-up - we've       */
                /* already completed this sequence in the key-down case.    */
                /************************************************************/
                if (!(flags & KF_EXTENDED))
                {
                    TRC_NRM((TB, _T("Drop VK_PAUSE Up")));
                    DC_QUIT;
                }
            }
            break;

#if defined(OS_WINNT)
            case VK_CANCEL:
            {
                TRC_DBG((TB, _T("VK_CANCEL")));

                if (!(flags & KF_EXTENDED))
                {
                    if (_pUt->UT_IsNEC98platform() && _pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95) {
                        //
                        // NEC PC-98 Windows 95 platform
                        // If the user presses STOP key, we also see VK_CANCEL,
                        // Don't send this key-up - we've already completed
                        // this sequence in the key-down case.
                        //
                        TRC_NRM((TB, _T("Drop VK_CANCEL Up")));
                        DC_QUIT;
                    }
                }
            }
            break;
#endif // OS_WINNT

            case VK_SHIFT:
            {
                TRC_DBG((TB, _T("VK_SHIFT")));
                #ifndef OS_WINCE  // We don't want unnecessary checks for Windows CE
                /************************************************************/
                /* Win311 and Win9x are Evil.  If a shift key is generated, */
                /* it is always the RIGHT shift, regardless of which one is */
                /* actually down.  Here we ensure that the correct Shift-Up */
                /* is sent to the Server.  Ick.                             */
                /*                                                          */
                /* As far as we know, this occurs only when NumLock is on.  */
                /*                                                          */
                /* Se the other half of this hack in the KEYDOWN case below.*/
                /************************************************************/
                if (((_pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95) ||
                     (_pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_31X)) &&
                        _IH.NumLock &&
                        (scancode == 0x36) &&
                        ((_IH.dwModifierKeyState & IH_RSHIFT_DOWN) == 0) )
                {
                    /********************************************************/
                    /* Ahem.  The condition is (WinEvil) and (RIGHT SHIFT   */
                    /* UP) and (We thought it WAS up) and (NumLock is on)   */
                    /********************************************************/
                    TRC_NRM((TB, _T("Evil hack: switch right to left shift")));
                    scancode = 0x2a;
                    _IH.fWinEvilShiftHack = TRUE;
                }
                #endif

                /************************************************************/
                /* If both Shift keys are pressed, then we only get one     */
                /* keyup message.  In this case send both the 'up's.        */
                /************************************************************/
                TRC_NRM((TB, _T("Shift up: state %x"), _IH.dwModifierKeyState & IH_SHIFT_MASK));
                if (_IH.dwModifierKeyState == IH_SHIFT_MASK)
                {
                    /************************************************************/
                    /* Add the two shift-up events                              */
                    /************************************************************/
                    pMsg->lParam = MAKELONG(lParamLo, 0x2a | flags);
                    IHAddEventToPDU(pMsg);

                    scancode = 0x36;

                    /************************************************************/
                    /* This one falls through to be added to the PDU below      */
                    /************************************************************/
                }

                /****************************************************************/
                /* Reset the shift state                                        */
                /****************************************************************/
                _IH.dwModifierKeyState &= ~IH_SHIFT_MASK;
            }
            break;

#ifndef OS_WINCE
            case VK_SNAPSHOT:
            {
                TRC_DBG((TB, _T("VK_SNAPSHOT")));

                /************************************************************/
                /* Some inferior operating systems put a scan code of 00    */
                /************************************************************/
                if ((DCUINT16)(HIWORD(pMsg->lParam) & 0x00FF) == 0) {
                    pMsg->lParam  = MAKELONG(0, 0x54);
                }

                /************************************************************/
                /* If Alt-Shift-PrtScr is pressed (it's an Accessability    */
                /* sequence), we see only PrtScr-up, no PrtScr-down.        */
                /* Hence, we fake a PrtScr-down here before injecting the   */
                /* PrtScr-up.                                               */
                /************************************************************/
                TRC_NRM((TB, _T("PrtScr Up")));
                if ((GetKeyState(VK_MENU) & IH_KEYSTATE_DOWN) &&
                    (GetKeyState(VK_SHIFT) & IH_KEYSTATE_DOWN))
                {
                    /********************************************************/
                    /* Add a PrtScr-down before this Prt-Scr up             */
                    /********************************************************/
                    TRC_NRM((TB, _T("Alt & Shift down")));
                    pMsg->message = WM_SYSKEYDOWN;
                    IHAddEventToPDU(pMsg);

                    pMsg->message = WM_SYSKEYUP;
                }
            }
            break;
#endif

#ifdef OS_WINNT
            case VK_CONTROL:
            {
                TRC_DBG((TB, _T("VK_CONTROL")));
                //
                // Track CTRL state and fixup for possible
                // incorrect assumption in IHSync
                //
                DCUINT cancelKey = (flags & KF_EXTENDED) ?
                                   IH_RCTRL_DOWN : IH_LCTRL_DOWN;
                if (_IH.dwModifierKeyState & cancelKey)
                {
                    _IH.dwModifierKeyState &= (~cancelKey);
                }
                else if ((IH_RCTRL_DOWN == cancelKey &&
                    (_IH.dwModifierKeyState & IH_LCTRL_DOWN)))
                {
                    //
                    // Must have made a wrong assumption in
                    // IH_Sync on 9x. Switch this RCTRL up
                    // to a LCTRL up to properly sync with
                    // the server.
                    //
                    flags &= ~KF_EXTENDED;
                    _IH.dwModifierKeyState &= (~IH_LCTRL_DOWN);
                }
                else
                {
                    // Current flags state is not consistent
                    // with the UP key we just received
                    TRC_ERR((TB,
                    _T("Ctrl up without previous down (E:%d,dwModifierKeyState:0x%x"),
                       (flags & KF_EXTENDED),_IH.dwModifierKeyState));
                }
            }
            break;
#endif

            case VK_HOME:
            {
                TRC_DBG((TB, _T("VK_HOME")));
                /************************************************************/
                /* Discard Home-up if we've just processed a Ctrl-Esc       */
                /* hotkey - but remain in this state.                       */
                /************************************************************/
                if (_IH.fCtrlEscHotkey)
                {
                    TRC_NRM((TB, _T("Discard Home-up")));
                    fCtrlEscHotkey = TRUE;
                    DC_QUIT;
                }
            }
            break;

#if defined(OS_WIN32)
            case VK_HANGUL:
            case VK_HANJA:
            {
                TRC_DBG((TB, _T("VK_HANGUL/VK_HANJA")));
                IHProcessKoreanVKHangulHanja(&scancode, &flags);
            }
            break;
#endif

            //
            // If we're hooking keys, we might send the Windows key as
            // a part of that feature. 
            // Only send the up if we intend to use it on the server
            //
            case VK_LWIN:
#ifndef OS_WINCE
                if (!_fUseHookBypass) {
#else
                if (!_fUseHookBypass && (g_CEConfig != CE_CONFIG_WBT)) {
#endif
                    DC_QUIT;
                } else {
                    _IH.dwModifierKeyState &= ~IH_LWIN_DOWN;
                }
                break;

            case VK_RWIN:
#ifndef OS_WINCE
                if (!_fUseHookBypass) {
#else
                if (!_fUseHookBypass && (g_CEConfig != CE_CONFIG_WBT)) {
#endif
                    DC_QUIT;
                } else {
                    _IH.dwModifierKeyState &= ~IH_RWIN_DOWN;
                }
                break;

            /****************************************************************/
            /* No default case - default is no special processing           */
            /****************************************************************/
        }
    }

    else
    {
        /********************************************************************/
        /* Handling for (SYS)KEYDOWN messages                               */
        /********************************************************************/
        TRC_ASSERT(
          ((pMsg->message == WM_KEYDOWN) || (pMsg->message == WM_SYSKEYDOWN)),
          (TB, _T("Unexpected message %#x"), pMsg->message));

        /********************************************************************/
        /* First, weed out hotkey sequences                                 */
        /********************************************************************/
#ifdef OS_WINCE
        if (g_CEConfig != CE_CONFIG_WBT)
        {
#endif // OS_WINCE		
            if (GetKeyState(VK_MENU) & IH_KEYSTATE_DOWN)
            {
                if (IHCheckForHotkey(pMsg))
                {
                    TRC_NRM((TB, _T("Hotkey processed")));
                    DC_QUIT;
                }
            }
#ifdef OS_WINCE
        }
#endif	// OS_WINCE

        /********************************************************************/
        /* Special processing per key                                       */
        /********************************************************************/
        switch (pMsg->wParam)
        {
            case VK_MENU:
            {
                TRC_DBG((TB, _T("VK_MENU down")));
                /************************************************************/
                /* Track Alt state                                          */
                /************************************************************/
                fLastKeyWasMenuDown = TRUE;
#ifdef OS_WINNT
                _IH.dwModifierKeyState |= (flags & KF_EXTENDED) ?
                                IH_RALT_DOWN : IH_LALT_DOWN;
#endif
                TRC_DBG((TB,_T("Process alt key. Mod key state: 0x%x"),
                         _IH.dwModifierKeyState));
            }
            break;

            case VK_PAUSE:
            {
                TRC_DBG((TB, _T("VK_PAUSE down")));
                /************************************************************/
                /* If the user presses the Pause key, we see a VK_PAUSE     */
                /* without the EXTENDED flag set.  We need to send          */
                /* Ctrl-NumLock, where the Ctrl has the EXTENDED1 flag set. */
                /*                                                          */
                /* If the user presses Ctrl-NumLock, we also see VK_PAUSE,  */
                /* but with the EXTENDED flag.  We simply let this through  */
                /* here.                                                    */
                /************************************************************/
                if ((pMsg->wParam == VK_PAUSE) && !(flags & KF_EXTENDED))
                {
                    TRC_NRM((TB, _T("Pause key from key no. 126 (Pause key)")));


#if defined(OS_WINNT)
                    if (! (_pUt->UT_IsNEC98platform() &&
                           _pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95)) {
#endif // OS_WINNT
                        pMsg->wParam  = VK_CONTROL;
                        pMsg->lParam  = MAKELONG(0,
                        MapVirtualKey(VK_CONTROL, 0) | IH_KF_EXTENDED1);
                        IHAddEventToPDU(pMsg);

                        pMsg->wParam  = VK_NUMLOCK;
                        pMsg->lParam  = MAKELONG(0, 0x45);
                        IHAddEventToPDU(pMsg);

                        pMsg->message = WM_KEYUP;
                        pMsg->wParam  = VK_CONTROL;
                        pMsg->lParam  = MAKELONG(0,
                                  MapVirtualKey(VK_CONTROL, 0) | IH_KF_EXTENDED1);
                        IHAddEventToPDU(pMsg);

                        pMsg->wParam  = VK_NUMLOCK;
                        pMsg->lParam  = MAKELONG(0, 0x45);
                        IHAddEventToPDU(pMsg);
#if defined(OS_WINNT)
                    }
                    else {
                        //
                        // NEC PC-98 Windows 98 platform
                        // If the user presses STOP key, we also see VK_PAUSE,
                        // but WTS PC-98 keyboard layout doesn't have VK_PAUSE.
                        // In this case, we need to send VK_CONTROL and VK_CANCEL.
                        //
                        pMsg->wParam  = VK_CONTROL;
                        pMsg->lParam  = MAKELONG(0,
                                  MapVirtualKey(VK_CONTROL, 0));
                        IHAddEventToPDU(pMsg);

                        pMsg->wParam  = VK_CANCEL;
                        pMsg->lParam  = MAKELONG(0, 0x60);
                        IHAddEventToPDU(pMsg);

                        pMsg->message = WM_KEYUP;
                        pMsg->wParam  = VK_CONTROL;
                        pMsg->lParam  = MAKELONG(0,
                                  MapVirtualKey(VK_CONTROL, 0));
                        IHAddEventToPDU(pMsg);

                        pMsg->wParam  = VK_CANCEL;
                        pMsg->lParam  = MAKELONG(0, 0x60);
                        IHAddEventToPDU(pMsg);
                    }
#endif // OS_WINNT

                    /********************************************************/
                    /* Now that we've sent that fine key sequence we are    */
                    /* done.                                                */
                    /********************************************************/
                    DC_QUIT;
                }
                else if ((pMsg->wParam == VK_PAUSE) && (flags & KF_EXTENDED) &&
                         (_pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95) &&
                         ((_IH.dwModifierKeyState & IH_CTRL_MASK) &&
                          (_IH.dwModifierKeyState & IH_ALT_MASK)))
                {
                    //
                    // Hackery to work around Win9x problem. On Win9x a
                    // CTRL-ALT-NUMLOCK is received as a VK_PAUSE (Scancode 0x45)
                    // with the extended flag set. On NT this is received
                    // as a VK_NUMLOCK (also 0x45) with the extended flag set.
                    //
                    // Because of this difference in how the keys are interpreted
                    // numlock gets toggled on the server but not on the client
                    // (if running 9x). We fix that up by syncing the local state
                    // to match the server.
                    //
                    _IH.focusSyncRequired = TRUE;
                }
            }
            break;

#if defined(OS_WINNT)
            case VK_CANCEL:
            {
                TRC_DBG((TB, _T("VK_CANCEL down")));

                if ((pMsg->wParam == VK_CANCEL) && !(flags & KF_EXTENDED))
                {
                    if (_pUt->UT_IsNEC98platform() && _pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95) {
                        //
                        // NEC PC-98 Windows 95 platform
                        // If the user presses STOP key, we also see VK_CANCEL,
                        // but this platform doesn't send VK_CONTROL.
                        // In this case, we need to send VK_CONTROL and VK_CANCEL.
                        //
                        pMsg->wParam  = VK_CONTROL;
                        pMsg->lParam  = MAKELONG(0,
                                  MapVirtualKey(VK_CONTROL, 0));
                        IHAddEventToPDU(pMsg);

                        pMsg->wParam  = VK_CANCEL;
                        pMsg->lParam  = MAKELONG(0, 0x60);
                        IHAddEventToPDU(pMsg);

                        pMsg->message = WM_KEYUP;
                        pMsg->wParam  = VK_CONTROL;
                        pMsg->lParam  = MAKELONG(0,
                                  MapVirtualKey(VK_CONTROL, 0));
                        IHAddEventToPDU(pMsg);

                        pMsg->wParam  = VK_CANCEL;
                        pMsg->lParam  = MAKELONG(0, 0x60);
                        IHAddEventToPDU(pMsg);
                    }

                    /********************************************************/
                    /* Now that we've sent that fine key sequence we are    */
                    /* done.                                                */
                    /********************************************************/
                    DC_QUIT;
                }
            }
            break;
#endif // OS_WINNT

            case VK_SHIFT:
            {
                TRC_DBG((TB, _T("VK_SHIFT down")));
#ifndef OS_WINCE  // We don't want unnecessary checks for Windows CE
                /************************************************************/
                /* Win311 and Win9x are Evil.  If a shift key is generated, */
                /* it is always the RIGHT shift, regardless of which one is */
                /* actually down.  Here we ensure that the correct          */
                /* Shift-Down is sent to the Server.  Ack.                  */
                /*                                                          */
                /* As far as we know, this occurs only when NumLock is on.  */
                /*                                                          */
                /* Se the other half of this hack in the KEYUP case above.  */
                /************************************************************/
                if (((_pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95) ||
                     (_pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_31X)) &&
                        _IH.NumLock &&
                        (scancode == 0x36) &&
                        _IH.fWinEvilShiftHack )
                {
                    /********************************************************/
                    /* If we're doing the hack and the right shift is going */
                    /* down again, switch it over to the matching left      */
                    /* down.                                                */
                    /********************************************************/
                    TRC_NRM((TB, _T("Evil hack (2): switch right to left shift")));
                    scancode = 0x2a;
                    _IH.fWinEvilShiftHack = FALSE;
                }
#endif

                /************************************************************/
                /* Keep track of shift state                                */
                /************************************************************/
#if defined(OS_WINNT)
                if (scancode == 0x2a)
                {
                    _IH.dwModifierKeyState |= IH_LSHIFT_DOWN;
                }
                else
                {
                    if (_pUt->UT_IsNEC98platform() && _pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95) {
                        TRC_ASSERT((scancode == 0x70 || scancode == 0x7d),
                                   (TB,_T("Unexpected scancode %#x for VK_SHIFT"),
                                   scancode));
                    }
                    else
                    {
                        TRC_ASSERT((scancode == 0x36),
                                   (TB,_T("Unexpected scancode %#x for VK_SHIFT"),
                                   scancode));
                    }
                    _IH.dwModifierKeyState |= IH_RSHIFT_DOWN;
                }
#endif // OS_WINNT

                TRC_NRM((TB, _T("Shift down: new state %x"), _IH.dwModifierKeyState & IH_SHIFT_MASK));
            }
            break;

#ifdef OS_WINNT
            case VK_CONTROL:
            {
                TRC_DBG((TB, _T("VK_CONTROL down")));
                /********************************************************************/
                /* Keep track of Ctrl state                                         */
                /********************************************************************/
                _IH.dwModifierKeyState |= (flags & KF_EXTENDED) ?
                                IH_RCTRL_DOWN : IH_LCTRL_DOWN;
            }
            break;
#endif

#if defined(OS_WIN32)
            case VK_HANGUL:
            case VK_HANJA:
            {
                TRC_DBG((TB, _T("VK_HANGUL/VK_HANJA down")));
                IHProcessKoreanVKHangulHanja(&scancode, &flags);
            }
            break;
#endif

#ifdef OS_WINNT
            //
            // If we're hooking keys, we might send the Windows key as
            // a part of that feature. Originally, Citrix clients sent
            // the Windows key make key and had the server ignore it
            // because the client OS would eat the up (and show the Start
            // menu). There's a protocol flag to make it not eat the make
            // key which we turn on so we can send it, which means we'll
            // need to eat the windows key make if we don't plan to send
            // a windows key break
            //

            case VK_LWIN:
#ifndef OS_WINCE
                if (!_fUseHookBypass) {
#else
                if (!_fUseHookBypass && (g_CEConfig != CE_CONFIG_WBT)) {
#endif
                    DC_QUIT;
                } else {
                    _IH.dwModifierKeyState |= IH_LWIN_DOWN;
                }
                break;

            case VK_RWIN:
#ifndef OS_WINCE
                if (!_fUseHookBypass) {
#else
                if (!_fUseHookBypass && (g_CEConfig != CE_CONFIG_WBT)) {
#endif
                    DC_QUIT;
                } else {
                    _IH.dwModifierKeyState |= IH_RWIN_DOWN;
                }
                break;
#endif

            /****************************************************************/
            /* No default case - default is no special processing           */
            /****************************************************************/
        }
    }

    /************************************************************************/
    /* Special processing for NUMLOCK key (on both KEYDOWN and KEYUP)       */
    /************************************************************************/
    if (pMsg->wParam == VK_NUMLOCK)
    {
        /********************************************************************/
        /* Keep track of its state                                          */
        /********************************************************************/
        _IH.NumLock = (GetKeyState(VK_NUMLOCK) & IH_KEYSTATE_TOGGLED);
        TRC_NRM((TB, _T("NumLock is %s"), _IH.NumLock ? _T("on") : _T("off")));

        /********************************************************************/
        /* Don't set the EXTENDED flag for NumLock - if NumLock is injected */
        /* at the Server with KF_EXTENDED, it doesn't work.                 */
        /********************************************************************/
        flags &= ~KF_EXTENDED;
    }

    /************************************************************************/
    /* Never set KF_EXTENDED for VK_PAUSE key                               */
    /************************************************************************/
    if (pMsg->wParam == VK_PAUSE)
    {
        TRC_DBG((TB, _T("Clear KF_EXTENDED for VK_PAUSE")));
        flags &= ~KF_EXTENDED;
    }

    /************************************************************************/
    /* Rebuild lParam before passing it to IHAddEventToPDU                  */
    /************************************************************************/
    lParamHi = (WORD)(scancode | flags);
    pMsg->lParam = MAKELONG(lParamLo, lParamHi);

    /************************************************************************/
    /* Finally!  Add the event to the PDU                                   */
    /************************************************************************/
    IHAddEventToPDU(pMsg);

    /************************************************************************/
    /* If we get here, it's OK to look for more messages in the queue       */
    /************************************************************************/
    rc = TRUE;

DC_EXIT_POINT:
    /************************************************************************/
    /* Set the new Ctrl-Esc state                                           */
    /************************************************************************/
    TRC_DBG((TB, _T("New Ctrl-Esc state is %d"), fCtrlEscHotkey));
    _IH.fCtrlEscHotkey = fCtrlEscHotkey;

    /************************************************************************/
    /* Set the new Alt-down state                                           */
    /************************************************************************/
    TRC_DBG((TB, _T("New Alt-down state is %d"), fLastKeyWasMenuDown));
    _IH.fLastKeyWasMenuDown = fLastKeyWasMenuDown;

    TRC_DBG((TB,_T("IHProcessKeyboardEvent modifier post:0x%x"), _IH.dwModifierKeyState));

    DC_END_FN();
    return (rc);
} /* IHProcessKeyboardEvent */


/****************************************************************************/
/* Name:      IHProcessMouseEvent                                           */
/*                                                                          */
/* Purpose:   Handle mouse input events from Windows                        */
/*                                                                          */
/* Returns:   TRUE  - event processed, continue with next event             */
/*            FALSE - do not continue wih next event                        */
/*                                                                          */
/* Params:    pMsg  - message from Windows                                  */
/****************************************************************************/
DCBOOL DCINTERNAL CIH::IHProcessMouseEvent(PMSG pMsg)
{
    DCBOOL rc = TRUE;

#ifdef OS_WINCE
    HANDLE  hThread;
    DCBOOL  bRet;
#endif

    DC_BEGIN_FN("IHProcessMouseEvent");

#if !defined(OS_WINCE)
    TRC_NRM((TB, _T("%s (%#x), wParam %#x, lParam %#lx"),
        pMsg->message == WM_MOUSEMOVE     ? "WM_MOUSEMOVE"     :
        pMsg->message == WM_LBUTTONDOWN   ? "WM_LBUTTONDOWN"   :
        pMsg->message == WM_RBUTTONDOWN   ? "WM_RBUTTONDOWN"   :
        pMsg->message == WM_MBUTTONDOWN   ? "WM_MBUTTONDOWN"   :
        pMsg->message == WM_LBUTTONUP     ? "WM_LBUTTONUP"     :
        pMsg->message == WM_RBUTTONUP     ? "WM_RBUTTONUP"     :
        pMsg->message == WM_MBUTTONUP     ? "WM_MBUTTONUP"     :
        pMsg->message == WM_LBUTTONDBLCLK ? "WM_LBUTTONDBLCLK" :
        pMsg->message == WM_RBUTTONDBLCLK ? "WM_RBUTTONDBLCLK" :
        pMsg->message == WM_MBUTTONDBLCLK ? "WM_MBUTTONDBLCLK" :
        pMsg->message == WM_MOUSEWHEEL    ? "WM_MOUSEWHEEL"    :
        pMsg->message == WM_XBUTTONDOWN   ? "WM_XBUTTONDOWN"   :
        pMsg->message == WM_XBUTTONUP     ? "WM_XBUTTONUP"     :
        pMsg->message == WM_XBUTTONDBLCLK ? "WM_XBUTTONDBLCLK" :
                                            "Unknown msg",
        pMsg->message, pMsg->wParam, pMsg->lParam));
#else
    TRC_NRM((TB, _T("%s (%#x), wParam %#x, lParam %#lx"),
        pMsg->message == WM_MOUSEMOVE     ? "WM_MOUSEMOVE"     :
        pMsg->message == WM_LBUTTONDOWN   ? "WM_LBUTTONDOWN"   :
        pMsg->message == WM_RBUTTONDOWN   ? "WM_RBUTTONDOWN"   :
        pMsg->message == WM_MBUTTONDOWN   ? "WM_MBUTTONDOWN"   :
        pMsg->message == WM_LBUTTONUP     ? "WM_LBUTTONUP"     :
        pMsg->message == WM_RBUTTONUP     ? "WM_RBUTTONUP"     :
        pMsg->message == WM_MBUTTONUP     ? "WM_MBUTTONUP"     :
        pMsg->message == WM_LBUTTONDBLCLK ? "WM_LBUTTONDBLCLK" :
        pMsg->message == WM_RBUTTONDBLCLK ? "WM_RBUTTONDBLCLK" :
        pMsg->message == WM_MBUTTONDBLCLK ? "WM_MBUTTONDBLCLK" :
                                            "Unknown msg",
        pMsg->message, pMsg->wParam, pMsg->lParam));
#endif

#ifdef OS_WIN32
    /************************************************************************/
    /* Delay sending mouse-downs until either another message arrives or    */
    /* IH_PENDMOUSE_DELAY elapses - only for Win95 though.                  */
    /************************************************************************/
    if (_pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95)
    {
        if ((pMsg->message == WM_LBUTTONDOWN) ||
            (pMsg->message == WM_MBUTTONDOWN) ||
            (pMsg->message == WM_RBUTTONDOWN))
        {
            TRC_DBG((TB, _T("Setting pendMouseDown to TRUE; ")
                         _T("starting pendmouse timer")));
            _IH.pendMouseDown = TRUE;
            _IH.mouseDownTime = _pUt->UT_GetCurrentTimeMS();

            /****************************************************************/
            /* This timer will kick us in 200ms to make sure we send our    */
            /* mouse-down.                                                  */
            /****************************************************************/
            _IH.pendMouseTimer = SetTimer(_IH.inputCaptureWindow,
                                         IH_PENDMOUSE_TIMER_ID,
                                         IH_PENDMOUSE_DELAY,
                                         NULL);
        }
        else
        {
            TRC_DBG((TB, _T("Setting pendMouseDown to FALSE; ")
                         _T("killing pendmouse timer")));
            _IH.pendMouseDown = FALSE;
            if (_IH.pendMouseTimer != 0)
            {
                KillTimer(_IH.inputCaptureWindow, _IH.pendMouseTimer);
            }
        }
    }
#endif

    /************************************************************************/
    /* Capture / release the mouse as required.                             */
    /************************************************************************/
    if ((pMsg->message == WM_LBUTTONDOWN) ||
        (pMsg->message == WM_MBUTTONDOWN) ||
        (pMsg->message == WM_RBUTTONDOWN))
    {
        TRC_DBG((TB, _T("Get capture")));
        SetCapture(_IH.inputCaptureWindow);
    }
    else if ((pMsg->message == WM_LBUTTONUP) ||
             (pMsg->message == WM_MBUTTONUP) ||
             (pMsg->message == WM_RBUTTONUP))
    {
        TRC_DBG((TB, _T("Release capture")));
        ReleaseCapture();
    }
#ifdef OS_WINCE
    if (_IH.maxMouseMove)
    {
        /************************************************************************/
        /* Set global attribute to show LMouse Button state                     */
        /************************************************************************/
        if (pMsg->message == WM_LBUTTONDOWN)
        {
            TRC_DBG((TB, _T("Set MouseDown")));
            _IH.bLMouseButtonDown = TRUE;

            /************************************************************************/
            /* Bump the thread priority so we get better mouse move data            */
            /************************************************************************/
            hThread = GetCurrentThread();
            if (NULL != hThread)
            {
                bRet = SetThreadPriority(hThread, THREAD_PRIORITY_ABOVE_NORMAL);
            }
        }
        else if (pMsg->message == WM_LBUTTONUP)
        {
            TRC_DBG((TB, _T("Set MouseUp")));
            _IH.bLMouseButtonDown = FALSE;

            /************************************************************************/
            /* Reset the thread back to normal                                      */
            /************************************************************************/
            hThread = GetCurrentThread();
            if (NULL != hThread)
            {
                bRet = SetThreadPriority(hThread, THREAD_PRIORITY_NORMAL);
            }
        }
    }
#endif  //OS_WINCE

    /************************************************************************/
    /* Add the event to the PDU                                             */
    /************************************************************************/
    IHAddEventToPDU(pMsg);

    /************************************************************************/
    /* Always go on to look for more messages                               */
    /************************************************************************/
    rc = TRUE;

    DC_END_FN();
    return (rc);
} /* IHProcessMouseEvent */


#if (!defined(OS_WINCE)) || (!defined(WINCE_SDKBUILD))
/****************************************************************************/
/* Name:      IHStaticLowLevelKeyboardProc                                  */
/*                                                                          */
/* Purpose:   Notice keyboard input that can't be captured normally         */
/*                                                                          */
/* Returns:   TRUE  - event processed, continue with next event             */
/*            FALSE - do not continue wih next event                        */
/*                                                                          */
/* Params:    pMsg  - message from Windows                                  */
/****************************************************************************/
LRESULT CALLBACK CIH::IHStaticLowLevelKeyboardProc(int nCode, WPARAM wParam,
        LPARAM lParam)
{
    LRESULT rc;
    CIH *tpIH = NULL;

    DC_BEGIN_FN("CIH::IHStaticLowLevelKeyboardProc");

    TRC_ASSERT(CIH::TlsIndex != 0xFFFFFFFF, (TB, _T("In hook with no TlsIndex")));

    tpIH = (CIH *)TlsGetValue(CIH::TlsIndex);
    TRC_ASSERT(tpIH != NULL, (TB, _T("Keyboard Hook with no tpIH")));

    //
    // Just call the non static one
    //
    rc = tpIH->IHLowLevelKeyboardProc(nCode, wParam, lParam);

    DC_END_FN();

    return rc;
}

/****************************************************************************/
/* Name:      IHLowLevelKeyboardProc                                        */
/*                                                                          */
/* Purpose:   Notice keyboard input that can't be captured normally         */
/*                                                                          */
/* Returns:   TRUE  - event processed, continue with next event             */
/*            FALSE - do not continue wih next event                        */
/*                                                                          */
/* Params:    pMsg  - message from Windows                                  */
/****************************************************************************/
LRESULT CIH::IHLowLevelKeyboardProc(int nCode, WPARAM wParam,
        LPARAM lParam)
{
    LRESULT rc = 1;
    PKBDLLHOOKSTRUCT pkbdhs = NULL;
    LPARAM outLParam = 0;
    WORD flags = 0;
    DWORD dwForegroundProcessId;
    BOOL fDoDefaultKeyProcessing = TRUE;
    BOOL fSelfInjectedKey = FALSE;

    DC_BEGIN_FN("CIH::IHLowLevelKeyboardProc");

    //
    // ****   Big Scary Comment   ****
    // This is a performance critical area. This gets run every keystroke
    // in the (typically console) session, so try to organize any ifs or
    // other logic to bail out quickly.
    // **** End Big Scary Comment ****
    //

    if (nCode == HC_ACTION) {

        //
        // Chance to look for keys and take action
        //

        TRC_DBG((TB, _T("Keyboard hook called with HC_ACTION code")));

        pkbdhs = (PKBDLLHOOKSTRUCT)lParam;
#ifndef OS_WINCE
        TRC_DBG((TB, _T("hook vk: 0x%04x sc: 0x%04x char:(%c) A/E/U: %d/%d/%d"),
                 pkbdhs->vkCode,
                 pkbdhs->scanCode,
                 pkbdhs->vkCode,
                 (pkbdhs->flags & LLKHF_ALTDOWN) != 0,
                 (pkbdhs->flags & LLKHF_EXTENDED) != 0,
                 (pkbdhs->flags & LLKHF_UP) != 0));
#endif

        GetWindowThreadProcessId( GetForegroundWindow(),
                &dwForegroundProcessId);
        if ((GetCurrentProcessId() == dwForegroundProcessId) &&
                (GetFocus() == _IH.inputCaptureWindow)) {

            fSelfInjectedKey = (pkbdhs->dwExtraInfo == IH_EXTRAINFO_IGNOREVALUE);

            //
            // Always discard self-injected keys
            // Otherwise do special handling if we're hooking or if it's a VK_PACKET
            //
            // The processing will convert the pkbdhs to a message that will
            // be posted to the IH's window proc for normal processing
            //
            if (!fSelfInjectedKey &&
                (_fUseHookBypass || pkbdhs->vkCode == VK_PACKET)) {

                switch (pkbdhs->vkCode) {
                    // Three LED keys
                case VK_CAPITAL:
                case VK_NUMLOCK:
                case VK_SCROLL:
                    // Other state keys
                case VK_KANA:
                    // Other modifiers, shift/control/alt
                case VK_SHIFT:
                case VK_LSHIFT:
                case VK_RSHIFT:
                case VK_CONTROL:
                case VK_LCONTROL:
                case VK_RCONTROL:
                case VK_MENU:
                case VK_LMENU:
                case VK_RMENU:
                    fDoDefaultKeyProcessing = FALSE;
                    break;

#ifndef OS_WINCE
                //
                // Skip Windows+L to make sure the local console
                // gets locked by that key combination
                //
                case VK_l: // intentional fallthru
                case VK_L:
                    {
                        //
                        // We make sure none of the other modifiers are down
                        // otherwise it's not a real Windows+L hotkey
                        //
                        // Note: We can't use GetAsyncKeyState(VK_LWIN)
                        //       because it doesn't work in a LL hook!
                        //
                        if ((_IH.dwModifierKeyState & IH_WIN_MASK)              &&
                             !(GetAsyncKeyState(VK_CONTROL) & IH_KEYSTATE_DOWN) &&
                             !(GetAsyncKeyState(VK_MENU) & IH_KEYSTATE_DOWN)    &&
                             !(GetAsyncKeyState(VK_SHIFT) & IH_KEYSTATE_DOWN)) {

                            //
                            // WindowsKey+L must be handled locally to ensure
                            // the local desktop is locked so don't send to server
                            //

                            TRC_NRM((TB, _T("Hook skipping Windows+L!")));

                            //
                            // Defer the tail processing to avoid spending a
                            // lot of time in the hook.
                            //
                            // We only want to do the work once so on keydown.
                            //
                            if (!(pkbdhs->flags & LLKHF_UP)) {
                                TRC_NRM((TB, _T("Posting to process Win+L")));
                                PostMessage(_IH.inputCaptureWindow,
                                            IH_WM_HANDLE_LOCKDESKTOP,
                                            0, 0);
                            }

                            fDoDefaultKeyProcessing = FALSE;

                            //
                            // Bail out completely to eat the 'L'
                            //
                            DC_QUIT;
                        }
                        else {
                            TRC_DBG((TB, _T("Normal 'l' handling will send")));
                        }
                    }
                    break;
#endif

                case VK_DELETE:
                    {
                        TRC_DBG((TB, _T("VK_DELETE pressed 0x%x, 0x%x"),
                                ((GetAsyncKeyState(VK_MENU) & IH_KEYSTATE_DOWN)) != 0,
                                (GetAsyncKeyState(VK_CONTROL) & IH_KEYSTATE_DOWN) != 0));

                        if ((GetAsyncKeyState(VK_MENU) & IH_KEYSTATE_DOWN) &&
                            (GetAsyncKeyState(VK_CONTROL) & IH_KEYSTATE_DOWN)) {

                            //
                            // This is Ctrl+Alt+Del, which can't be blocked.
                            // Getting Two SAS sequences for this would be
                            // confusing, so don't send that on to the IH
                            //

                            TRC_DBG((TB, _T("Skipping VK_DELETE with Ctrl and Alt down")));
                            fDoDefaultKeyProcessing = FALSE;

                        } else {

                            //
                            // Fall through to default processing for all other
                            // VK_DELETE events.
                            //
                            TRC_DBG((TB, _T("Normal VK_DELETE, sending to server")));
                        }
                    }
                    break;
                } // switch

                if (fDoDefaultKeyProcessing) {
#ifndef OS_WINCE
                    if (pkbdhs->flags & LLKHF_EXTENDED) {
                        flags |= KF_EXTENDED;
                    }

                    if (pkbdhs->flags & LLKHF_ALTDOWN) {
                        flags |= KF_ALTDOWN;
                    }

                    if (pkbdhs->flags & LLKHF_UP) {
                        flags |= KF_UP;
                    }

                    if (pkbdhs->vkCode != VK_PACKET)
                    {
                        outLParam = MAKELONG(1,
                                             ((WORD)pkbdhs->scanCode | flags));
                    }
                    else
                    {
                        outLParam = MAKELONG(1, ((WORD)pkbdhs->scanCode));
						//TRC_ERR((TB,_T("VK_PACKET: scan:0x%x"),pkbdhs->scanCode));
                    }
                    
#else
                    if ((pkbdhs->vkCode == VK_LWIN) || (pkbdhs->vkCode == VK_RWIN) || (pkbdhs->vkCode == VK_APPS)) {
                        flags |= KF_EXTENDED;
                    }
                    if (GetAsyncKeyState(VK_MENU) & IH_KEYSTATE_DOWN) {
                        flags |= KF_ALTDOWN;
                    }

                    if (wParam == WM_KEYUP) {
                        flags |= KF_UP;
                    }

                    if (pkbdhs->vkCode != VK_PACKET)
                    {
                        outLParam = MAKELONG(1, ((BYTE)pkbdhs->scanCode | flags));
                    }
                    else
                    {
                        outLParam = MAKELONG(1, ((BYTE)pkbdhs->scanCode));
                    }
#endif
                    
#ifndef OS_WINCE
                    if ((pkbdhs->flags & LLKHF_UP) && 
#else
                    if ((wParam == WM_KEYUP) && 
#endif
                            BITTEST(_KeyboardState, (BYTE)pkbdhs->vkCode)) {
                        //
                        // Key was pressed when we gained the focus, let the key up
                        // go through.
                        //
                        TRC_DBG((TB,_T("Allowing normal keypress to update keystate table")));
                        BITCLEAR(_KeyboardState, (BYTE)pkbdhs->vkCode);
                    } else {

                        if (PostMessage(_IH.inputCaptureWindow, wParam,
                                        pkbdhs->vkCode, outLParam)) {
                            DC_QUIT;
                        }
                        else {
                            TRC_SYSTEM_ERROR("PostThreadMessage in keyboard hook");
                        }
                    }
                } // if fDoDefaultKeyProcessing

            }
            else if (fSelfInjectedKey) {

                //
                // Just let the system handle any self-injected keys
                // Note: they could be posted to our message queue
                //       so we also check for the ignore flag there
                //
                TRC_DBG((TB,_T("Discard self injected key vk:0x%x")
                         _T("dwIgnore: 0x%x flags:0x%x"),
                         pkbdhs->vkCode,
                         pkbdhs->dwExtraInfo,
                         pkbdhs->flags));
            }
            else {
                //
                // We're not using hooks but we still leverage the hook to fix
                // an alt-space problem
                //
                switch (pkbdhs->vkCode) {
                case VK_SPACE:
                    if ((GetAsyncKeyState(VK_MENU) & IH_KEYSTATE_DOWN) &&
                            !(GetAsyncKeyState(VK_CONTROL) & IH_KEYSTATE_DOWN) &&
                            !(GetAsyncKeyState(VK_SHIFT) & IH_KEYSTATE_DOWN))
                    {
                        // Alt-Space!
                        //
                        // Queue a focus sync so that when the menu is dismissed
                        // we resync focus. (Prevents stuck alt key bug).
                        //
                        _IH.focusSyncRequired = TRUE;
                    }
                    break;

                }
            }
        } // if current process and focus
    } else {

        //
        // Not supposed to do anything but call the next hook
        //

        TRC_DBG((TB, _T("Keyboard hook called with non-HC_ACTION code")));
    }

    rc = CallNextHookEx(_hKeyboardHook, nCode, wParam, lParam);

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}
#endif

/****************************************************************************/
/* Name:      IHGatherKeyState                                              */
/*                                                                          */
/* Purpose:   Once the focus is gained, no keyup sequences will be seen     */
/*            locally, which may causes some strange behavior. Track which  */
/*            keys to allow back up after gaining the focus                 */
/*                                                                          */
/* Returns:   TRUE  - event processed, continue with next event             */
/*            FALSE - do not continue wih next event                        */
/*                                                                          */
/* Params:    pMsg  - message from Windows                                  */
/****************************************************************************/
VOID CIH::IHGatherKeyState()
{
    int i;

    DC_BEGIN_FN("CIH::IHGatherKeyState");

    for (i = 0; i < 256; i++) {
        if (GetAsyncKeyState(i) & IH_KEYSTATE_DOWN) {
            BITSET(_KeyboardState, i);
        } else {
            BITCLEAR(_KeyboardState, i);
        }
    }

    DC_END_FN();
}

VOID CIH::IHMaintainModifierKeyState(int vkKey)
/*
    IHMaintainModifierKeyState

    Purpose: Keep up the correct modifier key states by comparing our internal
    state (and therefore what the server should think) with what the local
    system will tell us. If these are out of sync, we should get them together
*/
{
    int vkShift, vkControl, vkMenu, vkWin;

    // ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*
    // IMPORTANT NOTE: 
    // When hooking is on we eat certain keys in the LL keyboard hook. In that
    // case win32k does not update the keyboard state so it is not valid
    // to call GetAsyncKeyState() or GetKeyState() on those keys. The prime
    // example is the VK_LWIN, VK_RWIN keys that we eat to prevent double
    // start menus.
    // 

    //
    // We call this thing every key stroke, so we try to use some quick 
    // checks to bail out early. We only have problems with modifiers getting
    // stuck down, so we only make calls to the system if we think they are 
    // down.
    //
    DC_BEGIN_FN("IHMaintainModifierKeyState");

    TRC_DBG((TB,_T("Maintain dwMod prev: 0x%x"), _IH.dwModifierKeyState));

    switch (vkKey)
    {
    case VK_SHIFT:
    case VK_CONTROL:
    case VK_MENU:
    case VK_LWIN:
    case VK_RWIN:

        //
        // Don't try to fix the keystate while it's changing
        //
        DC_QUIT;
    }


    //
    // GetKeyState doesn't work correctly on 9x for the right-side modifier
    // keys, so do the generic left hand thing first for everybody
    //
    
    if(_pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_NT) {

        //
        // NT systems check the specific key
        //

        vkShift = VK_LSHIFT;
        vkControl = VK_LCONTROL;
        vkMenu = VK_LMENU;
    } else {

        //
        // Win9x systems check the general key
        //

        vkShift = VK_SHIFT;
        vkControl = VK_CONTROL;
        vkMenu = VK_MENU;
    }

    if (_IH.dwModifierKeyState & IH_LSHIFT_DOWN) {
        if (!(GetKeyState(vkShift) & IH_KEYSTATE_DOWN)) {
            TRC_DBG((TB, _T("Add left-Shift up event")));
            IHInjectVKey(WM_KEYUP, vkShift);
            _IH.dwModifierKeyState &= ~IH_LSHIFT_DOWN;
        }
    }

    if (_IH.dwModifierKeyState & IH_LCTRL_DOWN) {
        if (!(GetKeyState(vkControl) & IH_KEYSTATE_DOWN)) {
            TRC_DBG((TB, _T("Add left-Ctrl up event")));
            IHInjectVKey(WM_KEYUP, vkControl);
#ifdef OS_WINNT
            _IH.dwModifierKeyState &= ~IH_LCTRL_DOWN;
#endif
        }
    }

    if (_IH.dwModifierKeyState & IH_LALT_DOWN) {
        if (!(GetKeyState(vkMenu) & IH_KEYSTATE_DOWN)) {
            TRC_DBG((TB, _T("Add left-ALT up event")));
            IHInjectVKey(WM_KEYUP, vkMenu);
#ifdef OS_WINNT
            _IH.dwModifierKeyState &= ~IH_LALT_DOWN;
#endif
        }
    }

    vkWin = VK_LWIN;
    //
    // Can only fixup winkeys when not hooking as the hook eats the VK_xWIN
    // so GetKeyState() will never return the correct results.
    //
    if (_IH.dwModifierKeyState & IH_LWIN_DOWN && !_fUseHookBypass) {

        if (!(GetKeyState(vkWin) & IH_KEYSTATE_DOWN)) {
            TRC_DBG((TB, _T("Add left-Win up event")));
            IHInjectKey(WM_KEYUP, VK_LWIN,(UINT16)
                        (MapVirtualKey(VK_LWIN, 0) | KF_EXTENDED));
#ifdef OS_WINNT
            _IH.dwModifierKeyState &= ~IH_LWIN_DOWN;
#endif
        }
    }


    //
    // Right keys
    //

    if(_pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_NT) {

        //
        // NT systems check the specific key
        //

        vkShift = VK_RSHIFT;
        vkControl = VK_RCONTROL;
        vkMenu = VK_RMENU;
    } else {

        //
        // Win9x systems check the general key
        //

        // which are already set, no need to assign again
    }

    //
    // Windows Key is fine on both platforms
    //
    vkWin = VK_RWIN;

    if (_IH.dwModifierKeyState & IH_RSHIFT_DOWN) {
        if (!(GetKeyState(vkShift) & IH_KEYSTATE_DOWN)) {
            TRC_DBG((TB, _T("Add right-Shift up event")));
            IHInjectKey(WM_KEYUP, VK_RSHIFT, (UINT16)IH_RSHIFT_SCANCODE);
            _IH.dwModifierKeyState &= ~IH_RSHIFT_DOWN;
        }
    }

    if (_IH.dwModifierKeyState & IH_RCTRL_DOWN) {
        if (!(GetKeyState(vkControl) & IH_KEYSTATE_DOWN)) {
            TRC_DBG((TB, _T("Add right-Ctrl up event")));
            IHInjectKey(WM_KEYUP, VK_RCONTROL,
                    (UINT16)(MapVirtualKey(VK_CONTROL, 0) | KF_EXTENDED));
#ifdef OS_WINNT
            _IH.dwModifierKeyState &= ~IH_RCTRL_DOWN;
#endif
        }
    }

    if (_IH.dwModifierKeyState & IH_RALT_DOWN) {
        if (!(GetKeyState(vkMenu) & IH_KEYSTATE_DOWN)) {
            TRC_DBG((TB, _T("Add right-ALT up event")));
            IHInjectKey(WM_KEYUP, VK_RMENU,
                    (UINT16)(MapVirtualKey(VK_MENU, 0) | KF_EXTENDED));
#ifdef OS_WINNT
            _IH.dwModifierKeyState &= ~IH_RALT_DOWN;
#endif
        }
    }

    //
    // Can only fixup winkeys when not hooking as the hook eats the VK_WINS
    // so GetKeyState() will never return the correct results.
    //
    if (_IH.dwModifierKeyState & IH_RWIN_DOWN && !_fUseHookBypass) {
        if (!(GetKeyState(vkWin) & IH_KEYSTATE_DOWN)) {
            TRC_DBG((TB, _T("Add right-Win up event")));
            IHInjectKey(WM_KEYUP, VK_RWIN,(UINT16)
                        (MapVirtualKey(VK_RWIN, 0) | KF_EXTENDED));

#ifdef OS_WINNT
            _IH.dwModifierKeyState &= ~IH_RWIN_DOWN;
#endif
        }
    }


DC_EXIT_POINT:
    DC_END_FN();
}

#ifdef OS_WINNT
//
// IHHandleLocalLockDesktop
//
// Called to do tail processing for the case when we detect and eat a 
// 'Windows+L' key request. In this case we want to
//
// 1) Fixup the remote windows key state
// 2) Send the local system a 'Windows+L' combo
//
VOID CIH::IHHandleLocalLockDesktop()
{
    DC_BEGIN_FN("IHHandleLocalLockDesktop");

#define IH_SCANCODE_LWIN 0x5b
#define IH_SCANCODE_L    0x26

    //
    // Sanity check. This path should only be entered in response to a
    // captured windows+L in the LL hook 
    //
    TRC_ASSERT(_fUseHookBypass,
               (TB,_T("IHHandleLocalLockDesktop called when not hooking!")));

    //
    // More IH specialness.
    //
    // If the server thinks the windows key was down
    // we have a problem because if/when the user returns from
    // the locked screen the windows key may be out of sync.
    //
    // We can't do a fixup in the normal MaintainModifiers() code
    // because GetKeyState() doesn't work when hooking.
    //
    // Send the following sequence to clear this up
    // -UP whatever winkey was down
    // -Down L-winkey
    //

    //
    // Inject local keys back into system.
    // IMPORTANT: dwExtraFlag is set to prevent feedback
    //
    TRC_DBG((TB,_T("Done injecting local Windows+L")));

    //LWIN down
    keybd_event(VK_LWIN, IH_SCANCODE_LWIN,
                KEYEVENTF_EXTENDEDKEY | 0,
                IH_EXTRAINFO_IGNOREVALUE);
    //'L' down
    keybd_event(VK_L, IH_SCANCODE_L,
                0, IH_EXTRAINFO_IGNOREVALUE);
    //'L' up
    keybd_event(VK_L, IH_SCANCODE_L,
                KEYEVENTF_KEYUP,
                IH_EXTRAINFO_IGNOREVALUE);
    //LWIN up
    keybd_event(VK_LWIN, IH_SCANCODE_LWIN,
                KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP,
                IH_EXTRAINFO_IGNOREVALUE);

    TRC_DBG((TB,_T("Done injecting local Windows+L")));

    if (_IH.dwModifierKeyState & IH_LWIN_DOWN) {
        TRC_DBG((TB,_T("Fixing up left windows key")));

        IHInjectVKey(WM_KEYDOWN, VK_SHIFT);
        IHInjectVKey(WM_KEYUP, VK_SHIFT);
        IHInjectKey(WM_KEYUP, VK_LWIN,(UINT16)
                 (MapVirtualKey(VK_LWIN, 0) | KF_EXTENDED | KF_UP));

        _IH.dwModifierKeyState &= ~IH_LWIN_DOWN;
    }
    
    if (_IH.dwModifierKeyState & IH_RWIN_DOWN) {
        TRC_DBG((TB,_T("Fixing up right windows key")));

        IHInjectVKey(WM_KEYDOWN, VK_SHIFT);
        IHInjectVKey(WM_KEYUP, VK_SHIFT);
        
        IHInjectKey(WM_KEYUP, VK_RWIN,
                 (UINT16)(MapVirtualKey(VK_RWIN, 0) | KF_EXTENDED | KF_UP));
        _IH.dwModifierKeyState &= ~IH_RWIN_DOWN;
        
    }

    TRC_DBG((TB,_T("End fixup remote windows key")));

    IHMaybeSendPDU();
    
    DC_END_FN();
}


BOOL
CIH::IHIsForegroundWindow()
{
    DWORD dwForegroundProcessId;
    BOOL  fIsFore = FALSE;
    DC_BEGIN_FN("IHIsForegroundWindow");

    GetWindowThreadProcessId( GetForegroundWindow(),
            &dwForegroundProcessId);
    if ((GetCurrentProcessId() == dwForegroundProcessId) &&
        (GetFocus() == _IH.inputCaptureWindow)) {
        fIsFore = TRUE;
    }

    DC_END_FN();
    return fIsFore;
}
#endif //OS_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\mcs.h ===
/****************************************************************************/
// mcs.h
//
// MCS Class header file
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/

#ifndef _H_MCS
#define _H_MCS

extern "C" {
    #include <adcgdata.h>
}
#include "objs.h"
#include "cd.h"

#define TRC_FILE    "mcs"
#define TRC_GROUP   TRC_GROUP_NETWORK

//    This constant is the equivalent with the one defined by the mcsimpl.h on 
//    the servers side. The meaning of it is the fact that the input buffers
//    have to be actually bigger with 8 bytes to avoid any overread in the 
//    decompression routines. The decompression function does not strictly 
//    check the input pointers for overread (for performance reasons) so it
//    can overread a maximum of 7 bytes. The bias will make the input buffer
//    8 bytes bigger so the overread can't happen.
#define MCS_INPUT_BUFFER_BIAS 8

/****************************************************************************/
/* MCS result codes.                                                        */
/****************************************************************************/
#define MCS_RESULT_SUCCESSFUL                       0
#define MCS_RESULT_DOMAIN_MERGING                   1
#define MCS_RESULT_DOMAIN_NOT_HIERARCHICAL          2
#define MCS_RESULT_NO_SUCH_CHANNEL                  3
#define MCS_RESULT_NO_SUCH_DOMAIN                   4
#define MCS_RESULT_NO_SUCH_USER                     5
#define MCS_RESULT_NOT_ADMITTED                     6
#define MCS_RESULT_OTHER_USER_ID                    7
#define MCS_RESULT_PARAMETERS_UNACCEPTABLE          8
#define MCS_RESULT_TOKEN_NOT_AVAILABLE              9
#define MCS_RESULT_TOKEN_NOT_POSSESSED              10
#define MCS_RESULT_TOO_MANY_CHANNELS                11
#define MCS_RESULT_TOO_MANY_TOKENS                  12
#define MCS_RESULT_TOO_MANY_USERS                   13
#define MCS_RESULT_UNSPECIFIED_FAILURE              14
#define MCS_RESULT_USER_REJECTED                    15


/****************************************************************************/
/* MCS reason codes.                                                        */
/****************************************************************************/
#define MCS_REASON_DOMAIN_DISCONNECTED              0
#define MCS_REASON_PROVIDER_INITIATED               1
#define MCS_REASON_TOKEN_PURGED                     2
#define MCS_REASON_USER_REQUESTED                   3
#define MCS_REASON_CHANNEL_PURGED                   4


/****************************************************************************/
/* Buffer handle (returned on MCS_GetBuffer).                               */
/****************************************************************************/
typedef ULONG_PTR           MCS_BUFHND;
typedef MCS_BUFHND   DCPTR PMCS_BUFHND;


#define MCS_INVALID_CHANNEL_ID                      0xFFFF


/****************************************************************************/
// MCS_SetDataLengthToReceive
//
// Mcro to allow XT to set up the required length for MCS data buffer
// reception.
/****************************************************************************/
#define MCS_SetDataLengthToReceive(mcsinst, len) \
    (##mcsinst)->_MCS.dataBytesNeeded = (len);  \
    (##mcsinst)->_MCS.dataBytesRead = 0;


/****************************************************************************/
// MCS_RecvToDataBuf
//
// Receives data into the MCS data buffer. Implemented as a macro for speed
// and for easy use within XT for fast-path output receives.  rc is:
//   S_OK if all the data is finished.
//   S_FALSE if there is more data.
//   E_* if an error occurred.
/****************************************************************************/
#define MCS_RecvToDataBuf(rc, xtinst, mcsinst) {  \
    unsigned bytesRecv;  \
\
    /* Make sure that we're expected to receive some data. */  \
    TRC_ASSERT(((mcsinst)->_MCS.dataBytesNeeded != 0), (TB, _T("No data to receive")));  \
    TRC_ASSERT(((mcsinst)->_MCS.dataBytesNeeded < 65535),  \
            (TB,_T("Data recv size %u too large"), (mcsinst)->_MCS.dataBytesNeeded));  \
    TRC_ASSERT(((mcsinst)->_MCS.pReceivedPacket != NULL),  \
            (TB, _T("Null rcv packet buffer")));  \
\
    if (((mcsinst)->_MCS.dataBytesRead + (mcsinst)->_MCS.dataBytesNeeded <= \
            sizeof((mcsinst)->_MCS.dataBuf) - 2 - MCS_INPUT_BUFFER_BIAS)) \
    { \
        /* Get some data into the data buffer. */  \
        bytesRecv = ##xtinst->XT_Recv((mcsinst)->_MCS.pReceivedPacket + (mcsinst)->_MCS.dataBytesRead,  \
                (mcsinst)->_MCS.dataBytesNeeded);  \
        TRC_ASSERT((bytesRecv <= (mcsinst)->_MCS.dataBytesNeeded),  \
                (TB,_T("XT_Recv returned more bytes read (%u) than requested (%u)"),  \
                bytesRecv, (mcsinst)->_MCS.dataBytesNeeded));  \
        (mcsinst)->_MCS.dataBytesNeeded -= bytesRecv;  \
        (mcsinst)->_MCS.dataBytesRead   += bytesRecv;  \
        rc = ((mcsinst)->_MCS.dataBytesNeeded == 0) ? S_OK : S_FALSE; \
    } \
    else \
    { \
        TRC_ABORT((TB, _T("Data buffer size %u too small for %u read + %u needed"),  \
        sizeof((mcsinst)->_MCS.dataBuf) - 2 - MCS_INPUT_BUFFER_BIAS,  \
        (mcsinst)->_MCS.dataBytesRead,  \
        (mcsinst)->_MCS.dataBytesNeeded)); \
        rc = E_ABORT; \
    } \
}



//
// Internal use
//

/****************************************************************************/
/*                                                                          */
/* DEFINITIONS                                                              */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* MCS receive state variables.                                             */
/****************************************************************************/
#define MCS_RCVST_PDUENCODING                   1
#define MCS_RCVST_BERHEADER                     2
#define MCS_RCVST_BERLENGTH                     3
#define MCS_RCVST_CONTROL                       4
#define MCS_RCVST_DATA                          5

/****************************************************************************/
/* MCS receive data state variables.                                        */
/****************************************************************************/
#define MCS_DATAST_SIZE1                        1
#define MCS_DATAST_SIZE2                        2
#define MCS_DATAST_SIZE3                        3
#define MCS_DATAST_READFRAG                     4
#define MCS_DATAST_READREMAINDER                5

/****************************************************************************/
/* Number of bytes required to determine the MCS PDU encoding.              */
/****************************************************************************/
#define MCS_NUM_PDUENCODING_BYTES               1

/****************************************************************************/
/* Size of the common part of an MCS header.                                */
/****************************************************************************/
#define MCS_SIZE_HEADER                         3

/****************************************************************************/
/* The MCS BER connect PDU prefix.                                          */
/****************************************************************************/
#define MCS_BER_CONNECT_PREFIX                  0x7F

/****************************************************************************/
/* Maximum length of the size data in a PER encoded MCS PDU.                */
/****************************************************************************/
#define MCS_MAX_SIZE_DATA_LENGTH                2

/****************************************************************************/
/* Maximum length of a MCS header.                                          */
/****************************************************************************/
#define MCS_DEFAULT_HEADER_LENGTH                   4096

/****************************************************************************/
/* Maximum length of a T.Share packet.                                      */
/****************************************************************************/
#ifdef DC_HICOLOR
#define MCS_MAX_RCVPKT_LENGTH                   (1024*16)
#else
#define MCS_MAX_RCVPKT_LENGTH                   (1024*12)
#endif

/****************************************************************************/
/* Maximum length of a MCS packet to be sent.                               */
/****************************************************************************/
#define MCS_MAX_SNDPKT_LENGTH                   16384

/****************************************************************************/
/* MCS user IDs are encoded as constrained integers in the range            */
/* 1001-65535.  The packed encoding rules (PER) encoded this as an integer  */
/* starting at 0, so we need this constant in decode/encode user-ids.       */
/****************************************************************************/
#define MCS_USERID_PER_OFFSET                   1001

/****************************************************************************/
/* Number of fields in a MCS connect-response PDU.                          */
/****************************************************************************/
#define MCS_CRPDU_NUMFIELDS                     4

/****************************************************************************/
/* Field offsets within a MCS connect-response PDU.                         */
/****************************************************************************/
#define MCS_CRPDU_RESULTOFFSET                  0
#define MCS_CRPDU_USERDATAOFFSET                3

/****************************************************************************/
/* Length of the connect-response result field.                             */
/****************************************************************************/
#define MCS_CR_RESULTLEN                        1

/****************************************************************************/
/* PER encoded field lengths and masks.  The lengths are in bits.           */
/****************************************************************************/
#define MCS_PDUTYPELENGTH                       6
#define MCS_PDUTYPEMASK                         0xFC
#define MCS_RESULTCODELENGTH                    4
#define MCS_RESULTCODEMASK                      0xF
#define MCS_REASONCODELENGTH                    3
#define MCS_REASONCODEMASK                      0x7

/****************************************************************************/
/* Offsets for the following:                                               */
/*                                                                          */
/*  - result and reason codes.                                              */
/*  - optional fields (user-id in AUC and channel-id in CJC).               */
/****************************************************************************/
#define MCS_AUC_RESULTCODEOFFSET                7
#define MCS_AUC_OPTIONALUSERIDLENGTH            1
#define MCS_AUC_OPTIONALUSERIDMASK              0x02
#define MCS_CJC_RESULTCODEOFFSET                7
#define MCS_CJC_OPTIONALCHANNELIDLENGTH         1
#define MCS_CJC_OPTIONALCHANNELIDMASK           0x02
#define MCS_DPUM_REASONCODEOFFSET               6

/****************************************************************************/
/* MCS PDU types.                                                           */
/****************************************************************************/
#define MCS_TYPE_UNKNOWN                        0
#define MCS_TYPE_CONNECTINITIAL                 0x65
#define MCS_TYPE_CONNECTRESPONSE                0x66
#define MCS_TYPE_ATTACHUSERREQUEST              0x28
#define MCS_TYPE_ATTACHUSERCONFIRM              0x2C
#define MCS_TYPE_DETACHUSERREQUEST              0x30
#define MCS_TYPE_DETACHUSERINDICATION           0x34
#define MCS_TYPE_CHANNELJOINREQUEST             0x38
#define MCS_TYPE_CHANNELJOINCONFIRM             0x3C
#define MCS_TYPE_SENDDATAREQUEST                0x64
#define MCS_TYPE_SENDDATAINDICATION             0x68
#define MCS_TYPE_DISCONNECTPROVIDERUM           0x20

/****************************************************************************/
/* Masks used to identify the segmentation flags in a Send-Data-Indication  */
/* PDU.                                                                     */
/****************************************************************************/
#define MCS_SDI_BEGINSEGMASK                    0x20
#define MCS_SDI_ENDSEGMASK                      0x10

/****************************************************************************/
/* MCS hard-coded PDUs - first of all MCS connect initial.                  */
/****************************************************************************/
#define MCS_DATA_CONNECTINITIAL                                              \
                  {0x657F,                 /* PDU type. 7F65 = CI        */  \
                   0x82, 0x00,             /* PDU length (length > 128)  */  \
                   0x04, 0x01, 0x01,       /* Calling domain selector    */  \
                   0x04, 0x01, 0x01,       /* Called domain selector     */  \
                   0x01, 0x01, 0xFF,       /* Upward flag                */  \
                   0x30, 0x19,             /* Target domain params       */  \
                   0x02, 0x01, 0x22,       /*   Max channel IDs          */  \
                   0x02, 0x01, 0x02,       /*   Max user IDs             */  \
                   0x02, 0x01, 0x00,       /*   Max token IDs            */  \
                   0x02, 0x01, 0x01,       /*   Number of priorities     */  \
                   0x02, 0x01, 0x00,       /*   Min throughput           */  \
                   0x02, 0x01, 0x01,       /*   Max height               */  \
                   0x02, 0x02, 0xFF, 0xFF, /*   Max MCSPDU size          */  \
                   0x02, 0x01, 0x02,       /*   Protocol version         */  \
                   0x30, 0x19,             /* Minimum domain parameters  */  \
                   0x02, 0x01, 0x01,       /*   Max channel IDs          */  \
                   0x02, 0x01, 0x01,       /*   Max user IDs             */  \
                   0x02, 0x01, 0x01,       /*   Max token IDs            */  \
                   0x02, 0x01, 0x01,       /*   Number of priorities     */  \
                   0x02, 0x01, 0x00,       /*   Min throughput           */  \
                   0x02, 0x01, 0x01,       /*   Max height               */  \
                   0x02, 0x02, 0x04, 0x20, /*   Max MCSPDU size          */  \
                   0x02, 0x01, 0x02,       /*   Protocol version         */  \
                   0x30, 0x1C,             /* Maximum domain parameters  */  \
                   0x02, 0x02, 0xFF, 0xFF, /*   Max channel IDs          */  \
                   0x02, 0x02, 0xFC, 0x17, /*   Max user IDs             */  \
                   0x02, 0x02, 0xFF, 0xFF, /*   Max token IDs            */  \
                   0x02, 0x01, 0x01,       /*   Number of priorities     */  \
                   0x02, 0x01, 0x00,       /*   Min throughput           */  \
                   0x02, 0x01, 0x01,       /*   Max height               */  \
                   0x02, 0x02, 0xFF, 0xFF, /*   Max MCSPDU size          */  \
                   0x02, 0x01, 0x02,       /*   Protocol version         */  \
                   0x04, 0x82, 0x00}       /* User data                  */  \

/****************************************************************************/
/* Hard-coded data for Erect-Domain-Request PDU.                            */
/****************************************************************************/
#define MCS_DATA_ERECTDOMAINREQUEST                                          \
                  {0x04,                   /* EDrq choice                */  \
                   0x0001,                 /* Sub-height                 */  \
                   0x0001}                 /* Sub-interval               */  \

/****************************************************************************/
/* Hard-coded data for Disconnect-Provider-Ultimatum PDU.  The reason       */
/* is hard-coded to rn-user-requested.                                      */
/****************************************************************************/
#define MCS_DATA_DISCONNECTPROVIDERUM                                        \
                  {0x8021}                 /* DPum choice and reason     */  \

/****************************************************************************/
/* Hard-coded data for Attach-User-Request PDU.                             */
/****************************************************************************/
#define MCS_DATA_ATTACHUSERREQUEST                                           \
                  {0x28}                   /* AUrq choice                */  \

/****************************************************************************/
/* Hard-coded data for Detach-User-Request PDU.                             */
/****************************************************************************/
#define MCS_DATA_DETACHUSERREQUEST                                           \
                  {0x31, 0x80,             /* DUrq choice and reason     */  \
                   0x01,                   /* Set of one user-id         */  \
                   0x0000}                 /* User ID                    */  \

/****************************************************************************/
/* Hard-coded data for Channel-Join-Request PDU.                            */
/****************************************************************************/
#define MCS_DATA_CHANNELJOINREQUEST                                          \
                  {0x38,                   /* CJrq choice                */  \
                   0x0000,                 /* User ID                    */  \
                   0x0000}                 /* Channel ID                 */  \

/****************************************************************************/
/* Hard-coded data for Send-Data-Request PDU.                               */
/****************************************************************************/
#define MCS_DATA_SENDDATAREQUEST                                             \
                  {0x64,                   /* SDrq choice                */  \
                   0x0000,                 /* User ID                    */  \
                   0x0000,                 /* Channel ID                 */  \
                   0x70}                   /* Priority and segmentation  */  \
                   
                   


/****************************************************************************/
/*                                                                          */
/* TYPEDEFS                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Turn on single-byte packing for these structures which we use to         */
/* overlay a byte stream from the network.                                  */
/****************************************************************************/
#pragma pack(push, MCSpack, 1)

/**STRUCT+*******************************************************************/
/* Structure: MCS_BER_1DATABYTE                                             */
/*                                                                          */
/* Description: A BER encoded 1 byte value.                                 */
/****************************************************************************/
typedef struct tagMCS_BER_1DATABYTE
{
    DCUINT8 tag;
    DCUINT8 length;
    DCUINT8 value;

} MCS_BER_1DATABYTE;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_BER_2DATABYTES                                            */
/*                                                                          */
/* Description: A BER encoded 2 byte value.                                 */
/****************************************************************************/
typedef struct tagMCS_BER_2DATABYTES
{
    DCUINT8 tag;
    DCUINT8 length;
    DCUINT8 value[2];

} MCS_BER_2DATABYTES;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_BER_3DATABYTES                                            */
/*                                                                          */
/* Description: A BER encoded 3 byte value.                                 */
/****************************************************************************/
typedef struct tagMCS_BER_3DATABYTES
{
    DCUINT8 tag;
    DCUINT8 length;
    DCUINT8 value[3];

} MCS_BER_3DATABYTES;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_BER_4DATABYTES                                            */
/*                                                                          */
/* Description: A BER encoded 4 byte value.                                 */
/****************************************************************************/
typedef struct tagMCS_BER_4DATABYTES
{
    DCUINT8 tag;
    DCUINT8 length;
    DCUINT8 value[4];

} MCS_BER_4DATABYTES;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_DOMAINPARAMETERS                                          */
/*                                                                          */
/* Description: Represents a Domain-Parameters sequence.                    */
/****************************************************************************/
typedef struct tagMCS_DOMAINPARAMETERS
{
    DCUINT8            tag;
    DCUINT8            length;
    MCS_BER_2DATABYTES maxChanIDs;
    MCS_BER_2DATABYTES maxUserIDs;
    MCS_BER_2DATABYTES maxTokenIDs;
    MCS_BER_1DATABYTE  numPriorities;
    MCS_BER_1DATABYTE  minThroughPut;
    MCS_BER_1DATABYTE  maxHeight;
    MCS_BER_2DATABYTES maxMCSPDUSize;
    MCS_BER_1DATABYTE  protocolVersion;

} MCS_DOMAINPARAMETERS;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_TARGETDOMAINPARAMETERS                                    */
/*                                                                          */
/* Description: Represents a Domain-Parameters sequence.                    */
/****************************************************************************/
typedef struct tagMCS_TARGETDOMAINPARAMETERS
{
    DCUINT8            tag;
    DCUINT8            length;
    MCS_BER_1DATABYTE  maxChanIDs;
    MCS_BER_1DATABYTE  maxUserIDs;
    MCS_BER_1DATABYTE  maxTokenIDs;
    MCS_BER_1DATABYTE  numPriorities;
    MCS_BER_1DATABYTE  minThroughPut;
    MCS_BER_1DATABYTE  maxHeight;
    MCS_BER_2DATABYTES maxMCSPDUSize;
    MCS_BER_1DATABYTE  protocolVersion;

} MCS_TARGETDOMAINPARAMETERS;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_MINDOMAINPARAMETERS                                       */
/*                                                                          */
/* Description: Represents a Domain-Parameters sequence.                    */
/****************************************************************************/
typedef struct tagMCS_MINDOMAINPARAMETERS
{
    DCUINT8            tag;
    DCUINT8            length;
    MCS_BER_1DATABYTE  maxChanIDs;
    MCS_BER_1DATABYTE  maxUserIDs;
    MCS_BER_1DATABYTE  maxTokenIDs;
    MCS_BER_1DATABYTE  numPriorities;
    MCS_BER_1DATABYTE  minThroughPut;
    MCS_BER_1DATABYTE  maxHeight;
    MCS_BER_2DATABYTES maxMCSPDUSize;
    MCS_BER_1DATABYTE  protocolVersion;

} MCS_MINDOMAINPARAMETERS;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_MAXDOMAINPARAMETERS                                       */
/*                                                                          */
/* Description: Represents a Domain-Parameters sequence.                    */
/****************************************************************************/
typedef struct tagMCS_MAXDOMAINPARAMETERS
{
    DCUINT8            tag;
    DCUINT8            length;
    MCS_BER_2DATABYTES maxChanIDs;
    MCS_BER_2DATABYTES maxUserIDs;
    MCS_BER_2DATABYTES maxTokenIDs;
    MCS_BER_1DATABYTE  numPriorities;
    MCS_BER_1DATABYTE  minThroughPut;
    MCS_BER_1DATABYTE  maxHeight;
    MCS_BER_2DATABYTES maxMCSPDUSize;
    MCS_BER_1DATABYTE  protocolVersion;

} MCS_MAXDOMAINPARAMETERS;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_PDU_CONNECTINITIAL                                        */
/*                                                                          */
/* Description: Represents a Connect-Initial PDU.                           */
/****************************************************************************/
typedef struct tagMCS_PDU_CONNECTINITIAL
{
    DCUINT16                   type;
    DCUINT8                    lengthLength;
    DCUINT16                   length;
    MCS_BER_1DATABYTE          callingDS;
    MCS_BER_1DATABYTE          calledDS;
    MCS_BER_1DATABYTE          upwardFlag;
    MCS_TARGETDOMAINPARAMETERS targetParams;
    MCS_MINDOMAINPARAMETERS    minimumParams;
    MCS_MAXDOMAINPARAMETERS    maximumParams;
    DCUINT8                    udIdentifier;
    DCUINT8                    udLengthLength;
    DCUINT16                   udLength;

} MCS_PDU_CONNECTINITIAL, DCPTR PMCS_PDU_CONNECTINITIAL;
/**STRUCT-*******************************************************************/


/**STRUCT+*******************************************************************/
/* Structure: MCS_PDU_CONNECTRESPONSE                                       */
/*                                                                          */
/* Description: Represents a Connect-Response PDU.                          */
/****************************************************************************/
typedef struct tagMCS_PDU_CONNECTRESPONSE
{
    DCUINT16             type;
    DCUINT8              length;
    MCS_BER_1DATABYTE    result;
    MCS_BER_1DATABYTE    connectID;
    MCS_DOMAINPARAMETERS domainParams;
    DCUINT8              userDataType;
    DCUINT8              userDataLength;

} MCS_PDU_CONNECTRESPONSE, DCPTR PMCS_PDU_CONNECTRESPONSE;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_PDU_ERECTDOMAINREQUEST                                    */
/*                                                                          */
/* Description: Represents a Erect-Domain-Request PDU.                      */
/****************************************************************************/
typedef struct tagMCS_PDU_ERECTDOMAINREQUEST
{
    DCUINT8  type;
    DCUINT16 subHeight;
    DCUINT16 subInterval;

} MCS_PDU_ERECTDOMAINREQUEST, DCPTR PMCS_PDU_ERECTDOMAINREQUEST;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_PDU_DISCONNECTPROVIDERUM                                  */
/*                                                                          */
/* Description: Represents a Disconnect-Provider-Ultimatum PDU              */
/****************************************************************************/
typedef struct tagMCS_PDU_DISCONNECTPROVIDERUM
{
    DCUINT16 typeReason;

} MCS_PDU_DISCONNECTPROVIDERUM, DCPTR PMCS_PDU_DISCONNECTPROVIDERUM;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_PDU_ATTACHUSERREQUEST                                     */
/*                                                                          */
/* Description: Represents an Attach-User-Request PDU.                      */
/****************************************************************************/
typedef struct tagMCS_PDU_ATTACHUSERREQUEST
{
    DCUINT8 type;

} MCS_PDU_ATTACHUSERREQUEST, DCPTR PMCS_PDU_ATTACHUSERREQUEST;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_PDU_ATTACHUSERCONFIRMCOMMON                               */
/*                                                                          */
/* Description: Represents the always present part of a Attach-User-Confirm */
/*              PDU.                                                        */
/****************************************************************************/
typedef struct tagMCS_PDU_ATTACHUSERCONFIRMCOMMON
{
    DCUINT16 typeResult;

} MCS_PDU_ATTACHUSERCONFIRMCOMMON, DCPTR PMCS_PDU_ATTACHUSERCONFIRMCOMMON;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_PDU_ATTACHUSERCONFIRMFULL                                 */
/*                                                                          */
/* Description: Represents a full Attach-User-Confirm PDU with the optional */
/*              userID.                                                     */
/****************************************************************************/
typedef struct tagMCS_PDU_ATTACHUSERCONFIRMFULL
{
    MCS_PDU_ATTACHUSERCONFIRMCOMMON common;
    DCUINT16                        userID;

} MCS_PDU_ATTACHUSERCONFIRMFULL, DCPTR PMCS_PDU_ATTACHUSERCONFIRMFULL;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_PDU_DETACHUSERREQUEST                                     */
/*                                                                          */
/* Description: Represents a Detach-User-Request PDU.                       */
/****************************************************************************/
typedef struct tagMCS_PDU_DETACHUSERREQUEST
{
    DCUINT8  type;
    DCUINT8  reason;
    DCUINT8  set;
    DCUINT16 userID;

} MCS_PDU_DETACHUSERREQUEST, DCPTR PMCS_PDU_DETACHUSERREQUEST;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_PDU_DETACHUSERINDICATION                                  */
/*                                                                          */
/* Description: Represents a Detach-User-Indication PDU.                    */
/****************************************************************************/
typedef struct tagMCS_PDU_DETACHUSERINDICATION
{
    DCUINT8  type;
    DCUINT8  reason;
    DCUINT8  set;
    DCUINT16 userID;

} MCS_PDU_DETACHUSERINDICATION, DCPTR PMCS_PDU_DETACHUSERINDICATION;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_PDU_CHANNELJOINREQUEST                                    */
/*                                                                          */
/* Description: Represents a Channel-Join-Request PDU.                      */
/****************************************************************************/
typedef struct tagMCS_PDU_CHANNELJOINREQUEST
{
    DCUINT8  type;
    DCUINT16 initiator;
    DCUINT16 channelID;

} MCS_PDU_CHANNELJOINREQUEST, DCPTR PMCS_PDU_CHANNELJOINREQUEST;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_PDU_CHANNELJOINCONFIRMCOMMON                              */
/*                                                                          */
/* Description: Represents the always present part of a                     */
/*              Channel-Join-Confirm PDU.                                   */
/****************************************************************************/
typedef struct tagMCS_PDU_CHANNELJOINCONFIRMCOMMON
{
    DCUINT16 typeResult;
    DCUINT16 initiator;
    DCUINT16 requested;

} MCS_PDU_CHANNELJOINCONFIRMCOMMON, DCPTR PMCS_PDU_CHANNELJOINCONFIRMCOMMON;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_PDU_CHANNELJOINCONFIRMFULL                                */
/*                                                                          */
/* Description: Represents a full Channel-Join-Confirm PDU including the    */
/*              optional channel-ID.                                        */
/****************************************************************************/
typedef struct tagMCS_PDU_CHANNELJOINCONFIRM
{
    MCS_PDU_CHANNELJOINCONFIRMCOMMON common;
    DCUINT16                         channelID;

} MCS_PDU_CHANNELJOINCONFIRMFULL, DCPTR PMCS_PDU_CHANNELJOINCONFIRMFULL;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_PDU_SENDDATAINDICATION                                    */
/*                                                                          */
/* Description: Represents a Send-Data-Indication PDU.                      */
/****************************************************************************/
typedef struct tagMCS_PDU_SENDDATAINDICATION
{
    DCUINT8  type;
    DCUINT16 userID;
    DCUINT16 channelID;
    DCUINT8  priSeg;

} MCS_PDU_SENDDATAINDICATION, DCPTR PMCS_PDU_SENDDATAINDICATION;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: MCS_PDU_SENDDATAREQUEST                                       */
/*                                                                          */
/* Description: Represents a Send-Data-Request PDU.                         */
/****************************************************************************/
typedef struct tagMCS_PDU_SENDDATAREQUEST
{
    DCUINT8  type;
    DCUINT16 userID;
    DCUINT16 channelID;
    DCUINT8  priSeg;

} MCS_PDU_SENDDATAREQUEST;
/**STRUCT-*******************************************************************/

/****************************************************************************/
/* Reset structure packing to its default.                                  */
/****************************************************************************/
#pragma pack(pop, MCSpack)

/**STRUCT+*******************************************************************/
/* Structure: MCS_DECOUPLEINFO                                              */
/*                                                                          */
/* Description: Structure used when decoupling channel and userIDs.         */
/****************************************************************************/
typedef struct tagMCS_DECOUPLEINFO
{
    DCUINT channel;
    DCUINT userID;

} MCS_DECOUPLEINFO, DCPTR PMCS_DECOUPLEINFO;
/**STRUCT-*******************************************************************/





/****************************************************************************/
/*                                                                          */
/* TYPEDEFS                                                                 */
/*                                                                          */
/****************************************************************************/
/**STRUCT+*******************************************************************/
/* Structure: MCS_GLOBAL_DATA                                               */
/*                                                                          */
/* Description: The MCS global data.                                        */
/****************************************************************************/
typedef struct tagMCS_GLOBAL_DATA
{
    DCUINT   rcvState;
    DCUINT   hdrBytesNeeded;
    DCUINT   hdrBytesRead;
    DCUINT   dataState;
    DCUINT   dataBytesNeeded;
    DCUINT   dataBytesRead;
    DCUINT   userDataLength;
    DCUINT   disconnectReason;
    PDCUINT8 pReceivedPacket;
    DCUINT8  pSizeBuf[MCS_MAX_SIZE_DATA_LENGTH];
    PDCUINT8 pHdrBuf;
    DCUINT   hdrBufLen;

    //
    // Channel with a pending join request - use this
    // to validate that the server isn't sending us bogus
    // joins for channels we didn't request
    //
    DCUINT16    pendingChannelJoin;
    DCUINT16    pad;
                             /* Note: dataBuf must start on 4-byte boundary */
    //    The decompression function does not check strictly the input buffer
    //    for performance reasons. So it can overread up to 8 bytes. So we pad
    //    the input buffer with enough bytes to avoid the overread.
    DCUINT8  dataBuf[MCS_MAX_RCVPKT_LENGTH + 2 + MCS_INPUT_BUFFER_BIAS];

} MCS_GLOBAL_DATA;
/**STRUCT-*******************************************************************/




//
// Class definition
//



class CCD;
class CNC;
class CUT;
class CXT;
class CNL;
class CSL;


class CMCS
{
public:

    CMCS(CObjs* objs);
    ~CMCS();

public:
    //
    // API functions
    //

    /****************************************************************************/
    /* FUNCTIONS                                                                */
    /****************************************************************************/
    DCVOID DCAPI MCS_Init(DCVOID);
    
    DCVOID DCAPI MCS_Term(DCVOID);
    
    DCVOID DCAPI MCS_Connect(BOOL     bInitateConnect,
                             PDCTCHAR pServerAddress,
                             PDCUINT8 pUserData,
                             DCUINT   userDataLength);

    DCVOID DCAPI MCS_Disconnect(DCVOID);
    
    DCVOID DCAPI MCS_AttachUser(DCVOID);
    
    DCVOID DCAPI MCS_JoinChannel(DCUINT channel, DCUINT userID);
    
    DCBOOL DCAPI MCS_GetBuffer(DCUINT      dataLen,
                               PPDCUINT8   ppBuffer,
                               PMCS_BUFHND pBufHandle);
    
    DCVOID DCAPI MCS_SendPacket(PDCUINT8   pData,
                                DCUINT     dataLen,
                                DCUINT     flags,
                                MCS_BUFHND bufHandle,
                                DCUINT     userID,
                                DCUINT     channel,
                                DCUINT     priority);
    
    DCVOID DCAPI MCS_FreeBuffer(MCS_BUFHND bufHandle);
    
public:
    //
    // Callbacks
    //

    DCVOID DCCALLBACK MCS_OnXTConnected(DCVOID);
    
    DCVOID DCCALLBACK MCS_OnXTDisconnected(DCUINT reason);
    
    DCBOOL DCCALLBACK MCS_OnXTDataAvailable(DCVOID);
    
    DCVOID DCCALLBACK MCS_OnXTBufferAvailable(DCVOID);

    //
    // Static versions
    //

    DCVOID DCCALLBACK MCS_StaticOnXTConnected(CMCS* inst)
    {
        inst->MCS_OnXTConnected();
    }
    
    DCVOID DCCALLBACK MCS_StaticOnXTDisconnected(CMCS* inst, DCUINT reason)
    {
        inst->MCS_OnXTDisconnected(reason);
    }
    
    DCBOOL DCCALLBACK MCS_StaticOnXTDataAvailable(CMCS* inst)
    {
        return inst->MCS_OnXTDataAvailable();
    }
    
    DCVOID DCCALLBACK MCS_StaticOnXTBufferAvailable(CMCS* inst)
    {
        inst->MCS_OnXTBufferAvailable();
    }

    DCUINT16 MCS_GetPendingChannelJoin()
    {
        return _MCS.pendingChannelJoin;
    }

    VOID MCS_SetPendingChannelJoin(DCUINT16 pendingChannelJoin)
    {
        _MCS.pendingChannelJoin = pendingChannelJoin;
    }



    DCVOID DCINTERNAL MCSSendConnectInitial(ULONG_PTR event);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CMCS, MCSSendConnectInitial);

    DCVOID DCINTERNAL MCSSendErectDomainRequest(ULONG_PTR event);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CMCS, MCSSendErectDomainRequest);
    
    DCVOID DCINTERNAL MCSSendAttachUserRequest(ULONG_PTR unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CMCS, MCSSendAttachUserRequest);
    
    DCVOID DCINTERNAL MCSSendChannelJoinRequest(PDCVOID pData, DCUINT dataLen);
    EXPOSE_CD_NOTIFICATION_FN(CMCS, MCSSendChannelJoinRequest);

    DCVOID DCINTERNAL MCSSendDisconnectProviderUltimatum(ULONG_PTR unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CMCS, MCSSendDisconnectProviderUltimatum);
    
    DCVOID DCINTERNAL MCSContinueDisconnect(ULONG_PTR unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CMCS, MCSContinueDisconnect);


public:
    //
    // Public data members
    //

    MCS_GLOBAL_DATA _MCS;


private:

    //
    // Internal functions
    //

    /****************************************************************************/
    /* Inline functions to convert between MCS byte order and local byte order. */
    /****************************************************************************/
    DCUINT16 DCINTERNAL MCSWireToLocal16(DCUINT16 val)
    {
        return((DCUINT16) (((DCUINT16)(((PDCUINT8)&(val))[0]) << 8) | \
                                        ((DCUINT16)(((PDCUINT8)&(val))[1]))));
    }
    #define MCSLocalToWire16 MCSWireToLocal16
    
    /****************************************************************************/
    /* Inline function to extract the result code from a PER encoded PDU.       */
    /* Typically the bits in the first two bytes are used as follows (the       */
    /* following is for an Attach-User-Confirm PDU).                            */
    /*                                                                          */
    /*       BYTE1            BYTE2                                             */
    /*  MSB         LSB  MSB         LSB                                        */
    /*  T T T T T T O R  R R R P P P P P                                        */
    /*                                                                          */
    /*  T: 6 bits used to identify the PDU type.                                */
    /*  O: 1 bit indicating whether the optional field is present.              */
    /*  R: 4 bits used for the result code.                                     */
    /*  P: 5 bits of padding.                                                   */
    /*                                                                          */
    /* Note: the optional bit "O" may or may not be present depending on the    */
    /*       PDU.                                                               */
    /*                                                                          */
    /* Parameters:  IN  value  - the value from which to extract the reason     */
    /*                           code in wire format.                           */
    /*              IN  offset - the offset from the MSB to the first bit of    */
    /*                           the result code.                               */
    /****************************************************************************/
    DCUINT DCINTERNAL MCSGetResult(DCUINT16 value, DCUINT offset)
    {
        DCUINT16 machineValue;
        DCUINT   shiftValue;
        DCUINT   result;
    
        DC_BEGIN_FN("MCSGetResult");
    
        /************************************************************************/
        /* Convert the value from wire to local machine format.                 */
        /************************************************************************/
        machineValue = MCSWireToLocal16(value);
    
        /************************************************************************/
        /* Now shift it right by the appropriate amount.  This amount is 16     */
        /* bits minus (the offset plus the length of the result code).          */
        /************************************************************************/
        shiftValue = 16 - (offset + MCS_RESULTCODELENGTH);
        machineValue >>= shiftValue;
    
        /************************************************************************/
        /* Finally mask off the bottom byte which contains the result code.     */
        /************************************************************************/
        result = machineValue & MCS_RESULTCODEMASK;
    
        TRC_NRM((TB, _T("Shift %#hx right by %u to get %#hx.  Mask to get %#x"),
                 MCSWireToLocal16(value),
                 shiftValue,
                 machineValue,
                 result));
    
        DC_END_FN();
        return(result);
    }
    
    /****************************************************************************/
    /* Macro to extract the reason code from a PER encoded PDU.  Typically      */
    /* the bits in the first two bytes are used as follows (the following is    */
    /* for a Disconnect-Provider-Ultimatum).                                    */
    /*                                                                          */
    /*       BYTE1            BYTE2                                             */
    /*  MSB         LSB  MSB         LSB                                        */
    /*  T T T T T T R R  R P P P P P P P                                        */
    /*                                                                          */
    /*  T: 6 bits used to identify the PDU type.                                */
    /*  R: 3 bits used for the result code.                                     */
    /*  P: 7 bits of padding.                                                   */
    /*                                                                          */
    /* Parameters:  IN  value  - the value from which to extract the reason     */
    /*                           code in wire format.                           */
    /*              IN  offset - the offset from the MSB to the first bit of    */
    /*                           the reason code.                               */
    /****************************************************************************/
    DCUINT DCINTERNAL MCSGetReason(DCUINT16 value, DCUINT offset)
    {
        DCUINT16 machineValue;
        DCUINT   shiftValue;
        DCUINT   reason;
    
        DC_BEGIN_FN("MCSGetResult");
    
        /************************************************************************/
        /* Convert the value from wire to local machine format.                 */
        /************************************************************************/
        machineValue = MCSWireToLocal16(value);
    
        /************************************************************************/
        /* Now shift it right by the appropriate amount.  This amount is 16     */
        /* bits minus (the offset plus the length of the reason code).          */
        /************************************************************************/
        shiftValue = 16 - (offset + MCS_REASONCODELENGTH);
        machineValue >>= shiftValue;
    
        /************************************************************************/
        /* Finally mask off the bottom byte which contains the reason code.     */
        /************************************************************************/
        reason = machineValue & MCS_REASONCODEMASK;
    
        TRC_NRM((TB, _T("Shift %#hx right by %u to get %#hx.  Mask to get %#x"),
                 MCSWireToLocal16(value),
                 shiftValue,
                 machineValue,
                 reason));
    
        DC_END_FN();
        return(reason);
    }
    
    /****************************************************************************/
    /* Inline functions to convert user-ids between the PER encoded values and  */
    /* the wire format.                                                         */
    /****************************************************************************/
    DCUINT16 DCINTERNAL MCSWireUserIDToLocalUserID(DCUINT16 wireUserID)
    {
        /************************************************************************/
        /* Convert from wire to local byte order and then add the PER encoding  */
        /* offset.                                                              */
        /************************************************************************/
        return((DCUINT16)(MCSWireToLocal16(wireUserID) + MCS_USERID_PER_OFFSET));
    }
    
    DCUINT16 DCINTERNAL MCSLocalUserIDToWireUserID(DCUINT16 localUserID)
    {
        /************************************************************************/
        /* Subtract the PER encoding offset and then convert from local to wire */
        /* byte order.                                                          */
        /************************************************************************/
        return(MCSLocalToWire16((DCUINT16)(localUserID - MCS_USERID_PER_OFFSET)));
    }
    
    /****************************************************************************/
    /* Inline function to calculate the number of length bytes in a BER         */
    /* encoded length.                                                          */
    /****************************************************************************/
    DCUINT DCINTERNAL MCSGetBERLengthSize(DCUINT8 firstByte)
    {
        DCUINT numLenBytes;
    
        DC_BEGIN_FN("MCSGetBERLengthSize");
    
        /************************************************************************/
        /* Check if the top bit is set.                                         */
        /************************************************************************/
        if (0x80 & firstByte)
        {
            /********************************************************************/
            /* The top bit is set - the low seven bits contain the number of    */
            /* length bytes.                                                    */
            /********************************************************************/
            numLenBytes = (firstByte & 0x7F) + 1;
            TRC_NRM((TB, _T("Top bit set - numLenBytes:%u"), numLenBytes));
        }
        else
        {
            /********************************************************************/
            /* The top bit was not set - this field contains the length.        */
            /********************************************************************/
            numLenBytes = 1;
            TRC_NRM((TB, _T("Top bit NOT set - numLenBytes:%u firstByte:%u"),
                     numLenBytes,
                     firstByte));
        }
    
        DC_END_FN();
        return(numLenBytes);
    }
    
    /****************************************************************************/
    /* Inline function to calculate the length of a BER encoded field.          */
    /****************************************************************************/
    DCUINT DCINTERNAL MCSGetBERLength(PDCUINT8 pLength)
    {
        DCUINT length = 0;
        DCUINT numLenBytes;
    
        DC_BEGIN_FN("MCSGetBERLength");
    
        TRC_ASSERT((pLength != NULL), (TB, _T("pLength is NULL")));
    
        /************************************************************************/
        /* Calculate the number of length bytes.                                */
        /************************************************************************/
        numLenBytes = MCSGetBERLengthSize(*pLength);
    
        switch (numLenBytes)
        {
            case 1:
            {
                /****************************************************************/
                /* The length is less than 128 bytes so the first field         */
                /* contains the length.                                         */
                /****************************************************************/
                length = *pLength;
            }
            break;
    
            case 2:
            {
                /****************************************************************/
                /* The length is >= 128 bytes but less than 256 bytes so it     */
                /* is encoded in the second byte.                               */
                /****************************************************************/
                pLength++;
                length = *pLength;
            }
            break;
    
            case 3:
            {
                /****************************************************************/
                /* The length is >= 256 bytes and less than 65535 bytes so it   */
                /* is encoded in bytes two and three.                           */
                /****************************************************************/
                pLength++;
                length = (DCUINT16)*pLength;
                pLength++;
                length = (length << 8) + (DCUINT16)*pLength;
            }
            break;
    
            default:
            {
                TRC_ABORT((TB, _T("Too many length bytes:%u"), numLenBytes));
            }
            break;
        }
    
        TRC_NRM((TB, _T("numLenBytes:%u length:%u"), numLenBytes, length));
    
        DC_END_FN();
        return(length);
    }
    
    
    /****************************************************************************/
    /*                                                                          */
    /* FUNCTIONS                                                                */
    /*                                                                          */
    /****************************************************************************/
    
    DCUINT DCINTERNAL MCSGetSDRHeaderLength(DCUINT dataLength);
    
    DCBOOL DCINTERNAL MCSRecvToHdrBuf(DCVOID);
    
    DCBOOL DCINTERNAL MCSRecvToDataBuf(DCVOID);
    
    DCVOID DCINTERNAL MCSGetPERInfo(PDCUINT pType, PDCUINT pSize);
    
    DCVOID DCINTERNAL MCSHandleControlPkt(DCVOID);
    
    DCVOID DCINTERNAL MCSHandleCRPDU(DCVOID);
    
    HRESULT DCINTERNAL MCSRecvData(BOOL *pfFinishedData);
    
    DCVOID DCINTERNAL MCSSetReasonAndDisconnect(DCUINT reason);

private:
    CCD* _pCd;
    CNC* _pNc;
    CUT* _pUt;
    CXT* _pXt;
    CNL* _pNl;
    CSL* _pSl;

private:
    CObjs* _pClientObjects;

};

#undef TRC_FILE
#undef TRC_GROUP

#endif // _H_MCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\ncapi.cpp ===
/**MOD+**********************************************************************/
/* Module:    ncapi.cpp                                                     */
/*                                                                          */
/* Purpose:   Node Controller API/callbacks                                 */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_NETWORK
#define TRC_FILE  "ncapi"
#include <atrcapi.h>
}

#include "autil.h"
#include "nc.h"
#include "cd.h"
#include "nl.h"
#include "mcs.h"
#include "cchan.h"

/****************************************************************************/
/* MCS user data header bytes.                                              */
/****************************************************************************/
const DCINT8  ncMCSHeader[NC_MCS_HDRLEN] =
{
    0x00, 0x05, 0x00, 0x14, 0x7C, 0x00, 0x01
};

/****************************************************************************/
/* GCC CreateConferenceRequest PDU body                                     */
/****************************************************************************/
const DCINT8 ncGCCBody[NC_GCC_REQLEN] =
{
    0x00,  /* extension bit; 3 * choice bits; 3 * optional fields           */
    0x08,  /* 5*Optional (user data only);2*ConfName options;length bit 0   */
    0x00,  /* Length bits 1-7; pad bit                                      */
    0x10,  /* Conference name (numeric) = "1"; locked; listed;              */
    0x00,  /* conductible; 2*Terminate =automatic; pad                      */
    0x01,  /* Number of UserData fields                                     */
   '\xC0', /* optional;choice;6*size (0=>4 octets)                          */
    0x00   /* 2* size; 6* pad                                               */
};


CNC::CNC(CObjs* objs)
{
    _pClientObjects = objs;
}

CNC::~CNC()
{
}


#ifdef OS_WIN32
/**PROC+*********************************************************************/
/* Name:      NC_Main                                                       */
/*                                                                          */
/* Purpose:   Receiver Thread message loop                                  */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CNC::NC_Main(DCVOID)
{
    MSG msg;

    DC_BEGIN_FN("NC_Main");

    TRC_NRM((TB, _T("Receiver Thread initialization")));

#if defined(OS_WINCE) && defined(WINCE_USEBRUSHCACHE)
    BrushCacheInitialize();
#endif


    _pCd  = _pClientObjects->_pCdObject;
    _pCc  = _pClientObjects->_pCcObject;
    _pMcs = _pClientObjects->_pMCSObject;
    _pUt  = _pClientObjects->_pUtObject;
    _pRcv = _pClientObjects->_pRcvObject;
    _pNl  = _pClientObjects->_pNlObject;
    _pSl  = _pClientObjects->_pSlObject;
    _pUi  = _pClientObjects->_pUiObject;
    _pChan = _pClientObjects->_pChanObject;

    NC_Init();

    TRC_NRM((TB, _T("Start Receiver Thread message loop")));
    while (GetMessage (&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    TRC_NRM((TB, _T("Exit Receiver Thread message loop")));
    NC_Term();

#if defined(OS_WINCE) && defined(WINCE_USEBRUSHCACHE)
    BrushCacheUninitialize();
#endif

    /************************************************************************/
    /* This is the end of the Receiver Thread.                              */
    /************************************************************************/
    TRC_NRM((TB, _T("Receiver Thread terminates")));

    DC_END_FN();

    return;

} /* NC_Main */
#endif /* OS_WIN32 */


/**PROC+*********************************************************************/
/* Name:      NC_Init                                                       */
/*                                                                          */
/* Purpose:   Initialize the Node Controller                                */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CNC::NC_Init(DCVOID)
{
    DC_BEGIN_FN("NC_Init");

    /************************************************************************/
    /* Initialize global data.                                              */
    /************************************************************************/
    DC_MEMSET(&_NC, 0, sizeof(_NC));

    /************************************************************************/
    /* Register with CD, to receive messages.                               */
    /************************************************************************/
    _pCd->CD_RegisterComponent(CD_RCV_COMPONENT);

    /************************************************************************/
    /* Initialize lower layers.                                             */
    /************************************************************************/
    _pMcs->MCS_Init();

    /************************************************************************/
    /* Initialize virtual channel stuff                                     */
    /************************************************************************/
    _pChan->ChannelOnInitializing();

    TRC_NRM((TB, _T("NC successfully initialized")));

    /************************************************************************/
    /* Tell the Core that we are initialized                                */
    /************************************************************************/
    _pNl->_NL.callbacks.onInitialized(_pSl);
    
    _pChan->ChannelOnInitialized();

    DC_END_FN();
    return;

} /* NC_Init */


/**PROC+*********************************************************************/
/* Name:      NC_Term                                                       */
/*                                                                          */
/* Purpose:   Terminate the Node Controller                                 */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CNC::NC_Term(DCVOID)
{
    DC_BEGIN_FN("NC_Term");

    /************************************************************************/
    /* Tell core that we are terminating                                    */
    /************************************************************************/
    _pNl->_NL.callbacks.onTerminating(_pSl);
    
    _pChan->ChannelOnTerminating();

    /************************************************************************/
    /* Terminate lower NL layers.                                           */
    /************************************************************************/
    _pMcs->MCS_Term();

    /************************************************************************/
    /* Unregister with CD                                                   */
    /************************************************************************/
    _pCd->CD_UnregisterComponent(CD_RCV_COMPONENT);

    DC_END_FN();
    return;

} /* NC_Term */



/**PROC+*********************************************************************/
/* Name:      NC_Connect                                                    */
/*                                                                          */
/* Purpose:   Connect to the requested Server by calling MCS                */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    IN      pData   - user data (SL + Core)                       */
/*            IN      dataLen - length                                      */
/*                                                                          */
/* Operation: Send an MCSConnectProvider request with a GCC Create          */
/*            Conference request encoded in the user data.  The encoding is */
/*            as follows:                                                   */
/*                                                                          */
/*            number of bytes   value                                       */
/*            ===============   =====                                       */
/*            NC_MCS_HDRLEN     MCS header                                  */
/*            1 or 2            Total GCC PDU length                        */
/*            NC_GCC_REQLEN     GCC CreateConference PDU body               */
/*            4                 H221 key                                    */
/*            1 or 2            length of GCC user data                     */
/*            ?                 GCC user data                               */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CNC::NC_Connect(PDCVOID pData, DCUINT dataLen)
{
    PNC_CONNECT_DATA pConn;
    PDCUINT8  pAddress;
    PDCUINT8  pProtocol;
    PDCUINT8  pUserData;
    DCUINT    userDataLen;
    DCUINT    mcsUserDataLen;
    DCUINT    gccPDULen;
    PDCUINT8  pGCCPDU;
    DCUINT8   mcsUserData[NC_GCCREQ_MAX_PDULEN];
    RNS_UD_CS_NET netUserData;
    PCHANNEL_DEF pVirtualChannels;
    BOOL      bInitateConnect;

    DC_BEGIN_FN("NC_Connect");

    DC_IGNORE_PARAMETER(dataLen);

    /************************************************************************/
    /* We are about to dereference pData as NC_CONNECT_DATA.  Thus, we must */
    /* have at least that much in our PDU.                                  */
    /************************************************************************/
    if (dataLen < ((ULONG)FIELDOFFSET(NC_CONNECT_DATA, userDataLen) +
                   (ULONG)FIELDSIZE(NC_CONNECT_DATA, userDataLen)))
    {
        DCUINT errorCode;
        TRC_ABORT((TB, _T("Not enough data for NC_CONNECT_DATA struct: %u"), dataLen));

        /************************************************************************/
        /* We haven't even called into the MCS layer yet, so the disconnect     */
        /* is a bit tricky.  Uninitialize our layer and bubble up.              */
        /************************************************************************/
        errorCode = NL_MAKE_DISCONNECT_ERR(NL_ERR_NCNOUSERDATA);
        NC_OnMCSDisconnected(errorCode);
        DC_QUIT;
    }

    pConn = (PNC_CONNECT_DATA)pData;

	    bInitateConnect = pConn->bInitateConnect;

    if( bInitateConnect )
    {
        pAddress  = pConn->data;
        TRC_ASSERT((pConn->addressLen > 0),
               (TB, _T("Invalid address length")));
    }
    else
    {
        pAddress = NULL;
        TRC_ASSERT((pConn->addressLen == 0),
               (TB, _T("Invalid address length %u"), pConn->addressLen));
    }

    pProtocol = pConn->data + pConn->addressLen;
    pUserData = pConn->data + pConn->addressLen + pConn->protocolLen;


    /************************************************************************/
    /* Verify that pUserdata sits within the data passed in, since          */
    /* we just get the pointer from an offset specified in the packet.      */
    /************************************************************************/
    if (!IsContainedPointer(pData,dataLen,pUserData))
    {
        DCUINT errorCode;
        TRC_ABORT((TB, _T("Invalid offset in data (pConn->addressLen): %u"), pConn->addressLen));

        /************************************************************************/
        /* We haven't even called into the MCS layer yet, so the disconnect     */
        /* is a bit tricky.  Uninitialize our layer and bubble up.              */
        /************************************************************************/
        errorCode = NL_MAKE_DISCONNECT_ERR(NL_ERR_NCNOUSERDATA);
        NC_OnMCSDisconnected(errorCode);
        DC_QUIT;
    }

    if( bInitateConnect )
    {
        TRC_DBG((TB, _T("Server address %s"), pProtocol));
    }
    else
    {
        TRC_DBG((TB, _T("Server address : not initiate connection%s")));
    }

    TRC_DBG((TB, _T("Protocol %s"), pProtocol));
    TRC_DBG((TB, _T("User data length %u"), pConn->userDataLen));
    TRC_DATA_NRM("User data from Core+SL", pUserData, pConn->userDataLen);

    /************************************************************************/
    /* Get Virtual Channel user data                                        */
    /************************************************************************/
    userDataLen = pConn->userDataLen;

    _pChan->ChannelOnConnecting(&pVirtualChannels, &(netUserData.channelCount));

    TRC_NRM((TB, _T("%d virtual channels"), netUserData.channelCount));
    if (netUserData.channelCount != 0)
    {
        netUserData.header.type = RNS_UD_CS_NET_ID;
        netUserData.header.length = (DCUINT16)(sizeof(RNS_UD_CS_NET) +
                    (netUserData.channelCount * sizeof(CHANNEL_DEF)));
        pConn->userDataLen += netUserData.header.length;
        TRC_NRM((TB, _T("User data length (NET/total): %d/%d"),
                netUserData.header.length, pConn->userDataLen));
    }

    TRC_ASSERT((pConn->userDataLen <= NC_MAX_UDLEN),
               (TB, _T("Too much userdata (%u)"), pConn->userDataLen));

    /************************************************************************/
    /* Work out the length of the GCC PDU: Fixed body + H221 Key +          */
    /* userDataLength (1 or 2) + user Data                                  */
    /************************************************************************/
    gccPDULen = NC_GCC_REQLEN + H221_KEY_LEN + 1 + pConn->userDataLen;
    if (pConn->userDataLen >= 128)
    {
        TRC_DBG((TB, _T("Two byte GCC PDU length field")));
        gccPDULen++;
    }
    TRC_DBG((TB, _T("GCC PDU Length %u"), gccPDULen));

    /************************************************************************/
    /* Write fixed MCS header                                               */
    /************************************************************************/
    pGCCPDU = &(mcsUserData[0]);
    DC_MEMCPY(pGCCPDU, ncMCSHeader, NC_MCS_HDRLEN);
    pGCCPDU += NC_MCS_HDRLEN;

    /************************************************************************/
    /* SECURITY: Note that the first few fields that we write into pGCCPDU  */
    /* don't have to be validated for buffer overruns.  This is because     */
    /* they are fixed-size, and pGCCPDU points to a fixed-size buffer.      */
    /* The first variable-length field that is written into this buffer is  */
    /* pUserData (len==userDataLen), which is below.                        */
    /************************************************************************/

    if (gccPDULen < 128)
    {
        /********************************************************************/
        /* single length byte                                               */
        /********************************************************************/
        *pGCCPDU++ = (DCUINT8)gccPDULen;
    }
    else
    {
        /********************************************************************/
        /* two length bytes                                                 */
        /********************************************************************/
        *pGCCPDU++ = (DCUINT8)((gccPDULen >> 8) | 0x0080);
        *pGCCPDU++ = (DCUINT8)(gccPDULen & 0x00FF);
    }

    /************************************************************************/
    /* Fixed GCC PDU body                                                   */
    /************************************************************************/
    DC_MEMCPY(pGCCPDU, ncGCCBody, NC_GCC_REQLEN);
    pGCCPDU += NC_GCC_REQLEN;

    /************************************************************************/
    /* H221 key                                                             */
    /************************************************************************/
    DC_MEMCPY(pGCCPDU, CLIENT_H221_KEY, H221_KEY_LEN);
    pGCCPDU += H221_KEY_LEN;

    /************************************************************************/
    /* Total Length = MCS header + GCC PDU + 1 or 2 length bytes.           */
    /************************************************************************/
    mcsUserDataLen = NC_MCS_HDRLEN + gccPDULen + 1;

    /************************************************************************/
    /* The GCC user data length field - 2 bytes if length > 127.            */
    /************************************************************************/
    if (pConn->userDataLen < 128)
    {
        *pGCCPDU++ = (DCUINT8)(pConn->userDataLen & 0x00ff);
    }
    else
    {
        TRC_NRM((TB, _T("Long UserData %d"), pConn->userDataLen));
        *pGCCPDU++ = (DCUINT8)((pConn->userDataLen >> 8) | 0x0080);
        *pGCCPDU++ = (DCUINT8)(pConn->userDataLen & 0x00ff);

        /********************************************************************/
        /* Add extra length byte                                            */
        /********************************************************************/
        mcsUserDataLen++;
    }

    /********************************************************************/
    /* Verify that the buffer has enough room, AND the source has       */
    /* enough data.                                                     */
    /********************************************************************/
    if (!IsContainedMemory(&(mcsUserData[0]), NC_GCCREQ_MAX_PDULEN, pGCCPDU, userDataLen) ||
        !IsContainedMemory(pData, dataLen, pUserData, userDataLen))
    {
        DCUINT errorCode;
        TRC_ABORT((TB, _T("Data source/dest size mismatch: targetsize=%u, sourcebuf=%u, copysize=%u"),
                  NC_GCCREQ_MAX_PDULEN, dataLen, userDataLen));

        /************************************************************************/
        /* Again, haven't called into MCS layer yet, so disconnect by calling   */
        /* NC_OnMCSDisconnected directly.                                       */
        /************************************************************************/
        errorCode = NL_MAKE_DISCONNECT_ERR(NL_ERR_NCNOUSERDATA);
        NC_OnMCSDisconnected(errorCode);
        DC_QUIT;
    }

    /************************************************************************/
    /* Write the SL + core UserData.                                        */
    /************************************************************************/
    DC_MEMCPY(pGCCPDU, pUserData, userDataLen);

    /************************************************************************/
    /* Write the NET user data                                              */
    /************************************************************************/
    if (netUserData.channelCount != 0)
    {
        TRC_NRM((TB, _T("Append NET user data")));
        pGCCPDU += userDataLen;
        DC_MEMCPY(pGCCPDU, &netUserData, sizeof(netUserData));
        pGCCPDU += sizeof(netUserData);
        DC_MEMCPY(pGCCPDU,
                  pVirtualChannels,
                  netUserData.header.length - sizeof(netUserData));
    }

    TRC_DATA_NRM("MCS User Data passed in", mcsUserData, mcsUserDataLen);

    /************************************************************************/
    /* Call MCS_Connect passing in the GCC CreateConference PDU as          */
    /* userdata.                                                            */
    /************************************************************************/
    _pMcs->MCS_Connect(bInitateConnect,
                (PDCTCHAR)pAddress,
                mcsUserData,
                mcsUserDataLen);

DC_EXIT_POINT:
    DC_END_FN();
    return;

} /* NC_Connect */


/**PROC+*********************************************************************/
/* Name:      NC_Disconnect                                                 */
/*                                                                          */
/* Purpose:   Disconnect from the Server by calling MCS                     */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    IN      unused - unused parameter                             */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CNC::NC_Disconnect(ULONG_PTR unused)
{
    DC_BEGIN_FN("NC_Disconnect");

    DC_IGNORE_PARAMETER(unused);

    /************************************************************************/
    /* Disconnect from the server by calling MCS_Disconnect.                */
    /************************************************************************/
    TRC_NRM((TB, _T("Call MCS_Disconnect")));
    _pMcs->MCS_Disconnect();

    DC_END_FN();
    return;

} /* NC_Disconnect */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\mcsapi.cpp ===
/**MOD+**********************************************************************/
/* Module:    mcsapi.cpp                                                    */
/*                                                                          */
/* Purpose:   MCS API code                                                  */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
extern "C" {
/****************************************************************************/
/* Tracing defines and include.                                             */
/****************************************************************************/
#define TRC_FILE "mcsapi"
#define TRC_GROUP TRC_GROUP_NETWORK
#include <atrcapi.h>
}

#include "autil.h"
#include "mcs.h"
#include "cd.h"
#include "xt.h"
#include "nc.h"
#include "nl.h"


CMCS::CMCS(CObjs* objs)
{
    _pClientObjects = objs;
}

CMCS::~CMCS()
{
}

/****************************************************************************/
/*                                                                          */
/* FUNCTIONS                                                                */
/*                                                                          */
/****************************************************************************/
/**PROC+*********************************************************************/
/* Name:      MCS_Init                                                      */
/*                                                                          */
/* Purpose:   Initializes _MCS.                                              */
/*                                                                          */
/* Returns:   Nothing.                                                      */
/*                                                                          */
/* Params:    None.                                                         */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CMCS::MCS_Init(DCVOID)
{
    DC_BEGIN_FN("MCS_Init");

    /************************************************************************/
    /* Initialize global data.                                              */
    /************************************************************************/
    DC_MEMSET(&_MCS, 0, sizeof(_MCS));

    _pCd  = _pClientObjects->_pCdObject;
    _pNc  = _pClientObjects->_pNcObject;
    _pUt  = _pClientObjects->_pUtObject;
    _pXt  = _pClientObjects->_pXTObject;
    _pNl  = _pClientObjects->_pNlObject;
    _pSl  = _pClientObjects->_pSlObject;

    /************************************************************************/
    /* Pre-allocate memory for the header buffer.                           */
    /************************************************************************/

    _MCS.pHdrBuf = (PDCUINT8)UT_Malloc( _pUt,  MCS_DEFAULT_HEADER_LENGTH );

    if( _MCS.pHdrBuf )
    {
        _MCS.hdrBufLen = MCS_DEFAULT_HEADER_LENGTH;
    }
    else
    {
        TRC_ASSERT(((ULONG_PTR)_MCS.pHdrBuf),
                 (TB, _T("Cannot allocate memory for MCS header")));
    }

    /************************************************************************/
    /* Set the received packet buffer pointer - this must be aligned to     */
    /* 4-byte boundary + 2, in order that 32-bit fields within a T.128      */
    /* packet are correctly aligned.                                        */
    /************************************************************************/
    _MCS.pReceivedPacket = &(_MCS.dataBuf[2]);

    TRC_ASSERT(((ULONG_PTR)_MCS.pReceivedPacket % 4 == 2),
             (TB, _T("Data buffer %p not 2-byte aligned"), _MCS.pReceivedPacket));

    /************************************************************************/
    /* Call the XT initialization function.                                 */
    /************************************************************************/
    _pXt->XT_Init();

    TRC_NRM((TB, _T("MCS successfully initialized")));

    DC_END_FN();
    return;

} /* MCS_Init */


/**PROC+*********************************************************************/
/* Name:      MCS_Term                                                      */
/*                                                                          */
/* Purpose:   Terminates _MCS.                                               */
/*                                                                          */
/* Returns:   Nothing.                                                      */
/*                                                                          */
/* Params:    None.                                                         */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CMCS::MCS_Term(DCVOID)
{
    DC_BEGIN_FN("MCS_Term");

    if( _MCS.pHdrBuf )
    {
        UT_Free( _pUt,  _MCS.pHdrBuf );
        _MCS.pHdrBuf = NULL;
        _MCS.hdrBufLen = 0;
    }

    /************************************************************************/
    /* Call the XT termination function.                                    */
    /************************************************************************/
    _pXt->XT_Term();

    TRC_NRM((TB, _T("MCS successfully terminated")));

    DC_END_FN();
    return;

} /* MCS_Term */


/**PROC+*********************************************************************/
/* Name:      MCS_Connect                                                   */
/*                                                                          */
/* Purpose:   This function calls XT_Connect to begin the connection        */
/*            process.  This will hopefully result in a MCS_OnXTConnected   */
/*            callback from XT.  At that point we can send the MCS          */
/*            Connect-Initial PDU.                                          */
/*                                                                          */
/* Returns:   Nothing.                                                      */
/*                                                                          */
/* Params:    IN  bInitateConnect - TRUE to Initate connection              */
/*            IN  pServerAddress - the address of the server to call.       */
/*            IN  pUserData      - a pointer to some user data.             */
/*            IN  userDataLength - the length of the user data.             */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CMCS::MCS_Connect(BOOL bInitateConnect,
                        PDCTCHAR pServerAddress,
                         PDCUINT8 pUserData,
                         DCUINT   userDataLength)
{
    DC_BEGIN_FN("MCS_Connect");

    /************************************************************************/
    /* Use the receiver buffer to temporarily store the user data.  We'll   */
    /* need to add it to the Connect-Initial PDU when we assemble it after  */
    /* receiving the MCS_OnXTConnected callback.                            */
    /************************************************************************/
    _MCS.userDataLength = userDataLength;
    TRC_ASSERT((_MCS.pReceivedPacket != NULL), (TB, _T("Null rcv packet buffer")));
    DC_MEMCPY(_MCS.pReceivedPacket, pUserData, _MCS.userDataLength);

    TRC_NRM((TB, _T("Copied userdata, now calling XT_Connect (address:%s)..."),
             pServerAddress));

    /************************************************************************/
    /* Now start the connection process.                                    */
    /************************************************************************/
    _pXt->XT_Connect(bInitateConnect, pServerAddress);

    DC_END_FN();
    return;

} /* MCS_Connect */


/**PROC+*********************************************************************/
/* Name:      MCS_Disconnect                                                */
/*                                                                          */
/* Purpose:   This function sends a Disconnect-Provider ultimatum PDU to    */
/*            the server.  After that has happened MCSContinueDisconnect    */
/*            will call XT_Disconnect to disconnect the lower layers.       */
/*                                                                          */
/* Returns:   Nothing.                                                      */
/*                                                                          */
/* Params:    None.                                                         */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CMCS::MCS_Disconnect(DCVOID)
{
    DC_BEGIN_FN("MCS_Disconnect");

    /************************************************************************/
    /* Call MCS to send a disconnect provider ultimatum.                    */
    /************************************************************************/
    TRC_NRM((TB, _T("Decouple to snd thrd and send MCS DPum PDU")));
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                                        this,
                                        CD_NOTIFICATION_FUNC(CMCS, MCSSendDisconnectProviderUltimatum),
                                        (ULONG_PTR) 0);

    DC_END_FN();
    return;

} /* MCS_Disconnect */


/**PROC+*********************************************************************/
/* Name:      MCS_AttachUser                                                */
/*                                                                          */
/* Purpose:   Generates and sends a MCS Attach-User-Request PDU.            */
/*                                                                          */
/* Returns:   Nothing.                                                      */
/*                                                                          */
/* Params:    None.                                                         */
/*                                                                          */
/* Operation: This function will result in a NC_OnMCSAttachUserConfirm      */
/*            callback.                                                     */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CMCS::MCS_AttachUser(DCVOID)
{
    DC_BEGIN_FN("MCS_AttachUser");

    /************************************************************************/
    /* Decouple to the send thread and send an MCS Attach-User-Request PDU. */
    /************************************************************************/
    TRC_NRM((TB, _T("Decouple to snd thrd and send MCS AUR PDU")));
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                    CD_NOTIFICATION_FUNC(CMCS, MCSSendAttachUserRequest),
                    (ULONG_PTR) 0);
    DC_END_FN();
    return;

} /* MCS_AttachUser */


/**PROC+*********************************************************************/
/* Name:      MCS_JoinChannel                                               */
/*                                                                          */
/* Purpose:   Joins the specified MCS channel.                              */
/*                                                                          */
/* Returns:   Nothing.                                                      */
/*                                                                          */
/* Params:    IN  channel - the channel ID to join.                         */
/*            IN  userID  - the MCS user ID.                                */
/*                                                                          */
/* Operation: This function will result in a NC_OnMCSChannelJoinConfirm     */
/*            callback.                                                     */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CMCS::MCS_JoinChannel(DCUINT channel, DCUINT userID)
{
    MCS_DECOUPLEINFO decoupleInfo;

    DC_BEGIN_FN("MCS_JoinChannel");

    //
    // Flag which channel we are currently joining so we
    // can validate channel confirm PDU's.
    //
    MCS_SetPendingChannelJoin((DCUINT16)channel);

    /************************************************************************/
    /* Fill in the decoupling information structure.                        */
    /************************************************************************/
    decoupleInfo.channel = channel;
    decoupleInfo.userID  = userID;

    /************************************************************************/
    /* Decouple to the send thread and send an MCS Channel-Join-Request     */
    /* PDU.                                                                 */
    /************************************************************************/
    TRC_NRM((TB, _T("Decouple to snd thrd and send MCS CJR PDU")));
    _pCd->CD_DecoupleNotification(CD_SND_COMPONENT,
                                  this,
                                  CD_NOTIFICATION_FUNC(CMCS, MCSSendChannelJoinRequest),
                                  &decoupleInfo,
                                  sizeof(decoupleInfo));
    DC_END_FN();
    return;

} /* MCS_JoinChannel */


/**PROC+*********************************************************************/
/* Name:      MCS_GetBuffer                                                 */
/*                                                                          */
/* Purpose:   Attempts to get a buffer from XT.  This function gets a       */
/*            buffer which is big enough to include the MCS header and then */
/*            updates the buffer pointer obtained from XT past the space    */
/*            reserved for the MCS header.                                  */
/*                                                                          */
/* Returns:   TRUE if a buffer is successfully obtained and FALSE           */
/*            otherwise.                                                    */
/*                                                                          */
/* Params:    IN   dataLength - length of the buffer requested.             */
/*            OUT  ppBuffer   - a pointer to a pointer to the buffer.       */
/*            OUT  pBufHandle - a pointer to a buffer handle.               */
/*                                                                          */
/**PROC-*********************************************************************/
DCBOOL DCAPI CMCS::MCS_GetBuffer(DCUINT      dataLength,
                           PPDCUINT8   ppBuffer,
                           PMCS_BUFHND pBufHandle)
{
    DCBOOL   rc;
    DCUINT   headerLength;
    PDCUINT8 pBuf = NULL;
    DCUINT   alignment;
    DCUINT   alignPad = 0;

    DC_BEGIN_FN("MCS_GetBuffer");

    /************************************************************************/
    /* Calculate the required header length.                                */
    /************************************************************************/
    headerLength = MCSGetSDRHeaderLength(dataLength);

    TRC_DBG((TB, _T("dataLength:%u headerLength:%u"), dataLength, headerLength));

    /************************************************************************/
    /* Now add this length to the total amount of data needed from XT.      */
    /************************************************************************/
    dataLength += headerLength;

    /************************************************************************/
    /* Adjust the length to take account of the 4n+2 alignment below.       */
    /************************************************************************/
    alignment = (_pXt->XT_GetBufferHeaderLen() + headerLength) % 4;
    TRC_DBG((TB, _T("alignment:%u"), alignment));
    if (alignment != 2)
    {
        alignPad = (6 - alignment) % 4;
        dataLength += alignPad;
        TRC_DBG((TB, _T("datalength now:%u"), dataLength));
    }

    /************************************************************************/
    /* Now get a buffer from XT.                                            */
    /************************************************************************/
    rc = _pXt->XT_GetPublicBuffer(dataLength, &pBuf, (PXT_BUFHND) pBufHandle);

    if (!rc)
    {
        /********************************************************************/
        /* We failed to get a buffer so just quit.                          */
        /********************************************************************/
        TRC_DBG((TB, _T("Failed to get a buffer from XT")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Now move the buffer pointer along to make space for our header.      */
    /************************************************************************/
    TRC_DBG((TB, _T("Moving header ptr from %p to %p"),
             pBuf,
             pBuf + headerLength));
    *ppBuffer = pBuf + headerLength;

    /************************************************************************/
    /* Force alignment to be 4n+2 - so that T.128 PDUs are naturally        */
    /* aligned.                                                             */
    /************************************************************************/
    if (alignment != 2)
    {
        *ppBuffer += alignPad;
        TRC_DBG((TB, _T("Realigned buffer pointer to %p"), *ppBuffer));
    }

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);

} /* MCS_GetBuffer */


/**PROC+*********************************************************************/
/* Name:      MCS_SendPacket                                                */
/*                                                                          */
/* Purpose:   Generates and adds an MCS header to the packet before         */
/*            passing it to XT to send.                                     */
/*                                                                          */
/* Returns:   Nothing.                                                      */
/*                                                                          */
/* Params:    IN  pData      - pointer to the start of the data.            */
/*            IN  dataLength - length of the data.                          */
/*            IN  bufHandle  - MCS buffer handle.                           */
/*            IN  channel    - channel to send the data on.                 */
/*            IN  priority   - priority to send the data at.                */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CMCS::MCS_SendPacket(PDCUINT8   pData,
                            DCUINT     dataLength,
                            DCUINT     flags,
                            MCS_BUFHND bufHandle,
                            DCUINT     userID,
                            DCUINT     channel,
                            DCUINT     priority)
{
    PDCUINT8 pHeader;
    DCUINT   headerLength;

    DC_BEGIN_FN("MCS_SendPacket");

    /************************************************************************/
    /* Ignore the priority parameter as we implement a single priority.     */
    /* Also ignore the flags parameter as we don't support any flags at     */
    /* present.                                                             */
    /************************************************************************/
    DC_IGNORE_PARAMETER(priority);
    DC_IGNORE_PARAMETER(flags);

    /************************************************************************/
    /* Assert that the hiword of the channel is 0.                          */
    /************************************************************************/
    TRC_ASSERT((0 == HIWORD((DCUINT32)channel)),
               (TB, _T("Hi-word of channel is non-zero")));

    /************************************************************************/
    /* Assert that the hiword of the user-id is 0.                          */
    /************************************************************************/
    TRC_ASSERT((0 == HIWORD((DCUINT32)userID)),
               (TB, _T("Hi-word of userID is non-zero")));

    /************************************************************************/
    /* Check that the packet length is within the allowable range.          */
    /************************************************************************/
    TRC_ASSERT((dataLength < MCS_MAX_SNDPKT_LENGTH),
               (TB, _T("Bad packet length :%u"), dataLength));

    /************************************************************************/
    /* Update the performance counter.                                      */
    /************************************************************************/
    PRF_INC_COUNTER(PERF_PKTS_SENT);

    /************************************************************************/
    /* The size of the MCS header is variable and depends on the length     */
    /* of the data in the PDU.  Calculate the length now.                   */
    /************************************************************************/
    headerLength = MCSGetSDRHeaderLength(dataLength);

    /************************************************************************/
    /* Wind back the data buffer pointer by the size of the MCS header.     */
    /************************************************************************/
    pData  -= headerLength;
    pHeader = pData;

    /************************************************************************/
    /* Generate the header - there is so little commonality between SDrq    */
    /* PDUs that we just fill all the fields in directly - instead of       */
    /* memcpying a common structure and filling in the case-specific gaps.  */
    /*                                                                      */
    /* Fill in the first byte.  The upper six bits of this byte contain the */
    /* PDU type followed by two bits of padding.                            */
    /************************************************************************/
    *pHeader = 0x64;
    pHeader++;

    /************************************************************************/
    /* Fill in the user-id.  Convert it from our local byte order to the    */
    /* wire byte order.                                                     */
    /* Avoid non-aligned access.                                            */
    /************************************************************************/
    *pHeader++ = (DCUINT8)(MCSLocalUserIDToWireUserID((DCUINT16)userID));
    *pHeader++ = (DCUINT8)(MCSLocalUserIDToWireUserID((DCUINT16)userID) >> 8);

    /************************************************************************/
    /* Fill in the channel-id.  Convert it from our local byte order to the */
    /* wire byte order.                                                     */
    /************************************************************************/
    *pHeader++ = (DCUINT8)(MCSLocalToWire16((DCUINT16)channel));
    *pHeader++ = (DCUINT8)(MCSLocalToWire16((DCUINT16)channel) >> 8);

    /************************************************************************/
    /* Fill in the data priority and segmentation.  The next byte is used   */
    /* in the following way (with our settings in square brackets on the    */
    /* far right):                                                          */
    /*                                                                      */
    /* b7 (MSB) : priority                                  [0]             */
    /* b6       : priority                                  [1]             */
    /* b5       : begin segmentation flag                   [1]             */
    /* b4       : end segmentation flag                     [1]             */
    /* b3       : padding                                   [0]             */
    /* b2       : padding                                   [0]             */
    /* b1       : padding                                   [0]             */
    /* b0 (LSB) : padding                                   [0]             */
    /*                                                                      */
    /* Our settings can be hard-coded as we only have one priority and      */
    /* never segment data.                                                  */
    /************************************************************************/
    *pHeader = 0x70;
    pHeader++;

    /************************************************************************/
    /* Now fill in the length of the user-data using packed encoded rules.  */
    /* These are as follows:                                                */
    /*                                                                      */
    /*  - if the length is less than 128 bytes then it is encoded using a   */
    /*    single byte.                                                      */
    /*  - if the length is more than 128 bytes but less than 16K then it    */
    /*    encoded using two bytes with the MSB of the first byte set to 1.  */
    /*                                                                      */
    /* Note that if the length is 16K or more then more complex encoding    */
    /* rules apply but we do not generate any packets greater than 16K in   */
    /* length currently.                                                    */
    /************************************************************************/
    if (dataLength < 128)
    {
        /********************************************************************/
        /* The length is less than 128 bytes so just fill in the value      */
        /* directly.                                                        */
        /********************************************************************/
        *pHeader = (DCUINT8) dataLength;
    }
    else
    {
        /********************************************************************/
        /* The length is greater than 128 bytes (and less than 16K) so fill */
        /* in the length.                                                   */
        /********************************************************************/
        *pHeader = (DCUINT8)(MCSLocalToWire16((DCUINT16)dataLength));
        *(pHeader+1) = (DCUINT8)(MCSLocalToWire16((DCUINT16)dataLength) >> 8);

        /********************************************************************/
        /* We now to set the MSB of the first byte to 1.                    */
        /********************************************************************/
        *pHeader |= 0x80;
    }

    /************************************************************************/
    /* Trace out the MCS header.                                            */
    /************************************************************************/
    TRC_DATA_DBG("MCS SDrq header", pData, headerLength);

    /************************************************************************/
    /* Now get XT to send the packet for us.                                */
    /************************************************************************/
    dataLength += headerLength;
    _pXt->XT_SendBuffer(pData, dataLength, (XT_BUFHND) bufHandle);

    TRC_DBG((TB, _T("Sent %u bytes of data on channel %#x"),
             dataLength,
             channel));

    DC_END_FN();
    return;

} /* MCS_SendPacket */


/**PROC+*********************************************************************/
/* Name:      MCS_FreeBuffer                                                */
/*                                                                          */
/* Purpose:   Frees a buffer.                                               */
/*                                                                          */
/* Returns:   Nothing.                                                      */
/*                                                                          */
/* Params:    IN  bufHandle  - MCS buffer handle.                           */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CMCS::MCS_FreeBuffer(MCS_BUFHND bufHandle)
{
    DC_BEGIN_FN("MCS_FreeBuffer");

    /************************************************************************/
    /* Pass this call through to XT to free the buffer.                     */
    /************************************************************************/
    _pXt->XT_FreeBuffer((XT_BUFHND) bufHandle);

    DC_END_FN();
    return;

} /* MCS_FreeBuffer */

/****************************************************************************/
/*                                                                          */
/* CALLBACKS                                                                */
/*                                                                          */
/****************************************************************************/
/**PROC+*********************************************************************/
/* Name:      MCS_OnXTConnected                                             */
/*                                                                          */
/* Purpose:   This function is called by XT when it has successfully        */
/*            connected.                                                    */
/*                                                                          */
/* Returns:   Nothing.                                                      */
/*                                                                          */
/* Params:    None.                                                         */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CMCS::MCS_OnXTConnected(DCVOID)
{
    DC_BEGIN_FN("MCS_OnXTConnected");

    /************************************************************************/
    /* Set up our receive control variable.  The initial state is           */
    /* MCS_RCVST_PDUENCODING so that we can work out what PDU encoding has  */
    /* been used for the PDU.  Also set the number of bytes needed and      */
    /* reset the count of header bytes read so far.                         */
    /************************************************************************/
    _MCS.rcvState        = MCS_RCVST_PDUENCODING;
    _MCS.hdrBytesNeeded  = MCS_NUM_PDUENCODING_BYTES;
    _MCS.hdrBytesRead    = 0;

    /************************************************************************/
    /* Set up the data receive control variables.  The initial state is     */
    /* MCS_DATAST_SIZE1 which is used to determine the size of the PDU from */
    /* the previously read header information.  Also set the number of      */
    /* bytes needed to zero (the number of bytes needed will be calculated  */
    /* once the size of the data in the PDU has been determined).  Finally  */
    /* the number of bytes read must be zero.                               */
    /************************************************************************/
    _MCS.dataState       = MCS_DATAST_SIZE1;
    _MCS.dataBytesNeeded = 0;
    _MCS.dataBytesRead   = 0;

    /************************************************************************/
    /* Finally decouple to the sender thread and get it to send the MCS     */
    /* Connect-Initial PDU.                                                 */
    /************************************************************************/
    TRC_NRM((TB, _T("Decouple to snd thrd and send MCS CI PDU")));
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                                        this,
                                        CD_NOTIFICATION_FUNC(CMCS, MCSSendConnectInitial),
                                        (ULONG_PTR) 0);
    DC_END_FN();
    return;

} /* MCS_OnXTConnected */


/**PROC+*********************************************************************/
/* Name:      MCS_OnXTDisconnected                                          */
/*                                                                          */
/* Purpose:   This callback function is called by XT when it has            */
/*            disconnected.                                                 */
/*                                                                          */
/* Returns:   Nothing.                                                      */
/*                                                                          */
/* Params:    IN  reason - reason for the disconnection.                    */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CMCS::MCS_OnXTDisconnected(DCUINT reason)
{
    DC_BEGIN_FN("MCS_OnXTDisconnected");

    TRC_ASSERT((reason != 0), (TB, _T("Disconnect reason from XT is 0")));

    /************************************************************************/
    /* Decide if we want to over-ride the disconnect reason code.           */
    /************************************************************************/
    if (_MCS.disconnectReason != 0)
    {
        TRC_ALT((TB, _T("Over-riding disconnection reason (%#x->%#x)"),
                 reason,
                 _MCS.disconnectReason));

        /********************************************************************/
        /* Over-ride the error code and set the global variable to 0.       */
        /********************************************************************/
        reason = _MCS.disconnectReason;
        _MCS.disconnectReason = 0;
    }

    /************************************************************************/
    /* Call NC to let him know that we've disconnected.                     */
    /************************************************************************/
    TRC_NRM((TB, _T("Disconnect reason:%#x"), reason));
    _pNc->NC_OnMCSDisconnected(reason);

    DC_END_FN();
    return;

} /* MCS_OnXTDisconnected */


/**PROC+*********************************************************************/
/* Name:      MCS_OnXTDataAvailable                                         */
/*                                                                          */
/* Purpose:   This callback function is called by XT when it has data       */
/*            available for MCS to process.  It returns either when MCS     */
/*            has finished processing a MCS PDU completely or when XT       */
/*            runs out of data.                                             */
/*                                                                          */
/* Returns:   TRUE if a MCS frame was processed completely and FALSE if     */
/*            a MCS frame is still being processed.                         */
/*                                                                          */
/* Params:    None.                                                         */
/*                                                                          */
/**PROC-*********************************************************************/
DCBOOL DCCALLBACK CMCS::MCS_OnXTDataAvailable(DCVOID)
{
    DCUINT  pduType;
    DCUINT  lengthBytes;
    DCBOOL  rc = FALSE;

    DC_BEGIN_FN("MCS_OnXTDataAvailable");

    /************************************************************************/
    /* Loop while there is data available in XT and we have not completed   */
    /* the processing of one MCS frame.                                     */
    /************************************************************************/
    while (_pXt->XT_QueryDataAvailable())
    {
        TRC_DBG((TB, _T("Data available in XT, state:%u"), _MCS.rcvState));

        /********************************************************************/
        /* Now switch on the receive state.                                 */
        /********************************************************************/
        switch (_MCS.rcvState)
        {
            case MCS_RCVST_PDUENCODING:
            {
                /************************************************************/
                /* We're expecting to receive some bytes of PDU encoding.   */
                /* Try to receive some more data into the header buffer.    */
                /************************************************************/
                if (MCSRecvToHdrBuf())
                {
                    /********************************************************/
                    /* Successfully received all the encoding bytes that    */
                    /* were required.  Now determine if this a BER or PER   */
                    /* encoded PDU.  This is done by looking at the first   */
                    /* byte to see if it is equal to the MCS BER connect    */
                    /* PDU prefix.                                          */
                    /********************************************************/
                    if (MCS_BER_CONNECT_PREFIX == _MCS.pHdrBuf[0])
                    {
                        /****************************************************/
                        /* This is a BER encoded PDU.  Get the next two     */
                        /* bytes.  The first of these contains the PDU      */
                        /* type while the second is the first length field. */
                        /* The length field is a variable length field so   */
                        /* we need to get the first byte to determine the   */
                        /* actual length.                                   */
                        /****************************************************/
                        _MCS.rcvState       = MCS_RCVST_BERHEADER;
                        _MCS.hdrBytesNeeded = 2;

                        TRC_NRM((TB, _T("State PDUENCODING->BERHEADER")));
                    }
                    else
                    {
                        /****************************************************/
                        /* This is a PER encoded PDU.  Determine the pdu    */
                        /* type and the number of remaining bytes to        */
                        /* receive.                                         */
                        /****************************************************/
                        MCSGetPERInfo(&pduType, &_MCS.hdrBytesNeeded);

                        if (MCS_TYPE_SENDDATAINDICATION == pduType)
                        {
                            /************************************************/
                            /* It's a data PDU so change to the data state. */
                            /************************************************/
                            _MCS.rcvState = MCS_RCVST_DATA;
                            TRC_DBG((TB, _T("State PDUENCODING->DATA")));
                        }
                        else
                        {
                            /************************************************/
                            /* It's a control PDU so change to the control  */
                            /* state.                                       */
                            /************************************************/
                            _MCS.rcvState = MCS_RCVST_CONTROL;
                            TRC_NRM((TB, _T("State PDUENCODING->CONTROL")));
                        }
                    }
                }
            }
            break;

            case MCS_RCVST_BERHEADER:
            {
                if (MCSRecvToHdrBuf())
                {
                    /********************************************************/
                    /* We now have a complete BER header so split out the   */
                    /* type.  We are expecting this to be a                 */
                    /* Connect-Response PDU, so check for this now.         */
                    /********************************************************/
                    TRC_DATA_NRM("Header buffer contents:",
                                 _MCS.pHdrBuf,
                                 _MCS.hdrBytesRead);

                    pduType = _MCS.pHdrBuf[1];

                    if (MCS_TYPE_CONNECTRESPONSE != pduType)
                    {
                        /****************************************************/
                        /* This is not a Connect-Response PDU.  Something   */
                        /* bad has happened to cause the other party to     */
                        /* send us this so get out now by disconnecting.    */
                        /****************************************************/
                        TRC_DATA_ERR("Header buffer contents:",
                                     _MCS.pHdrBuf,
                                     _MCS.hdrBytesRead);
                        TRC_ABORT((TB, _T("Not a MCS Connect-Response PDU")));
                        MCSSetReasonAndDisconnect(NL_ERR_MCSNOTCRPDU);
                        DC_QUIT;
                    }

                    /********************************************************/
                    /* The second byte tells us the length of the length    */
                    /* field itself.  For PDUs less than 127 bytes the      */
                    /* length is encoded directly in this field - for       */
                    /* lengths greater than 127 bytes this field has the    */
                    /* high bit set and the other bits contain a count of   */
                    /* the number of remaining bytes in the length field.   */
                    /********************************************************/
                    lengthBytes = MCSGetBERLengthSize(_MCS.pHdrBuf[2]) - 1;

                    if (0 == lengthBytes)
                    {
                        /****************************************************/
                        /* The length is less than or equal to 127 bytes so */
                        /* we don't need to get any additional length       */
                        /* bytes.  This means we can switch directly to the */
                        /* reading data state.                              */
                        /****************************************************/
                        _MCS.rcvState       = MCS_RCVST_CONTROL;
                        _MCS.hdrBytesNeeded = _MCS.pHdrBuf[2];
                        TRC_NRM((TB, _T("%u bytes needed"), _MCS.hdrBytesNeeded));

                        TRC_NRM((TB, _T("State BERHEADER->CONTROL")));
                    }
                    else
                    {
                        TRC_NRM((TB, _T("Length > 127 (%u length bytes remain)"),
                                 lengthBytes));

                        /****************************************************/
                        /* We don't expect to get a PDU more than 64Kb in   */
                        /* length - if we do then just disconnect as        */
                        /* something has obviously gone wrong.              */
                        /*                                                  */
                        /* SECURITY: The length coming from within the      */
                        /* packet is bad, but it is capped to 64k.  Thus,   */
                        /* this code-path won't ask the client to allocate  */
                        /* an infinite amount of memory.                    */
                        /****************************************************/
                        if (lengthBytes > 2)
                        {
                            TRC_ABORT((TB,
                                      _T("Bad MCS Connect-Response length (%u)"),
                                       lengthBytes));
                            MCSSetReasonAndDisconnect(NL_ERR_MCSBADCRLENGTH);
                            DC_QUIT;
                        }

                        /****************************************************/
                        /* We now need to read the remaining bytes in this  */
                        /* PDU so set up the new state variables and bytes  */
                        /* required.                                        */
                        /****************************************************/
                        _MCS.rcvState       = MCS_RCVST_BERLENGTH;
                        _MCS.hdrBytesNeeded = lengthBytes;

                        TRC_NRM((TB, _T("State BERHEADER->BERLENGTH")));
                    }
                }
            }
            break;

            case MCS_RCVST_BERLENGTH:
            {
                if (MCSRecvToHdrBuf())
                {
                    /********************************************************/
                    /* We now have a complete length field.                 */
                    /********************************************************/
                    TRC_DATA_NRM("Header buffer contents:",
                                 _MCS.pHdrBuf,
                                 _MCS.hdrBytesRead);

                    /********************************************************/
                    /* Work out how many length bytes are in this PDU.      */
                    /*                                                      */
                    /* SECURITY: The length coming from within the          */
                    /* packet is bad, but it is capped to 64k.  Thus,       */
                    /* this code-path won't ask the client to allocate      */
                    /* an infinite amount of memory.                        */
                    /********************************************************/
                    _MCS.hdrBytesNeeded = MCSGetBERLength(&_MCS.pHdrBuf[2]);
                    TRC_NRM((TB, _T("%u bytes needed"), _MCS.hdrBytesNeeded));

                    /********************************************************/
                    /* Finally set the next state.                          */
                    /********************************************************/
                    _MCS.rcvState = MCS_RCVST_CONTROL;
                    TRC_NRM((TB, _T("State BERLENGTH->CONTROL")));
                }
            }
            break;

            case MCS_RCVST_CONTROL:
            {
                if (MCSRecvToHdrBuf())
                {
                    /********************************************************/
                    /* We've now got a complete MCS control packet, so      */
                    /* hand it over to the interpretation function.         */
                    /********************************************************/
                    MCSHandleControlPkt();

                    /********************************************************/
                    /* Reset the state variables, ready for the next        */
                    /* packet.                                              */
                    /********************************************************/
                    _MCS.rcvState       = MCS_RCVST_PDUENCODING;
                    _MCS.hdrBytesRead   = 0;
                    _MCS.hdrBytesNeeded = 1;

                    /********************************************************/
                    /* Set the return code.  MCS will use this to throw     */
                    /* away any additional bytes that might exist in the    */
                    /* XT frame.                                            */
                    /********************************************************/
                    rc = TRUE;
                    TRC_NRM((TB, _T("State CONTROL->PDUENCODING")));

                    DC_QUIT;
                }
            }
            break;

            case MCS_RCVST_DATA:
            {
                HRESULT hrTemp;
                BOOL    fFinishedData;

                /************************************************************/
                /* Call the receive data function.                          */
                /************************************************************/
                hrTemp = MCSRecvData(&fFinishedData);
                if (fFinishedData || !SUCCEEDED(hrTemp))
                {
                    /********************************************************/
                    /* We've processed another complete packet for the      */
                    /* layer above, so reset our state variables.           */
                    /********************************************************/
                    _MCS.rcvState       = MCS_RCVST_PDUENCODING;
                    _MCS.hdrBytesRead   = 0;
                    _MCS.hdrBytesNeeded = MCS_NUM_PDUENCODING_BYTES;

                    /********************************************************/
                    /* In a failure case (MCSRecvData failed), we enter     */
                    /* this branch and clean up the MCS state (above).      */
                    /* However, there is still state in XT and TD that      */
                    /* is waiting to be processed for this packet, and      */
                    /* bailing out here and disconnecting WON'T CLEAN THAT  */
                    /* up.  That is why we call XT_IgnoreRestofPacket().    */
                    /*
                    /* In other cases of disconnecting, such a function     */
                    /* didn't have to be called, but that's because the     */
                    /* disconnect happened after processing the entire      */
                    /* packet; Here, were in the MIDDLE of reading in date  */
                    /* from XT/TD.  Without flushing data in XT/TD, the     */
                    /* next connection in this instance of the client would */
                    /* try to read the rest of this data, which is bogus.   */
                    /********************************************************/
                    if (!SUCCEEDED(hrTemp))
                    {
                        _pXt->XT_IgnoreRestofPacket();
                    }

                    /********************************************************/
                    /* Set the return code.  MCS will use this to throw     */
                    /* away any additional bytes that might exist in the    */
                    /* XT frame.  Even if we failed above, we still want    */
                    /* to throw away bytes in the XT frame.                 */
                    /********************************************************/
                    rc = TRUE;
                    TRC_DBG((TB, _T("State DATA->PDUENCODING")));

                    DC_QUIT;
                }
            }
            break;

            default:
            {
                TRC_ABORT((TB, _T("Unrecognized MCS receive state:%u"),
                           _MCS.rcvState));
            }
            break;
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);

} /* MCS_OnXTDataAvailable */


/**PROC+*********************************************************************/
/* Name:      MCS_OnXTBufferAvailable                                       */
/*                                                                          */
/* Purpose:   Callback from XT indicating that a back-pressure situation    */
/*            which caused an earlier XT_GetBuffer call to fail has now     */
/*            been relieved.  Called on the Receiver thread.                */
/*                                                                          */
/* Returns:   Nothing.                                                      */
/*                                                                          */
/* Params:    None.                                                         */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CMCS::MCS_OnXTBufferAvailable(DCVOID)
{
    DC_BEGIN_FN("MCS_OnXTBufferAvailable");

    /************************************************************************/
    /* Call the NL callback.                                                */
    /************************************************************************/
    TRC_NRM((TB, _T("Buffer available")));
    _pNc->NC_OnMCSBufferAvailable();

    DC_END_FN();
    return;

} /* MCS_OnXTBufferAvailable */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\nl.h ===
/****************************************************************************/
// nl.h
//
// Network layer.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_NL
#define _H_NL


extern "C" {
#include <adcgdata.h>
}

#include "td.h"
#include "mcs.h"

#include "objs.h"


class CUI;
class CCD;
class CMCS;
class CNC;
class CUT;
class CRCV;

/****************************************************************************/
/* Protocol name.                                                           */
/****************************************************************************/
#define NL_PROTOCOL_T128   _T("T.128")

/****************************************************************************/
/* Transport type, passed to NL_Connect                                     */
/****************************************************************************/
#define NL_TRANSPORT_TCP   1


/****************************************************************************/
/* Callback function prototypes                                             */
/****************************************************************************/

/****************************************************************************/
/* Name:      CB_SL_INITIALIZED                                                */
/*                                                                          */
/* Purpose:   Called when Network initialization is complete                */
/****************************************************************************/
typedef void (PDCCALLBACK CB_SL_INITIALIZED) (PVOID inst);

/****************************************************************************/
/* Name:      CB_SL_TERMINATING                                             */
/*                                                                          */
/* Purpose:   Called before network terminates                              */
/*                                                                          */
/* Operation: This function is called on the NL's receive thread to allow   */
/*            resources to be freed prior to termination.                   */
/****************************************************************************/
typedef void (PDCCALLBACK CB_SL_TERMINATING)(PVOID inst);

/****************************************************************************/
/* Name:      CB_SL_CONNECTED                                               */
/*                                                                          */
/* Purpose:   Called when a connection to the Server is complete            */
/*                                                                          */
/* Params:    channelID      - ID of T.128 broadcast channel                */
/*            pUserData      - user data from Server                        */
/*            userDataLength - length of user data                          */
/****************************************************************************/
typedef void (PDCCALLBACK CB_SL_CONNECTED)(
        PVOID inst,
        unsigned channelID,
        PVOID pUserData,
        unsigned userDataLength,
        UINT32 serverVersion);

/****************************************************************************/
/* Name:      CB_SL_DISCONNECTED                                            */
/*                                                                          */
/* Purpose:   Called a connection to the Server is disconnected             */
/*                                                                          */
/* Params:    result - reason for disconnection                             */
/****************************************************************************/
typedef void (PDCCALLBACK CB_SL_DISCONNECTED) (PVOID inst, unsigned result);

/****************************************************************************/
/* Name:      CB_SL_PACKET_RECEIVED                                         */
/*                                                                          */
/* Purpose:   Called when a packet is received from the Server              */
/*                                                                          */
/* Params:    pData    - packet received                                    */
/*            dataLen  - length of packet received                          */
/*            flags    - security flags (RNS_SEC_xxx)                       */
/*            userID   - ID of user who sent the packet                     */
/*            priority - priority on which packet was received              */
/****************************************************************************/
typedef HRESULT (PDCCALLBACK CB_SL_PACKET_RECEIVED)(
        PVOID inst,
        PBYTE pData,
        unsigned dataLen,
        unsigned flags,
        unsigned userID,
        unsigned priority);

/****************************************************************************/
/* Name:      CB_SL_BUFFER_AVAILABLE                                        */
/*                                                                          */
/* Purpose:   Called when the network is ready to send again after being    */
/*            busy for a period                                             */
/****************************************************************************/
typedef void (PDCCALLBACK CB_SL_BUFFER_AVAILABLE) (PVOID inst);


/****************************************************************************/
/* Structures                                                               */
/****************************************************************************/

/****************************************************************************/
/* Structure: NLtoSL_CALLBACKS                                              */
/*                                                                          */
/* Description: list of callbacks passed to NL_Init().                      */
/****************************************************************************/
typedef struct tagNL_CALLBACKS
{
    CB_SL_INITIALIZED      onInitialized;
    CB_SL_TERMINATING      onTerminating;
    CB_SL_CONNECTED        onConnected;
    CB_SL_DISCONNECTED     onDisconnected;
    CB_SL_PACKET_RECEIVED  onPacketReceived;
    CB_SL_BUFFER_AVAILABLE onBufferAvailable;
   
} NL_CALLBACKS, FAR *PNL_CALLBACKS;


/****************************************************************************/
/* Structure: NL_BUFHND                                                     */
/*                                                                          */
/* Description: Buffer Handle                                               */
/****************************************************************************/
typedef ULONG_PTR NL_BUFHND;
typedef NL_BUFHND FAR *PNL_BUFHND;


/****************************************************************************/
/* Macroed functions                                                        */
/****************************************************************************/
#ifdef DC_DEBUG
#define NL_SetNetworkThroughput    TD_SetNetworkThroughput
#define NL_GetNetworkThroughput    TD_GetNetworkThroughput
#endif /* DC_DEBUG */

#define NL_GetBuffer               MCS_GetBuffer
#define NL_SendPacket              MCS_SendPacket
#define NL_FreeBuffer              MCS_FreeBuffer


/****************************************************************************/
/* Structure: NL_GLOBAL_DATA                                                */
/****************************************************************************/
typedef struct tagNL_GLOBAL_DATA
{
    NL_CALLBACKS callbacks;
    UT_THREAD_DATA  threadData;
} NL_GLOBAL_DATA, FAR *PNL_GLOBAL_DATA;


class CNL
{
public:
    CNL(CObjs* objs);
    ~CNL();

public:
    // API Functions

    void DCAPI NL_Init(PNL_CALLBACKS);
    
    void DCAPI NL_Term();
    
    HRESULT DCAPI NL_Connect(BOOL, PTCHAR, unsigned, PTCHAR, PVOID, unsigned);

    void DCAPI NL_Disconnect();


public:
    //
    // public data members
    //
    NL_GLOBAL_DATA _NL;


private:
    CUI* _pUi;
    CCD* _pCd;
    CMCS* _pMcs;
    CNC*  _pNc;
    CUT* _pUt;
    CRCV* _pRcv;

private:
    CObjs* _pClientObjects;
};



#endif // _H_NL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\nc.h ===
/**INC+**********************************************************************/
/* Header:    nc.h                                                          */
/*                                                                          */
/* Purpose:   Node Controller Class header file                             */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#ifndef _H_NC
#define _H_NC

extern "C"  {
    #include <adcgdata.h>
    #include <pchannel.h>
}

#include "objs.h"
#include "cd.h"

/**STRUCT+*******************************************************************/
/* Structure: NC_CONNECT_DATA                                               */
/*                                                                          */
/* Description: Data passed to NC_Connect by NL                             */
/****************************************************************************/
typedef struct tagNC_CONNECT_DATA
{
    BOOL    bInitateConnect;    // TRUE if initate connection, 
                                // FALSE connect with already connected
                                // socket
    DCUINT  addressLen;
    DCUINT  protocolLen;
    DCUINT  userDataLen;

    //
    // The data field must be the last thing in the
    // structure because we have code that computes
    // how long the header part is based on the field offset below
    //
#define NC_CONNECT_DATALEN 512
    DCUINT8 data[NC_CONNECT_DATALEN];
} NC_CONNECT_DATA, DCPTR PNC_CONNECT_DATA;
/**STRUCT-*******************************************************************/


/**STRUCT+*******************************************************************/
/* Structure: NC_GLOBAL_DATA                                                */
/*                                                                          */
/* Description:                                                             */
/****************************************************************************/
typedef struct tagNC_GLOBAL_DATA
{
    DCUINT16  shareChannel;
    DCUINT    userDataLenRNS;
    DCUINT    disconnectReason;
    DCUINT    MCSChannelCount;
    DCUINT    MCSChannelNumber;
    DCUINT16  MCSChannel[CHANNEL_MAX_COUNT];
    PRNS_UD_SC_NET pNetData;
    DCUINT32  serverVersion;
    DCBOOL    fPendingAttachUserConfirm;

    /************************************************************************/
    /* User data                                                            */
    /************************************************************************/
    PDCUINT8    pUserDataRNS;

} NC_GLOBAL_DATA, DCPTR PNC_GLOBAL_DATA;
/**STRUCT-*******************************************************************/

/****************************************************************************/
/*                                                                          */
/* Constants for GCC PDUs encoded in MCS User Data                          */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* MCS Header bytes                                                         */
/****************************************************************************/
#define NC_MCS_HDRLEN 7

/****************************************************************************/
/* GCCCreateConferenceRequest PDU body length                               */
/****************************************************************************/
#define NC_GCC_REQLEN 8

/****************************************************************************/
/* GCCCreateConferenceConfirm body length                                   */
/****************************************************************************/
#define NC_GCC_RSPLEN 9

/****************************************************************************/
/* Maximum user data allowed                                                */
/****************************************************************************/
#define NC_MAX_UDLEN 1000

/****************************************************************************/
/* Maximum total MCS userdata for the CreateConferenceRequest - 2 bytes for */
/* each length field.                                                       */
/****************************************************************************/
#define NC_GCCREQ_MAX_PDULEN  \
         (NC_MCS_HDRLEN + 2 + NC_GCC_REQLEN + 2 + H221_KEY_LEN + NC_MAX_UDLEN)


class CCD;
class CCC;
class CMCS;
class CUT;
class CUI;
class CRCV;
class CNL;
class CSL;
class CChan;

class CNC
{
public:
    CNC(CObjs* objs);
    ~CNC();

public:
    //
    // API Functions
    //

    DCVOID DCAPI NC_Main(DCVOID);

    static DCVOID DCAPI NC_StaticMain(PDCVOID param)
    {
        ((CNC*)param)->NC_Main();
    }


    DCVOID DCAPI NC_Init(DCVOID);
    
    DCVOID DCAPI NC_Term(DCVOID);
    
    DCVOID DCAPI NC_Connect(PDCVOID pUserData, DCUINT userDataLen);
    EXPOSE_CD_NOTIFICATION_FN(CNC, NC_Connect);
    
    DCVOID DCAPI NC_Disconnect(ULONG_PTR unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CNC, NC_Disconnect);


public:
    //
    // Callbacks
    //
    DCVOID DCCALLBACK NC_OnMCSConnected(DCUINT   result,
                                    PDCUINT8 pUserData,
                                    DCUINT   userDataLen);

    DCVOID DCCALLBACK NC_OnMCSAttachUserConfirm(DCUINT result, DCUINT16 userID);

    DCVOID DCCALLBACK NC_OnMCSChannelJoinConfirm(DCUINT result, DCUINT16 channel);

    DCVOID DCCALLBACK NC_OnMCSDisconnected(DCUINT reason);

    DCVOID DCCALLBACK NC_OnMCSBufferAvailable(DCVOID);

    //
    // Static callbacks (Delegate to appropriate instance)
    //

    static DCVOID DCCALLBACK NC_StaticOnMCSConnected(CNC* inst, DCUINT   result,
                                PDCUINT8 pUserData,
                                DCUINT   userDataLen)
    {
        inst->NC_OnMCSConnected(result, pUserData, userDataLen);
    }

    static DCVOID DCCALLBACK NC_StaticOnMCSAttachUserConfirm(CNC* inst, DCUINT result, DCUINT16 userID)
    {
        inst->NC_OnMCSAttachUserConfirm(result, userID);
    }
    
    static DCVOID DCCALLBACK NC_StaticOnMCSChannelJoinConfirm(CNC* inst,
                                                         DCUINT result, DCUINT16 channel)
    {
        inst->NC_OnMCSChannelJoinConfirm( result, channel);
    }
    
    static DCVOID DCCALLBACK NC_StaticOnMCSDisconnected(CNC* inst, DCUINT reason)
    {
        inst->NC_OnMCSDisconnected( reason);
    }
    
    static DCVOID DCCALLBACK NC_StaticOnMCSBufferAvailable(CNC* inst)
    {
        inst->NC_OnMCSBufferAvailable();
    }
    
public:
    //
    // Public data members
    //

    NC_GLOBAL_DATA _NC;

private:
    CCD*    _pCd;
    CCC*    _pCc;
    CMCS*   _pMcs;
    CUT*    _pUt;
    CUI*    _pUi;
    CRCV*   _pRcv;
    CNL*    _pNl;
    CSL*    _pSl;
    CChan*  _pChan;

private:
    CObjs* _pClientObjects;

};


#endif // _H_NC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\mcsint.cpp ===
/****************************************************************************/
// mcsint.cpp
//
// MCS internal portable functions.
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_FILE "amcsint"
#define TRC_GROUP TRC_GROUP_NETWORK
#include <atrcapi.h>
}

#include "autil.h"
#include "mcs.h"
#include "cd.h"
#include "xt.h"
#include "nc.h"
#include "nl.h"



/****************************************************************************/
/* Name:      MCSSendConnectInitial                                         */
/*                                                                          */
/* Purpose:   This function generates and sends a MCS connect-initial PDU.  */
/****************************************************************************/
DCVOID DCINTERNAL CMCS::MCSSendConnectInitial(ULONG_PTR unused)
{
    XT_BUFHND              bufHandle;
    PDCUINT8               pData = NULL;
    DCUINT                 pduLength;
    DCUINT                 dataLength;
    DCBOOL                 intRC;
    MCS_PDU_CONNECTINITIAL ciPDU = MCS_DATA_CONNECTINITIAL;

    DC_BEGIN_FN("MCSSendConnectInitial");

    DC_IGNORE_PARAMETER(unused);

    /************************************************************************/
    /* Calculate the size of the data to send.  The pdu length is the size  */
    /* of the Connect-Initial header plus the user data.  The data length   */
    /* is the length transmitted in the length field of the PDU, which      */
    /* doesn't include the PDU type (2 bytes) or the length field (3        */
    /* bytes).  Thus we need to subtract 5 bytes.                           */
    /************************************************************************/
    pduLength = sizeof(ciPDU) + _MCS.userDataLength;
    dataLength = pduLength - 5;

    TRC_NRM((TB, _T("CI total length:%u (data:%u) (hc:%u user-data:%u)"),
             pduLength,
             dataLength,
             sizeof(ciPDU),
             _MCS.userDataLength));

    /************************************************************************/
    /* Assume that the total CI length is less than the maximum MCS send    */
    /* packet size.                                                         */
    /************************************************************************/
    TRC_ASSERT((dataLength <= MCS_MAX_SNDPKT_LENGTH),
               (TB, _T("Datalength out of range: %u"), dataLength));
    TRC_ASSERT((_MCS.pReceivedPacket != NULL), (TB, _T("Null rcv packet buffer")));

    /************************************************************************/
    /* Update the MCS CI header with the data size.                         */
    /************************************************************************/
    ciPDU.length = MCSLocalToWire16((DCUINT16)dataLength);

    /************************************************************************/
    /* Update the MCS user-data octet string length.                        */
    /************************************************************************/
    ciPDU.udLength = MCSLocalToWire16((DCUINT16)_MCS.userDataLength);

    /************************************************************************/
    /* Get a private buffer from XT.                                        */
    /************************************************************************/
    intRC = _pXt->XT_GetPrivateBuffer(pduLength, &pData, &bufHandle);
    if (!intRC)
    {
        /********************************************************************/
        /* We've failed to get a private buffer.  This ONLY happens when TD */
        /* has disconnected while the layers above are still trying to      */
        /* connect.  Since TD has now disconnected and is refusing to give  */
        /* us a buffer we might as well just give up trying to get a        */
        /* buffer.                                                          */
        /********************************************************************/
        TRC_NRM((TB, _T("Failed to get a private buffer - just quit")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Now fill in the buffer that we've just got.                          */
    /************************************************************************/
    DC_MEMCPY(pData, &ciPDU, sizeof(ciPDU));

    DC_MEMCPY((pData + sizeof(ciPDU)),
              _MCS.pReceivedPacket,
              _MCS.userDataLength);

    /************************************************************************/
    /* Trace out the PDU.                                                   */
    /************************************************************************/
    TRC_DATA_NRM("Connect-Initial PDU", pData, pduLength);

    /************************************************************************/
    /* Send the buffer.  If everything has worked OK, we should receive a   */
    /* Connect-Response PDU shortly.                                        */
    /************************************************************************/
    _pXt->XT_SendBuffer(pData, pduLength, bufHandle);

DC_EXIT_POINT:
    DC_END_FN();
} /* MCSSendConnectInitial */


/****************************************************************************/
/* Name:      MCSSendErectDomainRequest                                     */
/*                                                                          */
/* Purpose:   Generates and sends an Erect-Domain-Request (EDrq) PDU.       */
/****************************************************************************/
DCVOID DCINTERNAL CMCS::MCSSendErectDomainRequest(ULONG_PTR unused)
{
    PDCUINT8                   pData = NULL;
    XT_BUFHND                  bufHandle;
    DCBOOL                     intRC;
    MCS_PDU_ERECTDOMAINREQUEST edrPDU = MCS_DATA_ERECTDOMAINREQUEST;

    DC_BEGIN_FN("MCSSendErectDomainRequest");

    DC_IGNORE_PARAMETER(unused);

    /************************************************************************/
    /* Get a internal send buffer from XT.                                  */
    /************************************************************************/
    intRC = _pXt->XT_GetPrivateBuffer(sizeof(edrPDU), &pData, &bufHandle);
    if (!intRC)
    {
        /********************************************************************/
        /* We've failed to get a private buffer.  This ONLY happens when TD */
        /* has disconnected while the layers above are still trying to      */
        /* connect.  Since TD has now disconnected and is refusing to give  */
        /* us a buffer we might as well just give up trying to get a        */
        /* buffer.                                                          */
        /********************************************************************/
        TRC_NRM((TB, _T("Failed to get a private buffer - just quit")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Now fill in the buffer with the AUR PDU.                             */
    /************************************************************************/
    DC_MEMCPY(pData, &edrPDU, sizeof(edrPDU));

    TRC_DATA_NRM("EDR PDU:", &edrPDU, sizeof(edrPDU));

    /************************************************************************/
    /* Now send the buffer.                                                 */
    /************************************************************************/
    TRC_NRM((TB, _T("Sending EDR PDU...")));
    _pXt->XT_SendBuffer(pData, sizeof(edrPDU), bufHandle);

DC_EXIT_POINT:
    DC_END_FN();
} /* MCSSendErectDomainRequest */


/****************************************************************************/
/* Name:      MCSSendAttachUserRequest                                      */
/*                                                                          */
/* Purpose:   Generates and sends an MCS Attach-User-Request (AUrq) PDU.    */
/****************************************************************************/
DCVOID DCINTERNAL CMCS::MCSSendAttachUserRequest(ULONG_PTR unused)
{
    PDCUINT8                  pData = NULL;
    XT_BUFHND                 bufHandle;
    DCBOOL                    intRC;
    MCS_PDU_ATTACHUSERREQUEST aurPDU = MCS_DATA_ATTACHUSERREQUEST;

    DC_BEGIN_FN("MCSSendAttachUserRequest");

    DC_IGNORE_PARAMETER(unused);

    /************************************************************************/
    /* Get a internal send buffer from XT.                                  */
    /************************************************************************/
    intRC = _pXt->XT_GetPrivateBuffer(sizeof(aurPDU), &pData, &bufHandle);
    if (!intRC)
    {
        /********************************************************************/
        /* We've failed to get a private buffer.  This ONLY happens when TD */
        /* has disconnected while the layers above are still trying to      */
        /* connect.  Since TD has now disconnected and is refusing to give  */
        /* us a buffer we might as well just give up trying to get a        */
        /* buffer.                                                          */
        /********************************************************************/
        TRC_NRM((TB, _T("Failed to get a private buffer - just quit")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Now fill in the buffer with the AUR PDU.                             */
    /************************************************************************/
    DC_MEMCPY(pData, &aurPDU, sizeof(aurPDU));

    TRC_DATA_NRM("AUR PDU:", &aurPDU, sizeof(aurPDU));

    /************************************************************************/
    /* Now send the buffer.                                                 */
    /************************************************************************/
    TRC_NRM((TB, _T("Sending AUR PDU...")));
    _pXt->XT_SendBuffer(pData, sizeof(aurPDU), bufHandle);

DC_EXIT_POINT:
    DC_END_FN();
    return;

} /* MCSSendAttachUserRequest */


/****************************************************************************/
/* Name:      MCSSendChannelJoinRequest                                     */
/*                                                                          */
/* Purpose:   Generates and sends a Channel-Join-Request (CJrq) PDU.        */
/*                                                                          */
/* Params:    IN  channelID - the channel ID to join.                       */
/****************************************************************************/
DCVOID DCINTERNAL CMCS::MCSSendChannelJoinRequest(PDCVOID pData, DCUINT dataLen)
{
    PDCUINT8                   pBuffer = NULL;
    XT_BUFHND                  bufHandle;
    DCBOOL                     intRC;
    MCS_PDU_CHANNELJOINREQUEST cjrPDU        = MCS_DATA_CHANNELJOINREQUEST;
    PMCS_DECOUPLEINFO          pDecoupleInfo = (PMCS_DECOUPLEINFO)pData;

    DC_BEGIN_FN("MCSSendChannelJoinRequest");

    DC_IGNORE_PARAMETER(dataLen);

    TRC_NRM((TB, _T("Join channel:%#x for user:%#x"),
             pDecoupleInfo->channel,
             pDecoupleInfo->userID));

    /************************************************************************/
    /* Assert that the hiword of the channel is 0.                          */
    /************************************************************************/
    TRC_ASSERT((0 == HIWORD((DCUINT32)pDecoupleInfo->channel)),
               (TB, _T("Hi-word of channel is non-zero")));

    /************************************************************************/
    /* Assert that the hiword of the user-id is 0.                          */
    /************************************************************************/
    TRC_ASSERT((0 == HIWORD((DCUINT32)pDecoupleInfo->userID)),
               (TB, _T("Hi-word of userID is non-zero")));

    /************************************************************************/
    /* Add the channel and user ids.                                        */
    /************************************************************************/
    cjrPDU.initiator =
                  MCSLocalUserIDToWireUserID((DCUINT16)pDecoupleInfo->userID);
    cjrPDU.channelID = MCSLocalToWire16((DCUINT16)pDecoupleInfo->channel);

    /************************************************************************/
    /* Get a internal send buffer from XT.                                  */
    /************************************************************************/
    intRC = _pXt->XT_GetPrivateBuffer(sizeof(cjrPDU), &pBuffer, &bufHandle);
    if (!intRC)
    {
        /********************************************************************/
        /* We've failed to get a private buffer.  This ONLY happens when TD */
        /* has disconnected while the layers above are still trying to      */
        /* connect.  Since TD has now disconnected and is refusing to give  */
        /* us a buffer we might as well just give up trying to get a        */
        /* buffer.                                                          */
        /********************************************************************/
        TRC_NRM((TB, _T("Failed to get a private buffer - just quit")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Now fill in the buffer with the CJR PDU.                             */
    /************************************************************************/
    DC_MEMCPY(pBuffer, &cjrPDU, sizeof(cjrPDU));

    TRC_DATA_NRM("CJR PDU:", &cjrPDU, sizeof(cjrPDU));

    /************************************************************************/
    /* Now send the buffer.                                                 */
    /************************************************************************/
    TRC_NRM((TB, _T("Sending Channel-Join-Request PDU...")));
    _pXt->XT_SendBuffer(pBuffer, sizeof(cjrPDU), bufHandle);

DC_EXIT_POINT:
    DC_END_FN();
} /* MCSSendChannelJoinRequest */


/****************************************************************************/
/* Name:      MCSSendDisconnectProviderUltimatum                            */
/*                                                                          */
/* Purpose:   Generates and sends a Disconnect-Provider-Ultimatum (DPum)    */
/*            PDU with the reason code set to rn-user-requested.            */
/****************************************************************************/
DCVOID DCINTERNAL CMCS::MCSSendDisconnectProviderUltimatum(ULONG_PTR unused)
{
    PDCUINT8                     pData = NULL;
    XT_BUFHND                    bufHandle;
    DCBOOL                       intRC;
    MCS_PDU_DISCONNECTPROVIDERUM dpumPDU = MCS_DATA_DISCONNECTPROVIDERUM;

    DC_BEGIN_FN("MCSSendDisconnectProviderUltimatum");

    DC_IGNORE_PARAMETER(unused);

    /************************************************************************/
    /* Get a internal send buffer from XT.                                  */
    /************************************************************************/
    intRC = _pXt->XT_GetPrivateBuffer(sizeof(dpumPDU), &pData, &bufHandle);
    if (!intRC)
    {
        /********************************************************************/
        /* We've failed to get a private buffer.  This ONLY happens when TD */
        /* has disconnected while the layers above are still trying to      */
        /* connect.  Since TD has now disconnected and is refusing to give  */
        /* us a buffer we might as well just give up trying to get a        */
        /* buffer.                                                          */
        /********************************************************************/
        TRC_NRM((TB, _T("Failed to get a private buffer - just quit")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Now fill in the buffer with the DPum PDU.                            */
    /************************************************************************/
    DC_MEMCPY(pData, &dpumPDU, sizeof(dpumPDU));

    TRC_DATA_NRM("DPUM PDU:", &dpumPDU, sizeof(dpumPDU));

    /************************************************************************/
    /* Now send the buffer.                                                 */
    /************************************************************************/
    TRC_NRM((TB, _T("Sending Disconnect-Provider-Ultimatum PDU...")));
    _pXt->XT_SendBuffer(pData, sizeof(dpumPDU), bufHandle);

DC_EXIT_POINT:
    /************************************************************************/
    /* We don't get any feedback for this PDU (i.e.  there is no            */
    /* Disconnect-Provider-Confirm PDU), so we need to decouple back to     */
    /* the receiver thread and get it to begin disconnecting the layers     */
    /* below.                                                               */
    /************************************************************************/
    TRC_NRM((TB, _T("Decouple to receiver thrd and call MCSContinueDisconnect")));
    _pCd->CD_DecoupleSimpleNotification(CD_RCV_COMPONENT, this,
                                  CD_NOTIFICATION_FUNC(CMCS,MCSContinueDisconnect),
                                  (ULONG_PTR) 0);

    DC_END_FN();
} /* MCSSendDisconnectProviderUltimatum */


/****************************************************************************/
/* Name:      MCSContinueDisconnect                                         */
/*                                                                          */
/* Purpose:   Continue the disconnect processing on the receiver thread     */
/*            after having sent a MCS DPum on the sender thread.            */
/****************************************************************************/
DCVOID DCINTERNAL CMCS::MCSContinueDisconnect(ULONG_PTR unused)
{
    DC_BEGIN_FN("MCSContinueDisconnect");

    DC_IGNORE_PARAMETER(unused);

    /************************************************************************/
    /* Just call XT_Disconnect.                                             */
    /************************************************************************/
    TRC_NRM((TB, _T("Disconnect lower layers - call XT_Disconnect")));
    _pXt->XT_Disconnect();

    DC_END_FN();
} /* MCSContinueDisconnect */


/****************************************************************************/
/* Name:      MCSGetSDRHeaderLength                                         */
/*                                                                          */
/* Purpose:   This function calculates the length of a Send-Data-Request    */
/*            PDU header based on the length of the data passed in.         */
/*                                                                          */
/* Returns:   The length of the SDR header required for dataLength bytes    */
/*            of data.                                                      */
/*                                                                          */
/* Params:    IN  dataLength - the length of the data to base the header    */
/*                             calculation on.                              */
/****************************************************************************/
DCUINT DCINTERNAL CMCS::MCSGetSDRHeaderLength(DCUINT dataLength)
{
    DCUINT headerLength;

    DC_BEGIN_FN("MCSGetSDRHeaderLength");

    /************************************************************************/
    /* Check that we're being asked to send less than the maximum amount    */
    /* of data.                                                             */
    /************************************************************************/
    TRC_ASSERT((dataLength < MCS_MAX_SNDPKT_LENGTH),
               (TB, _T("Too much data to send:%u"), dataLength));

    /************************************************************************/
    /* Calculate the maximum size of a MCS data header.  This is comprised  */
    /* of a constant length part (which contains pkt type, user-id etc) and */
    /* a variable size field which encodes the length of the user-data      */
    /* according to the PER encoding rules.                                 */
    /*                                                                      */
    /* First get the length of the constant part.                           */
    /************************************************************************/
    headerLength = sizeof(MCS_PDU_SENDDATAREQUEST);

    /************************************************************************/
    /* Now use the length of the data to calculate how many bytes are       */
    /* required to encode it.                                               */
    /************************************************************************/
    if (dataLength < 128)
    {
        /********************************************************************/
        /* We need only one byte to encode the length of the data.          */
        /********************************************************************/
        headerLength += 1;
    }
    else
    {
        /********************************************************************/
        /* We need two bytes to encode the length of the data.              */
        /********************************************************************/
        headerLength += 2;
    }

    TRC_DBG((TB, _T("Returning header length of:%u for data length:%u"),
             headerLength,
             dataLength));

    DC_END_FN();
    return(headerLength);
} /* MCSGetSDRHeaderLength */


/****************************************************************************/
/* Name:      MCSRecvToHdrBuf                                               */
/*                                                                          */
/* Purpose:   Receives data into the header buffer.                         */
/*                                                                          */
/* Returns:   TRUE if the receive bytes needed count is zero, FALSE         */
/*            otherwise.                                                    */
/****************************************************************************/
DCBOOL DCINTERNAL CMCS::MCSRecvToHdrBuf(DCVOID)
{
    DCUINT bytesRecv;
    DCBOOL rc;

    DC_BEGIN_FN("MCSRecvToHdrBuf");

    TRC_ASSERT((NULL != _MCS.pHdrBuf), (TB, _T("No MCS header buffer!")));

    /************************************************************************/
    /* Make sure that we're expected to receive some data.                  */
    /************************************************************************/
    TRC_ASSERT((_MCS.hdrBytesNeeded != 0), (TB, _T("No data to receive")));

    /************************************************************************/
    /* Reallocate a larger buffer for the header if the current one is too  */
    /* small to contain the incoming data.                                  */
    /************************************************************************/
    if( _MCS.hdrBufLen < _MCS.hdrBytesRead + _MCS.hdrBytesNeeded )
    {   
        PDCUINT8 pNewHdrBuf;
                                                                
        pNewHdrBuf = (PDCUINT8)UT_Malloc( _pUt,  _MCS.hdrBytesRead + _MCS.hdrBytesNeeded );

        if( NULL == pNewHdrBuf )
        {
            TRC_ABORT((TB,
                   _T("Cannot allocate memory to receive MCS header (%u)"),
                   _MCS.hdrBytesNeeded + _MCS.hdrBytesRead));
            return( FALSE );
        }

        DC_MEMCPY( pNewHdrBuf, _MCS.pHdrBuf, _MCS.hdrBytesRead );

        UT_Free( _pUt,  _MCS.pHdrBuf );
        _MCS.pHdrBuf = pNewHdrBuf;
        _MCS.hdrBufLen = _MCS.hdrBytesRead + _MCS.hdrBytesNeeded;
    }
    
    /************************************************************************/
    /* Get some data into the header buffer.                                */
    /************************************************************************/
    bytesRecv = _pXt->XT_Recv(_MCS.pHdrBuf + _MCS.hdrBytesRead, _MCS.hdrBytesNeeded);

    TRC_DBG((TB, _T("Received %u of %u needed bytes"),
             bytesRecv,
             _MCS.hdrBytesNeeded));

    /************************************************************************/
    /* Update the receive byte counts.                                      */
    /************************************************************************/
    _MCS.hdrBytesNeeded -= bytesRecv;
    _MCS.hdrBytesRead   += bytesRecv;

    /************************************************************************/
    /* Determine if we've got all the bytes that we need.                   */
    /************************************************************************/
    if (0 == _MCS.hdrBytesNeeded)
    {
        /********************************************************************/
        /* We've got all that we were asked for - return TRUE.              */
        /********************************************************************/
        TRC_DBG((TB, _T("Got all the bytes needed")));
        rc = TRUE;
    }
    else
    {
        /********************************************************************/
        /* We need to wait for some more bytes.                             */
        /********************************************************************/
        TRC_NRM((TB, _T("Wait for %u more bytes"), _MCS.hdrBytesNeeded));
        rc = FALSE;
    }

    DC_END_FN();
    return(rc);
} /* MCSRecvToHdrBuf */


/****************************************************************************/
/* Name:      MCSGetPERInfo                                                 */
/*                                                                          */
/* Purpose:   This function identifies PER PDUs based on the first byte in  */
/*            the header buffer and also calculates how many additional     */
/*            header bytes are needed for a complete PDU.                   */
/*                                                                          */
/* Params:    OUT pType - the PDU type.                                     */
/*            OUT pSize - the number of additional header bytes needed.     */
/****************************************************************************/
DCVOID DCINTERNAL CMCS::MCSGetPERInfo(PDCUINT pType, PDCUINT pSize)
{
    DC_BEGIN_FN("MCSGetPERInfo");

    TRC_ASSERT((NULL != pType), (TB, _T("pType is NULL")));
    TRC_ASSERT((NULL != pSize), (TB, _T("pSize is NULL")));

    /************************************************************************/
    /* Trace out the header buffer.                                         */
    /************************************************************************/
    TRC_DATA_DBG("Header buffer contains", _MCS.pHdrBuf, _MCS.hdrBytesRead);

    /************************************************************************/
    /* This a PER encoded PDU.  The six most-significant bits of the first  */
    /* byte contain the PDU type - mask out the remainder.                  */
    /************************************************************************/
    *pType = _MCS.pHdrBuf[0] & MCS_PDUTYPEMASK;

    /************************************************************************/
    /* Check for PDU types that we don't expect to receive.  If we get any  */
    /* of the following then we disconnect as the server is asking us to do */
    /* things that we can't do - and which will require a response from us. */
    /************************************************************************/
    if ((MCS_TYPE_ATTACHUSERREQUEST  == *pType) ||
        (MCS_TYPE_DETACHUSERREQUEST  == *pType) ||
        (MCS_TYPE_CHANNELJOINREQUEST == *pType) ||
        (MCS_TYPE_SENDDATAREQUEST    == *pType))
    {
        TRC_ABORT((TB, _T("Unexpected MCS PDU type:%#x"), *pType));
        MCSSetReasonAndDisconnect(NL_ERR_MCSUNEXPECTEDPDU);
        DC_QUIT;
    }

    /************************************************************************/
    /* Now calculate the number of bytes that we still need for the         */
    /* different PDU types.  This is the size of the PDU minus the number   */
    /* of bytes that we've read so far.                                     */
    /************************************************************************/
    switch (*pType)
    {
        case MCS_TYPE_SENDDATAINDICATION:
        {
            *pSize = sizeof(MCS_PDU_SENDDATAINDICATION) - _MCS.hdrBytesRead;
            TRC_DBG((TB, _T("MCS_PDU_SENDDATAINDICATION (%#x) read:%u need:%u"),
                     *pType,
                     _MCS.hdrBytesRead,
                     *pSize));
        }
        break;

        case MCS_TYPE_ATTACHUSERCONFIRM:
        {
            /****************************************************************/
            /* The user-id is optional, so determine if it is present.      */
            /****************************************************************/
            if (_MCS.pHdrBuf[0] & MCS_AUC_OPTIONALUSERIDMASK)
            {
                /************************************************************/
                /* The user-id is present.                                  */
                /************************************************************/
                TRC_NRM((TB, _T("Optional user-id is present in AUC")));
                *pSize = sizeof(MCS_PDU_ATTACHUSERCONFIRMFULL) -
                         _MCS.hdrBytesRead;
            }
            else
            {
                /************************************************************/
                /* The user-id is NOT present.                              */
                /************************************************************/
                TRC_NRM((TB, _T("Optional user-id is NOT present in AUC")));
                *pSize = sizeof(MCS_PDU_ATTACHUSERCONFIRMCOMMON) -
                         _MCS.hdrBytesRead;
            }

            TRC_NRM((TB, _T("MCS_PDU_ATTACHUSERCONFIRM (%#x) read:%u need:%u"),
                     *pType,
                     _MCS.hdrBytesRead,
                     *pSize));
        }
        break;

        case MCS_TYPE_DETACHUSERINDICATION:
        {
            *pSize = sizeof(MCS_PDU_DETACHUSERINDICATION) - _MCS.hdrBytesRead;
            TRC_NRM((TB, _T("MCS_PDU_DETACHUSERINDICATION (%#x) read:%u need:%u"),
                     *pType,
                     _MCS.hdrBytesRead,
                     *pSize));
        }
        break;

        case MCS_TYPE_CHANNELJOINCONFIRM:
        {
            /****************************************************************/
            /* The channel-id is optional, so determine if it is present.   */
            /****************************************************************/
            if (_MCS.pHdrBuf[0] & MCS_CJC_OPTIONALCHANNELIDMASK)
            {
                /************************************************************/
                /* The channel-id is present.                               */
                /************************************************************/
                TRC_NRM((TB, _T("Optional channel-id is present in CJC")));
                *pSize = sizeof(MCS_PDU_CHANNELJOINCONFIRMFULL) -
                         _MCS.hdrBytesRead;
            }
            else
            {
                /************************************************************/
                /* The channel-id is NOT present.                           */
                /************************************************************/
                TRC_NRM((TB, _T("Optional channel-id is NOT present in CJC")));
                *pSize = sizeof(MCS_PDU_CHANNELJOINCONFIRMCOMMON) -
                         _MCS.hdrBytesRead;
            }

            TRC_NRM((TB, _T("MCS_PDU_CHANNELJOINCONFIRM (%#x) read:%u need:%u"),
                     *pType,
                     _MCS.hdrBytesRead,
                     *pSize));
        }
        break;

        case MCS_TYPE_DISCONNECTPROVIDERUM:
        {
            *pSize = sizeof(MCS_PDU_DISCONNECTPROVIDERUM) - _MCS.hdrBytesRead;
            TRC_NRM((TB, _T("MCS_PDU_DISCONNECTPROVIDERUM (%#x) read:%u need:%u"),
                     *pType,
                     _MCS.hdrBytesRead,
                     *pSize));
        }
        break;

        default:
        {
            /****************************************************************/
            /* This is an unexpected MCS PDU - disconnect, as something has */
            /* gone horribly wrong!                                         */
            /****************************************************************/
            TRC_ABORT((TB, _T("Unexpected MCS PDU type:%#x"), *pType));
            MCSSetReasonAndDisconnect(NL_ERR_MCSUNEXPECTEDPDU);
            *pSize = 0;
            DC_QUIT;
        }
        break;
    }

DC_EXIT_POINT:
    DC_END_FN();
} /* MCSGetPERInfo */


/****************************************************************************/
/* Name:      MCSHandleControlPkt                                           */
/*                                                                          */
/* Purpose:   This function handles a MCS control packet which is located   */
/*            in the header buffer.  After identifying the PDU type it      */
/*            calls a NC callback.                                          */
/****************************************************************************/
DCVOID DCINTERNAL CMCS::MCSHandleControlPkt(DCVOID)
{
    DCUINT pduType;
    DCUINT pduSize;

    DC_BEGIN_FN("MCSHandleControlPkt");

    /************************************************************************/
    /* Trace out the header buffer contents.                                */
    /************************************************************************/
    TRC_DATA_NRM("Header bytes read:", _MCS.pHdrBuf, _MCS.hdrBytesRead);

    /************************************************************************/
    /* Work out the PDU type.                                               */
    /************************************************************************/
    if (MCS_BER_CONNECT_PREFIX == _MCS.pHdrBuf[0])
    {
        /********************************************************************/
        /* This is a BER encoded PDU.  The next byte is the type.           */
        /********************************************************************/
        pduType = _MCS.pHdrBuf[1];
    }
    else
    {
        /********************************************************************/
        /* This is a PER encoded PDU.  Get the PDU type.                    */
        /********************************************************************/
        MCSGetPERInfo(&pduType, &pduSize);
    }

    /************************************************************************/
    /* Now switch on the PDU type.                                          */
    /************************************************************************/
    TRC_NRM((TB, _T("PDU type:%#x"), pduType));
    switch (pduType)
    {
        case MCS_TYPE_CONNECTRESPONSE:
        {
            TRC_NRM((TB, _T("Connect response PDU received")));
            MCSHandleCRPDU();
        }
        break;

        case MCS_TYPE_ATTACHUSERCONFIRM:
        {
            PMCS_PDU_ATTACHUSERCONFIRMCOMMON pAUCCommon;
            PMCS_PDU_ATTACHUSERCONFIRMFULL   pAUCFull;
            DCUINT                           result;
            DCUINT16                         userID;

            TRC_NRM((TB, _T("MCS Attach-User-Confirm PDU received")));

            /****************************************************************/
            /* Determine if this PDU includes the optional user-id as well. */
            /****************************************************************/
            if (!(_MCS.pHdrBuf[0] & MCS_AUC_OPTIONALUSERIDMASK))
            {
                TRC_ABORT((TB, _T("Optional user-id NOT present in AUC")));
                MCSSetReasonAndDisconnect(NL_ERR_MCSNOUSERIDINAUC);
                DC_QUIT;
            }

            /****************************************************************/
            /* Cast the header buffer in the form of the common part of     */
            /* this PDU.                                                    */
            /****************************************************************/
            pAUCCommon = (PMCS_PDU_ATTACHUSERCONFIRMCOMMON)_MCS.pHdrBuf;

            /****************************************************************/
            /* Pull out the result code from the PDU and translate it.      */
            /****************************************************************/
            result = MCSGetResult(pAUCCommon->typeResult,
                                  MCS_AUC_RESULTCODEOFFSET);

            /****************************************************************/
            /* Retrieve the user-id as well.                                */
            /****************************************************************/
            pAUCFull = (PMCS_PDU_ATTACHUSERCONFIRMFULL)_MCS.pHdrBuf;
            userID   = MCSWireUserIDToLocalUserID(pAUCFull->userID);

            TRC_NRM((TB, _T("Calling NC_OnMCSAUC - result:%u userID:%#x"),
                     result,
                     userID));
            _pNc->NC_OnMCSAttachUserConfirm(result, userID);
        }
        break;

        case MCS_TYPE_CHANNELJOINCONFIRM:
        {
            PMCS_PDU_CHANNELJOINCONFIRMCOMMON pCJCCommon;
            PMCS_PDU_CHANNELJOINCONFIRMFULL   pCJCFull;
            DCUINT16                          channelID;
            DCUINT                            result;

            TRC_NRM((TB, _T("MCS Channel-Join-Confirm PDU received")));

            /****************************************************************/
            /* Determine if this PDU includes the optional channel-id as    */
            /* well.                                                        */
            /****************************************************************/
            if (!(_MCS.pHdrBuf[0] & MCS_CJC_OPTIONALCHANNELIDMASK))
            {
                TRC_ABORT((TB, _T("Optional channel-id NOT present in CJC")));
                MCSSetReasonAndDisconnect(NL_ERR_MCSNOCHANNELIDINCJC);
                DC_QUIT;
            }

            /****************************************************************/
            /* Cast the header buffer in the form of this PDU.              */
            /****************************************************************/
            pCJCCommon = (PMCS_PDU_CHANNELJOINCONFIRMCOMMON)_MCS.pHdrBuf;

            /****************************************************************/
            /* Pull out the result code from the PDU and translate it.      */
            /****************************************************************/
            result = MCSGetResult(pCJCCommon->typeResult,
                                  MCS_CJC_RESULTCODEOFFSET);

            /****************************************************************/
            /* Retrieve the channel id.                                     */
            /****************************************************************/
            pCJCFull = (PMCS_PDU_CHANNELJOINCONFIRMFULL)_MCS.pHdrBuf;
            channelID = MCSWireToLocal16(pCJCFull->channelID);

            TRC_NRM((TB, _T("Calling NC_OnMCSCJC - result:%u channelID:%#x"),
                     result,
                     channelID));
            _pNc->NC_OnMCSChannelJoinConfirm(result, channelID);
        }
        break;

        case MCS_TYPE_DETACHUSERINDICATION:
        {
            /****************************************************************/
            /* The following code is only compiled in if normal level       */
            /* tracing is enabled - otherwise we just ignore detach-user    */
            /* indications.  The server will send us a disconnect-provider  */
            /* when it wants us to detach.                                  */
            /****************************************************************/
#ifdef TRC_ENABLE_NRM
            DCUINT16                      userID;
            PMCS_PDU_DETACHUSERINDICATION pDUI;

            /****************************************************************/
            /* Cast the header buffer in the form of this PDU.              */
            /****************************************************************/
            pDUI = (PMCS_PDU_DETACHUSERINDICATION)_MCS.pHdrBuf;

            /****************************************************************/
            /* Dig out the MCS user id and issue the NC callback.           */
            /****************************************************************/
            userID = MCSWireUserIDToLocalUserID(pDUI->userID);

            TRC_NRM((TB, _T("MCS Detach-User-Indication PDU recv'd - userID:%#x"),
                     userID));
#endif /* TRC_ENABLE_NRM */
        }
        break;

        case MCS_TYPE_DISCONNECTPROVIDERUM:
        {
            PMCS_PDU_DISCONNECTPROVIDERUM pDPum;
            DCUINT                        reason;

            TRC_NRM((TB, _T("Disconnect Provider Ultimatum received")));

            /****************************************************************/
            /* Cast the header buffer in the form of this PDU.              */
            /****************************************************************/
            pDPum = (PMCS_PDU_DISCONNECTPROVIDERUM)_MCS.pHdrBuf;

            /****************************************************************/
            /* Pull out the reason code from the PDU.                       */
            /****************************************************************/
            reason = MCSGetReason(pDPum->typeReason,
                                  MCS_DPUM_REASONCODEOFFSET);

            TRC_ASSERT((reason <= MCS_REASON_CHANNEL_PURGED),
                       (TB, _T("Unexpected MCS reason code:%u"), reason));

            /****************************************************************/
            /* Switch on the reason code.                                   */
            /****************************************************************/
            switch (reason)
            {
                case MCS_REASON_PROVIDER_INITIATED:
                {
                    /********************************************************/
                    /* The server has disconnected us.                      */
                    /********************************************************/
                    TRC_NRM((TB,
                           _T("DPum with reason MCS_REASON_PROVIDER_INITIATED")));
                    _MCS.disconnectReason = NL_DISCONNECT_REMOTE_BY_SERVER;
                }
                break;

                case MCS_REASON_USER_REQUESTED:
                {
                    /********************************************************/
                    /* We initiated the disconnection and the server        */
                    /* concurred.                                           */
                    /********************************************************/
                    TRC_NRM((TB,
                            _T("DPum with reason MCS_REASON_USER_REQUESTED")));
                    _MCS.disconnectReason = NL_DISCONNECT_REMOTE_BY_USER;
                }
                break;

                default:
                {
                    /********************************************************/
                    /* This is an unrecognized reason code.                 */
                    /********************************************************/
                    TRC_ABORT((TB, _T("Unexpected MCS reason code:%u"), reason));
                    _MCS.disconnectReason =
                               NL_MAKE_DISCONNECT_ERR(NL_ERR_MCSBADMCSREASON);
                }
                break;

            }

            /****************************************************************/
            /* Getting a DPum means we should disconnect so call XT to      */
            /* disconnect the lower layers.                                 */
            /****************************************************************/
            _pXt->XT_Disconnect();
        }
        break;

        default:
        {
            TRC_ABORT((TB, _T("Unrecognised PDU type:%#x"), pduType));
        }
        break;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return;

} /* MCSHandleControlPkt */


/****************************************************************************/
/* Name:      MCSHandleCRPDU                                                */
/*                                                                          */
/* Purpose:   Handles a MCS Connect-Response PDU.  This function splits out */
/*            the MCS result code and user-data from the PDU and issues a   */
/*            callback to NC with these values.                             */
/****************************************************************************/
DCVOID DCINTERNAL CMCS::MCSHandleCRPDU(DCVOID)
{
    BOOL     fBadFields = FALSE;
    PDCUINT8 pPDU;
    DCUINT   length, nBERBytes;
    DCUINT   i;
    DCUINT   result = MCS_RESULT_UNSPECIFIED_FAILURE;

    DC_BEGIN_FN("MCSHandleCRPDU");

    TRC_NRM((TB, _T("MCS Connect-Response PDU received")));

    TRC_DATA_NRM("Connect-Response data:", _MCS.pHdrBuf, _MCS.hdrBytesRead);

    /************************************************************************/
    /* Set our local pointer to the start of the PDU.                       */
    /************************************************************************/
    pPDU = _MCS.pHdrBuf;

    /************************************************************************/
    /* Skip the PDU type fields.                                            */
    /************************************************************************/
    pPDU += 2;

    /************************************************************************/
    /* Skip the length field.  Note that we add one to the result of        */
    /* MCSGetBERLengthSize as this function returns the number of           */
    /* additional bytes that are needed to encode the length.               */
    /* We know that it's safe to skip these first few bytes since we        */
    /* already verified that they were received in MCS_RCVST_BERHEADER      */
    /* and MCS_RCVST_BERLENGTH.                                             */
    /************************************************************************/
    pPDU += MCSGetBERLengthSize(*pPDU);
    TRC_NRM((TB, _T("Skipped type and length %p->%p"),
             _MCS.pHdrBuf,
             pPDU));

    /************************************************************************/
    /* Now loop through the PDU fields.  We are only interested in two of   */
    /* the fields - the result and the user data.                           */
    /************************************************************************/
    for (i = 0; i < MCS_CRPDU_NUMFIELDS; i++)
    {
        /********************************************************************/
        /* We need one byte for the BER encoded fieldtype. Also, we need at */
        /* least one byte to get the NUMBER of bytes in the BER length (1   */
        /* or 2 bytes).                                                     */
        /********************************************************************/
        if ((pPDU + 2) > (_MCS.pHdrBuf + _MCS.hdrBytesRead))
        {
            fBadFields = TRUE;
            DC_QUIT;
        }

        /********************************************************************/
        /* The first item in a BER encoded field is the type.  We're not    */
        /* interested in this so just skip it.                              */
        /********************************************************************/
        pPDU++;

        /********************************************************************/
        /* The next byte has the NUMBER of bytes for the length.            */
        /********************************************************************/
        nBERBytes = MCSGetBERLengthSize(*pPDU);

        /********************************************************************/
        /* The number of bytes had better be 1-3.  Also, make sure we have  */
        /* at least this many bytes left!                                   */
        /********************************************************************/
        if (nBERBytes > 3 ||
            ((pPDU + nBERBytes) > (_MCS.pHdrBuf + _MCS.hdrBytesRead)))
        {
            fBadFields = TRUE;
            DC_QUIT;
        }

        /********************************************************************/
        /* The second item is the length.  Calculate it and the number of   */
        /* bytes that the length was encoded in.  Note that we add one to   */
        /* the result of MCSGetBERNumOfLengthBytes as this function returns */
        /* the number of additional bytes that are needed to encode the     */
        /* length.                                                          */
        /********************************************************************/
        length = MCSGetBERLength(pPDU);
        pPDU  += nBERBytes;

        TRC_NRM((TB, _T("Field %u has length:%u (pPDU:%p)"), i, length, pPDU));

        /********************************************************************/
        /* Of course, we had better have enough space for the actual len.   */
        /********************************************************************/
        if ((pPDU + length) > (_MCS.pHdrBuf + _MCS.hdrBytesRead))
        {
            fBadFields = TRUE;
            DC_QUIT;
        }

        /********************************************************************/
        /* The third item is the actual data - switch on the field number   */
        /* to determine if this a piece of data that we're interested in.   */
        /********************************************************************/
        switch (i)
        {
            case MCS_CRPDU_RESULTOFFSET:
            {
                /************************************************************/
                /* This is the MCS result field - dig it out and store it.  */
                /************************************************************/
                TRC_ASSERT((MCS_CR_RESULTLEN == length),
                           (TB, _T("Bad CR result length expect:%u got:%u"),
                            MCS_CR_RESULTLEN,
                            length));
                result = *pPDU;
                TRC_NRM((TB, _T("Connect-Response result code:%u"), result));

                /************************************************************/
                /* If the rc is good then we need to send a MCS             */
                /* Erect-Domain-Request to the server.                      */
                /************************************************************/
                if (MCS_RESULT_SUCCESSFUL == result)
                {
                    TRC_NRM((TB, _T("Generating EDR PDU")));
                    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                                  CD_NOTIFICATION_FUNC(CMCS,MCSSendErectDomainRequest),
                                  (ULONG_PTR) 0);
                }
            }
            break;

            case MCS_CRPDU_USERDATAOFFSET:
            {
                /************************************************************/
                /* This is the user-data, so issue the NC callback.         */
                /************************************************************/
                TRC_NRM((TB, _T("Call NC_OnMCSCPC - rc:%u pUserData:%p len:%u"),
                         result,
                         pPDU,
                         length));
                _pNc->NC_OnMCSConnected(result,
                                  pPDU,
                                  length);
            }
            break;

            default:
            {
                /************************************************************/
                /* This is a field that we're not interested in so just     */
                /* skip it.                                                 */
                /************************************************************/
                TRC_NRM((TB, _T("Offset %u - skip %u bytes of data"), i, length));
            }
            break;
        }

        /********************************************************************/
        /* Skip the data field.                                             */
        /********************************************************************/
        pPDU += length;
    }

DC_EXIT_POINT:
    if (fBadFields)
    {
        TRC_ABORT((TB, _T("Bad CR PDU fields")));
        MCSSetReasonAndDisconnect(NL_ERR_MCSBADCRFIELDS);
    }
    DC_END_FN();
} /* MCSHandleCRPDU */

// This check will be sure that MCS.dataBytesNeeded is not greater than
// XT.dataBytesLeft.  This should be use ONLY when the MCS needs to read all
// it's data from the XT and is not allowed any network reads.  In these cases,
// without enough data in XT, the client goes into an endless loop
// BUG 647947
#define CHECK_VALID_MCS_DATABYTESNEEDED( mcsInst, xtInst, hr ) \
    TRC_DBG(( TB, _T("_MCS.dataBytesNeeded = %d"), (mcsInst).dataBytesNeeded ));    \
    if ((xtInst).dataBytesLeft < (mcsInst).dataBytesNeeded) {   \
        TRC_ABORT((TB, _T("Bad _MCS.dataBytesNeeded:%u _XT.dataBytesLeft=%u"),  \
            (mcsInst).dataBytesNeeded, (xtInst).dataBytesLeft ));  \
        MCSSetReasonAndDisconnect(NL_ERR_MCSINVALIDPACKETFORMAT);   \
        (hr) = E_ABORT; \
        DC_QUIT;    \
    }

/****************************************************************************/
/* Name:      MCSRecvData                                                   */
/*                                                                          */
/* Purpose:   This is the main data receiver function.  It reads data from  */
/*            the user-data section of a MCS SDin PDU and places it in the  */
/*            receiver buffer.                                              */
/*                                                                          */
/* Returns:   *pfFinishedData is TRUE if the data section of a MCS PDU was  */
/*            completely processed and FALSE if not.                        */
/****************************************************************************/
HRESULT DCINTERNAL CMCS::MCSRecvData(BOOL *pfFinishedData)
{
    BOOL                        fFinishedData = FALSE;
    HRESULT                     hrc = S_OK;
    PMCS_PDU_SENDDATAINDICATION pSDI;
    DCUINT16                    senderID;
    DCUINT16                    channelID;
    DCUINT                      fragCount;

    DC_BEGIN_FN("MCSRecvData");

    /************************************************************************/
    /* Switch on the data state.                                            */
    /************************************************************************/
    switch (_MCS.dataState)
    {
        case MCS_DATAST_SIZE1:
        {
            /****************************************************************/
            /* Try to receive the data into the header buffer.              */
            /****************************************************************/
            if (MCSRecvToHdrBuf())
            {
                /************************************************************/
                /* Trace out the contents of the header buffer.             */
                /************************************************************/
                TRC_DATA_DBG("Header buf contains:",
                             _MCS.pHdrBuf,
                             _MCS.hdrBytesRead);

                /************************************************************/
                /* Cast the contents of the header buffer.                  */
                /************************************************************/
                pSDI = (PMCS_PDU_SENDDATAINDICATION)_MCS.pHdrBuf;

                /************************************************************/
                /* Check to determine if the header begin segmentation flag */
                /* is set.                                                  */
                /* If the flag is set, the count of bytes read should be 0. */
                /* If it is NOT set, the count of bytes should be non-zero. */
                /************************************************************/
                if (((pSDI->priSeg & MCS_SDI_BEGINSEGMASK) &&
                       (0 != _MCS.dataBytesRead)) ||
                    (!(pSDI->priSeg & MCS_SDI_BEGINSEGMASK) &&
                       (0 == _MCS.dataBytesRead)))
                {
                    TRC_ABORT((TB, _T("Segmentation flag does not match data bytes read (%u)"),
                            _MCS.dataBytesRead));
                    MCSSetReasonAndDisconnect(NL_ERR_MCSINVALIDPACKETFORMAT);
                    hrc = E_ABORT;
                    DC_QUIT;
                }

                /************************************************************/
                /* Update the state variable.                               */
                /************************************************************/
                TRC_DBG((TB, _T("State: DATA_SIZE1->DATA_SIZE2")));
                _MCS.dataState = MCS_DATAST_SIZE2;
            }
        }
        break;

        case MCS_DATAST_SIZE2:
        {
            /****************************************************************/
            /* Now try to receive the first of the data size bytes into the */
            /* size buffer.  Since the size may be completely contained     */
            /* within a single byte we only want to read one byte at this   */
            /* time.                                                        */
            /****************************************************************/
            if (0 != _pXt->XT_Recv(&(_MCS.pSizeBuf[0]), 1))
            {
                /************************************************************/
                /* Trace out the contents of the size buffer.               */
                /************************************************************/
                TRC_DATA_DBG("Size buf contains:", _MCS.pSizeBuf, 2);

                if (_MCS.pSizeBuf[0] & 0x80)
                {
                    /********************************************************/
                    /* The MSB of the first byte is set.  We now need to    */
                    /* look at the second bit to discover if the following  */
                    /* data is fragmented.                                  */
                    /********************************************************/
                    if (_MCS.pSizeBuf[0] & 0x40)
                    {
                        /****************************************************/
                        /* Bits 1-6 now contain a number between 1 and 4    */
                        /* which when multiplied by 16K gives the length    */
                        /* of the following fragment.  We expect a          */
                        /* maximum packet size of 32K, so the most that     */
                        /* this value should be is 2.                       */
                        /****************************************************/
                        fragCount = _MCS.pSizeBuf[0] & 0x3F;
                        if (fragCount > 2)
                        {
                            TRC_ABORT((TB, _T("Bad fragCount:%u"), fragCount));
                            MCSSetReasonAndDisconnect(NL_ERR_MCSINVALIDPACKETFORMAT);
                            hrc = E_ABORT;
                            DC_QUIT;
                        }

                        TRC_DBG((TB, _T("Fragmentation count is %u"), fragCount));

                        /****************************************************/
                        /* Now work out the number of bytes to read and     */
                        /* change state.                                    */
                        /****************************************************/
                        _MCS.dataBytesNeeded = fragCount * 16384;
                        CHECK_VALID_MCS_DATABYTESNEEDED( _MCS, _pXt->_XT, hrc );
                        _MCS.dataState       = MCS_DATAST_READFRAG;

                        /************************************************************/
                        /* There is a retail check for size in MCS_RecvToDataBuf,   */
                        /* but this helps us debug it before that point.            */
                        /************************************************************/
                        TRC_ASSERT((_MCS.dataBytesNeeded < 65535),
                                (TB,_T("Data recv size %u too large"), _MCS.dataBytesNeeded));

                        TRC_DBG((TB, _T("Data bytes needed is now %u"),
                                 _MCS.dataBytesNeeded));

                        TRC_DBG((TB, _T("State: DATA_SIZE2->DATA_READSEG")));
                    }
                    else
                    {
                        /****************************************************/
                        /* This section is not fragmented, and contains     */
                        /* between 128 bytes and 16K of data.  We need to   */
                        /* read another byte before we can work out how     */
                        /* much data we need.  Change state.                */
                        /****************************************************/
                        _MCS.dataState = MCS_DATAST_SIZE3;

                        TRC_DBG((TB, _T("State: DATA_SIZE2->DATA_SIZE3")));
                    }
                }
                else
                {
                    /********************************************************/
                    /* The MSB of the first byte is not set, so this        */
                    /* section contains less than 128 bytes of data.  This  */
                    /* means we can just set the count of bytes needed to   */
                    /* the size of this byte and update the state to        */
                    /* reading remainder.                                   */
                    /********************************************************/
                    _MCS.dataBytesNeeded = _MCS.pSizeBuf[0];
                    CHECK_VALID_MCS_DATABYTESNEEDED( _MCS, _pXt->_XT, hrc );
                    _MCS.dataState       = MCS_DATAST_READREMAINDER;

                    /************************************************************/
                    /* There is a retail check for size in MCS_RecvToDataBuf,   */
                    /* but this helps us debug it before that point.            */
                    /************************************************************/
                    TRC_ASSERT((_MCS.dataBytesNeeded < 65535),
                            (TB,_T("Data recv size %u too large"), _MCS.dataBytesNeeded));

                    TRC_DBG((TB, _T("Read %u bytes"), _MCS.dataBytesNeeded));
                    TRC_DBG((TB, _T("State: DATA_SIZE2->DATA_READREMAINDER")));
                }
            }
        }
        break;

        case MCS_DATAST_SIZE3:
        {
            /****************************************************************/
            /* The length field is 2 bytes long (i.e.  the data size lies   */
            /* somewhere between 128 bytes and 16K) so try to read the      */
            /* second byte.  Just call XT_Recv directly to get the single   */
            /* byte.                                                        */
            /****************************************************************/
            if (0 != _pXt->XT_Recv(&(_MCS.pSizeBuf[1]), 1))
            {
                /************************************************************/
                /* Trace out the contents of the size buffer.               */
                /************************************************************/
                TRC_DATA_DBG("Size buf contains:", _MCS.pSizeBuf, 2);

                /************************************************************/
                /* We can now work out how much data to receive, so do it   */
                /* now.                                                     */
                /************************************************************/
                _MCS.dataBytesNeeded =
                        _MCS.pSizeBuf[1] + ((_MCS.pSizeBuf[0] & 0x3F) << 8);
                CHECK_VALID_MCS_DATABYTESNEEDED( _MCS, _pXt->_XT, hrc );
                _MCS.dataState = MCS_DATAST_READREMAINDER;

                /************************************************************/
                /* There is a retail check for size in MCS_RecvToDataBuf,   */
                /* but this helps us debug it before that point.            */
                /************************************************************/
                TRC_ASSERT((_MCS.dataBytesNeeded < 65535),
                        (TB,_T("Data recv size %u too large"), _MCS.dataBytesNeeded));

                TRC_DBG((TB, _T("State: DATA_SIZE3->DATA_READREMAINDER")));
            }
        }
        break;

        case MCS_DATAST_READFRAG:
        {
            MCS_RecvToDataBuf(hrc, _pXt, this);
            if (!SUCCEEDED(hrc))
            {
                MCSSetReasonAndDisconnect(NL_ERR_MCSINVALIDPACKETFORMAT);
                DC_QUIT;
            }

            if (S_OK == hrc) {
                fFinishedData = TRUE;

                /************************************************************/
                /* We've read this fragment completely so change state.     */
                /************************************************************/
                _MCS.dataState = MCS_DATAST_SIZE2;

                TRC_DBG((TB, _T("State: DATA_READFRAG->DATA_SIZE2")));
            }
        }
        break;

        case MCS_DATAST_READREMAINDER:
        {
            MCS_RecvToDataBuf(hrc, _pXt, this);
            if (!SUCCEEDED(hrc))
            {
                MCSSetReasonAndDisconnect(NL_ERR_MCSINVALIDPACKETFORMAT);
                DC_QUIT;
            }

            if (S_OK == hrc) {
                /************************************************************/
                /* We've completely read the data part of a MCS data        */
                /* packet, so return TRUE.                                  */
                /************************************************************/
                fFinishedData = TRUE;

                /************************************************************/
                /* Cast the contents of the header buffer.                  */
                /************************************************************/
                pSDI = (PMCS_PDU_SENDDATAINDICATION)_MCS.pHdrBuf;

                /************************************************************/
                /* Decide if we should issue a callback to the layer above  */
                /* with the packet - we do this if this is the last         */
                /* segment (i.e. the end segmentation flag is set).         */
                /************************************************************/
                if (pSDI->priSeg & MCS_SDI_ENDSEGMASK)
                {
                     /********************************************************/
                    /* Dig out the sender id.                               */
                    /********************************************************/
                    senderID = MCSWireUserIDToLocalUserID(pSDI->userID);
                    channelID = MCSWireToLocal16(pSDI->channelID);

                    /********************************************************/
                    /* Update the performance counter.                      */
                    /********************************************************/
                    PRF_INC_COUNTER(PERF_PKTS_RECV);

                    /********************************************************/
                    /* The flag is set, so issue the callback.              */
                    /********************************************************/
                    TRC_DBG((TB,
                        _T("Calling PRcb (senderID:%#x, channelID:%#x, size:%u)"),
                             senderID, channelID,
                             _MCS.dataBytesRead));

                    TRC_ASSERT((_MCS.pReceivedPacket != NULL),
                               (TB, _T("Null rcv packet buffer")));

                    /********************************************************/
                    /* If this function fails, we bail out of the rest of   */
                    /* the packet (outside of this function).               */
                    /********************************************************/
                    hrc = _pNl->_NL.callbacks.onPacketReceived(_pSl, _MCS.pReceivedPacket,
                                                  _MCS.dataBytesRead,
                                                  0,
                                                  channelID,
                                                  0);

                    /********************************************************/
                    /* Reset the count of bytes read.                       */
                    /********************************************************/
                    _MCS.dataBytesRead = 0;
                }

                /************************************************************/
                /* Finally update the state.                                */
                /************************************************************/
                _MCS.dataState = MCS_DATAST_SIZE1;

                TRC_DBG((TB, _T("State: DATA_READREMAINDER->DATA_SIZE1")));
            }
        }
        break;

        default:
        {
            TRC_ABORT((TB, _T("Unknown data state:%u"), _MCS.dataState));
        }
        break;
    }

DC_EXIT_POINT:
    *pfFinishedData = fFinishedData;

    DC_END_FN();
    return(hrc);
} /* MCSRecvData */


/****************************************************************************/
/* Name:      MCSSetReasonAndDisconnect                                     */
/*                                                                          */
/* Purpose:   This function is called when MCS detects that an error has    */
/*            occurred while processing a PDU.  It sets the reason code for */
/*            the disconnection which is used to over-ride the value that   */
/*            comes back in the OnDisconnected callback from XT.  After     */
/*            setting this variable it then calls XT_Disconnect to begin    */
/*            the disconnection process.                                    */
/*                                                                          */
/* Params:    IN  reason - the reason code for the disconnection.           */
/****************************************************************************/
DCVOID DCINTERNAL CMCS::MCSSetReasonAndDisconnect(DCUINT reason)
{
    DC_BEGIN_FN("MCSSetReasonAndDisconnect");

    /************************************************************************/
    /* Set the disconnect error code.  This will be used to over-ride the   */
    /* error value in the OnDisconnected callback from XT before we pass it */
    /* to NC.                                                               */
    /************************************************************************/
    TRC_ASSERT((0 == _MCS.disconnectReason),
               (TB, _T("Disconnect reason has already been set!")));
    _MCS.disconnectReason = NL_MAKE_DISCONNECT_ERR(reason);

    /************************************************************************/
    /* Attempt to disconnect.                                               */
    /************************************************************************/
    TRC_NRM((TB, _T("Set reason code to %#x so now call XT_Disconnect..."),
             _MCS.disconnectReason));
    _pXt->XT_Disconnect();

    DC_END_FN();
} /* MCSSetReasonAndDisconnect */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\nccb.cpp ===
/**MOD+**********************************************************************/
/* Module:    nccb.cpp                                                      */
/*                                                                          */
/* Purpose:   NC callbacks from MCS                                         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_NETWORK
#define TRC_FILE  "anccb"
#include <atrcapi.h>
}

#include "autil.h"
#include "wui.h"
#include "nc.h"
#include "mcs.h"
#include "nl.h"
#include "cchan.h"


/**PROC+*********************************************************************/
/* Name:      NC_OnMCSConnected                                             */
/*                                                                          */
/* Purpose:   Connected callback from MCS                                   */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    IN      result      - result code                             */
/*            IN      pUserData   - user data                               */
/*            IN      userDataLen - user data length                        */
/*                                                                          */
/* Operation: Validate the GCC PDU and userdata supplied in the MCS         */
/*            userdata.  If invalid, then disconnect.                       */
/*            The GCC PDU is encoded as follows:                            */
/*                                                                          */
/*            number of bytes   value                                       */
/*            ===============   =====                                       */
/*            NC_MCS_HDRLEN     MCS header                                  */
/*            1 or 2            Total GCC PDU length                        */
/*            NC_GCC_RSPLEN     GCC CreateConferenceConfirm PDU body        */
/*            4                 H221 key                                    */
/*            1 or 2            length of GCC user data                     */
/*            ?                 GCC user data                               */
/*                                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CNC::NC_OnMCSConnected(DCUINT   result,
                                    PDCUINT8 pUserData,
                                    DCUINT   userDataLen)
{
    PRNS_UD_HEADER pHdr;
    PDCUINT8       ptr;
    DCUINT16       udLen;
    PDCUINT16      pMCSChannel;

    DC_BEGIN_FN("NC_OnMCSConnected");

    if (result != MCS_RESULT_SUCCESSFUL)
    {
        /********************************************************************/
        /* Something's wrong.  Trace and set the disconnect error code.     */
        /********************************************************************/
        TRC_ERR((TB, _T("ConnectResponse error %u"), result));
        TRC_ASSERT((0 == _NC.disconnectReason),
                         (TB, _T("Disconnect reason has already been set!")));
        _NC.disconnectReason = NL_MAKE_DISCONNECT_ERR(NL_ERR_NCBADMCSRESULT);

        /********************************************************************/
        /* Begin the disconnection process.                                 */
        /********************************************************************/
        _pMcs->MCS_Disconnect();
        DC_QUIT;
    }

    TRC_NRM((TB, _T("Connected OK")));
    TRC_DATA_DBG("UserData", pUserData, userDataLen);

    /************************************************************************/
    /* First, skip the MCS header bytes                                     */
    /************************************************************************/
    ptr = pUserData + NC_MCS_HDRLEN;

    /************************************************************************/
    /* SECURITY: The GCC PDU length read below is a length encoded within   */
    /* a PDU (Usually, this is bad).  However, in this case, the client     */
    /* ignores this value (note the length is skipped over below).          */
    /* ALSO, the server has this size HARDCODED as 0x2a.  See               */
    /* tgccdata.c!gccEncodeUserData which uses hardcoded values to fill in  */
    /* parts of the GCC table.  Thus, it's not a security bug.              */
    /************************************************************************/

    /************************************************************************/
    /* Allow for length > 128.  In PER this is encoded as 10xxxxxx xxxxxxxx */
    /************************************************************************/
    TRC_DBG((TB, _T("GCC PDU length byte %#x"), *ptr));
    if (*ptr++ & 0x80)
    {
        ptr++;
        TRC_DBG((TB, _T("GCC PDU length byte 2 %#x"), *ptr));
    }

    /************************************************************************/
    /* The GCC PDU bytes don't contain any useful information, so just skip */
    /* over them.                                                           */
    /************************************************************************/
    ptr += NC_GCC_RSPLEN;

    if (ptr >= pUserData + userDataLen)
    {
        TRC_ERR((TB, _T("No UserData")));
        TRC_ASSERT((0 == _NC.disconnectReason),
                         (TB, _T("Disconnect reason has already been set!")));
        _NC.disconnectReason = NL_MAKE_DISCONNECT_ERR(NL_ERR_NCNOUSERDATA);
        _pMcs->MCS_Disconnect();
        DC_QUIT;
    }

    if (DC_MEMCMP(ptr, SERVER_H221_KEY, H221_KEY_LEN))
    {
        TRC_ERR((TB, _T("Invalid H221 key from server")));
        TRC_ASSERT((0 == _NC.disconnectReason),
                         (TB, _T("Disconnect reason has already been set!")));
        _NC.disconnectReason = NL_MAKE_DISCONNECT_ERR(NL_ERR_NCINVALIDH221KEY);
        _pMcs->MCS_Disconnect();
        DC_QUIT;
    }

    /************************************************************************/
    /* Skip H221 key; read the GCC userdata length.                         */
    /************************************************************************/
    ptr += H221_KEY_LEN;

    /************************************************************************/
    /* Length is PER encoded: either 0xxxxxxx or 10xxxxxx xxxxxxxx.         */
    /************************************************************************/
    udLen = (DCUINT16)*ptr++;
    if (udLen & 0x0080)
    {
        udLen = (DCUINT16)(*ptr++ | ((udLen & 0x3F) << 8));
    }
    TRC_DBG((TB, _T("Length of GCC userdata %hu"), udLen));

    /************************************************************************/
    /* Save the user data to return on the onConnected callback.            */
    /* Note: pass _NC.userDataRNS (aligned) to UT_ParseUserData(), not ptr  */
    /* (unaligned).                                                         */
    /************************************************************************/
    _NC.userDataLenRNS = udLen;

    if( _NC.pUserDataRNS )
    {
        UT_Free( _pUt,  _NC.pUserDataRNS );
    }

    /************************************************************************/
    /* Verify that the udLen size that came out of the packet is less than  */
    /* the packet size itself, since we're going to do a MEMCPY from the    */
    /* packet.  Also, because the size of udLen is limited to the size of   */
    /* the packet, the Malloc below is not unbounded.                       */
    /************************************************************************/
    if (!IsContainedMemory(pUserData, userDataLen, ptr, udLen))
    {
        TRC_ABORT((TB, _T("Bad UserData size")));
        TRC_ASSERT((0 == _NC.disconnectReason),
                         (TB, _T("Disconnect reason has already been set!")));
        _NC.disconnectReason = NL_MAKE_DISCONNECT_ERR(NL_ERR_NCNOCOREDATA);
        _pMcs->MCS_Disconnect();
        DC_QUIT;
    }

    _NC.pUserDataRNS = (PDCUINT8)UT_Malloc( _pUt,  udLen );

    if( NULL == _NC.pUserDataRNS )
    {
        TRC_ERR( ( TB, _T("Failed to allocate %u bytes for core user data"), udLen ) );
        DC_QUIT;
    }

    DC_MEMCPY(_NC.pUserDataRNS, ptr, udLen);

    /************************************************************************/
    /* Get the server version number from the CORE user data.               */
    /************************************************************************/
    pHdr = _pUt->UT_ParseUserData((PRNS_UD_HEADER)_NC.pUserDataRNS,
                            _NC.userDataLenRNS,
                            RNS_UD_SC_CORE_ID);
    if (pHdr == NULL)
    {
        /********************************************************************/
        /* No core user data, disconnect.                                   */
        /********************************************************************/
        TRC_ERR((TB, _T("No CORE user data")));
        TRC_ASSERT((0 == _NC.disconnectReason),
                         (TB, _T("Disconnect reason has already been set!")));
        _NC.disconnectReason = NL_MAKE_DISCONNECT_ERR(NL_ERR_NCNOCOREDATA);
        _pMcs->MCS_Disconnect();

        DC_QUIT;
    }

    _NC.serverVersion = ((PRNS_UD_SC_CORE)pHdr)->version;
    if (_RNS_MAJOR_VERSION(_NC.serverVersion) != RNS_UD_MAJOR_VERSION)
    {
        /********************************************************************/
        /*  The server version data doesn't match the client, so disconnect.*/
        /********************************************************************/
        TRC_ERR((TB, _T("Version mismatch, client: %#lx server: %#lx"),
                      RNS_UD_VERSION,
                      ((PRNS_UD_SC_CORE)pHdr)->version));
        TRC_ASSERT((0 == _NC.disconnectReason),
                         (TB, _T("Disconnect reason has already been set!")));
        _NC.disconnectReason = NL_MAKE_DISCONNECT_ERR(NL_ERR_NCVERSIONMISMATCH);
        _pMcs->MCS_Disconnect();
        DC_QUIT;
    }

    /************************************************************************/
    /* Extract the T.128 channel from the user data                         */
    /************************************************************************/
    pHdr = _pUt->UT_ParseUserData((PRNS_UD_HEADER)_NC.pUserDataRNS,
                            _NC.userDataLenRNS,
                            RNS_UD_SC_NET_ID);

    /************************************************************************/
    /* Disconnect if no NET user data.                                      */
    /************************************************************************/
    if (pHdr == NULL)
    {
        TRC_ERR((TB, _T("No NET data: cannot join share")));
        TRC_ASSERT((0 == _NC.disconnectReason),
                         (TB, _T("Disconnect reason has already been set!")));
        _NC.disconnectReason = NL_MAKE_DISCONNECT_ERR(NL_ERR_NCNONETDATA);
        _pMcs->MCS_Disconnect();
        DC_QUIT;
    }

    _NC.pNetData = (PRNS_UD_SC_NET)pHdr;

    //
    // Validate the share channel ID - the invalid channel ID is reserved
    // to prevent re-joining all channels (see #479976)
    //
    if (MCS_INVALID_CHANNEL_ID == _NC.pNetData->MCSChannelID) {
        TRC_ERR((TB, _T("Got invalid channel ID")));
        TRC_ASSERT((0 == _NC.disconnectReason),
                         (TB, _T("Disconnect reason has already been set!")));
        _NC.disconnectReason = NL_MAKE_DISCONNECT_ERR(NL_ERR_NCJOINBADCHANNEL);
        _pMcs->MCS_Disconnect();
        DC_QUIT;
    }
    _NC.shareChannel = _NC.pNetData->MCSChannelID;
    TRC_NRM((TB, _T("Share Channel from userData %#hx"), _NC.shareChannel));

    /************************************************************************/
    /* The length of .pNetData has already been checked to make sure that   */
    /* it fits in our source packet:                                        */
    /*   a) userDataLenRNS was bounds-checked above, within the packet      */
    /*      passed into this function.                                      */
    /*   b) pNetData->header.length was verified to be within               */
    /*      userDataLenRNS in the call to UT_ParseUserData above.           */
    /*                                                                      */
    /* Thus, pNetData sits within the packet passed into this function. We  */
    /* can assert this here, but the retail check was already done.         */
    /************************************************************************/
    TRC_ASSERT((IsContainedMemory(_NC.pUserDataRNS, _NC.userDataLenRNS, _NC.pNetData, _NC.pNetData->header.length)),
                         (TB, _T("Invalid pNetData size in packet; Retail check failed to catch it.")));

    /************************************************************************/
    /* Extract virtual channel numbers                                      */
    /************************************************************************/
    TRC_NRM((TB, _T("%d virtual channels returned"), _NC.pNetData->channelCount));
    if (_RNS_MINOR_VERSION(_NC.serverVersion) >= 3)
    {
        _NC.MCSChannelCount = _NC.pNetData->channelCount;
        if (_NC.pNetData->channelCount != 0 &&
            _NC.pNetData->channelCount < CHANNEL_MAX_COUNT)
        {
            pMCSChannel = (PDCUINT16)(_NC.pNetData + 1);
            DC_MEMCPY(&(_NC.MCSChannel),
                      pMCSChannel,
                      _NC.pNetData->channelCount * sizeof(DCUINT16));
        }
        else
        {
            TRC_ALT((TB,_T("Invalid or zero channel count.")));
            _NC.MCSChannelCount = 0;
        }
    }
    else
    {
        TRC_ALT((TB, _T("Server minor ver %hd doesn't support 4-byte lengths"),
            _RNS_MINOR_VERSION(_NC.serverVersion)));
        _NC.MCSChannelCount = 0;
    }

    /************************************************************************/
    /* Issue AttachUser to continue connection establishment.               */
    /************************************************************************/
    _pMcs->MCS_AttachUser();

    //
    // Flag we're waiting for a confirm to validate that we
    // only receive confirms in response to our requests
    //
    _NC.fPendingAttachUserConfirm = TRUE;

DC_EXIT_POINT:
    DC_END_FN();

    return;

} /* NC_OnMCSConnected */


/**PROC+*********************************************************************/
/* Name:      NC_OnMCSAttachUserConfirm                                     */
/*                                                                          */
/* Purpose:   AttachUserConfirm callback from MCS                           */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    IN      result   -  result code                               */
/*            IN      userID   -  MCS User ID                               */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CNC::NC_OnMCSAttachUserConfirm(DCUINT result, DCUINT16 userID)
{
    DC_BEGIN_FN("NC_OnMCSAttachUserConfirm");

    if (result == MCS_RESULT_SUCCESSFUL && _NC.fPendingAttachUserConfirm)
    {
        TRC_NRM((TB, _T("AttachUser OK - user %#hx"), userID));
        _pUi->UI_SetClientMCSID(userID);

        /********************************************************************/
        /* Join the channels                                                */
        /********************************************************************/
        _pMcs->MCS_JoinChannel(userID, userID);
    }
    else
    {
        TRC_NRM((TB, _T("AttachUser Failed - result %u fPending: %d"),
                 result, _NC.fPendingAttachUserConfirm));
        TRC_ASSERT((0 == _NC.disconnectReason),
                         (TB, _T("Disconnect reason has already been set!")));
        _NC.disconnectReason =
                            NL_MAKE_DISCONNECT_ERR(NL_ERR_NCATTACHUSERFAILED);
        _pMcs->MCS_Disconnect();
    }

    //
    // Only allow confirms in response to our requests
    //
    _NC.fPendingAttachUserConfirm = FALSE;


    DC_END_FN();
    return;

} /* NC_OnMCSAttachUserConfirm */


/**PROC+*********************************************************************/
/* Name:      NC_OnMCSChannelJoinConfirm                                    */
/*                                                                          */
/* Purpose:   ChannelJoinConfirm callback from MCS                          */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    IN      result   -  result code                               */
/*            IN      channel  -  MCS Channel                               */
/*                                                                          */
/* Operation: Join the other channel, or notify SL of connection            */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CNC::NC_OnMCSChannelJoinConfirm(DCUINT result, DCUINT16 channel)
{
    DCBOOL callOnConnected = FALSE;

    DC_BEGIN_FN("NC_OnMCSChannelJoinConfirm");

    /************************************************************************/
    /* Ensure that we joined the channel successfully.                      */
    /************************************************************************/
    if (result != MCS_RESULT_SUCCESSFUL)
    {
        /********************************************************************/
        /* We failed to join the channel so set the correct error reason    */
        /* and then disconnect.                                             */
        /********************************************************************/
        TRC_ALT((TB, _T("Channel join failed channel:%#hx result:%u"),
                 channel,
                 result));

        TRC_ASSERT((0 == _NC.disconnectReason),
                         (TB, _T("Disconnect reason has already been set!")));
        _NC.disconnectReason =
                           NL_MAKE_DISCONNECT_ERR(NL_ERR_NCCHANNELJOINFAILED);
        _pMcs->MCS_Disconnect();
        DC_QUIT;
    }

    TRC_NRM((TB, _T("Channel Join %#hx OK"), channel));

    //
    // Validate that we receive the confirm for the last channel
    // we requested.
    //
    if (_pMcs->MCS_GetPendingChannelJoin() != channel) {
        TRC_ERR((TB,_T("Received unexpected channel join.")
                 _T("Expecting: 0x%x received: 0x%x"),
                 _pMcs->MCS_GetPendingChannelJoin(), channel));

        _NC.disconnectReason =
                           NL_MAKE_DISCONNECT_ERR(NL_ERR_NCJOINBADCHANNEL);
        _pMcs->MCS_Disconnect();
        DC_QUIT;
    }

    /************************************************************************/
    /* Now determine which channel we joined.                               */
    /************************************************************************/
    if (channel == _pUi->UI_GetClientMCSID())
    {
        /********************************************************************/
        /* We've just successfully joined the single user channel, so now   */
        /* go on and try to join the share channel.                         */
        /********************************************************************/
        TRC_NRM((TB, _T("Joined user chan OK - attempt to join share chan %#hx"),
                 _NC.shareChannel));
        _pMcs->MCS_JoinChannel(_NC.shareChannel, _pUi->UI_GetClientMCSID());
    }
    else if (channel == _NC.shareChannel)
    {
        /********************************************************************/
        /* We've just joined the Share channel                              */
        /********************************************************************/
        if (_NC.MCSChannelCount != 0)
        {
            /****************************************************************/
            /* Start joining virtual channels                               */
            /****************************************************************/
            TRC_NRM((TB, _T("Joined Share channel - join first VC %d"),
                    _NC.MCSChannel[0]));
            _NC.MCSChannelNumber = 0;
            _pMcs->MCS_JoinChannel(_NC.MCSChannel[0], _pUi->UI_GetClientMCSID());
        }
        else
        {
            /****************************************************************/
            /* No virtual channels - tell the Core that we are connected.   */
            /****************************************************************/
            TRC_NRM((TB, _T("Joined share channel, no VCs - call OnConnected")));
            callOnConnected = TRUE;
        }
    }
    else if (channel == _NC.MCSChannel[_NC.MCSChannelNumber])
    {
        /********************************************************************/
        /* We've just joined a virtual channel                              */
        /********************************************************************/
        TRC_NRM((TB, _T("Joined Virtual channel #%d (%x)"),
                _NC.MCSChannelNumber, _NC.MCSChannel[_NC.MCSChannelNumber]));
        _NC.MCSChannelNumber++;

        if (_NC.MCSChannelNumber == _NC.MCSChannelCount)
        {
            /****************************************************************/
            /* That was the last virtual channel - tell the core            */
            /****************************************************************/
            TRC_NRM((TB, _T("All done - call OnConnected callbacks")));
            callOnConnected = TRUE;
        }
        else
        {
            /****************************************************************/
            /* Join the next virtual channel                                */
            /****************************************************************/
            TRC_NRM((TB, _T("Join virtual channel #%d (%x)"),
                    _NC.MCSChannelNumber, _NC.MCSChannel[_NC.MCSChannelNumber]));
            _pMcs->MCS_JoinChannel(_NC.MCSChannel[_NC.MCSChannelNumber],
                            _pUi->UI_GetClientMCSID());
        }
    }
    else
    {
        /********************************************************************/
        /* We didn't expect to join this channel!  Something bad must have  */
        /* happened so disconnect now.                                      */
        /********************************************************************/
        TRC_ABORT((TB, _T("Joined unexpected channel:%#hx"), channel));
        TRC_ASSERT((0 == _NC.disconnectReason),
                         (TB, _T("Disconnect reason has already been set!")));
        _NC.disconnectReason = NL_MAKE_DISCONNECT_ERR(NL_ERR_NCJOINBADCHANNEL);
        _pMcs->MCS_Disconnect();
        DC_QUIT;
    }

    /************************************************************************/
    /* Call the onConnected callbacks if required                           */
    /************************************************************************/
    if (callOnConnected)
    {
        TRC_NRM((TB, _T("Call onConnected callbacks")));

        //
        // We don't expect to join any more channels
        //
        _pMcs->MCS_SetPendingChannelJoin(MCS_INVALID_CHANNEL_ID);

        _pNl->_NL.callbacks.onConnected(_pSl, _NC.shareChannel,
                                 _NC.pUserDataRNS,
                                 _NC.userDataLenRNS,
                                 _NC.serverVersion);

        /************************************************************************/
        /* Note that the length pNetData->header.length was already verified    */
        /* in NC_OnMCSConnected (retail check).                                 */
        /************************************************************************/
        _pChan->ChannelOnConnected(_NC.shareChannel,
                           _NC.serverVersion,
                           _NC.pNetData,
                           _NC.pNetData->header.length);
    }

DC_EXIT_POINT:
    DC_END_FN();
    return;

} /* NC_OnMCSChannelJoinConfirm */


/**PROC+*********************************************************************/
/* Name:      NC_OnMCSDisconnected                                          */
/*                                                                          */
/* Purpose:   Disconnected callback from MCS.                               */
/*                                                                          */
/* Params:    IN      reason   -  reason code                               */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CNC::NC_OnMCSDisconnected(DCUINT reason)
{
    DC_BEGIN_FN("NC_OnMCSDisconnected");

    /************************************************************************/
    /* Decide if we want to over-ride the disconnect reason code.           */
    /************************************************************************/
    if (_NC.disconnectReason != 0)
    {
        TRC_ALT((TB, _T("Over-riding disconnection reason (%u->%u)"),
                 reason,
                 _NC.disconnectReason));

        /********************************************************************/
        /* Over-ride the error code and set the global variable to 0.       */
        /********************************************************************/
        reason = _NC.disconnectReason;
        _NC.disconnectReason = 0;
    }

    /************************************************************************/
    /* Free the core user data.                                             */
    /************************************************************************/

    if( _NC.pUserDataRNS )
    {
        UT_Free( _pUt,  _NC.pUserDataRNS );
        _NC.pUserDataRNS = NULL;
    }

    /************************************************************************/
    /* Issue the callback to the layer above to let him know that we've     */
    /* disconnected.                                                        */
    /************************************************************************/
    TRC_DBG((TB, _T("Disconnect reason:%u"), reason));
    _pNl->_NL.callbacks.onDisconnected(_pSl, reason);


    _pChan->ChannelOnDisconnected(reason);

    DC_END_FN();
    return;

} /* NC_OnMCSDisconnected */


/**PROC+*********************************************************************/
/* Name:      NC_OnMCSBufferAvailable                                       */
/*                                                                          */
/* Purpose:   OnBufferAvailable callback from MCS                           */
/*                                                                          */
/* Returns:   none                                                          */
/*                                                                          */
/* Params:    none                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCCALLBACK CNC::NC_OnMCSBufferAvailable(DCVOID)
{
    DC_BEGIN_FN("NC_OnMCSBufferAvailable");

    /************************************************************************/
    /* Call the core callback first to let the core have first shot at any  */
    /* available buffers                                                    */
    /************************************************************************/
    TRC_NRM((TB, _T("Call Core OnBufferAvailable callback")));

    _pNl->_NL.callbacks.onBufferAvailable(_pSl);

    /************************************************************************/
    /* Now call the virtual channel callback                                */
    /************************************************************************/
    TRC_NRM((TB, _T("Call VC OnBufferAvailable callback")));
    
    _pChan->ChannelOnBufferAvailable();

    DC_END_FN();

    return;

} /* NC_OnMCSBufferAvailable */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\nlapi.cpp ===
/**MOD+**********************************************************************/
/* Module:    nlapi.cpp                                                     */
/*                                                                          */
/* Purpose:   Network Layer API                                             */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_NETWORK
#define TRC_FILE  "anlapi"
#include <atrcapi.h>
}

#include "autil.h"
#include "nl.h"
#include "nc.h"
#include "cd.h"
#include "snd.h"

CNL::CNL(CObjs* objs)
{
    _pClientObjects = objs;
}

CNL::~CNL()
{
}

/**PROC+*********************************************************************/
/* Name:      NL_Init                                                       */
/*                                                                          */
/* Purpose:   Initialize the Network Layer                                  */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    IN      pCallbacks - callback functions                       */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CNL::NL_Init(PNL_CALLBACKS pCallbacks)
{
    DC_BEGIN_FN("NL_Init");

    _pUi  = _pClientObjects->_pUiObject;
    _pCd  = _pClientObjects->_pCdObject;
    _pMcs = _pClientObjects->_pMCSObject;
    _pNc  = _pClientObjects->_pNcObject;
    _pUt  = _pClientObjects->_pUtObject;
    _pRcv = _pClientObjects->_pRcvObject;

    TRC_ASSERT((pCallbacks != NULL), (TB, _T("Missing callbacks")));

    /************************************************************************/
    /* Store the callback functions                                         */
    /************************************************************************/
    DC_MEMCPY((&_NL.callbacks), pCallbacks, sizeof(NL_CALLBACKS));

    /************************************************************************/
    /* Start the new thread                                                 */
    /************************************************************************/
#ifdef OS_WIN32
    _pUt->UT_StartThread(CNC::NC_StaticMain, &(_NL.threadData), _pNc);
#else
    _pNc->NC_Init();
#endif

/****************************************************************************/
/* Seed the random number generator from the clock                          */
/****************************************************************************/
#ifdef DC_DEBUG
    srand((DCUINT)_pUt->UT_GetCurrentTimeMS());
#endif /* DC_DEBUG */

    TRC_NRM((TB, _T("Completed NL_Init")));

    DC_END_FN();

    return;

} /* NL_Init */


/**PROC+*********************************************************************/
/* Name:      NL_Term                                                       */
/*                                                                          */
/* Purpose:   Terminate the network layer.                                  */
/*                                                                          */
/* Returns:   nothing                                                       */
/*                                                                          */
/* Params:    none                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CNL::NL_Term(DCVOID)
{
    DC_BEGIN_FN("NL_Term");

    _pUt->UT_DestroyThread(_NL.threadData);

    TRC_NRM((TB, _T("Completed NL_Term")));

    DC_END_FN();
    return;

} /* NL_Term */


/**PROC+*********************************************************************/
/* Name:      NL_Connect                                                    */
/*                                                                          */
/* Purpose:   Connect to a server                                           */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    bInitateConnect - TRUE if initate connection                  */
/*            pServerAddress - address of the Server to connect to          */
/*            transportType  - transport type: NL_TRANSPORT_TCP             */
/*            pProtocolName  - protocol name, one of                        */
/*                             - NL_PROTOCOL_T128                           */
/*                             - Er, that's it.                             */
/*            pUserData      - user data to pass to Server Security Manager */
/*            userDataLength - length of user data                          */
/*                                                                          */
/**PROC-*********************************************************************/
HRESULT DCAPI CNL::NL_Connect(BOOL bInitateConnect,
                        PDCTCHAR pServerAddress,
                        DCUINT   transportType,
                        PDCTCHAR pProtocolName,
                        PDCVOID  pUserData,
                        DCUINT   userDataLength)
{
    DCUINT totalLen;
    NC_CONNECT_DATA connect;
    HRESULT hr = E_FAIL;

    DC_BEGIN_FN("NL_Connect");

    DC_IGNORE_PARAMETER(transportType);
    TRC_ASSERT((transportType == NL_TRANSPORT_TCP),
                           (TB, _T("Invalid transport type %d"), transportType));

    if( bInitateConnect )
    {
        TRC_ASSERT((pServerAddress != NULL), (TB, _T("No server address")));
    }

    TRC_ASSERT((pProtocolName != NULL), (TB, _T("No protocol name")));
    DC_IGNORE_PARAMETER(pProtocolName);

    if( bInitateConnect )
    {
        TRC_DBG((TB, _T("ServerAddress %s protocol %s, UD len %d"),
                 pServerAddress, pProtocolName, userDataLength));
    }
    else
    {
        TRC_DBG((TB, _T("Connect endpoint : protocol %s, UD len %d"),
                 pProtocolName, userDataLength));
    }

    TRC_DATA_DBG("UserData", pUserData, userDataLength);

    /************************************************************************/
    /* Copy data to buffer ready to send to NC.                             */
    /************************************************************************/
    if( bInitateConnect )
    {
        connect.addressLen = DC_TSTRBYTELEN(pServerAddress);
        connect.bInitateConnect = TRUE;
    }
    else
    {
        connect.addressLen = 0;
        connect.bInitateConnect = FALSE;
    }

    connect.protocolLen = DC_TSTRBYTELEN(pProtocolName);
    connect.userDataLen = userDataLength;

    totalLen = connect.addressLen + connect.protocolLen + connect.userDataLen;
    TRC_DBG((TB, _T("Total length %d"), totalLen));

    TRC_ASSERT((totalLen <= NC_CONNECT_DATALEN),
               (TB, _T("Too much connect data %d"), totalLen));

    if( bInitateConnect )
    {
        hr = StringCchCopy((PDCTCHAR)connect.data,
                           SIZE_TCHARS(connect.data),
                           pServerAddress);
        if (FAILED(hr)) {
            TRC_ERR((TB,_T("String copy failed for pServerAddress: 0x%x"),hr));
            DC_QUIT;
        }
    }

    hr = StringCbCopy((PDCTCHAR)(connect.data + connect.addressLen),
                      totalLen - connect.addressLen,
                      pProtocolName);
    if (SUCCEEDED(hr)) {
        DC_MEMCPY(connect.data + connect.addressLen + connect.protocolLen,
                  pUserData,
                  connect.userDataLen);

        /************************************************************************/
        /* Add the header bytes.                                                */
        /************************************************************************/
        totalLen += FIELDOFFSET(NC_CONNECT_DATA, data[0]);
        TRC_DATA_DBG("Connect data", &connect, totalLen);

        _pCd->CD_DecoupleNotification(CD_RCV_COMPONENT,
                                _pNc,
                                CD_NOTIFICATION_FUNC(CNC,NC_Connect),
                                (PDCVOID)&connect,
                                totalLen);
        hr = S_OK;
    }
    else {
        TRC_ERR((TB,_T("String copy for user data failed: 0x%x"),hr));
        DC_QUIT;
    }
    

DC_EXIT_POINT:
    DC_END_FN();

    return hr;
} /* NL_Connect */


/**PROC+*********************************************************************/
/* Name:      NL_Disconnect                                                 */
/*                                                                          */
/* Purpose:   Disconnect from the Server                                    */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CNL::NL_Disconnect(DCVOID)
{
    DC_BEGIN_FN("NL_Disconnect");

    _pCd->CD_DecoupleSimpleNotification(CD_RCV_COMPONENT,
                                  _pNc,
                                  CD_NOTIFICATION_FUNC(CNC,NC_Disconnect),
                                  (ULONG_PTR) 0);
    
    DC_END_FN();

    return;

} /* NL_Disconnect */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\nspint.h ===
/**INC+**********************************************************************/
/* Header:  nspint.h                                                        */
/*                                                                          */
/* Purpose: Sound Player - 32-bit specific internal header.                 */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/hydra/tshrclnt/core/nspint.h_v  $
 * 
 *    Rev 1.1   25 Sep 1997 14:49:54   KH
 * SFR1037: Initial Sound player implementation
**/
/**INC-**********************************************************************/
#ifndef _H_NSPINT
#define _H_NSPINT

#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "nspint"

/****************************************************************************/
/*                                                                          */
/* INLINE FUNCTIONS                                                         */
/*                                                                          */
/****************************************************************************/
__inline DCVOID DCINTERNAL SPPlaySound(DCUINT32 frequency, DCUINT32 duration)
{
    DC_BEGIN_FN("SPPlaySound");

    /************************************************************************/
    /* The parameters have no effect on Win95. A Win95 system with a sound  */
    /* card always plays the default system sound; a Win95 system without a */
    /* sound card always plays the standard system beep.                    */
    /************************************************************************/
#ifndef OS_WINCE
    if ( !Beep(frequency, duration) )
#else // OS_WINCE
    DC_IGNORE_PARAMETER(frequency);
    DC_IGNORE_PARAMETER(duration);
    if ( !MessageBeep(0xFFFFFFFF) )
#endif // OS_WINCE
    {
        TRC_ERR((TB, _T("Beep(%#lx, %lu) failed"), frequency, duration));
        TRC_SYSTEM_ERROR("Beep");
    }

    DC_END_FN();
}

#undef TRC_GROUP
#undef TRC_FILE

#endif /* _H_NSPINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\od.h ===
/****************************************************************************/
// od.h
//
// Order Decoder Class.
//
// Copyright (c) 1997-1999 Microsoft Corp.
// Portions copyright (c) 1992-1997 Microsoft, PictureTel
/****************************************************************************/

#ifndef _H_OD
#define _H_OD


extern "C" {
    #include <adcgdata.h>
}

#include "or.h"
#include "uh.h"
#include "cc.h"
#include "objs.h"



/****************************************************************************/
/* ODORDERFIELDINFO "type" flags.                                           */
/****************************************************************************/
#define OD_OFI_TYPE_FIXED           0x01
#define OD_OFI_TYPE_VARIABLE        0x02
#define OD_OFI_TYPE_COORDINATES     0x04
#define OD_OFI_TYPE_DATA            0x08
#define OD_OFI_TYPE_SIGNED          0x10
#define OD_OFI_TYPE_LONG_VARIABLE   0x20


/****************************************************************************/
/* Define the maximum sizes of fields within encoded orders.                */
/****************************************************************************/
#define OD_CONTROL_FLAGS_FIELD_SIZE     1
#define OD_TYPE_FIELD_SIZE              1
#define OD_MAX_FIELD_FLAG_BYTES         3
#define OD_MAX_ADDITIONAL_BOUNDS_BYTES  1


/****************************************************************************/
/* Structure: OD_ORDER_FIELD_INFO                                           */
/*                                                                          */
/* This structure contains information for a single field in an ORDER       */
/* structure                                                                */
/*                                                                          */
/* fieldPos          - The byte offset into the order structure to the      */
/*                     start of the field.                                  */
/*                                                                          */
/* fieldUnencodedLen - The length in bytes of the unencoded field.          */
/*                                                                          */
/* fieldEncodedLen   - The length in bytes of the encoded field.  This      */
/*                     should always be <= to FieldUnencodedLen.            */
/*                                                                          */
/* fieldSigned       - Does this field contain a signed or unsigned value?  */
/*                                                                          */
/* fieldType         - A description of the type of the field - this        */
/*                     is used to determine how to decode the               */
/*                     field.                                               */
/****************************************************************************/
typedef struct tagOD_ORDER_FIELD_INFO
{
    UINT16 fieldPos;
    BYTE   fieldUnencodedLen;
    BYTE   fieldEncodedLen;
    BYTE   fieldType;
} OD_ORDER_FIELD_INFO, FAR *POD_ORDER_FIELD_INFO;


class COD;

// Fast-path decoding function pointer type.
typedef HRESULT  (DCINTERNAL FAR COD::*POD_ORDER_HANDLER_FUNC)(
        PUH_ORDER pOrder,
        UINT16 uiVarDataLen,
        BOOL bBoundsSet);
 

typedef HRESULT  (DCINTERNAL FAR COD::*POD_FAST_ORDER_DECODE_FUNC)(
        BYTE ControlFlags,
        BYTE FAR * FAR *ppFieldDecode,
        DCUINT dataLen,
        UINT32 FieldFlags);

/*
typedef void (DCINTERNAL FAR *POD_FAST_ORDER_DECODE_FUNC)(
        BYTE ControlFlags,
        BYTE FAR * FAR *ppFieldDecode,
        UINT32 FieldFlags);

typedef void (DCINTERNAL FAR *POD_ORDER_HANDLER_FUNC)(
        PUH_ORDER pOrder,
        BOOL bBoundsSet);
*/

#define callMemberFunction(object,ptrToMember)  ((object).*(ptrToMember)) 

// Order attribute data, one per order type to store decoding tables and info.
typedef struct tagOD_ORDER_TABLE
{
    const OD_ORDER_FIELD_INFO FAR *pOrderTable;
    unsigned NumFields;
    PUH_ORDER LastOrder;
    DCUINT      cbMaxOrderLen;
    UINT16    cbVariableDataLen;
    POD_FAST_ORDER_DECODE_FUNC pFastDecode;
    POD_ORDER_HANDLER_FUNC pHandler;
} OD_ORDER_TABLE;


/****************************************************************************/
/* Structure: OD_GLOBAL_DATA                                                */
/*                                                                          */
/* Description:                                                             */
/****************************************************************************/
typedef struct tagOD_GLOBAL_DATA
{
    /************************************************************************/
    /* A copy of the last order of each type.                               */
    /* These are stored as byte array because we dont have a structure      */
    /* defined that has the header and the particular order defined.        */
    /************************************************************************/
    BYTE lastDstblt[UH_ORDER_HEADER_SIZE + sizeof(DSTBLT_ORDER)];
    BYTE lastPatblt[UH_ORDER_HEADER_SIZE + sizeof(PATBLT_ORDER)];
    BYTE lastScrblt[UH_ORDER_HEADER_SIZE + sizeof(SCRBLT_ORDER)];
    BYTE lastLineTo[UH_ORDER_HEADER_SIZE + sizeof(LINETO_ORDER)];
    BYTE lastOpaqueRect[UH_ORDER_HEADER_SIZE + sizeof(OPAQUERECT_ORDER)];
    BYTE lastSaveBitmap[UH_ORDER_HEADER_SIZE + sizeof(SAVEBITMAP_ORDER)];
    BYTE lastMembltR2[UH_ORDER_HEADER_SIZE + sizeof(MEMBLT_R2_ORDER)];
    BYTE lastMem3bltR2[UH_ORDER_HEADER_SIZE + sizeof(MEM3BLT_R2_ORDER)];
    BYTE lastMultiDstBlt[UH_ORDER_HEADER_SIZE + sizeof(MULTI_DSTBLT_ORDER)];
    BYTE lastMultiPatBlt[UH_ORDER_HEADER_SIZE + sizeof(MULTI_PATBLT_ORDER)];
    BYTE lastMultiScrBlt[UH_ORDER_HEADER_SIZE + sizeof(MULTI_SCRBLT_ORDER)];
    BYTE lastMultiOpaqueRect[UH_ORDER_HEADER_SIZE + sizeof(MULTI_OPAQUERECT_ORDER)];
    BYTE lastFastIndex[UH_ORDER_HEADER_SIZE + sizeof(FAST_INDEX_ORDER)];
    BYTE lastPolygonSC[UH_ORDER_HEADER_SIZE + sizeof(POLYGON_SC_ORDER)];
    BYTE lastPolygonCB[UH_ORDER_HEADER_SIZE + sizeof(POLYGON_CB_ORDER)];
    BYTE lastPolyLine[UH_ORDER_HEADER_SIZE + sizeof(POLYLINE_ORDER)];
    BYTE lastFastGlyph[UH_ORDER_HEADER_SIZE + sizeof(FAST_GLYPH_ORDER)];
    BYTE lastEllipseSC[UH_ORDER_HEADER_SIZE + sizeof(ELLIPSE_SC_ORDER)];
    BYTE lastEllipseCB[UH_ORDER_HEADER_SIZE + sizeof(ELLIPSE_CB_ORDER)];
    BYTE lastIndex[UH_ORDER_HEADER_SIZE + sizeof(INDEX_ORDER)];

#ifdef DRAW_NINEGRID
    BYTE lastDrawNineGrid[UH_ORDER_HEADER_SIZE + sizeof(DRAWNINEGRID_ORDER)];
    BYTE lastMultiDrawNineGrid[UH_ORDER_HEADER_SIZE + sizeof(MULTI_DRAWNINEGRID_ORDER)];
#endif
    /************************************************************************/
    /* The type of order, and a pointer to the last order                   */
    /************************************************************************/
    BYTE      lastOrderType;
    PUH_ORDER pLastOrder;

    /************************************************************************/
    /* The last bounds that were used.                                      */
    /************************************************************************/
    RECT lastBounds;

#ifdef DC_HICOLOR
//#ifdef DC_DEBUG
    /************************************************************************/
    /* Used for testing to confirm that we've received each of the order    */
    /* types                                                                */
    /************************************************************************/
    #define TS_FIRST_SECONDARY_ORDER    TS_MAX_ORDERS

    UINT32 orderHit[TS_MAX_ORDERS + TS_NUM_SECONDARY_ORDERS];
//#endif
#endif
} OD_GLOBAL_DATA;




class COD
{
public:
    COD(CObjs* objs);
    ~COD();

public:
    //
    // API
    //

    void      DCAPI OD_Init(void);

    void      DCAPI OD_Term(void);
    
    void      DCAPI OD_Enable(void);
    
    void      DCAPI OD_Disable(void);
    
    HRESULT DCAPI OD_DecodeOrder(PPDCVOID, DCUINT, PUH_ORDER *);


public:
    //
    // Public data members
    //
    OD_GLOBAL_DATA _OD;


    // Order attributes used for decoding, organized to optimize cache line
    // usage. The fourth and fifth fields of each row are the fast-path decode
    // and order handler functions, respectively. If a fast-path decode function
    // is used, neither a decoding table nor a handler function is needed,
    // since fast-path decode functions also perform the handling.
    OD_ORDER_TABLE odOrderTable[TS_MAX_ORDERS];


private:
    //
    // Internal functions
    //
    /****************************************************************************/
    /* FUNCTION PROTOTYPES                                                      */
    /****************************************************************************/
    HRESULT DCINTERNAL ODDecodeFieldSingle(PPDCUINT8, PDCVOID, unsigned, unsigned,
            BOOL);
    
    HRESULT ODDecodeMultipleRects(RECT *, UINT32,
            CLIP_RECT_VARIABLE_CODEDDELTALIST FAR *,
            UINT16 uiVarDataLen);         
    
    HRESULT DCINTERNAL ODDecodePathPoints(POINT *, RECT *, 
        BYTE FAR *pData,
        unsigned NumDeltaEntries, unsigned MaxNumDeltaEntries,
        unsigned dataLen, unsigned MaxDataLen,
        UINT16 uiVarDataLen,
        BOOL);
    
    HRESULT DCINTERNAL ODDecodeOpaqueRect(BYTE, BYTE FAR * FAR *, DCUINT, UINT32);
    
    HRESULT DCINTERNAL ODDecodeMemBlt(BYTE, BYTE FAR * FAR *, DCUINT, UINT32);
    
    HRESULT DCINTERNAL ODDecodeLineTo(BYTE, BYTE FAR * FAR *, DCUINT, UINT32);
    
    HRESULT DCINTERNAL ODDecodePatBlt(BYTE, BYTE FAR * FAR *, DCUINT, UINT32);
    
    HRESULT DCINTERNAL ODDecodeFastIndex(BYTE, BYTE FAR * FAR *, DCUINT, UINT32);
    
    
    HRESULT DCINTERNAL ODHandleMultiPatBlt(PUH_ORDER, UINT16, BOOL);
    
    HRESULT DCINTERNAL ODHandleDstBlts(PUH_ORDER, UINT16, BOOL);
    
    HRESULT DCINTERNAL ODHandleScrBlts(PUH_ORDER, UINT16, BOOL);
    
    HRESULT DCINTERNAL ODHandleMultiOpaqueRect(PUH_ORDER, UINT16, BOOL);
    
#ifdef DRAW_NINEGRID
    HRESULT DCINTERNAL ODHandleDrawNineGrid(PUH_ORDER, UINT16, BOOL);

    HRESULT DCINTERNAL ODHandleMultiDrawNineGrid(PUH_ORDER, UINT16, BOOL);
#endif

    HRESULT DCINTERNAL ODHandleMem3Blt(PUH_ORDER, UINT16, BOOL);
    
    HRESULT DCINTERNAL ODHandleSaveBitmap(PUH_ORDER, UINT16, BOOL);
    
    HRESULT DCINTERNAL ODHandlePolyLine(PUH_ORDER, UINT16, BOOL);
    
    HRESULT DCINTERNAL ODHandlePolygonSC(PUH_ORDER, UINT16, BOOL);
    
    HRESULT DCINTERNAL ODHandlePolygonCB(PUH_ORDER, UINT16, BOOL);
    
    HRESULT DCINTERNAL ODHandleEllipseSC(PUH_ORDER, UINT16, BOOL);
    
    HRESULT DCINTERNAL ODHandleEllipseCB(PUH_ORDER, UINT16, BOOL);
    
    HRESULT DCINTERNAL ODHandleFastGlyph(PUH_ORDER, UINT16, BOOL);
    
    HRESULT DCINTERNAL ODHandleGlyphIndex(PUH_ORDER, UINT16, BOOL);

#ifdef OS_WINCE
    BOOL DCINTERNAL ODHandleAlwaysOnTopRects(LPMULTI_SCRBLT_ORDER pSB);
#endif

private:
    COP* _pOp;
    CUH* _pUh;
    CCC* _pCc;
    CUI* _pUi;
    CCD* _pCd;

private:
    CObjs* _pClientObjects;
};



#endif // _H_OD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\op.h ===
/**INC+**********************************************************************/
/* Header:    op.h                                                          */
/*                                                                          */
/* Purpose:   Output Painter Class                                          */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#ifndef _H_OP
#define _H_OP

extern "C" {
 #include <adcgdata.h>
}
#include <adcgdata.h>

#define DIM_WINDOW_STEPS        16
#define DIM_WINDOW_TICK         150
#define DIM_WINDOW_TIMERID      1

//Disconnected icon timer ID sets blink rate
#define DIM_DISCONICON_TICK     500


#include "objs.h"
#include "cd.h"
#include "or.h"

/**STRUCT+*******************************************************************/
/* Structure: OP_GLOBAL_DATA                                                */
/*                                                                          */
/* Description:                                                             */
/****************************************************************************/
typedef struct tagOP_GLOBAL_DATA
{
    DCINT32       palettePDUsBeingProcessed;      /* Must be 4-byte aligned */
    HWND          hwndOutputWindow;
    DCBOOL        paletteRealizationSupported;
    DCUINT32      lastPaintTime;
} OP_GLOBAL_DATA, DCPTR POP_GLOBAL_DATA;
/**STRUCT-*******************************************************************/


/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
#define OP_CLASS_NAME    _T("OPWindowClass")

/****************************************************************************/
/* Maximum delay in processing of outstanding WM_PAINT messages.  If this   */
/* limit is reached we force the window to be painted.                      */
/****************************************************************************/
#define OP_WORST_CASE_WM_PAINT_PERIOD 1000

class CUT;
class CUH;
class CUI;
#ifdef OS_WINCE
class CIH;
#endif

class COP
{
public:
    COP(CObjs* objs);
    ~COP();

public:
    //
    // API functions
    //
    DCVOID DCAPI OP_Init(DCVOID);
    DCVOID DCAPI OP_Term(DCVOID);
    HWND   DCAPI OP_GetOutputWindowHandle(DCVOID);
    DCVOID DCAPI OP_PaletteChanged(HWND hwnd, HWND hwndTrigger);
    DCUINT DCAPI OP_QueryNewPalette(HWND hwnd);
    DCVOID DCAPI OP_MaybeForcePaint(DCVOID);
    DCVOID DCAPI OP_IncrementPalettePDUCount(DCVOID);
    DCVOID DCAPI OP_Enable(DCVOID);
    DCVOID DCAPI OP_Disable(BOOL fUseDisabledBitmap);

#ifdef SMART_SIZING
    BOOL OP_CopyShadowToDC(HDC hdc, LONG srcLeft, LONG srcTop, 
                                    LONG srcWidth, LONG srcHeight,
                                    BOOL fUseUpdateClipping = FALSE);
    void OP_AddUpdateRegion(DCINT left, DCINT top, DCINT right, DCINT bottom);
    DCVOID DCAPI OP_MainWindowSizeChange(ULONG_PTR msg);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(COP,OP_MainWindowSizeChange);

    /****************************************************************************/
    /* Name:      OP_ClearUpdateRegion                                          */
    /*                                                                          */
    /* Purpose:   Clears the update region                                      */
    /****************************************************************************/
    _inline void DCAPI OP_ClearUpdateRegion()
    {
        DC_BEGIN_FN("OP_ClearUpdateRegion");
#ifdef USE_GDIPLUS
        _rgnUpdate.MakeEmpty();
#else // USE_GDIPLUS
        SetRectRgn(_hrgnUpdate, 0, 0, 0, 0);
#endif // USE_GDIPLUS
        DC_END_FN();
    }

#endif // SMART_SIZING

    #ifdef OS_WINCE
    DCVOID DCAPI OP_DoPaint(DCUINT hwnd);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(COP,OP_DoPaint);
    #endif

    DCVOID DCAPI OP_DimWindow(ULONG_PTR fDim);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(COP,OP_DimWindow);


public:
    OP_GLOBAL_DATA _OP;


private:
    //
    // Internal functions
    //
    
    static LRESULT CALLBACK OPStaticWndProc( HWND hwnd,
                            UINT message,
                            WPARAM wParam,
                            LPARAM lParam );


    LRESULT CALLBACK OPWndProc( HWND hwnd,
                                UINT message,
                                WPARAM wParam,
                                LPARAM lParam );
    
#ifdef OS_WINCE
    static BOOL CALLBACK StaticEnumTopLevelWindowsProc(HWND hwnd, 
                                  LPARAM lParam );

    BOOL EnumTopLevelWindowsProc(HWND hwnd);
#endif

    DCUINT DCINTERNAL OPRealizePaletteInWindow(HWND hwnd);

    BOOL OPStartDimmingWindow();
    BOOL OPStopDimmingWindow();
    //
    // Grilled window and dimmed window effects for the
    // disconnected state
    // 
    //
    VOID GrillWindow(HDC hdc, DCSIZE& size);
    HBRUSH CreateDitheredBrush(); 

    VOID DimWindow(HDC hdc);
    VOID DimBits24(PBYTE pSrc, int cLen, int Amount);
    VOID DimBits16(PBYTE pSrc, int cLen, int Amount);
    VOID DimBits15(PBYTE pSrc, int cLen, int Amount);


private:
    CUT* _pUt;
    CUH* _pUh;
    CCD* _pCd;
    COR* _pOr;
    CUI* _pUi;
    COD* _pOd;
#ifdef OS_WINCE
    CIH* _pIh;
#endif

private:
    CObjs* _pClientObjects;
#ifdef SMART_SIZING
    DCSIZE _scaleSize;

#ifdef USE_GDIPLUS
    Gdiplus::Region _rgnUpdate;
    Gdiplus::Region _rgnUpdateRect;
#else // USE_GDIPLUS
    //
    // GDI scaled update region
    //
    HRGN _hrgnUpdate;
    HRGN _hrgnUpdateRect;

#endif // USE_GDIPLUS
#endif // SMART_SIZING

    //
    // Grayed window (for OPDisabled) support
    //
    BOOL    _fDimWindow;
    BOOL    _iDimWindowStepsLeft;
    INT     _nDimWindowTimerID;
};


#endif // _H_OP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\nslint.h ===
/**INC+**********************************************************************/
/* Header:    nslint.h                                                      */
/*                                                                          */
/* Purpose:   Ducati Security Layer Internal Functions Windows NT specific  */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/client/nslint.h_v  $
 * 
 *    Rev 1.8   31 Jul 1997 10:33:08   KH
 * SFR1022: Move security-32 DLL name definition to aslint.h
 *
 *    Rev 1.7   15 Jul 1997 15:37:18   AK
 * SFR1016: Support Unicode build
 *
 *    Rev 1.6   11 Jul 1997 12:34:58   KH
 * SFR1022: Add SLCopyEncryptionType
 *
 *    Rev 1.5   09 Jul 1997 17:34:46   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.4   03 Jul 1997 10:53:04   AK
 * SFR0000: Initial development completed
 *
 *    Rev 1.3   03 Jul 1997 08:46:14   KH
 * Win16Port: 16-bit UI startup changes
 *
 *    Rev 1.1   24 Jun 1997 15:20:40   KH
 * Win16Port: Contains SL 32 bit specifics
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_NSLINT
#define _H_NSLINT

/****************************************************************************/
/* Constants                                                                */
/****************************************************************************/

/****************************************************************************/
/*                                                                          */
/* INLINE FUNCTIONS                                                         */
/*                                                                          */
/****************************************************************************/

#endif /* _H_NSLINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\objs.cpp ===
/**MOD+**********************************************************************/
/* Module:    objs.cpp                                                      */
/*                                                                          */
/* Purpose:   Client object container class                                 */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/


#include <adcg.h>

#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "objs"


extern "C" {
#include <adcgdata.h>
#include <atrcapi.h>
}

#include "objs.h"

#include "wui.h"
#include "autil.h"
#include "aco.h"
#include "snd.h"
#include "cd.h"
#include "rcv.h"

#include "cc.h"
#include "ih.h"

#include "or.h"
#include "fs.h"
#include "sl.h"
#include "nl.h"
#include "nc.h"
#include "mcs.h"

#include "clicense.h"
#include "xt.h"
#include "td.h"
#include "cm.h"
#include "uh.h"
#include "gh.h"
#include "od.h"
#include "op.h"
#include "sp.h"
#include "clx.h"
#include "cchan.h"


CObjs::CObjs()
{
    DC_MEMSET(this, 0, sizeof(CObjs));

    _dwActiveObjects = 0;
    _cRefCount       = 0;

    _pCoObject      = new CCO(this);
    _pUtObject      = new CUT();
    _pCdObject      = new CCD(this);
    _pSndObject     = new CSND(this);
    _pRcvObject     = new CRCV(this);
    _pCcObject      = new CCC(this);
    _pIhObject      = new CIH(this);
    _pOrObject      = new COR(this);
    _pFsObject      = new CFS(this);
    _pSlObject      = new CSL(this);
    _pNlObject      = new CNL(this);
    _pNcObject      = new CNC(this);
    _pMCSObject     = new CMCS(this);
    _pLicObject     = new CLic(this);
    _pChanObject    = new CChan(this);

    _pXTObject      = new CXT(this);
    _pTDObject      = new CTD(this);
    _pCMObject      = new CCM(this);
    _pUHObject      = new CUH(this);
    _pGHObject      = new CGH(this);
    _pODObject      = new COD(this);
    _pOPObject      = new COP(this);
    _pSPObject      = new CSP(this);
    _pCLXObject     = new CCLX(this);
}

//
// Consistency check..returns FALSE
// if any of the object pointers are not set
//
BOOL CObjs::CheckPointers()
{
    DC_BEGIN_FN("CheckPointers");
    if(!_pCoObject)
    {
        TRC_ERR((TB,_T("_pCoObject NULL")));
        return FALSE;
    }

    if(!_pUtObject)
    {
        TRC_ERR((TB,_T("_pUtObject NULL")));
        return FALSE;
    }

    if(!_pCdObject)
    {
        TRC_ERR((TB,_T("_pCdObject NULL")));
        return FALSE;
    }

    if(!_pSndObject)
    {
        TRC_ERR((TB,_T("_pSndObject NULL")));
        return FALSE;
    }

    if(!_pRcvObject)
    {
        TRC_ERR((TB,_T("_pRcvObject NULL")));
        return FALSE;
    }

    if(!_pCcObject)
    {
        TRC_ERR((TB,_T("_pCcObject NULL")));
        return FALSE;
    }

    if(!_pIhObject)
    {
        TRC_ERR((TB,_T("_pIhObject NULL")));
        return FALSE;
    }
    
    if(!_pOrObject)
    {
        TRC_ERR((TB,_T("_pOrObject NULL")));
        return FALSE;
    }

    if(!_pFsObject)
    {
        TRC_ERR((TB,_T("_pFsObject NULL")));
        return FALSE;
    }

    if(!_pSlObject)
    {
        TRC_ERR((TB,_T("_pSlObject NULL")));
        return FALSE;
    }

    if(!_pNlObject)
    {
        TRC_ERR((TB,_T("_pNlObject NULL")));
        return FALSE;
    }

    if(!_pNcObject)
    {
        TRC_ERR((TB,_T("_pNcObject NULL")));
        return FALSE;
    }

    if(!_pMCSObject)
    {
        TRC_ERR((TB,_T("_pMCSObject NULL")));
        return FALSE;
    }

    if(!_pLicObject)
    {
        TRC_ERR((TB,_T("_pLicObject NULL")));
        return FALSE;
    }

    if(!_pChanObject)
    {
        TRC_ERR((TB,_T("_pChanObject NULL")));
        return FALSE;
    }

    if(!_pXTObject)
    {
        TRC_ERR((TB,_T("_pXTObject NULL")));
        return FALSE;
    }

    if(!_pTDObject)
    {
        TRC_ERR((TB,_T("_pTDObject NULL")));
        return FALSE;
    }

    if(!_pCMObject)
    {
        TRC_ERR((TB,_T("_pCMObject NULL")));
        return FALSE;
    }

    if(!_pUHObject)
    {
        TRC_ERR((TB,_T("_pUHObject NULL")));
        return FALSE;
    }

    if(!_pGHObject)
    {
        TRC_ERR((TB,_T("_pGHObject NULL")));
        return FALSE;
    }
    
    if(!_pODObject)
    {
        TRC_ERR((TB,_T("_pODObject NULL")));
        return FALSE;
    }

    if(!_pOPObject)
    {
        TRC_ERR((TB,_T("_pODObject NULL")));
        return FALSE;
    }

    if(!_pSPObject)
    {
        TRC_ERR((TB,_T("_pSPObject NULL")));
        return FALSE;
    }
        
    if(!_pCLXObject)
    {
        TRC_ERR((TB,_T("_pCLXObject NULL")));
        return FALSE;
    }
    
    DC_END_FN();
    return TRUE;
}


CObjs::~CObjs()
{
    
    delete _pCoObject;
    delete _pUtObject;
    delete _pCdObject;
    delete _pSndObject;
    delete _pRcvObject;
    delete _pCcObject;
    delete _pIhObject;
    delete _pOrObject;
    delete _pFsObject;
    delete _pSlObject;
    delete _pNlObject;
    delete _pNcObject;
    delete _pMCSObject;
    delete _pLicObject;
    delete _pChanObject;

    delete _pXTObject;
    delete _pTDObject;
    delete _pCMObject;
    delete _pUHObject;
    delete _pGHObject;
    delete _pODObject;
    delete _pOPObject;
    delete _pSPObject;
    delete _pCLXObject;

    DC_MEMSET(this, 0, sizeof(CObjs));
}

//
// Add a reference, flagging which object holds
// a reference
//
LONG CObjs::AddObjReference(DWORD dwFlag)
{
    _dwActiveObjects |= dwFlag;
    return AddRef();
}

//
// Add a reference, flagging which object release
// the reference
//
LONG CObjs::ReleaseObjReference(DWORD dwFlag)
{
    _dwActiveObjects &= ~dwFlag;
    return Release();
}

//
// Simple Addref
//
LONG CObjs::AddRef()
{
    return InterlockedIncrement(&_cRefCount);
}

//
// Simple release
// Does not delete on refcount == 0
// this is simply for debugging purposes
//
LONG CObjs::Release()
{
    DC_BEGIN_FN("Release");
    LONG ref = InterlockedDecrement(&_cRefCount);
    TRC_ASSERT(ref >= 0, (TB,_T("refcount when below zero %d"), ref));
    DC_END_FN();
    return ref;
}

//
// Checks if there are any active references
// returns true if yes
BOOL CObjs::CheckActiveReferences()
{
    if(_cRefCount || _dwActiveObjects)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\opapi.cpp ===
/**MOD+**********************************************************************/
/* Module:    opapi.cpp                                                     */
/*                                                                          */
/* Purpose:   Output Painter API functions                                  */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "opapi"
#include <atrcapi.h>
}

#include <math.h>
#include "autil.h"
#include "wui.h"
#include "op.h"
#include "aco.h"
#include "uh.h"

COP::COP(CObjs* objs)
{
    _pClientObjects = objs;
    _fDimWindow = FALSE;
    _iDimWindowStepsLeft = 0;
    _nDimWindowTimerID = 0;

    //
    // Init the OP structure to all zeros
    //
    DC_MEMSET(&_OP, 0, sizeof(_OP));
}


COP::~COP()
{
}

/**PROC+*********************************************************************/
/* Name:      OP_Init                                                       */
/*                                                                          */
/* Purpose:   Initialize Output Painter                                     */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI COP::OP_Init(DCVOID)
{
#ifndef OS_WINCE
    WNDCLASS    wndclass;
    WNDCLASS    tmpWndClass;
#endif

    DC_BEGIN_FN("OP_Init");

    _pUt  = _pClientObjects->_pUtObject;
    _pUh  = _pClientObjects->_pUHObject;
    _pCd  = _pClientObjects->_pCdObject;
    _pOr  = _pClientObjects->_pOrObject;
    _pUi  = _pClientObjects->_pUiObject;
    _pOd  = _pClientObjects->_pODObject;
#ifdef OS_WINCE
    _pIh  = _pClientObjects->_pIhObject;
#endif

#ifndef OS_WINCE


    if(!GetClassInfo(_pUi->UI_GetInstanceHandle(), OP_CLASS_NAME, &tmpWndClass))
    {
        //
        // Create Output Painter window
        //
        wndclass.style         = CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc   = OPStaticWndProc;
        wndclass.cbClsExtra    = 0;
        wndclass.cbWndExtra    = sizeof(void*);
        wndclass.hInstance     = _pUi->UI_GetInstanceHandle();
        wndclass.hIcon         = NULL;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
        wndclass.lpszMenuName  = NULL;
        wndclass.lpszClassName = OP_CLASS_NAME;
        RegisterClass (&wndclass);
    }
    _OP.hwndOutputWindow = CreateWindowEx(
#ifndef OS_WINCE
                                        WS_EX_NOPARENTNOTIFY,
#else
                                        0,
#endif
                                        OP_CLASS_NAME,
                                        _T("Output Painter Window"),
                                        WS_CHILD | WS_CLIPSIBLINGS,
                                        0,
                                        0,
                                        1,
                                        1,
                                        _pUi->UI_GetUIContainerWindow(),
                                        NULL,
                                        _pUi->UI_GetInstanceHandle(),
                                        this );

    if(!_OP.hwndOutputWindow)
    {
        TRC_ERR((TB,_T("_OP.hwndOutputWindow CreateWindowEx failed: 0x%x\n"),
                 GetLastError()));
        _pUi->UI_FatalError(DC_ERR_WINDOWCREATEFAILED);
        return;
    }
    SetWindowPos( _OP.hwndOutputWindow,
                  HWND_BOTTOM,
                  0, 0, 0, 0,
                  SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );
#else
    _OP.hwndOutputWindow = _pIh->IH_GetInputHandlerWindow();
#endif /* !OS_WINCE */

    /************************************************************************/
    /* @@JPB: Temporary - should calculate based on bpp.                    */
    /************************************************************************/
    _OP.paletteRealizationSupported = TRUE;

    DC_END_FN();

    return;

} /* OP_Init  */

#ifdef SMART_SIZING
/****************************************************************************/
/* Name:      OP_AddUpdateRegion                                            */
/*                                                                          */
/* Purpose:   Adds the a given region to the update region.                 */
/****************************************************************************/
void COP::OP_AddUpdateRegion(DCINT left, DCINT top, DCINT right, DCINT bottom)
{
    RECT rect;
    float newLeft, newTop, newRight, newBottom;
    DCSIZE desktopSize;

    DC_BEGIN_FN("OP_AddUpdateRegion");

    _pUi->UI_GetDesktopSize(&desktopSize);

    //if desktop remains the same size
    //we don't need to update this region
    if ((_scaleSize.width == desktopSize.width) &&
        (_scaleSize.height == desktopSize.height)) {
        DC_QUIT;
    }

    newLeft = (float)left * (float)_scaleSize.width / 
            (float)desktopSize.width;
    newTop = (float)top * (float)_scaleSize.height / 
            (float)desktopSize.height;
    newRight = (float)right * (float)_scaleSize.width  / 
            (float)desktopSize.width;
    newBottom = (float)bottom * (float)_scaleSize.height / 
            (float)desktopSize.height;

    //
    // Since stretching causes the destination bits to be based not only 
    // on the direct source bits, but some halftoning of other nearby 
    // bits, if you are tiling memblt orders and updating the screen,
    // you can get some artificats from tiles that reference bits in 
    // their neighboring tiles that haven't been drawn yet.
    //
    // When their neighbors are drawn, we'd like to update those first
    // tiles so the artifacts will be corrected. To do this we expand 
    // the size of memblt orders clipping
    //

    newLeft     -= 2;
    newTop      -= 2;
    newRight    += 2;
    newBottom   += 2;

#ifdef USE_GDIPLUS
    Gdiplus::RectF rectF(newLeft, newTop, newRight - newLeft, newBottom - newTop);

    if (_rgnUpdate.Union(rectF) != Gdiplus::Ok) {
        TRC_ERR((TB, _T("Gdiplus::Region.Union() failed")));
    }
#else // USE_GDIPLUS
    int nnewLeft, nnewTop, nnewRight, nnewBottom;

    // Round "outwards"
    #ifndef OS_WINCE
    nnewLeft = (int)floorf(newLeft);
    nnewTop = (int)floorf(newTop);
    nnewRight = (int)ceilf(newRight);
    nnewBottom = (int)ceilf(newBottom);
    #else
    nnewLeft = (int)floor(newLeft);
    nnewTop = (int)floor(newTop);
    nnewRight = (int)ceil(newRight);
    nnewBottom = (int)ceil(newBottom);
    #endif

    // Accommodate regional exclusive cordinates.
    // Ok, my thinking says this should be +1, but +2 is what is actually 
    // required to prevent bad painting.

    nnewRight += 1;
    nnewBottom += 1;

    SetRectRgn(_hrgnUpdateRect, nnewLeft, nnewTop, nnewRight, nnewBottom);

    // Combine the rectangle region with the update region.
    if (!UnionRgn(_hrgnUpdate, _hrgnUpdate, _hrgnUpdateRect)) {
        // The region union failed so we must simplify the region. This
        // means that we may paint areas which we have not received an
        // updates for - but this is better than not painting areas which
        // we have received updates for.
        TRC_ALT((TB, _T("UnionRgn failed")));
        GetRgnBox(_hrgnUpdate, &rect);
        SetRectRgn(_hrgnUpdate, rect.left, rect.top, rect.right + 1,
                rect.bottom + 1);
        if (!UnionRgn(_hrgnUpdate, _hrgnUpdate, _hrgnUpdateRect))
        {
            TRC_ERR((TB, _T("UnionRgn failed after simplification")));
        }
    }

#endif // USE_GDIPLUS
DC_EXIT_POINT:
    DC_END_FN();
}

#endif // SMART_SIZING

/**PROC+*********************************************************************/
/* Name:      OP_Term                                                       */
/*                                                                          */
/* Purpose:   Terminate the Output Painter                                  */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI COP::OP_Term(DCVOID)
{
    DC_BEGIN_FN("OP_Term");

#ifdef DESTROY_WINDOWS
    TRC_NRM((TB, _T("Calling DestroyWindow")));
    DestroyWindow(_OP.hwndOutputWindow);
    TRC_NRM((TB, _T("Destroyed window")));

    if (!UnregisterClass(OP_CLASS_NAME, _pUi->UI_GetInstanceHandle()))
    {
        //Failure to unregister could happen if another instance is still running
        //that's ok...unregistration will happen when the last instance exits.
        TRC_ERR((TB, _T("Failed to unregister OP window class")));
    }
#endif

    //
    // Clear window handle
    //
    _OP.hwndOutputWindow = NULL;
#if defined(SMART_SIZING) && !defined(USE_GDIPLUS)
    DeleteRgn(_hrgnUpdate);
    DeleteRgn(_hrgnUpdateRect);
#endif
    DC_END_FN();

    return;

} /* OP_Term */

/**PROC+*********************************************************************/
/* Name:      OP_GetOutputWindowHandle                                      */
/*                                                                          */
/* Purpose:   Returns the Output Window handle                              */
/*                                                                          */
/* Returns:   Output Window handle                                          */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
HWND DCAPI COP::OP_GetOutputWindowHandle(DCVOID)
{
    HWND    rc;

    DC_BEGIN_FN("OP_GetOutputWindowHandle");

    if(NULL == _OP.hwndOutputWindow)
    {
        TRC_ALT((TB,_T("_OP.hwndOutputWindow is NULL")));
    }

    rc = _OP.hwndOutputWindow;

    DC_END_FN();
    return(rc);
}

#ifdef OS_WINCE
/**PROC+*********************************************************************/
/* Name:      OP_DoPaint                                                    */
/*                                                                          */
/* Purpose:   Handle WM_PAINT from IH - Windows CE only.                    */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    IN      hwnd - window handle to paint                         */
/*                                                                          */
/* Operation: Required to work around the WS_CLIPSIBLINGS problem           */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI COP::OP_DoPaint(DCUINT hwnd)
{
    DC_BEGIN_FN("OP_DoPaint");

    OPWndProc((HWND)hwnd, WM_PAINT, 0, 0);

    DC_END_FN();

    return;

} /* OP_DoPaint */
#endif /* OS_WINCE */

/**PROC+*********************************************************************/
/* Name:      OP_PaletteChanged                                             */
/*                                                                          */
/* Purpose:   Handler for WM_PALETTECHANGED messages                        */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    hwnd - handle of window that received the WM_PALETTECHANGED   */
/*            message                                                       */
/*                                                                          */
/*            hwndTrigger - handle of window that realized the palette      */
/*            that caused the WM_PALETTECHANGED message to be sent          */
/*                                                                          */
/* Operation: Realizes the current palette in the output window.            */
/*                                                                          */
/* NOTE - This function is called on the UI thread, not the receive thread. */
/*        All functions and variables referenced must be thread-safe if     */
/*        they are also accessed from another thread.                       */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI COP::OP_PaletteChanged(HWND hwnd, HWND hwndTrigger)
{
    static DCBOOL fRealising = FALSE;

    DC_BEGIN_FN("OP_PaletteChanged");

    TRC_NRM((TB, _T("WM_PALETTECHANGED hwnd(%p) hwndTrigger(%p)"),
                                          hwnd, hwndTrigger));

    /************************************************************************/
    /* During termination, may get WM_PALETTECHANGED after the OP window    */
    /* has been destroyed (in OP_Term).  Handle this.                       */
    /************************************************************************/
    if (_OP.hwndOutputWindow == NULL)
    {
        TRC_ALT((TB, _T("No OP window")));
        DC_QUIT;
    }

    /************************************************************************/
    /* The system palette has changed.  If it wasn't us that did it, then   */
    /* realize our palette now to set up our new palette mapping.           */
    /************************************************************************/
    if (_OP.palettePDUsBeingProcessed != 0)
    {
        /********************************************************************/
        /* This palette change is the result of a palette PDU, so the       */
        /* server will be redrawing the screen by itself - we don't need to */
        /* trigger a repaint.                                               */
        /********************************************************************/
        TRC_DBG((TB, _T("Not invalidating client area")));

        /********************************************************************/
        /* Note the fact that we've now seen the message associated with a  */
        /* palette PDU.  The trace statement is before the decrement so     */
        /* that the point at which we're most likely to get pre-empted      */
        /* (TRC_GetBuffer) is before all the variable references.           */
        /********************************************************************/
        TRC_NRM((TB, _T("Palette PDUs now pending processing: %ld"),
                                           _OP.palettePDUsBeingProcessed - 1));
        _pUt->UT_InterlockedDecrement(&_OP.palettePDUsBeingProcessed);
    }
    else if ((hwndTrigger == hwnd) || (hwndTrigger == _OP.hwndOutputWindow))
    {
        if (fRealising == FALSE)
        {
            TRC_DBG((TB, _T("Invalidating client area cos we changed palette")));
            InvalidateRect(_OP.hwndOutputWindow, NULL, FALSE);
        }
        else
        {
            TRC_NRM((TB, _T("Not Invalidating client: still changing palette")));
        }
    }
    else
    {
        TRC_NRM((TB, _T("Not our window - realize palette in wnd(%p)"), hwnd));
        /********************************************************************/
        /* if we change the colors at all, we should repaint                */
        /********************************************************************/
#ifdef OS_WINCE // UpdateColors not supported on WinCE
        OPRealizePaletteInWindow(_OP.hwndOutputWindow);
#else
        fRealising = TRUE;
        if (OPRealizePaletteInWindow(_OP.hwndOutputWindow) != 0)
        {
            HDC hdcOutputWindow = GetDC(_OP.hwndOutputWindow);
            TRC_ASSERT(hdcOutputWindow, (TB, _T("GetDC returned NULL for _OP.hwndOutputWindow")));
            if(hdcOutputWindow)
            {
                TRC_NRM((TB, _T("Updating client area cos palette changed")));
                UpdateColors(hdcOutputWindow);
                ReleaseDC(_OP.hwndOutputWindow, hdcOutputWindow);
                InvalidateRect(_OP.hwndOutputWindow, NULL, FALSE);
            }
        }
        fRealising = FALSE;
#endif /* ifdef OS_WINCE */
    }

DC_EXIT_POINT:
    DC_END_FN();
    return;
}

/**PROC+*********************************************************************/
/* Name:      OP_QueryNewPalette                                            */
/*                                                                          */
/* Purpose:   Handler for WM_QUERYNEWPALETTE messages                       */
/*                                                                          */
/* Returns:   Number of palette entries changed                             */
/*                                                                          */
/* Params:    hwnd - handle of window that recieved the WM_QUERYNEWPALETTE  */
/*            message                                                       */
/*                                                                          */
/* Operation: Realizes the current palette in the output window.            */
/*                                                                          */
/* NOTE - This function is called on the UI thread, not the receive thread. */
/*        All functions and variables referenced must be thread-safe if     */
/*        they are also accessed from another thread.                       */
/*                                                                          */
/**PROC-*********************************************************************/
DCUINT DCAPI COP::OP_QueryNewPalette(HWND hwnd)
{
    DCUINT  rc = 0;

    DC_BEGIN_FN("OP_QueryNewPalette");

    DC_IGNORE_PARAMETER(hwnd);

    if (_OP.paletteRealizationSupported)
    {
        rc = OPRealizePaletteInWindow(_OP.hwndOutputWindow);

        TRC_NRM((TB, _T("Palette realized(%u)"), rc));
    }

    DC_END_FN();
    return(rc);
}

/**PROC+*********************************************************************/
/* Name:      OP_MaybeForcePaint                                            */
/*                                                                          */
/* Purpose:   Forces the Output Window to be painted if necessary           */
/*            (if a WM_PAINT has been outstanding for an unreasonable       */
/*            amount of time).                                              */
/*                                                                          */
/* Returns:   Nothing.                                                      */
/*                                                                          */
/* Params:    None.                                                         */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI COP::OP_MaybeForcePaint(DCVOID)
{
    DCUINT32    currentTime;

    DC_BEGIN_FN("OP_MaybeForcePaint");

    currentTime = _pUt->UT_GetCurrentTimeMS();

    if ((currentTime - _OP.lastPaintTime) > OP_WORST_CASE_WM_PAINT_PERIOD)
    {
        /********************************************************************/
        /* UpdateWindow synchronously calls the WndProc with a WM_PAINT if  */
        /* there is a non-NULL update region.                               */
        /********************************************************************/
        TRC_DBG((TB, _T("Forced update")));
        UpdateWindow(OP_GetOutputWindowHandle());

        _OP.lastPaintTime = currentTime;
    }

    DC_END_FN();
    return;
}

//
// OP_DimWindow
// CD call to change the window dim state
//
// Params:
//  fDim - BOOL indicating if window should start or stop being dimmed
//
DCVOID DCAPI COP::OP_DimWindow(ULONG_PTR fDim)
{
    BOOL fChanged = FALSE;
    DC_BEGIN_FN("OP_DimWindow");

    fChanged = (_fDimWindow != (BOOL)fDim);
    if (fChanged) {
        TRC_NRM((TB,_T("Changed window dim state to: %d"), _fDimWindow));

        if (fDim) {
            OPStartDimmingWindow();
        }
        else {
            OPStopDimmingWindow();
        }
        
        InvalidateRect(OP_GetOutputWindowHandle(), NULL, FALSE);
    }

    DC_END_FN();
}

#ifdef SMART_SIZING
/****************************************************************************/
/* Name:      OP_MainWindowSizeChange                                       */
/*                                                                          */
/* Purpose:   Remembers the size of the container for scaling               */
/****************************************************************************/
DCVOID DCAPI COP::OP_MainWindowSizeChange(ULONG_PTR msg)
{
    DCSIZE desktopSize;
    DCUINT width;
    DCUINT height;

    width  = LOWORD(msg);
    height = HIWORD(msg);

    if (_pUi) {
        _pUi->UI_GetDesktopSize(&desktopSize);

        if (width <= desktopSize.width) {
            _scaleSize.width = width;
        } else {
            // full screen, or other times the window is bigger than the 
            // display resolution
            _scaleSize.width = desktopSize.width;
        }
    
        // Similarly
        if (height <= desktopSize.height) {
            _scaleSize.height = height;
        } else {
            _scaleSize.height = desktopSize.height;
        }
    
        InvalidateRect(_OP.hwndOutputWindow, NULL, FALSE);
    }
}

/**PROC+*********************************************************************/
/* Name:      OP_CopyShadowToDC                                             */
/*                                                                          */
/* Purpose:   Copy the contents of the shadow bitmap to the destination,    */
/*            possibly with stretching                                      */
/*                                                                          */
/* Returns:   None.                                                         */
/*                                                                          */
/* Params:    None.                                                         */
/*                                                                          */
/**PROC-*********************************************************************/
BOOL COP::OP_CopyShadowToDC(HDC hdc, LONG srcLeft, LONG srcTop, 
                                LONG srcWidth, LONG srcHeight, BOOL fUseUpdateClipping)
{
    BOOL rcBlt, rc;
    
#ifdef USE_GDIPLUS
    Gdiplus::REAL dstLeft, dstTop, dstWidth, dstHeight;
#else // USE_GDIPLUS
    FLOAT dstLeft, dstTop, dstWidth, dstHeight;
#endif // USE_GDIPLUS
    
    DCSIZE desktopSize;
#ifdef USE_GDIPLUS
//    static Gdiplus::InterpolationMode interpolationMode = Gdiplus::InterpolationModeHighQualityBicubic;
    static Gdiplus::InterpolationMode interpolationMode = Gdiplus::InterpolationModeBilinear;
#endif // USE_GDIPLUS
    HDC hdcSrcBitmap = !_fDimWindow ? _pUh->UH_GetShadowBitmapDC() :
                                       _pUh->UH_GetDisconnectBitmapDC();

    DC_BEGIN_FN("OP_CopyShadowToDC");

    _pUi->UI_GetDesktopSize(&desktopSize);

    if (!_pUi->UI_GetSmartSizing() ||
        ((_scaleSize.width == desktopSize.width) &&
        (_scaleSize.height == desktopSize.height))) {
        if (fUseUpdateClipping) {
            SelectClipRgn(hdc, _pUh->_UH.hrgnUpdate);
        }
        rcBlt = BitBlt(hdc, srcLeft, srcTop, srcWidth,
                srcHeight, hdcSrcBitmap, srcLeft, srcTop, 
                SRCCOPY);
        if (fUseUpdateClipping) {
            SelectClipRgn(hdc, NULL);
        }
        if (rcBlt) {
            rc = TRUE;
        } else {
            /********************************************************/
            /* Failed to Blt.                                       */
            /********************************************************/
            TRC_ERR((TB, _T("BitBlt failed")));
            rc = FALSE;
        }
    } else {

#ifdef USE_GDIPLUS
        // Gdiplus version
        Gdiplus::Status status;
        Gdiplus::Bitmap *source = new Gdiplus::Bitmap(_pUh->_UH.hShadowBitmap, NULL);
        if (source && source->GetLastStatus() == Gdiplus::Ok) {
            Gdiplus::Graphics *gdst = new Gdiplus::Graphics(hdc);
            if (gdst && gdst->GetLastStatus() == Gdiplus::Ok) {
                gdst->SetInterpolationMode(interpolationMode);

                if (fUseUpdateClipping) {
                    gdst->SetClip(&_rgnUpdate);

                    // Adjust the rectangle to be
                    // no bigger than the bounding box of the clipping
                    //
                    // Use the unstretched coordinates for this

                    RECT rect;

                    GetRgnBox(_pUh->_UH.hrgnUpdate, &rect); 

                    if (rect.left < srcLeft)
                         rect.left = srcLeft;

                    if (rect.top < srcTop)
                        rect.top = srcTop;

                    if (rect.right > srcLeft + srcWidth)
                        rect.right = srcLeft + srcWidth;

                    if (rect.bottom > srcTop + srcHeight)
                        rect.bottom = srcTop + srcHeight;

                    srcLeft = rect.left;
                    srcWidth = rect.right - rect.left;
                    srcTop = rect.top;
                    srcHeight = rect.bottom - rect.top;
                }

                dstLeft = (float)srcLeft * (float)_scaleSize.width / 
                        (float)desktopSize.width;
                dstTop = (float)srcTop * (float)_scaleSize.height / 
                        (float)desktopSize.height;
                dstWidth = (float)srcWidth * (float)_scaleSize.width / 
                        (float)desktopSize.width;
                dstHeight = (float)srcHeight * (float)_scaleSize.height / 
                        (float)desktopSize.height;
                
#if 0
                Gdiplus::HatchBrush brush(Gdiplus::HatchStyleForwardDiagonal, 
                        Gdiplus::Color(0, 255, 0), Gdiplus::Color(0x00000000));

                gdst->FillRectangle(&brush, dstLeft, dstTop, dstLeft + dstWidth,
                             dstTop + dstHeight);
#endif 

                Gdiplus::RectF dstrect(dstLeft, dstTop, dstWidth, dstHeight);
                status = gdst->DrawImage(source, dstrect, (Gdiplus::REAL)srcLeft, 
                        (Gdiplus::REAL)srcTop, (Gdiplus::REAL)srcWidth, 
                        (Gdiplus::REAL)srcHeight, Gdiplus::UnitPixel);

#if 0
                Gdiplus::HatchBrush brush(Gdiplus::HatchStyleForwardDiagonal, 
                    Gdiplus::Color(0, 255, 0), Gdiplus::Color(0x00000000));

                gdst->FillRectangle(&brush, dstLeft, dstTop, dstLeft + dstWidth,
                             dstTop + dstHeight);
#endif 
                if (fUseUpdateClipping) {
                    gdst->ResetClip();
                }

                if (status == Gdiplus::Ok) {
                    rc = TRUE;
                } else {
                    rc = FALSE;
                    TRC_ERR((TB, _T("Failed to DrawImage")));
                }
                delete gdst;
            } else {
                TRC_ERR((TB, _T("Failed to create Graphics object")));
                if (gdst != NULL) {
                    delete gdst;
                }
                rc = FALSE;
            }
            delete source;
        } else {
            TRC_ERR((TB, _T("Failed to create Bitmap object")));
            if (source != NULL) {
                delete source;
            }
            rc = FALSE;
        }
#else // USE_GDIPLUS

        //
        // Non-GDI+ stretching solution, uses StretchBlt with the BltMode set
        // to HALFTONE
        //

        //
        // StretchBlt has a bug which will cause incorrect painting for
        // top-down, stretched, halftoned blts that use a subrectangle of
        // the source.
        //
        // So instead we'll always use clipping to get a subrectangle
        //

        if (srcLeft != 0 || srcTop != 0 || (DCUINT)srcWidth != desktopSize.width || 
                (DCUINT)srcHeight != desktopSize.height) {

            //
            // Calculate the destination rectangle
            //

            dstLeft = (float)srcLeft * (float)_scaleSize.width / 
                    (float)desktopSize.width;
            dstTop = (float)srcTop * (float)_scaleSize.height / 
                    (float)desktopSize.height;
            dstWidth = (float)srcWidth * (float)_scaleSize.width / 
                    (float)desktopSize.width;
            dstHeight = (float)srcHeight * (float)_scaleSize.height / 
                    (float)desktopSize.height;
            //
            // Make it region 
            //

            int ndstLeft, ndstTop, ndstWidth, ndstHeight;

            #ifndef OS_WINCE
            ndstLeft = (int)floorf(dstLeft);
            ndstTop = (int)floorf(dstTop);
            ndstWidth = (int)ceilf(dstWidth);
            ndstHeight = (int)ceilf(dstHeight);
            #else
            ndstLeft = (int)floor(dstLeft);
            ndstTop = (int)floor(dstTop);
            ndstWidth = (int)ceil(dstWidth);
            ndstHeight = (int)ceil(dstHeight);            
            #endif

            SetRectRgn(_hrgnUpdateRect, ndstLeft, ndstTop, 
                    ndstLeft + ndstWidth + 1, ndstTop + ndstHeight + 1);
        } else {
            dstLeft = 0;
            dstTop = 0;
            dstWidth = (float)_scaleSize.width;
            dstHeight = (float)_scaleSize.height;

            SetRectRgn(_hrgnUpdateRect, (int)dstLeft, (int)dstTop, 
                    (int)dstLeft + (int)dstWidth, (int)dstTop + (int)dstHeight);
        }


        if (fUseUpdateClipping) {

            //
            // _hrgnUpdate is the actual clipping region, which we don't want
            // to disturb. _hrgnUpdateRect is a scratch region we normally 
            // use to create a rect region in before we update _hrgnUpdate
            // This time we do it backwards to preserve _hrgnUpdate but
            // since _hrgnUpdateRect is just as scratch anyway, use it and 
            // don't create an extra region
            //

            if (!IntersectRgn(_hrgnUpdateRect, _hrgnUpdateRect, _hrgnUpdate)) {
                // Combining the regions failed. Consequence? StretchDIBits 
                // may be slowing because it will copy bits that don't need 
                // updating. But visually it will still be correct
                TRC_ERR((TB, _T("IntersectRgn failed!")));

            }
        }

        SelectClipRgn(hdc, _hrgnUpdateRect);

        DIBSECTION ds;

        #ifndef OS_WINCE
        if (_scaleSize.width  >= desktopSize.width &&
            _scaleSize.height >= desktopSize.height)
        {
            //
            // PERF: In identity case use COLORONCOLOR
            //       because HALFTONE is over 10 times slower
            //
            SetStretchBltMode(hdc, COLORONCOLOR);
        }
        else
        {
            //
            // HALFTONE looks good but is very slow
            //
            SetStretchBltMode(hdc, HALFTONE);
        }
        #endif
        
        SetBrushOrgEx(hdc, 0, 0, NULL);

        if (GetObject(_pUh->_UH.hShadowBitmap, sizeof(DIBSECTION), &ds) != 0) {

            if (_pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_NT) {
                ds.dsBmih.biHeight *= -1;
            }

            //
            // Update the traditional utility bmih, so we get the right
            // colors
            //

            _pUh->_UH.bitmapInfo.hdr.biHeight = ds.dsBmih.biHeight;
            _pUh->_UH.bitmapInfo.hdr.biWidth = ds.dsBmih.biWidth;
            _pUh->_UH.bitmapInfo.hdr.biClrImportant = ds.dsBmih.biClrImportant;
            _pUh->_UH.bitmapInfo.hdr.biClrUsed = ds.dsBmih.biClrUsed;

#if 0
            _pUh->UH_HatchRectDC(hdc, (DCINT)dstLeft, (DCINT)dstTop, 
                    (DCINT)(dstLeft + dstWidth), (DCINT)(dstTop + dstHeight),
                     UH_RGB_GREEN, UH_BRUSHTYPE_FDIAGONAL);
#endif

            if (StretchDIBits(hdc, 0, 0, _scaleSize.width, _scaleSize.height, 
                    0, 0, desktopSize.width, desktopSize.height, 
                    ds.dsBm.bmBits, (PBITMAPINFO) &(_pUh->_UH.bitmapInfo.hdr),
                    _pUh->_UH.DIBFormat, SRCCOPY) != GDI_ERROR) {
                rc = TRUE;
            } else {
                TRC_SYSTEM_ERROR("StretchDIBits");
                rc = FALSE;
            }
        } else {
            TRC_SYSTEM_ERROR("GetObject");
            rc = FALSE;
        }

        if (fUseUpdateClipping) {
            // 
            // Clear the clipping region
            //
            SelectClipRgn(hdc, NULL);
        }

#endif // USE_GDIPLUS
    }

    DC_END_FN();
    return rc;
}
#endif // SMART_SIZING

/**PROC+*********************************************************************/
/* Name:      OP_IncrementPalettePDUCount                                   */
/*                                                                          */
/* Purpose:   Increment the count of palette PDUs being processed.          */
/*                                                                          */
/* Returns:   None.                                                         */
/*                                                                          */
/* Params:    None.                                                         */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI COP::OP_IncrementPalettePDUCount(DCVOID)
{
    DC_BEGIN_FN("OP_IncrementPalettePDUCount");

    if (!_pUh->UH_ShadowBitmapIsEnabled())
    {
#ifdef DC_DEBUG
        /********************************************************************/
        /* This tracing is before the interlocked inc so that the point at  */
        /* which we're most likely to get pre-empted (TRC_GetBuffer) is     */
        /* before all references to the variable we're interested in.       */
        /********************************************************************/
        if (_OP.palettePDUsBeingProcessed >= 5)
        {
            TRC_ALT((TB, _T("TOO MANY Palette PDUs now pending processing: %ld"),
                         _OP.palettePDUsBeingProcessed + 1));
        }
        else
        {
            TRC_NRM((TB, _T("Palette PDUs now pending processing: %ld"),
                         _OP.palettePDUsBeingProcessed + 1));
        }
#endif
        _pUt->UT_InterlockedIncrement(&_OP.palettePDUsBeingProcessed);
    }

    DC_END_FN();
    return;

} /* OP_IncrementPalettePDUCount */


/**PROC+*********************************************************************/
/* Name:      OP_Enable                                                     */
/*                                                                          */
/* Purpose:   Prepare OP for a new share.                                   */
/*                                                                          */
/* Returns:   None.                                                         */
/*                                                                          */
/* Params:    None.                                                         */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI COP::OP_Enable(DCVOID)
{
    DCSIZE desktopSize;

    DC_BEGIN_FN("OP_Enable");

    /************************************************************************/
    /* Reset the count of palette PDUs received so that we correctly handle */
    /* abnormal call termination.                                           */
    /************************************************************************/
    TRC_NRM((TB, _T("Reset pending palette count to zero")));
    _OP.palettePDUsBeingProcessed = 0;

    /************************************************************************/
    /* Show the output window, setting the size to match the new desktop    */
    /* size                                                                 */
    /************************************************************************/
    _pUi->UI_GetDesktopSize(&desktopSize);
    TRC_NRM((TB, _T("Show output window size %dx%d"), desktopSize.width,
                                                  desktopSize.height));

    SetWindowPos( OP_GetOutputWindowHandle(),
                  NULL,
                  0, 0,
                  desktopSize.width,
                  desktopSize.height,
                  SWP_SHOWWINDOW | SWP_NOZORDER | SWP_NOMOVE |
                  SWP_NOACTIVATE | SWP_NOOWNERZORDER );

#if defined(SMART_SIZING) && !defined(USE_GDIPLUS)
    _hrgnUpdate = CreateRectRgn(0, 0, 0, 0);
    _hrgnUpdateRect = CreateRectRgn(0, 0, 0, 0);
#endif

    DC_END_FN();
    return;

} /* OP_Enable */


/**PROC+*********************************************************************/
/* Name:      OP_Disable                                                    */
/*                                                                          */
/* Purpose:   Do OP end-of-share processing                                 */
/*                                                                          */
/* Returns:   None.                                                         */
/*                                                                          */
/* Params:    fUseDisabledBitmap - if true display a grayed disable bitmap. */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI COP::OP_Disable(BOOL fUseDisabledBitmap)
{
    DC_BEGIN_FN("OP_Disable");

DC_EXIT_POINT:
    DC_END_FN();
    return;

} /* OP_Disable */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\odapi.cpp ===
/****************************************************************************/
// odapi.cpp
//
// Order Decoder API functions.
//
// Copyright (c) 1997-2000 Microsoft Corp.
// Portions copyright (c) 1992-2000 Microsoft
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "aodapi"
#include <atrcapi.h>
}
#define TSC_HR_FILEID TSC_HR_ODAPI_CPP

#include "od.h"

/****************************************************************************/
/* Define macros used to build the Order Decoder decoding data tables.      */
/*                                                                          */
/* Entries can be of fixed size or variable size.  Variable size entries    */
/* must be the last in each order structure.  OD decodes variable entries   */
/* into the unpacked structures.                                            */
/****************************************************************************/

/****************************************************************************/
/* Fields can either be signed (DCINT16 etc), or unsigned (DCUINT16 etc).   */
/****************************************************************************/
#define SIGNED_FIELD    OD_OFI_TYPE_SIGNED
#define UNSIGNED_FIELD  0

/****************************************************************************/
/* DTABLE_FIXED_ENTRY                                                       */
/*                                                                          */
/* Field is a fixed size                                                    */
/*   type   - The unencoded order structure type                            */
/*   size   - The size of the encoded version of the field                  */
/*   signed - TRUE if the field is signed, FALSE otherwise                  */
/*   field  - The name of the field in the order structure                  */
/****************************************************************************/
#define DTABLE_FIXED_ENTRY(type,size,signed,field)             \
  { (DCUINT8)FIELDOFFSET(type,field),                          \
    (DCUINT8)FIELDSIZE(type,field),                            \
    (DCUINT8)size,                                             \
    (DCUINT8)(OD_OFI_TYPE_FIXED | signed) }

/****************************************************************************/
/* DTABLE_FIXED_COORDS_ENTRY                                                */
/*                                                                          */
/* Field is coordinate of a fixed size                                      */
/*   type   - The unencoded order structure type                            */
/*   size   - The size of the encoded version of the field                  */
/*   signed - TRUE if the field is signed, FALSE otherwise                  */
/*   field  - The name of the field in the order structure                  */
/****************************************************************************/
#define DTABLE_FIXED_COORDS_ENTRY(type,size,signed,field)      \
  { (DCUINT8)FIELDOFFSET(type,field),                          \
    (DCUINT8)FIELDSIZE(type,field),                            \
    (DCUINT8)size,                                             \
    (DCUINT8)(OD_OFI_TYPE_FIXED | OD_OFI_TYPE_COORDINATES | signed) }

/****************************************************************************/
/* DTABLE_DATA_ENTRY                                                        */
/*                                                                          */
/* Field is a fixed number of bytes (array?)                                */
/*   type   - The unencoded order structure type                            */
/*   size   - The number of bytes in the encoded version of the field       */
/*   signed - TRUE if the field is signed, FALSE otherwise                  */
/*   field  - The name of the field in the order structure                  */
/****************************************************************************/
#define DTABLE_DATA_ENTRY(type,size,signed,field)              \
  { (DCUINT8)FIELDOFFSET(type,field),                          \
    (DCUINT8)FIELDSIZE(type,field),                            \
    (DCUINT8)size,                                             \
    (DCUINT8)(OD_OFI_TYPE_FIXED | OD_OFI_TYPE_DATA | signed) }

/****************************************************************************/
/* DTABLE_VARIABLE_ENTRY                                                    */
/*                                                                          */
/* Field is a variable structure of the form below, with the length field   */
/* encoded as ONE byte                                                      */
/*   typedef struct                                                         */
/*   {                                                                      */
/*      DCUINT32 len;                                                       */
/*      varType  varEntry[len];                                             */
/*   } varStruct                                                            */
/*                                                                          */
/*   type   - The unencoded order structure type                            */
/*   size   - The size of the encoded version of the field                  */
/*   signed - TRUE if the field is signed, FALSE otherwise                  */
/*   field  - The name of the field in the order structure (varStruct)      */
/*   elem   - The name of the variable element array (varEntry)             */
/****************************************************************************/
#define DTABLE_VARIABLE_ENTRY(type,size,signed,field,elem)     \
  { (DCUINT8)FIELDOFFSET(type,field.len),                      \
    (DCUINT8)FIELDSIZE(type,field.elem[0]),                    \
    (DCUINT8)size,                                             \
    (DCUINT8)(OD_OFI_TYPE_VARIABLE | signed) }

/****************************************************************************/
/* DTABLE_LONG_VARIABLE_ENTRY                                               */
/*                                                                          */
/* Field is a variable structure of the form below, with the length field   */
/* encoded as TWO bytes                                                     */
/*   typedef struct                                                         */
/*   {                                                                      */
/*      DCUINT32 len;                                                       */
/*      varType  varEntry[len];                                             */
/*   } varStruct                                                            */
/*                                                                          */
/*   type   - The unencoded order structure type                            */
/*   size   - The size of the encoded version of the field                  */
/*   signed - TRUE if the field is signed, FALSE otherwise                  */
/*   field  - The name of the field in the order structure (varStruct)      */
/*   elem   - The name of the variable element array (varEntry)             */
/****************************************************************************/
#define DTABLE_LONG_VARIABLE_ENTRY(type,size,signed,field,elem)     \
  { (DCUINT8)FIELDOFFSET(type,field.len),                      \
    (DCUINT8)FIELDSIZE(type,field.elem[0]),                    \
    (DCUINT8)size,                                             \
    (DCUINT8)(OD_OFI_TYPE_LONG_VARIABLE | signed) }


// Unused currently, so we also can ifdef some code.
#ifdef USE_VARIABLE_COORDS
/****************************************************************************/
/* DTABLE_VARIABLE_COORDS_ENTRY                                             */
/*                                                                          */
/* Field is a variable structure with its length encoded in ONE byte and    */
/* containing coords of the form                                            */
/*   typedef struct                                                         */
/*   {                                                                      */
/*      DCUINT32 len;                                                       */
/*      varCoord varEntry[len];                                             */
/*   } varStruct                                                            */
/*                                                                          */
/*   type   - The unencoded order structure type                            */
/*   size   - The size of the encoded version of the field                  */
/*   signed - TRUE if the field is signed, FALSE otherwise                  */
/*   field  - The name of the field in the order structure (varStruct)      */
/*   elem   - The name of the variable element array (varEntry)             */
/****************************************************************************/
#define DTABLE_VARIABLE_COORDS_ENTRY(type,size,signed,field,elem)   \
  { (DCUINT8)FIELDOFFSET(type,field.len),                           \
    (DCUINT8)FIELDSIZE(type,field.elem[0]),                         \
    (DCUINT8)size,                                                  \
    (DCUINT8)(OD_OFI_TYPE_VARIABLE | OD_OFI_TYPE_COORDINATES | signed) }

/****************************************************************************/
/* DTABLE_LONG_VARIABLE_COORDS_ENTRY                                        */
/*                                                                          */
/* Field is a variable structure with its length encoded in TWO bytes and   */
/* containing coords of the form                                            */
/*   typedef struct                                                         */
/*   {                                                                      */
/*      DCUINT32 len;                                                       */
/*      varCoord varEntry[len];                                             */
/*   } varStruct                                                            */
/*                                                                          */
/*   type   - The unencoded order structure type                            */
/*   size   - The size of the encoded version of the field                  */
/*   signed - TRUE if the field is signed, FALSE otherwise                  */
/*   field  - The name of the field in the order structure (varStruct)      */
/*   elem   - The name of the variable element array (varEntry)             */
/****************************************************************************/
#define DTABLE_LONG_VARIABLE_COORDS_ENTRY(type,size,signed,field,elem)   \
  { (DCUINT8)FIELDOFFSET(type,field.len),                           \
    (DCUINT8)FIELDSIZE(type,field.elem[0]),                         \
    (DCUINT8)size,                                                  \
    (DCUINT8)(OD_OFI_TYPE_LONG_VARIABLE | OD_OFI_TYPE_COORDINATES | signed) }
#endif  // USE_VARIABLE_COORDS 


const OD_ORDER_FIELD_INFO odDstBltFields[] =
{
    DTABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD,   nLeftRect),
    DTABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD,   nTopRect),
    DTABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD,   nWidth),
    DTABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD,   nHeight),
    DTABLE_FIXED_ENTRY       (DSTBLT_ORDER, 1, UNSIGNED_FIELD, bRop)
};

// Fast-path decode function used.
#if 0
const OD_ORDER_FIELD_INFO odPatBltFields[] =
{
    DTABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD,   nLeftRect),
    DTABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD,   nTopRect),
    DTABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD,   nWidth),
    DTABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD,   nHeight),
    DTABLE_FIXED_ENTRY       (PATBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
    DTABLE_DATA_ENTRY        (PATBLT_ORDER, 3, UNSIGNED_FIELD, BackColor),
    DTABLE_DATA_ENTRY        (PATBLT_ORDER, 3, UNSIGNED_FIELD, ForeColor),
    DTABLE_FIXED_ENTRY       (PATBLT_ORDER, 1, SIGNED_FIELD,   BrushOrgX),
    DTABLE_FIXED_ENTRY       (PATBLT_ORDER, 1, SIGNED_FIELD,   BrushOrgY),
    DTABLE_FIXED_ENTRY       (PATBLT_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
    DTABLE_FIXED_ENTRY       (PATBLT_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
    DTABLE_DATA_ENTRY        (PATBLT_ORDER, 7, UNSIGNED_FIELD, BrushExtra)
};
#endif

const OD_ORDER_FIELD_INFO odScrBltFields[] =
{
    DTABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD,   nLeftRect),
    DTABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD,   nTopRect),
    DTABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD,   nWidth),
    DTABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD,   nHeight),
    DTABLE_FIXED_ENTRY       (SCRBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
    DTABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD,   nXSrc),
    DTABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD,   nYSrc)
};


// Fast-path decode function used.
#if 0
const OD_ORDER_FIELD_INFO odLineToFields[] =
{
    DTABLE_FIXED_ENTRY       (LINETO_ORDER, 2, SIGNED_FIELD,   BackMode),
    DTABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD,   nXStart),
    DTABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD,   nYStart),
    DTABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD,   nXEnd),
    DTABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD,   nYEnd),
    DTABLE_DATA_ENTRY        (LINETO_ORDER, 3, UNSIGNED_FIELD, BackColor),
    DTABLE_FIXED_ENTRY       (LINETO_ORDER, 1, UNSIGNED_FIELD, ROP2),
    DTABLE_FIXED_ENTRY       (LINETO_ORDER, 1, UNSIGNED_FIELD, PenStyle),
    DTABLE_FIXED_ENTRY       (LINETO_ORDER, 1, UNSIGNED_FIELD, PenWidth),
    DTABLE_DATA_ENTRY        (LINETO_ORDER, 3, UNSIGNED_FIELD, PenColor)
};
#endif

// Fast-path decode function used.
#if 0
const OD_ORDER_FIELD_INFO odOpaqueRectFields[] =
{
    DTABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD,   nLeftRect),
    DTABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD,   nTopRect),
    DTABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD,   nWidth),
    DTABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD,   nHeight),
    DTABLE_DATA_ENTRY(OPAQUERECT_ORDER, 1, UNSIGNED_FIELD, Color.u.rgb.red),
    DTABLE_DATA_ENTRY(OPAQUERECT_ORDER, 1, UNSIGNED_FIELD, Color.u.rgb.green),
    DTABLE_DATA_ENTRY(OPAQUERECT_ORDER, 1, UNSIGNED_FIELD, Color.u.rgb.blue)
};
#endif

const OD_ORDER_FIELD_INFO odSaveBitmapFields[] =
{
    DTABLE_FIXED_ENTRY       (SAVEBITMAP_ORDER, 4, UNSIGNED_FIELD,
                                                         SavedBitmapPosition),
    DTABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
    DTABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                    nTopRect),
    DTABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                  nRightRect),
    DTABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                 nBottomRect),
    DTABLE_FIXED_ENTRY       (SAVEBITMAP_ORDER, 1, UNSIGNED_FIELD,
                                                                   Operation)
};

// Fast-path decode function used.
#if 0
const OD_ORDER_FIELD_INFO odMemBltFields[] =
{
    DTABLE_FIXED_ENTRY       (MEMBLT_R2_ORDER, 2, UNSIGNED_FIELD, Common.cacheId),
    DTABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD,   Common.nLeftRect),
    DTABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD,   Common.nTopRect),
    DTABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD,   Common.nWidth),
    DTABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD,   Common.nHeight),
    DTABLE_FIXED_ENTRY       (MEMBLT_R2_ORDER, 1, UNSIGNED_FIELD, Common.bRop),
    DTABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD,   Common.nXSrc),
    DTABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD,   Common.nYSrc),
    DTABLE_FIXED_ENTRY       (MEMBLT_R2_ORDER, 2, UNSIGNED_FIELD, Common.cacheIndex)
};
#endif

const OD_ORDER_FIELD_INFO odMem3BltFields[] =
{
    DTABLE_FIXED_ENTRY       (MEM3BLT_R2_ORDER, 2, UNSIGNED_FIELD,Common.cacheId),
    DTABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,  Common.nLeftRect),
    DTABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,  Common.nTopRect),
    DTABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,  Common.nWidth),
    DTABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,  Common.nHeight),
    DTABLE_FIXED_ENTRY       (MEM3BLT_R2_ORDER, 1, UNSIGNED_FIELD,Common.bRop),
    DTABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,  Common.nXSrc),
    DTABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,  Common.nYSrc),
    DTABLE_FIXED_ENTRY       (MEM3BLT_R2_ORDER, 3, UNSIGNED_FIELD,BackColor),
    DTABLE_FIXED_ENTRY       (MEM3BLT_R2_ORDER, 3, UNSIGNED_FIELD,ForeColor),
    DTABLE_FIXED_ENTRY       (MEM3BLT_R2_ORDER, 1, SIGNED_FIELD,  BrushOrgX),
    DTABLE_FIXED_ENTRY       (MEM3BLT_R2_ORDER, 1, SIGNED_FIELD,  BrushOrgY),
    DTABLE_FIXED_ENTRY       (MEM3BLT_R2_ORDER, 1, UNSIGNED_FIELD,BrushStyle),
    DTABLE_FIXED_ENTRY       (MEM3BLT_R2_ORDER, 1, UNSIGNED_FIELD,BrushHatch),
    DTABLE_FIXED_ENTRY       (MEM3BLT_R2_ORDER, 7, UNSIGNED_FIELD,BrushExtra),
    DTABLE_FIXED_ENTRY       (MEM3BLT_R2_ORDER, 2, UNSIGNED_FIELD,Common.cacheIndex)
};

const OD_ORDER_FIELD_INFO odMultiDstBltFields[] =
{
    DTABLE_FIXED_COORDS_ENTRY(MULTI_DSTBLT_ORDER, 2, SIGNED_FIELD,   nLeftRect),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_DSTBLT_ORDER, 2, SIGNED_FIELD,   nTopRect),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_DSTBLT_ORDER, 2, SIGNED_FIELD,   nWidth),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_DSTBLT_ORDER, 2, SIGNED_FIELD,   nHeight),
    DTABLE_FIXED_ENTRY       (MULTI_DSTBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
    DTABLE_FIXED_ENTRY       (MULTI_DSTBLT_ORDER, 1, UNSIGNED_FIELD, nDeltaEntries),
    DTABLE_LONG_VARIABLE_ENTRY(MULTI_DSTBLT_ORDER, 1, UNSIGNED_FIELD, codedDeltaList, Deltas)
};

const OD_ORDER_FIELD_INFO odMultiPatBltFields[] =
{
    DTABLE_FIXED_COORDS_ENTRY(MULTI_PATBLT_ORDER, 2, SIGNED_FIELD,   nLeftRect),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_PATBLT_ORDER, 2, SIGNED_FIELD,   nTopRect),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_PATBLT_ORDER, 2, SIGNED_FIELD,   nWidth),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_PATBLT_ORDER, 2, SIGNED_FIELD,   nHeight),
    DTABLE_FIXED_ENTRY       (MULTI_PATBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
    DTABLE_DATA_ENTRY        (MULTI_PATBLT_ORDER, 3, UNSIGNED_FIELD, BackColor),
    DTABLE_DATA_ENTRY        (MULTI_PATBLT_ORDER, 3, UNSIGNED_FIELD, ForeColor),
    DTABLE_FIXED_ENTRY       (MULTI_PATBLT_ORDER, 1, SIGNED_FIELD,   BrushOrgX),
    DTABLE_FIXED_ENTRY       (MULTI_PATBLT_ORDER, 1, SIGNED_FIELD,   BrushOrgY),
    DTABLE_FIXED_ENTRY       (MULTI_PATBLT_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
    DTABLE_FIXED_ENTRY       (MULTI_PATBLT_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
    DTABLE_DATA_ENTRY        (MULTI_PATBLT_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
    DTABLE_FIXED_ENTRY       (MULTI_PATBLT_ORDER, 1, UNSIGNED_FIELD, nDeltaEntries),
    DTABLE_LONG_VARIABLE_ENTRY(MULTI_PATBLT_ORDER, 1, UNSIGNED_FIELD, codedDeltaList, Deltas)
};

const OD_ORDER_FIELD_INFO odMultiScrBltFields[] =
{
    DTABLE_FIXED_COORDS_ENTRY(MULTI_SCRBLT_ORDER, 2, SIGNED_FIELD,   nLeftRect),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_SCRBLT_ORDER, 2, SIGNED_FIELD,   nTopRect),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_SCRBLT_ORDER, 2, SIGNED_FIELD,   nWidth),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_SCRBLT_ORDER, 2, SIGNED_FIELD,   nHeight),
    DTABLE_FIXED_ENTRY       (MULTI_SCRBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_SCRBLT_ORDER, 2, SIGNED_FIELD,   nXSrc),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_SCRBLT_ORDER, 2, SIGNED_FIELD,   nYSrc),
    DTABLE_FIXED_ENTRY       (MULTI_SCRBLT_ORDER, 1, UNSIGNED_FIELD, nDeltaEntries),
    DTABLE_LONG_VARIABLE_ENTRY(MULTI_SCRBLT_ORDER, 1, UNSIGNED_FIELD, codedDeltaList, Deltas)
};

const OD_ORDER_FIELD_INFO odMultiOpaqueRectFields[] =
{
    DTABLE_FIXED_COORDS_ENTRY(MULTI_OPAQUERECT_ORDER, 2, SIGNED_FIELD,   nLeftRect),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_OPAQUERECT_ORDER, 2, SIGNED_FIELD,   nTopRect),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_OPAQUERECT_ORDER, 2, SIGNED_FIELD,   nWidth),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_OPAQUERECT_ORDER, 2, SIGNED_FIELD,   nHeight),
    DTABLE_DATA_ENTRY        (MULTI_OPAQUERECT_ORDER, 1, UNSIGNED_FIELD, Color.u.rgb.red),
    DTABLE_DATA_ENTRY        (MULTI_OPAQUERECT_ORDER, 1, UNSIGNED_FIELD, Color.u.rgb.green),
    DTABLE_DATA_ENTRY        (MULTI_OPAQUERECT_ORDER, 1, UNSIGNED_FIELD, Color.u.rgb.blue),
    DTABLE_FIXED_ENTRY       (MULTI_OPAQUERECT_ORDER, 1, UNSIGNED_FIELD, nDeltaEntries),
    DTABLE_LONG_VARIABLE_ENTRY(MULTI_OPAQUERECT_ORDER, 1, UNSIGNED_FIELD, codedDeltaList, Deltas)
};

const OD_ORDER_FIELD_INFO odPolygonSCFields[] =
{
    DTABLE_FIXED_COORDS_ENTRY(POLYGON_SC_ORDER, 2, SIGNED_FIELD,   XStart),
    DTABLE_FIXED_COORDS_ENTRY(POLYGON_SC_ORDER, 2, SIGNED_FIELD,   YStart),
    DTABLE_FIXED_ENTRY       (POLYGON_SC_ORDER, 1, UNSIGNED_FIELD, ROP2),
    DTABLE_FIXED_ENTRY       (POLYGON_SC_ORDER, 1, UNSIGNED_FIELD, FillMode),
    DTABLE_DATA_ENTRY        (POLYGON_SC_ORDER, 3, UNSIGNED_FIELD, BrushColor),   
    DTABLE_FIXED_ENTRY       (POLYGON_SC_ORDER, 1, UNSIGNED_FIELD, NumDeltaEntries),
    DTABLE_VARIABLE_ENTRY    (POLYGON_SC_ORDER, 1, UNSIGNED_FIELD, CodedDeltaList, Deltas)
};

const OD_ORDER_FIELD_INFO odPolygonCBFields[] =
{
    DTABLE_FIXED_COORDS_ENTRY(POLYGON_CB_ORDER, 2, SIGNED_FIELD,   XStart),
    DTABLE_FIXED_COORDS_ENTRY(POLYGON_CB_ORDER, 2, SIGNED_FIELD,   YStart),
    DTABLE_FIXED_ENTRY       (POLYGON_CB_ORDER, 1, UNSIGNED_FIELD, ROP2),
    DTABLE_FIXED_ENTRY       (POLYGON_CB_ORDER, 1, UNSIGNED_FIELD, FillMode),
    DTABLE_DATA_ENTRY        (POLYGON_CB_ORDER, 3, UNSIGNED_FIELD, BackColor),
    DTABLE_DATA_ENTRY        (POLYGON_CB_ORDER, 3, UNSIGNED_FIELD, ForeColor),
    DTABLE_FIXED_ENTRY       (POLYGON_CB_ORDER, 1, SIGNED_FIELD,   BrushOrgX),
    DTABLE_FIXED_ENTRY       (POLYGON_CB_ORDER, 1, SIGNED_FIELD,   BrushOrgY),
    DTABLE_FIXED_ENTRY       (POLYGON_CB_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
    DTABLE_FIXED_ENTRY       (POLYGON_CB_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
    DTABLE_DATA_ENTRY        (POLYGON_CB_ORDER, 7, UNSIGNED_FIELD, BrushExtra),    
    DTABLE_FIXED_ENTRY       (POLYGON_CB_ORDER, 1, UNSIGNED_FIELD, NumDeltaEntries),
    DTABLE_VARIABLE_ENTRY    (POLYGON_CB_ORDER, 1, UNSIGNED_FIELD, CodedDeltaList, Deltas)
};

const OD_ORDER_FIELD_INFO odPolyLineFields[] =
{
    DTABLE_FIXED_COORDS_ENTRY(POLYLINE_ORDER, 2, SIGNED_FIELD,   XStart),
    DTABLE_FIXED_COORDS_ENTRY(POLYLINE_ORDER, 2, SIGNED_FIELD,   YStart),
    DTABLE_FIXED_ENTRY       (POLYLINE_ORDER, 1, UNSIGNED_FIELD, ROP2),
    DTABLE_FIXED_ENTRY       (POLYLINE_ORDER, 2, UNSIGNED_FIELD, BrushCacheEntry),
    DTABLE_DATA_ENTRY        (POLYLINE_ORDER, 3, UNSIGNED_FIELD, PenColor),
    DTABLE_FIXED_ENTRY       (POLYLINE_ORDER, 1, UNSIGNED_FIELD, NumDeltaEntries),
    DTABLE_VARIABLE_ENTRY    (POLYLINE_ORDER, 1, UNSIGNED_FIELD, CodedDeltaList, Deltas)
};

const OD_ORDER_FIELD_INFO odEllipseSCFields[] =
{
    DTABLE_FIXED_COORDS_ENTRY(ELLIPSE_SC_ORDER, 2, SIGNED_FIELD,   LeftRect),
    DTABLE_FIXED_COORDS_ENTRY(ELLIPSE_SC_ORDER, 2, SIGNED_FIELD,   TopRect),
    DTABLE_FIXED_COORDS_ENTRY(ELLIPSE_SC_ORDER, 2, SIGNED_FIELD,   RightRect),
    DTABLE_FIXED_COORDS_ENTRY(ELLIPSE_SC_ORDER, 2, SIGNED_FIELD,   BottomRect),
    DTABLE_FIXED_ENTRY       (ELLIPSE_SC_ORDER, 1, UNSIGNED_FIELD, ROP2),
    DTABLE_FIXED_ENTRY       (ELLIPSE_SC_ORDER, 1, UNSIGNED_FIELD, FillMode),
    DTABLE_DATA_ENTRY        (ELLIPSE_SC_ORDER, 3, UNSIGNED_FIELD, Color)   
};

const OD_ORDER_FIELD_INFO odEllipseCBFields[] =
{
    DTABLE_FIXED_COORDS_ENTRY(ELLIPSE_CB_ORDER, 2, SIGNED_FIELD,   LeftRect),
    DTABLE_FIXED_COORDS_ENTRY(ELLIPSE_CB_ORDER, 2, SIGNED_FIELD,   TopRect),
    DTABLE_FIXED_COORDS_ENTRY(ELLIPSE_CB_ORDER, 2, SIGNED_FIELD,   RightRect),
    DTABLE_FIXED_COORDS_ENTRY(ELLIPSE_CB_ORDER, 2, SIGNED_FIELD,   BottomRect),
    DTABLE_FIXED_ENTRY       (ELLIPSE_CB_ORDER, 1, UNSIGNED_FIELD, ROP2),
    DTABLE_FIXED_ENTRY       (ELLIPSE_CB_ORDER, 1, UNSIGNED_FIELD, FillMode),
    DTABLE_DATA_ENTRY        (ELLIPSE_CB_ORDER, 3, UNSIGNED_FIELD, BackColor),
    DTABLE_DATA_ENTRY        (ELLIPSE_CB_ORDER, 3, UNSIGNED_FIELD, ForeColor),
    DTABLE_FIXED_ENTRY       (ELLIPSE_CB_ORDER, 1, SIGNED_FIELD,   BrushOrgX),
    DTABLE_FIXED_ENTRY       (ELLIPSE_CB_ORDER, 1, SIGNED_FIELD,   BrushOrgY),
    DTABLE_FIXED_ENTRY       (ELLIPSE_CB_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
    DTABLE_FIXED_ENTRY       (ELLIPSE_CB_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
    DTABLE_DATA_ENTRY        (ELLIPSE_CB_ORDER, 7, UNSIGNED_FIELD, BrushExtra)    
};

// Fast-path decode function used.
#if 0
const OD_ORDER_FIELD_INFO odFastIndexFields[] =
{
    DTABLE_DATA_ENTRY        (FAST_INDEX_ORDER, 1, UNSIGNED_FIELD, cacheId),
    DTABLE_DATA_ENTRY        (FAST_INDEX_ORDER, 2, UNSIGNED_FIELD, fDrawing),
    DTABLE_DATA_ENTRY        (FAST_INDEX_ORDER, 3, UNSIGNED_FIELD, BackColor),
    DTABLE_DATA_ENTRY        (FAST_INDEX_ORDER, 3, UNSIGNED_FIELD, ForeColor),
    DTABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   BkLeft),
    DTABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   BkTop),
    DTABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   BkRight),
    DTABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   BkBottom),
    DTABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   OpLeft),
    DTABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   OpTop),
    DTABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   OpRight),
    DTABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   OpBottom),
    DTABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   x),
    DTABLE_FIXED_COORDS_ENTRY(FAST_INDEX_ORDER, 2, SIGNED_FIELD,   y),
    DTABLE_VARIABLE_ENTRY    (FAST_INDEX_ORDER, 1, UNSIGNED_FIELD, variableBytes, arecs)
};
#endif

const OD_ORDER_FIELD_INFO odFastGlyphFields[] =
{
    DTABLE_DATA_ENTRY        (FAST_GLYPH_ORDER, 1, UNSIGNED_FIELD, cacheId),
    DTABLE_DATA_ENTRY        (FAST_GLYPH_ORDER, 2, UNSIGNED_FIELD, fDrawing),
    DTABLE_DATA_ENTRY        (FAST_GLYPH_ORDER, 3, UNSIGNED_FIELD, BackColor),
    DTABLE_DATA_ENTRY        (FAST_GLYPH_ORDER, 3, UNSIGNED_FIELD, ForeColor),
    DTABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   BkLeft),
    DTABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   BkTop),
    DTABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   BkRight),
    DTABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   BkBottom),
    DTABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   OpLeft),
    DTABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   OpTop),
    DTABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   OpRight),
    DTABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   OpBottom),
    DTABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   x),
    DTABLE_FIXED_COORDS_ENTRY(FAST_GLYPH_ORDER, 2, SIGNED_FIELD,   y),
    DTABLE_VARIABLE_ENTRY    (FAST_GLYPH_ORDER, 1, UNSIGNED_FIELD, variableBytes, glyphData)
};

const OD_ORDER_FIELD_INFO odGlyphIndexFields[] =
{
    DTABLE_DATA_ENTRY       (INDEX_ORDER, 1, UNSIGNED_FIELD, cacheId),
    DTABLE_DATA_ENTRY       (INDEX_ORDER, 1, UNSIGNED_FIELD, flAccel),
    DTABLE_DATA_ENTRY       (INDEX_ORDER, 1, UNSIGNED_FIELD, ulCharInc),
    DTABLE_DATA_ENTRY       (INDEX_ORDER, 1, UNSIGNED_FIELD, fOpRedundant),
    DTABLE_DATA_ENTRY       (INDEX_ORDER, 3, UNSIGNED_FIELD, BackColor),
    DTABLE_DATA_ENTRY       (INDEX_ORDER, 3, UNSIGNED_FIELD, ForeColor),
    DTABLE_FIXED_ENTRY      (INDEX_ORDER, 2, SIGNED_FIELD,   BkLeft),
    DTABLE_FIXED_ENTRY      (INDEX_ORDER, 2, SIGNED_FIELD,   BkTop),
    DTABLE_FIXED_ENTRY      (INDEX_ORDER, 2, SIGNED_FIELD,   BkRight),
    DTABLE_FIXED_ENTRY      (INDEX_ORDER, 2, SIGNED_FIELD,   BkBottom),
    DTABLE_FIXED_ENTRY      (INDEX_ORDER, 2, SIGNED_FIELD,   OpLeft),
    DTABLE_FIXED_ENTRY      (INDEX_ORDER, 2, SIGNED_FIELD,   OpTop),
    DTABLE_FIXED_ENTRY      (INDEX_ORDER, 2, SIGNED_FIELD,   OpRight),
    DTABLE_FIXED_ENTRY      (INDEX_ORDER, 2, SIGNED_FIELD,   OpBottom),
    DTABLE_FIXED_ENTRY      (INDEX_ORDER, 1, SIGNED_FIELD,   BrushOrgX),
    DTABLE_FIXED_ENTRY      (INDEX_ORDER, 1, SIGNED_FIELD,   BrushOrgY),
    DTABLE_FIXED_ENTRY      (INDEX_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
    DTABLE_FIXED_ENTRY      (INDEX_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
    DTABLE_DATA_ENTRY       (INDEX_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
    DTABLE_FIXED_ENTRY      (INDEX_ORDER, 2, SIGNED_FIELD,   x),
    DTABLE_FIXED_ENTRY      (INDEX_ORDER, 2, SIGNED_FIELD,   y),
    DTABLE_VARIABLE_ENTRY   (INDEX_ORDER, 1,  UNSIGNED_FIELD,
                                              variableBytes, arecs)
};

#ifdef DRAW_NINEGRID
const OD_ORDER_FIELD_INFO odDrawNineGridFields[] =
{
    DTABLE_FIXED_COORDS_ENTRY(DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcLeft),
    DTABLE_FIXED_COORDS_ENTRY(DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcTop),
    DTABLE_FIXED_COORDS_ENTRY(DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcRight),
    DTABLE_FIXED_COORDS_ENTRY(DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcBottom),
    DTABLE_FIXED_ENTRY       (DRAWNINEGRID_ORDER, 2, UNSIGNED_FIELD, bitmapId)
};

const OD_ORDER_FIELD_INFO odMultiDrawNineGridFields[] =
{
    DTABLE_FIXED_COORDS_ENTRY(MULTI_DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcLeft),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcTop),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcRight),
    DTABLE_FIXED_COORDS_ENTRY(MULTI_DRAWNINEGRID_ORDER, 2, SIGNED_FIELD,   srcBottom),
    DTABLE_FIXED_ENTRY       (MULTI_DRAWNINEGRID_ORDER, 2, UNSIGNED_FIELD, bitmapId),    
    DTABLE_FIXED_ENTRY       (MULTI_DRAWNINEGRID_ORDER, 1, UNSIGNED_FIELD, nDeltaEntries),
    DTABLE_LONG_VARIABLE_ENTRY(MULTI_DRAWNINEGRID_ORDER, 1, UNSIGNED_FIELD, codedDeltaList, Deltas)
};
#endif

// Order attributes used for decoding, organized to optimize cache line
// usage. The fourth and fifth fields of each row are the fast-path decode
// and order handler functions, respectively. If a fast-path decode function
// is used, neither a decoding table nor a handler function is needed,
// since fast-path decode functions also perform the handling.


//
// This table contains just the static portions it is used to initialise
// the per instance table in the constructor below
//
OD_ORDER_TABLE odInitializeOrderTable[TS_MAX_ORDERS] = {
 { odDstBltFields,          NUM_DSTBLT_FIELDS,          NULL,          0, 0, NULL, NULL },
 { NULL, /* fastpath */     NUM_PATBLT_FIELDS,          NULL,          0, 0, NULL, NULL },
 { odScrBltFields,          NUM_SCRBLT_FIELDS,          NULL,          0, 0, NULL, NULL },
 { NULL,                    0,                          NULL,          0, 0, NULL, NULL },
 { NULL,                    0,                          NULL,          0, 0, NULL, NULL },
 { NULL,                    0,                          NULL,          0, 0, NULL, NULL },
 { NULL,                    0,                          NULL,          0, 0, NULL, NULL },
 #ifdef DRAW_NINEGRID
 { odDrawNineGridFields,    NUM_DRAWNINEGRID_FIELDS,    NULL,          0, 0, NULL, NULL },
 { odMultiDrawNineGridFields, NUM_MULTI_DRAWNINEGRID_FIELDS, NULL,     0, 0, NULL, NULL },
 #else
 { NULL,                    0,                          NULL,          0, 0, NULL, NULL },
 { NULL,                    0,                          NULL,          0, 0, NULL, NULL },
 #endif
 { NULL, /* fastpath */     NUM_LINETO_FIELDS,          NULL,          0, 0, NULL, NULL },
 { NULL, /* fastpath*/      NUM_OPAQUERECT_FIELDS,      NULL,          0, 0, NULL, NULL },
 { odSaveBitmapFields,      NUM_SAVEBITMAP_FIELDS,      NULL,          0, 0, NULL, NULL },
 { NULL,                    0,                          NULL,          0, 0, NULL, NULL },
 { NULL, /* fastpath */     NUM_MEMBLT_FIELDS,          NULL,          0, 0, NULL, NULL },
 { odMem3BltFields,         NUM_MEM3BLT_FIELDS,         NULL,          0, 0, NULL, NULL },
 { odMultiDstBltFields,     NUM_MULTIDSTBLT_FIELDS,     NULL,          0, 0, NULL, NULL },
 { odMultiPatBltFields,     NUM_MULTIPATBLT_FIELDS,     NULL,          0, 0, NULL, NULL },
 { odMultiScrBltFields,     NUM_MULTISCRBLT_FIELDS,     NULL,          0, 0, NULL, NULL },
 { odMultiOpaqueRectFields, NUM_MULTIOPAQUERECT_FIELDS, NULL,          0, 0, NULL, NULL },
 { NULL, /* fastpath*/      NUM_FAST_INDEX_FIELDS,      NULL,          0, 0, NULL, NULL },
 { odPolygonSCFields,       NUM_POLYGON_SC_FIELDS,      NULL,          0, 0, NULL, NULL },
 { odPolygonCBFields,       NUM_POLYGON_CB_FIELDS,      NULL,          0, 0, NULL, NULL },
 { odPolyLineFields,        NUM_POLYLINE_FIELDS,        NULL,          0, 0, NULL, NULL },
 { NULL,                    0,                          NULL,          0, 0, NULL, NULL },
 { odFastGlyphFields,       NUM_FAST_GLYPH_FIELDS,      NULL,          0, 0, NULL, NULL },
 { odEllipseSCFields,       NUM_ELLIPSE_SC_FIELDS,      NULL,          0, 0, NULL, NULL },
 { odEllipseCBFields,       NUM_ELLIPSE_CB_FIELDS,      NULL,          0, 0, NULL, NULL },
 { odGlyphIndexFields,      NUM_INDEX_FIELDS,           NULL,          0, 0, NULL, NULL },
};

#if 0
//
// This is the original just here for reference
//
{
 { odDstBltFields,          NUM_DSTBLT_FIELDS,          (PUH_ORDER)&_OD.lastDstblt,          NULL, ODHandleDstBlts },
 { NULL, /* fastpath */     NUM_PATBLT_FIELDS,          (PUH_ORDER)&_OD.lastPatblt,          ODDecodePatBlt, NULL },
 { odScrBltFields,          NUM_SCRBLT_FIELDS,          (PUH_ORDER)&_OD.lastScrblt,          NULL, ODHandleScrBlts },
 { NULL,                    0,                          NULL,                               NULL, NULL },
 { NULL,                    0,                          NULL,                               NULL, NULL },
 { NULL,                    0,                          NULL,                               NULL, NULL },
 { NULL,                    0,                          NULL,                               NULL, NULL },
 { NULL,                    0,                          NULL,                               NULL, NULL },
 { NULL,                    0,                          NULL,                               NULL, NULL },
 { NULL, /* fastpath */     NUM_LINETO_FIELDS,          (PUH_ORDER)&_OD.lastLineTo,          ODDecodeLineTo, NULL },
 { NULL, /* fastpath*/      NUM_OPAQUERECT_FIELDS,      (PUH_ORDER)&_OD.lastOpaqueRect,      ODDecodeOpaqueRect, NULL },
 { odSaveBitmapFields,      NUM_SAVEBITMAP_FIELDS,      (PUH_ORDER)&_OD.lastSaveBitmap,      NULL, ODHandleSaveBitmap },
 { NULL,                    0,                          NULL,                               NULL, NULL },
 { NULL, /* fastpath */     NUM_MEMBLT_FIELDS,          (PUH_ORDER)&_OD.lastMembltR2,        ODDecodeMemBlt, NULL },
 { odMem3BltFields,         NUM_MEM3BLT_FIELDS,         (PUH_ORDER)&_OD.lastMem3bltR2,       NULL, ODHandleMem3Blt },
 { odMultiDstBltFields,     NUM_MULTIDSTBLT_FIELDS,     (PUH_ORDER)&_OD.lastMultiDstBlt,     NULL, ODHandleDstBlts },
 { odMultiPatBltFields,     NUM_MULTIPATBLT_FIELDS,     (PUH_ORDER)&_OD.lastMultiPatBlt,     NULL, ODHandleMultiPatBlt },
 { odMultiScrBltFields,     NUM_MULTISCRBLT_FIELDS,     (PUH_ORDER)&_OD.lastMultiScrBlt,     NULL, ODHandleScrBlts },
 { odMultiOpaqueRectFields, NUM_MULTIOPAQUERECT_FIELDS, (PUH_ORDER)&_OD.lastMultiOpaqueRect, NULL, ODHandleMultiOpaqueRect },
 { NULL, /* fastpath*/      NUM_FAST_INDEX_FIELDS,      (PUH_ORDER)&_OD.lastFastIndex,       ODDecodeFastIndex, NULL },
 { odPolygonSCFields,       NUM_POLYGON_SC_FIELDS,      (PUH_ORDER)&_OD.lastPolygonSC,       NULL, ODHandlePolygonSC },
 { odPolygonCBFields,       NUM_POLYGON_CB_FIELDS,      (PUH_ORDER)&_OD.lastPolygonCB,       NULL, ODHandlePolygonCB },
 { odPolyLineFields,        NUM_POLYLINE_FIELDS,        (PUH_ORDER)&_OD.lastPolyLine,        NULL, ODHandlePolyLine },
 { NULL,                    0,                          NULL,                               NULL, NULL },
 { odFastGlyphFields,       NUM_FAST_GLYPH_FIELDS,      (PUH_ORDER)&_OD.lastFastGlyph,       NULL, ODHandleFastGlyph },
 { odEllipseSCFields,       NUM_ELLIPSE_SC_FIELDS,      (PUH_ORDER)&_OD.lastEllipseSC,       NULL, ODHandleEllipseSC },
 { odEllipseCBFields,       NUM_ELLIPSE_CB_FIELDS,      (PUH_ORDER)&_OD.lastEllipseCB,       NULL, ODHandleEllipseCB },
 { odGlyphIndexFields,      NUM_INDEX_FIELDS,           (PUH_ORDER)&_OD.lastIndex,           NULL, ODHandleGlyphIndex }
};
#endif

#ifdef DC_HICOLOR
#ifdef DC_DEBUG
// Names of all the order types
DCTCHAR orderNames[TS_MAX_ORDERS + TS_NUM_SECONDARY_ORDERS][64] = {
    _T("DSTBLT                 "),
    _T("PATBLT                 "),
    _T("SCRBLT                 "),
    _T("unused                 "),
    _T("unused                 "),
    _T("unused                 "),
    _T("unused                 "),
#ifdef DRAW_NINEGRID
    _T("DRAWNINEGRID           "),
    _T("MULTI_DRAWNINEGRID     "),
#else
    _T("unused                 "),
    _T("unused                 "),
#endif
    _T("LINETO                 "),
    _T("OPAQUERECT             "),
    _T("SAVEBITMAP             "),
    _T("unused                 "),
    _T("MEMBLT_R2              "),
    _T("MEM3BLT_R2             "),
    _T("MULTIDSTBLT            "),
    _T("MULTIPATBLT            "),
    _T("MULTISCRBLT            "),
    _T("MULTIOPAQUERECT        "),
    _T("FAST_INDEX             "),
    _T("POLYGON_SC (not wince) "),
    _T("POLYGON_CB (not wince) "),
    _T("POLYLINE               "),
    _T("unused                 "),
    _T("FAST_GLYPH             "),
    _T("ELLIPSE_SC (not wince) "),
    _T("ELLIPSE_CB (not wince) "),
    _T("INDEX (not expected)   "),
    _T("unused                 "),
    _T("unused                 "),
    _T("unused                 "),
    _T("unused                 "),

    _T("U/C CACHE BMP (legacy) "),
    _T("C COLOR TABLE (8bpp)   "),
    _T("COM CACHE BMP (legacy) "),
    _T("C GLYPH                "),
    _T("U/C CACHE BMP R2       "),
    _T("COM CACHE BMP R2       "),
    _T("unused                 "),
    _T("CACHE BRUSH            ")
};
#endif
#endif


COD::COD(CObjs* objs)
{
    _pClientObjects = objs;

    DC_MEMCPY( odOrderTable, odInitializeOrderTable, sizeof(odOrderTable));

    //
    // Initialize the per instance pointers of the ordertable
    //

    //{ odDstBltFields,          NUM_DSTBLT_FIELDS,          (PUH_ORDER)&_OD.lastDstblt,          NULL, ODHandleDstBlts },
    odOrderTable[0].LastOrder = (PUH_ORDER)&_OD.lastDstblt;
    odOrderTable[0].cbMaxOrderLen = sizeof(_OD.lastDstblt);
    odOrderTable[0].pFastDecode = NULL;
    odOrderTable[0].pHandler  = ODHandleDstBlts;

    //{ NULL, /* fastpath */     NUM_PATBLT_FIELDS,          (PUH_ORDER)&_OD.lastPatblt,          ODDecodePatBlt, NULL },
    odOrderTable[1].LastOrder = (PUH_ORDER)&_OD.lastPatblt;
    odOrderTable[1].cbMaxOrderLen = sizeof(_OD.lastPatblt);
    odOrderTable[1].pFastDecode = ODDecodePatBlt;
    odOrderTable[1].pHandler  = NULL;

    //{ odScrBltFields,          NUM_SCRBLT_FIELDS,          (PUH_ORDER)&_OD.lastScrblt,          NULL, ODHandleScrBlts },
    odOrderTable[2].LastOrder = (PUH_ORDER)&_OD.lastScrblt;
    odOrderTable[2].cbMaxOrderLen = sizeof(_OD.lastScrblt);
    odOrderTable[2].pFastDecode = NULL;
    odOrderTable[2].pHandler  = ODHandleScrBlts;

    //{ NULL,                    0,                          NULL,                               NULL, NULL },
    //{ NULL,                    0,                          NULL,                               NULL, NULL },
    //{ NULL,                    0,                          NULL,                               NULL, NULL },
    //{ NULL,                    0,                          NULL,                               NULL, NULL },
    
#ifdef DRAW_NINEGRID
    odOrderTable[7].LastOrder = (PUH_ORDER)&_OD.lastDrawNineGrid;
    odOrderTable[7].cbMaxOrderLen = sizeof(_OD.lastDrawNineGrid);
    odOrderTable[7].pFastDecode = NULL;
    odOrderTable[7].pHandler = ODHandleDrawNineGrid;

    odOrderTable[8].LastOrder = (PUH_ORDER)&_OD.lastMultiDrawNineGrid;
    odOrderTable[8].cbMaxOrderLen = sizeof(_OD.lastMultiDrawNineGrid);
    odOrderTable[8].pFastDecode = NULL;
    odOrderTable[8].pHandler = ODHandleMultiDrawNineGrid;
#else
    //{ NULL,                    0,                          NULL,                               NULL, NULL },
    //{ NULL,                    0,                          NULL,                               NULL, NULL },
#endif

    //{ NULL, /* fastpath */     NUM_LINETO_FIELDS,          (PUH_ORDER)&_OD.lastLineTo,          ODDecodeLineTo, NULL },
    odOrderTable[9].LastOrder = (PUH_ORDER)&_OD.lastLineTo;
    odOrderTable[9].cbMaxOrderLen = sizeof(_OD.lastLineTo);
    odOrderTable[9].pFastDecode = ODDecodeLineTo;
    odOrderTable[9].pHandler  = NULL;

    //{ NULL, /* fastpath*/      NUM_OPAQUERECT_FIELDS,      (PUH_ORDER)&_OD.lastOpaqueRect,      ODDecodeOpaqueRect, NULL },
    odOrderTable[10].LastOrder = (PUH_ORDER)&_OD.lastOpaqueRect;
    odOrderTable[10].cbMaxOrderLen = sizeof(_OD.lastOpaqueRect);
    odOrderTable[10].pFastDecode = ODDecodeOpaqueRect;
    odOrderTable[10].pHandler  = NULL;

    //{ odSaveBitmapFields,      NUM_SAVEBITMAP_FIELDS,      (PUH_ORDER)&_OD.lastSaveBitmap,      NULL, ODHandleSaveBitmap },
    odOrderTable[11].LastOrder = (PUH_ORDER)&_OD.lastSaveBitmap;
    odOrderTable[11].cbMaxOrderLen = sizeof(_OD.lastSaveBitmap);
    odOrderTable[11].pFastDecode = NULL;
    odOrderTable[11].pHandler  = ODHandleSaveBitmap;

    //{ NULL,                    0,                          NULL,                               NULL, NULL },


    // { NULL, /* fastpath */     NUM_MEMBLT_FIELDS,          (PUH_ORDER)&_OD.lastMembltR2,        ODDecodeMemBlt, NULL },
    odOrderTable[13].LastOrder = (PUH_ORDER)&_OD.lastMembltR2;
    odOrderTable[13].cbMaxOrderLen = sizeof(_OD.lastMembltR2);
    odOrderTable[13].pFastDecode = ODDecodeMemBlt;
    odOrderTable[13].pHandler  = NULL;

    //{ odMem3BltFields,         NUM_MEM3BLT_FIELDS,         (PUH_ORDER)&_OD.lastMem3bltR2,       NULL, ODHandleMem3Blt },
    odOrderTable[14].LastOrder = (PUH_ORDER)&_OD.lastMem3bltR2;
    odOrderTable[14].cbMaxOrderLen = sizeof(_OD.lastMem3bltR2);
    odOrderTable[14].pFastDecode = NULL;
    odOrderTable[14].pHandler  = ODHandleMem3Blt;

    //{ odMultiDstBltFields,     NUM_MULTIDSTBLT_FIELDS,     (PUH_ORDER)&_OD.lastMultiDstBlt,     NULL, ODHandleDstBlts },
    odOrderTable[15].LastOrder = (PUH_ORDER)&_OD.lastMultiDstBlt;
    odOrderTable[15].cbMaxOrderLen = sizeof(_OD.lastMultiDstBlt);
    odOrderTable[15].pFastDecode = NULL;
    odOrderTable[15].pHandler  = ODHandleDstBlts;

    //{ odMultiPatBltFields,     NUM_MULTIPATBLT_FIELDS,     (PUH_ORDER)&_OD.lastMultiPatBlt,     NULL, ODHandleMultiPatBlt },
    odOrderTable[16].LastOrder = (PUH_ORDER)&_OD.lastMultiPatBlt;
    odOrderTable[16].cbMaxOrderLen = sizeof(_OD.lastMultiPatBlt);
    odOrderTable[16].pFastDecode = NULL;
    odOrderTable[16].pHandler  = ODHandleMultiPatBlt;

    //{ odMultiScrBltFields,     NUM_MULTISCRBLT_FIELDS,     (PUH_ORDER)&_OD.lastMultiScrBlt,     NULL, ODHandleScrBlts },
    odOrderTable[17].LastOrder = (PUH_ORDER)&_OD.lastMultiScrBlt;
    odOrderTable[17].cbMaxOrderLen = sizeof(_OD.lastMultiScrBlt);
    odOrderTable[17].pFastDecode = NULL;
    odOrderTable[17].pHandler  = ODHandleScrBlts;

    //{ odMultiOpaqueRectFields, NUM_MULTIOPAQUERECT_FIELDS, (PUH_ORDER)&_OD.lastMultiOpaqueRect, NULL, ODHandleMultiOpaqueRect },
    odOrderTable[18].LastOrder = (PUH_ORDER)&_OD.lastMultiOpaqueRect;
    odOrderTable[18].cbMaxOrderLen = sizeof(_OD.lastMultiOpaqueRect);
    odOrderTable[18].pFastDecode = NULL;
    odOrderTable[18].pHandler  = ODHandleMultiOpaqueRect;

    //{ NULL, /* fastpath*/      NUM_FAST_INDEX_FIELDS,      (PUH_ORDER)&_OD.lastFastIndex,       ODDecodeFastIndex, NULL },
    odOrderTable[19].LastOrder = (PUH_ORDER)&_OD.lastFastIndex;
    odOrderTable[19].cbMaxOrderLen = sizeof(_OD.lastFastIndex);
    odOrderTable[19].pFastDecode = ODDecodeFastIndex;
    odOrderTable[19].pHandler  = NULL;

    //{ odPolygonSCFields,       NUM_POLYGON_SC_FIELDS,      (PUH_ORDER)&_OD.lastPolygonSC,       NULL, ODHandlePolygonSC },
    odOrderTable[20].LastOrder = (PUH_ORDER)&_OD.lastPolygonSC;
    odOrderTable[20].cbMaxOrderLen = sizeof(_OD.lastPolygonSC);
    odOrderTable[20].pFastDecode = NULL;
    odOrderTable[20].pHandler  = ODHandlePolygonSC;

    //{ odPolygonCBFields,       NUM_POLYGON_CB_FIELDS,      (PUH_ORDER)&_OD.lastPolygonCB,       NULL, ODHandlePolygonCB },
    odOrderTable[21].LastOrder = (PUH_ORDER)&_OD.lastPolygonCB;
    odOrderTable[21].cbMaxOrderLen = sizeof(_OD.lastPolygonCB);
    odOrderTable[21].pFastDecode = NULL;
    odOrderTable[21].pHandler  = ODHandlePolygonCB;

    //{ odPolyLineFields,        NUM_POLYLINE_FIELDS,        (PUH_ORDER)&_OD.lastPolyLine,        NULL, ODHandlePolyLine },
    odOrderTable[22].LastOrder = (PUH_ORDER)&_OD.lastPolyLine;
    odOrderTable[22].cbMaxOrderLen = sizeof(_OD.lastPolyLine);
    odOrderTable[22].pFastDecode = NULL;
    odOrderTable[22].pHandler  = ODHandlePolyLine;

    //{ NULL,                    0,                          NULL,                               NULL, NULL },

    //{ odFastGlyphFields,       NUM_FAST_GLYPH_FIELDS,      (PUH_ORDER)&_OD.lastFastGlyph,       NULL, ODHandleFastGlyph },
    odOrderTable[24].LastOrder = (PUH_ORDER)&_OD.lastFastGlyph;
    odOrderTable[24].cbMaxOrderLen = sizeof(_OD.lastFastGlyph);
    odOrderTable[24].pFastDecode = NULL;
    odOrderTable[24].pHandler  = ODHandleFastGlyph;

    //{ odEllipseSCFields,       NUM_ELLIPSE_SC_FIELDS,      (PUH_ORDER)&_OD.lastEllipseSC,       NULL, ODHandleEllipseSC },
    odOrderTable[25].LastOrder = (PUH_ORDER)&_OD.lastEllipseSC;
    odOrderTable[25].cbMaxOrderLen = sizeof(_OD.lastEllipseSC);
    odOrderTable[25].pFastDecode = NULL;
    odOrderTable[25].pHandler  = ODHandleEllipseSC;

    //{ odEllipseCBFields,       NUM_ELLIPSE_CB_FIELDS,      (PUH_ORDER)&_OD.lastEllipseCB,       NULL, ODHandleEllipseCB },
    odOrderTable[26].LastOrder = (PUH_ORDER)&_OD.lastEllipseCB;
    odOrderTable[26].cbMaxOrderLen = sizeof(_OD.lastEllipseCB);
    odOrderTable[26].pFastDecode = NULL;
    odOrderTable[26].pHandler  = ODHandleEllipseCB;

    //{ odGlyphIndexFields,      NUM_INDEX_FIELDS,           (PUH_ORDER)&_OD.lastIndex,           NULL, ODHandleGlyphIndex }
    odOrderTable[27].LastOrder = (PUH_ORDER)&_OD.lastIndex;
    odOrderTable[27].cbMaxOrderLen = sizeof(_OD.lastIndex);
    odOrderTable[27].pFastDecode = NULL;
    odOrderTable[27].pHandler  = ODHandleGlyphIndex;
}

COD::~COD()
{
}


/****************************************************************************/
/* Name:      OD_Init                                                       */
/*                                                                          */
/* Purpose:   Initializes the Order Decoder                                 */
/****************************************************************************/
DCVOID DCAPI COD::OD_Init(DCVOID)
{
    DC_BEGIN_FN("OD_Init");

    _pOp = _pClientObjects->_pOPObject;
    _pUh = _pClientObjects->_pUHObject;
    _pCc = _pClientObjects->_pCcObject;
    _pUi = _pClientObjects->_pUiObject;
    _pCd = _pClientObjects->_pCdObject;

    memset(&_OD, 0, sizeof(_OD));
    TRC_NRM((TB, _T("Initialized")));

    DC_END_FN();
}


/****************************************************************************/
/* Name:      OD_Term                                                       */
/*                                                                          */
/* Purpose:   Terminates the Order Decoder                                  */
/****************************************************************************/
DCVOID DCAPI COD::OD_Term(DCVOID)
{
    DC_BEGIN_FN("OD_Term");

    TRC_NRM((TB, _T("Terminating")));

    DC_END_FN();
}


/****************************************************************************/
/* Name:      OD_Enable                                                     */
/*                                                                          */
/* Purpose:   Called to enable _OD.                                          */
/****************************************************************************/
void DCAPI COD::OD_Enable(void)
{
    DC_BEGIN_FN("OD_Enable");

    // Reset the OD data.
    _OD.lastOrderType = TS_ENC_PATBLT_ORDER;
    _OD.pLastOrder = odOrderTable[_OD.lastOrderType].LastOrder;

    // Set all prev order buffers buffers to null, then set the order type
    // for each one, which is used by UHReplayGDIOrders().
#define RESET_ORDER(field, ord)                                 \
{                                                               \
    memset(&_OD.field, 0, sizeof(_OD.field));                     \
    ((PATBLT_ORDER*)(((PUH_ORDER)_OD.field)->orderData))->type = DCLO16(ord);\
}

    RESET_ORDER(lastDstblt,          TS_ENC_DSTBLT_ORDER);
    RESET_ORDER(lastPatblt,          TS_ENC_PATBLT_ORDER);
    RESET_ORDER(lastScrblt,          TS_ENC_SCRBLT_ORDER);
    RESET_ORDER(lastLineTo,          TS_ENC_LINETO_ORDER);
    RESET_ORDER(lastSaveBitmap,      TS_ENC_SAVEBITMAP_ORDER);
    RESET_ORDER(lastMembltR2,        TS_ENC_MEMBLT_R2_ORDER);
    RESET_ORDER(lastMem3bltR2,       TS_ENC_MEM3BLT_R2_ORDER);
    RESET_ORDER(lastOpaqueRect,      TS_ENC_OPAQUERECT_ORDER);
    RESET_ORDER(lastMultiDstBlt,     TS_ENC_MULTIDSTBLT_ORDER);
    RESET_ORDER(lastMultiPatBlt,     TS_ENC_MULTIPATBLT_ORDER);
    RESET_ORDER(lastMultiScrBlt,     TS_ENC_MULTISCRBLT_ORDER);
    RESET_ORDER(lastMultiOpaqueRect, TS_ENC_MULTIOPAQUERECT_ORDER);
    RESET_ORDER(lastFastIndex,       TS_ENC_FAST_INDEX_ORDER);
    RESET_ORDER(lastPolygonSC,       TS_ENC_POLYGON_SC_ORDER);
    RESET_ORDER(lastPolygonCB,       TS_ENC_POLYGON_CB_ORDER);
    RESET_ORDER(lastPolyLine,        TS_ENC_POLYLINE_ORDER);
    RESET_ORDER(lastFastGlyph,       TS_ENC_FAST_GLYPH_ORDER);
    RESET_ORDER(lastEllipseSC,       TS_ENC_ELLIPSE_SC_ORDER);
    RESET_ORDER(lastEllipseCB,       TS_ENC_ELLIPSE_CB_ORDER);
    RESET_ORDER(lastIndex,           TS_ENC_INDEX_ORDER);
#ifdef DRAW_NINEGRID
    RESET_ORDER(lastDrawNineGrid,    TS_ENC_DRAWNINEGRID_ORDER);
    RESET_ORDER(lastMultiDrawNineGrid, TS_ENC_DRAWNINEGRID_ORDER);
#endif

    // Reset the bounds rectangle.
    memset(&_OD.lastBounds, 0, sizeof(_OD.lastBounds));

    for(int i = 0; i < TS_MAX_ORDERS; i++) {
        odOrderTable[_OD.lastOrderType].cbVariableDataLen = 0;
    }

#ifdef DC_HICOLOR
//#ifdef DC_DEBUG
    /************************************************************************/
    /* Reset the list of order types we've seen                             */
    /************************************************************************/
    TRC_ALT((TB, _T("Clear order types received list")));
    memset(_OD.orderHit, 0, sizeof(_OD.orderHit));
//#endif
#endif

    DC_END_FN();
}


/****************************************************************************/
/* Name:      OD_Disable                                                    */
/*                                                                          */
/* Purpose:   Disables _OD.                                                  */
/****************************************************************************/
void DCAPI COD::OD_Disable(void)
{
    DC_BEGIN_FN("OD_Disable");

#ifdef DC_HICOLOR
#ifdef DC_DEBUG
    int i;
#endif
#endif

#ifdef DC_HICOLOR
#ifdef DC_DEBUG
    /************************************************************************/
    /* Dump the list of order types we've seen                              */
    /************************************************************************/
    TRC_DBG((TB, _T("Received order types:")));
    for (i = 0; i < (TS_MAX_ORDERS + TS_NUM_SECONDARY_ORDERS); i++) {
        TRC_DBG((TB, _T("- %02d %s %s"), i, orderNames[i], _OD.orderHit[i] ?
                _T("YES") : _T("NO") ));
    }
#endif
#endif

    TRC_NRM((TB, _T("Disabling OD")));

    DC_END_FN();
}


// Unneeded because we can fast-path single-field deltas below if we don't
// have variable-length coord fields.
#ifdef USE_VARIABLE_COORDS
/****************************************************************************/
/* Given two arrays, a source array and an array of deltas, add each delta  */
/* to the corresponding element in the source array, storing the results in */
/* the source array.                                                        */
/*                                                                          */
/*   srcArray     - The array of source values                              */
/*   srcArrayType - The type of the array of source values                  */
/*   deltaArray   - The array of deltas                                     */
/*   numElements  - The number of elements in the arrays                    */
/****************************************************************************/
#define COPY_DELTA_ARRAY(srcArray, srcArrayType, deltaArray, numElements)  \
{                                                            \
    DCUINT index;                                            \
    for (index = 0; index < (numElements); index++)          \
    {                                                        \
        (srcArray)[index] = (srcArrayType)                   \
           ((srcArray)[index] + (deltaArray)[index]);        \
    }                                                        \
}

/****************************************************************************/
/* Name:      ODCopyFromDeltaCoords                                         */
/*                                                                          */
/* Purpose:   Adjusts an array of coordinate values by the amounts          */
/*            specified in an array of coordinate deltas.                   */
/*                                                                          */
/* Params:    IN/OUT:  ppSrc - pointer to pointer to source data.           */
/*                     Updated by this function to after the processed      */
/*                     delta coordinate data.                               */
/*            IN/OUT:  pDst - pointer to coordinates to adjust.             */
/*            IN:      destFieldLength - size of elements in the dest array.*/
/*            IN:      signedValue - TRUE if the elements are signed.       */
/*            IN:      number of elements in the arrays.                    */
/****************************************************************************/
_inline DCVOID DCINTERNAL COD::ODCopyFromDeltaCoords( PPDCINT8  ppSrc,
                                                 PDCVOID   pDst,
                                                 DCUINT    dstFieldLength,
                                                 DCBOOL    signedValue,
                                                 DCUINT    numElements )
{
    PDCINT8 pSrc;

    DC_BEGIN_FN("ODCopyFromDeltaCoords");

    pSrc = *ppSrc;

    switch (dstFieldLength)
    {
        case 1:
            if (signedValue) {
                PDCINT8 pDst8Signed = (PDCINT8)pDst;

                COPY_DELTA_ARRAY( pDst8Signed,
                                  DCINT8,
                                  pSrc,
                                  numElements );
            }
            else {
                PDCUINT8 pDst8Unsigned = (PDCUINT8)pDst;

                COPY_DELTA_ARRAY( pDst8Unsigned,
                                  DCUINT8,
                                  pSrc,
                                  numElements );
            }
            break;

        case 2:
            if (signedValue) {
                PDCINT16 pDst16Signed = (PDCINT16)pDst;

                COPY_DELTA_ARRAY( pDst16Signed,
                                  DCINT16,
                                  pSrc,
                                  numElements );
            }
            else {
                PDCUINT16 pDst16Unsigned = (PDCUINT16)pDst;

                COPY_DELTA_ARRAY( pDst16Unsigned,
                                  DCUINT16,
                                  pSrc,
                                  numElements );
            }
            break;

        case 4:
            if (signedValue) {
                PDCINT32 pDst32Signed = (PDCINT32)pDst;

                COPY_DELTA_ARRAY( pDst32Signed,
                                  DCINT32,
                                  pSrc,
                                  numElements );
            }
            else
            {
                PDCUINT32 pDst32Unsigned = (PDCUINT32)pDst;

                COPY_DELTA_ARRAY( pDst32Unsigned,
                                  DCUINT32,
                                  pSrc,
                                  numElements );
            }
            break;

        default:
            TRC_ERR((TB, _T("Bad destination field length %d"), dstFieldLength));
            break;
    }

    *ppSrc += numElements;

    DC_END_FN();
}
#endif  // USE_VARIABLE_COORDS


/****************************************************************************/
/* Name:      OD_DecodeOrder                                                */
/*                                                                          */
/* Purpose:   Decodes an encoded order.                                     */
/*                                                                          */
/* Params:    IN:  ppEncodedOrderData - pointer to a pointer to the encoded */
/*                 order data.                                              */
/*            OUT: pLengthDecoded - pointer to a variable that receives     */
/*                 the amount of encoded order data used to produce the     */
/*                 decoded order.                                           */
/****************************************************************************/
HRESULT DCAPI COD::OD_DecodeOrder(PPDCVOID ppEncodedOrderData,
    DCUINT uiEncodedDataLength, PUH_ORDER *ppOrder)
{
    HRESULT hr = E_FAIL;
    BYTE FAR *pControlFlags;
    BYTE FAR *pNextDataToCopy;
    BYTE FAR *pDataEnd;
    PUINT32_UA pEncodingFlags;
    unsigned numEncodingFlagBytes;
    unsigned cZeroEncodingFlagBytes;
    unsigned encodedFieldLength;
    unsigned unencodedFieldLength;
    unsigned numReps;
    unsigned i;
    BYTE FAR *pDest;
    BYTE FAR *pLastOrderEnd;
    PUH_ORDER rc = NULL;
    UINT32 fieldChangedBits;
    const OD_ORDER_FIELD_INFO FAR *pTableEntry;

    DC_BEGIN_FN("OD_DecodeOrder");

    *ppOrder = NULL;
     pDataEnd = (PBYTE)*ppEncodedOrderData + uiEncodedDataLength;

    CHECK_READ_ONE_BYTE(*ppEncodedOrderData, pDataEnd, hr, 
        (TB, _T("no data passed in")))

    // Control flags are always the first byte.    
    pControlFlags = (BYTE FAR *)(*ppEncodedOrderData);
   
    // Check that the order has standard encoding.
    TRC_ASSERT((*pControlFlags & TS_STANDARD),
            (TB, _T("Non-standard encoding: %u"), (unsigned)*pControlFlags));
    TRC_ASSERT(!(*pControlFlags & TS_SECONDARY),
            (TB, _T("Unencoded: %u"), (unsigned)*pControlFlags));

    // If type has changed, new type will be first byte in encoded order.
    // Get pointer to last order of this type. The encoding flags follow
    // this byte (if it is present).
    if (*pControlFlags & TS_TYPE_CHANGE) {       
        CHECK_READ_ONE_BYTE((pControlFlags + 1), pDataEnd, hr, 
            (TB, _T("no data passed in")))
        TRC_DBG((TB, _T("Change type from %d to %d"), _OD.lastOrderType,
                *(pControlFlags + 1)));
    
        if (*(pControlFlags + 1) >= TS_MAX_ORDERS) {
            TRC_ERR((TB, _T("Invalid order type %u"), *(pControlFlags + 1)));
            hr = E_TSC_CORE_DECODETYPE;
            DC_QUIT;
        }
        
        _OD.lastOrderType = *(pControlFlags + 1);
        if (TS_MAX_ORDERS < _OD.lastOrderType) {
            TRC_ABORT((TB, _T("invalid order type: %u"), _OD.lastOrderType));
            hr = E_TSC_CORE_DECODETYPE;
            DC_QUIT;
        }

        // SECURITY: use the cbMaxOrderLen to be sure this entry in the 
        // table is filled out
        if (0 == odOrderTable[_OD.lastOrderType].cbMaxOrderLen) {
            TRC_ABORT((TB, _T("invalid order type: %u"), _OD.lastOrderType));
            hr = E_TSC_CORE_DECODETYPE;
            DC_QUIT;
        }
        
        _OD.pLastOrder = odOrderTable[_OD.lastOrderType].LastOrder;
        pEncodingFlags = (PUINT32_UA)(pControlFlags + 2);
    }
    else {
        pEncodingFlags = (PUINT32_UA)(pControlFlags + 1);
    }
    TRC_DBG((TB, _T("Type %x"), _OD.lastOrderType));

#ifdef DC_HICOLOR
//#ifdef DC_DEBUG
    /************************************************************************/
    /* For high color testing, we want to confirm that we've received each  */
    /* of the order types                                                   */
    /************************************************************************/
    _OD.orderHit[_OD.lastOrderType] += 1;
//#endif
#endif

    // Work out how many bytes are used to store the encoding flags for
    // this order. There is a flag for each field in the order structure.
    // For historical reasons, add 1 to the real number of fields before
    // calculating. This means that the first byte of field flags can
    // only contain 7 field bits.
    numEncodingFlagBytes = (odOrderTable[_OD.lastOrderType].NumFields + 1 +
            7) / 8;
    TRC_DBG((TB, _T("numEncodingFlagBytes %d"), numEncodingFlagBytes));

    
    TRC_ASSERT((numEncodingFlagBytes <= 3),
        (TB, _T("Too many flag bytes (%d)"), numEncodingFlagBytes));

    // Find out how many zero bytes of encoding flags there are.
    cZeroEncodingFlagBytes = (*pControlFlags & TS_ZERO_FIELD_COUNT_MASK) >>
            TS_ZERO_FIELD_COUNT_SHIFT;
    if (cZeroEncodingFlagBytes > numEncodingFlagBytes) {
        TRC_ERR((TB, _T("Too many zero encoding flag bytes (%d)"), 
            cZeroEncodingFlagBytes));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }

    // Now we know how many bytes make up the flags we can get a pointer to
    // where we start decoding the order data from.
    pNextDataToCopy = (BYTE FAR *)pEncodingFlags + numEncodingFlagBytes -
            cZeroEncodingFlagBytes;

    // Now build up the order header.
    // If a bounding rectangle is included, copy it into the order header.
    if (*pControlFlags & TS_BOUNDS) {
        BYTE FAR *pFlags;

        // The encoding used is a byte of flags followed by a variable number
        // of 16-bit coordinate values and 8-bit delta coordinate values
        // (which may be interleaved).

        // If there are zero bounds deltas then we are done.
        if (!(*pControlFlags & TS_ZERO_BOUNDS_DELTAS)) {
            // The first byte of the encoding will contain the flags that
            // represent how the coordinates of the rectangle were encoded.
            pFlags = pNextDataToCopy;
            pNextDataToCopy++;

            CHECK_READ_ONE_BYTE(pFlags, pDataEnd, hr, 
                (TB, _T("No data to read flags")))

            // If the flags indicate that none of the coordinates have
            // changed then we are done
            if (*pFlags != 0) {
                // For each of the four coordinate values in the rectangle:
                // If the coordinate was encoded as an 8-bit delta then add
                // on the delta to the previous value. If the coordinate
                // was encoded as a 16-bit value then copy the value across.
                // Otherwise the coordinate was the same as the previous one
                // so leave it alone.
                if (*pFlags & TS_BOUND_DELTA_LEFT) {
                    CHECK_READ_ONE_BYTE(pNextDataToCopy, pDataEnd, hr, 
                        ( TB, _T("TS_BOUND_DELTA_LEFT; pData %u pEnd %u"),
                        pNextDataToCopy + 1, pDataEnd ))

                    _OD.lastBounds.left += (int)(*((char FAR *)
                            pNextDataToCopy));
                    pNextDataToCopy++;        
                }
                else if (*pFlags & TS_BOUND_LEFT) {
                    CHECK_READ_N_BYTES(pNextDataToCopy, pDataEnd, 
                        sizeof(UINT16), hr,
                        ( TB, _T("TS_BOUND_LEFT; pData %u pEnd %u"),
                        pNextDataToCopy, pDataEnd ));
                    _OD.lastBounds.left = DC_EXTRACT_INT16_UA(pNextDataToCopy);
                    pNextDataToCopy += sizeof(UINT16);           
                }

                if (*pFlags & TS_BOUND_DELTA_TOP) {
                    CHECK_READ_ONE_BYTE(pNextDataToCopy, pDataEnd, hr, 
                        ( TB, _T("TS_BOUND_DELTA_TOP; pData %u pEnd %u"),
                        pNextDataToCopy + 1, pDataEnd ));
                    
                    _OD.lastBounds.top += (int)(*((char FAR *)
                            pNextDataToCopy));
                    pNextDataToCopy++;
                }
                else if (*pFlags & TS_BOUND_TOP) {
                    CHECK_READ_N_BYTES(pNextDataToCopy, pDataEnd, 
                        sizeof(UINT16),hr, 
                        ( TB, _T("TS_BOUND_TOP; pData %u pEnd %u"),
                        pNextDataToCopy, pDataEnd ));
                    _OD.lastBounds.top = DC_EXTRACT_INT16_UA(pNextDataToCopy);
                    pNextDataToCopy += sizeof(UINT16);
                }

                if (*pFlags & TS_BOUND_DELTA_RIGHT) {
                    CHECK_READ_ONE_BYTE(pNextDataToCopy, pDataEnd, hr, 
                        ( TB, _T("TS_BOUND_DELTA_RIGHT; pData %u pEnd %u"),
                        pNextDataToCopy + 1, pDataEnd ));
                    
                    _OD.lastBounds.right += (int)(*((char FAR *)
                            pNextDataToCopy));
                    pNextDataToCopy++;
                }
                else if (*pFlags & TS_BOUND_RIGHT) {
                    CHECK_READ_N_BYTES(pNextDataToCopy, pDataEnd, 
                        sizeof(UINT16), hr,
                        ( TB, _T("TS_BOUND_RIGHT; pData %u pEnd %u"),
                        pNextDataToCopy, pDataEnd ));
                    _OD.lastBounds.right = DC_EXTRACT_INT16_UA(
                            pNextDataToCopy);
                    pNextDataToCopy += sizeof(UINT16);
                }

                if (*pFlags & TS_BOUND_DELTA_BOTTOM) {
                    CHECK_READ_ONE_BYTE(pNextDataToCopy, pDataEnd, hr, 
                        ( TB, _T("TS_BOUND_DELTA_BOTTOM; pData %u pEnd %u"),
                        pNextDataToCopy + 1, pDataEnd ));
                    
                    _OD.lastBounds.bottom += (int)(*((char FAR *)
                            pNextDataToCopy));
                    pNextDataToCopy++;
                }
                else if (*pFlags & TS_BOUND_BOTTOM) {
                    CHECK_READ_N_BYTES(pNextDataToCopy, pDataEnd, sizeof(UINT16),
                        hr, ( TB, _T("TS_BOUND_BOTTOM; pData %u pEnd %u"),
                        pNextDataToCopy, pDataEnd ));

                    _OD.lastBounds.bottom = DC_EXTRACT_INT16_UA(
                            pNextDataToCopy);
                    pNextDataToCopy += sizeof(UINT16);
                }
            }
        }

        // Copy the (possibly newly calculated) bounds to the order header.
        _OD.pLastOrder->dstRect = _OD.lastBounds;

        TRC_NRM((TB, _T("Decoded bounds  l %d t %d r %d b %d"),
                _OD.pLastOrder->dstRect.left, _OD.pLastOrder->dstRect.top,
                _OD.pLastOrder->dstRect.right, _OD.pLastOrder->dstRect.bottom));
    }

    // Locate the entry in the decoding table for this order type and
    // extract the encoded order flags from the encoded order.
    fieldChangedBits = 0;
    for (i = (numEncodingFlagBytes - cZeroEncodingFlagBytes); i > 0; i--) {
        fieldChangedBits <<= 8;
        fieldChangedBits |= (UINT32)((BYTE FAR *)pEncodingFlags)[i - 1];
    }

    // If there is a fast-path decode function, use it.
    // Fast-path decode functions also do the order handling once decoded.
    // They must set pOrder->dstRect if (ControlFlags & TS_BOUNDS) == 0.
    if (odOrderTable[_OD.lastOrderType].pFastDecode != NULL) {

        hr = callMemberFunction(*this, 
        odOrderTable[_OD.lastOrderType].pFastDecode)(*pControlFlags,
                &pNextDataToCopy, pDataEnd - pNextDataToCopy, fieldChangedBits);
        DC_QUIT_ON_FAIL(hr);
        goto PostFastPathDecode;
    }

    // Now decode the order:
    // while field changed bits are non-zero
    //   if rightmost bit is non-zero
    //       decode the corresponding changed field
    //   skip to next entry in decoding table
    //   shift field changed bits right one bit
    pTableEntry = odOrderTable[_OD.lastOrderType].pOrderTable;
    pLastOrderEnd = (BYTE FAR *)_OD.pLastOrder + 
        odOrderTable[_OD.lastOrderType].cbMaxOrderLen;
  
    TRC_ASSERT((pTableEntry != NULL),
            (TB,_T("Unsupported order type %d received!"), _OD.lastOrderType));
    while (fieldChangedBits != 0) {
        // If this field was encoded (ie changed since the last order)...
        if (fieldChangedBits & 0x1) {
            // Set up a pointer to the destination (unencoded) field.
            pDest = (BYTE FAR *)_OD.pLastOrder + pTableEntry->fieldPos +
                    UH_ORDER_HEADER_SIZE;

            // If the field type is OD_OFI_TYPE_DATA, we just copy the
            // number of bytes given by the encoded length in the table.
            if (pTableEntry->fieldType & OD_OFI_TYPE_DATA) {
                CHECK_READ_N_BYTES(pNextDataToCopy, pDataEnd, 
                    pTableEntry->fieldEncodedLen, hr, 
                    ( TB, _T("OD_OFI_TYPE_DATA; pData %u pEnd %u"),
                    pNextDataToCopy + pTableEntry->fieldEncodedLen, pDataEnd));

                CHECK_WRITE_N_BYTES(pDest, pLastOrderEnd, 
                    pTableEntry->fieldEncodedLen, hr,
                    (TB, _T("Decode past end of buffer")));

                memcpy(pDest, pNextDataToCopy, pTableEntry->fieldEncodedLen);
                
                pNextDataToCopy += pTableEntry->fieldEncodedLen;
                TRC_TST((TB, _T("Byte data field, len %d"), numReps));
            }
            else {
                // This is not a straightforward data copy. The length of
                // the source and destination data is given in the table in
                // the fieldEncodedLen and fieldUnencodedLen elements
                // respectively.
                encodedFieldLength   = pTableEntry->fieldEncodedLen;
                unencodedFieldLength = pTableEntry->fieldUnencodedLen;

                // If the order was encoded using delta coordinate mode and
                // this field is a coordinate then convert the coordinate from
                // the single byte sized delta to a value of the size given by
                // unencodedFieldLen...
                // Note that we've already handled the leading length field of
                // variable length fields above, so we don't have to worry
                // about fixed/variable issues here.
                if ((*pControlFlags & TS_DELTA_COORDINATES) &&
                        (pTableEntry->fieldType & OD_OFI_TYPE_COORDINATES)) {
                    // Since we are not using variable-length coord fields,
                    // we can fast-path with an assumption that the source is
                    // length 1. Also, all coord fields are currently
                    // signed and destination size is always 4, so we can drop
                    // more branches.
                    if (!(pTableEntry->fieldType & OD_OFI_TYPE_SIGNED)) {
                        TRC_ABORT((TB,_T("Someone added a non-signed COORD")
                            _T(" field - order type %u"), _OD.lastOrderType));
                        hr = E_TSC_CORE_LENGTH;
                        DC_QUIT;
                    }
                    if (pTableEntry->fieldUnencodedLen != 4) {
                        TRC_ABORT((TB,_T("Someone added a non-4-byte COORD")
                            _T(" field - order type %u"), _OD.lastOrderType));
                        hr = E_TSC_CORE_LENGTH;
                        DC_QUIT;
                    }

                    CHECK_READ_ONE_BYTE(pNextDataToCopy, pDataEnd, hr,( TB,
                            _T("Reading destination offset past data end")));
                    CHECK_WRITE_N_BYTES(pDest, pLastOrderEnd, sizeof(INT32), hr,
                        (TB, _T("Decode past end of buffer")));
                    *((INT32 FAR *)pDest) += *((char FAR *)pNextDataToCopy);
                    pNextDataToCopy++;

#ifdef USE_VARIABLE_COORDS
                    CHECK_READ_N_BYTES(pNextDataToCopy, pDataEnd, 
                        (numReps * sizeof(BYTE)), hr,
                        ( TB, _T("Bad offset into lastOrder")));
                    CHECK_WRITE_N_BYTES(pDest, pLastOrderEnd, 
                        pTableEntry->fieldUnencodedLen, hr,
                        (TB, _T("decode off end of buffer" )));
                        
                    ODCopyFromDeltaCoords((PPDCINT8)&pNextDataToCopy,
                            pDest, pTableEntry->fieldUnencodedLen,
                            pTableEntry->fieldType & OD_OFI_TYPE_SIGNED,
                            numReps);
#endif
                }
                else {
                    if (pTableEntry->fieldType & OD_OFI_TYPE_FIXED) {
                        CHECK_READ_N_BYTES(pNextDataToCopy, pDataEnd, 
                            pTableEntry->fieldEncodedLen, hr,
                            ( TB, _T("OD_OFI_TYPE_FIXED; pData %u pEnd %u"),
                            pNextDataToCopy + pTableEntry->fieldEncodedLen, 
                            pDataEnd));

                        CHECK_READ_N_BYTES(pDest, pLastOrderEnd, 
                            pTableEntry->fieldUnencodedLen, hr,
                            ( TB, _T("Bad offset into lastOrder")));
                        
                        // Copy the field with appropriate field size conversion.
                        hr = ODDecodeFieldSingle(&pNextDataToCopy, pDest,
                                pTableEntry->fieldEncodedLen,
                                pTableEntry->fieldUnencodedLen,
                                pTableEntry->fieldType & OD_OFI_TYPE_SIGNED);
                        DC_QUIT_ON_FAIL(hr);
                    }
                    else {
                        // We assume that variable entries are only bytes
                        // (dest size = 1).
                        if(pTableEntry->fieldUnencodedLen != 1 ||
                            pTableEntry->fieldEncodedLen != 1) {
                            TRC_ABORT((TB,_T("Somebody added a variable field with ")
                                _T("non-byte contents - order type %u"),
                                _OD.lastOrderType));
                            hr = E_TSC_CORE_LENGTH;
                            DC_QUIT;
                        }

                        // This is a variable length field - see if it's long or
                        // short.
                        if (!(pTableEntry->fieldType &
                                OD_OFI_TYPE_LONG_VARIABLE)) {

                            CHECK_READ_ONE_BYTE(pNextDataToCopy, pDataEnd, hr, 
                                ( TB,  _T("Reading numReps (BYTE)")));
                                
                            // This is a variable field. The next byte to be
                            // decoded contains the number of BYTES of encoded
                            // data (not elements), so divide by the encoded
                            // field size to get numReps.
                            numReps = *pNextDataToCopy;
                                    // (/ pTableEntry->fieldEncodedLen) - bytes only

                            // Step past the length field in the encoded order.
                            pNextDataToCopy++;
                        }
                        else {
                            CHECK_READ_N_BYTES(pNextDataToCopy, pDataEnd, 
                                sizeof(UINT16), hr, 
                                ( TB,  _T("Reading numReps (UINT16)")));
                           
                            // This is a long variable field. The next two
                            // bytes to be decoded contain the number of BYTES
                            // of encoded data (not elements), so divide by the
                            // encoded field size to get numReps.
                            numReps = *((PUINT16_UA)pNextDataToCopy);
                                    // (/ pTableEntry->fieldEncodedLen) - bytes only

                            // Step past the length field in the encoded order.
                            pNextDataToCopy += sizeof(UINT16);
                        }

                        TRC_TST((TB, _T("Var field: encoded size %d, unencoded ")
                                "size %d, reps %d", pTableEntry->fieldEncodedLen,
                                pTableEntry->fieldUnencodedLen, numReps));
                        // Cast from unsigned to UINT16 is safe since the numReps read above
                        // is no more than a UINT16
                        odOrderTable[_OD.lastOrderType].cbVariableDataLen = (UINT16)numReps;

                        // For a variable length field, the unencoded version
                        // contains a UINT32 for the length (in bytes) of the
                        // following variable data, followed by the actual
                        // data. Fill in the length field in the unencoded
                        // order.
                        *(PUINT32)pDest = numReps; // (* pTableEntry->fieldUnencodedLen)
                        pDest += sizeof(UINT32);

                        CHECK_READ_N_BYTES(pNextDataToCopy, pDataEnd, numReps, 
                            hr, ( TB, _T("Reading numReps past end of data")));
                        CHECK_WRITE_N_BYTES(pDest, pLastOrderEnd, numReps, hr,
                            ( TB, 
                            _T("Writing numReps bytes past end of last order")));

                        // We assume that variable entries are only bytes
                        // (dest size = 1), since no one is using anything longer.
                        memcpy(pDest, pNextDataToCopy, numReps);
                        pNextDataToCopy += numReps;
                    }
                }
            }
        }

        // Move on to the next field in the order structure...
        fieldChangedBits >>= 1;
        pTableEntry++;
    }

    // Pass to the order handler (non-fast-path). These functions must set
    // pOrder->dstRect to the bounding rect of the entire operation if
    // bBoundsSet is FALSE, and set the clip region appropriately.
    TRC_ASSERT((odOrderTable[_OD.lastOrderType].pHandler != NULL),
            (TB,_T("Fast-path decoder and order handler funcs both NULL (ord=%u)"),
            _OD.lastOrderType));
    hr = callMemberFunction(*this, odOrderTable[_OD.lastOrderType].pHandler)(
        _OD.pLastOrder, odOrderTable[_OD.lastOrderType].cbVariableDataLen,
        *pControlFlags & TS_BOUNDS);
    DC_QUIT_ON_FAIL(hr);

PostFastPathDecode:
    // Update the source pointer to the start of the next encoded order.
    TRC_ASSERT( (DCUINT)(pNextDataToCopy - (BYTE*)(*ppEncodedOrderData)) <= uiEncodedDataLength,
        (TB, _T("Decoded more data than available")));
    *ppEncodedOrderData = (PDCVOID)pNextDataToCopy;
    
    TRC_DBG((TB, _T("Return %p"), *ppEncodedOrderData));

    *ppOrder = _OD.pLastOrder;

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\odint.cpp ===
/****************************************************************************/
// odint.cpp
//
// Order Decoder internal functions.
//
// Copyright (c) 1997-2000 Microsoft Corp.
// Portions copyright (c) 1992-1997 Microsoft, PictureTel
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "aodint"
#include <atrcapi.h>
}
#define TSC_HR_FILEID TSC_HR_ODINT_CPP

#include "od.h"
#include "cc.h"
#include "bbar.h"

// WinCE does not define BS_HATCHED for their wingdi.h
#ifdef OS_WINCE
#define BS_HATCHED 2
#endif

#define OD_DECODE_CHECK_READ( p, type, pEnd, hr )   \
    CHECK_READ_N_BYTES(p, pEnd, sizeof(type), hr, \
    ( TB, _T("Read past data end")))

#define OD_DECODE_CHECK_READ_MULT( p, type, mult, pEnd, hr )    \
    CHECK_READ_N_BYTES(p, pEnd, (mult) * sizeof(type), hr, \
    ( TB, _T("Read past data end")))    

#define OD_DECODE_CHECK_VARIABLE_DATALEN( have, required ) \
    if( have < required ) { \
        TRC_ABORT((TB,_T("Slowpath decode varaible data len ") \
            _T("[required=%u got=%u]"), required, have )); \
        hr = E_TSC_CORE_LENGTH; \
        DC_QUIT; \
    }

/****************************************************************************/
// ODDecodeOpaqueRect
//
// Fast-path decode function for OpaqueRect (most common order [57%] in
// WinBench99).
/****************************************************************************/
HRESULT DCINTERNAL COD::ODDecodeOpaqueRect(
        BYTE ControlFlags,
        BYTE FAR * FAR *ppFieldDecode,
        DCUINT dataLen,
        UINT32 FieldFlags)
{
    HRESULT hr = S_OK;
    PUH_ORDER pUHHdr = (PUH_ORDER)_OD.lastOpaqueRect;
    OPAQUERECT_ORDER FAR *pOR = (OPAQUERECT_ORDER FAR *)
            (_OD.lastOpaqueRect + UH_ORDER_HEADER_SIZE);
    BYTE FAR *pFieldDecode = *ppFieldDecode;
    BYTE FAR *pEnd = pFieldDecode + dataLen;

    DC_BEGIN_FN("ODDecodeOpaqueRect");

    if (ControlFlags & TS_DELTA_COORDINATES) {
        // All coord fields are 1-byte signed deltas from the last values.
        if (FieldFlags & 0x01) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pOR->nLeftRect += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x02) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pOR->nTopRect += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x04) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pOR->nWidth += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x08) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pOR->nHeight += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
    }
    else {
        // All coord fields are 2-byte values.sign-extended from the output.
        if (FieldFlags & 0x01) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pOR->nLeftRect = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x02) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pOR->nTopRect = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x04) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pOR->nWidth = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x08) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pOR->nHeight = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
    }

    // If we've not already set the bounds (the order didn't contain
    // any), set the bounds to the blt rect and reset the clip region.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!(ControlFlags & TS_BOUNDS)) {
        pUHHdr->dstRect.left = (int)pOR->nLeftRect;
        pUHHdr->dstRect.top = (int)pOR->nTopRect;
        pUHHdr->dstRect.right = (int)(pOR->nLeftRect + pOR->nWidth - 1);
        pUHHdr->dstRect.bottom = (int)(pOR->nTopRect + pOR->nHeight - 1);
        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pUHHdr->dstRect.left, pUHHdr->dstRect.top,
                pUHHdr->dstRect.right, pUHHdr->dstRect.bottom);
    }

    // Copy non-coordinate fields if present.
    if (FieldFlags & 0x10) {
        OD_DECODE_CHECK_READ( pFieldDecode, BYTE, pEnd, hr );
        pOR->Color.u.rgb.red = *pFieldDecode++;
    }
    if (FieldFlags & 0x20) {
        OD_DECODE_CHECK_READ( pFieldDecode, BYTE, pEnd, hr );
        pOR->Color.u.rgb.green = *pFieldDecode++;
    }
    if (FieldFlags & 0x40) {
        OD_DECODE_CHECK_READ( pFieldDecode, BYTE, pEnd, hr );
        pOR->Color.u.rgb.blue = *pFieldDecode++;
    }

    // Return the incremented pointer to the main routine.
    *ppFieldDecode = pFieldDecode;

#ifdef DC_HICOLOR
    TRC_NRM((TB,_T("ORDER: OpaqueRect x(%d) y(%d) w(%d) h(%d) c(%#06lx)"),
            (int)pOR->nLeftRect,
            (int)pOR->nTopRect,
            (int)pOR->nWidth,
            (int)pOR->nHeight,
            *((PDCUINT32)&pOR->Color) ));
#else
    TRC_NRM((TB,_T("ORDER: OpaqueRect x(%d) y(%d) w(%d) h(%d) c(%#02x)"),
            (int)pOR->nLeftRect,
            (int)pOR->nTopRect,
            (int)pOR->nWidth,
            (int)pOR->nHeight,
            (int)pOR->Color.u.index));
#endif

    // Create a solid brush of the required color. Hard-coded to use
    // palette brushes for now because we don't support anything more.
    _pUh->UHUseSolidPaletteBrush(pOR->Color);

    // Do the blt.
    TIMERSTART;
    PatBlt(_pUh->_UH.hdcDraw, (int)pOR->nLeftRect, (int)pOR->nTopRect,
            (int)pOR->nWidth, (int)pOR->nHeight, PATCOPY);
    TIMERSTOP;
    UPDATECOUNTER(FC_OPAQUERECT_TYPE);

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODDecodeMemBlt
//
// Fast-path decode function for MemBlt (3rd most common order in WinBench99).
/****************************************************************************/
HRESULT DCINTERNAL COD::ODDecodeMemBlt(
        BYTE ControlFlags,
        BYTE FAR * FAR *ppFieldDecode,
        DCUINT dataLen,
        UINT32 FieldFlags)
{
    HRESULT hr = S_OK;
    PUH_ORDER pUHHdr = (PUH_ORDER)_OD.lastMembltR2;
    MEMBLT_R2_ORDER FAR *pMB = (MEMBLT_R2_ORDER FAR *)
            (_OD.lastMembltR2 + UH_ORDER_HEADER_SIZE);
    BYTE FAR *pFieldDecode = *ppFieldDecode;
    BYTE FAR *pEnd = pFieldDecode + dataLen;

    DC_BEGIN_FN("ODDecodeMemBlt");

    // CacheID is a fixed 2-byte field.
    if (FieldFlags & 0x0001) {
        OD_DECODE_CHECK_READ( pFieldDecode, UINT16, pEnd, hr );
        pMB->Common.cacheId = *((UINT16 UNALIGNED FAR *)pFieldDecode);
        pFieldDecode += 2;
    }

    if (ControlFlags & TS_DELTA_COORDINATES) {
        // All coord fields are 1-byte signed deltas from the last values.
        if (FieldFlags & 0x0002) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pMB->Common.nLeftRect += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0004) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pMB->Common.nTopRect += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0008) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pMB->Common.nWidth += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0010) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pMB->Common.nHeight += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }

        // bRop is just 1 byte.
        if (FieldFlags & 0x0020) {
            OD_DECODE_CHECK_READ( pFieldDecode, BYTE, pEnd, hr );
            pMB->Common.bRop = *pFieldDecode++;
        }

        if (FieldFlags & 0x0040) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pMB->Common.nXSrc += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0080) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pMB->Common.nYSrc += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
    }
    else {
        // All coord fields are 2-byte values.sign-extended from the output.
        if (FieldFlags & 0x0002) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pMB->Common.nLeftRect = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0004) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pMB->Common.nTopRect = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0008) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pMB->Common.nWidth = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0010) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pMB->Common.nHeight = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }

        // bRop is just 1 byte.
        if (FieldFlags & 0x0020) {
            OD_DECODE_CHECK_READ( pFieldDecode, BYTE, pEnd, hr );
            pMB->Common.bRop = *pFieldDecode++;
        }

        if (FieldFlags & 0x0040) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pMB->Common.nXSrc = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0080) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pMB->Common.nYSrc = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
    }

    // CacheIndex is always a 2-byte field.
    if (FieldFlags & 0x0100) {
        OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
        pMB->Common.cacheIndex = *((UINT16 UNALIGNED FAR *)pFieldDecode);
        pFieldDecode += 2;
    }

    // If we've not already set the bounds (the order didn't contain
    // any), set the bounds to the blt rect and reset the clip region.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!(ControlFlags & TS_BOUNDS)) {
        pUHHdr->dstRect.left = (int)pMB->Common.nLeftRect;
        pUHHdr->dstRect.top = (int)pMB->Common.nTopRect;
        pUHHdr->dstRect.right = (int)(pMB->Common.nLeftRect +
               pMB->Common.nWidth - 1);
        pUHHdr->dstRect.bottom = (int)(pMB->Common.nTopRect +
               pMB->Common.nHeight - 1);
        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pUHHdr->dstRect.left, pUHHdr->dstRect.top,
                pUHHdr->dstRect.right, pUHHdr->dstRect.bottom);
    }

    // Return the incremented pointer to the main routine.
    *ppFieldDecode = pFieldDecode;

    TRC_NRM((TB, _T("ORDER: MemBlt")));

    hr = _pUh->UHDrawMemBltOrder(_pUh->_UH.hdcDraw, &pMB->Common);
    DC_QUIT_ON_FAIL(hr);

#ifdef DC_DEBUG
    if (_pUh->_UH.hdcDraw == _pUh->_UH.hdcShadowBitmap || 
            _pUh->_UH.hdcDraw == _pUh->_UH.hdcOutputWindow) {
    
        // Draw hatching over the memblt data if the option is enabled.
        if (_pUh->_UH.hatchMemBltOrderData) {
            unsigned cacheId;
            unsigned cacheEntry;

            cacheId = DCLO8(pMB->Common.cacheId);
            cacheEntry = pMB->Common.cacheIndex;

            if (cacheId < _pUh->_UH.NumBitmapCaches && 
                    cacheEntry != BITMAPCACHE_WAITING_LIST_INDEX) {
                if (_pUh->_UH.MonitorEntries[0] != NULL) {
                    _pUh->UH_HatchRect((int)pMB->Common.nLeftRect, (int)pMB->Common.nTopRect,
                                       (int)(pMB->Common.nLeftRect + pMB->Common.nWidth),
                                       (int)(pMB->Common.nTopRect + pMB->Common.nHeight),
                                       (_pUh->_UH.MonitorEntries[cacheId][cacheEntry].UsageCount == 1) ?
                                       UH_RGB_MAGENTA : UH_RGB_BLUE,
                                       UH_BRUSHTYPE_FDIAGONAL);
                } else {
                    _pUh->UH_HatchRect((int)pMB->Common.nLeftRect, (int)pMB->Common.nTopRect,
                                       (int)(pMB->Common.nLeftRect + pMB->Common.nWidth),
                                       (int)(pMB->Common.nTopRect + pMB->Common.nHeight),
                                       UH_RGB_MAGENTA,
                                       UH_BRUSHTYPE_FDIAGONAL);
                }
            }
        }
    
        // Label the memblt if the option is enabled.
        if (_pUh->_UH.labelMemBltOrders) {
            unsigned cacheId;
            unsigned cacheEntry;

            cacheId = DCLO8(pMB->Common.cacheId);
            cacheEntry = pMB->Common.cacheIndex;

            if (cacheId < _pUh->_UH.NumBitmapCaches &&
                    cacheEntry != BITMAPCACHE_WAITING_LIST_INDEX) {
                _pUh->UHLabelMemBltOrder((int)pMB->Common.nLeftRect,
                                         (int)pMB->Common.nTopRect,
                                         pMB->Common.cacheId, pMB->Common.cacheIndex);
            }
        }
    }
#endif /* DC_DEBUG */

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODDecodeLineTo
//
// Fast-path decode function for LineTo (5th most common order in WinBench99).
/****************************************************************************/
HRESULT DCINTERNAL COD::ODDecodeLineTo(
        BYTE ControlFlags,
        BYTE FAR * FAR *ppFieldDecode,
        DCUINT dataLen,
        UINT32 FieldFlags)
{
    HRESULT hr = S_OK;
    PUH_ORDER pUHHdr = (PUH_ORDER)_OD.lastLineTo;
    LINETO_ORDER FAR *pLT = (LINETO_ORDER FAR *)
            (_OD.lastLineTo + UH_ORDER_HEADER_SIZE);
    BYTE FAR *pFieldDecode = *ppFieldDecode;
    BYTE FAR *pEnd = pFieldDecode + dataLen;

    DC_BEGIN_FN("ODDecodeLineTo");

    // BackMode is always a 2-byte field.
    if (FieldFlags & 0x0001) {
        OD_DECODE_CHECK_READ( pFieldDecode, UINT16, pEnd, hr );
        pLT->BackMode = *((UINT16 UNALIGNED FAR *)pFieldDecode);
        pFieldDecode += 2;
    }

    if (ControlFlags & TS_DELTA_COORDINATES) {
        // All coord fields are 1-byte signed deltas from the last values.
        if (FieldFlags & 0x0002) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pLT->nXStart += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0004) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pLT->nYStart += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0008) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pLT->nXEnd += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0010) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pLT->nYEnd += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
    }
    else {
        // All coord fields are 2-byte values.sign-extended from the output.
        if (FieldFlags & 0x0002) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pLT->nXStart = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0004) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pLT->nYStart = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0008) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pLT->nXEnd = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0010) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pLT->nYEnd = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
    }

    // If we've not already set the bounds (the order didn't contain
    // any), set the bounds to the blt rect and reset the clip region.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!(ControlFlags & TS_BOUNDS)) {
        if (pLT->nXStart < pLT->nXEnd) {
            pUHHdr->dstRect.left = (int)pLT->nXStart;
            pUHHdr->dstRect.right = (int)pLT->nXEnd;
        }
        else {
            pUHHdr->dstRect.right = (int)pLT->nXStart;
            pUHHdr->dstRect.left = (int)pLT->nXEnd;
        }

        if (pLT->nYStart < pLT->nYEnd) {
            pUHHdr->dstRect.top = (int)pLT->nYStart;
            pUHHdr->dstRect.bottom = (int)pLT->nYEnd;
        }
        else {
            pUHHdr->dstRect.bottom = (int)pLT->nYStart;
            pUHHdr->dstRect.top = (int)pLT->nYEnd;
        }

        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pUHHdr->dstRect.left, pUHHdr->dstRect.top,
                pUHHdr->dstRect.right, pUHHdr->dstRect.bottom);
    }

    // Copy non-coordinate fields if present.
    if (FieldFlags & 0x0020) {
        OD_DECODE_CHECK_READ_MULT( pFieldDecode, BYTE, 3, pEnd, hr );
        
        pLT->BackColor.u.rgb.red = *pFieldDecode++;
        pLT->BackColor.u.rgb.green = *pFieldDecode++;
        pLT->BackColor.u.rgb.blue = *pFieldDecode++;
    }
    if (FieldFlags & 0x0040) {
        OD_DECODE_CHECK_READ( pFieldDecode, BYTE, pEnd, hr );
        pLT->ROP2 = *pFieldDecode++;
    }
    if (FieldFlags & 0x0080) {
        OD_DECODE_CHECK_READ( pFieldDecode, BYTE, pEnd, hr );
        pLT->PenStyle = *pFieldDecode++;
    }
    if (FieldFlags & 0x0100) {
        OD_DECODE_CHECK_READ( pFieldDecode, BYTE, pEnd, hr );
        pLT->PenWidth = *pFieldDecode++;
    }
    if (FieldFlags & 0x0200) {
        OD_DECODE_CHECK_READ_MULT( pFieldDecode, BYTE, 3, pEnd, hr );
        
        pLT->PenColor.u.rgb.red = *pFieldDecode++;
        pLT->PenColor.u.rgb.green = *pFieldDecode++;
        pLT->PenColor.u.rgb.blue = *pFieldDecode++;
    }

    // Return the incremented pointer to the main routine.
    *ppFieldDecode = pFieldDecode;

    TRC_NRM((TB,_T("ORDER: LineTo BC %08lX BM %04X rop2 %04X pen ")
            _T("%04X %04X %08lX x1 %d y1 %d x2 %d y2 %d"),
            pLT->BackColor,
            pLT->BackMode,
            pLT->ROP2,
            pLT->PenStyle,
            pLT->PenWidth,
            pLT->PenColor,
            pLT->nXStart,
            pLT->nYStart,
            pLT->nXEnd,
            pLT->nYEnd));

    UHUseBkColor(pLT->BackColor, UH_COLOR_PALETTE, _pUh);
    UHUseBkMode((int)pLT->BackMode, _pUh);
    UHUseROP2((int)pLT->ROP2, _pUh);
    _pUh->UHUsePen((unsigned)pLT->PenStyle, (unsigned)pLT->PenWidth, pLT->PenColor,
            UH_COLOR_PALETTE);

    TIMERSTART;

#ifdef OS_WINCE
    {
        POINT pts[2];

        pts[0].x = pLT->nXStart;
        pts[0].y = pLT->nYStart;
        pts[1].x = pLT->nXEnd;
        pts[1].y = pLT->nYEnd;
        Polyline(_pUh->_UH.hdcDraw, pts, 2);
    }
#else
    MoveToEx(_pUh->_UH.hdcDraw, (int)pLT->nXStart, (int)pLT->nYStart, NULL);
    LineTo(_pUh->_UH.hdcDraw, (int)pLT->nXEnd, (int)pLT->nYEnd);
#endif // OS_WINCE

    TIMERSTOP;
    UPDATECOUNTER(FC_LINETO_TYPE);

#ifdef DC_ROTTER
#pragma message("ROTTER keystroke return code compiled in")
    /****************************************************************/
    /* For use with ROund Trip TimER application                    */
    /*                                                              */
    /* ROTTER runs on the server and initiates a series of drawing  */
    /* commands to the screen, ending with a specific unusual line  */
    /* drawing command (from (1,1) and (51,51) with MERGEPENNOT ROP)*/
    /*                                                              */
    /* It then waits until it receives a 't' or 'T' keystroke after */
    /* which it calculates the elapsed time between the start of    */
    /* the drawing and the receipt of the keystroke.  This is the   */
    /* round trip time.                                             */
    /*                                                              */
    /* The following code checks to see whether ROTTER has finished */
    /* drawing, by testing all LineTo commands to see if any are 50 */
    /* across by 50 down with MERGEPENNOT ROP.  We are not able to  */
    /* simply test that the line's start and endpoints are at (1,1) */
    /* and (51,51) because the coordinates that are received by     */
    /* Ducati depend on the position of ROTTER's window on the      */
    /* terminal.                                                    */
    /*                                                              */
    /* When the special case is detected we post a "T", by          */
    /* synthesizing a press of the T key and injecting it into the  */
    /* IH input handler window, which causes IH to send a key-down  */
    /* key-up sequence for the T key to the server.                 */
    /****************************************************************/
    if ((R2_MERGEPENNOT == (pLineTo->ROP2))    &&
        (50             == ((pLineTo->nXEnd) - (pLineTo->nXStart))) &&
        (50             == ((pLineTo->nYEnd) - (pLineTo->nYStart))))
    {
        TRC_ALT((TB,_T("MERGEPENNOT ROP2 detected. Sending 'T'")));
        PostMessage(IH_GetInputHandlerWindow(),
                    WM_KEYDOWN,
                    0x00000054,
                    0x00140001);
        PostMessage(IH_GetInputHandlerWindow(),
                    WM_KEYUP,
                    0x00000054,
                    0xC0140001);
    }
#endif /* DC_ROTTER */

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODDecodePatBlt
//
// Fast-path decode function for PatBlt.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODDecodePatBlt(
        BYTE ControlFlags,
        BYTE FAR * FAR *ppFieldDecode,
        DCUINT dataLen,
        UINT32 FieldFlags)
{
    HRESULT hr = S_OK;
    UINT32 WindowsROP;    
    PUH_ORDER pUHHdr = (PUH_ORDER)_OD.lastPatblt;
    PATBLT_ORDER FAR *pPB = (PATBLT_ORDER FAR *)
            (_OD.lastPatblt + UH_ORDER_HEADER_SIZE);
    BYTE FAR *pFieldDecode = *ppFieldDecode;
    BYTE FAR *pEnd = pFieldDecode + dataLen;

    DC_BEGIN_FN("ODDecodePatBlt");

    if (ControlFlags & TS_DELTA_COORDINATES) {
        // All coord fields are 1-byte signed deltas from the last values.
        if (FieldFlags & 0x0001) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pPB->nLeftRect += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0002) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pPB->nTopRect += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0004) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pPB->nWidth += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0008) {
            OD_DECODE_CHECK_READ( pFieldDecode, char, pEnd, hr );
            pPB->nHeight += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
    }
    else {
        // All coord fields are 2-byte values.sign-extended from the output.
        if (FieldFlags & 0x0001) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pPB->nLeftRect = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0002) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pPB->nTopRect = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0004) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pPB->nWidth = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0008) {
            OD_DECODE_CHECK_READ( pFieldDecode, INT16, pEnd, hr );
            pPB->nHeight = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
    }

    // If we've not already set the bounds (the order didn't contain
    // any), set the bounds to the blt rect and reset the clip region.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!(ControlFlags & TS_BOUNDS)) {
        pUHHdr->dstRect.left = (int)pPB->nLeftRect;
        pUHHdr->dstRect.top = (int)pPB->nTopRect;
        pUHHdr->dstRect.right = (int)(pPB->nLeftRect + pPB->nWidth - 1);
        pUHHdr->dstRect.bottom = (int)(pPB->nTopRect + pPB->nHeight - 1);
        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pUHHdr->dstRect.left, pUHHdr->dstRect.top,
                pUHHdr->dstRect.right, pUHHdr->dstRect.bottom);
    }

    // Copy non-coordinate fields if present.
    if (FieldFlags & 0x0010) {
        OD_DECODE_CHECK_READ( pFieldDecode, BYTE, pEnd, hr );        
        pPB->bRop = *pFieldDecode++;
    }
    if (FieldFlags & 0x0020) {
        OD_DECODE_CHECK_READ_MULT( pFieldDecode, BYTE, 3, pEnd, hr );        
        pPB->BackColor.u.rgb.red = *pFieldDecode++;
        pPB->BackColor.u.rgb.green = *pFieldDecode++;
        pPB->BackColor.u.rgb.blue = *pFieldDecode++;
    }
    if (FieldFlags & 0x0040) {
        OD_DECODE_CHECK_READ_MULT( pFieldDecode, BYTE, 3, pEnd, hr );  
        pPB->ForeColor.u.rgb.red = *pFieldDecode++;
        pPB->ForeColor.u.rgb.green = *pFieldDecode++;
        pPB->ForeColor.u.rgb.blue = *pFieldDecode++;
    }
    if (FieldFlags & 0x0080) {
        OD_DECODE_CHECK_READ( pFieldDecode, BYTE, pEnd, hr );  
        pPB->BrushOrgX = *pFieldDecode++;
    }
    if (FieldFlags & 0x0100) {
        OD_DECODE_CHECK_READ( pFieldDecode, BYTE, pEnd, hr );  
        pPB->BrushOrgY = *pFieldDecode++;
    }
    if (FieldFlags & 0x0200) {
        OD_DECODE_CHECK_READ( pFieldDecode, BYTE, pEnd, hr );  
        pPB->BrushStyle = *pFieldDecode++;
    }
    if (FieldFlags & 0x0400) {
        OD_DECODE_CHECK_READ( pFieldDecode, BYTE, pEnd, hr );  
        pPB->BrushHatch = *pFieldDecode++;
    }
    if (FieldFlags & 0x0800) {
        OD_DECODE_CHECK_READ_MULT( pFieldDecode, BYTE, 7, pEnd, hr );  
        memcpy(&pPB->BrushExtra, pFieldDecode, 7);
        pFieldDecode += 7;
    }

    // Return the incremented pointer to the main routine.
    *ppFieldDecode = pFieldDecode;

    TRC_NRM((TB, _T("ORDER: PatBlt Brush %02X %02X BC %02x FC %02x ")
            _T("X %d Y %d w %d h %d rop %08lX"),
            (int)pPB->BrushStyle,
            (int)pPB->BrushHatch,
            (int)pPB->BackColor.u.index,
            (int)pPB->ForeColor.u.index,
            (int)pPB->nLeftRect,
            (int)pPB->nTopRect,
            (int)pPB->nWidth,
            (int)pPB->nHeight,
            _pUh->UHConvertToWindowsROP((unsigned)pPB->bRop)));

    // Explicitly use palette entries; we don't support more than that now.
    UHUseBkColor(pPB->BackColor, UH_COLOR_PALETTE, _pUh);
    
    UHUseTextColor(pPB->ForeColor, UH_COLOR_PALETTE, _pUh);
    UHUseBrushOrg((int)pPB->BrushOrgX, (int)pPB->BrushOrgY,_pUh);
    hr = _pUh->UHUseBrush((unsigned)pPB->BrushStyle, (unsigned)pPB->BrushHatch,
            pPB->ForeColor, UH_COLOR_PALETTE, pPB->BrushExtra);
    DC_QUIT_ON_FAIL(hr);

    WindowsROP = _pUh->UHConvertToWindowsROP((unsigned)pPB->bRop);

    TIMERSTART;
    PatBlt(_pUh->_UH.hdcDraw, (int)pPB->nLeftRect, (int)pPB->nTopRect,
            (int)pPB->nWidth, (int)pPB->nHeight, WindowsROP);
    TIMERSTOP;
    UPDATECOUNTER(FC_PATBLT_TYPE);

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODHandleMultiPatBlt
//
// Handler for MultiPatBlt orders.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODHandleMultiPatBlt(PUH_ORDER pOrder, 
    UINT16 uiVarDataLen, BOOL bBoundsSet)
{
    HRESULT hr = S_OK;
    unsigned i;
    UINT32 WindowsROP;    
    RECT Rects[ORD_MAX_ENCODED_CLIP_RECTS + 1];
    MULTI_PATBLT_ORDER FAR *pPB = (MULTI_PATBLT_ORDER FAR *)pOrder->orderData;

    DC_BEGIN_FN("ODHandleMultiPatBlt");

    // If there are no rects, we have nothing to draw.  The server in error, or
    // a bad server, can send 0 rects.  In this case we should simply defend our
    // selves
    if (0 == pPB->nDeltaEntries) {
        TRC_ERR((TB,_T("Multipatblt with no rects; uiVarDataLen=%u"), 
            uiVarDataLen));
        hr = S_OK;
        DC_QUIT;
    }

    // If we've not already set the bounds (the order didn't contain
    // any), set the bounds to the blt rect and reset the clip region.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!bBoundsSet) {
        pOrder->dstRect.left = (int)pPB->nLeftRect;
        pOrder->dstRect.top = (int)pPB->nTopRect;
        pOrder->dstRect.right = (int)(pPB->nLeftRect + pPB->nWidth - 1);
        pOrder->dstRect.bottom = (int)(pPB->nTopRect + pPB->nHeight - 1);
        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pOrder->dstRect.left, pOrder->dstRect.top,
                pOrder->dstRect.right, pOrder->dstRect.bottom);
    }

    TRC_NRM((TB, _T("ORDER: PatBlt Brush %02X %02X BC %02x FC %02x ")
            _T("X %d Y %d w %d h %d rop %08lX"),
            (int)pPB->BrushStyle,
            (int)pPB->BrushHatch,
            (int)pPB->BackColor.u.index,
            (int)pPB->ForeColor.u.index,
            (int)pPB->nLeftRect,
            (int)pPB->nTopRect,
            (int)pPB->nWidth,
            (int)pPB->nHeight,
            _pUh->UHConvertToWindowsROP((unsigned)pPB->bRop)));

    // Explicitly use palette entries; we don't support more than that now.
    UHUseBkColor(pPB->BackColor, UH_COLOR_PALETTE, _pUh);
    UHUseTextColor(pPB->ForeColor, UH_COLOR_PALETTE, _pUh);

    UHUseBrushOrg((int)pPB->BrushOrgX, (int)pPB->BrushOrgY, _pUh);
    hr = _pUh->UHUseBrush((unsigned)pPB->BrushStyle, (unsigned)pPB->BrushHatch,
            pPB->ForeColor, UH_COLOR_PALETTE, pPB->BrushExtra);
    DC_QUIT_ON_FAIL(hr);

    hr = ODDecodeMultipleRects(Rects, pPB->nDeltaEntries, &pPB->codedDeltaList, 
        uiVarDataLen);
    DC_QUIT_ON_FAIL(hr);
    
    WindowsROP = _pUh->UHConvertToWindowsROP((unsigned)pPB->bRop);

    TIMERSTART;
    for (i = 0; i < pPB->nDeltaEntries; i++ )
        PatBlt(_pUh->_UH.hdcDraw, (int)Rects[i].left, (int)Rects[i].top,
                (int)(Rects[i].right - Rects[i].left),
                (int)(Rects[i].bottom - Rects[i].top),
                WindowsROP);
    TIMERSTOP;
    UPDATECOUNTER(FC_PATBLT_TYPE);

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODHandleDstBlts
//
// Order handler for both DstBlt and MultiDstBlt.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODHandleDstBlts(PUH_ORDER pOrder, UINT16 uiVarDataLen,
    BOOL bBoundsSet)
{
    HRESULT hr = S_OK;
    RECT Rects[ORD_MAX_ENCODED_CLIP_RECTS + 1];
    UINT32 WindowsROP;
    unsigned i;
    LPDSTBLT_ORDER pDB = (LPDSTBLT_ORDER)pOrder->orderData;

    DC_BEGIN_FN("ODHandleDstBlts");      

    // If we've not already set the bounds (the order didn't contain
    // any), set the bounds to the blt rect and reset the clip region.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!bBoundsSet) {
        pOrder->dstRect.left = (int)pDB->nLeftRect;
        pOrder->dstRect.top = (int)pDB->nTopRect;
        pOrder->dstRect.right = (int)(pDB->nLeftRect + pDB->nWidth - 1);
        pOrder->dstRect.bottom = (int)(pDB->nTopRect + pDB->nHeight - 1);
        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pOrder->dstRect.left, pOrder->dstRect.top,
                pOrder->dstRect.right, pOrder->dstRect.bottom);
    }

    WindowsROP = _pUh->UHConvertToWindowsROP(pDB->bRop);

    if (pDB->type == TS_ENC_DSTBLT_ORDER) {
        TRC_NRM((TB, _T("ORDER: DstBlt X %d Y %d w %d h %d rop %08lX"),
                (int)pDB->nLeftRect, (int)pDB->nTopRect,
                (int)pDB->nWidth, (int)pDB->nHeight,
                WindowsROP));
        
        TRC_NRM((TB, _T("Single")));

        TRC_ASSERT((0==uiVarDataLen),
            (TB,_T("Recieved varaible length data in fixed length order")));
        
        TIMERSTART;
        PatBlt(_pUh->_UH.hdcDraw, (int)pDB->nLeftRect, (int)pDB->nTopRect,
                (int)pDB->nWidth, (int)pDB->nHeight, WindowsROP);
        TIMERSTOP;
        UPDATECOUNTER(FC_DSTBLT_TYPE);
    }
    else {
        LPMULTI_DSTBLT_ORDER pMDB = (LPMULTI_DSTBLT_ORDER)pDB;
        TRC_NRM((TB, _T("ORDER: MultiDstBlt X %d Y %d w %d h %d rop %08lX ")
            _T("nDeltas %d"), (int)pMDB->nLeftRect, (int)pMDB->nTopRect,
            (int)pMDB->nWidth, (int)pMDB->nHeight, WindowsROP, 
            pMDB->nDeltaEntries));

        if (0 == pMDB->nDeltaEntries) {
            TRC_ERR((TB,_T("MultiDstBlt with no rects; uiVarDataLen=%u"), 
                uiVarDataLen));
            hr = S_OK;
            DC_QUIT;
        }
        
        hr = ODDecodeMultipleRects(Rects, pMDB->nDeltaEntries, 
            &pMDB->codedDeltaList, uiVarDataLen);
        DC_QUIT_ON_FAIL(hr);
        
        TIMERSTART;
        for (i = 0; i < pMDB->nDeltaEntries; i++)
            PatBlt(_pUh->_UH.hdcDraw, (int)Rects[i].left, (int)Rects[i].top,
                    (int)(Rects[i].right - Rects[i].left),
                    (int)(Rects[i].bottom - Rects[i].top),
                    WindowsROP);
        TIMERSTOP;
        UPDATECOUNTER(FC_DSTBLT_TYPE);
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODHandleScrBlts
//
// Order handler for ScrBlt and MultiScrBlt.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODHandleScrBlts(PUH_ORDER pOrder, UINT16 uiVarDataLen,
    BOOL bBoundsSet)
{
    HRESULT hr = S_OK;
    RECT Rects[ORD_MAX_ENCODED_CLIP_RECTS + 1];
    UINT32 WindowsROP;
    unsigned i;
    LPSCRBLT_ORDER pSB = (LPSCRBLT_ORDER)pOrder->orderData;
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
    RECT rectTemp, rectIntersect;
    int nX, nY;
    int nWidth;
#endif

    DC_BEGIN_FN("ODHandleScrBlts");

    // If we've not already set the bounds (the order didn't contain
    // any), set the bounds to the blt rect and reset the clip region.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!bBoundsSet) {
        pOrder->dstRect.left = (int)pSB->nLeftRect;
        pOrder->dstRect.top = (int)pSB->nTopRect;
        pOrder->dstRect.right = (int)(pSB->nLeftRect + pSB->nWidth - 1);
        pOrder->dstRect.bottom = (int)(pSB->nTopRect + pSB->nHeight - 1);
        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pOrder->dstRect.left, pOrder->dstRect.top,
                pOrder->dstRect.right, pOrder->dstRect.bottom);
    }

    WindowsROP = _pUh->UHConvertToWindowsROP((unsigned)pSB->bRop);

    if (pSB->type == TS_ENC_SCRBLT_ORDER) {
        TRC_NRM((TB, _T("ORDER: ScrBlt dx %d dy %d w %d h %d sx %d sy %d rop %08lX"),
                (int)pSB->nLeftRect, (int)pSB->nTopRect,
                (int)pSB->nWidth, (int)pSB->nHeight,
                (int)pSB->nXSrc, (int)pSB->nYSrc, WindowsROP));

        TIMERSTART;
        // If we turned off screenblt support due to shadowing a
        // large session from WinCE, the server will not currently
        // register that and will still send us ScrBlts. We won't
        // have a shadow bitmap in this scenario, but we can deal
        // with this by invalidating the affected output area.
        if (_pCc->_ccCombinedCapabilities.orderCapabilitySet.
                orderSupport[TS_NEG_SCRBLT_INDEX]) {
            TRC_DBG((TB, _T("Real ScrBlt")));
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
            if (!_pUh->_UH.DontUseShadowBitmap && _pUh->_UH.hdcShadowBitmap ) {
#else
            if (_pUh->_UH.hdcShadowBitmap) {
#endif             
                if (!BitBlt(_pUh->_UH.hdcDraw, (int)pSB->nLeftRect, (int)pSB->nTopRect,
                        (int)pSB->nWidth, (int)pSB->nHeight, _pUh->_UH.hdcShadowBitmap,
                        (int)pSB->nXSrc, (int)pSB->nYSrc,
                        WindowsROP)) {
                    TRC_ERR((TB, _T("BitBlt failed")));
                }
            }
            else {

#ifdef OS_WINCE
                if (!ODHandleAlwaysOnTopRects(pSB))
                {
#endif
                    if (!BitBlt(_pUh->_UH.hdcDraw, (int)pSB->nLeftRect, (int)pSB->nTopRect,
                            (int)pSB->nWidth, (int)pSB->nHeight, _pUh->_UH.hdcOutputWindow,
                            (int)pSB->nXSrc, (int)pSB->nYSrc,
                            WindowsROP)) {
                        TRC_ERR((TB, _T("BitBlt failed")));
                    }
#ifdef OS_WINCE
                }
#endif

#ifdef DISABLE_SHADOW_IN_FULLSCREEN
                if ((_pUh->_UH.fIsBBarVisible) && (_pUh->_UH.hdcDraw == _pUh->_UH.hdcOutputWindow)) 
                {
                    rectTemp.left   = (int)(pSB->nXSrc);
                    rectTemp.top    = (int)(pSB->nYSrc);
                    rectTemp.right  = (int)(pSB->nXSrc + pSB->nWidth);
                    rectTemp.bottom = (int)(pSB->nYSrc + pSB->nHeight);

                    if (IntersectRect(&rectIntersect, &rectTemp, &(_pUh->_UH.rectBBar))) {
                        nX = pSB->nLeftRect - pSB->nXSrc;
                        nY = pSB->nTopRect - pSB->nYSrc;
                        rectIntersect.left += nX;
                        rectIntersect.right += nX;
                        rectIntersect.top += nY;
                        rectIntersect.bottom += nY;

                        // In fullscreen, when moving a window quickly inside and outside the bbar
                        // part of window intersected by bbar is not drawn correctly
                        // here we invalidate larger rectangle to solve this problem
                        nWidth = rectIntersect.right - rectIntersect.left;
                        rectIntersect.left -= nWidth;
                        rectIntersect.right += nWidth;
                        rectIntersect.bottom += _pUh->_UH.rectBBar.bottom * 2;

                        InvalidateRect(_pOp->OP_GetOutputWindowHandle(), &rectIntersect, FALSE);
                    }
                }
#endif // DISABLE_SHADOW_IN_FULLSCREEN
             }
        }
        else {
            // Alternative processing for when we get a ScrBlt
            // without having advertised support for it.
            TRC_DBG((TB, _T("Simulated ScrBlt")));
            Rects[0].left   = (int)(pSB->nLeftRect);
            Rects[0].top    = (int)(pSB->nTopRect);
            Rects[0].right  = (int)(pSB->nLeftRect + pSB->nWidth);
            Rects[0].bottom = (int)(pSB->nTopRect + pSB->nHeight);
            InvalidateRect(_pOp->OP_GetOutputWindowHandle(), &Rects[0], FALSE);
        }
        TIMERSTOP;
        UPDATECOUNTER(FC_SCRBLT_TYPE);
    }
    else {
        int deltaX, deltaY;
        LPMULTI_SCRBLT_ORDER pMSB = (LPMULTI_SCRBLT_ORDER)pSB;

        TRC_NRM((TB, _T("ORDER: MultiScrBlt dx %d dy %d w %d h %d sx %d sy %d ")
            _T("rop %08lX nDeltas=%d"),
                (int)pMSB->nLeftRect, (int)pMSB->nTopRect,
                (int)pMSB->nWidth, (int)pMSB->nHeight,
                (int)pMSB->nXSrc, (int)pMSB->nYSrc, WindowsROP, 
                (int)pMSB->nDeltaEntries));

        TRC_ASSERT((pMSB->codedDeltaList.len <=
                (ORD_MAX_CLIP_RECTS_CODEDDELTAS_LEN +
                ORD_MAX_CLIP_RECTS_ZERO_FLAGS_BYTES)),
                (TB,_T("Received MultiScrBlt with too-large internal length")));

        if (0 == pMSB->nDeltaEntries) {
            TRC_ERR((TB,_T("MultiScrBlt with no rects; uiVarDataLen=%u"), 
                uiVarDataLen));
            hr = S_OK;
            DC_QUIT;
        }        
        
        hr = ODDecodeMultipleRects(Rects, pMSB->nDeltaEntries,
                &pMSB->codedDeltaList, uiVarDataLen);
        DC_QUIT_ON_FAIL(hr);

        // Do a ScrBlt for each of the clip rects as a subrect of the
        // original ScrBlt rect.
        TIMERSTART;
        if (_pCc->_ccCombinedCapabilities.orderCapabilitySet.
                orderSupport[TS_NEG_MULTISCRBLT_INDEX]) {
            TRC_DBG((TB, _T("Real MultiScrBlt")));
            for (i = 0; i < pMSB->nDeltaEntries; i++ ) {
                // Clip rects in Rects[] are specified within the dest
                // rect (pSB->nLeftRect, nTopRect, nRightRect,
                // nBottomRect) so we need to calc the offset from the
                // source point (pSB->nXSrc, nYSrc) by calculating
                // the delta from the dest rect top-left to the clip rect
                // top-left, then adding the delta to the source point.
                deltaX = (int)(Rects[i].left - pSB->nLeftRect);
                deltaY = (int)(Rects[i].top  - pSB->nTopRect);

                // Do the ScrBlt. Note that rects are in exclusive coords.
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
                if (!_pUh->_UH.DontUseShadowBitmap && _pUh->_UH.hdcShadowBitmap) {
#else
                if (_pUh->_UH.hdcShadowBitmap) {
#endif                
                    if (!BitBlt(_pUh->_UH.hdcDraw, (int)Rects[i].left, (int)Rects[i].top,
                                (int)(Rects[i].right - Rects[i].left),
                                (int)(Rects[i].bottom - Rects[i].top),
                                _pUh->_UH.hdcShadowBitmap, (int)pMSB->nXSrc + deltaX,
                                (int)pMSB->nYSrc + deltaY,
                                WindowsROP)) {
                        TRC_ERR((TB, _T("BitBlt failed")));
                    }
                }
                else {
#ifdef OS_WINCE
                    if (!ODHandleAlwaysOnTopRects(pSB))
                    {
#endif
                        if (!BitBlt(_pUh->_UH.hdcDraw, (int)Rects[i].left, (int)Rects[i].top,
                                    (int)(Rects[i].right - Rects[i].left),
                                    (int)(Rects[i].bottom - Rects[i].top),
                                    _pUh->_UH.hdcOutputWindow, (int)pMSB->nXSrc + deltaX,
                                    (int)pMSB->nYSrc + deltaY,
                                    WindowsROP)) {
                            TRC_ERR((TB, _T("BitBlt failed")));
                        }
#ifdef OS_WINCE
                    }
#endif

#ifdef DISABLE_SHADOW_IN_FULLSCREEN
                    if ((_pUh->_UH.fIsBBarVisible) && (_pUh->_UH.hdcDraw == _pUh->_UH.hdcOutputWindow)) 
                    {
                        rectTemp.left   = (int)(pSB->nXSrc + deltaX);
                        rectTemp.top    = (int)(pSB->nYSrc + deltaY);
                        rectTemp.right  = (int)(pSB->nXSrc + deltaX + Rects[i].right - Rects[i].left);
                        rectTemp.bottom = (int)(pSB->nYSrc + deltaY + Rects[i].bottom - Rects[i].top);

                        if (IntersectRect(&rectIntersect, &rectTemp, &(_pUh->_UH.rectBBar))) {
                            nX = pMSB->nLeftRect - pMSB->nXSrc;
                            nY = pMSB->nTopRect - pMSB->nYSrc;
                            rectIntersect.left += nX;
                            rectIntersect.right += nX;
                            rectIntersect.top += nY;
                            rectIntersect.bottom += nY;

                            // In fullscreen, when moving a window quickly inside and outside the bbar
                            // part of window intersected by bbar is not drawn correctly
                            // here we invalidate larger rectangle to solve this problem
                            nWidth = rectIntersect.right - rectIntersect.left;
                            rectIntersect.left -= nWidth;
                            rectIntersect.right += nWidth;
                            rectIntersect.bottom += _pUh->_UH.rectBBar.bottom * 2;

                            InvalidateRect(_pOp->OP_GetOutputWindowHandle(), &rectIntersect, FALSE);
                        }
                    }
#endif //DISABLE_SHADOW_IN_FULLSCREEN
                }
            }
        }
        else {
            // Alternative processing for when we get a MultiScrBlt
            // without having advertised support for it.
            TRC_DBG((TB, _T("Simulated MultiScrBlt")));
            Rects[0].left   = (int)(pMSB->nLeftRect);
            Rects[0].top    = (int)(pMSB->nTopRect);
            Rects[0].right  = (int)(pMSB->nLeftRect + pMSB->nWidth);
            Rects[0].bottom = (int)(pMSB->nTopRect + pMSB->nHeight);
            InvalidateRect(_pOp->OP_GetOutputWindowHandle(), &Rects[0], FALSE);
        }
        TIMERSTOP;
        UPDATECOUNTER(FC_SCRBLT_TYPE);
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODHandleMultiOpaqueRect
//
// Order handler for MultiOpaqueRect.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODHandleMultiOpaqueRect(PUH_ORDER pOrder, 
    UINT16 uiVarDataLen, BOOL bBoundsSet)
{
    HRESULT hr;
    RECT Rects[ORD_MAX_ENCODED_CLIP_RECTS + 1];
    unsigned i;
    LPMULTI_OPAQUERECT_ORDER pOR =
            (LPMULTI_OPAQUERECT_ORDER)pOrder->orderData;

    DC_BEGIN_FN("ODHandleMultiOpaqueRect");

    if (0 == pOR->nDeltaEntries) {
        TRC_ERR((TB,_T("MultiOpaqueRect with no rects; uiVarDataLen=%u"), 
            uiVarDataLen));
        hr = S_OK;
        DC_QUIT;
    } 

    // If we've not already set the bounds (the order didn't contain
    // any), set the bounds to the blt rect and reset the clip region.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!bBoundsSet) {
        pOrder->dstRect.left = (int)pOR->nLeftRect;
        pOrder->dstRect.top = (int)pOR->nTopRect;
        pOrder->dstRect.right = (int)(pOR->nLeftRect + pOR->nWidth - 1);
        pOrder->dstRect.bottom = (int)(pOR->nTopRect + pOR->nHeight - 1);
        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pOrder->dstRect.left, pOrder->dstRect.top,
                pOrder->dstRect.right, pOrder->dstRect.bottom);
    }

    TRC_NRM((TB, _T("ORDER: OpaqueRect x(%d) y(%d) w(%d) h(%d) c(%#02x)"),
            (int)pOR->nLeftRect, (int)pOR->nTopRect,
            (int)pOR->nWidth,
            (int)pOR->nHeight,
            (int)pOR->Color.u.index));

    _pUh->UHUseSolidPaletteBrush(pOR->Color);

    hr = ODDecodeMultipleRects(Rects, pOR->nDeltaEntries, &pOR->codedDeltaList, 
        uiVarDataLen);
    DC_QUIT_ON_FAIL(hr);

    TIMERSTART;
    for (i = 0; i < pOR ->nDeltaEntries; i++)
        PatBlt(_pUh->_UH.hdcDraw, (int)Rects[i].left, (int)Rects[i].top,
                (int)(Rects[i].right - Rects[i].left),
                (int)(Rects[i].bottom - Rects[i].top), PATCOPY);
    TIMERSTOP;
    UPDATECOUNTER(FC_OPAQUERECT_TYPE);

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}

#ifdef DRAW_NINEGRID
/****************************************************************************/
// ODHandleDrawNineGrid
//
// Order handler for DrawNineGrid.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODHandleDrawNineGrid(PUH_ORDER pOrder, 
    UINT16 uiVarDataLen, BOOL bBoundsSet)
{
    HRESULT hr = S_OK;
    LPDRAWNINEGRID_ORDER pDNG =
            (LPDRAWNINEGRID_ORDER)pOrder->orderData;

    DC_BEGIN_FN("ODHandleDrawNineGrid");

    TRC_ASSERT((bBoundsSet != 0), (TB, _T("Bounds is not set for DrawNineGrid")));
    TRC_ASSERT((0==uiVarDataLen), 
        (TB, _T("Varaible length data in fixed length packet")));

    hr = _pUh->UHIsValidNineGridCacheIndex(pDNG->bitmapId);
    DC_QUIT_ON_FAIL(hr);

    // The bounds is for the destination bounding rect, not clip region 
    // needs to be set
    _pUh->UH_ResetClipRegion();
    
    TRC_NRM((TB, _T("ORDER: DrawNineGrid x(%d) y(%d) w(%d) h(%d) id(%d)"),
            (int)pOrder->dstRect.left, (int)pOrder->dstRect.top,
            (int)pOrder->dstRect.right,
            (int)pOrder->dstRect.bottom,
            (int)pDNG->bitmapId));

    TIMERSTART;
    hr = _pUh->UH_DrawNineGrid(pOrder, pDNG->bitmapId, (RECT *)&(pDNG->srcLeft));
    TIMERSTOP;
    DC_QUIT_ON_FAIL(hr);
    //UPDATECOUNTER(FC_OPAQUERECT_TYPE);

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}

/****************************************************************************/
// ODHandleMultiOpaqueRect
//
// Order handler for MultiOpaqueRect.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODHandleMultiDrawNineGrid(PUH_ORDER pOrder, 
    UINT16 uiVarDataLen, BOOL bBoundsSet)
{
    HRESULT hr = S_OK;
    RECT Rects[ORD_MAX_ENCODED_CLIP_RECTS + 1];
    unsigned i;
    LPMULTI_DRAWNINEGRID_ORDER pDNG =
            (LPMULTI_DRAWNINEGRID_ORDER)pOrder->orderData;
    
    DC_BEGIN_FN("ODHandleMultiDrawNineGrid");

    TRC_ASSERT((bBoundsSet != 0), (TB, _T("Bounds is not set for MultiDrawNineGrid")));

    if (0 == pDNG->nDeltaEntries) {
        TRC_ERR((TB,_T("MultiDrawNineGrid with no rects; uiVarDataLen=%u"), 
            uiVarDataLen));
        hr = S_OK;
        DC_QUIT;
    } 
    
    hr = _pUh->UHIsValidNineGridCacheIndex(pDNG->bitmapId);
    DC_QUIT_ON_FAIL(hr);
        
    // Need to setup the clip region
    hr = ODDecodeMultipleRects(Rects, pDNG->nDeltaEntries, 
        &pDNG->codedDeltaList, uiVarDataLen);
    DC_QUIT_ON_FAIL(hr);

#if defined (OS_WINCE)
    _UH.validClipDC = NULL;
#endif

    SelectClipRgn(_pUh->_UH.hdcDraw, NULL);
    SetRectRgn(_pUh->_UH.hDrawNineGridClipRegion, 0, 0, 0, 0);
    
    for (i = 0; i < pDNG->nDeltaEntries; i++) {
        UH_ORDER OrderRect;
        OrderRect.dstRect.left = Rects[i].left;
        OrderRect.dstRect.top = Rects[i].top;
        OrderRect.dstRect.right = Rects[i].right -1;
        OrderRect.dstRect.bottom = Rects[i].bottom -1;

        _pUh->UHAddUpdateRegion(&OrderRect, _pUh->_UH.hDrawNineGridClipRegion);            
    }

#if defined (OS_WINCE)
    _UH.validClipDC = NULL;
#endif

    SelectClipRgn(_pUh->_UH.hdcDraw, _pUh->_UH.hDrawNineGridClipRegion);
    
    TRC_NRM((TB, _T("ORDER: MultiDrawNineGrid x(%d) y(%d) w(%d) h(%d) id(%d)"),
            (int)pOrder->dstRect.left, (int)pOrder->dstRect.top,
            (int)pOrder->dstRect.right,
            (int)pOrder->dstRect.bottom,
            (int)pDNG->bitmapId));
   
    TIMERSTART;
    hr = _pUh->UH_DrawNineGrid(pOrder, pDNG->bitmapId, (RECT *)&(pDNG->srcLeft));
    TIMERSTOP;
    //UPDATECOUNTER(FC_OPAQUERECT_TYPE);
    DC_QUIT_ON_FAIL(hr);

#if defined (OS_WINCE)
    _UH.validClipDC = NULL;
#endif

    SelectClipRgn(_pUh->_UH.hdcDraw, NULL);

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}
#endif

/****************************************************************************/
// ODHandleMem3Blt
//
// Order handler for Mem3Blt.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODHandleMem3Blt(PUH_ORDER pOrder, 
    UINT16 uiVarDataLen, BOOL bBoundsSet)
{
    HRESULT hr = S_OK;
    LPMEM3BLT_R2_ORDER pMB = (LPMEM3BLT_R2_ORDER)pOrder->orderData;

    DC_BEGIN_FN("ODHandleMem3Blt");

    TRC_ASSERT((0==uiVarDataLen), 
        (TB, _T("Varaible length data in fixed length packet")));

    // If we've not already set the bounds (the order didn't contain
    // any), set the bounds to the blt rect and reset the clip region.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!bBoundsSet) {
        pOrder->dstRect.left = (int)pMB->Common.nLeftRect;
        pOrder->dstRect.top = (int)pMB->Common.nTopRect;
        pOrder->dstRect.right = (int)(pMB->Common.nLeftRect +
                pMB->Common.nWidth - 1);
        pOrder->dstRect.bottom = (int)(pMB->Common.nTopRect +
                pMB->Common.nHeight - 1);
        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pOrder->dstRect.left, pOrder->dstRect.top,
                pOrder->dstRect.right, pOrder->dstRect.bottom);
    }

    TRC_NRM((TB, _T("ORDER: Mem3Blt")));

    UHUseBkColor(pMB->BackColor, UH_COLOR_PALETTE, _pUh);
    UHUseTextColor(pMB->ForeColor, UH_COLOR_PALETTE, _pUh);
    UHUseBrushOrg((int)pMB->BrushOrgX, (int)pMB->BrushOrgY, _pUh);
    hr = _pUh->UHUseBrush((int)pMB->BrushStyle, (int)pMB->BrushHatch,
            pMB->ForeColor, UH_COLOR_PALETTE, pMB->BrushExtra);
    DC_QUIT_ON_FAIL(hr);

    hr = _pUh->UHDrawMemBltOrder(_pUh->_UH.hdcDraw, &pMB->Common);
    DC_QUIT_ON_FAIL(hr);

#ifdef DC_DEBUG
    // Draw hatching over the memblt data if the option is enabled.
    if (_pUh->_UH.hdcDraw == _pUh->_UH.hdcShadowBitmap ||
            _pUh->_UH.hdcDraw == _pUh->_UH.hdcOutputWindow) {
    
        if (_pUh->_UH.hatchMemBltOrderData) {
            unsigned cacheId;
            unsigned cacheEntry;

            cacheId = DCLO8(pMB->Common.cacheId);
            cacheEntry = pMB->Common.cacheIndex;

            if (cacheEntry != BITMAPCACHE_WAITING_LIST_INDEX &&
                SUCCEEDED(_pUh->UHIsValidBitmapCacheIndex(cacheId, cacheEntry))) {
                if (_pUh->_UH.MonitorEntries[0] != NULL)
                    _pUh->UH_HatchRect((int)pMB->Common.nLeftRect, (int)pMB->Common.nTopRect,
                                       (int)(pMB->Common.nLeftRect + pMB->Common.nWidth),
                                       (int)(pMB->Common.nTopRect + pMB->Common.nHeight),
                                       (_pUh->_UH.MonitorEntries[cacheId][cacheEntry].UsageCount == 1) ?
                                       UH_RGB_MAGENTA : UH_RGB_GREEN,
                                       UH_BRUSHTYPE_FDIAGONAL);
                else
                    _pUh->UH_HatchRect((int)pMB->Common.nLeftRect, (int)pMB->Common.nTopRect,
                                       (int)(pMB->Common.nLeftRect + pMB->Common.nWidth),
                                       (int)(pMB->Common.nTopRect + pMB->Common.nHeight),
                                       UH_RGB_MAGENTA, UH_BRUSHTYPE_FDIAGONAL);
            }
        }

        // Label the memblt if the option is enabled.
        if (_pUh->_UH.labelMemBltOrders) {
            unsigned cacheId;
            unsigned cacheEntry;

            cacheId = DCLO8(pMB->Common.cacheId);
            cacheEntry = pMB->Common.cacheIndex;

            if (cacheEntry != BITMAPCACHE_WAITING_LIST_INDEX &&
                SUCCEEDED(_pUh->UHIsValidBitmapCacheIndex(cacheId, cacheEntry))) {
                _pUh->UHLabelMemBltOrder((int)pMB->Common.nLeftRect,
                                     (int)pMB->Common.nTopRect, pMB->Common.cacheId,
                                     pMB->Common.cacheIndex);
            }
        }
    }

#endif /* DC_DEBUG */

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODHandleSaveBitmap
//
// Order handler for SaveBitmap.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODHandleSaveBitmap(PUH_ORDER pOrder, 
    UINT16 uiVarDataLen, BOOL bBoundsSet)
{
    HRESULT hr = S_OK;
    int xSaveBitmap;
    int ySaveBitmap;
    int xScreenBitmap;
    int yScreenBitmap;
    int cxTile;
    int cyTile;
    int ScreenLeft, ScreenTop, ScreenRight, ScreenBottom;
    LPSAVEBITMAP_ORDER pSB = (LPSAVEBITMAP_ORDER)pOrder->orderData;

    DC_BEGIN_FN("ODHandleSaveBitmap");

    TRC_ASSERT((0==uiVarDataLen), 
        (TB, _T("Varaible length data in fixed length packet")));

    // If we've not already set the bounds (the order didn't contain
    // any), set the bounds to the blt rect and reset the clip region.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!bBoundsSet) {
        pOrder->dstRect.left = (int)pSB->nLeftRect;
        pOrder->dstRect.top = (int)pSB->nTopRect;
        pOrder->dstRect.right = (int)pSB->nRightRect;
        pOrder->dstRect.bottom = (int)pSB->nBottomRect;
        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pOrder->dstRect.left, pOrder->dstRect.top,
                pOrder->dstRect.right, pOrder->dstRect.bottom);
    }

    TRC_NRM((TB, _T("ORDER: SaveBitmap op %d rect %d %d %d %d"),
            (int)pSB->Operation, (int)pSB->nLeftRect,
            (int)pSB->nTopRect, (int)pSB->nRightRect,
            (int)pSB->nBottomRect));

    if (_pUh->_UH.hSaveScreenBitmap != NULL) {
        // Check that we have selected a DC to draw to.
        TRC_ASSERT((NULL != _pUh->_UH.hdcDraw), (TB,_T("No drawing hdc!")));

        // Calculate the (x,y) offset into the Save Desktop Bitmap from the
        // start position as encoded in the order. (The server knows the
        // dimensions of our bitmap and is reponsible for telling us where to
        // store/retrieve rectangles in the bitmap.)
        // See T.128 8.16.17 for a justification of this algorithm.
        ySaveBitmap = (int)((pSB->SavedBitmapPosition /
                (UH_SAVE_BITMAP_WIDTH *
                (UINT32)UH_SAVE_BITMAP_Y_GRANULARITY)) *
                UH_SAVE_BITMAP_Y_GRANULARITY);

        xSaveBitmap = (int)((pSB->SavedBitmapPosition -
                (ySaveBitmap * (UINT32)UH_SAVE_BITMAP_WIDTH)) /
                UH_SAVE_BITMAP_Y_GRANULARITY);

        TRC_DBG((TB, _T("start pos %lu = (%d,%d)"),
                pSB->SavedBitmapPosition, xSaveBitmap, ySaveBitmap));

        // Split the bitmap rectangle into tiles that fit neatly into the
        // save bitmap. Each tile's dimensions are a multiple of the
        // xGranularity and yGranularity. Tiling is used so that a screen
        // bitmap rectangle can be saved even if it is taller than the
        // save bitmap. e.g.:
        //   Screen Bitmap  Save Bitmap
        //      111111      1111112222
        //      222222  ->  2233333344
        //      333333      4444------
        //      444444

        // The protocol uses inclusive co-ordinates, whereas Windows
        // has an exclusive co-ordinate system. Therefore, doctor
        // these co-ords to make sure the lower-right edges are included.
        ScreenLeft = (int)pSB->nLeftRect;
        ScreenTop = (int)pSB->nTopRect;
        ScreenRight = (int)pSB->nRightRect + 1;
        ScreenBottom = (int)pSB->nBottomRect + 1;

        // Start tiling in the top left corner of the Screen Bitmap rectangle.
        xScreenBitmap = ScreenLeft;
        yScreenBitmap = ScreenTop;

        // The height of the tile is the vertical granularity (or less - if
        // the Screen Bitmap rect is thinner than the granularity).
        cyTile = DC_MIN(ScreenBottom - yScreenBitmap,
                UH_SAVE_BITMAP_Y_GRANULARITY);

        // Repeat while there are more tiles in the Screen Bitmap rect to
        // process.
        while (yScreenBitmap < ScreenBottom) {
            // The width of the tile is the minimum of:
            // - the width of the remaining rectangle in the current strip of
            //   the Screen Bitmap rectangle
            // - the width of the remaining empty space in the Save Bitmap
            cxTile = DC_MIN(UH_SAVE_BITMAP_WIDTH - xSaveBitmap,
                    ScreenRight - xScreenBitmap);

            TRC_DBG((TB, _T("screen(%d,%d) save(%d,%d) cx(%d) cy(%d)"),
                    xScreenBitmap, yScreenBitmap, xSaveBitmap, ySaveBitmap,
                    cxTile, cyTile));

            // Copy this tile.
            if (pSB->Operation == SV_SAVEBITS) {
                TRC_NRM((TB, _T("Save a desktop bitmap")));
                if (!BitBlt(_pUh->_UH.hdcSaveScreenBitmap, xSaveBitmap, ySaveBitmap,
                        cxTile, cyTile, _pUh->_UH.hdcDraw, xScreenBitmap,
                        yScreenBitmap, SRCCOPY)) {
                    TRC_SYSTEM_ERROR("BitBlt");
                    TRC_ERR((TB, _T("Screen(%u,%u) Tile(%u,%u) Save(%u,%u)"),
                            xScreenBitmap, yScreenBitmap, cxTile, cyTile,
                            xSaveBitmap, ySaveBitmap));
                }

            }
            else {
                TRC_NRM((TB, _T("Restore a desktop bitmap")));
                if (!BitBlt(_pUh->_UH.hdcDraw, xScreenBitmap, yScreenBitmap, cxTile,
                        cyTile, _pUh->_UH.hdcSaveScreenBitmap, xSaveBitmap,
                        ySaveBitmap, SRCCOPY)) {
                    TRC_SYSTEM_ERROR("BitBlt");
                    TRC_ERR((TB, _T("Screen(%u,%u) Tile(%u,%u) Save(%u,%u)"),
                            xScreenBitmap, yScreenBitmap, cxTile, cyTile,
                            xSaveBitmap, ySaveBitmap));
                }

            }

            // Move to the next tile in the Screen Bitmap rectangle.
            xScreenBitmap += cxTile;
            if (xScreenBitmap >= ScreenRight) {
                xScreenBitmap = ScreenLeft;
                yScreenBitmap += cyTile;
                cyTile = DC_MIN(ScreenBottom - yScreenBitmap,
                        UH_SAVE_BITMAP_Y_GRANULARITY);
            }

            // Move to the next free space in the Save Bitmap.
            xSaveBitmap += UHROUNDUP(cxTile, UH_SAVE_BITMAP_X_GRANULARITY);
            if (xSaveBitmap >= UH_SAVE_BITMAP_WIDTH) {
                // Move to the next horizontal strip.
                TRC_DBG((TB,_T("Next strip")));
                xSaveBitmap = 0;
                ySaveBitmap += UHROUNDUP(cyTile, UH_SAVE_BITMAP_Y_GRANULARITY);
            }

            if (ySaveBitmap >= UH_SAVE_BITMAP_HEIGHT) {
                // Assert that we haven't been sent too much stuff. Quietly
                // stop saving data in the retail build.
                TRC_ABORT((TB, _T("Server out of bounds!")));
                break;
            }
        }

#ifdef DC_DEBUG
        // Draw hatching over the SSB data if the option is enabled.
        if (_pUh->_UH.hatchSSBOrderData)
            _pUh->UH_HatchRect((int)pSB->nLeftRect, (int)pSB->nTopRect,
                    (int)pSB->nRightRect, (int)pSB->nBottomRect,
                    UH_RGB_CYAN, UH_BRUSHTYPE_FDIAGONAL);
#endif

    }
    else {
        // This should never happen. We only advertise SSB support
        // if UH has successfully created this bitmap.
        // Fail to process the order in the retail build - the
        // server is probably being evil.
        TRC_ABORT((TB, _T("SSB bitmap null!")));
    }

    return hr;
    DC_END_FN();
}


/****************************************************************************/
// ODHandlePolyLine
//
// Order handler for PolyLine.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODHandlePolyLine(PUH_ORDER pOrder, 
    UINT16 uiVarDataLen, BOOL bBoundsSet)
{
    HRESULT hr = S_OK;
    POINT Points[ORD_MAX_POLYLINE_ENCODED_POINTS + 1];
    RECT BoundRect;
    DCCOLOR ZeroColor;
    PPOLYLINE_ORDER pPL = (PPOLYLINE_ORDER)pOrder->orderData;

    DC_BEGIN_FN("ODHandlePolyLine");

    TRC_NRM((TB, _T("ORDER: PolyLine xs=%d ys=%d rop2=%04X brc=0x%X ")
            _T("penc=%08lX #entr=%d"),
            pPL->XStart, pPL->YStart, pPL->ROP2, pPL->BrushCacheEntry,
            pPL->PenColor, pPL->NumDeltaEntries));

    ZeroColor.u.rgb.red = 0;
    ZeroColor.u.rgb.green = 0;
    ZeroColor.u.rgb.blue = 0;
    UHUseBkColor(ZeroColor, UH_COLOR_PALETTE, _pUh);
    UHUseBkMode(TRANSPARENT, _pUh);
    UHUseROP2((int)pPL->ROP2, _pUh);
    _pUh->UHUsePen(PS_SOLID, 1, pPL->PenColor, UH_COLOR_PALETTE);

    Points[0].x = (int)pPL->XStart;
    Points[0].y = (int)pPL->YStart;

    BoundRect.left = BoundRect.right = Points[0].x;
    BoundRect.top = BoundRect.bottom = Points[0].y;

    hr = ODDecodePathPoints(Points, &BoundRect, 
        pPL->CodedDeltaList.Deltas,
        (unsigned)pPL->NumDeltaEntries, ORD_MAX_POLYLINE_ENCODED_POINTS,
        pPL->CodedDeltaList.len, ORD_MAX_POLYLINE_CODEDDELTAS_LEN +
        ORD_MAX_POLYLINE_ZERO_FLAGS_BYTES, uiVarDataLen, !bBoundsSet);
    DC_QUIT_ON_FAIL(hr);

    // If we didn't get a rect across the net, use the one we calculated.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!bBoundsSet) {
        pOrder->dstRect.left = BoundRect.left;
        pOrder->dstRect.top = BoundRect.top;
        pOrder->dstRect.right = BoundRect.right;
        pOrder->dstRect.bottom = BoundRect.bottom;
        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pOrder->dstRect.left, pOrder->dstRect.top,
                pOrder->dstRect.right, pOrder->dstRect.bottom);
    }

    TIMERSTART;
    Polyline(_pUh->_UH.hdcDraw, Points, (UINT16)pPL->NumDeltaEntries + 1);
    TIMERSTOP;
    UPDATECOUNTER(FC_POLYLINE_TYPE);

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODHandlePolygonSC
//
// Order handler for Polygon with solic color brush.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODHandlePolygonSC(PUH_ORDER pOrder, 
    UINT16 uiVarDataLen, BOOL bBoundsSet)
{
    HRESULT hr = S_OK;
    POINT Points[ORD_MAX_POLYGON_ENCODED_POINTS + 1];
    RECT BoundRect;
    DCCOLOR ZeroColor;
    POLYGON_SC_ORDER FAR *pPG = (POLYGON_SC_ORDER FAR *)pOrder->orderData;

    DC_BEGIN_FN("ODHandlePolygonSC");

    TRC_NRM((TB, _T("ORDER: PolyGonSC xs=%d ys=%d rop2=%04X fill=%d ")
            _T("brushc=%08lX #entr=%d"),
            pPG->XStart, pPG->YStart, pPG->ROP2, pPG->FillMode,
            pPG->BrushColor, pPG->NumDeltaEntries));

    ZeroColor.u.rgb.red = 0;
    ZeroColor.u.rgb.green = 0;
    ZeroColor.u.rgb.blue = 0;
    UHUseBkColor(ZeroColor, UH_COLOR_PALETTE, _pUh);
    UHUseBkMode(TRANSPARENT, _pUh);
    UHUseROP2((int)pPG->ROP2, _pUh);
    _pUh->UHUsePen(PS_NULL, 1, ZeroColor, UH_COLOR_PALETTE);
    _pUh->UHUseSolidPaletteBrush(pPG->BrushColor);
    UHUseFillMode(pPG->FillMode,_pUh);

    Points[0].x = (int)pPG->XStart;
    Points[0].y = (int)pPG->YStart;

    BoundRect.left = BoundRect.right = Points[0].x;
    BoundRect.top = BoundRect.bottom = Points[0].y;

    hr = ODDecodePathPoints(Points, &BoundRect, 
        pPG->CodedDeltaList.Deltas,
        (unsigned)pPG->NumDeltaEntries, ORD_MAX_POLYGON_ENCODED_POINTS,
        pPG->CodedDeltaList.len, ORD_MAX_POLYGON_CODEDDELTAS_LEN +
        ORD_MAX_POLYGON_ZERO_FLAGS_BYTES, uiVarDataLen, !bBoundsSet);
    DC_QUIT_ON_FAIL(hr);

    // If we didn't get a rect across the net, use the one we calculated.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!bBoundsSet) {
        pOrder->dstRect.left = BoundRect.left;
        pOrder->dstRect.top = BoundRect.top;
        pOrder->dstRect.right = BoundRect.right;
        pOrder->dstRect.bottom = BoundRect.bottom;
        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pOrder->dstRect.left, pOrder->dstRect.top,
                pOrder->dstRect.right, pOrder->dstRect.bottom);
    }

    TIMERSTART;
    Polygon(_pUh->_UH.hdcDraw, Points, (UINT16)pPG->NumDeltaEntries + 1);
    TIMERSTOP;
    UPDATECOUNTER(FC_POLYGONSC_TYPE);

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODHandlePolygonCB
//
// Order handler for Polygon with complex brush.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODHandlePolygonCB(PUH_ORDER pOrder, 
    UINT16 uiVarDataLen, BOOL bBoundsSet)
{
    HRESULT hr = S_OK;
    POINT Points[ORD_MAX_POLYGON_ENCODED_POINTS + 1];
    RECT BoundRect;
    DCCOLOR ZeroColor;
    POLYGON_CB_ORDER FAR *pPG = (POLYGON_CB_ORDER FAR *)pOrder->orderData;

    DC_BEGIN_FN("ODHandlePolygonCB");

    TRC_NRM((TB, _T("ORDER: PolyGonCB xs=%d ys=%d rop2=%04X fill=%d ")
            _T("#entr=%d"),
            pPG->XStart, pPG->YStart, pPG->ROP2, pPG->FillMode,
            pPG->NumDeltaEntries));

    ZeroColor.u.rgb.red = 0;
    ZeroColor.u.rgb.green = 0;
    ZeroColor.u.rgb.blue = 0;
    UHUseBkColor(pPG->BackColor, UH_COLOR_PALETTE, _pUh);

    // If the brush is a hatched brush, we need to check the high bit (bit 7)
    // of ROP2 to see if the background mode should be transparent or opaque:
    // 1 means transparent mode, 0 means opaque mode
    if (pPG->BrushStyle == BS_HATCHED) {
        if (!(pPG->ROP2 & 0x80)) {
            UHUseBkMode(OPAQUE, _pUh);
        }
        else {
            UHUseBkMode(TRANSPARENT, _pUh);
        }
    }

    // Set the ROP2 for the forground mix mode
    UHUseROP2(((int)pPG->ROP2) & 0x1F, _pUh);

    UHUseTextColor(pPG->ForeColor, UH_COLOR_PALETTE, _pUh);
     _pUh->UHUsePen(PS_NULL, 1, ZeroColor, UH_COLOR_PALETTE);
    UHUseBrushOrg((int)pPG->BrushOrgX, (int)pPG->BrushOrgY, _pUh);
    hr = _pUh->UHUseBrush((unsigned)pPG->BrushStyle, (unsigned)pPG->BrushHatch,
            pPG->ForeColor, UH_COLOR_PALETTE, pPG->BrushExtra);
    DC_QUIT_ON_FAIL(hr);
    
    UHUseFillMode(pPG->FillMode, _pUh);

    Points[0].x = (int)pPG->XStart;
    Points[0].y = (int)pPG->YStart;

    BoundRect.left = BoundRect.right = Points[0].x;
    BoundRect.top = BoundRect.bottom = Points[0].y;

    hr = ODDecodePathPoints(Points, &BoundRect, 
        pPG->CodedDeltaList.Deltas,
        (unsigned)pPG->NumDeltaEntries, ORD_MAX_POLYGON_ENCODED_POINTS,
        pPG->CodedDeltaList.len, ORD_MAX_POLYGON_CODEDDELTAS_LEN +
        ORD_MAX_POLYGON_ZERO_FLAGS_BYTES, uiVarDataLen, !bBoundsSet);
    DC_QUIT_ON_FAIL(hr);

    // If we didn't get a rect across the net, use the one we calculated.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!bBoundsSet) {
        pOrder->dstRect.left = BoundRect.left;
        pOrder->dstRect.top = BoundRect.top;
        pOrder->dstRect.right = BoundRect.right;
        pOrder->dstRect.bottom = BoundRect.bottom;
        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pOrder->dstRect.left, pOrder->dstRect.top,
                pOrder->dstRect.right, pOrder->dstRect.bottom);
    }

    TIMERSTART;
    Polygon(_pUh->_UH.hdcDraw, Points, (UINT16)pPG->NumDeltaEntries + 1);
    TIMERSTOP;
    UPDATECOUNTER(FC_POLYGONCB_TYPE);

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODHandleEllipseSC
//
// Order handler for Ellipse with solid color brush.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODHandleEllipseSC(PUH_ORDER pOrder, 
    UINT16 uiVarDataLen, BOOL bBoundsSet)
{
    HRESULT hr = S_OK;
    unsigned FudgeFactor;
    DCCOLOR ZeroColor;
    PELLIPSE_SC_ORDER pEL = (PELLIPSE_SC_ORDER)pOrder->orderData;

    DC_BEGIN_FN("ODHandleEllipseSC");

    TRC_ASSERT((0==uiVarDataLen), 
        (TB, _T("Varaible length data in fixed length packet")));

    TRC_NRM((TB, _T("ORDER: Ellipse SC xs=%d ys=%d xe=%d ye=%d rop2=%04X ")
            _T("fillmode=%d penc=%08lX"),
            pEL->LeftRect, pEL->TopRect, pEL->RightRect, pEL->BottomRect,
            pEL->ROP2, pEL->FillMode, pEL->Color));

    ZeroColor.u.rgb.red = 0;
    ZeroColor.u.rgb.green = 0;
    ZeroColor.u.rgb.blue = 0;
    UHUseBkColor(ZeroColor, UH_COLOR_PALETTE, _pUh);
    UHUseBkMode(TRANSPARENT, _pUh);
    UHUseROP2((int)pEL->ROP2, _pUh);

    if (pEL->FillMode) {
        _pUh->UHUsePen(PS_NULL, 1, ZeroColor, UH_COLOR_PALETTE);
        _pUh->UHUseSolidPaletteBrush(pEL->Color);
        UHUseFillMode(pEL->FillMode, _pUh);

        // Because of the way the null pen works, we need to fudge the bottom
        // and right coords a bit.
        FudgeFactor = 1;
    }
    else {
        UINT32 extra[2] = { 0, 0 };

        _pUh->UHUsePen(PS_SOLID, 1, pEL->Color, UH_COLOR_PALETTE);
        hr = _pUh->UHUseBrush(BS_NULL, 0, ZeroColor, UH_COLOR_PALETTE,
                (BYTE FAR *)extra);
        DC_QUIT_ON_FAIL(hr);
        FudgeFactor = 0;
    }

    // If we didn't get a rect across the net, use the one we calculated.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!bBoundsSet) {
        pOrder->dstRect.left = (int)pEL->LeftRect;
        pOrder->dstRect.top = (int)pEL->TopRect;
        pOrder->dstRect.right = (int)pEL->RightRect;
        pOrder->dstRect.bottom = (int)pEL->BottomRect;
        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pOrder->dstRect.left, pOrder->dstRect.top,
                pOrder->dstRect.right, pOrder->dstRect.bottom);
    }

    TIMERSTART;
    // We add 1 to bottom and right here since the server sends an
    // inclusive rect to us but GDI is exclusive.
    Ellipse(_pUh->_UH.hdcDraw, (int)pEL->LeftRect, (int)pEL->TopRect,
            (int)pEL->RightRect + 1 + FudgeFactor,
            (int)pEL->BottomRect + 1 + FudgeFactor);
    TIMERSTOP;
    UPDATECOUNTER(FC_ELLIPSESC_TYPE);

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODHandleEllipseCB
//
// Order handler for Ellipse with complex brush.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODHandleEllipseCB(PUH_ORDER pOrder, UINT16 uiVarDataLen,
    BOOL bBoundsSet)
{
    HRESULT hr = S_OK;
    DCCOLOR ZeroColor;
    PELLIPSE_CB_ORDER pEL = (PELLIPSE_CB_ORDER)pOrder->orderData;

    DC_BEGIN_FN("ODHandleEllipseCB");

    TRC_ASSERT((0==uiVarDataLen), 
        (TB, _T("Varaible length data in fixed length packet")));

    TRC_NRM((TB, _T("ORDER: Ellipse CB xs=%d ys=%d xe=%d ye=%d rop2=%04X ")
            _T("fillmode=%d"),
            pEL->LeftRect, pEL->TopRect, pEL->RightRect, pEL->BottomRect,
            pEL->ROP2, pEL->FillMode));

    TRC_DBG((TB, _T("ORDER: Ellipse Brush %02X %02X BC %02x FC %02x ")
            _T("(%02x %02x %02x %02x %02x %02x %02x) rop %08lX"),
            (int)pEL->BrushStyle,
            (int)pEL->BrushHatch,
            (int)pEL->BackColor.u.index,
            (int)pEL->ForeColor.u.index,
            (int)pEL->BrushExtra[0],
            (int)pEL->BrushExtra[1],
            (int)pEL->BrushExtra[2],
            (int)pEL->BrushExtra[3],
            (int)pEL->BrushExtra[4],
            (int)pEL->BrushExtra[5],
            (int)pEL->BrushExtra[6],
            (int)pEL->ROP2));

    ZeroColor.u.rgb.red = 0;
    ZeroColor.u.rgb.green = 0;
    ZeroColor.u.rgb.blue = 0;
    _pUh->UHUsePen(PS_NULL, 1, ZeroColor, UH_COLOR_PALETTE);
    UHUseBkColor(pEL->BackColor, UH_COLOR_PALETTE, _pUh);

    // If the brush is a hatched brush, we need to check the high bit (bit 7)
    // of ROP2 to see if the background mode should be transparent or opaque:
    // 1 means transparent mode, 0 means opaque mode
    if (pEL->BrushStyle == BS_HATCHED) {
        if (!(pEL->ROP2 & 0x80)) {
            UHUseBkMode(OPAQUE, _pUh);
        }
        else {
            UHUseBkMode(TRANSPARENT, _pUh);
        }
    }

    // Set the ROP2 for the forground mix mode
    UHUseROP2((((int)pEL->ROP2) & 0x1F), _pUh);

    UHUseTextColor(pEL->ForeColor, UH_COLOR_PALETTE, _pUh);
    UHUseBrushOrg((int)pEL->BrushOrgX, (int)pEL->BrushOrgY, _pUh);
    
    
    hr = _pUh->UHUseBrush((unsigned)pEL->BrushStyle, (unsigned)pEL->BrushHatch,
                     pEL->ForeColor, UH_COLOR_PALETTE, pEL->BrushExtra);
    DC_QUIT_ON_FAIL(hr);

    UHUseFillMode(pEL->FillMode, _pUh);

    // If we didn't get a rect across the net, use the one we calculated.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!bBoundsSet) {
        pOrder->dstRect.left = (int)pEL->LeftRect;
        pOrder->dstRect.top = (int)pEL->TopRect;
        pOrder->dstRect.right = (int)pEL->RightRect;
        pOrder->dstRect.bottom = (int)pEL->BottomRect;
        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pOrder->dstRect.left, pOrder->dstRect.top,
                pOrder->dstRect.right, pOrder->dstRect.bottom);
    }

    TIMERSTART;
    // We add 1 to bottom and right here since the server sends an
    // inclusive rect to us but GDI is exclusive. Also, to offset
    // a null-pen bias at the bottom and right by adding another 1.
    Ellipse(_pUh->_UH.hdcDraw, (int)pEL->LeftRect, (int)pEL->TopRect,
            (int)pEL->RightRect + 2, (int)pEL->BottomRect + 2);
    TIMERSTOP;
    UPDATECOUNTER(FC_ELLIPSECB_TYPE);

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODDecodeFastIndex
//
// Fast-path order decoder for FastIndex orders.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODDecodeFastIndex(
        BYTE ControlFlags,
        BYTE FAR * FAR *ppFieldDecode,
        DCUINT dataLen,
        UINT32 FieldFlags)
{
    HRESULT hr = S_OK;
    unsigned OpEncodeFlags = 0;
    PUH_ORDER pOrder = (PUH_ORDER)_OD.lastFastIndex;
    LPINDEX_ORDER pGI = (LPINDEX_ORDER)(_OD.lastFastIndex +
            UH_ORDER_HEADER_SIZE);
    FAST_INDEX_ORDER FAR *pFI = (FAST_INDEX_ORDER FAR *)
            (_OD.lastFastIndex + UH_ORDER_HEADER_SIZE);
    BYTE FAR *pFieldDecode = *ppFieldDecode;
    BYTE FAR *pEnd = pFieldDecode + dataLen;

    DC_BEGIN_FN("ODDecodeFastIndex");

    // Copy initial non-coordinate fields if present.
    if (FieldFlags & 0x0001) {
        OD_DECODE_CHECK_READ(pFieldDecode, BYTE, pEnd, hr);
        pFI->cacheId = *pFieldDecode++;
    }
    if (FieldFlags & 0x0002) {
        OD_DECODE_CHECK_READ(pFieldDecode, UINT16, pEnd, hr);
        pFI->fDrawing = *((UINT16 UNALIGNED FAR *)pFieldDecode);
        pFieldDecode += 2;
    }
    if (FieldFlags & 0x0004) {
        OD_DECODE_CHECK_READ_MULT(pFieldDecode, BYTE, 3, pEnd, hr);
        pFI->BackColor.u.rgb.red = *pFieldDecode++;
        pFI->BackColor.u.rgb.green = *pFieldDecode++;
        pFI->BackColor.u.rgb.blue = *pFieldDecode++;
    }
    if (FieldFlags & 0x0008) {
        OD_DECODE_CHECK_READ_MULT(pFieldDecode, BYTE, 3, pEnd, hr);
        pFI->ForeColor.u.rgb.red = *pFieldDecode++;
        pFI->ForeColor.u.rgb.green = *pFieldDecode++;
        pFI->ForeColor.u.rgb.blue = *pFieldDecode++;
    }

    if (ControlFlags & TS_DELTA_COORDINATES) {
        // All coord fields are 1-byte signed deltas from the last values.
        if (FieldFlags & 0x0010) {
            OD_DECODE_CHECK_READ(pFieldDecode, char, pEnd, hr);
            pFI->BkLeft += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0020) {
            OD_DECODE_CHECK_READ(pFieldDecode, char, pEnd, hr);
            pFI->BkTop += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0040) {
            OD_DECODE_CHECK_READ(pFieldDecode, char, pEnd, hr);
            pFI->BkRight += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0080) {
            OD_DECODE_CHECK_READ(pFieldDecode, char, pEnd, hr);
            pFI->BkBottom += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }

        if (FieldFlags & 0x0100) {
            OD_DECODE_CHECK_READ(pFieldDecode, char, pEnd, hr);
            pFI->OpLeft += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0200) {
            OD_DECODE_CHECK_READ(pFieldDecode, char, pEnd, hr);
            pFI->OpTop += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0400) {
            OD_DECODE_CHECK_READ(pFieldDecode, char, pEnd, hr);
            pFI->OpRight += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x0800) {
            OD_DECODE_CHECK_READ(pFieldDecode, char, pEnd, hr);
            pFI->OpBottom += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }

        if (FieldFlags & 0x1000) {
            OD_DECODE_CHECK_READ(pFieldDecode, char, pEnd, hr);
            pFI->x += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
        if (FieldFlags & 0x2000) {
            OD_DECODE_CHECK_READ(pFieldDecode, char, pEnd, hr);
            pFI->y += *((char FAR *)pFieldDecode);
            pFieldDecode++;
        }
    }
    else {
        // All coord fields are 2-byte values.sign-extended from the output.
        if (FieldFlags & 0x0010) {
            OD_DECODE_CHECK_READ(pFieldDecode, INT16, pEnd, hr);
            pFI->BkLeft = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0020) {
            OD_DECODE_CHECK_READ(pFieldDecode, INT16, pEnd, hr);
            pFI->BkTop = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0040) {
            OD_DECODE_CHECK_READ(pFieldDecode, INT16, pEnd, hr);
            pFI->BkRight = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0080) {
            OD_DECODE_CHECK_READ(pFieldDecode, INT16, pEnd, hr);
            pFI->BkBottom = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }

        if (FieldFlags & 0x0100) {
            OD_DECODE_CHECK_READ(pFieldDecode, INT16, pEnd, hr);
            pFI->OpLeft = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0200) {
            OD_DECODE_CHECK_READ(pFieldDecode, INT16, pEnd, hr);
            pFI->OpTop = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0400) {
            OD_DECODE_CHECK_READ(pFieldDecode, INT16, pEnd, hr);
            pFI->OpRight = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x0800) {
            OD_DECODE_CHECK_READ(pFieldDecode, INT16, pEnd, hr);
            pFI->OpBottom = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }

        if (FieldFlags & 0x1000) {
            OD_DECODE_CHECK_READ(pFieldDecode, INT16, pEnd, hr);
            pFI->x = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
        if (FieldFlags & 0x2000) {
            OD_DECODE_CHECK_READ(pFieldDecode, INT16, pEnd, hr);
            pFI->y = *((INT16 UNALIGNED FAR *)pFieldDecode);
            pFieldDecode += 2;
        }
    }

    if (FieldFlags & 0x4000) {
        // First byte is the number of following bytes.

        OD_DECODE_CHECK_READ(pFieldDecode, BYTE, pEnd, hr);
        pFI->variableBytes.len = *pFieldDecode++;

        // The structure is defined with 255 elements
        if (255 < pFI->variableBytes.len) {
            TRC_ABORT(( TB, _T("VARIBLE_INDEXBYTES len too great; len %u"),
                pFI->variableBytes.len ));
            hr = E_TSC_CORE_LENGTH;
            DC_QUIT;
        }

        OD_DECODE_CHECK_READ_MULT(pFieldDecode, BYTE, pFI->variableBytes.len,
            pEnd, hr);
        memcpy(pFI->variableBytes.arecs, pFieldDecode,
                pFI->variableBytes.len);
        pFieldDecode += pFI->variableBytes.len;
    }

    // Return the incremented pointer to the main routine.
    *ppFieldDecode = pFieldDecode;

    // If we've not already set the bounds (the order didn't contain
    // any), set the bounds to the blt rect and reset the clip region.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!(ControlFlags & TS_BOUNDS)) {
        if (pFI->OpTop < pFI->OpBottom) {
            pOrder->dstRect.right = (int)pFI->OpRight;
            pOrder->dstRect.left = (int)pFI->OpLeft;
            pOrder->dstRect.top = (int)pFI->OpTop;
            pOrder->dstRect.bottom = (int)pFI->OpBottom;
        }
        else {
            // Since we encode OpRect fields, we have to 
            // decode it to get the correct bound rect.
            if (pFI->OpTop == 0xF) {
                // Opaque rect is same as bk rect
                pOrder->dstRect.left = (int)pFI->BkLeft;
                pOrder->dstRect.top = (int)pFI->BkTop;
                pOrder->dstRect.right = (int)pFI->BkRight;
                pOrder->dstRect.bottom = (int)pFI->BkBottom;
            }
            else if (pFI->OpTop == 0xD) {
                // Opaque rect is same as bk rect except 
                // OpRight stored in OpTop field
                pOrder->dstRect.left = (int)pFI->BkLeft;
                pOrder->dstRect.top = (int)pFI->BkTop;
                pOrder->dstRect.right = (int)pFI->OpRight;
                pOrder->dstRect.bottom = (int)pFI->BkBottom;
            }
            else {
                // We take the Bk rect as bound rect
                pOrder->dstRect.right = (int)pFI->BkRight;
                pOrder->dstRect.left = (int)pFI->BkLeft;
                pOrder->dstRect.top = (int)pFI->BkTop;
                pOrder->dstRect.bottom = (int)pFI->BkBottom;
            }
        }

        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pOrder->dstRect.left, pOrder->dstRect.top,
                pOrder->dstRect.right, pOrder->dstRect.bottom);
    }

    // pGI and pFI are different views of the same order memory.
    // We translate to the regular glyph index order format for display
    // handling, then translate back.
    pGI->cacheId = (BYTE)(pFI->cacheId & 0xF);  // Mask out high bits for future use.
    pGI->flAccel = (BYTE)(pFI->fDrawing >> 8);
    pGI->ulCharInc = (BYTE)(pFI->fDrawing & 0xFF);
    pGI->fOpRedundant = 0;

    // For Fast Index order, we need to decode for x, y and 
    // opaque rect.
    if (pFI->OpBottom == INT16_MIN) {
        OpEncodeFlags = (unsigned)pFI->OpTop;
        if (OpEncodeFlags == 0xF) {
            // Opaque rect is redundant
            pGI->OpLeft = pFI->BkLeft;
            pGI->OpTop = pFI->BkTop;
            pGI->OpRight = pFI->BkRight;
            pGI->OpBottom = pFI->BkBottom;
        }
        else if (OpEncodeFlags == 0xD) {
            // Opaque rect is redundant except OpRight
            // which is stored in OpTop
            pGI->OpLeft = pFI->BkLeft;
            pGI->OpTop = pFI->BkTop;
            pGI->OpRight = pFI->OpRight;
            pGI->OpBottom = pFI->BkBottom;
        }
    }

    if (pFI->x == INT16_MIN)
        pGI->x = pFI->BkLeft;
    if (pFI->y == INT16_MIN)
        pGI->y = pFI->BkTop;

    TRC_NRM((TB, _T("ORDER: Glyph index cacheId %u flAccel %u ")
            _T("ulCharInc %u fOpRedundant %u"),
            pGI->cacheId, (unsigned)pGI->flAccel, (unsigned)pGI->ulCharInc,
            (unsigned)pGI->fOpRedundant));
    TRC_NRM((TB, _T("       bc %08lX fc %08lX Bk(%ld,%ld)-(%ld,%ld) ")
            _T("Op(%ld,%ld)-(%ld,%ld)"),
            pGI->BackColor, pGI->ForeColor,
            pGI->BkLeft, pGI->BkTop, pGI->BkRight, pGI->BkBottom,
            pGI->OpLeft, pGI->OpTop, pGI->OpRight, pGI->OpBottom));
    TRC_NRM((TB, _T("       BrushOrg x %ld y %ld BrushStyle %lu x %ld y %ld"),
            pGI->BrushOrgX, pGI->BrushOrgY,
            pGI->BrushStyle, pGI->x, pGI->y));

    TIMERSTART;
    hr = _pUh->UHDrawGlyphOrder(pGI, &pFI->variableBytes);
    TIMERSTOP;
    UPDATECOUNTER(FC_FAST_INDEX_TYPE);
    DC_QUIT_ON_FAIL(hr);

    // Now we need to put bits back
    if (OpEncodeFlags) {
        if (OpEncodeFlags == 0xF) {
            pGI->OpLeft = 0;
            pGI->OpTop = OpEncodeFlags;
            pGI->OpRight = 0;
            pGI->OpBottom = INT16_MIN;
        }
        else if (OpEncodeFlags == 0xD) {
            pGI->OpLeft = 0;
            pGI->OpTop = OpEncodeFlags;
            pGI->OpRight = pGI->OpRight;
            pGI->OpBottom = INT16_MIN;
        }
    }

    if (pFI->x == pFI->BkLeft)
        pGI->x = INT16_MIN;
    if (pFI->y == pFI->BkTop)
        pGI->y = INT16_MIN;

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODHandleFastGlyph
//
// Order handler for FastGlyph orders.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODHandleFastGlyph(PUH_ORDER pOrder, UINT16 uiVarDataLen,
    BOOL bBoundsSet)
{
    HRESULT hr = S_OK;
    unsigned OpEncodeFlags = 0;
    VARIABLE_INDEXBYTES VariableBytes;
    LPINDEX_ORDER pGI = (LPINDEX_ORDER)pOrder->orderData;
    LPFAST_GLYPH_ORDER pFG = (LPFAST_GLYPH_ORDER)pOrder->orderData;

    DC_BEGIN_FN("ODHandleFastGlyph");

    // If we've not already set the bounds (the order didn't contain
    // any), set the bounds to the blt rect and reset the clip region.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!bBoundsSet) {
        if (pFG->OpTop < pFG->OpBottom) {
            pOrder->dstRect.right = (int)pFG->OpRight;
            pOrder->dstRect.left = (int)pFG->OpLeft;
            pOrder->dstRect.top = (int)pFG->OpTop;
            pOrder->dstRect.bottom = (int)pFG->OpBottom;
        }
        else {
            // Since we encode OpRect fields, we have to 
            // decode it to get the correct bound rect.
            if (pFG->OpTop == 0xF) {
                // Opaque rect is same as bk rect
                pOrder->dstRect.left = (int)pFG->BkLeft;
                pOrder->dstRect.top = (int)pFG->BkTop;
                pOrder->dstRect.right = (int)pFG->BkRight;
                pOrder->dstRect.bottom = (int)pFG->BkBottom;
            }
            else if (pFG->OpTop == 0xD) {
                // Opaque rect is same as bk rect except 
                // OpRight stored in OpTop field
                pOrder->dstRect.left = (int)pFG->BkLeft;
                pOrder->dstRect.top = (int)pFG->BkTop;
                pOrder->dstRect.right = (int)pFG->OpRight;
                pOrder->dstRect.bottom = (int)pFG->BkBottom;
            }
            else {
                // We take the Bk rect as bound rect
                pOrder->dstRect.right = (int)pFG->BkRight;
                pOrder->dstRect.left = (int)pFG->BkLeft;
                pOrder->dstRect.top = (int)pFG->BkTop;
                pOrder->dstRect.bottom = (int)pFG->BkBottom;
            }
        }

        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pOrder->dstRect.left, pOrder->dstRect.top,
                pOrder->dstRect.right, pOrder->dstRect.bottom);
    }

    // pGI and pFG are different views of the same order memory.
    // We translate to the regular glyph index order format for display
    // handling, then translate back.

    pGI->cacheId = (BYTE)(pFG->cacheId & 0xF);  // Mask out high bits for future use.

    OD_DECODE_CHECK_VARIABLE_DATALEN(uiVarDataLen, pFG->variableBytes.len);

    // The structure is defined with 255 elements
    if (255 < pFG->variableBytes.len) {
        TRC_ABORT(( TB, _T("VARIBLE_INDEXBYTES len too great; len %u"),
            pFG->variableBytes.len ));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }

    if (pFG->variableBytes.len < 1) {
        TRC_ERR((TB,_T("No variable bytes")));
        DC_QUIT;
    }

    if (pFG->variableBytes.len > 1) {
        // SECURITY - the cacheId is verify in call to UHProcessCacheGlyphOrderRev2
        hr = _pUh->UHProcessCacheGlyphOrderRev2(pGI->cacheId, 1, 
                pFG->variableBytes.glyphData,
                (unsigned)pFG->variableBytes.len);
        DC_QUIT_ON_FAIL(hr);
    }

    pGI->flAccel = (BYTE)(pFG->fDrawing >> 8);
    pGI->ulCharInc = (BYTE)(pFG->fDrawing & 0xff);
    pGI->fOpRedundant = 0;

    // For Fast Index order, we need to decode for x, y and 
    // opaque rect.
    if (pFG->OpBottom == INT16_MIN) {
        OpEncodeFlags = (unsigned)pFG->OpTop;
        if (OpEncodeFlags == 0xF) {
            // Opaque rect is redundant
            pGI->OpLeft = pFG->BkLeft;
            pGI->OpTop = pFG->BkTop;
            pGI->OpRight = pFG->BkRight;
            pGI->OpBottom = pFG->BkBottom;
        }
        else if (OpEncodeFlags == 0xD) {
            // Opaque rect is redundant except OpRight
            // which is stored in OpTop
            pGI->OpLeft = pFG->BkLeft;
            pGI->OpTop = pFG->BkTop;
            pGI->OpRight = pFG->OpRight;
            pGI->OpBottom = pFG->BkBottom;
        }
    }

    if (pFG->x == INT16_MIN)
        pGI->x = pFG->BkLeft;
    if (pFG->y == INT16_MIN)
        pGI->y = pFG->BkTop;

    // Setup index order for the glyph
    VariableBytes.len = 2;
    VariableBytes.arecs[0].byte = (BYTE)pFG->variableBytes.glyphData[0];
    VariableBytes.arecs[1].byte = 0;

    TIMERSTART;
    hr = _pUh->UHDrawGlyphOrder(pGI, &VariableBytes);
    TIMERSTOP;
    UPDATECOUNTER(FC_FAST_INDEX_TYPE);
    DC_QUIT_ON_FAIL(hr);

    // Now we need to put bits back
    if (OpEncodeFlags) {
        if (OpEncodeFlags == 0xF) {
            pGI->OpLeft = 0;
            pGI->OpTop = OpEncodeFlags;
            pGI->OpRight = 0;
            pGI->OpBottom = INT16_MIN;
        }
        else if (OpEncodeFlags == 0xD) {
            pGI->OpLeft = 0;
            pGI->OpTop = OpEncodeFlags;
            pGI->OpRight = pGI->OpRight;
            pGI->OpBottom = INT16_MIN;
        }
    }

    if (pFG->x == pFG->BkLeft)
        pGI->x = INT16_MIN;
    if (pFG->y == pFG->BkTop)
        pGI->y = INT16_MIN;

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODHandleGlyphIndex
//
// Order handler for GlyphIndex orders.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODHandleGlyphIndex(PUH_ORDER pOrder, 
    UINT16 uiVarDataLen, BOOL bBoundsSet)
{
    HRESULT hr = S_OK;
    LPINDEX_ORDER pGI = (LPINDEX_ORDER)pOrder->orderData;

    DC_BEGIN_FN("ODHandleGlyphIndex");

    // If we've not already set the bounds (the order didn't contain
    // any), set the bounds to the blt rect and reset the clip region.
    // This rect might be needed later to add to the clip region for
    // updating the shadow buffer to the screen.
    if (!bBoundsSet) {
        if (pGI->OpTop < pGI->OpBottom) {
            pOrder->dstRect.right = (int)pGI->OpRight;
            pOrder->dstRect.left = (int)pGI->OpLeft;
            pOrder->dstRect.top = (int)pGI->OpTop;
            pOrder->dstRect.bottom = (int)pGI->OpBottom;
        }
        else {
            pOrder->dstRect.right = (int)pGI->BkRight;
            pOrder->dstRect.left = (int)pGI->BkLeft;
            pOrder->dstRect.top = (int)pGI->BkTop;
            pOrder->dstRect.bottom = (int)pGI->BkBottom;
        }

        _pUh->UH_ResetClipRegion();
    }
    else {
        _pUh->UH_SetClipRegion(pOrder->dstRect.left, pOrder->dstRect.top,
                pOrder->dstRect.right, pOrder->dstRect.bottom);
    }

    // Handle the opaque rectangle if given.
    if (pGI->fOpRedundant) {
        pGI->OpTop = pGI->BkTop;
        pGI->OpRight = pGI->BkRight;
        pGI->OpBottom = pGI->BkBottom;
        pGI->OpLeft = pGI->BkLeft;
    }

    TRC_NRM((TB, _T("ORDER: Glyph index cacheId %u flAccel %u ")
            _T("ulCharInc %u fOpRedundant %u"),
            pGI->cacheId, (unsigned)pGI->flAccel, (unsigned)pGI->ulCharInc,
            (unsigned)pGI->fOpRedundant));
    TRC_NRM((TB, _T("       bc %08lX fc %08lX Bk(%ld,%ld)-(%ld,%ld) ")
            _T("Op(%ld,%ld)-(%ld,%ld)"),
            pGI->BackColor, pGI->ForeColor,
            pGI->BkLeft, pGI->BkTop, pGI->BkRight, pGI->BkBottom,
            pGI->OpLeft, pGI->OpTop, pGI->OpRight, pGI->OpBottom));
    TRC_NRM((TB, _T("       BrushOrg x %ld y %ld BrushStyle %lu x %ld y %ld"),
            pGI->BrushOrgX, pGI->BrushOrgY,
            pGI->BrushStyle, pGI->x, pGI->y));

    OD_DECODE_CHECK_VARIABLE_DATALEN(uiVarDataLen, pGI->variableBytes.len);    

    // The structure is defined with 255 elements
    if (255 < pGI->variableBytes.len) {
        TRC_ABORT((TB, _T("Variable bytes length too great; %u"), 
            pGI->variableBytes.len));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }

    TIMERSTART;
    hr = _pUh->UHDrawGlyphOrder(pGI, &pGI->variableBytes);
    TIMERSTOP;
    UPDATECOUNTER(FC_INDEX_TYPE);
    DC_QUIT_ON_FAIL(hr);

    // Restore the correct last order data.
    if (pGI->fOpRedundant) {
        pGI->OpTop = 0;
        pGI->OpRight = 0;
        pGI->OpBottom = 0;
        pGI->OpLeft = 0;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODDecodeMultipleRects
//
// Translates wire protocol multiple clipping rects to unpacked form.
/****************************************************************************/

#define DECODE_DELTA()                                              \
    if (bDeltaZero) {                                               \
        Delta = 0;                                                  \
    }                                                               \
    else {             \
        OD_DECODE_CHECK_READ(pCurDecode, char, pDataEnd, hr); \
        \
        /* Sign-extend the low 7 bits of first byte into int.   */  \
        Delta = (int)((char)((*pCurDecode & 0x7F) |                 \
                            ((*pCurDecode & 0x40) << 1)));          \
                                                                    \
        /* Get 2nd  byte if present.                            */  \
        if (*pCurDecode++ & ORD_CLIP_RECTS_LONG_DELTA)            {  \
            OD_DECODE_CHECK_READ(pCurDecode, BYTE, pDataEnd, hr); \
            Delta = (Delta << 8) | (*pCurDecode++);                 \
        } \
    }                                                               \

HRESULT COD::ODDecodeMultipleRects(
        RECT   *Rects,
        UINT32 nDeltaEntries,
        CLIP_RECT_VARIABLE_CODEDDELTALIST FAR *codedDeltaList,
        UINT16 uiVarDataLen)
{
    int           Delta;
    BYTE          *ZeroFlags;
    BOOL          bDeltaZero;
    unsigned      i;
    unsigned char *pCurDecode;
    BYTE            *pDataEnd;
    HRESULT hr = S_OK;

    DC_BEGIN_FN("ODDecodeMultipleRects");

    TRC_ASSERT((nDeltaEntries > 0), (TB,_T("No rects passed in")));
       
    OD_DECODE_CHECK_VARIABLE_DATALEN(uiVarDataLen, codedDeltaList->len);

    // SECURITY: Because the OD_Decode already wrote this varible data into
    // the lastOrderBuffer, we should be sure that we didn't get too much
    // data at this point
    if (codedDeltaList->len > ORD_MAX_CLIP_RECTS_CODEDDELTAS_LEN +
        ORD_MAX_CLIP_RECTS_ZERO_FLAGS_BYTES) {
        TRC_ABORT((TB, _T("codedDeltaList length too great; [got %u, max %u]"),
            codedDeltaList->len, ORD_MAX_CLIP_RECTS_CODEDDELTAS_LEN +
            ORD_MAX_CLIP_RECTS_ZERO_FLAGS_BYTES));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }

    if (nDeltaEntries > ORD_MAX_ENCODED_CLIP_RECTS) {
        TRC_ABORT((TB, _T("number deltas too great; [got %u, max %u]"),
            nDeltaEntries, ORD_MAX_ENCODED_CLIP_RECTS));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;        
    } 

    pDataEnd = ((BYTE*)codedDeltaList->Deltas) + codedDeltaList->len;

    // Get pointers to the zero flags placed before the encoded deltas, and
    // the encoded deltas.  Note the zero flags take 2 bits per encode
    // point, 2 points per rectangle, rounded up to the nearest byte.
    ZeroFlags  = codedDeltaList->Deltas;
    pCurDecode = codedDeltaList->Deltas + ((nDeltaEntries + 1) / 2);

    // All access to ZeroFlags are checked with this
    CHECK_READ_N_BYTES(ZeroFlags, pDataEnd, (BYTE*)pCurDecode-(BYTE*)ZeroFlags, hr,
        (TB, _T("Read past end of data")));

    // The first points are encoded as a delta from (0,0).
    bDeltaZero = ZeroFlags[0] & ORD_CLIP_RECTS_XLDELTA_ZERO;
    DECODE_DELTA();
    TRC_DBG((TB, _T("Start x left %d"), Delta));
    Rects[0].left = Delta;

    bDeltaZero = ZeroFlags[0] & ORD_CLIP_RECTS_YTDELTA_ZERO;
    DECODE_DELTA();
    TRC_DBG((TB, _T("Start y top %d"), Delta));
    Rects[0].top = Delta;

    bDeltaZero = ZeroFlags[0] & ORD_CLIP_RECTS_XRDELTA_ZERO;
    DECODE_DELTA();
    TRC_DBG((TB, _T("Start x right %d"), Delta));
    Rects[0].right = Rects[0].left + Delta;

    bDeltaZero = ZeroFlags[0] & ORD_CLIP_RECTS_YBDELTA_ZERO;
    DECODE_DELTA();
    TRC_DBG((TB, _T("Start y %d"), Delta));
    Rects[0].bottom = Rects[0].top + Delta;

    TRC_NRM((TB,
             _T("Rectangle #0  l,t %d,%d - r,b %d,%d"),
            (int)Rects[0].left,
            (int)Rects[0].top,
            (int)Rects[0].right,
            (int)Rects[0].bottom));

    // Decode the encoded point deltas into regular POINTs to draw.
    for (i = 1; i < nDeltaEntries; i++) {
        // Decode the top left corner.
        bDeltaZero = ZeroFlags[i / 2] &
                    (ORD_CLIP_RECTS_XLDELTA_ZERO >> (4 * (i & 0x01)));
        DECODE_DELTA();
        TRC_DBG((TB, _T("Delta x left %d"), Delta));
        Rects[i].left = Rects[i - 1].left + Delta;

        bDeltaZero = ZeroFlags[i / 2] &
                    (ORD_CLIP_RECTS_YTDELTA_ZERO >> (4 * (i & 0x01)));
        DECODE_DELTA();
        TRC_DBG((TB, _T("Delta y top %d"), Delta));
        Rects[i].top = Rects[i - 1].top + Delta;

        // and now the bottom right - note this is relative to the current
        // top left rather than to the previous bottom right
        bDeltaZero = ZeroFlags[i / 2] &
                    (ORD_CLIP_RECTS_XRDELTA_ZERO >> (4 * (i & 0x01)));
        DECODE_DELTA();
        TRC_DBG((TB, _T("Delta x right %d"), Delta));
        Rects[i].right = Rects[i].left + Delta;

        bDeltaZero = ZeroFlags[i / 2] &
                    (ORD_CLIP_RECTS_YBDELTA_ZERO >> (4 * (i & 0x01)));
        DECODE_DELTA();
        TRC_DBG((TB, _T("Delta y bottom %d"), Delta));
        Rects[i].bottom = Rects[i].top + Delta;

        TRC_NRM((TB,
                _T("Drawing rectangle #%d  l,t %d,%d - r,b %d,%d"),
                i,
                (int)Rects[i].left,
                (int)Rects[i].top,
                (int)Rects[i].right,
                (int)Rects[i].bottom));
    }

DC_EXIT_POINT:    
    DC_END_FN();
    return hr;
}

/****************************************************************************/
// ODDecodePathPoints
//
// Decode encoded polygon and ellipse path points.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODDecodePathPoints(
        POINT *Points,
        RECT  *BoundRect,
        BYTE FAR *pData,
        unsigned NumDeltaEntries,
        unsigned MaxNumDeltaEntries,
        unsigned dataLen, 
        unsigned MaxDataLen,
        UINT16 uiVarDataLen,
        BOOL fUnClipped)
{
    HRESULT hr = S_OK;
    int Delta;
    BOOL bDeltaZero;
    unsigned i;
    BYTE FAR * ZeroFlags;
    BYTE FAR * pCurDecode;
    BYTE FAR * pEnd;

    DC_BEGIN_FN("ODDecodePathPoints");

    OD_DECODE_CHECK_VARIABLE_DATALEN(uiVarDataLen, (UINT16)dataLen);

    if (NumDeltaEntries > MaxNumDeltaEntries) {
        TRC_ABORT((TB, _T("NumDeltaEntries too great; [got %u max %u]"),
            NumDeltaEntries, MaxNumDeltaEntries));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }

    if (dataLen > MaxDataLen) {
        TRC_ABORT((TB,_T("Received PolyLine with too-large internal length; ")
            _T("[got %u max %u]"), dataLen, MaxDataLen));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }

    // Get pointers to the zero flags placed before the encoded
    // deltas, and the encoded deltas. Note the zero flags take 2
    // bits per encode point, rounded up to the nearest byte.
    ZeroFlags = pData;
    pCurDecode = pData +
            ((NumDeltaEntries + 3) / 4);
    pEnd = ZeroFlags + dataLen;

    CHECK_READ_N_BYTES(ZeroFlags, pEnd, (BYTE*)pCurDecode-(BYTE*)ZeroFlags, hr,
            (TB, _T("Read past end of data")));

    // Decode the encoded point deltas into regular POINTs to draw.
    for (i = 0; i < NumDeltaEntries; i++) {
        // Determine if the X delta is zero by checking the 0 flag.
        bDeltaZero = ZeroFlags[i / 4] &
                     (ORD_POLYLINE_XDELTA_ZERO >> (2 * (i & 0x03)));
        if (bDeltaZero) {
            Delta = 0;
        }
        else {
            OD_DECODE_CHECK_READ(pCurDecode, char, pEnd, hr);
            
            // Sign-extend the low 7 bits of first X byte into int.
            Delta = (int)((char)((*pCurDecode & 0x7F) |
                                 ((*pCurDecode & 0x40) << 1)));

            // Get 2nd X byte if present.
            if (*pCurDecode++ & ORD_POLYLINE_LONG_DELTA) {
                OD_DECODE_CHECK_READ(pCurDecode, BYTE, pEnd, hr);               
                Delta = (Delta << 8) | (*pCurDecode++);
            }
        }
        Points[i + 1].x = Points[i].x + Delta;

        // Determine if the Y delta is zero by checking the 0 flag.
        bDeltaZero = ZeroFlags[i / 4] &
                     (ORD_POLYLINE_YDELTA_ZERO >> (2 * (i & 0x03)));
        if (bDeltaZero) {
            Delta = 0;
        }
        else {
            OD_DECODE_CHECK_READ(pCurDecode, char, pEnd, hr);
            
            // Sign-extend the low 7 bits of first Y byte into int.
            Delta = (int)((char)((*pCurDecode & 0x7F) |
                                 ((*pCurDecode & 0x40) << 1)));

            // Get 2nd Y byte if present.
            if (*pCurDecode++ & ORD_POLYLINE_LONG_DELTA) {
                OD_DECODE_CHECK_READ(pCurDecode, BYTE, pEnd, hr);
                Delta = (Delta << 8) | (*pCurDecode++);
            }
        }
        Points[i + 1].y = Points[i].y + Delta;

        if (fUnClipped) {
            // Update the calculated bounding rect.
            if (Points[i + 1].x < BoundRect->left)
                BoundRect->left = Points[i + 1].x;
            else if (Points[i + 1].x > BoundRect->right)
                BoundRect->right = Points[i + 1].x;

            if (Points[i + 1].y < BoundRect->top)
                BoundRect->top = Points[i + 1].y;
            else if (Points[i + 1].y > BoundRect->bottom)
                BoundRect->bottom = Points[i + 1].y;
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// ODDecodeFieldSingle
//
// Copies a single field entry from src to dest with field size
// conversion as necessary.
/****************************************************************************/
HRESULT DCINTERNAL COD::ODDecodeFieldSingle(
        PPDCUINT8 ppSrc,
        PDCVOID   pDst,
        unsigned  srcFieldLength,
        unsigned  dstFieldLength,
        BOOL      signedValue)
{
    HRESULT hr = S_OK;
    DC_BEGIN_FN("ODDecodeFieldSingle");

    if (dstFieldLength < srcFieldLength) {
        TRC_ABORT((TB, _T("Src size greater than dest")));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }

    // If the source and destination field lengths are the same, we can
    // just do a copy (no type conversion required).
    if (srcFieldLength == dstFieldLength) {
        memcpy(pDst, *ppSrc, dstFieldLength);
    }
    else {
        // 3 types left to consider:
        //    8 bit -> 16 bit
        //    8 bit -> 32 bit
        //   16 bit -> 32 bit
        //
        // We also have to get the signed / unsigned attributes correct. If
        // we try to promote a signed value using unsigned pointers, we
        // will get the wrong result.
        //
        // e.g. Consider converting the value -1 from a INT16 to INT32
        //      using unsigned pointers.
        //
        //      -1 -> DCUINT16 == 65535
        //         -> DCUINT32 == 65535
        //         -> DCINT32  == 65535

        // Most common among non-coord entries: 1-byte source.
        if (srcFieldLength == 1) {
            // Most common: 4-byte destination.
            if (dstFieldLength == 4) {
                // Most common: unsigned
                if (!signedValue)
                    *((UINT32 FAR *)pDst) = *((BYTE FAR *)*ppSrc);
                else
                    *((INT32 FAR *)pDst) = *((char FAR *)*ppSrc);
            }
            else if (dstFieldLength == 2) {
                if (!signedValue)
                    *((UINT16 FAR *)pDst) = *((UINT16 UNALIGNED FAR *)*ppSrc);
                else
                    *((INT16 FAR *)pDst) = *((short UNALIGNED FAR *)*ppSrc);
            }
            else {
                TRC_ABORT((TB,_T("src size 1->dst %u"), dstFieldLength));                
                hr = E_TSC_CORE_LENGTH;
                DC_QUIT;
            }
        }
        
        // Only thing left should be 2-byte to 4-byte.
        else if (srcFieldLength == 2 && dstFieldLength == 4) {
            if (!signedValue)
                *((UINT32 FAR *)pDst) = *((UINT16 UNALIGNED FAR *)*ppSrc);
            else
                *((INT32 FAR *)pDst) = *((short UNALIGNED FAR *)*ppSrc);
        }
        else {
            TRC_ABORT((TB,_T("src=%u, dst=%u - unexpected"), srcFieldLength,
                    dstFieldLength));            
            hr = E_TSC_CORE_LENGTH;
            DC_QUIT;
        }
    }

    *ppSrc += srcFieldLength;

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


#ifdef OS_WINCE

BOOL DCINTERNAL COD::ODHandleAlwaysOnTopRects(LPMULTI_SCRBLT_ORDER pSB)
{
    DC_BEGIN_FN("ODHandleAlwaysOnTopRects");

    BOOL bIntersect = FALSE;
    RECT rectSrc, rectIntersect, rectInvalid;

    SetRect(&rectSrc, (int)pSB->nXSrc, (int)pSB->nYSrc, 
        (int)(pSB->nXSrc + pSB->nWidth), (int)(pSB->nYSrc + pSB->nHeight));

    for (DWORD j=0; j<_pUh->_UH.ulNumAOTRects; j++)
    {
        if (IntersectRect(&rectIntersect, &rectSrc, &(_pUh->_UH.rcaAOT[j])))
        {
            bIntersect = TRUE;
            break;
        }
    }

    if (!bIntersect)
    {
        GetUpdateRect(_pOp->OP_GetOutputWindowHandle(), &rectInvalid, FALSE);
        bIntersect = (IntersectRect(&rectIntersect, &rectSrc, &rectInvalid));
    }

    if (bIntersect)
    {
        SetRect(&rectInvalid, pSB->nLeftRect, pSB->nTopRect, 
                pSB->nLeftRect+pSB->nWidth, pSB->nTopRect+pSB->nHeight);
        InvalidateRect(_pOp->OP_GetOutputWindowHandle(), &rectInvalid, FALSE);
    }
	
    DC_END_FN();
    
    return bIntersect;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\orapi.cpp ===
/**MOD+**********************************************************************/
/* Module:    or.cpp                                                        */
/*                                                                          */
/* Purpose:   Output Requestor API                                          */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>

extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "worapi"
#include <atrcapi.h>
}

#include "or.h"

COR::COR(CObjs* objs)
{
    _pClientObjects = objs;
}

COR::~COR()
{
}

/**PROC+*********************************************************************/
/* Name:    OR_Init                                                         */
/*                                                                          */
/* Purpose: Initialize OR                                                   */
/*                                                                          */
/* Returns: Nothing                                                         */
/*                                                                          */
/* Params:  None                                                            */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI COR::OR_Init(DCVOID)
{
    DC_BEGIN_FN("OR_Init");

    _pSl  = _pClientObjects->_pSlObject;
    _pUt  = _pClientObjects->_pUtObject;
    _pUi  = _pClientObjects->_pUiObject;

    TRC_DBG((TB, _T("In OR_Init")));
    DC_MEMSET(&_OR, 0, sizeof(_OR));
    _OR.invalidRectEmpty = TRUE;

    _OR.pendingSendSuppressOutputPDU = FALSE;
    _OR.outputSuppressed = FALSE;

    _OR.enabled = FALSE;

    DC_END_FN();

    return;

} /* OR_Init */


/**PROC+*********************************************************************/
/* Name: OR_Term                                                            */
/*                                                                          */
/* Purpose: Terminates OR                                                   */
/*                                                                          */
/* Returns: Nothing                                                         */
/*                                                                          */
/* Params: None                                                             */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI COR::OR_Term(DCVOID)
{
    DC_BEGIN_FN("OR_Term");

    /************************************************************************/
    /* No action                                                            */
    /************************************************************************/

    DC_END_FN();

    return;

} /* OR_Term */

/**PROC+*********************************************************************/
/* Name:    OR_Enable                                                       */
/*                                                                          */
/* Purpose: Enables OR                                                      */
/*                                                                          */
/* Returns: Nothing                                                         */
/*                                                                          */
/* Params:  None                                                            */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI COR::OR_Enable(DCVOID)
{
    DC_BEGIN_FN("OR_Enable");

    _OR.enabled = TRUE;
    TRC_DBG((TB, _T("OR Enabled")));

    DC_END_FN();

    return;

} /* OR_Enable */


/**PROC+*********************************************************************/
/* Name:    OR_Disable                                                      */
/*                                                                          */
/* Purpose: Disables OR                                                     */
/*                                                                          */
/* Returns: Nothing                                                         */
/*                                                                          */
/* Params:  None                                                            */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI COR::OR_Disable(DCVOID)
{
    DC_BEGIN_FN("OR_Disable");

    _OR.enabled = FALSE;

    DC_MEMSET(&_OR.invalidRect, 0, sizeof(_OR.invalidRect));
    _OR.invalidRectEmpty = TRUE;

    _OR.pendingSendSuppressOutputPDU = FALSE;
    _OR.outputSuppressed = FALSE;

    TRC_DBG((TB, _T("OR disabled")));

    DC_END_FN();

    return;

} /* OR_Disable */


/**PROC+*********************************************************************/
/* Name:    OR_RequestUpdate                                                */
/*                                                                          */
/* Purpose: API to send a RefreshRectPDU                                    */
/*                                                                          */
/* Returns: Nothing                                                         */
/*                                                                          */
/* Params:  pRect - IN - pointer to the rectangle to be updated             */
/*          unusedLen - not used                                            */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI COR::OR_RequestUpdate(PDCVOID pData, DCUINT unusedLen)
{
    RECT * pRect = (RECT *) pData;

    DC_BEGIN_FN("OR_RequestUpdate");

    DC_IGNORE_PARAMETER(unusedLen);

    /************************************************************************/
    /* If OR is not enabled, don't do anything                              */
    /************************************************************************/
    if (!_OR.enabled)
    {
        TRC_DBG((TB, _T("Request Update quitting since not enabled")));
        DC_QUIT;
    }

    TRC_ASSERT((pRect != NULL), (TB,_T("Rect NULL")));

    TRC_ASSERT(( (pRect->left < pRect->right) &&
                 (pRect->top < pRect->bottom) ),
                 (TB,_T("Invalid RECT (%d, %d), (%d,%d)") , pRect->left,
                 pRect->top, pRect->right, pRect->bottom));

    TRC_DBG((TB, _T("Add rectangle (%d, %d, %d, %d) to update area"),
                                                   pRect->left,
                                                   pRect->top,
                                                   pRect->right,
                                                   pRect->bottom));

    if (!_OR.invalidRectEmpty)
    {
        /********************************************************************/
        /* If we currently have a rect to be sent merge the two             */
        /********************************************************************/
        TRC_DBG((TB, _T("Merging refresh rects")));
        _OR.invalidRect.left   = DC_MIN(pRect->left,
                                             _OR.invalidRect.left);
        _OR.invalidRect.top    = DC_MIN(pRect->top,
                                             _OR.invalidRect.top);
        _OR.invalidRect.right  = DC_MAX(pRect->right,
                                             _OR.invalidRect.right);
        _OR.invalidRect.bottom = DC_MAX(pRect->bottom,
                                             _OR.invalidRect.bottom);
    }
    else
    {
        /********************************************************************/
        /* Else put the copy the rect into _OR.invalidRect                   */
        /********************************************************************/
        _OR.invalidRect = *pRect;
        _OR.invalidRectEmpty = FALSE;
    }

    TRC_DBG((TB, _T("New Update area (%d, %d, %d, %d)"), _OR.invalidRect.left,
                                                     _OR.invalidRect.top,
                                                     _OR.invalidRect.right,
                                                     _OR.invalidRect.bottom));

    /************************************************************************/
    /* Attempt to send the PDU                                              */
    /************************************************************************/
    TRC_NRM((TB, _T("Attempting to send RefreshRectPDU")));
    ORSendRefreshRectanglePDU();

DC_EXIT_POINT:
    DC_END_FN();

    return;

} /* OR_RequestUpdate */

/**PROC+*********************************************************************/
/* Name:    OR_SetSuppressOutput                                            */
/*                                                                          */
/* Purpose: API to send a SuppressOutputPDU                                 */
/*                                                                          */
/* Returns: Nothing                                                         */
/*                                                                          */
/* Params:  newWindowState - IN - new window state passed from CO           */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI COR::OR_SetSuppressOutput(ULONG_PTR newWindowState)
{
    DC_BEGIN_FN("OR_SetSuppressOutput");

    /************************************************************************/
    /* If OR is not enabled don't do anything                               */
    /************************************************************************/
    if (!_OR.enabled)
    {
        TRC_DBG((TB, _T("SetOuputRectangle quitting since OR not enabled")));
        DC_QUIT;
    }

    switch (newWindowState)
    {
        case SIZE_MAXIMIZED:
        case SIZE_RESTORED:
        {
            if (_OR.outputSuppressed == FALSE)
            {
                DC_QUIT;
            }
            _OR.outputSuppressed = FALSE;
        }
        break;

        case SIZE_MINIMIZED:
        {
            if (_OR.outputSuppressed == TRUE)
            {
                DC_QUIT;
            }
            _OR.outputSuppressed = TRUE;
        }
        break;

        default:
        {
            TRC_ABORT((TB,_T("Illegal window state passed to OR")));
        }
        break;
    }

    TRC_NRM((TB, _T("Attempting to send SuppressOutputPDU")));
    _OR.pendingSendSuppressOutputPDU = TRUE;
    ORSendSuppressOutputPDU();

DC_EXIT_POINT:
    DC_END_FN();

    return;

} /* OR_SetSuppressOutput */

/**PROC+*********************************************************************/
/* Name:    OR_OnBufferAvailable                                            */
/*                                                                          */
/* Purpose: Retries to send SuppressOutputPDUs and RefreshRectPDUs if       */
/*          necessary                                                       */
/*                                                                          */
/* Returns: Nothing                                                         */
/*                                                                          */
/* Params:  None                                                            */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI COR::OR_OnBufferAvailable(DCVOID)
{
    DC_BEGIN_FN("OR_OnBufferAvailable");

    /************************************************************************/
    /* If Or is not enabled don't do anything                               */
    /************************************************************************/
    if (!_OR.enabled)
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* If we are pending a SendSuppressOutputPDU then call it               */
    /************************************************************************/
    if (_OR.pendingSendSuppressOutputPDU)
    {
        ORSendSuppressOutputPDU();
    }

    /************************************************************************/
    /* If there is a Update rectangle pending, try to send it again         */
    /************************************************************************/
    if (!_OR.invalidRectEmpty)
    {
        ORSendRefreshRectanglePDU();
    }

DC_EXIT_POINT:
    DC_END_FN();

    return;

} /* OR_OnBufferAvailable */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\orint.cpp ===
/**MOD+**********************************************************************/
/* Module:    orint.cpp                                                     */
/*                                                                          */
/* Purpose:   Output Requestor internal functions                           */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>

extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "worint"
#include <atrcapi.h>
}

#include "autil.h"
#include "wui.h"
#include "or.h"
#include "sl.h"


/**PROC+*********************************************************************/
/* Name:    ORSendRefreshRectanglePDU                                       */
/*                                                                          */
/* Purpose: Builds and sends a RefreshRectanglePDU                          */
/*                                                                          */
/* Returns: Nothing                                                         */
/*                                                                          */
/* Params:  None                                                            */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCINTERNAL COR::ORSendRefreshRectanglePDU(DCVOID)
{
    PTS_REFRESH_RECT_PDU    pSendBuffer;
    SL_BUFHND  bufHandle;

    DC_BEGIN_FN("ORSendRefreshRectanglePDU");

    /************************************************************************/
    /* If we can't get a buffer, abandon the send                           */
    /************************************************************************/
    if (!_pSl->SL_GetBuffer(TS_REFRESH_RECT_PDU_SIZE,
                      (PPDCUINT8) &pSendBuffer,
                      &bufHandle))
    {
        TRC_NRM((TB, _T("Failed to GetBuffer")));
        DC_QUIT;
    }

    TRC_NRM((TB, _T("GetBuffer succeeded")));

    /************************************************************************/
    /* Fill in the buffer with a RefreshRect PDU                            */
    /************************************************************************/
    DC_MEMSET(pSendBuffer, 0, TS_REFRESH_RECT_PDU_SIZE);
    pSendBuffer->shareDataHeader.shareControlHeader.pduType =
                                    TS_PROTOCOL_VERSION | TS_PDUTYPE_DATAPDU;
    pSendBuffer->shareDataHeader.shareControlHeader.pduSource =
                                                       _pUi->UI_GetClientMCSID();

    TS_DATAPKT_LEN(pSendBuffer)            = TS_REFRESH_RECT_PDU_SIZE;
    TS_UNCOMP_LEN(pSendBuffer)             = TS_REFRESH_RECT_UNCOMP_LEN;
    pSendBuffer->shareDataHeader.shareID   = _pUi->UI_GetShareID();
    pSendBuffer->shareDataHeader.streamID  = TS_STREAM_LOW;
    pSendBuffer->shareDataHeader.pduType2  = TS_PDUTYPE2_REFRESH_RECT;

    /************************************************************************/
    /* Set a single rectangle.                                              */
    /************************************************************************/
    pSendBuffer->numberOfAreas = 1;
    RECT_TO_TS_RECTANGLE16(&(pSendBuffer->areaToRefresh[0]),
                           &_OR.invalidRect)

    /************************************************************************/
    /* Now send the buffer                                                  */
    /************************************************************************/
    _pSl->SL_SendPacket((PDCUINT8)pSendBuffer,
                  TS_REFRESH_RECT_PDU_SIZE,
                  RNS_SEC_ENCRYPT,
                  bufHandle,
                  _pUi->UI_GetClientMCSID(),
                  _pUi->UI_GetChannelID(),
                  TS_HIGHPRIORITY);

    DC_MEMSET(&_OR.invalidRect, 0, sizeof(RECT));
    _OR.invalidRectEmpty = TRUE;

DC_EXIT_POINT:
    DC_END_FN();

    return;

} /* ORSendRefreshRectanglePDU */


/**PROC+*********************************************************************/
/* Name:    ORSendSuppressOutputPDU                                         */
/*                                                                          */
/* Purpose: Builds and sends a SuppressOutputPDU                            */
/*                                                                          */
/* Returns: Nothing                                                         */
/*                                                                          */
/* Params:  None                                                            */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCINTERNAL COR::ORSendSuppressOutputPDU(DCVOID)
{
    PTS_SUPPRESS_OUTPUT_PDU pSendBuffer;
    SL_BUFHND               bufHandle;
    DCUINT                  numberOfRectangles;
    TS_RECTANGLE16          tsRect;
    DCSIZE                  desktopSize;

    DC_BEGIN_FN("ORSendSuppressOutputPDU");

    TRC_ASSERT((_OR.pendingSendSuppressOutputPDU),
                                  (TB,_T("Not expecting to send SupressOutput")));

    /************************************************************************/
    /* If _OR.outputSuppressed is set then the number of rectangles is 0, if */
    /* not the number of rectangle is 1 and we should put the desktop area  */
    /* in the PDU                                                           */
    /************************************************************************/
    if (_OR.outputSuppressed)
    {
        numberOfRectangles = 0;

        // prevent tsRect not initialized warning
        tsRect.top = 0;
        tsRect.left = 0;
        tsRect.bottom = 0;
        tsRect.right = 0;
    }
    else
    {
        numberOfRectangles = 1;

        /********************************************************************/
        /* Get the rectangle to send and put it in tsRect                   */
        /********************************************************************/
        _pUi->UI_GetDesktopSize(&desktopSize);

        tsRect.top = (DCUINT16) 0;
        tsRect.left = (DCUINT16) 0;
        tsRect.bottom = (DCUINT16) desktopSize.height;
        tsRect.right = (DCUINT16) desktopSize.width;
    }

    /************************************************************************/
    /* If we can't get a buffer, abandon the send                           */
    /************************************************************************/
    if (!_pSl->SL_GetBuffer( TS_SUPPRESS_OUTPUT_PDU_SIZE(numberOfRectangles),
                       (PPDCUINT8) &pSendBuffer,
                       &bufHandle))
    {
        TRC_NRM((TB, _T("Get Buffer failed")));
        DC_QUIT;
    }

    TRC_NRM((TB, _T("Get Buffer succeeded")));

    /************************************************************************/
    /* Fill in the buffer with a RefreshRec PDU                             */
    /************************************************************************/
    DC_MEMSET(pSendBuffer,
              0,
              TS_SUPPRESS_OUTPUT_PDU_SIZE(numberOfRectangles));
    pSendBuffer->shareDataHeader.shareControlHeader.pduType =
                                    TS_PROTOCOL_VERSION | TS_PDUTYPE_DATAPDU;
    pSendBuffer->shareDataHeader.shareControlHeader.pduSource =
                                                       _pUi->UI_GetClientMCSID();

    TS_DATAPKT_LEN(pSendBuffer)
                = (DCUINT16) TS_SUPPRESS_OUTPUT_PDU_SIZE(numberOfRectangles);
    TS_UNCOMP_LEN(pSendBuffer)
              = (DCUINT16) TS_SUPPRESS_OUTPUT_UNCOMP_LEN(numberOfRectangles);
    pSendBuffer->shareDataHeader.shareID   = _pUi->UI_GetShareID();
    pSendBuffer->shareDataHeader.streamID  = TS_STREAM_LOW;
    pSendBuffer->shareDataHeader.pduType2  = TS_PDUTYPE2_SUPPRESS_OUTPUT;

    pSendBuffer->numberOfRectangles = (DCUINT8) numberOfRectangles;

    /************************************************************************/
    /* If we have a rectangle to put into the PDU, put it in                */
    /************************************************************************/
    if (numberOfRectangles == 1)
    {
        DC_MEMCPY(pSendBuffer->includedRectangle,
                  &tsRect,
                  sizeof(TS_RECTANGLE16));
    }

    TRC_NRM((TB, _T("Sending SuppressOutputPDU")));

    /************************************************************************/
    /* Send the PDU                                                         */
    /************************************************************************/
    _pSl->SL_SendPacket((PDCUINT8)pSendBuffer,
                  TS_SUPPRESS_OUTPUT_PDU_SIZE(numberOfRectangles),
                  RNS_SEC_ENCRYPT,
                  bufHandle,
                  _pUi->UI_GetClientMCSID(),
                  _pUi->UI_GetChannelID(),
                  TS_HIGHPRIORITY);

    _OR.pendingSendSuppressOutputPDU = FALSE;

DC_EXIT_POINT:
    DC_END_FN();

    return;

} /* ORSendSuppressOutputPDU */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\rcvapi.cpp ===
/****************************************************************************/
/* Module:    rcvapi.cpp                                                    */
/*                                                                          */
/* Purpose:   Receiver Thread initialization - in the Core                  */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999                                  */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "rcvapi"
#include <atrcapi.h>
}

#include "rcv.h"
#include "autil.h"
#include "cd.h"
#include "op.h"
#include "cm.h"
#include "wui.h"
#include "uh.h"
#include "od.h"
#include "sp.h"
#include "clx.h"

DWORD g_dwRCVDbgStatus = 0;
#define RCV_DBG_INIT_CALLED        0x01
#define RCV_DBG_INIT_DONE          0x02
#define RCV_DBG_TERM_CALLED        0x04
#define RCV_DBG_TERM_ACTUAL_DONE1  0x08
#define RCV_DBG_TERM_ACTUAL_DONE2  0x10
#define RCV_DBG_TERM_RETURN        0x20

CRCV::CRCV(CObjs* objs)
{
    _pClientObjects = objs;
    _fRCVInitComplete = FALSE;
}


CRCV::~CRCV()
{
}



/****************************************************************************/
/* Name:      RCV_Init                                                      */
/*                                                                          */
/* Purpose:   Initialize the Receiver Thread                                */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI CRCV::RCV_Init(DCVOID)
{
    DC_BEGIN_FN("RCV_Init");

    g_dwRCVDbgStatus |= RCV_DBG_INIT_CALLED;

    TRC_ASSERT(_pClientObjects, (TB,_T("_pClientObjects is NULL")));
    _pClientObjects->AddObjReference(RCV_OBJECT_FLAG);

    _pCm  = _pClientObjects->_pCMObject;
    _pUh  = _pClientObjects->_pUHObject;
    _pOd  = _pClientObjects->_pODObject;
    _pOp  = _pClientObjects->_pOPObject;
    _pSp  = _pClientObjects->_pSPObject;
    _pClx = _pClientObjects->_pCLXObject;
    _pUt  = _pClientObjects->_pUtObject;
    _pCd  = _pClientObjects->_pCdObject;
    _pUi  = _pClientObjects->_pUiObject;

    
    // Initialize subcomponents of the Core in the Receiver Thread.
    _pCm->CM_Init();
    _pUh->UH_Init();
    _pOd->OD_Init();
    _pOp->OP_Init();
    _pSp->SP_Init();

    // Initialize Client Extension DLL
    TRC_DBG((TB, _T("RCV Initialising Client Extension DLL")));
    _pClx->CLX_Init(_pUi->UI_GetUIMainWindow(), _pUi->_UI.CLXCmdLine);

    // Allow UI to call Core functions
    _pUi->UI_SetCoreInitialized();

    //
    // This needs to be a direct call because the CD won't be able
    // to post to the UI layer because the ActiveX control is blocked
    // waiting on the core init event (blocking the main wnd loop on thread 0).
    //
    _pUi->UI_NotifyAxLayerCoreInit();

    // Tell the UI that the core has initialized
    _pCd->CD_DecoupleSimpleNotification(CD_UI_COMPONENT,
                                  _pUi,
                                  CD_NOTIFICATION_FUNC(CUI,UI_OnCoreInitialized),
                                  (ULONG_PTR) 0);

    _fRCVInitComplete = TRUE;

    g_dwRCVDbgStatus |= RCV_DBG_INIT_DONE;

    DC_END_FN();

    return;

} /* RCV_Init */

/****************************************************************************/
/* Name:      RCV_Term                                                      */
/*                                                                          */
/* Purpose:   Terminate the Receiver Thread                                 */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI CRCV::RCV_Term(DCVOID)
{
    DC_BEGIN_FN("RCV_Term");

    g_dwRCVDbgStatus |= RCV_DBG_TERM_CALLED;

    if(_fRCVInitComplete)
    {
        g_dwRCVDbgStatus |= RCV_DBG_TERM_ACTUAL_DONE1;
        // Terminate subcomponents of the Core in the Receiver Thread.
        _pSp->SP_Term();
        _pOp->OP_Term();
        _pOd->OD_Term();
        _pUh->UH_Term();
        _pCm->CM_Term();
    
        //
        // Terminate utilities.
        //
        _pUt->UT_Term();
    
        // Terminate the Client Extension DLL
        // CLX_Term used to be called before CO_Term in UI_Term.  CLX_Term
        // needs to be called after the SND and RCV threads are terminated.
        // So, we move CLX_Term after UI_Term in the recv thread
        //
        _pClx->CLX_Term();
    
        _pClientObjects->ReleaseObjReference(RCV_OBJECT_FLAG);
        g_dwRCVDbgStatus |= RCV_DBG_TERM_ACTUAL_DONE2;
    }

    g_dwRCVDbgStatus |= RCV_DBG_TERM_RETURN;

    DC_END_FN();

    return;

} /* RCV_Term */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\opint.cpp ===
/**MOD+**********************************************************************/
/* Module:    wopint.c                                                      */
/*                                                                          */
/* Purpose:   Output Painter internal functions                             */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "wopint"
#include <atrcapi.h>
}

#include "autil.h"
#include "wui.h"
#include "op.h"
#include "uh.h"
#include "cd.h"
#include "or.h"
#include "aco.h"


/**PROC+*********************************************************************/
/* Name:      OPRealizePaletteInWindow                                      */
/*                                                                          */
/* Purpose:   Realizes the current palette in a given window                */
/*                                                                          */
/* Returns:   The number of palette entries changed                         */
/*                                                                          */
/* Params:    hwnd - handle of the window to realize the current palette in */
/*                                                                          */
/**PROC-*********************************************************************/
DCUINT DCINTERNAL COP::OPRealizePaletteInWindow(HWND hwnd)
{
    HDC       hdc;
    HPALETTE  hpalOld;
    DCUINT    rc;

    DC_BEGIN_FN("OPRealizePaletteInWindow");

    hdc = GetWindowDC(hwnd);
    TRC_ASSERT(hdc, (TB,_T("GetWindowDC returned NULL\n")));
    if(NULL == hdc)
    {
        return 0;
    }

    hpalOld = SelectPalette(hdc, _pUh->UH_GetCurrentPalette(), FALSE);

    rc = RealizePalette(hdc);

    SelectPalette(hdc, hpalOld, FALSE);

    ReleaseDC(hwnd, hdc);

    DC_END_FN();
    return(rc);
}


/**PROC+*********************************************************************/
/* Name:      OPStaticWndProc                                               */
/*                                                                          */
/* Purpose:   Output Window WndProc (static delegator)                      */
/*                                                                          */
/* Returns:   Usual WndProc return values                                   */
/*                                                                          */
/* Params:    Usual WndProc parameters                                      */
/*                                                                          */
/**PROC-*********************************************************************/
LRESULT CALLBACK COP::OPStaticWndProc (HWND hwnd, UINT message,
                                                 WPARAM wParam, LPARAM lParam)
{
    COP* pOP = (COP*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(WM_CREATE == message)
    {
        //pull out the this pointer and stuff it in the window class
        LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
        pOP = (COP*)lpcs->lpCreateParams;

        SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)pOP);
    }
    
    //
    // Delegate the message to the appropriate instance
    //

    if(pOP)
    {
        return pOP->OPWndProc(hwnd, message, wParam, lParam);
    }
    else
    {
        return DefWindowProc(hwnd, message, wParam, lParam);
    }
    
}

//
// Start the process of dimming the window
//
BOOL COP::OPStartDimmingWindow()
{
    BOOL fRet = FALSE;
    DC_BEGIN_FN("OPStartDimmingWindow");

    if (_fDimWindow) {
        DC_QUIT;
    }
    _fDimWindow = TRUE;

    if (!CUT::UT_IsScreen8bpp()) {

        //
        // High color so do the cool grayed dimming anim
        //

        _iDimWindowStepsLeft = DIM_WINDOW_STEPS;
        _nDimWindowTimerID = SetTimer(OP_GetOutputWindowHandle(),
                                      DIM_WINDOW_TIMERID,
                                      DIM_WINDOW_TICK, NULL);

        if (!_nDimWindowTimerID) {
            TRC_ERR((TB,_T("SetTimer for dimming window failed: 0x%x"),
                     GetLastError()));
            DC_QUIT;
        }
    }
    else {
        
        //
        // 8bpp so do the win9x style shutdown grill
        //

        HDC hdcToDim = _pUh->UH_GetDisconnectBitmapDC();
        HWND hwndOutput = OP_GetOutputWindowHandle();
        RECT cliRect;
        DCSIZE size;

        GetClientRect(hwndOutput, &cliRect);
        size.width = cliRect.right - cliRect.left;
        size.height = cliRect.bottom - cliRect.top;
        
        if (hdcToDim) {
            GrillWindow(hdcToDim, size); 
        }
        else {
            TRC_ERR((TB,_T("Didn't get a DC to dim")));
        }
    }


DC_EXIT_POINT:
    DC_END_FN();
    return fRet;
}

//
// Stop dimming the output window contents
//
BOOL COP::OPStopDimmingWindow()
{
    BOOL fRet = FALSE;
    HWND hwnd = OP_GetOutputWindowHandle();
    DC_BEGIN_FN("OPStopDimmingWindow");

    if (_nDimWindowTimerID) {
        KillTimer(hwnd,
                  _nDimWindowTimerID);
        _nDimWindowTimerID = 0;
    }

    _fDimWindow = FALSE;

    fRet = TRUE;

    DC_END_FN();
    return fRet;
}

const WORD c_GrayBits[] = {0x5555, 0xAAAA, 0x5555, 0xAAAA,
                           0x5555, 0xAAAA, 0x5555, 0xAAAA};
HBRUSH COP::CreateDitheredBrush()
{
    DC_BEGIN_FN("CreateDitheredBrush");

    HBITMAP hbmp = CreateBitmap(8, 8, 1, 1, c_GrayBits);
    if (hbmp)
    {
        HBRUSH hbr = CreatePatternBrush(hbmp);
        DeleteObject(hbmp);
        return hbr;
    }
    
    DC_END_FN();
    return NULL;
}

//
// Overlays the image in the window with a grill
// aka like the Win2k shutdown effect
//
VOID COP::GrillWindow(HDC hdc, DCSIZE& size)
{
#ifndef OS_WINCE
    RECT rc;
#endif
    DC_BEGIN_FN("GrillWindow");

    static const int ROP_DPna = 0x000A0329;
    
    HBRUSH hbr = CreateDitheredBrush();
    if (hbr)
    {
#ifndef OS_WINCE
        RECT rc;
#endif
        HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, hbr);

        PatBlt(hdc, 0, 0, size.width, size.height, ROP_DPna);
        SelectObject(hdc, hbrOld);
        DeleteObject(hbr);
    }

    DC_END_FN();
}

//
// Grays the image in the window
// like the XP shutdown effect
//
VOID COP::DimWindow(HDC hdc)
{
#ifndef OS_WINCE
    RECT rc;
#endif
    HBITMAP dstBitmap;
    DIBSECTION dibSection;
    PBYTE pDstBits;

    DC_BEGIN_FN("GrayWindow");

    dstBitmap = (HBITMAP)GetCurrentObject(hdc, OBJ_BITMAP);
    if (dstBitmap != NULL) {
        if (sizeof(dibSection) !=
                GetObject(dstBitmap, sizeof(dibSection), &dibSection)) {
            TRC_ERR((TB, _T("GetObject failed")));
            DC_QUIT;
        }
    }
    pDstBits = (PBYTE)dibSection.dsBm.bmBits;
    if (24 == dibSection.dsBm.bmBitsPixel) {
        DimBits24(pDstBits,
                  dibSection.dsBm.bmWidth * dibSection.dsBm.bmHeight,
                  0xd5);
    }
    else if (16 == dibSection.dsBm.bmBitsPixel) {
        DimBits16(pDstBits,
                  dibSection.dsBm.bmWidth * dibSection.dsBm.bmHeight,
                  0xd5);
    }
    else if (15 == dibSection.dsBm.bmBitsPixel) {
        DimBits15(pDstBits,
                  dibSection.dsBm.bmWidth * dibSection.dsBm.bmHeight,
                  0xd5);
    }

DC_EXIT_POINT:
    DC_END_FN();
}

VOID COP::DimBits24(PBYTE pSrc, int cLen, int Amount)
{
    for (int i = cLen - 1; i >= 0; i--)
    {
        ULONG B = (ULONG)*pSrc;
        ULONG G = (ULONG)*(pSrc+1);
        ULONG R = (ULONG)*(pSrc+2);
        ULONG ulGray = (54*R+183*G+19*B) >> 8;
        ULONG ulTemp = ulGray * (0xff - Amount);
        R = (R*Amount+ulTemp) >> 8;
        G = (G*Amount+ulTemp) >> 8;
        B = (B*Amount+ulTemp) >> 8;
        *pSrc++ = (BYTE)B;
        *pSrc++ = (BYTE)G;
        *pSrc++ = (BYTE)R;
    }
}

#define rgb555(r,g,b)   (( ((WORD)(r) << 10) & TS_RED_MASK_15BPP)   | \
                           (((WORD)(g) << 5) & TS_GREEN_MASK_15BPP) | \
                           ((WORD)(b) & TS_BLUE_MASK_15BPP))

#define rgb565(r,g,b)   (( ((WORD)(r) << 11) & TS_RED_MASK_16BPP)   | \
                           (((WORD)(g) << 5) & TS_GREEN_MASK_16BPP) | \
                           ((WORD)(b) & TS_BLUE_MASK_16BPP))
VOID COP::DimBits16(PBYTE pSrc, int cLen, int Amount)
{
    ULONG R,G,B;
	USHORT color;
#ifndef OS_WINCE
    ULONG ulGray, ulTemp;
#endif
    //
    // All our 16bpp bitmaps are 565
    //
    // Do the conversion in a cheesy way by upsampling to 24bpp first
    //
    for (int i = cLen - 1; i >= 0; i--)
    {
        memcpy(&color, pSrc, 2);
        B = (color & TS_BLUE_MASK_16BPP);
        G = ((color & TS_GREEN_MASK_16BPP) >> 5) / 2;
        R = ((color & TS_RED_MASK_16BPP) >> 11);
         
        ULONG ulGray = (54*R+183*G+19*B) >> 8;
        ULONG ulTemp = ulGray * (0xff - Amount);
        R = ((R*Amount+ulTemp) >> 8) / 2;
        G = ((G*Amount+ulTemp) >> 8) / 2;
        B = ((B*Amount+ulTemp) >> 8) / 2;
        color = rgb565(R,G,B);
        memcpy(pSrc, &color, 2);
        pSrc+=2;
    }
}

VOID COP::DimBits15(PBYTE pSrc, int cLen, int Amount)
{
    ULONG R,G,B;
	USHORT color;
    ULONG ulGray, ulTemp;
	ULONG scaleAmt = Amount/8;
    //
    // All our 15bpp bitmaps are 555
    //
    for (int i = cLen - 1; i >= 0; i--)
    {
        memcpy(&color, pSrc, 2);
        B = (color & TS_BLUE_MASK_15BPP);
        G = (color & TS_GREEN_MASK_15BPP) >> 5;
        R = (color & TS_RED_MASK_15BPP) >> 5;
         
        ulGray = (R+G+B) / 3;
        ulTemp = ulGray * (0xFF/8 - scaleAmt);
        R = (R*scaleAmt+ulTemp) >> 8;
        G = (G*scaleAmt+ulTemp) >> 8;
        B = (B*scaleAmt+ulTemp) >> 8;
        color = rgb555(R,G,B);
        memcpy(pSrc, &color, 2);
        pSrc+=2;
    }
}





/**PROC+*********************************************************************/
/* Name:      OPWndProc                                                     */
/*                                                                          */
/* Purpose:   Output Window WndProc                                         */
/*                                                                          */
/* Returns:   Usual WndProc return values                                   */
/*                                                                          */
/* Params:    Usual WndProc parameters                                      */
/*                                                                          */
/**PROC-*********************************************************************/
LRESULT CALLBACK COP::OPWndProc( HWND hwnd,
                            UINT message,
                            WPARAM wParam,
                            LPARAM lParam )
{
    LRESULT     rc = 0;

    DC_BEGIN_FN("OPWndProc");

    switch (message)
    {
        case WM_PAINT:
        {
            HDC         hdc;
            PAINTSTRUCT ps;
            HPALETTE    hpalOld;
            DCSIZE      desktopSize;

#ifdef DC_PERF
            UTPERFCOUNTER counter1;
            UTPERFCOUNTER counter2;
#endif

            TRC_NRM((TB, _T("WM_PAINT")));
#ifdef DC_PERF
            _pUt->UT_QueryPerformanceCounter(&counter1);
#endif

            hdc = BeginPaint(hwnd, &ps);
            if (hdc == NULL)
            {
                TRC_SYSTEM_ERROR("BeginPaint failed");
                break;
            }

#ifdef DISABLE_SHADOW_IN_FULLSCREEN            
            if (!_pUh->_UH.DontUseShadowBitmap   &&
                _pUh->UH_ShadowBitmapIsEnabled() ||
                _fDimWindow)
#else
            if (_pUh->UH_ShadowBitmapIsEnabled() || _fDimWindow)
#endif // DISABLE_SHADOW_IN_FULLSCREEN
            {
#ifndef SMART_SIZING
                BOOL rcBlt;
#endif // SMART_SIZING
                
                TRC_DBG((TB, _T("Paint from shadow bitmap")));

                hpalOld = SelectPalette(hdc, _pUh->UH_GetCurrentPalette(), FALSE);

                RealizePalette(hdc);

                _pUi->UI_GetDesktopSize(&desktopSize);

#ifdef SMART_SIZING
                OP_CopyShadowToDC(hdc, 0, 0, desktopSize.width, 
                        desktopSize.height);

#else // SMART_SIZING
                rcBlt = BitBlt(hdc,
                               0, 0,
                               desktopSize.width,
                               desktopSize.height,
                               !_fDimWindow ? _pUh->UH_GetShadowBitmapDC() :
                                               _pUh->UH_GetDisconnectBitmapDC(),
                               0, 0,
                               SRCCOPY);
    
                if (!rcBlt)
                {
                    /********************************************************/
                    /* Failed to paint.                                     */
                    /********************************************************/
                    TRC_ERR((TB, _T("BitBlt failed")));
                }
#endif // SMART_SIZING

                SelectPalette(hdc, hpalOld, FALSE);
            }
            else
            {
                /************************************************************/
                /* Shadow Bitmap disabled - have to get the output resent   */
                /* from the server.                                         */
                /*                                                          */
                /* A. TRIVIAL IMPLEMENTATION:                               */
                /*                                                          */
                /* Send an UpdateRectPDU to the server for                  */
                /*                                                          */
                /*                 ps.rcPaint                               */
                /*                                                          */
                /* B. ADVANCED IMPLEMENTATION (Win32 only)                  */
                /*                                                          */
                /* Send a set of UpdateRectPDUs to the server for the       */
                /* rects returned by:                                       */
                /*                                                          */
                /*  GetUpdateRgn (this must be called BEFORE BeginPaint)    */
                /*  GetRgnData   (returns rectangles in region)             */
                /*                                                          */
                /* If there are too many rects in region (Q: what is too    */
                /* many?) then simply revert to Plan A.                     */
                /*                                                          */
                /************************************************************/
                TRC_DBG((TB, _T("Paint using UpdateRectPDU")));

                if ( (ps.rcPaint.right > ps.rcPaint.left ) &&
                                      (ps.rcPaint.bottom > ps.rcPaint.top) )
                {
                    _pCd->CD_DecoupleNotification(CD_SND_COMPONENT,
                                            _pOr,
                                            CD_NOTIFICATION_FUNC(COR,OR_RequestUpdate),
                                            &ps.rcPaint,
                                            sizeof(RECT));
                    
                }
#ifdef OS_WINCE
                _pUh->_UH.ulNumAOTRects = 0;
                SetRectEmpty(&_pUh->_UH.rcaAOT[MAX_AOT_RECTS-1]);
                EnumWindows(StaticEnumTopLevelWindowsProc, (LPARAM)this);
#endif
            }
    
            EndPaint(hwnd, &ps);

#ifdef DC_PERF
            _pUt->UT_QueryPerformanceCounter(&time2);
            TRC_NRM((TB, _T("WM_PAINT: %u"),
                           _pUt->UT_PerformanceCounterDiff(&counter1, &counter2) ));
#endif

            _OP.lastPaintTime = _pUt->UT_GetCurrentTimeMS();
        }
        break;

        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_KEYDOWN:
        case WM_SYSKEYDOWN:
        {
            //
            // If we are dimming then beep on input
            //
            if (_fDimWindow) {
                MessageBeep((UINT)-1);
            }
        }
        break;


        case WM_TIMER:
        {
            switch (wParam)
            {
                case DIM_WINDOW_TIMERID:
                {
                    BOOL fStopDimming = FALSE;
                    if (_fDimWindow) {
                        _iDimWindowStepsLeft--;
                        if (_iDimWindowStepsLeft >= 0) {

                            //
                            // Dim the window some more
                            //
                            HDC hdcToDim = _pUh->UH_GetDisconnectBitmapDC();
                            if (hdcToDim) {
                                DimWindow(hdcToDim);
                                InvalidateRect(OP_GetOutputWindowHandle(),
                                               NULL,
                                               FALSE);
                            }
                            else {
                                TRC_ERR((TB,
                                    _T("hdcToDim is NULL. Not dimming!")));
                                fStopDimming = TRUE;
                            }
                        }
                        else {
                            fStopDimming = TRUE;
                        }
                    }
                    else {
                        fStopDimming = TRUE;
                    }

                    if (fStopDimming) {
                        //
                        // Stop the dimming
                        //
                        KillTimer(hwnd, _nDimWindowTimerID);
                    }
                }
                break;
            }
        }
        break;

        default:
        {
            rc = DefWindowProc(hwnd, message, wParam, lParam);
        }
        break;
    }

    DC_END_FN();

    return(rc);

} /* OPWndProc   */




#ifdef OS_WINCE
BOOL CALLBACK COP::StaticEnumTopLevelWindowsProc (HWND hwnd, LPARAM lParam)
{
    COP* pOP = (COP*)lParam;
    return pOP->EnumTopLevelWindowsProc(hwnd);
}

BOOL COP::EnumTopLevelWindowsProc (HWND hwnd)
{
    DC_BEGIN_FN("EnumTopLevelWindowsProc");
    if ( (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST) &&
         (GetWindowLong(hwnd, GWL_STYLE) & WS_VISIBLE) )
    {
        RECT rectWindow;
        GetWindowRect(hwnd, &rectWindow);
        if (!IsRectEmpty(&rectWindow))
        {
            if (_pUh->_UH.ulNumAOTRects < MAX_AOT_RECTS - 1)
            {
                _pUh->_UH.rcaAOT[_pUh->_UH.ulNumAOTRects++] = rectWindow;
            }
            else
            {
                TRC_ASSERT((_pUh->_UH.ulNumAOTRects == MAX_AOT_RECTS - 1), 
                            (TB,_T("_pUh->_UH.ulNumAOTRects is invalid!\n")));

                if (IsRectEmpty(&_pUh->_UH.rcaAOT[_pUh->_UH.ulNumAOTRects]))
                {
                    _pUh->_UH.rcaAOT[_pUh->_UH.ulNumAOTRects] = rectWindow;
                }
                else
                {
                    UnionRect(&_pUh->_UH.rcaAOT[_pUh->_UH.ulNumAOTRects], 
                            &_pUh->_UH.rcaAOT[_pUh->_UH.ulNumAOTRects], &rectWindow);
                }
            }
        }
    }
    DC_END_FN();
    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\or.h ===
/**MOD+**********************************************************************/
/* Module:    or.h                                                          */
/*                                                                          */
/* Purpose:   Header file for or.cpp                                        */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/

#ifndef _OR_H_
#define _OR_H_

extern "C" {
    #include <adcgdata.h>
}
#include "objs.h"
#include "cd.h"


/**STRUCT+*******************************************************************/
/* Structure: OR_GLOBAL_DATA                                                */
/*                                                                          */
/* Description: Output Requestor global data                                */
/****************************************************************************/
typedef struct tagOR_GLOBAL_DATA
{
    RECT   invalidRect;
    DCBOOL invalidRectEmpty;
    DCBOOL enabled;

    DCUINT outputSuppressed;
    DCBOOL pendingSendSuppressOutputPDU;

} OR_GLOBAL_DATA, DCPTR POR_GLOBAL_DATA;
/**STRUCT-*******************************************************************/


/****************************************************************************/
/* Macros                                                                   */
/****************************************************************************/

/****************************************************************************/
/* Turns a RECT into a TS_RECTANGLE16 (exclusive to inclusive and LONG to   */
/* DCUINT16)                                                                */
/****************************************************************************/
#define RECT_TO_TS_RECTANGLE16(X,Y)         \
(X)->left   = (DCUINT16) (Y)->left;         \
(X)->top    = (DCUINT16) (Y)->top;          \
(X)->right  = (DCUINT16) ((Y)->right - 1) ;   \
(X)->bottom = (DCUINT16) ((Y)->bottom - 1) ;


class CSL;
class CUT;
class CUI;


class COR
{
public:
    COR(CObjs* objs);
    ~COR();


public:
    //
    // API
    //

    DCVOID DCAPI OR_Init(DCVOID);
    DCVOID DCAPI OR_Term(DCVOID);
    
    DCVOID DCAPI OR_Enable(DCVOID);
    DCVOID DCAPI OR_Disable(DCVOID);
    
    DCVOID DCAPI OR_RequestUpdate(PDCVOID pData, DCUINT len);
    EXPOSE_CD_NOTIFICATION_FN(COR, OR_RequestUpdate);
    DCVOID DCAPI OR_SetSuppressOutput(ULONG_PTR newWindowState);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(COR, OR_SetSuppressOutput);
    
    DCVOID DCAPI OR_OnBufferAvailable(DCVOID);


public:
    //
    // Data members
    //

    OR_GLOBAL_DATA _OR;

private:
    //
    // Internal member functions
    // 
    DCVOID DCINTERNAL ORSendRefreshRectanglePDU(DCVOID);
    DCVOID DCINTERNAL ORSendSuppressOutputPDU(DCVOID);

private:
    CSL* _pSl;
    CUT* _pUt;
    CUI* _pUi;

private:
    CObjs* _pClientObjects;

};


#endif // _OR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\rcv.h ===
/**INC+**********************************************************************/
/* Header:    arcvapi.h                                                     */
/*                                                                          */
/* Purpose:   Receiver Thread Class                                         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/


#ifndef _H_RCV
#define _H_RCV

extern "C" {
    #include <adcgdata.h>
//    #include <autapi.h>
}

#include "autil.h"

/**STRUCT+*******************************************************************/
/* Structure: RCV_GLOBAL_DATA                                               */
/*                                                                          */
/* Description:                                                             */
/****************************************************************************/
typedef struct tagRCV_GLOBAL_DATA
{
    UT_THREAD_DATA paintThreadInfo;
} RCV_GLOBAL_DATA;
/**STRUCT-*******************************************************************/



class CCM;
class CUH;
class COD;
class COP;
class CSP;
class CCLX;
class CUT;
class CCD;
class CUI;

#include "objs.h"

class CRCV
{
public:
    CRCV(CObjs* objs);
    ~CRCV();

public:
    //
    // API
    //

    DCVOID DCAPI RCV_Init(DCVOID);
    DCVOID DCAPI RCV_Term(DCVOID);


public:
    //
    // Public data members
    //
    RCV_GLOBAL_DATA _RCV;


private:
    CCM* _pCm;
    CUH* _pUh;
    COD* _pOd;
    COP* _pOp;
    CSP* _pSp;
    CCLX* _pClx;
    CUT* _pUt;
    CCD* _pCd;
    CUI* _pUi;
private:
    CObjs* _pClientObjects;
    BOOL   _fRCVInitComplete;

};



#endif // _H_RCV
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\sl.h ===
/****************************************************************************/
/* sl.h                                                                     */
/*                                                                          */
/* Security Layer class                                                     */
/*                                                                          */
/* Copyright (C) 1997-1999 Microsoft Corporation                            */
/****************************************************************************/


#ifndef _H_SL
#define _H_SL

extern "C" {
    #include <adcgdata.h>
    #include <at120ex.h>
}

#include "cd.h"
#include "nl.h"
#include "cchan.h"
#include "objs.h"
#include "capienc.h"

#define SL_DBG_INIT_CALLED        0x00001
#define SL_DBG_INIT_DONE          0x00002
#define SL_DBG_TERM_CALLED        0x00004
#define SL_DBG_TERM_DONE          0x00008

#define SL_DBG_CONNECT_CALLED     0x00010
#define SL_DBG_CONNECT_DONE       0x00020
#define SL_DBG_DISCONNECT_CALLED  0x00040
#define SL_DBG_DISCONNECT_DONE1   0x00080

#define SL_DBG_DISCONNECT_DONE2   0x00100
#define SL_DBG_ONINIT_CALLED      0x00200
#define SL_DBG_ONINIT_DONE1       0x00400
#define SL_DBG_ONINIT_DONE2       0x00800

#define SL_DBG_ONDISC_CALLED      0x01000
#define SL_DBG_ONDISC_DONE1       0x02000
#define SL_DBG_ONDISC_DONE2       0x04000
#define SL_DBG_ONTERM_CALLED      0x08000

#define SL_DBG_ONTERM_DONE1       0x10000
#define SL_DBG_ONTERM_DONE2       0x20000
#define SL_DBG_TERM_DONE1         0x40000


extern DWORD g_dwSLDbgStatus;
#define SL_DBG_SETINFO(x)   g_dwSLDbgStatus |= x;

/****************************************************************************/
/* Protocol type(s)                                                         */
/****************************************************************************/
#define SL_PROTOCOL_T128   NL_PROTOCOL_T128


/****************************************************************************/
/* Network transport types.                                                 */
/****************************************************************************/
#define SL_TRANSPORT_TCP  NL_TRANSPORT_TCP


#ifdef DC_LOOPBACK
/****************************************************************************/
/* Loopback testing constants                                               */
/****************************************************************************/
/****************************************************************************/
/* Test string: Put two pad bytes at the front, since MG will overwrite     */
/* these with a length field on the server.  Check only subsequent parts of */
/* the string.                                                              */
/* Ensure that the whole thing is a multiple of 4 bytes (including the null */
/* terminator) to avoid padding inconsistencies.                            */
/****************************************************************************/
#define SL_LB_RETURN_STRING \
                     {'L','o','o','p','b','a','c','k',' ','t','e','s','t',' '}
#define SL_LB_RETURN_STRING_SIZE  14
#define SL_LB_STR_CORRUPT_LENGTH 2
#define SL_LB_STRING_SIZE  \
                         (SL_LB_STR_CORRUPT_LENGTH + SL_LB_RETURN_STRING_SIZE)
#define SL_LB_HDR_SIZE     sizeof(SL_LB_PACKET)
#define SL_LB_SIZE_INC     1
#define SL_LB_MAX_PACKETS  6000
#define SL_LB_MAX_SIZE     4000
#define SL_LB_MIN_SIZE     (SL_LB_HDR_SIZE + SL_LB_SIZE_INC)
#endif /* DC_LOOPBACK */


/****************************************************************************/
/* Structure: SL_BUFHND                                                     */
/*                                                                          */
/* Description: Buffer Handle                                               */
/****************************************************************************/
typedef NL_BUFHND SL_BUFHND;
typedef SL_BUFHND DCPTR PSL_BUFHND;


/****************************************************************************/
/* Structure: SL_CALLBACKS                                                  */
/*                                                                          */
/* Description: list of callbacks passed to SL_Init().                      */
/****************************************************************************/
typedef NL_CALLBACKS SL_CALLBACKS;
typedef SL_CALLBACKS DCPTR PSL_CALLBACKS;


//
// For internal functions
//

/****************************************************************************/
/* Constants                                                                */
/****************************************************************************/
/****************************************************************************/
/* Multiplier to turn a default string format byte count into a Unicode     */
/* string byte count.                                                       */
/* For 32-bit, the default is Unicode, so the multiplier is a NOP, ie 1.    */
/* For 16-bit, the default is ANSI, so multiply by 2 to give Unicode        */
/* (assumes security package names always use single byte chars).           */
/****************************************************************************/
#ifdef UNICODE
#define SL_DEFAULT_TO_UNICODE_FACTOR 1
#else
#define SL_DEFAULT_TO_UNICODE_FACTOR 2
#endif

/****************************************************************************/
/* States                                                                   */
/****************************************************************************/
#define SL_STATE_TERMINATED                 0
#define SL_STATE_INITIALIZING               1
#define SL_STATE_INITIALIZED                2
#define SL_STATE_NL_CONNECTING              3
#define SL_STATE_SL_CONNECTING              4
#define SL_STATE_LICENSING                  5
#define SL_STATE_CONNECTED                  6
#define SL_STATE_DISCONNECTING              7
#define SL_STATE_TERMINATING                8
#define SL_NUMSTATES                        9

/****************************************************************************/
/* Events                                                                   */
/****************************************************************************/
#define SL_EVENT_SL_INIT                    0
#define SL_EVENT_SL_TERM                    1
#define SL_EVENT_SL_CONNECT                 2
#define SL_EVENT_SL_DISCONNECT              3
#define SL_EVENT_SL_SENDPACKET              4
#define SL_EVENT_SL_GETBUFFER               5
#define SL_EVENT_ON_INITIALIZED             6
#define SL_EVENT_ON_TERMINATING             7
#define SL_EVENT_ON_CONNECTED               8
#define SL_EVENT_ON_DISCONNECTED            9
#define SL_EVENT_ON_RECEIVED_SEC_PACKET     10
#define SL_EVENT_ON_RECEIVED_LIC_PACKET     11
#define SL_EVENT_ON_RECEIVED_DATA_PACKET    12
#define SL_EVENT_ON_BUFFERAVAILABLE         13
#define SL_NUMEVENTS                        14

/****************************************************************************/
/* Values in the state table                                                */
/****************************************************************************/
#define SL_TABLE_OK                         0
#define SL_TABLE_WARN                       1
#define SL_TABLE_ERROR                      2

/****************************************************************************/
/* Macros                                                                   */
/****************************************************************************/
/****************************************************************************/
/* SL_CHECK_STATE - check SL is in the right state for an event.            */
/****************************************************************************/
#define SL_CHECK_STATE(event)                                               \
{                                                                           \
    TRC_DBG((TB, _T("Test event %s in state %s"),                               \
                slEvent[event], slState[_SL.state]));                        \
    if (slStateTable[event][_SL.state] != SL_TABLE_OK)                       \
    {                                                                       \
        if (slStateTable[event][_SL.state] == SL_TABLE_WARN)                 \
        {                                                                   \
            TRC_ALT((TB, _T("Unusual event %s in state %s"),                    \
                      slEvent[event], slState[_SL.state]));                  \
        }                                                                   \
        else                                                                \
        {                                                                   \
            TRC_ABORT((TB, _T("Invalid event %s in state %s"),                  \
                      slEvent[event], slState[_SL.state]));                  \
        }                                                                   \
        DC_QUIT;                                                            \
    }                                                                       \
}

/****************************************************************************/
/* SL_SET_STATE - set the SL state                                          */
/****************************************************************************/
#define SL_SET_STATE(newstate)                                              \
{                                                                           \
    TRC_NRM((TB, _T("Set state from %s to %s"),                                 \
            slState[_SL.state], slState[newstate]));                        \
    _SL.state = newstate;                                                   \
}


#ifdef DC_LOOPBACK
/****************************************************************************/
/* Loopback testing structures and functions                                */
/****************************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: SL_LB_PACKET                                                  */
/*                                                                          */
/* Description: template for building up the packet to be sent              */
/****************************************************************************/
typedef struct tagSL_LB_PACKET
{
    DCUINT8 testString[SL_LB_STRING_SIZE]; /* multiple of 4 bytes           */
    DCUINT32 sequenceNumber; /* Chosen to ensure data begins on word        */
                             /* boundary                                    */
} SL_LB_PACKET, DCPTR PSL_LB_PACKET;
/**STRUCT-*******************************************************************/

/**STRUCT+*******************************************************************/
/* Structure: SL_LB_Q_ELEMENT                                               */
/*                                                                          */
/* Description: Elements in sent and received queues of loopback packets    */
/****************************************************************************/
typedef struct tagSL_LB_Q_ELEMENT SL_LB_Q_ELEMENT, DCPTR PSL_LB_Q_ELEMENT;
struct tagSL_LB_Q_ELEMENT
{
    PSL_LB_PACKET pCurrent;
    SL_LB_Q_ELEMENT *pNext;
};
/**STRUCT-*******************************************************************/

#endif //DC_LOOPBACK

//
// Data
//

/****************************************************************************/
/* Structure: SL_GLOBAL_DATA                                                */
/*                                                                          */
/* Description: Security Layer global data                                  */
/****************************************************************************/
typedef struct tagSL_GLOBAL_DATA
{
    /************************************************************************/
    /* List of callbacks to the Core                                        */
    /************************************************************************/
    SL_CALLBACKS            callbacks;

    /************************************************************************/
    /* Flags and State information                                          */
    /************************************************************************/
    DCUINT                  state;

    /************************************************************************/
    /* Encryption flags and data.                                           */
    /************************************************************************/
    DCBOOL                  encrypting;
    DCBOOL                  encryptionEnabled;

    DCBOOL                  decryptFailed;

    DCUINT32                encryptionMethodsSupported;
    DCUINT32                encryptionMethodSelected;
    DCUINT32                encryptionLevel;

    RANDOM_KEYS_PAIR        keyPair;
    DCUINT32                keyLength;

    DCUINT32                encryptCount;      // reset every 4K packets
    DCUINT32                totalEncryptCount; // cumulative count
    DCUINT8                 startEncryptKey[MAX_SESSION_KEY_SIZE];
    DCUINT8                 currentEncryptKey[MAX_SESSION_KEY_SIZE];
    struct RC4_KEYSTRUCT    rc4EncryptKey;

    DCUINT32                decryptCount;      // reset every 4K packets
    DCUINT32                totalDecryptCount; // cumulative count
    DCUINT8                 startDecryptKey[MAX_SESSION_KEY_SIZE];
    DCUINT8                 currentDecryptKey[MAX_SESSION_KEY_SIZE];
    struct RC4_KEYSTRUCT    rc4DecryptKey;

    DCUINT8                 macSaltKey[MAX_SESSION_KEY_SIZE];

    /************************************************************************/
    /* Server certificate and public key data                               */
    /************************************************************************/

    PDCUINT8                pbCertificate;
    DCUINT                  cbCertificate;
    PHydra_Server_Cert      pServerCert;
    PDCUINT8                pbServerPubKey;
    DCUINT32                cbServerPubKey;
    
#ifdef USE_LICENSE

    /************************************************************************/
    /* License Manager handle                                               */
    /************************************************************************/
    HANDLE                  hLicenseHandle;
#endif  //USE_LICENSE

    /************************************************************************/
    /* ID of MCS broadcast channel                                          */
    /************************************************************************/
    DCUINT                  channelID;

    /************************************************************************/
    /* User data to be passed to the Core (saved in SLOnConnected() and     */
    /* passed to Core's OnReceived callback by SLOnPacketReceived())        */
    /************************************************************************/
    PDCUINT8                pSCUserData;
    DCUINT                  SCUserDataLength;

    /************************************************************************/
    /* User data to be passed to the Server (saved in SLInitSecurity() and  */
    /* passed to NL_Connect() by SL_Connect()).                             */
    /************************************************************************/
    PDCUINT8                pCSUserData;
    DCUINT                  CSUserDataLength;

    /************************************************************************/
    /* Disconnection reason code.  This may be used to override the NL      */
    /* disconnection reason code.                                           */
    /************************************************************************/
    DCUINT                  disconnectErrorCode;

    /************************************************************************/
    /* Server version (once connected)                                      */
    /************************************************************************/
    DCUINT32                serverVersion;

    //
    // Safe checksum enabled
    //
    BOOL    fEncSafeChecksumCS;
    BOOL    fEncSafeChecksumSC;

    CAPIData                SLCapiData;
} SL_GLOBAL_DATA, DCPTR PSL_GLOBAL_DATA;


/****************************************************************************/
/* SL State Table                                                           */
/****************************************************************************/
static unsigned slStateTable[SL_NUMEVENTS][SL_NUMSTATES]
    = {

        /********************************************************************/
        /* This is not a state table in the strict sense.  It simply shows  */
        /* which events are valid in which states.  It is not used to drive */
        /* _SL.                                                              */
        /*                                                                  */
        /* Values mean                                                      */
        /* - 0 event OK in this state.                                      */
        /* - 1 warning - event should not occur in this state, but does in  */
        /*     some race conditions - ignore it.                            */
        /* - 2 error - event should not occur in ths state at all.          */
        /*                                                                  */
        /* These values are hard-coded here in order to make the table      */
        /* readable.  They correspond to the constants SL_TABLE_OK,         */
        /* SL_TABLE_WARN & SL_TABLE_ERROR.                                  */
        /*                                                                  */
        /* SL may enter Initialized state after issuing a Disconnect        */
        /* reqeest, but before the OnDisconnected indication is received.   */
        /* In this state, the Sender thread may issue SL_GetBuffer or       */
        /* SL_Disconnect (as it has not yet received the OnDisconnected     */
        /* callback).                                                       */
        /* Also, if the security exchange fails, we can enter Initialized   */
        /* state before the NL is disconnected, and so could receive        */
        /* packets from the network.                                        */
        /*                                                                  */
        /* When SL is in Disconnecting state, the Sender Thread may still   */
        /* issue GetBuffer and SendPacket calls.  If disconnect is          */
        /* requested during security exchange, then packets may be received */
        /* (until OnDisconnected is called).                                */
        /* Also, may get OnConnected in Disconnecting state if a Disconnect */
        /* is before the connection is complete (cross-over).               */
        /*                                                                  */
        /*  Terminated                                                      */
        /*  |    Initializing                                               */
        /*  |    |    Initialized                                           */
        /*  |    |    |    NL Connecting                                    */
        /*  |    |    |    |    SL Connecting                               */
        /*  |    |    |    |    |    Licensing                              */
        /*  |    |    |    |    |    |    Connected                         */
        /*  |    |    |    |    |    |    |    Disconnecting                */
        /*  |    |    |    |    |    |    |    |    Terminating             */
        /********************************************************************/
        {   0,   2,   2,   2,   2,   2,   2,   2,   2}, /* SL_Init          */
        {   2,   0,   0,   0,   0,   0,   0,   0,   2}, /* SL_Term          */
        {   2,   2,   0,   2,   2,   2,   2,   2,   2}, /* SL_Connect       */
        {   2,   2,   1,   0,   0,   0,   0,   1,   2}, /* SL_Disconnect    */
        {   2,   2,   1,   2,   0,   0,   0,   1,   2}, /* SL_SendPacket    */
        {   2,   2,   1,   1,   1,   0,   0,   1,   2}, /* SL_GetBuffer     */
        {   2,   0,   2,   2,   2,   2,   2,   2,   2}, /* SL_OnInitialized */
        {   2,   2,   2,   2,   2,   2,   2,   2,   0}, /* SL_OnTerminating */
        {   2,   2,   2,   0,   2,   2,   2,   1,   2}, /* SL_OnConnected   */
        {   2,   2,   1,   0,   0,   0,   0,   0,   0}, /* SL_OnDisconnected*/
        {   2,   2,   1,   2,   0,   2,   2,   1,   2}, /* SL_OnPktRec(Sec) */
        {   2,   2,   1,   2,   2,   0,   2,   1,   2}, /* SL_OnPktRec(Lic) */
        {   2,   2,   1,   1,   2,   2,   0,   1,   2}, /* SL_OnPktRec(Data)*/
        {   1,   1,   1,   1,   0,   0,   0,   0,   1}  /* SL_OnBufferAvail */
    };

#ifdef DC_DEBUG
/****************************************************************************/
/* State and event descriptions (debug build only)                          */
/****************************************************************************/
static const DCTCHAR slState[SL_NUMSTATES][25]
//#ifdef DC_DEFINE_GLOBAL_DATA
    = {
        _T("SL_STATE_TERMINATED"),
        _T("SL_STATE_INITIALIZING"),
        _T("SL_STATE_INITIALIZED"),
        _T("SL_STATE_NL_CONNECTING"),
        _T("SL_STATE_SL_CONNECTING"),
        _T("SL_STATE_LICENSING"),
        _T("SL_STATE_CONNECTED"),
        _T("SL_STATE_DISCONNECTING"),
        _T("SL_STATE_TERMINATING")
    }
//#endif /* DC_DEFINE_GLOBAL_DATA */
;

static const DCTCHAR slEvent[SL_NUMEVENTS][35]
//#ifdef DC_DEFINE_GLOBAL_DATA
    = {
        _T("SL_EVENT_SL_INIT"),
        _T("SL_EVENT_SL_TERM"),
        _T("SL_EVENT_SL_CONNECT"),
        _T("SL_EVENT_SL_DISCONNECT"),
        _T("SL_EVENT_SL_SENDPACKET"),
        _T("SL_EVENT_SL_GETBUFFER"),
        _T("SL_EVENT_ON_INITIALIZED"),
        _T("SL_EVENT_ON_TERMINATING"),
        _T("SL_EVENT_ON_CONNECTED"),
        _T("SL_EVENT_ON_DISCONNECTED"),
        _T("SL_EVENT_ON_RECEIVED_SEC_PACKET"),
        _T("SL_EVENT_ON_RECEIVED_LIC_PACKET"),
        _T("SL_EVENT_ON_RECEIVED_DATA_PACKET"),
        _T("SL_EVENT_ON_BUFFERAVAILABLE")
    }
//#endif /* DC_DEFINE_GLOBAL_DATA */
;

#endif /* DC_DEBUG */


class CUI;
class CUH;
class CRCV;
class CCD;
class CSND;
class CCC;
class CIH;
class COR;
class CSP;
class CNL;
class CMCS;
class CTD;
class CCO;
class CCLX;
class CLic;
class CChan;


class CSL
{
public:
    CSL(CObjs* objs);
    ~CSL();

public:
    //
    // API
    //

    DCVOID DCAPI SL_Init(PSL_CALLBACKS pCallbacks);

    DCVOID DCAPI SL_Term(DCVOID);
    
    DCVOID DCAPI SL_Connect(BOOL bInitateConnect,
                            PDCTCHAR pServerAddress,
                            DCUINT   transportType,
                            PDCTCHAR pProtocolName,
                            PDCUINT8  pUserData,
                            DCUINT   userDataLength);

    
    DCVOID DCAPI SL_Disconnect(DCVOID);
    
    DCVOID DCAPI SL_SendPacket(PDCUINT8   pData,
                               DCUINT     dataLen,
                               DCUINT     flags,
                               SL_BUFHND  bufHandle,
                               DCUINT     userID,
                               DCUINT     channel,
                               DCUINT     priority);
    
    void DCAPI SL_SendFastPathInputPacket(BYTE FAR *, unsigned, unsigned,
            SL_BUFHND);
    
    DCBOOL DCAPI SL_GetBufferRtl(DCUINT     dataLen,
                                 PPDCUINT8  pBuffer,
                                 PSL_BUFHND pBufHandle);
    
    DCBOOL DCAPI SL_GetBufferDbg(DCUINT     dataLen,
                                 PPDCUINT8  pBuffer,
                                 PSL_BUFHND pBufHandle,
                                 PDCTCHAR   pCaller);
    
    /****************************************************************************/
    /* Debug and retail versions of SL_GetBuffer                                */
    /****************************************************************************/
    #ifdef DC_DEBUG
    #define SL_GetBuffer(dataLen, pBuffer, pBufHandle) \
        SL_GetBufferDbg(dataLen, pBuffer, pBufHandle, trc_fn)
    #else
    #define SL_GetBuffer(dataLen, pBuffer, pBufHandle) \
        SL_GetBufferRtl(dataLen, pBuffer, pBufHandle)
    #endif
    
    DCVOID DCAPI SL_FreeBuffer(SL_BUFHND bufHandle);
    
    DCVOID DCAPI SL_SendSecurityPacket(PDCVOID pData,
                                       DCUINT dataLength);
    EXPOSE_CD_NOTIFICATION_FN(CSL, SL_SendSecurityPacket);

    DCVOID DCAPI SL_SendSecInfoPacket(PDCVOID pData,
                                      DCUINT dataLength);

    EXPOSE_CD_NOTIFICATION_FN(CSL, SL_SendSecInfoPacket);
    
    DCVOID DCAPI SL_EnableEncryption(ULONG_PTR pEnableEncryption);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CSL, SL_EnableEncryption);
    
    /****************************************************************************/
    /* Loopback testing                                                         */
    /****************************************************************************/
    #ifdef DC_LOOPBACK
    DCVOID DCAPI SL_LoopBack(DCBOOL start);
    DCVOID DCAPI SL_LoopbackLoop(DCUINT ignored);
    #endif /* DC_LOOPBACK */
    
public:

    //
    // Data members
    //
    SL_GLOBAL_DATA _SL;


public:
    /****************************************************************************/
    /* Callbacks from NL (passed on NL_Init())                                  */
    /****************************************************************************/
    DCVOID DCCALLBACK SL_OnInitialized(DCVOID);
    
    DCVOID DCCALLBACK SL_OnTerminating(DCVOID);
    
    DCVOID DCCALLBACK SL_OnConnected(DCUINT   channelID,
                                     PDCVOID  pUserData,
                                     DCUINT   userDataLength,
                                     DCUINT32 serverVersion);
    
    DCVOID DCCALLBACK SL_OnDisconnected(DCUINT reason);
    
    HRESULT DCCALLBACK SL_OnPacketReceived(PDCUINT8   pData,
                                          DCUINT     dataLen,
                                          DCUINT     flags,
                                          DCUINT     channelID,
                                          DCUINT     priority);
    
    DCVOID DCCALLBACK SL_OnBufferAvailable(DCVOID);

    HRESULT DCAPI SL_OnFastPathOutputReceived(BYTE FAR *, unsigned,
                                              BOOL, BOOL);

    //
    // Immediately drop the link
    //
    HRESULT SL_DropLinkImmediate(UINT reason);

    //
    // Static inline versions
    //
    static void DCCALLBACK SL_StaticOnInitialized(PVOID inst)
    {
        ((CSL*)inst)->SL_OnInitialized();
    }

    static void DCCALLBACK SL_StaticOnTerminating(PVOID inst)
    {
        ((CSL*)inst)->SL_OnTerminating();
    }
    
    static void DCCALLBACK SL_StaticOnConnected(
            PVOID inst,
            unsigned channelID,
            PVOID  pUserData,
            unsigned userDataLength,
            UINT32 serverVersion)
    {
        ((CSL*)inst)->SL_OnConnected( channelID, pUserData, userDataLength, serverVersion);
    }
    
    static void DCCALLBACK SL_StaticOnDisconnected(PVOID inst, unsigned reason)
    {
        ((CSL*)inst)->SL_OnDisconnected( reason);
    }
    
    static HRESULT DCCALLBACK SL_StaticOnPacketReceived(
            PVOID inst,
            BYTE *pData,
            unsigned dataLen,
            unsigned flags,
            unsigned channelID,
            unsigned priority)
    {
        return ((CSL*)inst)->SL_OnPacketReceived(pData, dataLen, flags, channelID, priority);
    }
    
    static void DCCALLBACK SL_StaticOnBufferAvailable(PVOID inst)
    {
        ((CSL*)inst)->SL_OnBufferAvailable();
    }


    DCVOID DCAPI SLIssueDisconnectedCallback(ULONG_PTR reason);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN( CSL, SLIssueDisconnectedCallback); 

    DCVOID DCAPI SLSetReasonAndDisconnect(ULONG_PTR reason);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN( CSL, SLSetReasonAndDisconnect);
    
    DCVOID DCAPI SLLicenseData(PDCVOID pData, DCUINT dataLen);
    EXPOSE_CD_NOTIFICATION_FN( CSL, SLLicenseData);

    DCVOID DCAPI SL_SetEncSafeChecksumCS(ULONG_PTR f)
    {
        _SL.fEncSafeChecksumCS = (BOOL)f;
    }
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CSL, SL_SetEncSafeChecksumCS);

    BOOL SL_GetEncSafeChecksumCS()
    {
        return _SL.fEncSafeChecksumCS;
    }

    DCVOID DCAPI SL_SetEncSafeChecksumSC(BOOL f)
    {
        _SL.fEncSafeChecksumSC = f;
    }
    BOOL SL_GetEncSafeChecksumSC()
    {
        return _SL.fEncSafeChecksumSC;
    }


private:
    
    /****************************************************************************/
    /* Internal functions                                                       */
    /****************************************************************************/
    DCVOID DCINTERNAL SLInitSecurity(DCVOID);
    
    DCVOID DCINTERNAL SLInitCSUserData(DCVOID);

    DCVOID DCINTERNAL SLSendSecInfoPacket(DCVOID);
    
    DCBOOL DCINTERNAL SLSendSecurityPacket(PDCUINT8 serverPublicKey,
                                           DCUINT32 serverPublicKeyLen);
    
    HRESULT DCINTERNAL SLReceivedDataPacket(PDCUINT8   pData,
                                           DCUINT     dataLen,
                                           DCUINT     flags,
                                           DCUINT     channelID,
                                           DCUINT     priority);

    DCBOOL DCINTERNAL SLDecryptRedirectionPacket(PDCUINT8   *ppData,
                                                 DCUINT     *pdataLen);


    DCBOOL DCINTERNAL SL_DecryptHelper(PDCUINT8   pData,
                                       DCUINT     *pdataLen);

    DCVOID DCINTERNAL SLReceivedSecPacket(PDCUINT8   pData,
                                          DCUINT     dataLen,
                                          DCUINT     flags,
                                          DCUINT     channelID,
                                          DCUINT     priority);
    
    DCVOID DCINTERNAL SLReceivedLicPacket(PDCUINT8   pData,
                                          DCUINT     dataLen,
                                          DCUINT     flags,
                                          DCUINT     channelID,
                                          DCUINT     priority);
    
    DCVOID DCINTERNAL SLFreeConnectResources(DCVOID);
    
    DCVOID DCINTERNAL SLFreeInitResources(DCVOID);
    
    
    DCBOOL DCINTERNAL SLValidateServerCert( PDCUINT8        pbCert, 
                                            DCUINT32        cbCert, 
                                            CERT_TYPE *     pCertType );
    
    
    #ifdef DC_LOOPBACK
    DCVOID DCINTERNAL SLLoopbackSendPacket(PDCUINT8   pData,
                                           DCUINT     dataLen,
                                           SL_BUFHND  bufHandle,
                                           PDCUINT8   pRefData);
    
    DCVOID DCINTERNAL SLLBQueueAdd(PSL_LB_PACKET pPacket,
                                   PSL_LB_Q_ELEMENT pRoot);
    
    PSL_LB_Q_ELEMENT DCINTERNAL SLLBQueueRemove(PSL_LB_Q_ELEMENT pRoot);
    
    DCVOID DCINTERNAL SLLBPacketCheck(PDCUINT8 pData, DCUINT dataLen);
    
    #endif /* DC_LOOPBACK */
    
    DCBOOL DCINTERNAL SLGetComputerAddressW(PDCUINT8 szBuff);
    BOOL
    SLComputeHMACVerifier(
        PBYTE pCookie,     //IN - the shared secret
        LONG cbCookieLen,  //IN - the shared secret len
        PBYTE pRandom,     //IN - the session random
        LONG cbRandomLen,  //IN - the session random len
        PBYTE pVerifier,   //OUT- the verifier
        LONG cbVerifierLen //IN - the verifier buffer length
        );

private:
    CUT* _pUt;
    CUI* _pUi;
    CNL* _pNl;
    CUH* _pUh;
    CRCV* _pRcv;
    
    CCD* _pCd;
    CSND* _pSnd;
    CCC* _pCc;
    CIH* _pIh;
    COR* _pOr;
    CSP* _pSp;

    CMCS* _pMcs;
    CTD*  _pTd;
    CCO*  _pCo;
    CCLX* _pClx;
    CLic* _pLic;
    CChan* _pChan;

private:
    CObjs* _pClientObjects;
    BOOL   _fSLInitComplete;
};

#endif // _H_SL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\res_inc.c ===
//
// res_inc.c
//
// Resources in a C file for ARC on SP1
//
// Copyright Microsoft Corportation 2002
// (nadima)
//
// Data Generated by bintoc.pl
//

static const DWORD g_DisconImageBits[] = {
0x3a2e4d42,0x00000000,0x00360000,0x00280000,0x00460000,0x00460000,0x00010000,
0x00000018,0x39f80000,0x00000000,0x00000000,0x00000000,0x00000000,0x39390000,
0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,
0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,
0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,
0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,
0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,
0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,
0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,
0x39fb3939,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0x39fb3939,0x3939fb39,
0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,
0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,
0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,
0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,
0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,
0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,
0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,
0x39390000,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,
0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,
0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,
0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,
0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,
0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,
0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,
0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,
0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,
0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,
0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,
0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,
0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x84d8698b,0x5975c064,0xb4536eb4,0x6eb4536e,0x536eb453,
0xb4536eb4,0x75c0536e,0x6484d859,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,
0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x6484d869,0xb45975c0,0x6eb4536e,0x536eb453,0xb4536eb4,0x5f9c536e,
0x33416a48,0x52263252,0x32522632,0x26325226,0x52263252,0x416a2632,0x485f9c33,
0xb4536eb4,0x6eb4536e,0x536eb453,0xc0536eb4,0x84d85975,0x698be464,0xe4698be4,
0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,
0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x5975c069,0x52374877,
0x32522632,0x26325226,0x52263252,0x2b452632,0x151c2e23,0x22101522,0x15221015,
0x10152210,0x22101522,0x1c2e1015,0x232b4515,0x52263252,0x32522632,0x26325226,
0x77263252,0x75c03748,0x698be459,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,
0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x536eb469,0x22263252,0x15221015,0x10152210,0x1c101522,
0x74020d11,0xa67402a6,0x02a67402,0x7402a674,0xa67402a6,0x02a67402,0x1522a674,
0x10152210,0x22101522,0x15221015,0x10152210,0x52101522,0x6eb42632,0x698be453,
0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,
0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xd8698be4,0x76c26484,0x5470b759,0xb75470b7,
0x70b75470,0x5470b754,0xb75470b7,0x70b75470,0x5470b754,0xb75470b7,0x70b75470,
0x5470b754,0xb05470b7,0x6eb4516b,0x536eb453,0xb75470b7,0x70b75470,0x26262654,
0x26262626,0x26262626,0x26262626,0x26262626,0xaf282626,0xebc12ad9,0x2ad9af28,
0xaf28ebc1,0xebc12ad9,0x02ebc12a,0x2626a674,0x26262626,0x26262626,0x26262626,
0x26262626,0x52262626,0x6eb42632,0x698be453,0xe4698be4,0x8be4698b,0x698be469,
0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xb76484d8,0x5a955470,0x3f538945,0x893f5389,0x53893f53,0x3f53893f,0x893f5389,
0x53893f53,0x3f53893f,0x893f5389,0x53893f53,0x3f53893f,0x8d3f5389,0x53894156,
0x3d50843f,0x893f5389,0x53893f53,0x9999993f,0x73737373,0x73737373,0x73737373,
0x73737373,0xaf287373,0xf4d55dd9,0x5df4d55d,0xd55df4d5,0xf4d55df4,0x02f4d55d,
0x7373a674,0x73737373,0x73737373,0x73737373,0x73737373,0x52262626,0x6eb42632,
0x698be453,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,
0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x955976c2,0x63a1455a,0x5470b74b,
0xb75470b7,0x70b75470,0x5470b754,0xb75470b7,0x70b75470,0x5470b754,0xb75470b7,
0x70b75470,0x5470b754,0xb65470b7,0x70b7546f,0x536eb454,0xb75470b7,0x70b75470,
0x99999954,0xa6a6a6a6,0xa6a6a6a6,0xa6a6a6a6,0xa6a6a6a6,0xaf28a6a6,0xf4d55dd9,
0x95fbe895,0xe895fbe8,0xfbe895fb,0x13f4d55d,0xa6a6ba8b,0xa6a6a6a6,0xa6a6a6a6,
0xa6a6a6a6,0xa6a6a6a6,0x52262626,0x6eb42632,0x698be453,0xe4698be4,0x8be4698b,
0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0x295470b7,0x04421004,0x21044a18,0x4a21044a,0x044a2104,0x21044a21,
0x4a21044a,0x044a2104,0x21044a21,0x0021044a,0x00000000,0x00000000,0x37000000,
0x040a1905,0x00000005,0x00000000,0x00000000,0x99999900,0xe6e6e6e6,0xe6e6e6e6,
0xe6e6e6e6,0xe6e6e6e6,0xaf28e6e6,0xfbe895d9,0x95fbe895,0xe895fbe8,0xfbf3c6fb,
0x13fbe895,0xe6e6ba8b,0xe6e6e6e6,0xe6e6e6e6,0xe6e6e6e6,0xe6e6e6e6,0x77262626,
0x75c03748,0x698be459,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,
0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x8921044a,0x70b73f53,
0x698be454,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x99999969,0xffdff1ff,0xf1ffdff1,0xdff1ffdf,0xffe0f1ff,0xaf28e0f1,
0xfbf3c6d9,0xc6fbf3c6,0xf3c6fbf3,0xfbf3c6fb,0x13fbf3c6,0xf1ffba8b,0xdff1ffdf,
0xffdff1ff,0xf1ffdff1,0xdff1ffdf,0xc0262626,0x84d85975,0x698be464,0xe4698be4,
0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,
0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0x8921044a,0x70b73f53,0x698be454,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x99999969,0x99999999,
0x99999999,0x99999999,0x99999999,0xb4479999,0xeaeae4d8,0xffffffff,0xffffffff,
0xffffffff,0x13eaeae4,0x9999ba8b,0x99999999,0x99999999,0x99999999,0x99999999,
0xe4999999,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,
0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x8921044a,
0x70b73f53,0x698be454,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe2698be4,
0xaf28688a,0xd8b447d9,0x47d8b447,0xaf28d8b4,0xd9af28d9,0x47d9af28,0x5a95d8b4,
0x698be445,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,
0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0x8921044a,0x70b73f53,0x698be454,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x99999969,0xe6e0f1ff,
0xa6a6e6e6,0x737373a6,0x52262626,0x6eb42632,0x698be453,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xa121044a,0x76c24b63,0x698be459,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x99999969,0xe6e0f1ff,0xa6a6e6e6,0x737373a6,0x52262626,
0x6eb42632,0x698be453,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,
0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8ae2698b,0x6687de68,0xb621044a,0x72bb546f,0x5a77c456,
0xc45a77c3,0x78c65a77,0x5e7ccb5c,0xdb6181d2,0x8ae26586,0x698be468,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x99999969,
0xe6e0f1ff,0xa6a6e6e6,0x737373a6,0x52262626,0x6eb42632,0x698be453,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xde698be4,0x7ccb6687,
0x536eb45e,0x89210452,0x4c7c3f53,0x37487739,0x77344572,0x4c7c3748,0x3d508439,
0xad455a95,0x78c64f69,0x6484d85c,0xe4688ae2,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x99999969,0xe6e0f1ff,0xa6a6e6e6,0x737373a6,
0x77262626,0x75c03748,0x698be459,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,
0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x688ae269,0xb76383d7,0x568d5470,0x33416a41,0x43253150,0x28431e28,
0x1921371e,0x37192137,0x253d1921,0x1e28431c,0x63232e4b,0x50842e3d,0x4f69ad3d,
0xe1607fd0,0x8be46889,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x99999969,0xe6e0f1ff,0xa6a6e6e6,0x737373a6,0xc0262626,0x84d85975,0x698be464,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,
0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x6383d769,0x77516bb0,
0x35573748,0x363b5b29,0x874c4f73,0x61875f61,0x686c985f,0x87686c98,0x4f735f61,
0x363b5b4c,0x37232b45,0x2b451921,0x33416a23,0xd04b63a1,0x8ae2607f,0x698be468,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x99999969,0x99999999,0x99999999,
0x99999999,0xe4999999,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,
0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,
0xe4698be4,0x89e0698b,0x5874be67,0x73404c7e,0x769e4c4f,0xb4b7c875,0xdacdcdd4,
0xcedacece,0xcecedace,0xd2c6c6d7,0xa4c3b8b8,0x9596c2a2,0x7375769e,0x2b454c4f,
0x1c253d23,0xb033416a,0x86db516b,0x698be465,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x044a698b,0x3f538921,0xe45470b7,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,
0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x84d7698b,0x4f66a765,
0xc9686c98,0xe2e1c4c2,0xe5e5e4e2,0xdee2e2e1,0xd4dadddd,0xcecedad4,0xd2c6c6d7,
0xb8d2b8b8,0xaaaac2b8,0xc29b9bc2,0x6c989b9b,0x30365268,0x95232e4b,0x7fd0455a,
0x698be460,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x0442698b,0x3f538918,0xe45470b7,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,
0x698be469,0xe4698be4,0x83d5698b,0x6d77b465,0xedd4d4da,0xeae4f1f1,0xe5e5e4ea,
0xdee2e2e1,0xd4dadddd,0xd4d4dad4,0xd7c0c0d7,0xcdd4c0c0,0xb4b7c8cd,0xc2aaaac2,
0x9dcb9596,0x75769e9d,0x7c303652,0x6eb4394c,0x5e7ccb53,0xdb6181d2,0x8ae26586,
0x698be468,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x044a698b,0x3f538921,0xe45470b7,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,
0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x83d1698b,
0xb4b7c86b,0xecf1f1ed,0xecececec,0xecececec,0xe1e6e6e6,0xdddee2e2,0xd4d4dadd,
0xd7c0c0d7,0xb8d2c0c0,0xaeaecdb8,0xb8aeaecd,0x9dcb9697,0x9596c29d,0x544c4f73,
0x45722733,0x3d508434,0xad455a95,0x78c64f69,0x6484d85c,0xe4688ae2,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xbe6383d7,0x05375874,0x33416a19,0xd7455a95,0x8be46383,0x698be469,0xe4698be4,
0x83d7698b,0x5874be63,0xb1526cb1,0x74be526c,0x6383d758,0xe4698be4,0x8be4698b,
0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,
0x8be4698b,0x698be469,0xe4698be4,0x83d1698b,0xc6c6d76b,0xedf1f1ed,0xf8f6f1f1,
0xf8f8f6f8,0xe6f1f1ed,0xdddee6e6,0xd4d4dadd,0xd2b8b8d2,0x9dcbb8b8,0x9d9dcb9d,
0xbd9d9dcb,0x9dcb9090,0x9d9dcb9d,0x374c4f73,0x253d1921,0x1e28431c,0x63232e4b,
0x50842e3d,0x4f69ad3d,0xe1607fd0,0x8be46889,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x725874be,0x0b163445,0x151c2e0a,
0xa5253150,0x83d74d63,0x698be463,0xd7698be4,0x63a56383,0x2e3d634d,0x4b232e4b,
0x4572232e,0x5874be34,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,
0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,
0x8cde698b,0x9aa4cf6d,0xf6f1f1ed,0xfffff8f8,0xffffffff,0xe4f8f8f6,0xe2e1eaea,
0xcecedae2,0xd2aeaecd,0x8dcda7a5,0x8d8dcd8d,0xb88d8dcd,0x9dcb828b,0x9596c29d,
0x8775769e,0x4f735f61,0x363b5b4c,0x37232b45,0x2b451921,0x33416a23,0xd04b63a1,
0x8ae2607f,0x698be468,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x688ae269,0x635672bb,0x040a2e3d,0x05040a05,0x570d111c,0x63a52935,0x6383d74d,
0xa56383d7,0x33544d63,0x0d111c27,0x220a0b16,0x3d631015,0x5874be2e,0xe4698be4,
0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,
0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x708cd469,0xf6c0c0d7,
0xcde4f8f8,0xcecedad1,0xece8e2e9,0xe6e3ecec,0xc0c0d7e6,0xcdaaa8ca,0x7bcc8d8d,
0x8285cf7b,0xbf7b7bcc,0x9bc28583,0xaeaecd9b,0xd2c6c6d7,0xa4c3b8b8,0x9596c2a2,
0x7375769e,0x2b454c4f,0x1c253d23,0xb033416a,0x86db516b,0x698be465,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x1fba1e1f,0x1e1fba1e,
0xba1e1fba,0x220a0b16,0x34551015,0x455a9527,0x57455a95,0x1e1f2935,0xba1e1fba,
0x1fba1e1f,0x63a1ba1e,0x6383d74b,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,
0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xcf7892d9,0x83bf9aa4,0x8285cf85,0xc9a7a5d2,
0xc6d4c4bb,0xaaa8cacc,0xce8d8dcd,0x72ce7172,0x7172ce71,0xbf6d6bc7,0xb8d28583,
0xcecedab8,0xd2c6c6d7,0xb8d2b8b8,0xaaaac2b8,0xc29b9bc2,0x6c989b9b,0x30365268,
0x95232e4b,0x7fd0455a,0x698be460,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0x21f78e8e,0x2121c921,0xc92121c9,0x1cc92121,0x15220d11,
0x1c253d10,0x211c253d,0x2121c921,0xc92121c9,0x8ec92121,0x83d7f78e,0x698be463,
0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,
0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xc06889e1,0x80bb677b,0x4f97e474,0xd358a8eb,0x94cd879c,0x8583bf9a,0xc56d6bc7,
0x5bc55b5b,0x6061c95b,0xb96061c9,0xd4da908e,0xcecedad4,0xd7c0c0d7,0xcdd4c0c0,
0xb4b7c8cd,0xc2aaaac2,0x9dcb9b9b,0x75769e9d,0x8d363b5b,0x7fd04156,0x698be460,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x76698be4,
0x2121e076,0xc92121c9,0x1fc92121,0x0b16ba1e,0x0d111c0a,0x21ba1e1f,0x2121c921,
0xc92121c9,0xd7e07676,0x8be46383,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xb46586db,0x89c96d77,0x1ca0f675,
0xff14acff,0xacf331b4,0x6e9bdf53,0xc38285cf,0x4fb3766c,0x554fb355,0xc3554fb3,
0xdddea2a4,0xd4d4dadd,0xd7c0c0d7,0xb8d2c0c0,0xaeaecdb8,0xb8aeaecd,0x9dcb9697,
0x909ac69d,0xa5505685,0x83d74d63,0x698be463,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe2698be4,0x554f688a,0xda2929db,0x29da2929,
0x1e1fda29,0xba1e1fba,0x29da2929,0x2929da29,0xdb554fda,0xe46383d7,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,
0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xbb6584d7,0x89c97480,0x1ca0f675,0xff14acff,0xb0fe14ac,0x31b4ff24,
0xec4eb5f7,0x92d96bac,0x6d6bc778,0xca554fb3,0xdddeaaa8,0xd4d4dadd,0xd2b8b8d2,
0x9dcbb8b8,0x9d9dcb9d,0xbd9d9dcb,0x9dcb9090,0x9d9dcb9d,0xc6686c98,0x89e05c78,
0x698be467,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x044a698b,0xeb353621,0x29da2929,0x2929da29,0xda2929da,0x29da2929,
0x3536da29,0x526cb1eb,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xaf6681cf,0x99d98382,
0x24b0fe5f,0xff31b4ff,0xb4ff31b4,0x31b4ff31,0xff31b4ff,0xbcff36bc,0x5eb4f243,
0xcf6e9bdf,0x9ed38285,0xb8b8d2a3,0xd2aeaecd,0x8dcda7a5,0x8d8dcd8d,0xbf8d8dcd,
0x9bc28583,0x9090bd9b,0xde677bc0,0x8be46687,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x044a698b,0xefc6c621,
0x36eb3536,0x3536eb35,0xeb3536eb,0x39eb3536,0x253dce39,0x455a951c,0xe46383d7,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,
0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x688ae269,0xb9677bc0,0x99d9908e,0x31b4ff5f,0xff3cbcff,0xbcff43bc,
0x43bcff43,0xff43bcff,0xbcff43bc,0x36bcff3c,0xf73cbcff,0xa0e74eb5,0x6b83d161,
0xcd8285cf,0x7bcc8d8d,0x8285cf7b,0xbf7b7bcc,0x96c28583,0x7480bb95,0xe46788df,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x044a698b,0x2e3d6321,0x36efc6c6,0x3536eb35,0xeb3536eb,
0x36eb3536,0x1522eb35,0x29355710,0xd74d63a5,0x8be46383,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,
0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x6687de69,0xc26d77b4,
0xa8eb9596,0x3cbcff58,0xff4cbfff,0xc3ff4cbf,0x52c3ff52,0xff52c3ff,0xbfff52c3,
0x4cbfff4c,0xff43bcff,0xbcff3cbc,0x44adf536,0xce7172ce,0x72ce7172,0x7172ce71,
0xb46d6bc7,0x6c986d77,0x5e7ccb68,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xd7698be4,0x05376383,
0x19213719,0x39eb3536,0x4343fb39,0xfb3939fe,0x36fb3939,0x0b16eb35,0x1015220a,
0xa5293557,0x83d74d63,0x698be463,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,
0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x6584d769,0xc68382af,0xb0ed909a,0x4ac5ff50,0xfe52c3ff,
0xc6fe5ac6,0x5dcaff5a,0xff5dcaff,0xc6fe5dca,0x5ac6fe5a,0xff52c3ff,0xbcff4cbf,
0x44adf543,0xc56d6bc7,0x5bc55b5b,0x5b5bc55b,0x856061c9,0x4c7c5056,0x5672bb39,
0xe06383d7,0x8be46789,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xa56383d7,0x0b164d63,0xe74a4a0a,0x56fb3939,0x706fff56,
0xfe4343ff,0x39fb3939,0x4a4afb39,0x0a0b16e7,0x57101522,0x63a52935,0x6383d74d,
0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,
0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x6681cf69,
0xc88a8dad,0xbbf38b9c,0x57caff52,0xff63cbff,0xcfff63cb,0x69cfff69,0xff69cfff,
0xcfff69cf,0x63cbff69,0xfe63cbff,0xc3ff5ac6,0x58a8eb52,0xc37172ce,0x4fb3766c,
0x554fb355,0x6a554fb3,0x33543341,0x394c7c27,0xc64d63a5,0x86db5c78,0x698be465,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x635874be,
0x5a5a2e3d,0xfe4343e9,0x6fff5656,0x7676ff70,0xf78e8ee0,0x43ff5656,0x4343fe43,
0xe95a5afe,0x220a0b16,0x3d631015,0x5874be2e,0xe4698be4,0x8be4698b,0x698be469,
0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,
0x698be469,0xe4698be4,0x8ae2698b,0x6a82c568,0xcf9697b8,0xc6fe7fa5,0x69cfff5a,
0xff69cfff,0xd3ff6fd3,0x79d6ff73,0xff79d6ff,0xd3ff79d6,0x6fd3ff73,0xff69cfff,
0xcaff63cb,0x61a0e757,0xec5f8cdb,0x92d96bac,0x766cc378,0x6a554fb3,0x21373341,
0x1e284319,0x952e3d63,0x7ccb455a,0x688ae25e,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0x765874be,0x4343e076,0xfe4343fe,0x4fff706f,
0x83d7db55,0x698be463,0x56ff706f,0x4343ff56,0xe95a5afe,0x4be07676,0x4572232e,
0x5874be34,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,
0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x87de698b,
0x7480bb66,0xd4aaaac2,0xcbff77ac,0x6fd3ff63,0xff79d6ff,0xdbff7bda,0x83dbff83,
0xff83dbff,0xdbff83db,0x79d6ff83,0xff73d3ff,0xcfff6fd3,0x6e9bdf69,0xff4f97e4,
0xbcff36bc,0x5eb4f243,0xb46e9bdf,0x4a876d77,0x2c2e5648,0x721e2843,0x72bb3445,
0x6789e056,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0x43f7adad,0x8e8efe43,0xf78e8ef7,0xd7e95a5a,0x8be46383,0x698be469,0x56698be4,
0x706fff56,0xf78e8eff,0xadff5656,0x74bef7ad,0x6383d758,0xe4698be4,0x8be4698b,
0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,
0x8be4698b,0x698be469,0xe4698be4,0x86db698b,0x8382af65,0xdeaaaac2,0xd3ff71b5,
0x7bdaff6f,0xff83dbff,0xdfff8add,0x93e3ff8f,0xff8fdfff,0xdfff93e3,0x8addff8f,
0xff83dbff,0xd3ff79d6,0x6e9bdf6f,0xff4f97e4,0xbcff43bc,0x36bcff3c,0xf73cbcff,
0xa0e74eb5,0x5c78c661,0x72484a87,0x74be3445,0x688ae258,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x6fff706f,0x706fff70,0xff706fff,
0xe4546fb6,0x8be4698b,0x698be469,0xe4698be4,0x706f698b,0xff706fff,0x8eff706f,
0x8be4f78e,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,
0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,
0x84d2698b,0x9290b066,0xe6a4adc4,0xdaff6fbf,0x83dbff7b,0xff8ce3ff,0xe6ff93e3,
0x9ee9ff9b,0xff9ee9ff,0xe6ff9ee9,0x93e3ff9b,0xff8addff,0xd6ff83db,0x708cd479,
0xff58a8eb,0xbfff52c3,0x4cbfff4c,0xff43bcff,0xbcff3cbc,0x44adf536,0x845662b5,
0x78c63d50,0x698be45c,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x044a698b,0x3f538921,0xe45470b7,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,
0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x82c5698b,0xb0b0be6a,0xef9baac6,
0xdbff72cb,0x8fdfff83,0xff9be6ff,0xeeff9ee9,0xa8eeffa8,0xffa8eeff,0xeeffa8ee,
0x9ee9ffa8,0xff93e3ff,0xd4fa8ce3,0x7589c982,0xff5eb4f2,0xc6fe5dca,0x5ac6fe5a,
0xff52c3ff,0xbcff4cbf,0x44adf543,0x894d63a5,0x7ccb3f53,0x698be45e,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x044a698b,
0x3f538921,0xe45470b7,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,
0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,
0xe4698be4,0x80bb698b,0xc4bbc974,0xf78fafc6,0xe3ff78d8,0x96e8ff8c,0xff9ee9ff,
0xf3fea9f6,0xb7f6ffb2,0xffb7f6ff,0xf3feb7f6,0xa8eeffb2,0xff9ee9ff,0xd0f396e8,
0x7589c987,0xff6cc1f5,0xcfff69cf,0x63cbff69,0xfe63cbff,0xc3ff5ac6,0x58a8eb52,
0x8d505498,0x77c44156,0x5976c25a,0xb75470b7,0x70b75470,0x5470b754,0xb75470b7,
0x70b75470,0x5470b754,0xb75470b7,0x044a5470,0x455a9521,0xe45976c2,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,
0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x9cc8698b,0xc4c2c98b,
0xbc8c94a6,0xb5d58da7,0x97d0e58c,0xfea4e1f1,0xfcffb2f3,0xc8fefebd,0xfec8fefe,
0xfcffc8fe,0xb2f3febd,0xffa8eeff,0xc5e996e8,0x7d94cc8b,0xff78cffb,0xd3ff79d6,
0x6fd3ff73,0xff69cfff,0xcaff63cb,0x61a0e75d,0x95484a87,0x72bb455a,0x4b63a156,
0x893f5389,0x53893f53,0x3f53893f,0x893f5389,0x53893f53,0x3f53893f,0x893f5389,
0x04423f53,0x5470b718,0xe46484d8,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,
0x698be469,0xe4698be4,0xaec8698b,0xcdcdd4a4,0xa4a19eaa,0x8e9f9994,0x918e9f91,
0xbc8c94a6,0xb6cc8da7,0xb1d0dca5,0xf3bde0e8,0xfcffc4ee,0xbdfcffbd,0xffa9f6ff,
0xc5e9a9f6,0x7d94cc8b,0xff82d4fa,0xdbff83db,0x79d6ff83,0xff73d3ff,0xcfff6fd3,
0x6e9bdf69,0x9c484a87,0x7ccb485f,0x5976c25e,0xb75470b7,0x70b75470,0x5470b754,
0xb75470b7,0x70b75470,0x5470b754,0xb75470b7,0x04295470,0x6484d810,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,
0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x94cc698b,
0xa5b6cc7d,0xc8b4b7c8,0xb0beb4b7,0xa9a7bab0,0xa4a19eaa,0x87a69994,0x8a87a68a,
0xb88a8dad,0xaac69697,0x9fbed79b,0xf49fcee4,0xb5d59ce1,0x879cd38c,0xff8fdfff,
0xdfff93e3,0x8addff8f,0xff83dbff,0xd3ff79d6,0x708cd46f,0xa7484a87,0x04524f66,
0x21044a21,0x4a21044a,0x044a2104,0x21044a21,0x4a21044a,0x044a2104,0x21044a21,
0x4a21044a,0x8be42104,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x6e8de069,0xd97892d9,0x9cd37892,
0x879cd387,0xc69aa4cf,0xa4c39baa,0xa9a7baa2,0xb09290b0,0x87a69290,0x8382af8a,
0xb88382af,0x8bb8828b,0x8cb5d582,0xff9be6ff,0xe6ff9ee9,0x93e3ff9b,0xff8addff,
0xd6ff83db,0x6a82c579,0xb1404c7e,0x88df526c,0x698be467,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,
0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xde6b8ce2,0x89c96d8c,
0xa9a7ba75,0xd5a4adc4,0xb0ce8cb5,0x9baac696,0xb29090bd,0x82af8d87,0x99c0de83,
0xffa8eeff,0xeeffa8ee,0x9ee9ffa8,0xff93e3ff,0xd4fa8ce3,0x6d77b482,0xbb404c7e,
0x89e15672,0x698be468,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,
0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x80bb698b,0xc4bbc974,0xf78fafc6,0xe3ff78d8,
0x96e8ff8c,0xffa8eeff,0xf3fea9f6,0xb7f6ffb2,0xffb7f6ff,0xf3feb7f6,0xa8eeffb2,
0xff9ee9ff,0xd0f396e8,0x6d77b487,0xc1404c7e,0x8ae25976,0x698be468,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,
0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x9ac6698b,0xc4c2c990,0xbc8c94a6,0xb5d58da7,0x97d0e58c,0xfea4e1f1,0xfcffb2f3,
0xc8fefebd,0xfec8fefe,0xfcffc8fe,0xb2f3febd,0xffa8eeff,0xc5e996e8,0x686c988b,
0xc63d5084,0x8be45c78,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,
0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0xaec8698b,0xcdcdd4a4,0xa4a19eaa,
0x8e9f9994,0x918e9f91,0xbc8c94a6,0xb6cc8da7,0xb1d0dca5,0xf3bde0e8,0xfcffc4ee,
0xbdfcffbd,0xffa9f6ff,0xc5e9a9f6,0x5f61878b,0xcb3f5389,0x8be45e7c,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x94cc698b,0xa5b6cc7d,0xc8b4b7c8,0xb0beb4b7,0xa9a7bab0,0xa4a19eaa,
0x87a69994,0x8a87a68a,0xb88a8dad,0xaac69697,0x9fbed79b,0xf49fcee4,0xb5d59ce1,
0x686c988c,0xd44b63a1,0x8be46281,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,
0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x6e8de069,
0xd97892d9,0x9cd37892,0x879cd387,0xc69aa4cf,0xa4c39baa,0x9b9bc2a2,0xb09697b8,
0x87a69290,0x8382af8a,0xb88382af,0x8bb8828b,0x6d77b482,0xe0607fd0,0x8be46789,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xde6b8ce2,0x92d96d8c,0x7892d978,0xc8879cd3,0x9ac68b9c,0x9596c290,0xb2908eb9,
0x82af8d87,0x7589c983,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,
0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,
0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,
0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,
0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,
0x39390000,0xfb3939fb,0xe4fb3939,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0x39698be4,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0xe4fb3939,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,
0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,
0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0xe4698be4,
0x8be4698b,0x698be469,0xe4698be4,0x8be4698b,0x698be469,0x39698be4,0x3939fb39,
0xfb3939fb,0x39390000,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,
0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,
0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,
0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,
0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,
0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,
0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,
0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,
0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,
0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,
0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,
0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,
0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,
0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,
0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,
0x3939fb39,0xfb3939fb,0x39390000,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,
0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,
0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,
0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,
0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,
0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,
0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,
0x39fb3939,0x3939fb39,0xfb3939fb,0x39fb3939,0x3939fb39,0xfb3939fb,0x00000000
};

//
// Size is 2 bytes less than the array
//
static const DWORD g_cbDisconImageBits = sizeof(g_DisconImageBits) - 2;


static const DWORD g_DisconImage8Bits[] = {
0x12b64d42,0x00000000,0x04360000,0x00280000,0x003f0000,0x003a0000,0x00010000,
0x00000008,0x0e800000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
0x00000000,0x80000080,0x80000000,0x00800080,0x00800000,0x80800080,0xc0c00000,
0x9da100c0,0xdfe3009d,0x200000e0,0x20000040,0x20000060,0x20000080,0x200000a0,
0x200000c0,0x400000e0,0x40000000,0x40000020,0x40000040,0x40000060,0x40000080,
0x400000a0,0x400000c0,0x600000e0,0x60000000,0x60000020,0x60000040,0x60000060,
0x60000080,0x600000a0,0x600000c0,0x800000e0,0x80000000,0x80000020,0x80000040,
0x80000060,0x80000080,0x800000a0,0x800000c0,0xa00000e0,0xa0000000,0xa0000020,
0xa0000040,0xa0000060,0xa0000080,0xa00000a0,0xa00000c0,0xc00000e0,0xc0000000,
0xc0000020,0xc0000040,0xc0000060,0xc0000080,0xc00000a0,0xc00000c0,0xe00000e0,
0xe0000000,0xe0000020,0xe0000040,0xe0000060,0xe0000080,0xe00000a0,0xe00000c0,
0x004000e0,0x00400000,0x00400020,0x00400040,0x00400060,0x00400080,0x004000a0,
0x004000c0,0x204000e0,0x20400000,0x20400020,0x20400040,0x20400060,0x20400080,
0x204000a0,0x204000c0,0x404000e0,0x40400000,0x40400020,0x40400040,0x40400060,
0x40400080,0x404000a0,0x404000c0,0x604000e0,0x60400000,0x60400020,0x60400040,
0x60400060,0x60400080,0x604000a0,0x604000c0,0x804000e0,0x80400000,0x80400020,
0x80400040,0x80400060,0x80400080,0x804000a0,0x804000c0,0xa04000e0,0xa0400000,
0xa0400020,0xa0400040,0xa0400060,0xa0400080,0xa04000a0,0xa04000c0,0xc04000e0,
0xc0400000,0xc0400020,0xc0400040,0xc0400060,0xc0400080,0xc04000a0,0xc04000c0,
0xe04000e0,0xe0400000,0xe0400020,0xe0400040,0xe0400060,0xe0400080,0xe04000a0,
0xe04000c0,0x008000e0,0x00800000,0x00800020,0x00800040,0x00800060,0x00800080,
0x008000a0,0x008000c0,0x208000e0,0x20800000,0x20800020,0x20800040,0x20800060,
0x20800080,0x208000a0,0x208000c0,0x408000e0,0x40800000,0x40800020,0x40800040,
0x40800060,0x40800080,0x408000a0,0x408000c0,0x608000e0,0x60800000,0x60800020,
0x60800040,0x60800060,0x60800080,0x608000a0,0x608000c0,0x808000e0,0x80800000,
0x80800020,0x80800040,0x80800060,0x80800080,0x808000a0,0x808000c0,0xa08000e0,
0xa0800000,0xa0800020,0xa0800040,0xa0800060,0xa0800080,0xa08000a0,0xa08000c0,
0xc08000e0,0xc0800000,0xc0800020,0xc0800040,0xc0800060,0xc0800080,0xc08000a0,
0xc08000c0,0xe08000e0,0xe0800000,0xe0800020,0xe0800040,0xe0800060,0xe0800080,
0xe08000a0,0xe08000c0,0x00c000e0,0x00c00000,0x00c00020,0x00c00040,0x00c00060,
0x00c00080,0x00c000a0,0x00c000c0,0x20c000e0,0x20c00000,0x20c00020,0x20c00040,
0x20c00060,0x20c00080,0x20c000a0,0x20c000c0,0x40c000e0,0x40c00000,0x40c00020,
0x40c00040,0x40c00060,0x40c00080,0x40c000a0,0x40c000c0,0x60c000e0,0x60c00000,
0x60c00020,0x60c00040,0x60c00060,0x60c00080,0x60c000a0,0x60c000c0,0x80c000e0,
0x80c00000,0x80c00020,0x80c00040,0x80c00060,0x80c00080,0x80c000a0,0x80c000c0,
0xa0c000e0,0xa0c00000,0xa0c00020,0xa0c00040,0xa0c00060,0xa0c00080,0xa0c000a0,
0xa0c000c0,0xc0c000e0,0xc0c00000,0xc0c00020,0xc0c00040,0xc0c00060,0xc0c00080,
0xfbf000a0,0x576800ff,0x80800058,0x00000080,0xff0000ff,0xff000000,0x00ff00ff,
0x00ff0000,0xffff00ff,0xffff0000,0xf9f900ff,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,
0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,
0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f900f9,0xf9f9f9f9,
0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,
0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,
0xf9f900f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,
0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,
0xf9f9f9f9,0xf9f9f9f9,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,
0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,
0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,
0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe301e3e3,0xe3e3e3e3,0xf9e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,
0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0x01f9e3e3,0xe3e3e3e3,0xf901e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0x01f9e3e3,0xe3e3e3e3,0xf9f901e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9e3e3e3,
0xe3e3e301,0xe3f9f901,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,
0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0x000000e3,0xe3e30000,
0xe3e3e3e3,0xe3e3e3e3,0x01e301f9,0xe3e3f9f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e300,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9f9f9,0xe3e3e3f9,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e300,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9f9e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e300,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xf9f9f901,0xe3e3e301,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,
0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e300,
0xe3e3e3e3,0xe3e3e3e3,0x01e3e3e3,0xf9f9f9f9,0xe3e301f9,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e300,0xe3e3e3e3,0xe3e3e3e3,0xf901e3e3,0xf9e3e3f9,0xe301f9f9,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e300,0xe3e3e3e3,0xe3e3e3e3,0xf9f901e3,
0xe3e3e3e3,0x01f9f9f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,
0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e300,0xe3e3e3e3,
0xe3e3e3e3,0xe3f9f9e3,0xe3e3e3e3,0xf9f9f9e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e300,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,
0xe3e3e3e3,0xe3e3e3e3,0x0000e3e3,0x00000000,0x00000000,0xe3e30000,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,
0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xa4a4a4e3,0xa4a4a4a4,0xa4a4a4a4,
0xe300a4a4,0xe3e3e3e3,0xe3e3e3e3,0xe300e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0x07ffa4e3,
0x07070707,0x00000007,0xe300a407,0xe3e3e3e3,0xe3e3e3e3,0xe300e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,
0xe3e3e3e3,0xffffa4e3,0xffffffff,0xffffffff,0xe300a4ff,0xe3e3e3e3,0xe3e3e3e3,
0xe300e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,
0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0x00a4e3e3,0x00000000,0x00000000,0x0000a400,
0x00000000,0xe3e30000,0xe300e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0x07a4e3e3,0x07070707,
0x07070707,0xa4a400a4,0xa4a4a4a4,0xe300a4a4,0xe300e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,
0x07a4e3e3,0xa4a4a4a4,0x07a4a4a4,0x070700a4,0x00000007,0xe300a407,0xe3e30000,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,
0xe3e3e3e3,0xe3e3e3e3,0x07a4e3e3,0x06060600,0x07060606,0xffff00a4,0xffffffff,
0xe300a4ff,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,
0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0x07a4e3e3,0x06060600,0x07060606,
0x000000a4,0x00000000,0xe300a400,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0x07a4e3e3,
0x0606ff00,0x07060606,0x070700a4,0x07070707,0xe3e300a4,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,
0xe3e3e3e3,0x07a4e3e3,0x0606ff00,0x07060606,0xa4a400a4,0x07a4a4a4,0xe3e300a4,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,
0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0x07a4e3e3,0x00000000,0x07000000,0x060600a4,
0x07060606,0xe3e300a4,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0x07a4e3e3,0x07070707,
0x07070707,0x060600a4,0x07060606,0xe3e300a4,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,
0xa4e3e3e3,0xa4a4a4a4,0xa4a4a4a4,0x0606ffa4,0x07060606,0xe3e300a4,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0x07a4e3e3,0x0606ff00,0x07060606,
0xe3e300a4,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,
0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0x07a4e3e3,
0x00000000,0x07000000,0xe3e300a4,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0x07a4e3e3,0x07070707,0x07070707,0xe3e300a4,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xa4e3e3e3,0xa4a4a4a4,0xa4a4a4a4,0xe3e3e3a4,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,
0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,
0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,0xe3e3e3f9,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xf9f9e3e3,0xf9f900f9,
0xe3e3e3f9,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,0xe3e3e3e3,
0xf9f9e3e3,0xf9f900f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,
0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,
0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f900f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,
0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,
0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f900f9,0xf9f9f9f9,
0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,
0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,0xf9f9f9f9,
0x0000f900,
};

//
// Size is 2 bytes less than the array
//
static const DWORD g_cbDisconImage8Bits = sizeof(g_DisconImage8Bits) - 2;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\slint.cpp ===
/****************************************************************************/
// slint.cpp
//
// RDP client Security Layer functions.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_SECURITY
#define TRC_FILE  "aslint"
#include <atrcapi.h>
#include "licecert.h"
#include "regapi.h"
}

#ifndef OS_WINCE
#include <hydrix.h>
#endif

//
// Autoreconnect security related
//
#include <md5.h>
#include <hmac.h>


#include "autil.h"
#include "cd.h"
#include "sl.h"
#include "nl.h"
#include "wui.h"
#include "aco.h"
#include "clicense.h"
#include "clx.h"

//
// Instrumentation
//
DWORD  g_dwSLDbgStatus = 0;


/****************************************************************************/
/* Name:      SL_OnInitialized                                              */
/*                                                                          */
/* Purpose:   Called by NL when its initialization is complete              */
/*                                                                          */
/* Operation: Called in the Receive context                                 */
/****************************************************************************/
void DCCALLBACK CSL::SL_OnInitialized()
{
    DC_BEGIN_FN("SL_OnInitialized");

    SL_DBG_SETINFO(SL_DBG_ONINIT_CALLED);

    SL_CHECK_STATE(SL_EVENT_ON_INITIALIZED);

    //
    // Sets state here to prevent a race that
    // causes problems when disconnection/connecting quickly
    // change made to fix webctrl problem.
    //
    SL_SET_STATE(SL_STATE_INITIALIZED);

    TRC_NRM((TB, _T("Initialized")));
    _SL.callbacks.onInitialized(_pCo);

    SL_DBG_SETINFO(SL_DBG_ONINIT_DONE1);

DC_EXIT_POINT:
    SL_DBG_SETINFO(SL_DBG_ONINIT_DONE2);

    DC_END_FN();
} /* SL_OnInitialized */


/****************************************************************************/
/* Name:      SL_OnTerminating                                              */
/*                                                                          */
/* Purpose:   Called by NL before terminating                               */
/*                                                                          */
/* Operation: This function is called on the NL's receive thread to allow   */
/*            resources to be freed prior to termination.                   */
/****************************************************************************/

//TEMP instrumentation to help track down races
DCUINT g_slDbgStateOnTerminating = -1;
void DCCALLBACK CSL::SL_OnTerminating()
{
    DC_BEGIN_FN("SL_OnTerminating");

    SL_DBG_SETINFO(SL_DBG_ONTERM_CALLED);
    g_slDbgStateOnTerminating = _SL.state;

    SL_CHECK_STATE(SL_EVENT_ON_TERMINATING);
    TRC_NRM((TB, _T("Terminating")));

    SLFreeConnectResources();
    SLFreeInitResources();

    /************************************************************************/
    /* No need to clear SL data - it will be reinitialied to 0 when         */
    /* SL_Init() is called.  However, reset 'initialized' flag here in case */
    /* a late SL_ call comes in.                                            */
    /************************************************************************/

    // Call the Core's callback.
    _SL.callbacks.onTerminating(_pCo);
    SL_SET_STATE(SL_STATE_TERMINATED);

    SL_DBG_SETINFO(SL_DBG_ONTERM_DONE1);

DC_EXIT_POINT:
    SL_DBG_SETINFO(SL_DBG_ONTERM_DONE2);

    DC_END_FN();
} /* SL_OnTerminating */


/****************************************************************************/
/* Name:      SL_OnConnected                                                */
/*                                                                          */
/* Purpose:   Called by NL when its connection to the Server is complete    */
/*                                                                          */
/* Params:    channelID      - ID of T.Share broadcast channel              */
/*            pUserData      - user data from Server                        */
/*            userDataLength - length of user data                          */
/*                                                                          */
/* Operation: Called in the Receive context                                 */
/****************************************************************************/
DCVOID DCCALLBACK CSL::SL_OnConnected(DCUINT   channelID,
                                 PDCVOID  pUserData,
                                 DCUINT   userDataLength,
                                 DCUINT32 serverVersion)
{
    PRNS_UD_SC_SEC1 pSecUD;
    PDCUINT8        pSecUDEnd;
    DCUINT32        encMethod;
    CERT_TYPE       CertType = CERT_TYPE_INVALID;
    BOOL            fDisconnect;

    DC_BEGIN_FN("SL_OnConnected");

    SL_CHECK_STATE(SL_EVENT_ON_CONNECTED);

    /************************************************************************/
    /* Save channel ID                                                      */
    /************************************************************************/
    TRC_NRM((TB, _T("Share channel %x"), channelID));
    _SL.channelID = channelID;

    TRC_NRM((TB, _T("Server version %x"), serverVersion));
    _SL.serverVersion = serverVersion;

    /************************************************************************/
    /* Check for user data.                                                 */
    /************************************************************************/
    if ((NULL == pUserData) || (0 == userDataLength))
    {
        TRC_ERR((TB, _T("No user data (pUserData:%p length:%u)"),
                 pUserData,
                 userDataLength));

        _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                                      CD_NOTIFICATION_FUNC(CSL, SLSetReasonAndDisconnect),
                                      (ULONG_PTR) SL_ERR_NOSECURITYUSERDATA);

        DC_QUIT;
    }

    /************************************************************************/
    /* userDataLength has already been verified to sit within the received  */
    /* packet in nccb.cpp!NC_OnMCSChannelJoinConfirm.  (This was a retail   */
    /* check.)  Thus, the allocation size is bounded by network-speed.      */
    /* The allocation is capped at thesize of a receive-packet buffer.      */
    /************************************************************************/
    TRC_ASSERT((userDataLength <= MCS_MAX_RCVPKT_LENGTH),
               (TB, _T("UserData expected to be smaller than a packet size (sanity check)")));

    /************************************************************************/
    /* There is some user data.  Allocate space for a copy, because it is   */
    /* not valid after this function returns, and SL needs it beyond that   */
    /* time.                                                                */
    /************************************************************************/
    TRC_NRM((TB, _T("Got %u bytes of user data"), userDataLength));
    TRC_DATA_NRM("User data", pUserData, userDataLength);

    _SL.pSCUserData = (PDCUINT8)UT_Malloc(_pUt, userDataLength);
    if (_SL.pSCUserData == NULL)
    {
        TRC_ERR((TB, _T("Failed to alloc %u bytes for user data"),
                userDataLength));

        _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                CD_NOTIFICATION_FUNC(CSL, SLSetReasonAndDisconnect),
                (ULONG_PTR) SL_ERR_NOMEMFORRECVUD);

        DC_QUIT;
    }

    /************************************************************************/
    /* Save the userdata, to be passed to the Core later.                   */
    /************************************************************************/
    memcpy(_SL.pSCUserData, pUserData, userDataLength);
    _SL.SCUserDataLength = userDataLength;

    /************************************************************************/
    /* Loop through each piece of user data: - if it's security data, save  */
    /* the encryption type                                                  */
    /************************************************************************/
    pSecUD = (PRNS_UD_SC_SEC1)
        _pUt->UT_ParseUserData(
                (PRNS_UD_HEADER)pUserData,
                userDataLength,
                RNS_UD_SC_SEC_ID);
    if (pSecUD == NULL)
    {
        /********************************************************************/
        /* There is no SECURITY data in UserData, so disconnect.            */
        /********************************************************************/
        TRC_ERR((TB, _T("No SECURITY user data")));

        _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                                      CD_NOTIFICATION_FUNC(CSL, SLSetReasonAndDisconnect),
                                      (ULONG_PTR) SL_ERR_NOSECURITYUSERDATA);
        DC_QUIT;
    }
    pSecUDEnd = (PDCUINT8)pSecUD + pSecUD->header.length;

    fDisconnect = FALSE;
    if ((PDCUINT8)pSecUD + sizeof(RNS_UD_SC_SEC) > pSecUDEnd)
    {
        fDisconnect = TRUE;
    }
    else if (0 != ((PRNS_UD_SC_SEC)pSecUD)->encryptionLevel)
    {
        /********************************************************************/
        /* There should be at least enough data for:                        */
        /*   a) PRNS_UD_SC_SEC1 struct                                      */
        /*   b) RANDOM_KEY_LENGTH                                           */
        /*   c) pSecUD->serverCertLen (Certificate length)                  */
        /********************************************************************/
        if (((PDCUINT8)(&pSecUD->serverCertLen) + sizeof(pSecUD->serverCertLen) > pSecUDEnd) ||
           (((PDCUINT8)pSecUD +
             sizeof(RNS_UD_SC_SEC1) +
             RANDOM_KEY_LENGTH +
             pSecUD->serverCertLen) > pSecUDEnd))
        {
            fDisconnect = TRUE;
        }
    }

    if (fDisconnect)
    {
        TRC_ABORT((TB, _T("Invalid SECURITY user data")));

        _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                                      CD_NOTIFICATION_FUNC(CSL, SLSetReasonAndDisconnect),
                                      (ULONG_PTR) SL_ERR_NOSECURITYUSERDATA);

        DC_QUIT;
    }

    /************************************************************************/
    /* remember the server's encryption level and encryption method.        */
    /************************************************************************/
    _SL.encryptionLevel = pSecUD->encryptionLevel;
    _SL.encryptionMethodSelected =
        encMethod = pSecUD->encryptionMethod;

    // If FIPS GP is set, disconnect if encryptionMethod is not FIPS 
    if (_SL.encryptionMethodsSupported == SM_FIPS_ENCRYPTION_FLAG) {
        if (encMethod != SM_FIPS_ENCRYPTION_FLAG) {
            TRC_ERR((TB, _T("Invalid encryption method received, %u"), encMethod ));

            _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                                        CD_NOTIFICATION_FUNC(CSL, SLSetReasonAndDisconnect),
                                        SL_ERR_INVALIDENCMETHOD);
            DC_QUIT;
        }
    }


    if( !encMethod ) {
        TRC_NRM((TB, _T("No encryption for this session")));
        _SL.encrypting = FALSE;
    }
    else {
        PDCUINT8 pData;

        if( (encMethod != SM_40BIT_ENCRYPTION_FLAG) &&
            (encMethod != SM_56BIT_ENCRYPTION_FLAG) &&
            (encMethod != SM_128BIT_ENCRYPTION_FLAG) &&
            (encMethod != SM_FIPS_ENCRYPTION_FLAG) ) {

            TRC_ERR((TB, _T("Invalid encryption method received, %u"), encMethod ));

            _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                                          CD_NOTIFICATION_FUNC(CSL, SLSetReasonAndDisconnect),
                                          SL_ERR_INVALIDENCMETHOD);
            DC_QUIT;
        }

        /********************************************************************/
        /* gather the client random and verify the server certificate sent. */
        /********************************************************************/
        if( pSecUD->serverRandomLen != RANDOM_KEY_LENGTH ) {

            TRC_ERR((TB, _T("Invalid server random received, %u"), encMethod ));

            _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                                          CD_NOTIFICATION_FUNC(CSL, SLSetReasonAndDisconnect),
                                          SL_ERR_INVALIDSRVRAND);
            DC_QUIT;
        }

        pData = (PDCUINT8)pSecUD + sizeof(RNS_UD_SC_SEC1);
        memcpy(_SL.keyPair.serverRandom, pData, RANDOM_KEY_LENGTH);

        pData += RANDOM_KEY_LENGTH;

        /********************************************************************/
        /* validate the server certificate.                                 */
        /********************************************************************/
        if (!SLValidateServerCert( pData, pSecUD->serverCertLen, &CertType))
        {
            TRC_ERR( ( TB, _T("Invalid server certificate received, %u"),
                encMethod ) );

            _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                    CD_NOTIFICATION_FUNC(CSL, SLSetReasonAndDisconnect),
                    SL_ERR_INVALIDSRVCERT);

            DC_QUIT;
        }

        if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            if (!TSCAPI_Init(&_SL.SLCapiData) || !TSCAPI_Enable(&(_SL.SLCapiData))) {
                TRC_ERR( ( TB, _T("Init CAPI failed")));
                _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                                                CD_NOTIFICATION_FUNC(CSL, SLSetReasonAndDisconnect),
                                                SL_ERR_INITFIPSFAILED);
                DC_QUIT;
            }
            else {
                TRC_ERR( ( TB, _T("Init CAPI succeed")));
            }
        }

        /********************************************************************/
        /* generate client random key                                       */
        /********************************************************************/
        if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            if (!TSCAPI_GenerateRandomNumber(
                    &(_SL.SLCapiData),
                    (PDCUINT8)_SL.keyPair.clientRandom,
                    sizeof(_SL.keyPair.clientRandom) ) ) {
                TRC_ERR((TB, _T("Failed create client random") ));

                _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                        CD_NOTIFICATION_FUNC(CSL, SLSetReasonAndDisconnect),
                        SL_ERR_GENSRVRANDFAILED);
                DC_QUIT;
            }
        }
        else {
            if (!TSRNG_GenerateRandomBits(
                    (PDCUINT8)_SL.keyPair.clientRandom,
                    sizeof(_SL.keyPair.clientRandom) ) ) {
                TRC_ERR((TB, _T("Failed create client random") ));

                _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                        CD_NOTIFICATION_FUNC(CSL, SLSetReasonAndDisconnect),
                        SL_ERR_GENSRVRANDFAILED);
                DC_QUIT;
            }
        }

        if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            TSCAPI_MakeSessionKeys(&(_SL.SLCapiData), &(_SL.keyPair), NULL);
        }
        else {
            /********************************************************************/
            /* make security session keys                                       */
            /*                                                                  */
            /* Note : Server encryption key should be same as the client        */
            /* decryption key and vice versa. So the encryption/decryption      */
            /* parameters passed below are reverse order that of the server     */
            /* call.                                                            */
            /********************************************************************/
            if (!MakeSessionKeys(
                    &_SL.keyPair,
                    _SL.startDecryptKey,
                    &_SL.rc4DecryptKey,
                    _SL.startEncryptKey,
                    &_SL.rc4EncryptKey,
                    _SL.macSaltKey,
                    _SL.encryptionMethodSelected,
                    &_SL.keyLength,
                    _SL.encryptionLevel)) {
                TRC_ERR((TB, _T("MakeSessionKeys failed") ));

                _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                        CD_NOTIFICATION_FUNC(CSL, SLSetReasonAndDisconnect),
                        SL_ERR_MKSESSKEYFAILED);

                DC_QUIT;
            }

            TRC_ASSERT((_SL.keyLength == (DCUINT32)
                    ((_SL.encryptionMethodSelected ==
                        SM_128BIT_ENCRYPTION_FLAG) ?
                            MAX_SESSION_KEY_SIZE :
                            (MAX_SESSION_KEY_SIZE/2))),
                    (TB, _T("Invalid key length")));

            /********************************************************************/
            /* use startKey as currentKey for the first time                    */
            /********************************************************************/
            memcpy(_SL.currentEncryptKey, _SL.startEncryptKey,
                    sizeof(_SL.currentEncryptKey));
            memcpy(_SL.currentDecryptKey, _SL.startDecryptKey,
                    sizeof(_SL.currentEncryptKey));
        }

        /********************************************************************/
        /* reset encryption and decryption count.                           */
        /********************************************************************/
        _SL.encryptCount = 0;
        _SL.decryptCount = 0;
        _SL.totalEncryptCount = 0;
        _SL.totalDecryptCount = 0;

        _SL.encrypting = TRUE;
    }

    /************************************************************************/
    /* Build and send security packet.  Note that                           */
    /* SLSendSecurityPacket will call onConnected/onDisconnected if:        */
    /*   - the connection process completes successfully, OR                */
    /*   - the connection process fails.                                    */
    /*                                                                      */
    /* Therefore SLSetReasonAndDisconnect is not called here on failure as  */
    /* that would cause SLSetReasonAndDisconnect to be called twice.        */
    /************************************************************************/
    SL_SET_STATE(SL_STATE_SL_CONNECTING);

    if( CERT_TYPE_PROPRIETORY == CertType )
    {
        SLSendSecurityPacket(
            _SL.pServerCert->PublicKeyData.pBlob,
            _SL.pServerCert->PublicKeyData.wBlobLen );
    }
    else if( CERT_TYPE_X509 == CertType )
    {
        SLSendSecurityPacket(
            _SL.pbServerPubKey,
            _SL.cbServerPubKey );
    }
    else if (!_SL.encrypting)
    {
        SLSendSecurityPacket( NULL, 0 );
    }
    else
    {
        TRC_ERR((TB, _T("Unexpected CertType %d"), CertType));
    }

    TRC_NRM((TB, _T("Security packets sent to the server")));

DC_EXIT_POINT:
    DC_END_FN();
} /* SL_OnConnected */


/****************************************************************************/
/* Name:      SLValidateServerCert                                          */
/*                                                                          */
/* Purpose:   Validate the terminal server certificate                      */
/*                                                                          */
/* Returns:   TRUE if the certificate is validated successfully or FALSE    */
/*            FALSE otherwise.                                              */
/*                                                                          */
/* Params:    pbCert - The server certificate.                              */
/*            cbCert - size of the server certificate.                      */
/*                                                                          */
/* Operation: Called by SL_OnConnected.                                     */
/****************************************************************************/
DCBOOL DCINTERNAL CSL::SLValidateServerCert( PDCUINT8     pbCert,
                                        DCUINT32     cbCert,
                                        CERT_TYPE *  pCertType )
{
    DWORD
            dwCertVersion;
    DCBOOL
            fResult = TRUE;

    DC_BEGIN_FN( "SLValidateServerCert" );

    /********************************************************************/
    /* Make sure the packet is long enough for the version number.      */
    /********************************************************************/
    if (cbCert < sizeof(DWORD))
    {
        TRC_ABORT( ( TB, _T("Invalid certificate version")));
        fResult = FALSE;
        DC_QUIT;
    } 

    memcpy( &dwCertVersion, pbCert, sizeof( DWORD ) );

    if( CERT_CHAIN_VERSION_2 > GET_CERTIFICATE_VERSION( dwCertVersion ) )
    {
        //
        // decode and validate proprietory certificate.
        //
        *pCertType = CERT_TYPE_PROPRIETORY;

        _SL.pbCertificate = (PDCUINT8)UT_Malloc(_pUt, ( DCUINT )cbCert );
        if( NULL == _SL.pbCertificate )
        {
            TRC_ERR( ( TB, _T("Failed to allocate %u bytes for server certificate"),
                     cbCert ) );
            fResult = FALSE;
            DC_QUIT;
        }

        _SL.pServerCert = (PHydra_Server_Cert)UT_Malloc(_pUt, sizeof( Hydra_Server_Cert ) );
        if( NULL == _SL.pServerCert )
        {
            TRC_ERR( ( TB, _T("Failed to allocate server certificate data structure") ) );
            fResult = FALSE;
            DC_QUIT;
        }

        memcpy( _SL.pbCertificate, pbCert, cbCert );
        _SL.cbCertificate = (unsigned)cbCert;

        if( !UnpackServerCert( _SL.pbCertificate, _SL.cbCertificate, _SL.pServerCert ) )
        {
            TRC_ERR( ( TB, _T("Failed to unpack server certificate\n") ) ) ;
            fResult = FALSE;
            DC_QUIT;
        }

        /********************************************************************/
        /* validate the server certificate.                                 */
        /********************************************************************/
        if( !ValidateServerCert( _SL.pServerCert ) )
        {
            TRC_ERR( ( TB, _T("Invalid server certificate received\n") ) );
            fResult = FALSE;
            DC_QUIT;
        }

        if( _pUi->UI_GetNotifyTSPublicKey() )
        {
            fResult = (BOOL) SendMessage(_pUi->_UI.hWndCntrl, 
                                WM_TS_RECEIVEDPUBLICKEY, 
                                (WPARAM)_SL.pServerCert->PublicKeyData.wBlobLen,
                                (LPARAM)_SL.pServerCert->PublicKeyData.pBlob
                            );
        }
    }
    else if( MAX_CERT_CHAIN_VERSION >= GET_CERTIFICATE_VERSION( dwCertVersion ) )
    {
        LICENSE_STATUS
            Status;
        DWORD
            fDates =  CERT_DATE_DONT_VALIDATE;

        //
        // decode X509 certificate and extract public key
        //

        *pCertType = CERT_TYPE_X509;

        Status = VerifyCertChain( pbCert, cbCert, NULL, &_SL.cbServerPubKey, &fDates );

        if( LICENSE_STATUS_INSUFFICIENT_BUFFER == Status )
        {
            _SL.pbServerPubKey = (PDCUINT8)UT_Malloc( _pUt,  ( DCUINT )_SL.cbServerPubKey );
        }
        else if( LICENSE_STATUS_OK != Status )
        {
            TRC_ERR( ( TB, _T("Failed to verify server certificate: %u\n"), Status ) ) ;
            fResult = FALSE;
            DC_QUIT;
        }

        if( NULL == _SL.pbServerPubKey )
        {
            TRC_ERR( ( TB, _T("Failed to allocate %u bytes for server public key\n"),
                     _SL.cbServerPubKey ) ) ;
            fResult = FALSE;
            DC_QUIT;
        }

        Status = VerifyCertChain( pbCert, cbCert, _SL.pbServerPubKey, &_SL.cbServerPubKey, &fDates );

        if( LICENSE_STATUS_OK != Status )
        {
            TRC_ERR( ( TB, _T("Failed to verify server certificate: %d\n"), Status ) ) ;
            fResult = FALSE;
            DC_QUIT;
        }

        if( _pUi->UI_GetNotifyTSPublicKey() )
        {
            fResult = (BOOL) SendMessage(_pUi->_UI.hWndCntrl, 
                                        WM_TS_RECEIVEDPUBLICKEY, 
                                        (WPARAM)_SL.cbServerPubKey,
                                        (LPARAM)_SL.pbServerPubKey
                                        );
        }
    }
    else
    {
        //
        // don't know how to decode this version of certificate
        //
        TRC_ERR( ( TB, _T("Invalid certificate version: %d\n"),
                 GET_CERTIFICATE_VERSION( dwCertVersion ) ) ) ;

        fResult = FALSE;
        DC_QUIT;
    }

DC_EXIT_POINT:

    if( FALSE == fResult )
    {
        //
        // free resources if failed.
        //
        if( CERT_TYPE_PROPRIETORY == *pCertType )
        {
            if( _SL.pServerCert )
            {
                UT_Free( _pUt,  _SL.pServerCert );
                _SL.pServerCert = NULL;
            }

            if( _SL.pbCertificate )
            {
                UT_Free( _pUt,  _SL.pbCertificate );
                _SL.pbCertificate = NULL;
                _SL.cbCertificate = 0;
            }
        }
        else if( CERT_TYPE_X509 == *pCertType )
        {
            if( _SL.pbServerPubKey )
            {
                UT_Free( _pUt,  _SL.pbServerPubKey );
                _SL.pbServerPubKey = NULL;
                _SL.cbServerPubKey = 0;
            }
        }
    }

    DC_END_FN();
    return( fResult );
}


/****************************************************************************/
/* Name:      SL_OnDisconnected                                             */
/*                                                                          */
/* Purpose:   Called by NL when its connection to the Server is disconnected*/
/*                                                                          */
/* Operation: Called in the Receive context                                 */
/****************************************************************************/
void DCCALLBACK CSL::SL_OnDisconnected(unsigned reason)
{
    DC_BEGIN_FN("SL_OnDisconnected");

    SL_DBG_SETINFO(SL_DBG_ONDISC_CALLED);

    SL_CHECK_STATE(SL_EVENT_ON_DISCONNECTED);
    TRC_ASSERT((0 != reason), (TB, _T("Disconnect reason from NL is 0")));

    // Free the connection resources and set the state to initialized.
    SLFreeConnectResources();
    SL_SET_STATE(SL_STATE_INITIALIZED);

    // Decide if we want to over-ride the disconnect reason code.
    if (_SL.disconnectErrorCode != 0)
    {
        TRC_ALT((TB, _T("Over-riding disconnection error code (%u->%u)"),
                 reason,
                 _SL.disconnectErrorCode));

        // Over-ride the error code and set the global variable to 0.
        reason = _SL.disconnectErrorCode;
        _SL.disconnectErrorCode = 0;
    }

    // Tell the Core.
    TRC_NRM((TB, _T("Disconnect reason:%u"), reason));
    _SL.callbacks.onDisconnected(_pCo, reason);

    SL_DBG_SETINFO(SL_DBG_ONDISC_DONE1);

DC_EXIT_POINT:

    SL_DBG_SETINFO(SL_DBG_ONDISC_DONE2);

    DC_END_FN();
} /* SL_OnDisconnected */


/****************************************************************************/
/* Name:      SL_OnPacketReceived                                           */
/*                                                                          */
/* Purpose:   Called by NL when a packet is received from the Server        */
/*                                                                          */
/* Params:    pData    - packet received                                    */
/*            dataLen  - length of packet received                          */
/*            flags    - security flags (always 0)                          */
/*            channelID - channel ID on which data was sent                 */
/*            priority - priority on which packet was received              */
/*                                                                          */
/* Operation: Two types of packet might be received:                        */
/*            - security packet (during the security exchange sequence)     */
/*            - data packet (otherwise).                                    */
/*            The code recognises a security packet as one which is received*/
/*            - before the encryption type has been negotiated              */
/*            - AND before the session is connected.                        */
/*            Other packets are data packets.                               */
/*                                                                          */
/*            Called in the Receive context                                 */
/****************************************************************************/
HRESULT DCCALLBACK CSL::SL_OnPacketReceived(
        PDCUINT8   pData,
        DCUINT     dataLen,
        DCUINT     flags,
        DCUINT     channelID,
        DCUINT     priority)
{
    DCBOOL  dataPacket;
    HRESULT hrc = S_OK;
    DCBOOL  rc;

    DC_BEGIN_FN("SL_OnPacketReceived");

    /************************************************************************/
    /* The packet should be at least large enough to hold Security Header   */
    /************************************************************************/
    if (dataLen < sizeof(RNS_SECURITY_HEADER))
    {
        TRC_ABORT((TB, _T("SL packet too small for RNS_SECURITY_HEADER: %u"), dataLen));

        //
        // It is necessary to immediately abort the connection
        // as we may be under attack here and we should stop processing
        // any additional data
        //
        SL_DropLinkImmediate(SL_ERR_INVALIDPACKETFORMAT);

        /************************************************************************/
        /* Do not process the rest of this packet!                              */
        /************************************************************************/
        hrc = E_ABORT;
        DC_QUIT;
    }

    /************************************************************************/
    /* Read the flags from the packet.                                      */
    /************************************************************************/
    flags = (DCUINT)((PRNS_SECURITY_HEADER)pData)->flags;

    /************************************************************************/
    /* First of all, determine what type of packet this is                  */
    /************************************************************************/
    TRC_NRM((TB, _T("Encrypting? %s, state %s, flags %#lx: channel %x"),
            _SL.encrypting ? "Y" : "N",
            slState[_SL.state],
            ((PRNS_SECURITY_HEADER)pData)->flags, channelID ));

    TRC_DATA_DBG("Pkt from NL", pData, dataLen);

    /************************************************************************/
    /* If no encryption is in force, assume this is a data packet unless    */
    /* we're still negotiating the encryption exchange                      */
    /************************************************************************/
    if (_SL.encrypting) {
        // If encryption is in force, the encryption header tells us
        // whether this is a security or data packet.
        dataPacket =
                (((PRNS_SECURITY_HEADER)pData)->flags & RNS_SEC_NONDATA_PKT) ?
                FALSE : TRUE;
    }
    else {
        dataPacket = (_SL.state == SL_STATE_CONNECTED);
    }

    // Handle the packet.
    if (dataPacket) {
        TRC_DBG((TB, _T("Data packet")));
        hrc = SLReceivedDataPacket(pData, dataLen, flags, channelID, priority);
    }
    else {
        // Non-data packets always have a security header, even when
        // encryption is not in effect. Use this to determine what type of
        // packet this is.
        if (((PRNS_SECURITY_HEADER)pData)->flags & RNS_SEC_EXCHANGE_PKT) {
            TRC_NRM((TB, _T("Security packet")));
            SLReceivedSecPacket(pData, dataLen, flags, channelID, priority);
        }
        else if (((PRNS_SECURITY_HEADER)pData)->flags & RNS_SEC_LICENSE_PKT) {
#ifdef USE_LICENSE
            TRC_NRM((TB, _T("Licensing packet")));
            SLReceivedLicPacket(pData, dataLen, flags, channelID, priority);
#else /* USE_LICENSE */
            TRC_ABORT((TB,_T("Licensing not yet implemented")));
#endif /* USE_LICENSE */
        }
        else {
            TRC_NRM((TB, _T("Server redirection packet")));
            // The redirection packet is encrypted
            if (((PRNS_SECURITY_HEADER)pData)->flags & RDP_SEC_REDIRECTION_PKT3) {
                rc = SLDecryptRedirectionPacket(&pData, &dataLen);
                if (!rc) {
                    SL_DropLinkImmediate(SL_ERR_INVALIDPACKETFORMAT);
                    hrc = E_ABORT;
                    DC_QUIT;
                }
            }

            /************************************************************************/
            /* The packet should be at least large enough to hold the               */
            /* RDP_SERVER_REDIRECTION_PACKET packet, since we cast to that type     */
            /* below.                                                               */
            /************************************************************************/
            if (dataLen < sizeof(RDP_SERVER_REDIRECTION_PACKET))
            {
                TRC_ABORT((TB, _T("SL packet too small for RDP_SERVER_REDIRECTION_PACKET: %u"), dataLen));

                //
                // It is necessary to immediately abort the connection
                // as we may be under attack here and we should stop processing
                // any additional data
                //
                SL_DropLinkImmediate(SL_ERR_INVALIDPACKETFORMAT);

                /************************************************************************/
                /* Do not process the rest of this packet!                              */
                /************************************************************************/
                hrc = E_ABORT;
                DC_QUIT;
            }

            _pCo->CO_OnServerRedirectionPacket(
                    (RDP_SERVER_REDIRECTION_PACKET UNALIGNED *)pData, dataLen);
        }
    }
DC_EXIT_POINT:
    DC_END_FN();
    return(hrc);
}


/****************************************************************************/
// SL_OnFastPathOutputReceived
//
// Special-case data reception path for fast-path output packets.
/****************************************************************************/
HRESULT DCAPI CSL::SL_OnFastPathOutputReceived(
        BYTE FAR *pData,
        unsigned DataLen,
        BOOL bEncrypted,
        BOOL fSecureChecksum)
{
    HRESULT hrc = S_OK;
    unsigned HeaderLen, padlen;

    DC_BEGIN_FN("SL_OnFastPathOutputReceived");

    if (_SL.encrypting && _SL.encryptionLevel >= 2) {
        BOOL rc;

        if (!bEncrypted) {
            //
            // It is necessary to immediately abort the connection
            // as we may be under attack here and we should stop processing
            // any additional data
            //
            TRC_ERR((TB, _T("unencrypted data received in encrypted stream")));
            SL_DropLinkImmediate(SL_ERR_DECRYPTFAILED);
            DC_QUIT;            
        }

        // The encryption MAC signature is in the first 8 bytes of the
        // packet after the header byte and size.

        if (_SL.decryptCount == UPDATE_SESSION_KEY_COUNT) {
            rc = TRUE;
            // Don't need to update the session key if using FIPS
            if (_SL.encryptionMethodSelected != SM_FIPS_ENCRYPTION_FLAG) {
                rc = UpdateSessionKey(
                        _SL.startDecryptKey,
                        _SL.currentDecryptKey,
                        _SL.encryptionMethodSelected,
                        _SL.keyLength,
                        &_SL.rc4DecryptKey,
                        _SL.encryptionLevel);
            }
            if (rc) {
                // Reset counter.
                _SL.decryptCount = 0;
            }
            else {
                TRC_ERR((TB, _T("SL failed to update session key")));
                DC_QUIT;
            }
        }

        TRC_ASSERT((_SL.decryptCount < UPDATE_SESSION_KEY_COUNT),
            (TB, _T("Invalid decrypt count")));

        if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            HeaderLen = sizeof(RNS_SECURITY_HEADER2) - sizeof(RNS_SECURITY_HEADER);
        }
        else {
            HeaderLen = DATA_SIGNATURE_SIZE;
        }

        // There needs to be enough data at least for the data signature and header.
        if (DataLen < HeaderLen)
        {
            TRC_ABORT((TB, _T("Not enough data in PDU for DATA_SIGNATURE_SIZE: %u"), DataLen));

            //
            // It is necessary to immediately abort the connection
            // as we may be under attack here and we should stop processing
            // any additional data
            //
            SL_DropLinkImmediate(SL_ERR_INVALIDPACKETFORMAT);

            hrc = E_ABORT;
            DC_QUIT;
        }
        pData += HeaderLen;
        DataLen -= HeaderLen;
        if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            padlen = *((TSUINT8 *)(pData - MAX_SIGN_SIZE - sizeof(TSUINT8)));
        }

        if (SL_GetEncSafeChecksumSC() != (fSecureChecksum != 0)) {
            TRC_ERR((TB,_T("SC safechecksum: 0x%x mismatch protocol:0x%x"),
                     SL_GetEncSafeChecksumSC(),
                     fSecureChecksum));
        }

        if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            rc = TSCAPI_DecryptData(
                                    &(_SL.SLCapiData),
                                    pData,
                                    DataLen,
                                    padlen,
                                    pData - MAX_SIGN_SIZE,
                                    _SL.totalDecryptCount);
            DataLen -= padlen;
        }
        else {
            rc = DecryptData(
                        _SL.encryptionLevel,
                        _SL.currentDecryptKey,
                        &_SL.rc4DecryptKey,
                        _SL.keyLength,
                        pData,
                        DataLen,
                        _SL.macSaltKey,
                        pData - DATA_SIGNATURE_SIZE,
                        fSecureChecksum,
                        _SL.totalDecryptCount);
        }
        if (rc) {
            // Successfully decrypted a packet, increment the decryption
            // counter.
            _SL.decryptCount++;
            _SL.totalDecryptCount++;
        }
        else {

            //
            // It is necessary to immediately abort the connection
            // as we may be under attack here and we should stop processing
            // any additional data
            //
            TRC_ERR((TB, _T("SL failed to decrypt data")));
            SL_DropLinkImmediate(SL_ERR_DECRYPTFAILED);
            DC_QUIT;
        }
    }

    // For TS4 server, the default is only client to server encryption
    // so if encryptionlevel is 1 or less, then we accept unencrypted
    // data as default.
    _pCo->CO_OnFastPathOutputReceived(pData, DataLen);

DC_EXIT_POINT:
    DC_END_FN();
    return(hrc);
}


/****************************************************************************/
/* Name:      SL_OnBufferAvailable                                          */
/*                                                                          */
/* Purpose:   Called by NL when the network is ready to send again after    */
/*            being busy for a period                                       */
/*                                                                          */
/* Operation: Called in the Receive context                                 */
/****************************************************************************/
void DCCALLBACK CSL::SL_OnBufferAvailable()
{
    DC_BEGIN_FN("SL_OnBufferAvailable");

    SL_CHECK_STATE(SL_EVENT_ON_BUFFERAVAILABLE);

    // Tell the Core.
    TRC_NRM((TB, _T("Tell the Core ready to send")));
    _SL.callbacks.onBufferAvailable(_pCo);

    // No state change.

DC_EXIT_POINT:
    DC_END_FN();
}


/****************************************************************************/
/* Name:      SLSendSecInfoPacket                                           */
/*                                                                          */
/* Purpose:   Build and send a security information packet to the Server.   */
/****************************************************************************/
void DCINTERNAL CSL::SLSendSecInfoPacket()
{
    RNS_INFO_PACKET    InfoPkt;
    PDCWCHAR    pszW;
    LPVOID      p;
    DCUINT32    flags;
    UINT        cb, cc;
    BYTE        Salt[UT_SALT_LENGTH];

    DC_BEGIN_FN("SLSendSecInfoPacket");

    /********************************************************************/
    /* set InfoPkt contents                                             */
    /********************************************************************/

    // Cached Logon information is always Unicode, even on Win16. The
    // information is only obtained from the server, so it never has to
    // be manipulated on the client side.
    // Auto logon information does have to be displayed on the client side
    // so in that case the Win16 client should send the information as
    // ANSI, and a code page the server can use to convert it. Win32
    // clients will always just send it Unicode

    flags = 0;

    // This flag indicates the client will only send encrypted
    // packets to the server.  Pre XP client sends unencrypted VC packets
    // from client to server.
    flags |= RNS_INFO_FORCE_ENCRYPTED_CS_PDU;

    if (_pUi->UI_GetMouse())
        flags |= RNS_INFO_MOUSE;

    if (_pUi->UI_GetDisableCtrlAltDel())
        flags |= RNS_INFO_DISABLECTRLALTDEL;

    if (_pUi->UI_GetEnableWindowsKey())
        flags |= RNS_INFO_ENABLEWINDOWSKEY;

    if (_pUi->UI_GetDoubleClickDetect())
        flags |= RNS_INFO_DOUBLECLICKDETECT;

    if (_pUi->UI_GetAutoLogon())
        flags |= RNS_INFO_AUTOLOGON;

    if (_pUi->UI_GetMaximizeShell())
        flags |= RNS_INFO_MAXIMIZESHELL;

    if (_pClx->CLX_Loaded())
        flags |= RNS_INFO_LOGONNOTIFY;

    // Advertise TS5 new 64K compression handling to the server.
    if (_pUi->UI_GetCompress())
        flags |= RNS_INFO_COMPRESSION |
                (PACKET_COMPR_TYPE_64K << RNS_INFO_COMPR_TYPE_SHIFT);

    if (_pUi->UI_GetAudioRedirectionMode() == UTREG_UI_AUDIO_MODE_PLAY_ON_SERVER)
    {
        //Add protocol flag for audio plays on server here.
        flags |= RNS_INFO_REMOTECONSOLEAUDIO;
    }

    {
        SecureZeroMemory(&InfoPkt, sizeof(InfoPkt));

        //
        // In the UNICODE packet the CodePage field was unused so we
        // 
        //
#ifndef OS_WINCE
        InfoPkt.CodePage = (TSUINT32)PtrToUlong(CicSubstGetKeyboardLayout(NULL));
#else
        InfoPkt.CodePage = (TSUINT32)PtrToUlong(GetKeyboardLayout(0));
#endif
        TRC_NRM((TB,_T("Passing up keyboard layout in CodePage field: 0x%x"),
                 InfoPkt.CodePage));
        InfoPkt.flags = (DCUINT32)(flags | (DCUINT32)RNS_INFO_UNICODE);
        pszW = (PDCWCHAR)&InfoPkt.Domain[0];

        // fill in the Unicode buffer

        _pUi->UI_GetDomain((PDCUINT8)pszW, sizeof(InfoPkt.Domain));
        cc = wcslen(pszW);
        InfoPkt.cbDomain = (DCUINT16)(cc * sizeof(DCWCHAR));
#ifdef UNICODE
#define UNICODE_FORMAT_STRING _T("%s")
#else
#define UNICODE_FORMAT_STRING "%S"
#endif
        TRC_NRM((TB, _T("Domain: ") UNICODE_FORMAT_STRING, pszW));
        pszW += cc + 1;

        // Be kind to old servers (see above)
        if (_SL.serverVersion < RNS_DNS_USERNAME_UD_VERSION) {
            cb = TS_MAX_USERNAME_LENGTH_OLD - 4;
        } else {
            cb = sizeof(InfoPkt.Domain);
        }

        if (_pUi->UI_GetUseRedirectionUserName()) {
            _pUi->UI_GetRedirectionUserName((PDCUINT8)pszW, cb);
        } else {
            _pUi->UI_GetUserName((PDCUINT8)pszW, cb);
        }
        
        cc = wcslen(pszW);
        InfoPkt.cbUserName = (DCUINT16)(cc * sizeof(DCWCHAR));
        TRC_NRM((TB, _T("Username: ") UNICODE_FORMAT_STRING, pszW));
        pszW += cc + 1;

        //
        // Only pass up the password if it was specified (i.e AutoLogon)
        //
        if (_pUi->UI_GetAutoLogon()) {

            _pUi->UI_GetPassword((PDCUINT8)pszW, sizeof(InfoPkt.Password));
            _pUi->UI_GetSalt(Salt, sizeof(Salt));

            if (!EncryptDecryptLocalData50((LPBYTE)pszW, sizeof(InfoPkt.Password),
                    Salt, sizeof(Salt)))
            {
                TRC_ERR((TB, _T("Failed to decrypt Password")));
            }
            cc = wcslen(pszW);
            InfoPkt.cbPassword = (DCUINT16)(cc * sizeof(DCWCHAR));
            pszW += cc + 1;

        }
        else {
            InfoPkt.cbPassword = 0;
			//Trailing NULL is still needed even though there is nothing else
			pszW += 1;
        }


        _pUi->UI_GetAlternateShell((PDCUINT8)pszW, sizeof(InfoPkt.AlternateShell));
        cc = wcslen(pszW);
        InfoPkt.cbAlternateShell = (DCUINT16)(cc * sizeof(DCWCHAR));
        TRC_NRM((TB, _T("AlternateShell: ") UNICODE_FORMAT_STRING, pszW));
        pszW += cc + 1;

        _pUi->UI_GetWorkingDir((PDCUINT8)pszW, sizeof(InfoPkt.WorkingDir));
        cc = wcslen(pszW);
        InfoPkt.cbWorkingDir = (DCUINT16)(cc * sizeof(DCWCHAR));
        TRC_NRM((TB, _T("WorkingDir: ") UNICODE_FORMAT_STRING, pszW));
        pszW += cc + 1;

        // computer address
        SLGetComputerAddressW((PDCUINT8)pszW);
        // cc is in characters, not in bytes.  since we are storing wchar,
        // we need to divide by 2.
        cc = (sizeof(InfoPkt.ExtraInfo.clientAddressFamily) +
                sizeof(InfoPkt.ExtraInfo.cbClientAddress) +
                *((PDCUINT16_UA)((PDCUINT8)pszW + sizeof(InfoPkt.ExtraInfo.clientAddressFamily)))) / 2;
        pszW += cc;

        // client directory name
        _pUt->UT_GetClientDirW((PDCUINT8)pszW);
        // cc is in characters, not in bytes.  since we are storing wchar,
        // we need to divide by 2.
        cc = (sizeof(InfoPkt.ExtraInfo.cbClientDir) +
                *((PDCUINT16_UA)((PDCUINT8)pszW))) / 2;
        pszW += cc;

        //client time zone information
        {
            UNALIGNED RDP_TIME_ZONE_INFORMATION * prdptz =(RDP_TIME_ZONE_INFORMATION *)pszW;

            //for win32 get real time zone information
            TIME_ZONE_INFORMATION tzi;

            GetTimeZoneInformation(&tzi);

            prdptz->Bias         = tzi.Bias;
            prdptz->StandardBias = tzi.StandardBias;
            prdptz->DaylightBias = tzi.DaylightBias;
            memcpy(&prdptz->StandardName,&tzi.StandardName,sizeof(prdptz->StandardName));
            memcpy(&prdptz->DaylightName,&tzi.DaylightName,sizeof(prdptz->DaylightName));

            prdptz->StandardDate.wYear         = tzi.StandardDate.wYear        ;
            prdptz->StandardDate.wMonth        = tzi.StandardDate.wMonth       ;
            prdptz->StandardDate.wDayOfWeek    = tzi.StandardDate.wDayOfWeek   ;
            prdptz->StandardDate.wDay          = tzi.StandardDate.wDay         ;
            prdptz->StandardDate.wHour         = tzi.StandardDate.wHour        ;
            prdptz->StandardDate.wMinute       = tzi.StandardDate.wMinute      ;
            prdptz->StandardDate.wSecond       = tzi.StandardDate.wSecond      ;
            prdptz->StandardDate.wMilliseconds = tzi.StandardDate.wMilliseconds;

            prdptz->DaylightDate.wYear         = tzi.DaylightDate.wYear        ;
            prdptz->DaylightDate.wMonth        = tzi.DaylightDate.wMonth       ;
            prdptz->DaylightDate.wDayOfWeek    = tzi.DaylightDate.wDayOfWeek   ;
            prdptz->DaylightDate.wDay          = tzi.DaylightDate.wDay         ;
            prdptz->DaylightDate.wHour         = tzi.DaylightDate.wHour        ;
            prdptz->DaylightDate.wMinute       = tzi.DaylightDate.wMinute      ;
            prdptz->DaylightDate.wSecond       = tzi.DaylightDate.wSecond      ;
            prdptz->DaylightDate.wMilliseconds = tzi.DaylightDate.wMilliseconds;

            // divide by 2 !!!
            pszW += sizeof(RDP_TIME_ZONE_INFORMATION) / 2;
        }

        // get the sessionid on which we're running
        _pUi->UI_GetLocalSessionId((PDCUINT32)pszW);
        // cc is in characters, not in bytes.  since we are storing wchar,
        // we need to divide by 2.
        cc = (sizeof(InfoPkt.ExtraInfo.clientSessionId)) / 2;
        pszW += cc;

        //
        // Send up the features to disable list.
        //
        DWORD dwPerformanceFlags = _pUi->UI_GetPerformanceFlags();
        memcpy(pszW, &dwPerformanceFlags, sizeof(DWORD));
        cc = sizeof(DWORD)/sizeof(WCHAR);
        pszW += cc;

        //
        // Potentially send the autoreconnect packet
        //
        BOOL fAddedAutoReconnectInfo = FALSE;
        if (_pUi->UI_GetEnableAutoReconnect()) {
            DCUINT16 cbAutoReconnectLen = 
                (DCUINT16)_pUi->UI_GetAutoReconnectCookieLen();
            PBYTE pAutoReconnectCookie = _pUi->UI_GetAutoReconnectCookie();

            TRC_ASSERT(cbAutoReconnectLen <= TS_MAX_AUTORECONNECT_LEN,
                       (TB,_T("Reconnect packet len too big: %d"),
                       cbAutoReconnectLen));

            if (cbAutoReconnectLen && pAutoReconnectCookie)
            {
                PARC_SC_PRIVATE_PACKET pArcSCPkt;
                ARC_CS_PRIVATE_PACKET ArcCSPkt;
                pArcSCPkt = (PARC_SC_PRIVATE_PACKET)pAutoReconnectCookie;
                char hmacVerifier[TS_ARC_VERIFIER_LEN];

                TRC_ASSERT(sizeof(hmacVerifier) == 
                           sizeof(ArcCSPkt.SecurityVerifier),
                       (TB,_T("HMAC verifier size doesn't match pkt format")));

                
                memset(&hmacVerifier, 0, sizeof(hmacVerifier));
                memset(&ArcCSPkt, 0, sizeof(ArcCSPkt));

#ifdef INSTRUMENT_ARC
                LPDWORD pdwArcBits = (LPDWORD)pArcSCPkt->ArcRandomBits;
                KdPrint(("ARC-Client:Sending arc for LID:%d"
                         "- ARC: 0x%x,0x%x,0x%x,0x%x\n",
                        ArcCSPkt.LogonId,
                        pdwArcBits[0],pdwArcBits[1],
                        pdwArcBits[2],pdwArcBits[3]));
#endif
                

                if (SLComputeHMACVerifier(pArcSCPkt->ArcRandomBits,
                                          sizeof(pArcSCPkt->ArcRandomBits),
                                          _SL.keyPair.clientRandom,
                                          RANDOM_KEY_LENGTH,
                                          (PBYTE)&hmacVerifier,
                                          sizeof(hmacVerifier))) {

                    ArcCSPkt.cbLen = sizeof(ArcCSPkt);
                    ArcCSPkt.LogonId = pArcSCPkt->LogonId;
                    ArcCSPkt.Version = 1;
                    memcpy(ArcCSPkt.SecurityVerifier,
                           hmacVerifier,
                           sizeof(hmacVerifier));

#ifdef INSTRUMENT_ARC
                    LPDWORD pdwHMACbits = (LPDWORD)hmacVerifier;
                    KdPrint(("ARC-Client:Sending HMAC for SID:%d -"
                             "HMAC: 0x%x,0x%x,0x%x,0x%x\n",
                            ArcCSPkt.LogonId,
                            pdwHMACbits[0],pdwHMACbits[1],
                            pdwHMACbits[2],pdwHMACbits[3]));
#endif

                    //
                    // Send the HMAC verifier in the ARC C->S packet
                    //
                    DCUINT16 cbArcCSPkt = sizeof(ArcCSPkt);
                    memset(pszW, 0, TS_MAX_AUTORECONNECT_LEN);
                    memcpy(pszW, &cbArcCSPkt, sizeof(DCUINT16));
                    pszW += sizeof(DCUINT16) / 2;
                    memcpy(pszW, &ArcCSPkt, cbArcCSPkt);
                    pszW += cbArcCSPkt / 2;

                    //
                    // For security clear the data
                    //
                    memset(&hmacVerifier, 0, sizeof(hmacVerifier));
                    memset(&ArcCSPkt, 0, sizeof(ArcCSPkt));

                    fAddedAutoReconnectInfo = TRUE;
                }
            }
        }
        else {
#ifdef INSTRUMENT_ARC
            KdPrint(("ARC-Client: Not sending any autoreconnect info\n"));
#endif
        }

        //
        // If we're not going to add ARC info just add a zero length
        // and update the pointer
        //
        if (!fAddedAutoReconnectInfo) {
            DCUINT16 cbZeroLen = 0;
            // 0 length autoreconnect info
            memcpy(pszW, &cbZeroLen, sizeof(DCUINT16));
            pszW += sizeof(DCUINT16) / 2;
        }

        // Set up the pointer and size for the decouple call
        p = &InfoPkt;
        cb = (UINT) (((BYTE*)pszW) - ((BYTE *)p));
    }

    /************************************************************************/
    /* Decouple to the send context before sending the security packet      */
    /************************************************************************/
    _pCd->CD_DecoupleNotification(CD_SND_COMPONENT,
                            this,
                            CD_NOTIFICATION_FUNC(CSL,SL_SendSecInfoPacket),
                            p,
                            cb);

    // Erase the clear text password from stack variable
    SecureZeroMemory(&InfoPkt, sizeof(InfoPkt));

    DC_END_FN();
}


/****************************************************************************/
/* Name:      SLSendSecurityPacket                                          */
/*                                                                          */
/* Purpose:   1. Build and send a security packet to the Server.            */
/*            2. Build and send security info packet also.                  */
/*            3. call the Core's OnConnected callback.                      */
/*            3. move the state to SL_STATE_LICENSING.                      */
/*                                                                          */
/* Returns:   TRUE  - if all of the above setps are completed successfully. */
/*            FALSE - otherwise.                                            */
/*                                                                          */
/* Operation: Called in the Receive context                                 */
/****************************************************************************/
DCBOOL DCINTERNAL CSL::SLSendSecurityPacket(PDCUINT8 serverPublicKey,
                                       DCUINT32 serverPublicKeyLen)
{
    DCBOOL               rc = FALSE;
    DCUINT32             secPktLength;
    PRNS_SECURITY_PACKET pSecPkt = NULL;

    DC_BEGIN_FN("SLSendSecurityPacket");

    /************************************************************************/
    /* send a security packet if we are encrypting.                         */
    /************************************************************************/
    if (_SL.encrypting) {
        /********************************************************************/
        /* ALLOCATE a maximum possible encrypted data size buffer on the    */
        /* stack.                                                           */
        /********************************************************************/
        DCUINT8 encClientRandom[512];
        DCUINT32 encClientRandomLen;

        encClientRandomLen = sizeof(encClientRandom);
        if( !EncryptClientRandom(
                serverPublicKey,
                serverPublicKeyLen,
                (PDCUINT8)&_SL.keyPair.clientRandom,
                sizeof(_SL.keyPair.clientRandom),
                (PDCUINT8)&encClientRandom,
                &encClientRandomLen) ) {
            TRC_ERR((TB, _T("Failed to encrypt client random") ));


            _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                                          this,
                                          CD_NOTIFICATION_FUNC(CSL,SLSetReasonAndDisconnect),
                                          SL_ERR_ENCCLNTRANDFAILED);

            DC_QUIT;
        }

        TRC_ASSERT((encClientRandomLen <= sizeof(encClientRandom) ),
            (TB, _T("Invalid encClientRandomLen")));

        /********************************************************************/
        /* Allocate space for security exchange packet                      */
        /********************************************************************/
        secPktLength = (DCUINT)
                (sizeof(RNS_SECURITY_PACKET) + encClientRandomLen);

        pSecPkt = (PRNS_SECURITY_PACKET)UT_Malloc( _pUt, (DCUINT)secPktLength);
        if (pSecPkt == NULL)
        {
            TRC_ERR((TB, _T("Failed to allocate %u bytes for security packet"),
                    secPktLength));

            _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                                          this,
                                          CD_NOTIFICATION_FUNC(CSL,SLSetReasonAndDisconnect),
                                          SL_ERR_NOMEMFORSECPACKET);

            DC_QUIT;
        }

        /*********************************************************************/
        /* Build security packet                                             */
        /* SECURITY: We tell the server that we know how to accept an        */
        /* encrypted licensing-data packet.                                  */
        /*********************************************************************/
        TRC_NRM((TB, _T("Build security packet")));
        pSecPkt->flags = RNS_SEC_EXCHANGE_PKT | RDP_SEC_LICENSE_ENCRYPT_SC;
        pSecPkt->length = encClientRandomLen;

        TRC_NRM((TB, _T("Copy %lu bytes of client security info"),
            sizeof(encClientRandom)));

        DC_MEMCPY(
            (PDCVOID)(pSecPkt + 1),
            (PDCVOID)encClientRandom,
            (DCUINT)encClientRandomLen);

        /********************************************************************/
        /* Decouple to the send context before sending the security packet  */
        /********************************************************************/
        _pCd->CD_DecoupleNotification(CD_SND_COMPONENT,
                                this,
                                CD_NOTIFICATION_FUNC(CSL,SL_SendSecurityPacket),
                                pSecPkt,
                                (DCUINT)secPktLength);

        /********************************************************************/
        /* we finished sending the security packet. Send Info packet now.   */
        /********************************************************************/
    }

    /************************************************************************/
    /* move the state to connected state.                                   */
    /************************************************************************/
    _pUi->UI_SetChannelID(_SL.channelID);
    SLSendSecInfoPacket();

    /************************************************************************/
    /* We've finished - tell the core                                       */
    /************************************************************************/
    TRC_NRM((TB, _T("Security exchange complete")));

#ifdef USE_LICENSE
    /************************************************************************/
    /* Finished security exchange - wait for licensing                      */
    /************************************************************************/
    SL_SET_STATE(SL_STATE_LICENSING);

    //
    // Decouple to the UI thread, it will take care of
    // stopping the connection timers and starting the
    // licensing timer (in a thread safe way).
    //
    _pCd->CD_DecoupleSimpleNotification(CD_UI_COMPONENT,
                                        _pUi,
                                        CD_NOTIFICATION_FUNC(CUI,
                                            UI_OnSecurityExchangeComplete),
                                        NULL);

    if(LICENSE_OK!= _pLic->CLicenseInit(&_SL.hLicenseHandle))
    {
        TRC_ERR((TB, _T("Failed to init License Manager")));
        DC_QUIT;
    }
#else /* USE_LICENSE */
    /************************************************************************/
    /* We've finished - tell the core                                       */
    /************************************************************************/
    SL_SET_STATE(SL_STATE_CONNECTED);

    _pCd->CD_DecoupleSimpleNotification(CD_UI_COMPONENT,
                                        _pUi,
                                        CD_NOTIFICATION_FUNC(CUI,
                                            UI_OnSecurityExchangeComplete),
                                        NULL);

    _SL.callbacks.onConnected(_pCo, _SL.channelID,
                             _SL.pSCUserData,
                             _SL.SCUserDataLength,
                             _SL.serverVersion);
#endif /* USE_LICENSE */

    /************************************************************************/
    /* Hurrah! Everything has worked                                        */
    /************************************************************************/
    rc = TRUE;

DC_EXIT_POINT:

    /************************************************************************/
    /* Free the security packet (if allocated)                              */
    /************************************************************************/
    if (pSecPkt != NULL)
    {
        TRC_NRM((TB, _T("Free the security packet")));
        UT_Free( _pUt, pSecPkt);
    }

    /************************************************************************/
    /* Return to caller                                                     */
    /************************************************************************/
    DC_END_FN();
    return(rc);
}


/****************************************************************************/
/* Name:      SLReceivedDataPacket                                          */
/*                                                                          */
/* Purpose:   Handle incoming data packets                                  */
/*                                                                          */
/* Operation: Called in the Receive context                                 */
/****************************************************************************/
HRESULT DCINTERNAL CSL::SLReceivedDataPacket(PDCUINT8   pData,
                                       DCUINT     dataLen,
                                       DCUINT     flags,
                                       DCUINT     channelID,
                                       DCUINT     priority)
{
    HRESULT              hrc = S_OK;
    PRNS_SECURITY_HEADER pSecHdr;
    PDCUINT8             pCoreData;
    DCUINT               coreDataLen;
#ifdef DC_LOOPBACK
    PDCUINT8             pString;
    DCUINT8              lbRetString[SL_LB_RETURN_STRING_SIZE] =
                                 SL_LB_RETURN_STRING;
#endif

    DC_BEGIN_FN("SLReceivedDataPacket");

    SL_CHECK_STATE(SL_EVENT_ON_RECEIVED_DATA_PACKET);

    /************************************************************************/
    /* Decrypt the packet if necessary                                      */
    /************************************************************************/
    if (_SL.encrypting)
    {
        /************************************************************************/
        /* There needs to be at least enough data for RNS_SECURITY_HEADER       */
        /************************************************************************/
        if (dataLen < sizeof(RNS_SECURITY_HEADER))
        {
            TRC_ABORT((TB, _T("No RNS_SECURITY_HEADER in encrypted packet (size=%u)"), dataLen));

            //
            // It is necessary to immediately abort the connection
            // as we may be under attack here and we should stop processing
            // any additional data
            //
            SL_DropLinkImmediate(SL_ERR_DECRYPTFAILED);

            hrc = E_ABORT;
            DC_QUIT;
        }

        pSecHdr = (PRNS_SECURITY_HEADER)pData;
        if (pSecHdr->flags & RNS_SEC_ENCRYPT)
        {
            if (!SL_DecryptHelper(pData, &dataLen))
            {
                TRC_ERR((TB, _T("SL failed to decompress data")));
                DC_QUIT;
            }

            if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
                coreDataLen = dataLen - sizeof(RNS_SECURITY_HEADER2);
                pCoreData = (PDCUINT8)pSecHdr + sizeof(RNS_SECURITY_HEADER2);
            }
            else {
                coreDataLen = dataLen - sizeof(RNS_SECURITY_HEADER1);
                pCoreData = (PDCUINT8)pSecHdr + sizeof(RNS_SECURITY_HEADER1);
            }
        }
        else
        {
            /****************************************************************/
            /* This packet not encrypted, although encryption is supported  */
            /****************************************************************/
            if (_SL.encryptionLevel <= 1) {
                // For TS4 server, the default is only client to server encryption
                // so if encryptionlevel is 1 or less, then we accept unencrypted
                // data as default.
                coreDataLen = dataLen - sizeof(RNS_SECURITY_HEADER);
                pCoreData = (PDCUINT8)(pSecHdr) + sizeof(RNS_SECURITY_HEADER);
                TRC_DBG((TB, _T("Unencrypted packet at %p (%u)"),
                        pCoreData, coreDataLen));
            }
            else {
            
                //
                // It is necessary to immediately abort the connection
                // as we may be under attack here and we should stop processing
                // any additional data
                //
                TRC_ERR((TB, _T("unencrypted data received in encrypted stream")));
                SL_DropLinkImmediate(SL_ERR_DECRYPTFAILED);
                DC_QUIT;
            }
        }

        /********************************************************************/
        /* Decryption OK or packet not encrypted - set up stuff to pass to  */
        /* Core                                                             */
        /********************************************************************/
        flags = (DCUINT)pSecHdr->flags;
    }
    else
    {
        /********************************************************************/
        /* Not encrypting - set up data pointer and length                  */
        /********************************************************************/
        pCoreData = pData;
        coreDataLen = dataLen;
        flags &= ~RNS_SEC_ENCRYPT;
        TRC_DBG((TB, _T("Never-encrypted packet at %p (%u)"),
                pCoreData, coreDataLen));
    }

    {
        if (channelID == _SL.channelID)
        {
            /****************************************************************/
            /* Pass the packet to the Core                                  */
            /****************************************************************/
            TRC_NRM((TB, _T("Packet received on Share channel %x - pass to CO"),
                    channelID));
            _SL.callbacks.onPacketReceived(_pCo, pCoreData,
                                          coreDataLen,
                                          flags,
                                          channelID,
                                          priority);
        }
        else
        {
            /****************************************************************/
            /* Pass packet to virtual channel handler                       */
            /****************************************************************/
            TRC_NRM((TB, _T("Packet received on channel %x"),
                    channelID));

            _pChan->ChannelOnPacketReceived(pCoreData,
                                    coreDataLen,
                                    flags,
                                    channelID,
                                    priority);
        }
    }

    /************************************************************************/
    /* No state change                                                      */
    /************************************************************************/

DC_EXIT_POINT:
    DC_END_FN();
    return(hrc);
} /* SLReceivedDataPacket */


/****************************************************************************/
/* Name:      SLDecryptRedirectionPacket                                    */
/*                                                                          */
/* Purpose:   Decrypt Redirection packet from server                        */
/****************************************************************************/
DCBOOL DCINTERNAL CSL::SLDecryptRedirectionPacket(PDCUINT8   *ppData,
                                                  DCUINT     *pdataLen)
{
    // *ppData returns the decrypted data
    PRNS_SECURITY_HEADER1 pSecHdr;
    PRNS_SECURITY_HEADER2 pSecHdr2;
    PDCUINT8             pCoreData;
    DCUINT               coreDataLen;
    BOOL                 rc = FALSE;

    DC_BEGIN_FN("SLDecryptRedirectionPacket");

    SL_CHECK_STATE(SL_EVENT_ON_RECEIVED_DATA_PACKET);

    /************************************************************************/
    /* Decrypt the packet if necessary                                      */
    /************************************************************************/
    if (_SL.encrypting) {
        pSecHdr = (PRNS_SECURITY_HEADER1)*ppData;

        if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            // *pdataLen must be larger than sizeof(RNS_SECURITY_HEADER2)
            if (*pdataLen <= sizeof(RNS_SECURITY_HEADER2)) {
                SL_DropLinkImmediate(SL_ERR_DECRYPTFAILED);
                TRC_ERR((TB, _T("SL security header not large enough")));
                rc = FALSE;
                DC_QUIT;
            }

            pSecHdr2 = (PRNS_SECURITY_HEADER2)*ppData;
            coreDataLen = *pdataLen - sizeof(RNS_SECURITY_HEADER2);
            pCoreData = (PDCUINT8)pSecHdr2 + sizeof(RNS_SECURITY_HEADER2);

            TRC_DBG((TB, _T("Encrypted packet at %p (%u), sign %p (%u)"),
                pCoreData, coreDataLen, pSecHdr2,
                sizeof(RNS_SECURITY_HEADER2)));
        }
        else {
            // Bug 679216 - must check there is enough data before reading
            // *pdataLen must be larger than sizeof(RNS_SECURITY_HEADER1)
            if (*pdataLen <= sizeof(RNS_SECURITY_HEADER1)) {
                SL_DropLinkImmediate(SL_ERR_DECRYPTFAILED);
                TRC_ERR((TB, _T("SL security header not large enough")));
                rc = FALSE;
                DC_QUIT;
            }

            pSecHdr = (PRNS_SECURITY_HEADER1)*ppData;
            coreDataLen = *pdataLen - sizeof(RNS_SECURITY_HEADER1);
            pCoreData = (PDCUINT8)pSecHdr + sizeof(RNS_SECURITY_HEADER1);
        
            TRC_DBG((TB, _T("Encrypted packet at %p (%u), sign %p (%u)"),
                pCoreData, coreDataLen, pSecHdr,
                sizeof(RNS_SECURITY_HEADER1)));
        }

        TRC_DATA_DBG("Data buffer before decryption", pCoreData, coreDataLen);

        TRC_NRM((TB, _T("Update Decrypt Session Key Count , %d"),
                _SL.decryptCount));

        /****************************************************************/
        /* Decrypt the packet                                           */
        /****************************************************************/
        if( _SL.decryptCount == UPDATE_SESSION_KEY_COUNT ) {
            rc = TRUE;
            // Don't need to update the session key if using FIPS
            if (_SL.encryptionMethodSelected != SM_FIPS_ENCRYPTION_FLAG) {
                rc = UpdateSessionKey(
                    _SL.startDecryptKey,
                    _SL.currentDecryptKey,
                    _SL.encryptionMethodSelected,
                    _SL.keyLength,
                    &_SL.rc4DecryptKey,
                    _SL.encryptionLevel );
            }
            if( !rc ) {
                TRC_ERR((TB, _T("SL failed to update session key")));
                DC_QUIT;
            }

            /************************************************************/
            /* reset counter.                                           */
            /************************************************************/
            _SL.decryptCount = 0;
        }

        if (SL_GetEncSafeChecksumSC() !=
            ((pSecHdr->flags & RDP_SEC_SECURE_CHECKSUM) != 0)) {
            TRC_ERR((TB,_T("SC safechecksum: 0x%x mismatch protocol:0x%x"),
                     SL_GetEncSafeChecksumSC(),
                     (pSecHdr->flags & RDP_SEC_SECURE_CHECKSUM)));
        }

        if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            rc = TSCAPI_DecryptData(
                                    &(_SL.SLCapiData),
                                    pCoreData,
                                    coreDataLen,
                                    pSecHdr2->padlen,
                                    (PDCUINT8)pSecHdr2->dataSignature,
                                    _SL.totalDecryptCount);
            *pdataLen -= pSecHdr2->padlen;
        }
        else {
            rc = DecryptData(
                            _SL.encryptionLevel,
                            _SL.currentDecryptKey,
                            &_SL.rc4DecryptKey,
                            _SL.keyLength,
                            pCoreData,
                            coreDataLen,
                            _SL.macSaltKey,
                            (PDCUINT8)((PRNS_SECURITY_HEADER1)pSecHdr)->dataSignature,
                            (pSecHdr->flags & RDP_SEC_SECURE_CHECKSUM),
                            _SL.totalDecryptCount
                            );
        }
        *ppData = pCoreData;
        if( !rc ) {
            //
            // It is necessary to immediately abort the connection
            // as we may be under attack here and we should stop processing
            // any additional data
            //
            SL_DropLinkImmediate(SL_ERR_DECRYPTFAILED);
            TRC_ERR((TB, _T("SL failed to decrypt data")));
            DC_QUIT;
        }

        /****************************************************************/
        /* successfully decrypted a packet, increment the decrption     */
        /* counter.                                                     */
        /****************************************************************/
        _SL.decryptCount++;
        _SL.totalDecryptCount++;

        TRC_DBG((TB, _T("Data decrypted")));
        TRC_DATA_DBG("Data buffer after decryption", pCoreData, coreDataLen);
    }
    else {
        TRC_ABORT((TB,_T("Should not get here unless decrypt state is wrong")));
        // Should add disconnect here later
    }

DC_EXIT_POINT:
    return rc;
    DC_END_FN();
} /* SLDecryptRedirectionPacket */


/****************************************************************************/
/* Name:      SLReceivedSecPacket                                           */
/*                                                                          */
/* Purpose:   Handle incoming security packet                               */
/*                                                                          */
/* Operation: Called in the Receive context                                 */
/****************************************************************************/
DCVOID DCINTERNAL CSL::SLReceivedSecPacket(PDCUINT8   pData,
                                      DCUINT     dataLen,
                                      DCUINT     flags,
                                      DCUINT     channelID,
                                      DCUINT     priority)
{
    BOOL bAssert;

    DC_BEGIN_FN("SLReceivedSecPacket");

    SL_CHECK_STATE(SL_EVENT_ON_RECEIVED_SEC_PACKET);

    DC_IGNORE_PARAMETER(pData);
    DC_IGNORE_PARAMETER(dataLen);
    DC_IGNORE_PARAMETER(flags);
    DC_IGNORE_PARAMETER(channelID);
    DC_IGNORE_PARAMETER(priority);

    bAssert = FALSE;
    TRC_ASSERT((bAssert),
        (TB, _T("SLReceivedSecPacket - ")
         _T("WE DON'T EXPECT SECURITY PACKET FROM SERVER")));

DC_EXIT_POINT:
    DC_END_FN();
} /* SLReceivedSecPacket  */

/****************************************************************************/
/* Name:      SLInitSecurity                                                */
/*                                                                          */
/* Purpose:   Initialize security interface                                 */
/****************************************************************************/
DCVOID DCINTERNAL CSL::SLInitSecurity(DCVOID)
{
    DCBOOL intRC = FALSE;
    DWORD FipsPolicy = 0;
    DCBOOL rc = FALSE;
    HKEY hKey;
    DWORD KeyType, cbSize;

    DC_BEGIN_FN("SLInitSecurity");

    _SL.encryptionEnabled = TRUE;

    // Read GP Fips setting
    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      TS_FIPS_POLICY,
                      0,
                      KEY_READ,
                      &hKey);

    if (ERROR_SUCCESS == rc) {
        cbSize = sizeof(FipsPolicy);
        rc = RegQueryValueEx(hKey,
                             FIPS_ALGORITH_POLICY,
                             0,
                             &KeyType,
                             (LPBYTE)&FipsPolicy,
                             &cbSize);
        if (ERROR_SUCCESS != rc) {
            FipsPolicy = 0;
        }
        RegCloseKey(hKey);
    }
    TRC_ERR((TB, _T("GP setting for FIPS is %d"), FipsPolicy));

    // If GP FIPS policy is enabled, only do FIPS
    if (FipsPolicy == 1) {
        _SL.encryptionMethodsSupported = SM_FIPS_ENCRYPTION_FLAG;
        _pUi->UI_SetfUseFIPS(TRUE);
    }
    else {
        _SL.encryptionMethodsSupported =
              SM_40BIT_ENCRYPTION_FLAG |
              SM_56BIT_ENCRYPTION_FLAG |
              SM_128BIT_ENCRYPTION_FLAG |
              SM_FIPS_ENCRYPTION_FLAG;
    }
    
    /************************************************************************/
    /* The server certificate and public key.                               */
    /************************************************************************/
    _SL.pbCertificate    = NULL;
    _SL.cbCertificate    = 0;
    _SL.pServerCert      = NULL;
    _SL.pbServerPubKey   = NULL;
    _SL.cbServerPubKey   = 0;

    _SL.SLCapiData.hDecKey = NULL;
    _SL.SLCapiData.hEncKey = NULL;
    _SL.SLCapiData.hProv = NULL;
    _SL.SLCapiData.hSignKey = NULL;

    /************************************************************************/
    /* Initialization complete                                              */
    /************************************************************************/
    intRC = TRUE;

DC_EXIT_POINT:
    /************************************************************************/
    /* If anything failed, release resources                                */
    /************************************************************************/
    if (!intRC)
    {
        TRC_NRM((TB, _T("Clean up")));
        SLFreeInitResources();
    }

    DC_END_FN();
} /* SLInitSecurity */


/****************************************************************************/
/* Name:      SLInitCSUserData                                              */
/*                                                                          */
/* Purpose:   Initialize Core to Server security user data                  */
/*                                                                          */
/* Operation: Called during initialization, after security API has been     */
/*            initialized successfully, to build the user data which is     */
/*            passed to NL_Connect().                                       */
/****************************************************************************/
DCVOID DCAPI CSL::SLInitCSUserData(DCVOID)
{
    DC_BEGIN_FN("SLInitCSUserData");

    /************************************************************************/
    /* Calculate the size of user data required (& trace the packages).     */
    /* Initial size is "size of RNS_UD_CS_SEC"                              */
    /************************************************************************/
    _SL.CSUserDataLength  = sizeof(RNS_UD_CS_SEC);

    /************************************************************************/
    /* Allocate space for all user data                                     */
    /************************************************************************/
    _SL.pCSUserData = (PDCUINT8)UT_Malloc( _pUt, _SL.CSUserDataLength);
    if (_SL.pCSUserData == NULL)
    {
        TRC_ERR((TB, _T("Failed to alloc %u bytes for user data"),
                 _SL.CSUserDataLength));
        _pUi->UI_FatalError(DC_ERR_OUTOFMEMORY);
        TRC_ABORT((TB,_T("returned from UI_FatalError")));
    }
    TRC_NRM((TB, _T("Allocated %u bytes for user data"), _SL.CSUserDataLength));

    /************************************************************************/
    /* Build security user data                                             */
    /************************************************************************/
    TRC_NRM((TB, _T("Build security user data")));

    ((PRNS_UD_CS_SEC)_SL.pCSUserData)->header.type = RNS_UD_CS_SEC_ID;
    ((PRNS_UD_CS_SEC)_SL.pCSUserData)->header.length =
        (DCUINT16)_SL.CSUserDataLength;
    ((PRNS_UD_CS_SEC)_SL.pCSUserData)->encryptionMethods =
        _SL.encryptionMethodsSupported;
    ((PRNS_UD_CS_SEC)_SL.pCSUserData)->extEncryptionMethods = 0;


    //
    // for backward compatibility, we need to set the encryptionMethods field to
    // zero for Frnech Locale system. However set the required encryption level
    // in the new field extEncryptionMethods.
    //

    if( FindIsFrenchSystem() ) {
        ((PRNS_UD_CS_SEC)_SL.pCSUserData)->encryptionMethods = 0;
        ((PRNS_UD_CS_SEC)_SL.pCSUserData)->extEncryptionMethods =
            _SL.encryptionMethodsSupported;
    }

    TRC_DATA_NRM("Built user data", _SL.pCSUserData, _SL.CSUserDataLength);

DC_EXIT_POINT:

    /************************************************************************/
    /* Return to caller                                                     */
    /************************************************************************/
    DC_END_FN();
} /* SLInitCSUserData */


/****************************************************************************/
/* Name:      SLFreeConnectResources                                        */
/*                                                                          */
/* Purpose:   Release resources acquired during connection processing       */
/*                                                                          */
/* Operation: Called by both SL_OnDisconnected and SL_OnTerminating to free */
/*            resources                                                     */
/****************************************************************************/
DCVOID DCINTERNAL CSL::SLFreeConnectResources(DCVOID)
{
    DC_BEGIN_FN("SLFreeConnectResources");

    /************************************************************************/
    /* Free SC user data if any                                             */
    /************************************************************************/
    if (_SL.pSCUserData != NULL)
    {
        TRC_NRM((TB, _T("Free user data")));
        UT_Free( _pUt, _SL.pSCUserData);
        _SL.pSCUserData = NULL;
        _SL.SCUserDataLength = 0;
    }

    /************************************************************************/
    /* Free the server certificate and public key                           */
    /************************************************************************/
    if( _SL.pServerCert )
    {
        UT_Free( _pUt,  _SL.pServerCert );
        _SL.pServerCert = NULL;
    }
    if( _SL.pbCertificate )
    {
        UT_Free( _pUt,  _SL.pbCertificate );
        _SL.pbCertificate = NULL;
        _SL.cbCertificate = 0;
    }
    if( _SL.pbServerPubKey )
    {
        UT_Free( _pUt,  _SL.pbServerPubKey );
        _SL.pbServerPubKey = NULL;
        _SL.cbServerPubKey = 0;
    }

    /************************************************************************/
    /* Clear global data                                                    */
    /************************************************************************/
    _SL.decryptFailed = FALSE;

    DC_END_FN();
} /* SLFreeConnectResources */


/****************************************************************************/
/* Name:      SLFreeInitResources                                           */
/*                                                                          */
/* Purpose:   Release resources acquired during initialization              */
/*                                                                          */
/* Operation: Called by SLTerminating to free resources                     */
/****************************************************************************/
DCVOID DCINTERNAL CSL::SLFreeInitResources(DCVOID)
{
    DC_BEGIN_FN("SLFreeInitResources");

    /************************************************************************/
    /* Free CS user data if any                                             */
    /************************************************************************/
    if (_SL.pCSUserData != NULL)
    {
        TRC_NRM((TB, _T("Free CS user data")));
        UT_Free( _pUt, _SL.pCSUserData);
        _SL.pCSUserData = NULL;
        _SL.CSUserDataLength = 0;
    }

    /************************************************************************/
    /* Free CS User Data.                                                   */
    /************************************************************************/
    if (_SL.pCSUserData != NULL)
    {
        TRC_NRM((TB, _T("Free CS User Data")));
        UT_Free( _pUt, _SL.pCSUserData);
        _SL.pCSUserData = NULL;
        _SL.CSUserDataLength = 0;
    }

    /************************************************************************/
    /* No need to clear SL data - it will be reinitialized to 0 when        */
    /* SL_Init() is called.                                                 */
    /************************************************************************/

    DC_END_FN();
} /* SLFreeInitResources */


/****************************************************************************/
/* Name:    SLIssueDisconnectedCallback                                     */
/*                                                                          */
/* Purpose: Issues a onDisconnected callback.  This function is called      */
/*          when an SL connection error occurs before the lower layers      */
/*          are connected.                                                  */
/*                                                                          */
/* Params:  IN  reason - reason to pass on the callback.                    */
/****************************************************************************/
DCVOID DCINTERNAL CSL::SLIssueDisconnectedCallback(ULONG_PTR reason)
{
    DC_BEGIN_FN("SLIssueDisconnectedCallback");

    /************************************************************************/
    /* Just issue a onDisconnected callback with the specified reason.      */
    /************************************************************************/
    SL_OnDisconnected(SL_MAKE_DISCONNECT_ERR(reason));

    DC_END_FN();
} /* SLIssueDisconnectedCallback */


/****************************************************************************/
/* Name:    SLSetReasonAndDisconnect                                        */
/*                                                                          */
/* Purpose: Set the disconnection reason and then call NL_Disconnect.  This */
/*          function is always called in the sender context.                */
/****************************************************************************/
DCVOID DCINTERNAL CSL::SLSetReasonAndDisconnect(ULONG_PTR reason)
{
    DC_BEGIN_FN("SLSetReasonAndDisconnect");

    TRC_NRM((TB, _T("Setting disconnect error code from %u->%u"),
             _SL.disconnectErrorCode,
             SL_MAKE_DISCONNECT_ERR(reason)));

    // Check that the disconnectErrorCode has not already been set and then
    // set it.
    if (0 != _SL.disconnectErrorCode)
    {
        TRC_ERR((TB, _T("Disconnect error code has already been set! Was %u"),
                     _SL.disconnectErrorCode));
    }

    _SL.disconnectErrorCode = SL_MAKE_DISCONNECT_ERR(reason);

    // Finally begin the disconnect processing.
    SL_Disconnect();

    DC_END_FN();
} /* SLSetReasonAndDisconnect */


/****************************************************************************/
/* Name:      SL_DecryptHelper                                              */
/*                                                                          */
/* Purpose:   Increments decryptcount, does decryption.                     */
/*                                                                          */
/* Returns:   TRUE if the certificate is validated successfully or FALSE    */
/*            FALSE otherwise.                                              */
/****************************************************************************/
DCBOOL DCINTERNAL CSL::SL_DecryptHelper(
        PDCUINT8   pData,
        DCUINT     *pdataLen)
{
    PRNS_SECURITY_HEADER pSecHdr;
    PRNS_SECURITY_HEADER2 pSecHdr2;
    PDCUINT8 pCoreData;
    DCUINT   coreDataLen;
    DCBOOL   rc;

    DC_BEGIN_FN("SL_DecryptHelper");

    // Bug 679214 - must check there is enough data before reading
    if (*pdataLen < sizeof(RNS_SECURITY_HEADER) ||
        *pdataLen < sizeof(RNS_SECURITY_HEADER1)) {
        SL_DropLinkImmediate(SL_ERR_DECRYPTFAILED);
        TRC_ERR((TB, _T("SL security header not large enough")));
        rc = FALSE;
        DC_QUIT;
    }

    pSecHdr = (PRNS_SECURITY_HEADER)pData;
    TRC_ASSERT((pSecHdr->flags & RNS_SEC_ENCRYPT),
                (TB, _T("SL_DecryptHelper should only be called on encrypted data")));

    if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
        // Bug 679214 - must check there is enough data before reading
        if (*pdataLen < sizeof(RNS_SECURITY_HEADER2)) {
            SL_DropLinkImmediate(SL_ERR_DECRYPTFAILED);
            TRC_ERR((TB, _T("SL security header not large enough")));
            rc = FALSE;
            DC_QUIT;
        }
        pSecHdr2 = (PRNS_SECURITY_HEADER2)pData;
        pCoreData = (PDCUINT8)pData + sizeof(RNS_SECURITY_HEADER2);
        coreDataLen = *pdataLen - sizeof(RNS_SECURITY_HEADER2);

        TRC_DBG((TB, _T("Encrypted packet at %p (%u), sign %p (%u)"),
                pCoreData, coreDataLen, pData, sizeof(RNS_SECURITY_HEADER2)));
    }
    else {
        pCoreData = (PDCUINT8)pData + sizeof(RNS_SECURITY_HEADER1);
        coreDataLen = *pdataLen - sizeof(RNS_SECURITY_HEADER1);

        TRC_DBG((TB, _T("Encrypted packet at %p (%u), sign %p (%u)"),
                pCoreData, coreDataLen, pData, sizeof(RNS_SECURITY_HEADER1)));
    }

    TRC_NRM((TB, _T("Update Decrypt Session Key Count , %d"),
        _SL.decryptCount));

    /****************************************************************/
    /* Decrypt the packet                                           */
    /****************************************************************/
    if( _SL.decryptCount == UPDATE_SESSION_KEY_COUNT ) {
        rc = TRUE;
        // Don't need to update the session key if using FIPS
        if (_SL.encryptionMethodSelected != SM_FIPS_ENCRYPTION_FLAG) {
            rc = UpdateSessionKey(
                    _SL.startDecryptKey,
                    _SL.currentDecryptKey,
                    _SL.encryptionMethodSelected,
                    _SL.keyLength,
                    &_SL.rc4DecryptKey,
                    _SL.encryptionLevel );
        }
        if( !rc ) {
            TRC_ERR((TB, _T("SL failed to update session key")));
            DC_QUIT;
        }

        /************************************************************/
        /* reset counter.                                           */
        /************************************************************/
        _SL.decryptCount = 0;
    }

    TRC_ASSERT((_SL.decryptCount < UPDATE_SESSION_KEY_COUNT),
        (TB, _T("Invalid decrypt count")));

    TRC_DATA_DBG("Data buffer before decryption", pCoreData, coreDataLen);

    if (SL_GetEncSafeChecksumSC() !=
        ((pSecHdr->flags & RDP_SEC_SECURE_CHECKSUM) != 0)) {
        TRC_ERR((TB,_T("SC safechecksum: 0x%x mismatch protocol:0x%x"),
                 SL_GetEncSafeChecksumSC(),
                 (pSecHdr->flags & RDP_SEC_SECURE_CHECKSUM)));
    }

    if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
        rc = TSCAPI_DecryptData(
                        &(_SL.SLCapiData),
                        pCoreData,
                        coreDataLen,
                        pSecHdr2->padlen,
                        (PDCUINT8)pSecHdr2->dataSignature,
                        _SL.totalDecryptCount);
        *pdataLen -= pSecHdr2->padlen;
    }
    else {
        rc = DecryptData(
                _SL.encryptionLevel,
                _SL.currentDecryptKey,
                &_SL.rc4DecryptKey,
                _SL.keyLength,
                pCoreData,
                coreDataLen,
                _SL.macSaltKey,
                (PDCUINT8)((PRNS_SECURITY_HEADER1)pSecHdr)->dataSignature,
                (pSecHdr->flags & RDP_SEC_SECURE_CHECKSUM),
                _SL.totalDecryptCount);
    }
    if( !rc ) {

        //
        // It is necessary to immediately abort the connection
        // as we may be under attack here and we should stop processing
        // any additional data
        //
        SL_DropLinkImmediate(SL_ERR_DECRYPTFAILED);

        TRC_ERR((TB, _T("SL failed to decrypt data")));
        DC_QUIT;
    }

    /****************************************************************/
    /* successfully decrypted a packet, increment the decrption     */
    /* counter.                                                     */
    /****************************************************************/
    _SL.decryptCount++;
    _SL.totalDecryptCount++;

    TRC_DBG((TB, _T("Data decrypted")));
    TRC_DATA_DBG("Data buffer after decryption", pCoreData, coreDataLen);

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


#ifdef USE_LICENSE

/****************************************************************************/
/* Name:      SLReceivedLicPacket                                           */
/*                                                                          */
/* Purpose:   Handle incoming license packet                                */
/*                                                                          */
/* Operation: Called in the Receive context                                 */
/****************************************************************************/
DCVOID DCINTERNAL CSL::SLReceivedLicPacket(
        PDCUINT8   pData,
        DCUINT     dataLen,
        DCUINT     flags,
        DCUINT     channelID,
        DCUINT     priority)
{
    DC_BEGIN_FN("SLReceivedLicPacket");

    SL_CHECK_STATE(SL_EVENT_ON_RECEIVED_LIC_PACKET);

    DC_IGNORE_PARAMETER(flags);
    DC_IGNORE_PARAMETER(channelID);
    DC_IGNORE_PARAMETER(priority);

    //
    // We will decrypt the S->C licensing data packet if encryption is
    // on AND if the server encrypted this particular packet.
    //
    if (_SL.encrypting &&
        (((PRNS_SECURITY_HEADER_UA)pData)->flags & RNS_SEC_ENCRYPT))
    {
        if (!SL_DecryptHelper(pData, &dataLen))
        {
            TRC_ERR((TB, _T("SL failed to decompress data")));
            DC_QUIT;
        }
    }

    // Decouple to Sender thread.
    _pCd->CD_DecoupleSyncDataNotification(CD_SND_COMPONENT, this,
            CD_NOTIFICATION_FUNC(CSL,SLLicenseData), pData, dataLen);

DC_EXIT_POINT:
    DC_END_FN();
} /* SLReceivedLicPacket */


/****************************************************************************/
/* Name:      SLLicenseData                                                 */
/*                                                                          */
/* Purpose:   Handle incoming license packets on the Send thread            */
/*                                                                          */
/* Params:    pData   - pointer to incoming license data                    */
/*            dataLen - length of data                                      */
/****************************************************************************/
DCVOID DCINTERNAL CSL::SLLicenseData(PDCVOID pData, DCUINT dataLen)
{
    int licenseResult;
    int nSecHeader;
    PDCUINT8 pbInput = NULL;
    UINT32 uiExtendedErrorInfo = TS_ERRINFO_NOERROR;

    DC_BEGIN_FN("SLLicenseData");

    if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
        nSecHeader = sizeof(RNS_SECURITY_HEADER2);
    }
    else {
        nSecHeader = (((PRNS_SECURITY_HEADER_UA)pData)->flags & RNS_SEC_ENCRYPT) ?
                        sizeof(RNS_SECURITY_HEADER1) : sizeof(RNS_SECURITY_HEADER);
    }
    pbInput = (PDCUINT8)pData;
    dataLen -= nSecHeader;
    pbInput += nSecHeader;

    if(((PRNS_SECURITY_HEADER_UA)pData)->flags & RDP_SEC_LICENSE_ENCRYPT_CS)
    {
        TRC_NRM((TB,_T("Server specified encrypt licensing packets")));
        _pLic->SetEncryptLicensingPackets(TRUE);
    }
    else
    {
        _pLic->SetEncryptLicensingPackets(FALSE);
    }

    /************************************************************************/
    /* Call licensing callout                                               */
    /************************************************************************/
    licenseResult = _pLic->CLicenseData(_SL.hLicenseHandle,
                                 pbInput,
                                 (DWORD)dataLen,
                                 &uiExtendedErrorInfo);

    //
    // Licensing is enforced, proceed with the connection only if the licensing
    // protocol has completed successfully.
    //
    TRC_ASSERT( ( ( licenseResult == LICENSE_OK ) ||
                ( licenseResult == LICENSE_CONTINUE ) ||
                ( licenseResult == LICENSE_ERROR ) ),
                ( TB,_T("Invalid license result %d"), licenseResult ) );

    /************************************************************************/
    /* If everything is finished, tell the Core                             */
    /************************************************************************/
    if ( licenseResult == LICENSE_OK )
    {
        TRC_NRM((TB, _T("License negotiation complete")));

        //
        // stop the licensing timer
        //

        //
        // Decouple to the UI thread, it will take care of
        // stopping the licensing timer.
        // (in a thread safe way).
        //
        _pCd->CD_DecoupleSimpleNotification(CD_UI_COMPONENT,
                                            _pUi,
                                            CD_NOTIFICATION_FUNC(CUI,
                                            UI_OnLicensingComplete),
                                            NULL);

        SL_SET_STATE(SL_STATE_CONNECTED);

        TRC_NRM((TB, _T("Terminate License Manager")));

        _pLic->CLicenseTerm(_SL.hLicenseHandle);
                _SL.hLicenseHandle = NULL;

        _SL.callbacks.onConnected(_pCo, _SL.channelID,
                                 _SL.pSCUserData,
                                 _SL.SCUserDataLength,
                                 _SL.serverVersion);
    }
    else if( LICENSE_CONTINUE != licenseResult )
    {
        TRC_ERR((TB, _T("License negotiation failed: %d"), licenseResult));

        SL_SET_STATE(SL_STATE_DISCONNECTING);

        _pCd->CD_DecoupleSimpleNotification(
                                 CD_UI_COMPONENT,
                                 _pUi,
                                  CD_NOTIFICATION_FUNC(CUI,
                                      UI_SetDisconnectReason),
                                  UI_MAKE_DISCONNECT_ERR(
                                      UI_ERR_LICENSING_NEGOTIATION_FAIL));


        _pCd->CD_DecoupleSimpleNotification(
                                 CD_UI_COMPONENT,
                                 _pUi,
                                  CD_NOTIFICATION_FUNC(CUI,
                                      UI_SetServerErrorInfo),
                                  uiExtendedErrorInfo);

        SL_Disconnect();
    }

    DC_END_FN();
} /* SLLicenseData  */
#endif  //USE_LICENSE


#ifdef OS_WINCE
#define CLIENTADDRESS_LENGTH 30
#endif


/****************************************************************************/
/* Name:      SLGetComputerAddressW                                         */
/*                                                                          */
/* Purpose:   Retrieves the computer address.                               */
/****************************************************************************/
DCBOOL DCINTERNAL CSL::SLGetComputerAddressW(PDCUINT8 szBuff)
{
   BOOL rc = FALSE;

   DC_BEGIN_FN("UT_GetComputerAddressW");

   // initialize client address family and client address length
   *((PDCUINT16_UA)szBuff) = 0;
   *((PDCUINT16_UA)(szBuff+sizeof(DCUINT16))) = 0;

   if (_pUi->UI_GetTDSocket() != INVALID_SOCKET) {
       int      sockLen;
       SOCKADDR sockName;
       char     *pszaddr;
       UINT     addrlength;
       USHORT   pstrW[CLIENTADDRESS_LENGTH + 2];

       sockLen = sizeof(sockName);

       if (getsockname(_pUi->UI_GetTDSocket(), &sockName, &sockLen) == 0) {
           // client address family
           *((PDCUINT16_UA)szBuff) = sockName.sa_family;
           szBuff += sizeof(DCUINT16);

           pszaddr = inet_ntoa(((PSOCKADDR_IN)&sockName)->sin_addr);
           addrlength = strlen(pszaddr) + 1;

           // client address length
           *((PDCUINT16_UA)szBuff) = (USHORT) (addrlength * 2);
           szBuff += sizeof(DCUINT16);

           // client address
#ifdef OS_WIN32
           {
           ULONG ulRetVal;

           ulRetVal = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                   pszaddr, -1, pstrW, CLIENTADDRESS_LENGTH + 2);
           pstrW[ulRetVal] = 0;
           memcpy(szBuff, pstrW, (ulRetVal + 1) * 2);
           }
#else // !OS_WIN32
           mbstowcs(pstrW, pszaddr, addrlength);
           memcpy(szBuff, pstrW, addrlength * 2);
#endif // OS_WIN32

           rc = TRUE;
       }
   }

   DC_END_FN()
   return rc;
}

//
// SLComputeHMACVerifier
// Compute the HMAC verifier from the random
// and the cookie
//
BOOL
CSL::SLComputeHMACVerifier(
    PBYTE pCookie,     //IN - the shared secret
    LONG cbCookieLen,  //IN - the shared secret len
    PBYTE pRandom,     //IN - the session random
    LONG cbRandomLen,  //IN - the session random len
    PBYTE pVerifier,   //OUT- the verifier
    LONG cbVerifierLen //IN - the verifier buffer length
    )
{
    BOOL fRet = FALSE;
    DC_BEGIN_FN("SLComputeHMACVerifier");

    TRC_ASSERT(cbVerifierLen >= MD5DIGESTLEN,
               (TB,_T("cbVerifierLen too short!")));

    if (!(pCookie &&
          cbCookieLen &&
          pRandom &&
          cbRandomLen &&
          pVerifier &&
          cbVerifierLen)) {

        TRC_ERR((TB,_T("Invalid param(s) bailing on HMAC")));
        DC_QUIT;

    }
    HMACMD5_CTX hmacctx;
    HMACMD5Init(&hmacctx, pCookie, cbCookieLen);

    HMACMD5Update(&hmacctx, pRandom, cbRandomLen);
    HMACMD5Final(&hmacctx, pVerifier);

    fRet = TRUE;

    DC_END_FN();

DC_EXIT_POINT:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\snd.h ===
/**INC+**********************************************************************/
/* Header:    snd.h                                                         */
/*                                                                          */
/* Purpose:   Sender Thread API                                             */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#ifndef _H_SND
#define _H_SND

#include "objs.h"
#include "cd.h"

class CCD;
class CCC;
class CIH;
class COR;
class CCO;
class CFS;
class CSL;
class CUH;

class CSND
{
public:
    CSND(CObjs* objs);
    ~CSND();

public:
    //
    // API
    //
    DCVOID DCAPI SND_Main(DCVOID);

    static DCVOID DCAPI SND_StaticMain(PDCVOID param)
    {
        ((CSND*)param)->SND_Main();
    }

    DCVOID DCAPI SND_Init(DCVOID);
    DCVOID DCAPI SND_Term(DCVOID);
    DCVOID DCAPI SND_BufferAvailable(ULONG_PTR unusedParam);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CSND, SND_BufferAvailable);


private:
    CCD* _pCd;
    CCC* _pCc;
    CIH* _pIh;
    COR* _pOr;
    CCO* _pCo;
    CFS* _pFs;
    CSL* _pSl;
    CUH* _pUh;

private:
    CObjs* _pClientObjects;
    BOOL   _fSNDInitComplete;
};

#endif /* _H_SND */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\slapi.cpp ===
/****************************************************************************/
/* slapi.cpp                                                                */
/*                                                                          */
/* Security Layer API                                                       */
/*                                                                          */
/* Copyright (C) 1997-1999 Microsoft Corporation                            */
/****************************************************************************/

#include <adcg.h>

extern "C" {
#define TRC_GROUP TRC_GROUP_SECURITY
#define TRC_FILE  "aslapi"
#include <atrcapi.h>
}

#include "autil.h"
#include "wui.h"
#include "sl.h"
#include "nl.h"
#include "td.h"
#include "cd.h"
#include "clicense.h"

CSL::CSL(CObjs* objs)
{
    _pClientObjects = objs;
    _fSLInitComplete = FALSE;
}


CSL::~CSL()
{
}

/****************************************************************************/
/* Name:      SL_Init                                                       */
/*                                                                          */
/* Purpose:   Initialize the Security Layer                                 */
/*                                                                          */
/* Params:    pCallbacks - list of callbacks                                */
/*                                                                          */
/* Operation: Called in the Send context                                    */
/****************************************************************************/
DCVOID DCINTERNAL CSL::SL_Init(PSL_CALLBACKS pCallbacks)
{
    SL_CALLBACKS myCallbacks;

    DC_BEGIN_FN("SL_Init");

    SL_DBG_SETINFO(SL_DBG_INIT_CALLED);

    _pUt   = _pClientObjects->_pUtObject;
    _pUi   = _pClientObjects->_pUiObject;
    _pNl   = _pClientObjects->_pNlObject;
    _pUh   = _pClientObjects->_pUHObject;
    _pRcv  = _pClientObjects->_pRcvObject;
    _pCd   = _pClientObjects->_pCdObject;
    _pSnd  = _pClientObjects->_pSndObject;
    _pCc   = _pClientObjects->_pCcObject;
    _pIh   = _pClientObjects->_pIhObject;
    _pOr   = _pClientObjects->_pOrObject;
    _pSp   = _pClientObjects->_pSPObject;
    _pMcs  = _pClientObjects->_pMCSObject;
    _pTd   = _pClientObjects->_pTDObject;
    _pCo   = _pClientObjects->_pCoObject;
    _pClx  = _pClientObjects->_pCLXObject;
    _pLic  = _pClientObjects->_pLicObject;
    _pChan = _pClientObjects->_pChanObject;


    /************************************************************************/
    /* Initialize global data                                               */
    /************************************************************************/
    DC_MEMSET(&_SL, 0, sizeof(_SL));


    SL_CHECK_STATE(SL_EVENT_SL_INIT);

    /************************************************************************/
    /* Check parameters                                                     */
    /************************************************************************/
    TRC_ASSERT((pCallbacks != NULL), (TB, _T("Null callback list")));
    TRC_ASSERT((pCallbacks->onInitialized    != NULL),
                (TB, _T("NULL onInitialized callback")));
    TRC_ASSERT((pCallbacks->onTerminating    != NULL),
                (TB, _T("NULL onTerminating callback")));
    TRC_ASSERT((pCallbacks->onConnected      != NULL),
                (TB, _T("NULL onConnected callback")));
    TRC_ASSERT((pCallbacks->onDisconnected   != NULL),
                (TB, _T("NULL onDisconnected callback")));
    TRC_ASSERT((pCallbacks->onPacketReceived != NULL),
                (TB, _T("NULL onPacketReceived callback")));
    TRC_ASSERT((pCallbacks->onBufferAvailable  != NULL),
                (TB, _T("NULL onBufferAvailable callback")));


    /************************************************************************/
    /* Store callbacks                                                      */
    /************************************************************************/
    DC_MEMCPY(&_SL.callbacks, pCallbacks, sizeof(_SL.callbacks));

    /************************************************************************/
    /* Initialize Security stuff.  The call to SLInitSecurity will attempt  */
    /* to load the security DLL and find the required entry points.  This   */
    /* may fail - in which case we just carry on but without any            */
    /* encryption.  In either case we need to call SLInitCSUserData to set  */
    /* up the necessary user data.                                          */
    /************************************************************************/
    SLInitSecurity();
    SLInitCSUserData();

    /************************************************************************/
    /* Initialize list of callbacks to pass to NL                           */
    /************************************************************************/
    myCallbacks.onInitialized     = CSL::SL_StaticOnInitialized;
    myCallbacks.onTerminating     = CSL::SL_StaticOnTerminating;
    myCallbacks.onConnected       = CSL::SL_StaticOnConnected;
    myCallbacks.onDisconnected    = CSL::SL_StaticOnDisconnected;
    myCallbacks.onPacketReceived  = CSL::SL_StaticOnPacketReceived;
    myCallbacks.onBufferAvailable = CSL::SL_StaticOnBufferAvailable;

    SL_SET_STATE(SL_STATE_INITIALIZING);

    /************************************************************************/
    /* Initialize NL                                                        */
    /************************************************************************/
    TRC_NRM((TB, _T("Initialize NL")));
    
    _pNl->NL_Init(&myCallbacks);

    _fSLInitComplete = TRUE;

    SL_DBG_SETINFO(SL_DBG_INIT_DONE);

    /************************************************************************/
    /* Return to caller                                                     */
    /************************************************************************/
DC_EXIT_POINT:
    DC_END_FN();
    return;
} /* SL_Init */


/****************************************************************************/
/* Name:      SL_Term                                                       */
/*                                                                          */
/* Purpose:   Terminate the Security Layer                                  */
/*                                                                          */
/* Operation: Called in the Send context                                    */
/****************************************************************************/
DCVOID DCAPI CSL::SL_Term(DCVOID)
{
    DC_BEGIN_FN("SL_Term");

    SL_DBG_SETINFO(SL_DBG_TERM_CALLED);

    SL_CHECK_STATE(SL_EVENT_SL_TERM);
    SL_SET_STATE(SL_STATE_TERMINATING);

    TRC_NRM((TB, _T("Terminate NL")));
    _pNl->NL_Term();

    if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
        TSCAPI_Term(&(_SL.SLCapiData));
    }

    SL_DBG_SETINFO(SL_DBG_TERM_DONE);

DC_EXIT_POINT:
    SL_DBG_SETINFO(SL_DBG_TERM_DONE1);
    DC_END_FN();
    return;
} /* SL_Term */


/****************************************************************************/
/* Name:      SL_Connect                                                    */
/*                                                                          */
/* Purpose:   Connect to a Server                                           */
/*                                                                          */
/* Params:    bInitiateConnect - Initiate connection                        */
/*            pServerAddress - address of the Server to connect to          */
/*            transportType  - protocol type: SL_TRANSPORT_TCP              */
/*            pProtocolName  - protocol name, one of                        */
/*                             - SL_PROTOCOL_T128                           */
/*                             - Er, that's it.                             */
/*            pUserData      - user data to pass to Server Security Manager */
/*            userDataLength - length of user data                          */
/*                                                                          */
/* Operation: Called in the Send context                                    */
/****************************************************************************/
DCVOID DCAPI CSL::SL_Connect(BOOL bInitiateConnect,
                        PDCTCHAR  pServerAddress,
                        DCUINT   transportType,
                        PDCTCHAR pProtocolName,
                        PDCUINT8 pUserData,
                        DCUINT   userDataLength)
{
    DCUINT          newUserDataLength;
    PDCUINT8        pUserDataOut = NULL;
    DCBOOL          userDataAllocated = FALSE;

    DC_BEGIN_FN("SL_Connect");

    SL_DBG_SETINFO(SL_DBG_CONNECT_CALLED);

    SL_CHECK_STATE(SL_EVENT_SL_CONNECT);

    if( bInitiateConnect )
    {
        TRC_ASSERT((pServerAddress != NULL), (TB, _T("NULL Server address")));
    }

    //
    // Reset this for every connection
    //
    SL_SetEncSafeChecksumCS(FALSE);
    SL_SetEncSafeChecksumSC(FALSE);

    TRC_ASSERT((pProtocolName != NULL), (TB, _T("NULL protocol name")));
    TRC_ASSERT((DC_TSTRCMP(pProtocolName, SL_PROTOCOL_T128) == 0),
                (TB, _T("Unknown protocol %s"), pProtocolName));
    TRC_ASSERT((transportType == SL_TRANSPORT_TCP),
                (TB,_T("Illegal transport type %u"), transportType));

    if( bInitiateConnect )
    {
        TRC_NRM((TB, _T("Connect Server %s, protocol %s, %u bytes user data"),
                pServerAddress, pProtocolName, userDataLength));
    }
    else
    {
        TRC_NRM((TB, _T("Connect endpoint protocol %s, %u bytes user data"),
                pProtocolName, userDataLength));
    }


    /************************************************************************/
    /* Allocate space for all user data                                     */
    /************************************************************************/
    if (_SL.CSUserDataLength != 0)
    {
        newUserDataLength = userDataLength + _SL.CSUserDataLength;
        pUserDataOut = (PDCUINT8)UT_Malloc(_pUt, newUserDataLength);

        if (pUserDataOut == NULL)
        {
            TRC_ERR((TB, _T("Failed to alloc %u bytes for user data"),
                     newUserDataLength));

            /****************************************************************/
            /* We've not tried to connect the lower layers yet so we need   */
            /* to do no more than just decouple to the receiver thread and  */
            /* generate a onDisconnected callback.                          */
            /****************************************************************/

            _pCd->CD_DecoupleSimpleNotification(CD_RCV_COMPONENT, this,
                                          CD_NOTIFICATION_FUNC(CSL,SLIssueDisconnectedCallback),
                                          (ULONG_PTR) SL_ERR_NOMEMFORSENDUD);
            
            DC_QUIT;
        }
        TRC_NRM((TB, _T("Allocated %u bytes for user data"), newUserDataLength));
        userDataAllocated = TRUE;

        /********************************************************************/
        /* Copy user data passed by Core (if any) to new user data buffer   */
        /********************************************************************/
        if (pUserData != NULL)
        {
            TRC_NRM((TB, _T("Copy %u bytes of Core user data"), userDataLength));
            DC_MEMCPY(pUserDataOut, pUserData, userDataLength);
        }

        /********************************************************************/
        /* Copy security user data                                          */
        /********************************************************************/
        TRC_NRM((TB, _T("Copy %u bytes of security user data"),
                _SL.CSUserDataLength));
        DC_MEMCPY(pUserDataOut + userDataLength,
                  _SL.pCSUserData,
                  _SL.CSUserDataLength);
    }
    else
    {
        /********************************************************************/
        /* NO SL user data - just pass on Core data.                        */
        /********************************************************************/
        TRC_DBG((TB, _T("No SL user data")));
        newUserDataLength = userDataLength;
        pUserDataOut = pUserData;
    }

    /************************************************************************/
    /* Next state                                                           */
    /************************************************************************/
    SL_SET_STATE(SL_STATE_NL_CONNECTING);

    /************************************************************************/
    /* Call NL                                                              */
    /************************************************************************/
    if( bInitiateConnect ) 
    {
        TRC_NRM((TB, _T("Connect to %s"), pServerAddress));
    }
    else
    {
        TRC_NRM((TB, _T("Connect with end point")));
    }

    _pNl->NL_Connect(
               bInitiateConnect, // initate connection
               pServerAddress,
               transportType,
               pProtocolName,
               pUserDataOut,
               newUserDataLength);

    SL_DBG_SETINFO(SL_DBG_CONNECT_DONE);

DC_EXIT_POINT:
    /************************************************************************/
    /* Free user data (if any)                                              */
    /************************************************************************/
    if ( userDataAllocated )
    {
        TRC_NRM((TB, _T("Free user data")));
        UT_Free(_pUt, pUserDataOut);
    }

    DC_END_FN();
} /* SL_Connect */


/****************************************************************************/
/* Name:      SL_Disconnect                                                 */
/*                                                                          */
/* Purpose:   Disconnect from the Server                                    */
/*                                                                          */
/* Operation: Called in the Send context                                    */
/****************************************************************************/
DCVOID DCAPI CSL::SL_Disconnect(DCVOID)
{
    DC_BEGIN_FN("SL_Disconnect");

    SL_DBG_SETINFO(SL_DBG_DISCONNECT_CALLED);

    SL_CHECK_STATE(SL_EVENT_SL_DISCONNECT);

    SL_DBG_SETINFO(SL_DBG_DISCONNECT_DONE1);

DC_EXIT_POINT:
    /************************************************************************/
    /* Regardless of the outcome of the state check we want to try and      */
    /* disconnect - so always call NL_Disconnect.                           */
    /************************************************************************/
    TRC_NRM((TB, _T("Disconnect from Server")));
    SL_SET_STATE(SL_STATE_DISCONNECTING);
    _pNl->NL_Disconnect();

    SL_DBG_SETINFO(SL_DBG_DISCONNECT_DONE2);

    DC_END_FN();
} /* SL_Disconnect */


/****************************************************************************/
/* Name:      SL_SendPacket                                                 */
/*                                                                          */
/* Purpose:   Send a packet                                                 */
/*                                                                          */
/* Params:    pData        - pointer to data to send (buffer returned by    */
/*                           SL_GetBuffer())                                */
/*            dataLen      - length of data to send (excluding security     */
/*                           header)                                        */
/*            flags        - zero or more of the RNS_SEC flags              */
/*            bufHandle    - buffer handle returned by SL_GetBuffer()       */
/*            userID       - MCS user ID                                    */
/*            channel      - channel ID to send data on                     */
/*            priority     - priority of data - one of                      */
/*                           - TS_LOWPRIORITY                               */
/*                           - TS_MEDPRIORITY                               */
/*                           - TS_HIGHPRIORITY                              */
/*                                                                          */
/* Operation: Note that the contents of the packet are changed by this      */
/*            function.                                                     */
/*                                                                          */
/*            Called in the Send context                                    */
/****************************************************************************/
DCVOID DCAPI CSL::SL_SendPacket(PDCUINT8   pData,
                           DCUINT     dataLen,
                           DCUINT     flags,
                           SL_BUFHND  bufHandle,
                           DCUINT     userID,
                           DCUINT     channel,
                           DCUINT     priority)
{
    DCBOOL rc = FALSE;

    DC_BEGIN_FN("SL_SendPacket");

    SL_CHECK_STATE(SL_EVENT_SL_SENDPACKET);

    /************************************************************************/
    /* Check if we're encrypting this message                               */
    /************************************************************************/
    if (_SL.encrypting ||
            (flags & RNS_SEC_INFO_PKT) ||
            (flags & RNS_SEC_LICENSE_PKT))
    {
        TRC_DBG((TB, _T("Encrypting")));

        if (_SL.encrypting && (flags & RNS_SEC_ENCRYPT))
        {
            PRNS_SECURITY_HEADER1   pSecHeader1;
            PRNS_SECURITY_HEADER2   pSecHeader2;

            TRC_DBG((TB, _T("Encrypt this message")));

            if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
                pSecHeader2 = (PRNS_SECURITY_HEADER2)
                    (pData - sizeof(RNS_SECURITY_HEADER2));
                pSecHeader2->padlen = TSCAPI_AdjustDataLen(dataLen) - dataLen;
                pSecHeader2->length = sizeof(RNS_SECURITY_HEADER2);
                pSecHeader2->version =  TSFIPS_VERSION1;
            }
            else {
                pSecHeader1 = (PRNS_SECURITY_HEADER1)
                    (pData - sizeof(RNS_SECURITY_HEADER1));
            }

            /****************************************************************/
            /* check to see we need to update the session key.              */
            /****************************************************************/
            if( _SL.encryptCount == UPDATE_SESSION_KEY_COUNT ) {
                TRC_ALT((TB, _T("Update Encrypt Session Key, Count=%d"),
                        _SL.encryptCount));
                rc = TRUE;
                // Don't need to update the session key if using FIPS
                if (_SL.encryptionMethodSelected != SM_FIPS_ENCRYPTION_FLAG) {
                    rc = UpdateSessionKey(
                            _SL.startEncryptKey,
                            _SL.currentEncryptKey,
                            _SL.encryptionMethodSelected,
                            _SL.keyLength,
                            &_SL.rc4EncryptKey,
                            _SL.encryptionLevel);
                }
                if (rc) {
                    // Reset counter.
                    _SL.encryptCount = 0;
                }
                else {
                    TRC_ERR((TB, _T("SL failed to update session key")));
                    DC_QUIT;
                }
            }

            TRC_ASSERT((_SL.encryptCount < UPDATE_SESSION_KEY_COUNT),
                (TB, _T("Invalid encrypt count")));

            TRC_DATA_DBG("Data buffer before encryption", pData, dataLen);

            if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
                DWORD dataLenTemp;

                dataLenTemp = dataLen;
                rc = TSCAPI_EncryptData(
                        &(_SL.SLCapiData),
                        pData,
                        &dataLenTemp,
                        dataLen + pSecHeader2->padlen,
                        (LPBYTE)pSecHeader2->dataSignature,
                        _SL.totalEncryptCount);
            }
            else {
                rc = EncryptData(
                        _SL.encryptionLevel,
                        _SL.currentEncryptKey,
                        &_SL.rc4EncryptKey,
                        _SL.keyLength,
                        pData,
                        dataLen,
                        _SL.macSaltKey,
                        (LPBYTE)pSecHeader1->dataSignature,
                        SL_GetEncSafeChecksumCS(),
                        _SL.totalEncryptCount);
            }
            if (rc) {
                TRC_DBG((TB, _T("Data encrypted")));
                TRC_DATA_DBG("Data buffer after encryption", pData, dataLen);

                // Increment the encryption counter.
                _SL.encryptCount++;
                _SL.totalEncryptCount++;

                if (SL_GetEncSafeChecksumCS()) {
                    flags |= RDP_SEC_SECURE_CHECKSUM;
                }

                // Message encrypted successfully.  Set up security header and
                // NL data pointer and length.
                if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
                    pSecHeader2->flags = (DCUINT16)flags;

                    pData = (PDCUINT8)pSecHeader2;
                    dataLen += (sizeof(RNS_SECURITY_HEADER2) + pSecHeader2->padlen);
                }
                else {
                    pSecHeader1->flags = (DCUINT16)flags;

                    pData = (PDCUINT8)pSecHeader1;
                    dataLen += sizeof(RNS_SECURITY_HEADER1);
                }
            }
            else {
                TRC_ERR((TB, _T("SM failed to encrypt data")));

                //
                // This call is made on the Send thread so there is no need
                // to trigger an immediate disconnect with SL_DropLinkImmediate
                //
                SLSetReasonAndDisconnect(SL_ERR_ENCRYPTFAILED);
                DC_QUIT;
            }
        }
        else
        {
            PRNS_SECURITY_HEADER pSecHeader;

            /****************************************************************/
            /* Packet not encrypted - send flags, but not the signature.    */
            /****************************************************************/
            pSecHeader = (PRNS_SECURITY_HEADER)
                    (pData - sizeof(RNS_SECURITY_HEADER));

            /****************************************************************/
            /* setup security headers and NL data pointer and length        */
            /****************************************************************/
            pSecHeader->flags = (DCUINT16)flags;
            pData = (PDCUINT8)pSecHeader;
            dataLen += sizeof(RNS_SECURITY_HEADER);
            TRC_DATA_DBG("Send unencrypted data", pData, dataLen);
        }
    }

    /************************************************************************/
    /* Trace out parameters and send the packet.                            */
    /************************************************************************/
    TRC_DBG((TB, _T("Send buf:%p len:%u flags:%#x handle:%#x userID:%u chan:%u")
                 _T("pri:%u"),
                 pData,
                 dataLen,
                 flags,
                 bufHandle,
                 userID,
                 channel,
                 priority));

    //NL_SendPacket is a macro to an MCS function.
    _pMcs->NL_SendPacket(pData,
                  dataLen,
                  flags,
                  bufHandle,
                  userID,
                  channel,
                  priority);

    /************************************************************************/
    /* No state change                                                      */
    /************************************************************************/

DC_EXIT_POINT:
    DC_END_FN();
} /* SL_SendPacket */


/****************************************************************************/
// SL_SendFastPathInputPacket
//
// Encrypts and assembles the security information and the final header
// format for a fast-path input packet before sending to TD. See at128.h for
// the fast-path input packet format.
/****************************************************************************/
void DCAPI CSL::SL_SendFastPathInputPacket(
        BYTE FAR *pData,
        unsigned PktLen,
        unsigned NumEvents,
        SL_BUFHND bufHandle)
{
    DCBOOL rc;
    unsigned flags;
    DWORD dataLenTemp;
    PBYTE pDataSignature;
    DCUINT8 *pPadLen;

    DC_BEGIN_FN("SL_SendFastPathInputPacket");

    SL_CHECK_STATE(SL_EVENT_SL_SENDPACKET);

    // We're encrypting if encyption enabled on this link.
    if (_SL.encrypting) {
        // Check to see we need to update the session key.
        if (_SL.encryptCount == UPDATE_SESSION_KEY_COUNT) {
            TRC_ALT((TB, _T("Update Encrypt Session Key, Count=%d"),
                    _SL.encryptCount));
            rc = TRUE;
            // Don't need to update the session key if using FIPS
            if (_SL.encryptionMethodSelected != SM_FIPS_ENCRYPTION_FLAG) {
                rc = UpdateSessionKey(
                    _SL.startEncryptKey,
                    _SL.currentEncryptKey,
                    _SL.encryptionMethodSelected,
                    _SL.keyLength,
                    &_SL.rc4EncryptKey,
                    _SL.encryptionLevel);
            }
            if (rc) {
                // Reset counter.
                _SL.encryptCount = 0;
            }
            else {
                TRC_ERR((TB, _T("SL failed to update session key")));
                DC_QUIT;
            }
        }

        TRC_ASSERT((_SL.encryptCount < UPDATE_SESSION_KEY_COUNT),
            (TB, _T("Invalid encrypt count")));

        // We encrypt into the DATA_SIGNATURE_SIZE bytes immediately before
        // the packet data. Unlike the regular send path, we don't waste 4
        // extra bytes in an RNS_SECURITY_HEADER1 to contain the 'encrypted'
        // bit.
        if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            

            dataLenTemp = PktLen;
            pDataSignature = pData - MAX_SIGN_SIZE;
            pPadLen = (DCUINT8 *)(pDataSignature - sizeof(DCUINT8));
            *pPadLen = (DCUINT8)(TSCAPI_AdjustDataLen(PktLen) - PktLen);

            rc = TSCAPI_EncryptData(
                    &(_SL.SLCapiData),
                    pData,
                    &dataLenTemp,
                    PktLen + *pPadLen,
                    pDataSignature,
                    _SL.totalEncryptCount);
        }
        else {
            rc = EncryptData(
                    _SL.encryptionLevel,
                    _SL.currentEncryptKey,
                    &_SL.rc4EncryptKey,
                    _SL.keyLength,
                    pData,
                    PktLen,
                    _SL.macSaltKey,
                    pData - DATA_SIGNATURE_SIZE,
                    SL_GetEncSafeChecksumCS(),
                    _SL.totalEncryptCount);
        }
        if (rc) {
            // Increment the encryption counter.
            _SL.encryptCount++;
            _SL.totalEncryptCount++;
            flags = TS_INPUT_FASTPATH_ENCRYPTED;
            if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
                pData -= (sizeof(RNS_SECURITY_HEADER2) - 4);
                PktLen += (sizeof(RNS_SECURITY_HEADER2) - 4 + *pPadLen);
            }
            else {
                pData -= DATA_SIGNATURE_SIZE;
                PktLen += DATA_SIGNATURE_SIZE;
            }
            TRC_DBG((TB, _T("Data encrypted")));
        }
        else {

            //
            // This call is made on the Send thread so there is no need
            // to trigger an immediate disconnect with SL_DropLinkImmediate
            //
            SLSetReasonAndDisconnect(SL_ERR_ENCRYPTFAILED);
            TRC_ERR((TB, _T("SM failed to encrypt data")));
            DC_QUIT;
        }
    }
    else {
        // No encryption flag.
        flags = 0;
    }

    // Now prepend the fast-path header (2 or 3 bytes, see at128.h).
    // Work backwards from where we are: First, the total packet length
    // including the header.
    if (PktLen <= 125) {
        // 1-byte form of length, high bit 0.
        PktLen += 2;
        pData -= 2;
        *(pData + 1) = (BYTE)PktLen;
    }
    else {
        // 2-byte form of length, first byte has high bit 1 and 7 most
        // significant bits.
        PktLen += 3;
        pData -= 3;
        *(pData + 1) = (BYTE)(0x80 | ((PktLen & 0x7F00) >> 8));
        *(pData + 2) = (BYTE)(PktLen & 0xFF);
    }

    // The header byte.
    *pData = (BYTE)(flags | (NumEvents << 2));

    //
    // Flag if the packet has a checksum of encrypted bytes
    //
    if (SL_GetEncSafeChecksumCS()) {
        *pData |= TS_INPUT_FASTPATH_SECURE_CHECKSUM;
    }

    // Direct-send the packet through the transport, no more parsing needed.
    _pTd->TD_SendBuffer(pData, PktLen, bufHandle);

DC_EXIT_POINT:
    DC_END_FN();
}


#ifdef DC_DEBUG
/****************************************************************************/
/* Name:      SL_GetBufferDbg                                               */
/*                                                                          */
/* Purpose:   Get a send buffer (debug version)                             */
/*                                                                          */
/* Returns:   see SL_GetBufferRtl                                           */
/*                                                                          */
/* Params:    see SL_GetBufferRtl                                           */
/*            pCaller - name of calling function                            */
/****************************************************************************/
DCBOOL DCAPI CSL::SL_GetBufferDbg(DCUINT     dataLen,
                             PPDCUINT8  ppBuffer,
                             PSL_BUFHND pBufHandle,
                             PDCTCHAR   pCaller)
{
    DCBOOL bRc;
    DC_BEGIN_FN("SL_GetBufferDbg");

    /************************************************************************/
    /* First get a buffer                                                   */
    /************************************************************************/
    bRc = SL_GetBufferRtl(dataLen, ppBuffer, pBufHandle);

    /************************************************************************/
    /* If that worked, set its owner                                        */
    /************************************************************************/
    if (bRc)
    {
        TRC_NRM((TB, _T("Buffer allocated - set its owner")));
        _pTd->TD_SetBufferOwner(*pBufHandle, pCaller);
    }

    DC_END_FN();
    return(bRc);
} /* SL_GetBufferDbg */
#endif /* DC_DEBUG */


/****************************************************************************/
/* Name:      SL_GetBufferRtl                                               */
/*                                                                          */
/* Purpose:   Get a send buffer (retail version)                            */
/*                                                                          */
/* Returns:   TRUE  - buffer available                                      */
/*            FALSE - buffer not available                                  */
/*                                                                          */
/* Params:    dataLen    - Size of buffer required                          */
/*            pBuffer    - Pointer to the returned buffer                   */
/*            pBufHandle - Pointer to the buffer handle                     */
/****************************************************************************/
DCBOOL DCAPI CSL::SL_GetBufferRtl(DCUINT     dataLen,
                             PPDCUINT8  ppBuffer,
                             PSL_BUFHND pBufHandle)
{
    DCBOOL   rc = FALSE;
    DCUINT   myLen;
    PDCUINT8 myBuffer;
    DCUINT   headerLen;
    DCUINT   newDataLen;
    PRNS_SECURITY_HEADER2 pSecHeader2;

    DC_BEGIN_FN("SL_GetBufferRtl");

    SL_CHECK_STATE(SL_EVENT_SL_GETBUFFER);

    /************************************************************************/
    /* Adjust requested length to account for SL header                     */
    /************************************************************************/
    if (_SL.encrypting)
    {
        if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            // If FIPS is used, 
            // it must have room for an extra block
            headerLen = sizeof(RNS_SECURITY_HEADER2);
            newDataLen = TSCAPI_AdjustDataLen(dataLen);
            myLen = newDataLen + headerLen;        
        }
        else {
            headerLen = sizeof(RNS_SECURITY_HEADER1);
            myLen = dataLen + headerLen;
        }
        TRC_DBG((TB, _T("Ask NL for %d (was %d) bytes"), myLen, dataLen));
    }
    else
    {
        myLen = dataLen;
        headerLen = 0;
        TRC_DBG((TB, _T("Not encrypting, ask NL for %d bytes"), myLen));
    }

    /************************************************************************/
    /* Get buffer from NL                                                   */
    /************************************************************************/
    rc = _pMcs->NL_GetBuffer(myLen, &myBuffer, pBufHandle);
    if (rc)
    {
        /********************************************************************/
        /* Adjust buffer pointer to account for SL header                   */
        /********************************************************************/
        *ppBuffer = myBuffer + headerLen;

        // Since FIPS need extra block, fill in the padding size
        if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            pSecHeader2 = (PRNS_SECURITY_HEADER2)myBuffer;
            pSecHeader2->padlen = newDataLen - dataLen;
        }

        /********************************************************************/
        /* Assert that NL has returned a correctly aligned buffer.          */
        /********************************************************************/
        TRC_ASSERT(((ULONG_PTR)(*ppBuffer) % 4 == 2),
                   (TB, _T("non-aligned buffer")));
    }
    TRC_DBG((TB, _T("Return buffer %p (was %p), rc %d"),
            *ppBuffer, myBuffer, rc));

    /************************************************************************/
    /* Return to caller                                                     */
    /************************************************************************/
DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
} /* SL_GetBufferRtl */


/****************************************************************************/
/* Name:      SL_FreeBuffer                                                 */
/*                                                                          */
/* Purpose:   Frees a buffer previously allocated.                          */
/*                                                                          */
/* Params:    IN  pBufHandle - pointer to the buffer handle.                */
/****************************************************************************/
DCVOID DCAPI CSL::SL_FreeBuffer(SL_BUFHND bufHandle)
{
    DC_BEGIN_FN("SL_FreeBuffer");

    /************************************************************************/
    /* Just call onto the NL equivalent.                                    */
    /************************************************************************/
    _pMcs->NL_FreeBuffer((NL_BUFHND) bufHandle);

    DC_END_FN();
} /* SL_FreeBuffer */


/****************************************************************************/
/* Name:      SL_SendSecurityPacket                                         */
/*                                                                          */
/* Purpose:   Sends a security packet in the Send context                   */
/*                                                                          */
/* Params:    pData      - data from Receive context (packet to send)       */
/*            dataLength - length of data passed                            */
/****************************************************************************/
DCVOID DCAPI CSL::SL_SendSecurityPacket(PDCVOID pData, DCUINT dataLength)
{
    DCBOOL rc;
    PDCUINT8 pBuffer;
    SL_BUFHND bufHnd;

    DC_BEGIN_FN("SL_SendSecurityPacket");

    /************************************************************************/
    /* Get a buffer from NL                                                 */
    /************************************************************************/
    rc = _pMcs->NL_GetBuffer(dataLength, &pBuffer, &bufHnd);

    /************************************************************************/
    /* We don't expect this getBuffer to fail.  However, it can do so in    */
    /* the following scenario.                                              */
    /* - SLSendSecurityPacket decouples to SL_SendSecurityPacket.           */
    /* - Session is disconnected.                                           */
    /* - CD calls SL_SendSecurityPacket.                                    */
    /************************************************************************/
    if (!rc)
    {
        TRC_ERR((TB, _T("Failed to alloc buffer for security packet, state %d"),
                _SL.state));
        DC_QUIT;
    }

    /************************************************************************/
    /* Send the packet                                                      */
    /************************************************************************/
    DC_MEMCPY(pBuffer, pData, dataLength);
    TRC_NRM((TB, _T("Send security exchange packet")));
    _pMcs->NL_SendPacket(pBuffer,
                  dataLength,
                  0,
                  bufHnd,
                  _pUi->UI_GetClientMCSID(),
                  _SL.channelID,
                  TS_HIGHPRIORITY);

DC_EXIT_POINT:
    DC_END_FN();
}


/****************************************************************************/
/* Name:      SL_SendSecInfoPacket                                          */
/*                                                                          */
/* Purpose:   Sends an rns info pkt in the Send context                     */
/*                                                                          */
/* Params:    pData      - data from Receive context (packet to send)       */
/*            dataLength - length of data passed                            */
/****************************************************************************/
DCVOID DCAPI CSL::SL_SendSecInfoPacket(PDCVOID pData, DCUINT dataLen)
{
    PDCUINT8    pBuffer;
    SL_BUFHND   BufHandle;
    DCUINT      headerLen, newDataLen, TotalDataLen;
    PRNS_SECURITY_HEADER2 pSecHeader2;

    DC_BEGIN_FN("SL_SendSecInfoPacket");

    /************************************************************************/
    /* Adjust requested length to account for SL header and                 */
    /* get the buffer from NL                                               */
    /************************************************************************/

    if (_SL.encrypting)
    {
        if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
            // If FIPS is used, 
            // it must have room for an extra block
            headerLen = sizeof(RNS_SECURITY_HEADER2);
            newDataLen = TSCAPI_AdjustDataLen(dataLen);
            TotalDataLen = newDataLen + headerLen;         
        }
        else {
            headerLen = sizeof(RNS_SECURITY_HEADER1);
            TotalDataLen = dataLen + headerLen;
        }
    }
    else {
        headerLen = sizeof(RNS_SECURITY_HEADER);
        TotalDataLen = dataLen + headerLen;
    }

    if (!_pMcs->NL_GetBuffer(TotalDataLen, &pBuffer, &BufHandle))
    {
        TRC_ALT((TB, _T("Failed to get SendSecInfoPacket buffer")));
        DC_QUIT;
    }

    // Since FIPS need extra block, fill in the padding size
    if (_SL.encryptionMethodSelected == SM_FIPS_ENCRYPTION_FLAG) {
        pSecHeader2 = (PRNS_SECURITY_HEADER2)pBuffer;
        pSecHeader2->padlen = newDataLen - dataLen;
    }
    /********************************************************************/
    /* Adjust buffer pointer to account for SL header                   */
    /********************************************************************/
    pBuffer += headerLen;

    DC_MEMCPY(pBuffer, pData, dataLen);

    SL_SendPacket(pBuffer,
                  dataLen,
                  RNS_SEC_ENCRYPT | RNS_SEC_INFO_PKT,
                  BufHandle,
                  _pUi->UI_GetClientMCSID(),
                  _SL.channelID,
                  TS_HIGHPRIORITY);

DC_EXIT_POINT:
    DC_END_FN();
}


/****************************************************************************/
/* Name:      SL_EnableEncryption                                           */
/*                                                                          */
/* Purpose:   Enables or disables encryption                                */
/*                                                                          */
/* Params: enableEncryption - IN - flag indicating whether encryption       */
/*                                 should be on or off                      */
/*                                 0 - disabled                             */
/*                                 1 - enabled                              */
/****************************************************************************/
DCVOID DCAPI CSL::SL_EnableEncryption(ULONG_PTR enableEncryption)
{
    DC_BEGIN_FN("SL_EnableEncryption");

    /************************************************************************/
    /* @@@ ENH 13.8.97 Need to do something with this notification          */
    /************************************************************************/
    _SL.encryptionEnabled = (DCBOOL) enableEncryption;

    DC_END_FN();
} /* SL_EnableEncryption */

//
// SL_DropLinkImmediate
//
// Purpose: Immediately drops the link without doing a gracefull connection
//          shutdown (i.e. no DPUm is sent and we don't transition to the SND
//          thread at any point before dropping the link). Higher level components
//          will still get all the usual disconnect notifications so they can
//          be properly torn down.
//
//          This call was added to trigger an immediate disconnect in cases
//          where we detect invalid data that could be due to an attack, it
//          ensures we won't receive any more data after the call returns
//
// Params:  reason - SL disconnect reason code
//
// Returns: HRESULT
// 
// Thread context: Call on RCV thread
//
HRESULT
CSL::SL_DropLinkImmediate(UINT reason)
{
    HRESULT hr = E_FAIL;
    DC_BEGIN_FN("SL_DropLinkImmediate");

    TRC_NRM((TB, _T("Setting disconnect error code from %u->%u"),
             _SL.disconnectErrorCode,
             SL_MAKE_DISCONNECT_ERR(reason)));

    // Check that the disconnectErrorCode has not already been set and then
    // set it.
    if (0 != _SL.disconnectErrorCode) {
        TRC_ERR((TB, _T("Disconnect error code has already been set! Was %u"),
                     _SL.disconnectErrorCode));
    }
    _SL.disconnectErrorCode = SL_MAKE_DISCONNECT_ERR(reason);


    TRC_ALT((TB,_T("Triggering immediate drop link")));

    _pTd->TD_DropLink();
    hr = S_OK;

    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\sp.h ===
/**INC+**********************************************************************/
/* Header:    sp.h                                                          */
/*                                                                          */
/* Purpose:   Sound Player Class                                            */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#ifndef _H_SP
#define _H_SP

#include "objs.h"


class CSP
{
public:
    CSP(CObjs* objs);
    ~CSP();

public:
    //
    // API functions
    //

    DCVOID DCAPI SP_Init(DCVOID);
    DCVOID DCAPI SP_Term(DCVOID);
    
    HRESULT DCAPI SP_OnPlaySoundPDU(PTS_PLAY_SOUND_PDU_DATA pPlaySoundPDU,
        DCUINT);



private:
    //
    // Internal functions
    //
    #include <wspint.h>
private:
    CObjs* _pClientObjects;
    
};


#endif // _H_SP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\sndapi.cpp ===
/****************************************************************************/
// sndapi.cpp
//
// Sender thread functions.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "sndapi"
#include <atrcapi.h>
}

#include "snd.h"
#include "cd.h"
#include "cc.h"
#include "aco.h"
#include "fs.h"
#include "ih.h"
#include "sl.h"
#include "or.h"
#include "uh.h"


CSND::CSND(CObjs* objs)
{
    _pClientObjects = objs;
    _fSNDInitComplete = FALSE;
}

CSND::~CSND()
{
}


#ifdef OS_WIN32
/****************************************************************************/
/* Name:      SND_Main                                                      */
/*                                                                          */
/* Purpose:   Sender Thread entry point                                     */
/*                                                                          */
/* Operation: call SND_Init, run the message dispatch loop, call SND_Term   */
/****************************************************************************/
void DCAPI CSND::SND_Main()
{
    MSG msg;

    DC_BEGIN_FN("SND_Main");

    TRC_NRM((TB, _T("Sender Thread initialization")));

    TRC_ASSERT(_pClientObjects, (TB,_T("_pClientObjects is NULL")));
    _pClientObjects->AddObjReference(SND_OBJECT_FLAG);
    
    //Setup local object pointers
    _pCd  = _pClientObjects->_pCdObject;
    _pCc  = _pClientObjects->_pCcObject;
    _pIh  = _pClientObjects->_pIhObject;
    _pOr  = _pClientObjects->_pOrObject;
    _pCo  = _pClientObjects->_pCoObject;
    _pFs  = _pClientObjects->_pFsObject;
    _pSl  = _pClientObjects->_pSlObject;
    _pUh  = _pClientObjects->_pUHObject;

    SND_Init();


    TRC_NRM((TB, _T("Start Sender Thread message loop")));
    while (GetMessage (&msg, NULL, 0, 0))
    {
        /********************************************************************/
        /* Note that TranslateMessage is called here, even though IH only   */
        /* processes raw WM_KEYUP/DOWN events, not WM_CHAR.  This is        */
        /* required to enable the keyboard indicator lights to work on      */
        /* Windows 95.                                                      */
        /* Note that on Win16 the single global message loop contains       */
        /* TranslateMessage().                                              */
        /********************************************************************/
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    TRC_NRM((TB, _T("Exit Sender Thread message loop")));
    SND_Term();

    // This is the end of the Sender Thread.
    TRC_NRM((TB, _T("Sender Thread terminates")));

    DC_END_FN();
} /* SND_Main */
#endif /* OS_WIN32 */


/****************************************************************************/
/* Name:      SND_Init                                                      */
/*                                                                          */
/* Purpose:   Initialize Sender Thread                                      */
/****************************************************************************/
void DCAPI CSND::SND_Init()
{
    SL_CALLBACKS callbacks;

    DC_BEGIN_FN("SND_Init");

    // Register with CD, to receive messages.
    _pCd->CD_RegisterComponent(CD_SND_COMPONENT);

    // Initialize Sender Thread components.
    _pCc->CC_Init();
    _pIh->IH_Init();
    _pOr->OR_Init();

    // Font Sender may take a long time, unless multi-threaded.
    _pFs->FS_Init();

    // Initialize the Network Layer.  Pass in the Core callback functions
    // required.
    callbacks.onInitialized     = CCO::CO_StaticOnInitialized;
    callbacks.onTerminating     = CCO::CO_StaticOnTerminating;
    callbacks.onConnected       = CCO::CO_StaticOnConnected;
    callbacks.onDisconnected    = CCO::CO_StaticOnDisconnected;
    callbacks.onPacketReceived  = CCO::CO_StaticOnPacketReceived;
    callbacks.onBufferAvailable = CCO::CO_StaticOnBufferAvailable;
    _pSl->SL_Init(&callbacks);

    _fSNDInitComplete = TRUE;

DC_EXIT_POINT:
    DC_END_FN();
} /* SND_Init */


/****************************************************************************/
/* Name:      SND_BufferAvailable                                           */
/*                                                                          */
/* Purpose:   Call Send components BufferAvailable functions                */
/****************************************************************************/
void DCAPI CSND::SND_BufferAvailable(ULONG_PTR unusedParam)
{
    DC_BEGIN_FN("SND_BufferAvailable");

    DC_IGNORE_PARAMETER(unusedParam);

    // We used to call FS_BufferAvailable here.  But now we send a zero font
    // PDU from UH.  So FS_BufferAvailable is no longer needed.  We need
    // UH_BufferAvailable because we might have to send multiple Persistent
    // Key list PDUs.
    _pUh->UH_BufferAvailable();

    _pIh->IH_BufferAvailable();

    _pCc->CC_Event(CC_EVT_API_ONBUFFERAVAILABLE);

    DC_END_FN();
} /* SND_BufferAvailable */


/****************************************************************************/
/* Name:      SND_Term                                                      */
/*                                                                          */
/* Purpose:   Terminate the Sender Thread                                   */
/****************************************************************************/
void DCAPI CSND::SND_Term()
{
    DC_BEGIN_FN("SND_Term");

    if(_fSNDInitComplete)
    {
        // Terminate the Network Layer.
        _pSl->SL_Term();
    
        // Terminate the Sender thread components.
        // We use glyphs instead of fonts for text. So FS code becomes obsolete
        // now. FS_Term is an empty function now. We keep it here to make this
        // function symmetrical to FS_Init since we still need that one.
        _pFs->FS_Term();
    
        _pOr->OR_Term();
        _pIh->IH_Term();
        _pCc->CC_Term();
    
        // Unregister with CD.
        _pCd->CD_UnregisterComponent(CD_SND_COMPONENT);
    
        _pClientObjects->ReleaseObjReference(SND_OBJECT_FLAG);
    }

    DC_END_FN();
} /* SND_Term */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\td.h ===
/****************************************************************************/
// td.h
//
// Transport driver - portable API.
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/

#ifndef _H_TD
#define _H_TD

extern "C" {
#ifdef OS_WINCE
#include <winsock.h>
#include <wsasync.h>
#endif
#include <adcgdata.h>
}

#include "objs.h"
#include "cd.h"

#define TRC_FILE "td"
#define TRC_GROUP TRC_GROUP_NETWORK

/****************************************************************************/
/* Define the TD buffer handle type.                                        */
/****************************************************************************/
typedef ULONG_PTR          TD_BUFHND;
typedef TD_BUFHND   DCPTR PTD_BUFHND;


//
// Internal
//

/****************************************************************************/
/* FSM inputs.                                                              */
/****************************************************************************/
#define TD_EVT_TDINIT                0
#define TD_EVT_TDTERM                1
#define TD_EVT_TDCONNECT_IP          2
#define TD_EVT_TDCONNECT_DNS         3
#define TD_EVT_TDDISCONNECT          4
#define TD_EVT_WMTIMER               5
#define TD_EVT_OK                    6
#define TD_EVT_ERROR                 7
#define TD_EVT_CONNECTWITHENDPOINT   8
#define TD_EVT_DROPLINK              9

#define TD_FSM_INPUTS                10


/****************************************************************************/
/* FSM state definitions.                                                   */
/****************************************************************************/
#define TD_ST_NOTINIT                0
#define TD_ST_DISCONNECTED           1
#define TD_ST_WAITFORDNS             2
#define TD_ST_WAITFORSKT             3
#define TD_ST_CONNECTED              4
#define TD_ST_WAITFORCLOSE           5

#define TD_FSM_STATES                6


/****************************************************************************/
/* Send buffer sizes for the private and public queues.  These must be      */
/* sorted in order of increasing size.  Note that the buffer sizes are      */
/* chosen to minimize the runtime working set - under normal circumstances  */
/* only the two 2000 byte public buffers will be in-use, consuming 1 page   */
/* of memory.                                                               */
/*                                                                          */
/* The two 4096-byte public buffers are provided to support virtual channel */
/* data.  If VCs are not in use, these buffers are unlikely to be used.     */
/*                                                                          */
/* NOTE: The constant TD_SNDBUF_PUBNUM must reflect the number of           */
/*       buffers in the TD_SNDBUF_PUBSIZES array.                           */
/*       Similarily TD_SNDBUF_PRINUM must reflect the number of buffers in  */
/*       the TD_SNDBUF_PRISIZES array.                                      */
/****************************************************************************/
#define TD_SNDBUF_PUBSIZES           {2000, 2000, 4096, 4096}
#define TD_SNDBUF_PUBNUM             4

#define TD_SNDBUF_PRISIZES           {1024, 512}
#define TD_SNDBUF_PRINUM             2


/****************************************************************************/
/* Limited broadcast address.                                               */
/****************************************************************************/
#define TD_LIMITED_BROADCAST_ADDRESS "255.255.255.255"


/****************************************************************************/
/* Maximum number of bytes TD will receive on a single FD_READ              */
/****************************************************************************/
#define TD_MAX_UNINTERRUPTED_RECV (16 * 1024)


// Number of bytes to allocate to the recv buffer.
//
// The recv buffer size should be as large as the largest typical server
// OUTBUF that will come our way (8K minus a bit). Most recv()
// implementations try to copy all the data for a TCP sequence (an entire
// OUTBUF) into the target buffer, if the space is available. This means
// that, for code that can access an unaligned data stream, we can use the
// data bytes straight out of the TD receive buffer most of the time, saving
// a large memcpy to an aligned reassembly buffer.
//
// NOTE: Because of Win2000 bug 392510, we alloc a full 8K but only use
// (8K - 2 bytes) because the MPPC decompression code in core\compress.c
// does not stay within the source data buffer boundary.
#define TD_RECV_BUFFER_SIZE 8192


/****************************************************************************/
/* Macro to trace out all the send buffers and the contents of the send     */
/* queue.  This is used when a send-buffer error occurs.                    */
/****************************************************************************/
#if defined(DC_DEBUG) && (TRC_COMPILE_LEVEL < TRC_LEVEL_DIS)
#define TD_TRACE_SENDINFO(level)                                             \
{                                                                            \
    TD_TRACE_SENDBUFS(level, _TD.pubSndBufs, TD_SNDBUF_PUBNUM, "Pub");        \
    TD_TRACE_SENDBUFS(level, _TD.priSndBufs, TD_SNDBUF_PRINUM, "Pri");        \
    TD_TRACE_SENDQUEUE(level);                                               \
}

#define TD_TRACE_SENDBUFS(level, queue, numBufs, pText)                      \
{                                                                            \
    DCUINT i;                                                                \
    for (i = 0; i < numBufs; i++)                                            \
    {                                                                        \
        TRCX(level, (TB, _T("%sQ[%u] <%p> pNxt:%p iU:%s ")                       \
                         "size:%u pBuf:%p bLTS:%u pDLTS:%p owner %s",        \
                         pText,                                              \
                         i,                                                  \
                         &queue[i],                                          \
                         queue[i].pNext,                                     \
                         queue[i].inUse ? "T" : "F",                         \
                         queue[i].size,                                      \
                         queue[i].pBuffer,                                   \
                         queue[i].bytesLeftToSend,                           \
                         queue[i].pDataLeftToSend,                           \
                         queue[i].pOwner));                                  \
    }                                                                        \
}

#define TD_TRACE_SENDQUEUE(level)                                            \
{                                                                            \
    PTD_SNDBUF_INFO pBuf;                                                    \
    DCUINT          i = 0;                                                   \
                                                                             \
    pBuf = _TD.pFQBuf;                                                        \
    if (NULL == pBuf)                                                        \
    {                                                                        \
        TRCX(level, (TB, _T("SendQ is empty")));                                 \
    }                                                                        \
    else                                                                     \
    {                                                                        \
        while (NULL != pBuf)                                                 \
        {                                                                    \
            TRCX(level, (TB, _T("SendQ[%u] <%p> pNxt:%p size:%u bLTS:%u"),       \
                             i,                                              \
                             pBuf,                                           \
                             pBuf->pNext,                                    \
                             pBuf->size,                                     \
                             pBuf->bytesLeftToSend));                        \
            pBuf = pBuf->pNext;                                              \
        }                                                                    \
        TRCX(level, (TB, _T("End of send queue")));                              \
    }                                                                        \
}
#else // defined(DC_DEBUG) && (TRC_COMPILE_LEVEL < TRC_LEVEL_DIS)
#define TD_TRACE_SENDINFO(level)
#endif // defined(DC_DEBUG) && (TRC_COMPILE_LEVEL < TRC_LEVEL_DIS)

/****************************************************************************/
/* Structure:   TD_SNDBUF_INFO                                              */
/*                                                                          */
/* Description: Contains information about a TD send buffer.                */
/****************************************************************************/
typedef struct tagTD_SNDBUF_INFO DCPTR PTD_SNDBUF_INFO;

typedef struct tagTD_SNDBUF_INFO
{
    PTD_SNDBUF_INFO pNext;
    DCBOOL          inUse;
    DCUINT          size;
    PDCUINT8        pBuffer;
    DCUINT          bytesLeftToSend;
    PDCUINT8        pDataLeftToSend;
#ifdef DC_DEBUG
    PDCTCHAR        pOwner;
#endif
} TD_SNDBUF_INFO;


/****************************************************************************/
/* Structure:   TD_RECV_BUFFER                                              */
/*                                                                          */
/* Description: Contains information about the buffer into which TD         */
/*              receives data from Winsock.                                 */
/****************************************************************************/
typedef struct tagTD_RCVBUF_INFO
{
    DCUINT   size;
    DCUINT   dataStart;
    DCUINT   dataLength;
    PDCUINT8 pData;
} TD_RCVBUF_INFO;



/****************************************************************************/
/* Structure:   TD_GLOBAL_DATA                                              */
/*                                                                          */
/* Description: TD global data                                              */
/****************************************************************************/
typedef struct tagTD_GLOBAL_DATA
{
    HWND            hWnd;
    DCUINT          fsmState;
    HANDLE          hGHBN;
    SOCKET          hSocket;    // connection socket
    INT_PTR         hTimer;
    DCBOOL          dataInTD;
    PTD_SNDBUF_INFO pFQBuf;
    TD_SNDBUF_INFO  pubSndBufs[TD_SNDBUF_PUBNUM];
    TD_SNDBUF_INFO  priSndBufs[TD_SNDBUF_PRINUM];
    DCUINT          recvByteCount;
    TD_RCVBUF_INFO  recvBuffer;
    DCBOOL          inFlushSendQueue;
    DCBOOL          getBufferFailed;
#ifdef OS_WINCE
    DCBOOL          enableWSRecv;
#if (_WIN32_WCE > 300)
    HANDLE          hevtAddrChange;
    HANDLE          hAddrChangeThread;
#endif
#endif // OS_WINCE

#ifdef DC_DEBUG
    INT_PTR         hThroughputTimer;
    DCUINT32        periodSendBytesLeft;
    DCUINT32        periodRecvBytesLeft;
    DCUINT32        currentThroughput;
#endif /* DC_DEBUG */

} TD_GLOBAL_DATA;

#ifdef DC_DEBUG
/****************************************************************************/
/* State and event descriptions (debug build only)                          */
/****************************************************************************/
static const DCTCHAR tdStateText[TD_FSM_STATES][50]
    = {
        _T("TD_ST_NOTINIT"),
        _T("TD_ST_DISCONNECTED"),
        _T("TD_ST_WAITFORDNS"),
        _T("TD_ST_WAITFORSKT"),
        _T("TD_ST_CONNECTED"),
        _T("TD_ST_WAITFORCLOSE"),
    }
;

static const DCTCHAR tdEventText[TD_FSM_INPUTS][50]
    = {
        _T("TD_EVT_TDINIT"),
        _T("TD_EVT_TDTERM"),
        _T("TD_EVT_TDCONNECT_IP"),
        _T("TD_EVT_TDCONNECT_DNS"),
        _T("TD_EVT_TDDISCONNECT"),
        _T("TD_EVT_WMTIMER"),
        _T("TD_EVT_OK"),
        _T("TD_EVT_ERROR"),
        _T("TD_EVT_CONNECTWITHENDPOINT")
    }
;

#endif /* DC_DEBUG */


class CUI;
class CCD;
class CNL;
class CUT;
class CXT;
class CCD;


class CTD
{

public:

    CTD(CObjs* objs);
    ~CTD();

public:
    //
    // API functions
    //

    DCVOID DCAPI TD_Init(DCVOID);

    DCVOID DCAPI TD_Term(DCVOID);
    
    DCVOID DCAPI TD_Connect(BOOL bInitateConnect, PDCTCHAR pServerAddress);

    DCVOID DCAPI TD_Disconnect(DCVOID);

    //
    // Abortive disconnect
    //
    DCVOID DCAPI TD_DropLink(DCVOID);
    
    DCBOOL DCAPI TD_GetPublicBuffer(DCUINT     dataLength,
                                    PPDCUINT8  ppBuffer,
                                    PTD_BUFHND pBufHandle);
    
    DCBOOL DCAPI TD_GetPrivateBuffer(DCUINT     dataLength,
                                     PPDCUINT8  ppBuffer,
                                     PTD_BUFHND pBufHandle);
    
    DCVOID DCAPI TD_SendBuffer(PDCUINT8  pData,
                               DCUINT    dataLength,
                               TD_BUFHND bufHandle);
    
    DCVOID DCAPI TD_FreeBuffer(TD_BUFHND bufHandle);
    
    DCUINT DCAPI TD_Recv(PDCUINT8 pData,
                         DCUINT   size);
    
    #ifdef DC_DEBUG
    DCVOID DCAPI TD_SetBufferOwner(TD_BUFHND bufHandle, PDCTCHAR pOwner);
    #endif
    
    
    /****************************************************************************/
    /* Name:      TD_QueryDataAvailable                                         */
    /*                                                                          */
    /* Purpose:   The return value indicates whether there is data available    */
    /*            in _TD.                                                        */
    /*                                                                          */
    /* Returns:   TRUE if there is data available in TD and FALSE otherwise.    */
    /*                                                                          */
    /* Operation: This function simply returns the global variable _TD.dataInTD  */
    /*            which is set to TRUE whenever we get a FD_READ from WinSock   */
    /*            and set to FALSE whenever a call to recv returns fewer bytes  */
    /*            than requested.                                               */
    /****************************************************************************/
    inline DCBOOL DCAPI TD_QueryDataAvailable(DCVOID)
    {
        DC_BEGIN_FN("TD_QueryDataAvailable");
    
        TRC_DBG((TB, "Data is%s available in TD", _TD.dataInTD ? "" : _T(" NOT")));
    
        DC_END_FN();
        return(_TD.dataInTD);
    } /* TD_QueryDataAvailable */
    
    
    #ifdef OS_WINCE
    /****************************************************************************/
    /* Name:      TD_EnableWSRecv                                               */
    /*                                                                          */
    /* Purpose:   Perform only one recv per FD_READ                             */
    /****************************************************************************/
    inline DCVOID TD_EnableWSRecv(DCVOID)
    {
        DC_BEGIN_FN("TD_EnableWSRecv");
    
        TRC_DBG((TB, _T("_TD.enableWSRecv is currently set to %s."),
                _TD.enableWSRecv ? "TRUE" : "FALSE"));
    
        TRC_ASSERT((_TD.enableWSRecv == FALSE),
            (TB, _T("_TD.enableWSRecv is incorrectly set!")));
    
        _TD.enableWSRecv = TRUE;
        DC_END_FN();
    } /* TD_EnableWSRecv */
    #endif // OS_WINCE
    
    
    #ifdef DC_DEBUG
    DCVOID DCAPI TD_SetNetworkThroughput(DCUINT32 maxThroughput);
    
    DCUINT32 DCAPI TD_GetNetworkThroughput(DCVOID);
    #endif /* DC_DEBUG */
    
    
    /****************************************************************************/
    // TD_GetDataForLength
    //
    // Macro-function for XT to directly use recv()'d data from the TD data
    // buffer. If we have the requested data fully constructed in the receive
    // buffer, skip the data and pass back a pointer, otherwise pass back NULL.
    /****************************************************************************/
    #define TD_GetDataForLength(_len, _ppData, tdinst) \
        if ((tdinst)->_TD.recvBuffer.dataLength >= (_len)) {  \
            *(_ppData) = (tdinst)->_TD.recvBuffer.pData + (tdinst)->_TD.recvBuffer.dataStart;  \
            (tdinst)->_TD.recvBuffer.dataLength -= (_len);  \
            if ((tdinst)->_TD.recvBuffer.dataLength == 0)  \
                /* Used all the data from the recv buffer so reset start pos. */  \
                (tdinst)->_TD.recvBuffer.dataStart = 0;  \
            else  \
                /* Still some data left in recv buffer. */  \
                (tdinst)->_TD.recvBuffer.dataStart += (_len);  \
        }  \
        else {  \
            *(_ppData) = NULL;  \
        }

    #define TD_IgnoreRestofPacket(tdinst) \
        { \
    	    (tdinst)->_TD.recvBuffer.dataLength = 0; \
    	    (tdinst)->_TD.recvBuffer.dataStart  = 0; \
    	}

        
    unsigned DCINTERNAL TDDoWinsockRecv(BYTE FAR *, unsigned);

    
    void DCINTERNAL TDClearSendQueue(ULONG_PTR);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CTD, TDClearSendQueue);

    void DCINTERNAL TDSendError(ULONG_PTR);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CTD, TDSendError);

public:
    //
    // public data members
    //
    TD_GLOBAL_DATA _TD;


private:
    //
    // Internal member functions
    //
    
    /****************************************************************************/
    /* FUNCTIONS                                                                */
    /****************************************************************************/
    DCVOID DCINTERNAL TDConnectFSMProc(DCUINT fsmEvent, ULONG_PTR eventData);
    
    DCVOID DCINTERNAL TDAllocBuf(PTD_SNDBUF_INFO pSndBufInf, DCUINT size);
    
    DCVOID DCINTERNAL TDInitBufInfo(PTD_SNDBUF_INFO pSndBufInf);

    #include "wtdint.h"
    
public:
    //Can be called by CD so has to be public
    void DCINTERNAL TDFlushSendQueue(ULONG_PTR);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CTD, TDFlushSendQueue);
    
private:
    CNL* _pNl;
    CUT* _pUt;
    CXT* _pXt;
    CUI* _pUi;
    CCD* _pCd;

private:
    CObjs* _pClientObjects;
};

#undef TRC_FILE
#undef TRC_GROUP

#endif // _H_TD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\spapi.cpp ===
/**MOD+**********************************************************************/                                                                                              /**MOD+**********************************************************************/
/* Module:    aspapi.c                                                      */
/*                                                                          */
/* Purpose:   Sound Player API functions                                    */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>                                                                              
extern "C" {                                                                              
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "aspapi"
#include <atrcapi.h>
}

#include "sp.h"

CSP::CSP(CObjs* objs)
{
    _pClientObjects = objs;
}

CSP::~CSP()
{
}

/**PROC+*********************************************************************/
/* Name:      SP_Init                                                       */
/*                                                                          */
/* Purpose:   Sound Player initialization function                          */
/*                                                                          */
/* Returns:   Nothing.                                                      */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CSP::SP_Init(DCVOID)
{
    DC_BEGIN_FN("SP_Init");

    TRC_NRM((TB, _T("SP Initialized")));

DC_EXIT_POINT:
    DC_END_FN();
    return;
}

/**PROC+*********************************************************************/
/* Name:      SP_Term                                                       */
/*                                                                          */
/* Purpose:   Sound Player termination function                             */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI CSP::SP_Term(DCVOID)
{
    DC_BEGIN_FN("SP_Term");

    TRC_NRM((TB, _T("SP terminated")));

    DC_END_FN();
    return;
}

/**PROC+*********************************************************************/
/* Name:      SP_OnPlaySoundPDU                                             */
/*                                                                          */
/* Purpose:   Handles the arrival of a PlaySound PDU                        */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    IN  pPlaySoundPDU: pointer to a PlaySound PDU                 */
/*                                                                          */
/**PROC-*********************************************************************/
HRESULT DCAPI CSP::SP_OnPlaySoundPDU(PTS_PLAY_SOUND_PDU_DATA pPlaySoundPDU,
    DCUINT dataLen)
{
    DC_BEGIN_FN("SP_OnPlaySoundPDU");

    DC_IGNORE_PARAMETER(dataLen);

    /************************************************************************/
    /* Check the sound frequency is within the allowed Windows range.       */
    /************************************************************************/
    if((pPlaySoundPDU->frequency >= 0x25) &&
       (pPlaySoundPDU->frequency <= 0x7fff))
    {
        /************************************************************************/
        /* Check the sound is of a sensible duration (less than 1 minute).      */
        /************************************************************************/
        TRC_ASSERT((pPlaySoundPDU->duration < 60000),
                   (TB, _T("PlaySound PDU duration is %lu ms"),
                                                        pPlaySoundPDU->duration));

        TRC_NRM((TB, _T("PlaySound PDU frequency %#lx duration %lu"),
                                                        pPlaySoundPDU->frequency,
                                                        pPlaySoundPDU->duration));

        /************************************************************************/
        /* Play the sound. This is synchronous for Win32, asynchronous for      */
        /* Win16.                                                               */
        /************************************************************************/
        SPPlaySound(pPlaySoundPDU->frequency, pPlaySoundPDU->duration);
    }
    else
    {
        TRC_ERR((TB, _T("PlaySound PDU frequency %#lx out of range"),
                     pPlaySoundPDU->frequency));
    }

    DC_END_FN();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\tdapi.cpp ===
/****************************************************************************/
/* tdapi.c                                                                  */
/*                                                                          */
/* Transport driver - portable specific API                                 */
/*                                                                          */
/* Copyright (C) 1997-1999 Microsoft Corporation                            */
/****************************************************************************/

#include <adcg.h>

extern "C" {
#define TRC_FILE "tdapi"
#define TRC_GROUP TRC_GROUP_NETWORK
#include <atrcapi.h>
}

#include "autil.h"
#include "td.h"
#include "xt.h"
#include "nl.h"

CTD::CTD(CObjs* objs)
{
    _pClientObjects = objs;
}

CTD::~CTD()
{
}

/****************************************************************************/
/* Name:      TD_Init                                                       */
/*                                                                          */
/* Purpose:   Initializes the transport driver.  This is called on the      */
/*            receiver thread.                                              */
/****************************************************************************/
DCVOID DCAPI CTD::TD_Init(DCVOID)
{
    DC_BEGIN_FN("TD_Init");


    _pNl  = _pClientObjects->_pNlObject;
    _pUt  = _pClientObjects->_pUtObject;
    _pXt  = _pClientObjects->_pXTObject;
    _pUi  = _pClientObjects->_pUiObject;
    _pCd  = _pClientObjects->_pCdObject;

    /************************************************************************/
    /* Initialize the global data and set the initial FSM state.            */
    /************************************************************************/
    DC_MEMSET(&_TD, 0, sizeof(_TD));
    _TD.fsmState = TD_ST_NOTINIT;

    /************************************************************************/
    /* Call the FSM.                                                        */
    /************************************************************************/
    TDConnectFSMProc(TD_EVT_TDINIT, 0);

    DC_END_FN();
} /* TD_Init */


/****************************************************************************/
/* Name:      TD_Term                                                       */
/*                                                                          */
/* Purpose:   Terminates the transport driver.  This is called on the       */
/*            receiver thread.                                              */
/****************************************************************************/
DCVOID DCAPI CTD::TD_Term(DCVOID)
{
    DC_BEGIN_FN("TD_Term");

    /************************************************************************/
    /* Call the FSM.                                                        */
    /************************************************************************/
    TDConnectFSMProc(TD_EVT_TDTERM, 0);

    DC_END_FN();
} /* TD_Term */


/****************************************************************************/
/* Name:      TD_Connect                                                    */
/*                                                                          */
/* Purpose:   Connects to a remote server.  Called on the receiver thread.  */
/*                                                                          */
/* Params:                                                                  */
/*     IN bInitateConnect : TRUE if we are making connection,               */
/*                          FALSE if connect with already connected  socket */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI CTD::TD_Connect(BOOL bInitateConnect, PDCTCHAR pServerAddress)
{
    DCUINT   i;
    DCUINT   errorCode;
    u_long   addr;
    DCUINT   nextEvent;
    ULONG_PTR eventData;
    DCACHAR  ansiBuffer[256];

    DC_BEGIN_FN("TD_Connect");

    /************************************************************************/
    /* Check that the string is not null.                                   */
    /************************************************************************/
    if( bInitateConnect )
    {
        TRC_ASSERT((0 != *pServerAddress), 
                    (TB, _T("Server address is NULL")));
    }

    /************************************************************************/
    /* Check that all the buffers are not in-use.                           */
    /************************************************************************/
    for (i = 0; i < TD_SNDBUF_PUBNUM; i++)
    {
        if (_TD.pubSndBufs[i].inUse)
        {
            TD_TRACE_SENDINFO(TRC_LEVEL_ERR);
            TRC_ABORT((TB, _T("Public buffer %u still in-use"), i));
        }
    }

    for (i = 0; i < TD_SNDBUF_PRINUM; i++)
    {
        if (_TD.priSndBufs[i].inUse)
        {
            TD_TRACE_SENDINFO(TRC_LEVEL_ERR);
            TRC_ABORT((TB, _T("Private buffer %u still in-use"), i));
        }
    }

    /************************************************************************/
    /* Trace out the send buffer information.                               */
    /************************************************************************/
    TD_TRACE_SENDINFO(TRC_LEVEL_NRM);

    if( FALSE == bInitateConnect )
    {
        TDConnectFSMProc(TD_EVT_CONNECTWITHENDPOINT, NULL);
        DC_QUIT; // all we need is the buffer.
    }

#ifdef UNICODE
    /************************************************************************/
    /* WinSock 1.1 only supports ANSI, so we need to convert any Unicode    */
    /* strings at this point.                                               */
    /************************************************************************/
    if (!WideCharToMultiByte(CP_ACP,
                             0,
                             pServerAddress,
                             -1,
                             ansiBuffer,
                             256,
                             NULL,
                             NULL))
    {
        /********************************************************************/
        /* Conversion failed                                                */
        /********************************************************************/
        TRC_ERR((TB, _T("Failed to convert address to ANSI")));

        /********************************************************************/
        /* Generate the error code.                                         */
        /********************************************************************/
        errorCode = NL_MAKE_DISCONNECT_ERR(NL_ERR_TDANSICONVERT);

        TRC_ASSERT((HIWORD(errorCode) == 0),
                   (TB, _T("disconnect reason code unexpectedly using 32 bits")));
        _pXt->XT_OnTDDisconnected(errorCode);
    }

#else
        DC_ASTRCPY(ansiBuffer, pServerAddress);
#endif /* UNICODE */

    /************************************************************************/
    /* Check that the address is not the limited broadcast address          */
    /* (255.255.255.255).                                                   */
    /************************************************************************/
    if (0 == DC_ASTRCMP(ansiBuffer, TD_LIMITED_BROADCAST_ADDRESS))
    {
        TRC_ALT((TB, _T("Cannot connect to the limited broadcast address")));

        /********************************************************************/
        /* Generate the error code.                                         */
        /********************************************************************/
        errorCode = NL_MAKE_DISCONNECT_ERR(NL_ERR_TDBADIPADDRESS);

        TRC_ASSERT((HIWORD(errorCode) == 0),
                   (TB, _T("disconnect reason code unexpectedly using 32 bits")));
        _pXt->XT_OnTDDisconnected(errorCode);
        DC_QUIT;
    }

    /************************************************************************/
    /* Now determine whether a DNS lookup is required.                      */
    /************************************************************************/
    TRC_NRM((TB, _T("ServerAddress:%s"), ansiBuffer));

    /************************************************************************/
    /* Check that we have a string and that the address is not the limited  */
    /* broadcast address.                                                   */
    /************************************************************************/
    TRC_ASSERT((NULL != ansiBuffer), (TB, _T("ansiBuffer is NULL")));
    TRC_ASSERT(('\0' != ansiBuffer[0]),
               (TB, _T("Empty server address string")));
    TRC_ASSERT((0 != DC_ASTRCMP(ansiBuffer, TD_LIMITED_BROADCAST_ADDRESS)),
               (TB, _T("Cannot connect to the limited broadcast address")));

    /************************************************************************/
    /* Check for a dotted-IP address string.                                */
    /************************************************************************/
    addr = inet_addr(ansiBuffer);
    TRC_NRM((TB, _T("Address returned is %#lx"), addr));

    /************************************************************************/
    /* Now determine whether this is an address string or a host name.      */
    /* Note that inet_addr doesn't distinguish between an invalid IP        */
    /* address and the limited broadcast address (255.255.255.255).         */
    /* However since we don't allow the limited broadcast address and have  */
    /* already checked explicitly for it we don't need to worry about this  */
    /* case.                                                                */
    /************************************************************************/
    if (INADDR_NONE == addr)
    {
        /********************************************************************/
        /* This looks like a host name so call the FSM with the current     */
        /* address.                                                         */
        /********************************************************************/
        TRC_NRM((TB, _T("%s looks like a hostname - need DNS lookup"),
                 ansiBuffer));
        nextEvent = TD_EVT_TDCONNECT_DNS;
        eventData = (ULONG_PTR) ansiBuffer;
    }
    else
    {
        /********************************************************************/
        /* If we get here then it appears to be a dotted-IP address.  Call  */
        /* the FSM with the updated address.                                */
        /********************************************************************/
        TRC_NRM((TB, _T("%s looks like a dotted-IP address:%lu"),
                 ansiBuffer,
                 addr));
        nextEvent = TD_EVT_TDCONNECT_IP;
        eventData = addr;
    }

    /************************************************************************/
    /* Now call the FSM with the appropriate parameters.                    */
    /************************************************************************/
    TDConnectFSMProc(nextEvent, eventData);

DC_EXIT_POINT:
    DC_END_FN();
} /* TD_Connect */


/****************************************************************************/
/* Name:      TD_Disconnect                                                 */
/*                                                                          */
/* Purpose:   Disconnects from the server.  This is called on the receiver  */
/*            thread.                                                       */
/****************************************************************************/
DCVOID DCAPI CTD::TD_Disconnect(DCVOID)
{
    DC_BEGIN_FN("TD_Disconnect");

    /************************************************************************/
    /* Call the FSM.  We pass NL_DISCONNECT_LOCAL which will be used as the */
    /* return code to XT in the cases where we are waiting for the DNS      */
    /* lookup to return or the socket to connect.                           */
    /************************************************************************/
    TDConnectFSMProc(TD_EVT_TDDISCONNECT, NL_DISCONNECT_LOCAL);

    DC_END_FN();
} /* TD_Disconnect */

//
// TD_DropLink - drops the link immediately (ungracefully)
//
VOID
CTD::TD_DropLink(DCVOID)
{
    DC_BEGIN_FN("TD_DropLink");

    TDConnectFSMProc(TD_EVT_DROPLINK, NL_DISCONNECT_LOCAL);

    DC_END_FN();
}


/****************************************************************************/
/* Name:      TD_GetPublicBuffer                                            */
/*                                                                          */
/* Purpose:   Attempts to allocate a buffer from the public TD buffer pool. */
/*                                                                          */
/* Returns:   If the allocation succeeds then this function returns TRUE    */
/*            otherwise it returns FALSE.                                   */
/*                                                                          */
/* Params:    IN   dataLength - length of the buffer requested.             */
/*            OUT  ppBuffer   - a pointer to a pointer to the buffer.       */
/*            OUT  pBufHandle - a pointer to a buffer handle.               */
/****************************************************************************/
DCBOOL DCAPI CTD::TD_GetPublicBuffer(DCUINT     dataLength,
                                PPDCUINT8  ppBuffer,
                                PTD_BUFHND pBufHandle)
{
    DCUINT i;
    DCBOOL rc = FALSE;
    DCUINT lastfree = TD_SNDBUF_PUBNUM;
    PDCUINT8 pbOldBuffer;
    DCUINT cbOldBuffer;

    DC_BEGIN_FN("TD_GetPublicBuffer");

    // Check that we're in the correct state. If we're disconnected
    // then fail the call. Note that the FSM state is maintained by the
    // receiver thread - but we're on the sender thread.
    if (_TD.fsmState == TD_ST_CONNECTED) {
        TRC_DBG((TB, _T("Searching for a buffer big enough for %u bytes"),
                dataLength));

        // Trace out the send buffer information.
        TD_TRACE_SENDINFO(TRC_LEVEL_DBG);

        // Search the array of buffers looking for the first free one that is
        // large enough.
        for (i = 0; i < TD_SNDBUF_PUBNUM; i++) {
            TRC_DBG((TB, _T("Trying buf:%u inUse:%s size:%u"),
                     i,
                     _TD.pubSndBufs[i].inUse ? "TRUE" : "FALSE",
                     _TD.pubSndBufs[i].size));

            if(!_TD.pubSndBufs[i].inUse)
            {
                lastfree = i;
            }

            if ((!(_TD.pubSndBufs[i].inUse)) &&
                    (_TD.pubSndBufs[i].size >= dataLength)) {
                TRC_DBG((TB, _T("bufHandle:%p (idx:%u) free - size:%u (req:%u)"),
                        &_TD.pubSndBufs[i], i, _TD.pubSndBufs[i].size,
                        dataLength));

                // Now mark this buffer as being in use and set up the return
                // values. The handle is just a pointer to the buffer
                // information structure.
                _TD.pubSndBufs[i].inUse = TRUE;
                *ppBuffer = _TD.pubSndBufs[i].pBuffer;

                *pBufHandle = (TD_BUFHND) (PDCVOID)&_TD.pubSndBufs[i];

                // Set a good return code.
                rc = TRUE;

                // Check that the other fields are set correctly.
                TRC_ASSERT((_TD.pubSndBufs[i].pNext == NULL),
                           (TB, _T("Buf:%u next non-zero"), i));
                TRC_ASSERT((_TD.pubSndBufs[i].bytesLeftToSend == 0),
                           (TB, _T("Buf:%u bytesLeftToSend non-zero"), i));
                TRC_ASSERT((_TD.pubSndBufs[i].pDataLeftToSend == NULL),
                           (TB, _T("Buf:%u pDataLeftToSend non-null"), i));

                // Update the performance counter.
                PRF_INC_COUNTER(PERF_PKTS_ALLOCATED);

                // That's all we need to do so just quit.
                DC_QUIT;
            }
        }

        // check if we need to re-allocate
        if(lastfree < TD_SNDBUF_PUBNUM)
        {
            pbOldBuffer = _TD.pubSndBufs[lastfree].pBuffer;
            cbOldBuffer = _TD.pubSndBufs[lastfree].size;

            // reallocate space
            TDAllocBuf(
                    &_TD.pubSndBufs[lastfree], 
                    dataLength
                );

            // TDAllocBuf() return DCVOID with UI_FatalError()
            if( NULL != _TD.pubSndBufs[lastfree].pBuffer )
            {
                UT_Free( _pUt, pbOldBuffer );

                // Now mark this buffer as being in use and set up the return
                // values. The handle is just a pointer to the buffer
                // information structure.
                _TD.pubSndBufs[lastfree].inUse = TRUE;
                *ppBuffer = _TD.pubSndBufs[lastfree].pBuffer;
                *pBufHandle = (TD_BUFHND) (PDCVOID)&_TD.pubSndBufs[lastfree];

                // Set a good return code.
                rc = TRUE;

                // Update the performance counter.
                PRF_INC_COUNTER(PERF_PKTS_ALLOCATED);

                // That's all we need to do so just quit.
                DC_QUIT;
            }
            else
            {
                // restore pointer and size.
                _TD.pubSndBufs[lastfree].pBuffer = pbOldBuffer;
                _TD.pubSndBufs[lastfree].size = cbOldBuffer;
            }
        }

        // We failed to find a free buffer. Trace the send buffer info.
        _TD.getBufferFailed = TRUE;
        TRC_ALT((TB, _T("Failed to find a free buffer (req dataLength:%u) Bufs:"),
                dataLength));
        TD_TRACE_SENDINFO(TRC_LEVEL_ALT);
    }
    else {
        TRC_NRM((TB, _T("Not connected therefore fail get buffer call")));
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
} /* TD_GetPublicBuffer */


/****************************************************************************/
/* Name:      TD_GetPrivateBuffer                                           */
/*                                                                          */
/* Purpose:   Attempts to allocate a buffer from the private TD buffer      */
/*            pool.                                                         */
/*                                                                          */
/* Returns:   If the allocation succeeds then this function returns TRUE    */
/*            otherwise it returns FALSE.                                   */
/*                                                                          */
/* Params:    IN   dataLength - length of the buffer requested.             */
/*            OUT  ppBuffer   - a pointer to a pointer to the buffer.       */
/*            OUT  pBufHandle - a pointer to a buffer handle.               */
/*                                                                          */
/* Operation: This function should always return a buffer - it it up to     */
/*            the network layer to ensure that it does not allocate more    */
/*            buffers than are available in the private list.               */
/****************************************************************************/
DCBOOL DCAPI CTD::TD_GetPrivateBuffer(DCUINT     dataLength,
                                 PPDCUINT8  ppBuffer,
                                 PTD_BUFHND pBufHandle)
{
    DCUINT i;
    DCBOOL rc = FALSE;

    DC_BEGIN_FN("TD_GetPrivateBuffer");

    // Check that we're in the correct state. If we're disconnected
    // then fail the call. Note that the FSM state is maintained by the
    // receiver thread - but we're on the sender thread.
    if (_TD.fsmState == TD_ST_CONNECTED) {
        TRC_DBG((TB, _T("Searching for a buffer big enough for %u bytes"),
                dataLength));

        // Trace out the send buffer information.
        TD_TRACE_SENDINFO(TRC_LEVEL_DBG);

        // Search the array of buffers looking for the first free one that is
        // large enough.
        for (i = 0; i < TD_SNDBUF_PRINUM; i++) {
            TRC_DBG((TB, _T("Trying buf:%u inUse:%s size:%u"),
                     i,
                     _TD.priSndBufs[i].inUse ? "TRUE" : "FALSE",
                     _TD.priSndBufs[i].size));

            if ((!(_TD.priSndBufs[i].inUse)) &&
            (_TD.priSndBufs[i].size >= dataLength)) {
                TRC_DBG((TB, _T("bufHandle:%p (idx:%u) free - size:%u (req:%u)"),
                        &_TD.priSndBufs[i], i, _TD.priSndBufs[i].size,
                        dataLength));

                // Now mark this buffer as being in use and set up the return
                // values. The handle is just a pointer to the buffer
                // information structure.
                _TD.priSndBufs[i].inUse = TRUE;
                *ppBuffer = _TD.priSndBufs[i].pBuffer;
                *pBufHandle = (TD_BUFHND) (PDCVOID)&_TD.priSndBufs[i];

                // Set a good return code.
                rc = TRUE;

                // Check that the other fields are set correctly.
                TRC_ASSERT((_TD.priSndBufs[i].pNext == NULL),
                           (TB, _T("Buf:%u next non-zero"), i));
                TRC_ASSERT((_TD.priSndBufs[i].bytesLeftToSend == 0),
                           (TB, _T("Buf:%u bytesLeftToSend non-zero"), i));
                TRC_ASSERT((_TD.priSndBufs[i].pDataLeftToSend == NULL),
                           (TB, _T("Buf:%u pDataLeftToSend non-null"), i));

                // That's all we need to do so just quit.
                DC_QUIT;
            }
        }

        // We failed to find a free buffer - flag this internal error by
        // tracing out the entire buffer structure and then aborting.
        TD_TRACE_SENDINFO(TRC_LEVEL_ERR);
        TRC_ABORT((TB, _T("Failed to find a free buffer (req dataLength:%u)"),
                dataLength));
    }
    else {
        TRC_NRM((TB, _T("Not connected therefore fail get buffer call")));
    }

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
} /* TD_GetPrivateBuffer */


/****************************************************************************/
/* Name:      TD_SendBuffer                                                 */
/*                                                                          */
/* Purpose:   Sends a buffer.  The buffer is added to the end of the        */
/*            pending queue and all data on the pending queue is then       */
/*            sent.                                                         */
/*                                                                          */
/* Params:    IN  pData      - pointer to the start of the data.            */
/*            IN  dataLength - amount of the buffer used.                   */
/*            IN  bufHandle  - handle to a buffer.                          */
/****************************************************************************/
DCVOID DCAPI CTD::TD_SendBuffer(PDCUINT8  pData,
                           DCUINT    dataLength,
                           TD_BUFHND bufHandle)
{
    PTD_SNDBUF_INFO pNext;
    PTD_SNDBUF_INFO pHandle = (PTD_SNDBUF_INFO) bufHandle;

    DC_BEGIN_FN("TD_SendBuffer");

    // Trace out the function parameters.
    TRC_DBG((TB, _T("bufHandle:%p dataLength:%u pData:%p"), bufHandle,
            dataLength, pData));

    // Check that the handle is valid.
    TRC_ASSERT((((pHandle >= &_TD.pubSndBufs[0]) &&
                 (pHandle <= &_TD.pubSndBufs[TD_SNDBUF_PUBNUM - 1])) ||
                ((pHandle >= &_TD.priSndBufs[0]) &&
                 (pHandle <= &_TD.priSndBufs[TD_SNDBUF_PRINUM - 1]))),
               (TB, _T("Invalid buffer handle:%p"), bufHandle));

    // Verify buffer contents.
    TRC_ASSERT((0 == pHandle->bytesLeftToSend),
            (TB, _T("pHandle->bytesLeftToSend non-zero (pHandle:%p)"), pHandle));
    TRC_ASSERT((NULL == pHandle->pDataLeftToSend),
            (TB, _T("pHandle->pDataLeftToSend non NULL (pHandle:%p)"), pHandle));
    TRC_ASSERT((NULL != pHandle->pBuffer),
            (TB, _T("pHandle->pBuffer is NULL (pHandle:%p)"), pHandle));
    TRC_ASSERT((NULL == pHandle->pNext),
            (TB, _T("pHandle->pNext (pHandle:%p) non NULL"), pHandle));
    TRC_ASSERT((pHandle->inUse), (TB, _T("pHandle %p is not in-use"), pHandle));

    // Check that pData lies within the buffer and pData+dataLength does not
    // overrun the end.
    TRC_ASSERT(((pData >= pHandle->pBuffer) &&
            (pData < (pHandle->pBuffer + pHandle->size))),
            (TB, _T("pData lies outwith range")));
    TRC_ASSERT(((pData + dataLength) <= (pHandle->pBuffer + pHandle->size)),
            (TB, _T("pData + dataLength over the end of the buffer")));

    //
    // Update the fields in the buffer information structure and add to the
    // pending buffer queue.
    //
    pHandle->pDataLeftToSend = pData;
    pHandle->bytesLeftToSend = dataLength;
    
    if (NULL == _TD.pFQBuf) {
        TRC_DBG((TB, _T("Inserted buffer:%p at queue head"), pHandle));
        _TD.pFQBuf = pHandle;
    }
    else {
        // OK - the queue is not empty.  We need to scan through the queue
        // looking for the first empty slot to insert this buffer in at.
        pNext = _TD.pFQBuf;
        while (NULL != pNext->pNext)
            pNext = pNext->pNext;

        // Update the next field of the this buffer information structure.
        pNext->pNext = pHandle;
        TRC_DBG((TB, _T("Inserted buffer:%p"), pHandle));
    }

    // Finally attempt to flush the send queue.
    TDFlushSendQueue(0);

    DC_END_FN();
} /* TD_SendBuffer */


/****************************************************************************/
/* Name:      TD_FreeBuffer                                                 */
/*                                                                          */
/* Purpose:   Frees the passed buffer.                                      */
/****************************************************************************/
DCVOID DCAPI CTD::TD_FreeBuffer(TD_BUFHND bufHandle)
{
    PTD_SNDBUF_INFO pHandle = (PTD_SNDBUF_INFO) bufHandle;

    DC_BEGIN_FN("TD_FreeBuffer");

    // Trace out the function parameters.
    TRC_DBG((TB, _T("bufHandle:%p"), bufHandle));

    // Check that the handle is valid.
    TRC_ASSERT((((pHandle >= &_TD.pubSndBufs[0]) &&
                 (pHandle <= &_TD.pubSndBufs[TD_SNDBUF_PUBNUM - 1])) ||
                ((pHandle >= &_TD.priSndBufs[0]) &&
                 (pHandle <= &_TD.priSndBufs[TD_SNDBUF_PRINUM - 1]))),
               (TB, _T("Invalid buffer handle:%p"), bufHandle));

    // Verify the buffer contents. InUse does not matter, we can legitimately
    // free a non-in-use buffer.
    TRC_ASSERT((0 == pHandle->bytesLeftToSend),
            (TB, _T("pHandle->bytesLeftToSend non-zero (pHandle:%p)"), pHandle));
    TRC_ASSERT((NULL == pHandle->pDataLeftToSend),
            (TB, _T("pHandle->pDataLeftToSend non NULL (pHandle:%p)"), pHandle));
    TRC_ASSERT((NULL != pHandle->pBuffer),
            (TB, _T("pHandle->pBuffer is NULL (pHandle:%p)"), pHandle));
    TRC_ASSERT((NULL == pHandle->pNext),
            (TB, _T("pHandle->pNext (pHandle:%p) non NULL"), pHandle));

    // Free the buffer.
    pHandle->inUse = FALSE;

    // Update the performance counter.
    PRF_INC_COUNTER(PERF_PKTS_FREED);

    DC_END_FN();
} /* TD_FreeBuffer */


#ifdef DC_DEBUG

/****************************************************************************/
/* Name:      TD_SetBufferOwner                                             */
/*                                                                          */
/* Purpose:   Note the owner of a TD buffer                                 */
/*                                                                          */
/* Params:    bufHandle - handle to the buffer                              */
/*            pOwner - name of the 'owner'                                  */
/****************************************************************************/
DCVOID DCAPI CTD::TD_SetBufferOwner(TD_BUFHND bufHandle, PDCTCHAR pOwner)
{
    PTD_SNDBUF_INFO pHandle = (PTD_SNDBUF_INFO) bufHandle;

    DC_BEGIN_FN("TD_SetBufferOwner");

    /************************************************************************/
    /* Trace out the function parameters.                                   */
    /************************************************************************/
    TRC_DBG((TB, _T("bufHandle:%p owner %s"), bufHandle, pOwner));

    /************************************************************************/
    /* Check that the handle is valid.                                      */
    /************************************************************************/
    TRC_ASSERT((((pHandle >= &_TD.pubSndBufs[0]) &&
                 (pHandle <= &_TD.pubSndBufs[TD_SNDBUF_PUBNUM - 1])) ||
                ((pHandle >= &_TD.priSndBufs[0]) &&
                 (pHandle <= &_TD.priSndBufs[TD_SNDBUF_PRINUM - 1]))),
               (TB, _T("Invalid buffer handle:%p"), bufHandle));

    /************************************************************************/
    /* Save the owner                                                       */
    /************************************************************************/
    pHandle->pOwner = pOwner;

    DC_END_FN();
} /* TD_SetBufferOwner */

#endif/* DC_DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\uhapi.cpp ===
/****************************************************************************/
/* uhapi.cpp                                                                */
/*                                                                          */
/* Update Handler API                                                       */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/****************************************************************************/

#include <adcg.h>

extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "uhapi"
#include <atrcapi.h>
}


#include "autil.h"
#include "uh.h"

#include "op.h"
#include "od.h"
#include "aco.h"
#include "cd.h"
#include "or.h"
#include "cc.h"
#include "wui.h"
#include "sl.h"

extern "C" {
#include <stdio.h>
#ifdef OS_WINNT
#include <shlobj.h>
#endif
}

#ifdef OS_WINCE
#ifdef DC_DEBUG
#include <eosint.h>
#endif
#endif



CUH::CUH(CObjs* objs)
{
    _pClientObjects = objs;
}

CUH::~CUH()
{
}

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

/****************************************************************************/
// UHGrabPersistentCacheLock
//
// Takes out a lock on the persistent cache directory to make sure no other
// instances of MSTSC on the system can use the cache directory.
// Returns FALSE if the lock could not be grabbed, nonzero if it was grabbed.
/****************************************************************************/
inline BOOL CUH::UHGrabPersistentCacheLock(VOID)
{
    BOOL rc = TRUE;

    DC_BEGIN_FN("UHGrabPersistentCacheLock");

    _UH.hPersistentCacheLock = CreateMutex(NULL, TRUE, _UH.PersistentLockName);
    if (_UH.hPersistentCacheLock == NULL ||
            GetLastError() == ERROR_ALREADY_EXISTS) {
        if (_UH.hPersistentCacheLock != NULL) {
            CloseHandle(_UH.hPersistentCacheLock);
            _UH.hPersistentCacheLock = NULL;
        }
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
// UHReleasePersistentCacheLock
//
// Releases the lock taken out with UHGrabPersistentCacheLock().
/****************************************************************************/
inline VOID CUH::UHReleasePersistentCacheLock(VOID)
{
    DC_BEGIN_FN("UHReleasePersistentCacheLock");

    if (_UH.hPersistentCacheLock != NULL) {
        CloseHandle(_UH.hPersistentCacheLock);
        _UH.hPersistentCacheLock = NULL;
    }

    DC_END_FN();
}

/****************************************************************************/
// Wrappers for directory enumeration functions - to translate into Win32
// (non-WinCE) and Win16 enumeration methods.
//
// UHFindFirstFile returns INVALID_FILE_HANDLE on enumeration start failure.
// UHFindNextFile returns TRUE if there are more files to enumerate.
/****************************************************************************/
#if (defined(OS_WINNT) || (defined(OS_WINCE) && defined(ENABLE_BMP_CACHING_FOR_WINCE)))

inline HANDLE CUH::UHFindFirstFile(
        const TCHAR *Path,
        TCHAR *Filename,
        long *pFileSize)
{
    HANDLE hSearch;
    WIN32_FIND_DATA FindData;

    hSearch = FindFirstFile(Path, &FindData);
    if (hSearch != INVALID_HANDLE_VALUE) {
        Filename[12] = _T('\0');
        _tcsncpy(Filename, FindData.cFileName, 12);
        *pFileSize = FindData.nFileSizeLow;
    }

    return hSearch;
}

inline BOOL CUH::UHFindNextFile(
        HANDLE hSearch,
        TCHAR *Filename,
        long *pFileSize)
{
    WIN32_FIND_DATA FindData;

    if (FindNextFile(hSearch, &FindData)) {
        Filename[12] = _T('\0');
        _tcsncpy(Filename, FindData.cFileName, 12);
        *pFileSize = FindData.nFileSizeLow;
        return TRUE;
    }

    return FALSE;
}

inline void CUH::UHFindClose(HANDLE hSearch)
{
    FindClose(hSearch);
}


#endif  // OS_WINNT and OS_WINCE


#ifdef OS_WINNT
inline BOOL CUH::UHGetDiskFreeSpace(
        TCHAR  *pPathName,
        ULONG *pSectorsPerCluster,
        ULONG *pBytesPerSector,
        ULONG *pNumberOfFreeClusters,
        ULONG *pTotalNumberOfClusters)
{
    return GetDiskFreeSpace(pPathName, pSectorsPerCluster,
            pBytesPerSector, pNumberOfFreeClusters,
            pTotalNumberOfClusters);
}

#elif defined(OS_WINCE)
#ifdef ENABLE_BMP_CACHING_FOR_WINCE
inline BOOL CUH::UHGetDiskFreeSpace(
        TCHAR *pPathName,
        ULONG *pSectorsPerCluster,
        ULONG *pBytesPerSector,
        ULONG *pNumberOfFreeClusters,
        ULONG *pTotalNumberOfClusters)
{

    ULARGE_INTEGER FreeBytesAvailableToCaller;  // receives the number of bytes on
                                                // disk available to the caller
    ULARGE_INTEGER TotalNumberOfBytes;          // receives the number of bytes on disk
    ULARGE_INTEGER TotalNumberOfFreeBytes;      // receives the free bytes on disk

    BOOL bRet = GetDiskFreeSpaceEx(
                    pPathName,
                    &FreeBytesAvailableToCaller,
                    &TotalNumberOfBytes,
                    &TotalNumberOfFreeBytes
                    );

    if (bRet) {
        // For calculation of free space, we assume that each cluster contains
        // one sector, and each sector contains one byte.

        *pSectorsPerCluster = 1;
        *pBytesPerSector = 1;
        *pNumberOfFreeClusters = TotalNumberOfFreeBytes.LowPart;
        *pTotalNumberOfClusters = TotalNumberOfBytes.LowPart;
    }

    return bRet;

}
#endif // ENABLE_BMP_CACHING_FOR_WINCE
#endif  // OS_WINNT and OS_WINCE


/***************************************************************************/
// UHSendPersistentBitmapKeyList
//
// Attempts to send a persistent bitmap key PDU
/***************************************************************************/
#define UH_BM_PERSISTENT_LIST_SENDBUFSIZE 1400

VOID DCINTERNAL CUH::UHSendPersistentBitmapKeyList(ULONG_PTR unusedParm)
{
    UINT i;
    ULONG curEntry;
    SL_BUFHND hBuf;
    PTS_BITMAPCACHE_PERSISTENT_LIST pList;

    // Max entries we can fill into the max PDU size we will be using.
    const unsigned MaxPDUEntries = ((UH_BM_PERSISTENT_LIST_SENDBUFSIZE -
            sizeof(TS_BITMAPCACHE_PERSISTENT_LIST)) /
            sizeof(TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY)) + 1;

    DC_BEGIN_FN("UHSendPersistentBitmapKeyList");

    DC_IGNORE_PARAMETER(unusedParm);

    TRC_ASSERT((_UH.bEnabled), (TB, _T("UH not enabled")));
    TRC_ASSERT((_UH.bBitmapKeyEnumComplete), (TB, _T("Enumeration is not complete")));

    TRC_NRM((TB, _T("Send Persistent Bitmap Key PDU")));

    if (_UH.totalNumKeyEntries == 0) {
        for (i = 0; i < _UH.NumBitmapCaches; i++) {
            _UH.numKeyEntries[i] = min(_UH.numKeyEntries[i],
                    _UH.bitmapCache[i].BCInfo.NumVirtualEntries);
            _UH.totalNumKeyEntries += _UH.numKeyEntries[i];
        }
    }

    if (_pSl->SL_GetBuffer(UH_BM_PERSISTENT_LIST_SENDBUFSIZE,
            (PPDCUINT8)&pList, &hBuf)) {
        // Fill in the header information - zero first then set nonzero
        // fields.
        memset(pList, 0, sizeof(TS_BITMAPCACHE_PERSISTENT_LIST));
        pList->shareDataHeader.shareControlHeader.pduType =
                               TS_PDUTYPE_DATAPDU | TS_PROTOCOL_VERSION;
        pList->shareDataHeader.shareControlHeader.pduSource =
                                                  _pUi->UI_GetClientMCSID();
        pList->shareDataHeader.shareID = _pUi->UI_GetShareID();
        pList->shareDataHeader.streamID = TS_STREAM_LOW;
        pList->shareDataHeader.pduType2 =
                TS_PDUTYPE2_BITMAPCACHE_PERSISTENT_LIST;

        // set the first PDU flag
        if (_UH.sendNumBitmapKeys == 0)
            pList->bFirstPDU = TRUE;

        // set the last PDU flag
        if (_UH.totalNumKeyEntries - _UH.sendNumBitmapKeys <=
            MaxPDUEntries)
            pList->bLastPDU = TRUE;

        // Copy the total entries.
        for (i = 0; i < _UH.NumBitmapCaches; i++)
            pList->TotalEntries[i] = (DCUINT16) _UH.numKeyEntries[i];

        // Continue the entry enumeration from where we left off.
        curEntry = 0;
        while (curEntry < MaxPDUEntries &&
                _UH.sendBitmapCacheId < _UH.NumBitmapCaches) {
            if (_UH.sendBitmapCacheIndex < _UH.numKeyEntries[_UH.sendBitmapCacheId]) {
                // set up the Bitmap Page Table
                _UH.bitmapCache[_UH.sendBitmapCacheId].PageTable.PageEntries
                        [_UH.sendBitmapCacheIndex].bmpInfo = _UH.pBitmapKeyDB
                        [_UH.sendBitmapCacheId][_UH.sendBitmapCacheIndex];
#ifdef DC_DEBUG
                UHCacheEntryKeyLoadOnSessionStart(_UH.sendBitmapCacheId,
                        _UH.sendBitmapCacheIndex);
#endif

                // fill the bitmap keys into PDU
                pList->Entries[curEntry].Key1 = _UH.bitmapCache
                        [_UH.sendBitmapCacheId].PageTable.PageEntries
                        [_UH.sendBitmapCacheIndex].bmpInfo.Key1;
                pList->Entries[curEntry].Key2 = _UH.bitmapCache
                        [_UH.sendBitmapCacheId].PageTable.PageEntries
                        [_UH.sendBitmapCacheIndex].bmpInfo.Key2;

                TRC_NRM((TB,_T("Idx: %d K1: 0x%x K2: 0x%x"),
                         _UH.sendBitmapCacheIndex,
                         pList->Entries[curEntry].Key1,
                         pList->Entries[curEntry].Key2 ));

                pList->NumEntries[_UH.sendBitmapCacheId]++;

                // move on to the next key
                _UH.sendBitmapCacheIndex++;
                curEntry++;
            }
            else {
                // move on to next cache
                _UH.sendBitmapCacheId++;
                _UH.sendBitmapCacheIndex = 0;
            }
       }

       // Send the PDU.
       pList->shareDataHeader.shareControlHeader.totalLength =
               (TSUINT16)(sizeof(TS_BITMAPCACHE_PERSISTENT_LIST) -
               sizeof(TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY) +
               (curEntry * sizeof(TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY)));
       _pSl->SL_SendPacket((PDCUINT8)pList,
               pList->shareDataHeader.shareControlHeader.totalLength, RNS_SEC_ENCRYPT,
               hBuf, _pUi->UI_GetClientMCSID(), _pUi->UI_GetChannelID(), TS_MEDPRIORITY);

       TRC_NRM((TB,_T("Sent persistent bitmap key PDU, #keys=%u"),curEntry));
       _UH.sendNumBitmapKeys += curEntry;

       if (_UH.sendNumBitmapKeys >= _UH.totalNumKeyEntries) {
           _UH.bPersistentBitmapKeysSent = TRUE;
           //
           // now we need to send
           // a zero font list PDU
           //
           _pFs->FS_SendZeroFontList(0);
       }
       else {
           // more key PDU to send

           _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                   this, CD_NOTIFICATION_FUNC(CUH,UHSendPersistentBitmapKeyList), 0);
       }
    }
    else {
        // On buffer allocation failure, UHSendPersistentBitmapKeyList will
        // be retried from UH_BufferAvailable.
        TRC_ALT((TB, _T("Unable to allocate buffer to send Bitmap Key PDU")));
    }

DC_EXIT_POINT:
    DC_END_FN();
} // UHSendPersistentBitmapKeyList

/****************************************************************************/
// UHReadFromCacheFileForEnum
//
// Read a bitmap entry from the cache file for the purpose of
// enumerating keys.
/****************************************************************************/
_inline BOOL DCINTERNAL CUH::UHReadFromCacheFileForEnum(VOID)
{
    BOOL rc = FALSE;
    BOOL bApiRet = FALSE;
    LONG filelen = 0;

    DC_BEGIN_FN("UHReadFromCacheFile");

    TRC_ASSERT(_UH.bBitmapKeyEnumerating,
               (TB,_T("UHReadFromCacheFile should only be called for enum")));

    TRC_ASSERT(_UH.currentCopyMultiplier,
               (TB,_T("currentCopyMultiplier not set")));
    

    // read the bitmap entry to the bitmap key database
    DWORD cbRead;
    bApiRet = ReadFile( _UH.currentFileHandle,
                   &_UH.pBitmapKeyDB[_UH.currentBitmapCacheId]
                                    [_UH.numKeyEntries[_UH.currentBitmapCacheId]],
                   sizeof(TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY),
                   &cbRead,
                   NULL );
    if(bApiRet && sizeof(TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY) == cbRead)
    {
        if (_UH.pBitmapKeyDB[_UH.currentBitmapCacheId][_UH.numKeyEntries
                [_UH.currentBitmapCacheId]].Key1 != 0 &&
                _UH.pBitmapKeyDB[_UH.currentBitmapCacheId][_UH.numKeyEntries
                [_UH.currentBitmapCacheId]].Key2 != 0) {
            // we read a valid entry
            _UH.numKeyEntries[_UH.currentBitmapCacheId]++;
            
            rc = TRUE;

            // Move onto the next entry in the cache file
            if((SetFilePointer(_UH.currentFileHandle,
                               _UH.numKeyEntries[_UH.currentBitmapCacheId] * 
                               (UH_CellSizeFromCacheIDAndMult(
                                   _UH.currentBitmapCacheId,
                                   _UH.currentCopyMultiplier) +
                               sizeof(UHBITMAPFILEHDR)),
                               NULL,
                               FILE_BEGIN) != INVALID_SET_FILE_POINTER) &&
                (_UH.numKeyEntries[_UH.currentBitmapCacheId] <
                _UH.maxNumKeyEntries[_UH.currentBitmapCacheId]))
            {
                    DC_QUIT;
            }
        }

#ifdef DC_HICOLOR
        // This needs to be here - or we may try to do an lseek on a file
        // that's hit the end
        DWORD dwRet = SetFilePointer(_UH.currentFileHandle,
                                     0,
                                     NULL,
                                     FILE_END);
        if(INVALID_SET_FILE_POINTER != dwRet)
        {
            filelen = dwRet;
        }

        if (filelen > 0) {
            _UH.bitmapCacheSizeInUse += filelen;
        }
        else {
            TRC_ABORT((TB, _T("failed SetFilePointer to end of file")));
        }
#endif
    }
    else {
        // end of file or error in cache file.
        // Close this cache file and move on to next one
        TRC_ERR((TB, _T("ReadFile failed with err 0x%x"),
                 GetLastError()));
        if(GetLastError() == ERROR_HANDLE_EOF)
        {
            rc = TRUE;
        }
    }

#ifndef DC_HICOLOR
    DWORD dwRet = SetFilePointer(_UH.currentFileHandle,
                                 0,
                                 NULL,
                                 FILE_END);
    if(INVALID_SET_FILE_POINTER != dwRet)
    {
        filelen = dwRet;
    }

    if (filelen > 0) {
        _UH.bitmapCacheSizeInUse += filelen;
    }
    else {
        TRC_ABORT((TB, _T("failed SetFilePointer to end of file")));
    }
#endif //HICOLOR

    CloseHandle(_UH.currentFileHandle);
    _UH.currentFileHandle = INVALID_HANDLE_VALUE;
    _UH.currentBitmapCacheId++;
    _UH.currentFileHandle = 0;


DC_EXIT_POINT:
    DC_END_FN();

    return rc;
}


/****************************************************************************/
// UHEnumerateBitmapKeyList
//
// Enumerate the persistent bitmap keys from disk cache
/****************************************************************************/
#define UH_ENUM_PER_POST   50
VOID DCINTERNAL CUH::UHEnumerateBitmapKeyList(ULONG_PTR unusedParm)
{
    UINT  numEnum;
    UINT  virtualSize = 0;
    HRESULT hr;

    DC_BEGIN_FN("UHEnumerateBitmapKeyList");

    DC_IGNORE_PARAMETER(unusedParm);

    numEnum = 0;

    if (_UH.bBitmapKeyEnumComplete)
    {
        TRC_NRM((TB,_T("Enumeration has completed. Bailing out")));
        DC_QUIT;
    }

    if (!_UH.bBitmapKeyEnumerating)
    {
        TRC_NRM((TB,_T("Starting new enumeration for copymult:%d"),
                 _UH.copyMultiplier));
        _UH.bBitmapKeyEnumerating = TRUE;

        //
        // Track enumeration copy-multiplier as _UH.copyMultiplier
        // can potentially change during enumeration as a UH_Enable
        // call comes in
        //
        _UH.currentCopyMultiplier = _UH.copyMultiplier;
    }

    //
    // Can't be enumerating while complete
    //
    TRC_ASSERT(!(_UH.bBitmapKeyEnumerating && _UH.bBitmapKeyEnumComplete),
                (TB,_T("Bad state: enumerating while complete")));

    // enumerate the bitmap cache directories
    while (_UH.currentBitmapCacheId < _UH.RegNumBitmapCaches &&
            numEnum < UH_ENUM_PER_POST) {
        // See if this cache is marked persistent.
        if (_UH.RegBCInfo[_UH.currentBitmapCacheId].bSendBitmapKeys) {
            if (_UH.pBitmapKeyDB[_UH.currentBitmapCacheId] == NULL) {
                // we haven't allocate key database memory for this cache yet

                // determine the max possible key database entries for this cache
                virtualSize = 
                    UH_PropVirtualCacheSizeFromMult(_UH.currentCopyMultiplier);
                _UH.maxNumKeyEntries[_UH.currentBitmapCacheId] =
                        virtualSize /
                        (UH_CellSizeFromCacheIDAndMult(
                            _UH.currentBitmapCacheId,
                            _UH.currentCopyMultiplier) +
                        sizeof(UHBITMAPFILEHDR));

                _UH.pBitmapKeyDB[_UH.currentBitmapCacheId] =
                        (PTS_BITMAPCACHE_PERSISTENT_LIST_ENTRY)
                        UT_MallocHuge(_pUt,
                        _UH.maxNumKeyEntries[_UH.currentBitmapCacheId] *
                        sizeof(TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY));

                if (_UH.pBitmapKeyDB[_UH.currentBitmapCacheId] == NULL) {
                    TRC_ERR((TB, _T("failed to alloc mem for key database")));
                    _UH.bBitmapKeyEnumComplete = TRUE;
                    break;
                }
            }

            if (_UH.currentFileHandle != INVALID_HANDLE_VALUE) {
                // we already have an open cache file
                // read a bitmap's info from the cache file
                UHReadFromCacheFileForEnum();
            }

            else {
                // we need to open this cache file
                hr = UHSetCurrentCacheFileName(_UH.currentBitmapCacheId,
                                               _UH.currentCopyMultiplier);

                if (SUCCEEDED(hr)) {

                // Start the file enumeration.
#ifndef OS_WINCE
                    if (!_UH.fBmpCacheMemoryAlloced)
                    {
                        _UH.currentFileHandle = CreateFile( _UH.PersistCacheFileName,
                                                            GENERIC_READ,
                                                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                            NULL,
                                                            OPEN_EXISTING,
                                                            FILE_ATTRIBUTE_NORMAL,
                                                            NULL);
                    }
                    else
                    {
                        //UH_Enable and UHAllocBitmapCacheMemory has been called
                        //and should have created the bitmap cache files. If we were
                        //to create file here we'd get a sharing violation so instead
                        //duplicated the existing handle
                        HANDLE hCacheFile =
                          _UH.bitmapCache[_UH.currentBitmapCacheId].PageTable.CacheFileInfo.hCacheFile;
                        TRC_NRM((TB,_T("About to dup handle to bmp cache file 0x%x"),
                                 hCacheFile));
                        if (INVALID_HANDLE_VALUE != hCacheFile)
                        {
                            HANDLE hCurProc = GetCurrentProcess();
                            if (hCurProc)
                            {
                                if(!DuplicateHandle(hCurProc,
                                                    hCacheFile,
                                                    hCurProc,
                                                    &_UH.currentFileHandle,
                                                    GENERIC_READ,
                                                    FALSE,
                                                    0))
                                {
                                    TRC_ERR((TB,_T("Dup handle failed 0x%x"),
                                             GetLastError()));
                                    _UH.currentFileHandle = INVALID_HANDLE_VALUE;
                                }
                            }
                            else
                            {
                                TRC_ERR((TB,_T("GetCurrentProcess failed 0x%x"),
                                         GetLastError()));
                                _UH.currentFileHandle = INVALID_HANDLE_VALUE;
                            }
                        }
                        else
                        {
                            _UH.currentFileHandle = INVALID_HANDLE_VALUE;
                        }
                    }
#else //OS_WINCE
                    // CE_FIXNOTE:
                    // CE doesn't support duplicate handle so on a reconnect
                    // it is possible the CreateFile will fail with a sharing
                    // violation. Might need to revisit the logic and on CE only
                    // create the files with R/W sharing
                    //
                    _UH.currentFileHandle = CreateFile( _UH.PersistCacheFileName,
                                                        GENERIC_READ | GENERIC_WRITE,
                                                        FILE_SHARE_READ,
                                                        NULL,
                                                        OPEN_EXISTING,
                                                        FILE_ATTRIBUTE_NORMAL,
                                                        NULL);
#endif
                }
                else {
                    _UH.currentFileHandle = INVALID_HANDLE_VALUE;
                }

                if (_UH.currentFileHandle != INVALID_HANDLE_VALUE) {

                    // First entry of the cache file
                    UHReadFromCacheFileForEnum();
                }
                else {
                    // we can't open the cache file for this cache,
                    // move on to the next cache
                    // we also need to clear the cache file
                    UH_ClearOneBitmapDiskCache(_UH.currentBitmapCacheId,
                                               _UH.currentCopyMultiplier);
                    _UH.currentBitmapCacheId++;
                    _UH.currentFileHandle = INVALID_HANDLE_VALUE;
                }
            }

            numEnum++;
        }
        else {
            // check next cache
            _UH.currentBitmapCacheId++;
            _UH.currentFileHandle = INVALID_HANDLE_VALUE;
        }
    } // end of while

    if (_UH.currentBitmapCacheId == _UH.RegNumBitmapCaches ||
            _UH.bBitmapKeyEnumComplete == TRUE) {
        TRC_NRM((TB, _T("Finished bitmap keys enumeration for copymult:%d"),
                 _UH.currentCopyMultiplier));
        _UH.bBitmapKeyEnumComplete = TRUE;
        _UH.bBitmapKeyEnumerating = FALSE;

        // We need to make sure we have enough disk space for persistent caching
        UINT vcacheSize = UH_PropVirtualCacheSizeFromMult(_UH.currentCopyMultiplier);
        if (vcacheSize / _UH.BytesPerCluster >= _UH.NumberOfFreeClusters) {
            //
            // Be careful to correctly map the array index (-1 to go 0 based)
            //
            _UH.PropBitmapVirtualCacheSize[_UH.currentCopyMultiplier-1] =
                min(vcacheSize,(_UH.bitmapCacheSizeInUse +
                                _UH.NumberOfFreeClusters / 2 *
                                _UH.BytesPerCluster));
        }
          
        // We disable persistent caching if we don't have enough disk space
        // We need at least as much as memory cache size
        if (UH_PropVirtualCacheSizeFromMult(_UH.currentCopyMultiplier) <
            _UH.RegBitmapCacheSize)
        {
            _UH.bPersistenceDisable = TRUE;
        }

        // UH is enabled and enumeration is finished, try to send the bitmap
        // key PDU now
        if (_UH.bEnabled) {
            if (_UH.bPersistenceActive && !_UH.bPersistentBitmapKeysSent)
            {
                if (_UH.currentCopyMultiplier == _UH.copyMultiplier)
                {
                    //Great we've enumerated keys for the correct
                    //copy multiplier
                    UHSendPersistentBitmapKeyList(0);
                }
                else
                {
                    //
                    // We got connected at a different copy multiplier
                    // need to enumerate keys again. Reset enumeration state
                    //
                    UHResetAndRestartEnumeration();
                }
            }
        }
    }
    else {
        if (_UH.bitmapKeyEnumTimerId == 0) {
           TRC_DBG((TB, _T("Calling CD again")));
           _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                   CD_NOTIFICATION_FUNC(CUH,UHEnumerateBitmapKeyList), 0);
        }
    }

DC_EXIT_POINT:

    if (_UH.bBitmapKeyEnumComplete)
    {
        _UH.bBitmapKeyEnumerating = FALSE;
    }

    DC_END_FN();
} //UHEnumerateBitmapKeyList

/****************************************************************************/
// UH_ClearOneBitmapDiskCache
//
// remove all the files under a bitmap disk cache
/****************************************************************************/
VOID DCAPI CUH::UH_ClearOneBitmapDiskCache(UINT cacheId, UINT copyMultiplier)
{
    DC_BEGIN_FN("UH_ClearOneBitmapDiskCache");

    UHSetCurrentCacheFileName(cacheId, copyMultiplier);

    DeleteFile(_UH.PersistCacheFileName);

    DC_END_FN();
}
#endif  // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))


/****************************************************************************/
// UH_Init
//
// Purpose: Initialize _UH. Called on program init, one or more connections
// may be performed after this and before UH_Term is called.
/****************************************************************************/
DCVOID DCAPI CUH::UH_Init(DCVOID)
{
    PDCUINT16 pIndexTable;
    DCUINT    i;
    HRESULT   hr;

#ifdef OS_WINCE
    BOOL bUseStorageCard = FALSE;
    BOOL bSuccess = FALSE;
#endif

    DC_BEGIN_FN("UH_Init");

    TRC_ASSERT(_pClientObjects, (TB,_T("_pClientObjects is NULL")));
    _pClientObjects->AddObjReference(UH_OBJECT_FLAG);

    #ifdef DC_DEBUG
    _pClientObjects->CheckPointers();
    #endif
    
    _pGh  = _pClientObjects->_pGHObject;
    _pOp  = _pClientObjects->_pOPObject;
    _pSl  = _pClientObjects->_pSlObject;
    _pUt  = _pClientObjects->_pUtObject;
    _pFs  = _pClientObjects->_pFsObject;
    _pOd  = _pClientObjects->_pODObject;
    _pIh  = _pClientObjects->_pIhObject;
    _pCd  = _pClientObjects->_pCdObject;
    _pUi  = _pClientObjects->_pUiObject;
    _pCc  = _pClientObjects->_pCcObject;
    _pClx = _pClientObjects->_pCLXObject;
    _pOr  = _pClientObjects->_pOrObject;

    memset(&_UH, 0, sizeof(_UH));

    //
    // At UH_Init time the client hasn't connected
    // yet so key the color depth off what the user
    // has requested
    //
    switch (_pUi->_UI.colorDepthID)
    {
        case CO_BITSPERPEL8:
            _UH.copyMultiplier = 1;
            break;
        case CO_BITSPERPEL15:
        case CO_BITSPERPEL16:
            _UH.copyMultiplier = 2;
            break;
        case CO_BITSPERPEL24:
            _UH.copyMultiplier = 3;
            break;
        default:
            TRC_ERR((TB,_T("Unknown color depth: %d"),
                    _pUi->UI_GetColorDepth()));
            _UH.copyMultiplier = 1;
            break;
    }

    _UH.currentFileHandle = INVALID_HANDLE_VALUE;

    _pGh->GH_Init();

    /************************************************************************/
    // Set up the nonzero invariant fields in the BitmapInfoHeader
    // structure.  This is used for processing received Bitmap PDUs.
    // Note that for WinCE this is required for UHAllocBitmapCacheMemory().
    /************************************************************************/
    _UH.bitmapInfo.hdr.biSize = sizeof(BITMAPINFOHEADER);
    _UH.bitmapInfo.hdr.biPlanes = 1;
    _UH.bitmapInfo.hdr.biBitCount = 8;
    _UH.bitmapInfo.hdr.biCompression = BMCRGB;
    _UH.bitmapInfo.hdr.biXPelsPerMeter = 10000;
    _UH.bitmapInfo.hdr.biYPelsPerMeter = 10000;

    /************************************************************************/
    // Allocate and init the color table cache memory.
    // If alloc fails then we will not later allocate and advertise bitmap
    // and glyph caching capability.
    // Note that bitmap cache memory and capabilities are set up during
    // connection.
    /************************************************************************/
    if (UHAllocColorTableCacheMemory()) {
        TRC_NRM((TB, _T("Color table cache memory OK")));

        // Init headers with default values.
        for (i = 0; i < UH_COLOR_TABLE_CACHE_ENTRIES; i++) {
            _UH.pMappedColorTableCache[i].hdr.biSize = sizeof(BITMAPINFOHEADER);
            _UH.pMappedColorTableCache[i].hdr.biPlanes = 1;
            _UH.pMappedColorTableCache[i].hdr.biBitCount = 8;
            _UH.pMappedColorTableCache[i].hdr.biCompression = BMCRGB;
            _UH.pMappedColorTableCache[i].hdr.biSizeImage = 0;
            _UH.pMappedColorTableCache[i].hdr.biXPelsPerMeter = 10000;
            _UH.pMappedColorTableCache[i].hdr.biYPelsPerMeter = 10000;
            _UH.pMappedColorTableCache[i].hdr.biClrUsed = 0;
            _UH.pMappedColorTableCache[i].hdr.biClrImportant = 0;
        }
    }
    else {
        TRC_ERR((TB, _T("Color table cache alloc failed - bitmap caching ")
                _T("disabled")));
#ifdef OS_WINCE
        //This and other failure paths are added for WINCE because it is difficult to 
        //recover from an OOM scenario on CE. So we trigger a fatal error and not let 
        //the connection continue in case any memory allocation fails.
        DC_QUIT;
#endif
    }

    // Allocate the glyph cache memory, set up glyph cache capabilities.
    if (UHAllocGlyphCacheMemory())
        TRC_NRM((TB, _T("Glyph cache memory OK")));
    else
#ifdef OS_WINCE
    {
#endif
        TRC_ERR((TB, _T("Glyph cache memory allocation failed!")));
#ifdef OS_WINCE
            DC_QUIT;
    }
#endif

    // Allocate the brush cache.
    if (UHAllocBrushCacheMemory())
        TRC_NRM((TB, _T("Brush cache memory OK")));
    else
#ifdef OS_WINCE
        {
#endif
        TRC_ERR((TB, _T("Brush cache memory allocation failed!")));
#ifdef OS_WINCE
            DC_QUIT;
        }
#endif

    // Allocate the offscreen cache
    if (UHAllocOffscreenCacheMemory()) {
        TRC_NRM((TB, _T("Offscreen cache memory OK")));
    }
    else {
        TRC_ERR((TB, _T("Offscreen cache memory allocation failed!")));
    }

#ifdef DRAW_NINEGRID
    // Allocate the drawninegrid cache
    if (UHAllocDrawNineGridCacheMemory()) {
        TRC_NRM((TB, _T("DrawNineGrid cache memory OK")));
    }
    else {
        TRC_ERR((TB, _T("DrawNineGrid cache memory allocation failed!")));
#ifdef OS_WINCE
        DC_QUIT;
#endif
    }
#endif

    // Preload bitmap cache registry settings.
    UHReadBitmapCacheSettings();

    _UH.hpalDefault = (HPALETTE)GetStockObject(DEFAULT_PALETTE);
    _UH.hpalCurrent = _UH.hpalDefault;

    _UH.hrgnUpdate = CreateRectRgn(0, 0, 0, 0);
    _UH.hrgnUpdateRect = CreateRectRgn(0, 0, 0, 0);

    _UH.colorIndicesEnabled  = TRUE;
    _pCc->_ccCombinedCapabilities.orderCapabilitySet.orderFlags |=
            TS_ORDERFLAGS_COLORINDEXSUPPORT;


#ifdef DC_DEBUG
    /************************************************************************/
    /* Initialize the Bitmap Cache Monitor                                  */
    /************************************************************************/
    UHInitBitmapCacheMonitor();
#endif /* DC_DEBUG */

    /************************************************************************/
    // We pass received bitmap data to StretchDIBits with the
    // CO_DIB_PAL_COLORS option, which requires a table of indices into
    // the currently selected palette in place of a color table.
    //
    // We set up this table here, as we always have a simple 1-1
    // mapping. Start from 1 since we zeroed the 1st entry with the memset
    // above.
    /************************************************************************/
    pIndexTable = &(_UH.bitmapInfo.paletteIndexTable[1]);
    for (i = 1; i < 256; i++)
        *pIndexTable++ = (UINT16)i;
    _UH.bitmapInfo.bIdentityPalette = TRUE;

    /************************************************************************/
    /* Set up the codepage                                                  */
    /************************************************************************/
    _pCc->_ccCombinedCapabilities.orderCapabilitySet.textANSICodePage =
            (UINT16)_pUt->UT_GetANSICodePage();

    /************************************************************************/
    /* Read the update frequency                                            */
    /************************************************************************/
    _UH.drawThreshold = _pUi->_UI.orderDrawThreshold;
    if (_UH.drawThreshold == 0)
    {
        _UH.drawThreshold = (DCUINT)(-1);
    }
    TRC_NRM((TB, _T("Draw output every %d orders"), _UH.drawThreshold));

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

    /************************************************************************/
    // Grab the mstsc's executable path for use in managing bitmap caches as
    // default.  _UH.EndPersistCacheDir points to the '\0' after the path.
    /************************************************************************/
#ifdef OS_WINNT
    if (_UH.PersistCacheFileName[0] == _T('\0')) {
#define CACHE_PROFILE_NAME _T("\\Microsoft\\Terminal Server Client\\Cache\\")

// for NT5, by default, we should place the cache directory at the user profile
// location instead of where the client is installed

        HRESULT hr = E_FAIL;
#ifdef UNIWRAP
        //Call the uniwrap SHGetFolderPath, it does the necessary dynamic
        //binding and will thunk to ANSI on Win9x
        hr = SHGetFolderPathWrapW(NULL, CSIDL_LOCAL_APPDATA|CSIDL_FLAG_CREATE,
                        NULL, 0, _UH.PersistCacheFileName);
#else //UNIWRAP not defined
        HMODULE hmodSH32DLL;

#ifdef UNICODE
        typedef HRESULT (STDAPICALLTYPE FNSHGetFolderPath)(HWND, int, HANDLE, DWORD, LPWSTR);
#else
        typedef HRESULT (STDAPICALLTYPE FNSHGetFolderPath)(HWND, int, HANDLE, DWORD, LPSTR);
#endif
        FNSHGetFolderPath *pfnSHGetFolderPath;

        // get the handle to shell32.dll library
        hmodSH32DLL = LoadLibrary(TEXT("SHELL32.DLL"));

        if (hmodSH32DLL != NULL) {
            // get the proc address for SHGetFolderPath
#ifdef UNICODE
            pfnSHGetFolderPath = (FNSHGetFolderPath *)GetProcAddress(hmodSH32DLL, "SHGetFolderPathW");
#else
            pfnSHGetFolderPath = (FNSHGetFolderPath *)GetProcAddress(hmodSH32DLL, "SHGetFolderPathA");
#endif
            // get the user profile local application data location
            if (pfnSHGetFolderPath != NULL) {
                hr = (*pfnSHGetFolderPath) (NULL, CSIDL_LOCAL_APPDATA|CSIDL_FLAG_CREATE,
                        NULL, 0, _UH.PersistCacheFileName);
            }

            FreeLibrary(hmodSH32DLL);
        }
#endif //UNIWRAP

        if (SUCCEEDED(hr)) // did  SHGetFolderPath succeed
        {
            _UH.EndPersistCacheDir = _tcslen(_UH.PersistCacheFileName);
            if (_UH.EndPersistCacheDir +
                sizeof(CACHE_PROFILE_NAME)/sizeof(TCHAR) + 1< MAX_PATH) {

                //LENGTH is validated above
                StringCchCopy(_UH.PersistCacheFileName + _UH.EndPersistCacheDir,
                              MAX_PATH,
                              CACHE_PROFILE_NAME);
            }
        }
    }
#endif //OS_WINNT

    if (_UH.PersistCacheFileName[0] == _T('\0')) {
#ifdef OS_WINCE
        //
        // First let's see if there is a storage card.
        // and if there is enough space in there, then we will use it.
        //
        DWORDLONG tmpDiskSize = 0;
        UINT32 BytesPerSector = 0, SectorsPerCluster = 0, TotalNumberOfClusters = 0, FreeClusters = 0;

        // If we're scaling the bitmap caches by the bit depth, test disk
        // space for 24-bit depth, otherwise test simply for 8bpp.
        if (UHGetDiskFreeSpace(
                WINCE_STORAGE_CARD_DIRECTORY,
                (PULONG)&SectorsPerCluster,
                (PULONG)&BytesPerSector,
                (PULONG)&FreeClusters,
                (PULONG)&TotalNumberOfClusters))
        { 
            //The cast is needed to do 64bit math, without it we have
            //an overflow problem
            tmpDiskSize = (DWORDLONG)BytesPerSector * SectorsPerCluster * FreeClusters;
            if(tmpDiskSize >= (_UH.RegBitmapCacheSize *
                              (_UH.RegScaleBitmapCachesByBPP ? 3 : 1)))
            {
                bUseStorageCard = TRUE;
                _tcscpy(_UH.PersistCacheFileName, WINCE_STORAGE_CARD_DIRECTORY);
                _tcscat(_UH.PersistCacheFileName, CACHE_DIRECTORY_NAME);
            }
        }
        else {
#endif
        _UH.EndPersistCacheDir = GetModuleFileName(_pUi->UI_GetInstanceHandle(),
                _UH.PersistCacheFileName, MAX_PATH - sizeof(CACHE_DIRECTORY_NAME)/sizeof(TCHAR));
        if (_UH.EndPersistCacheDir > 0) {
            // Strip the module name off the end to leave the executable
            // directory path, by looking for the last backslash.
            _UH.EndPersistCacheDir--;
            while (_UH.EndPersistCacheDir != 0) {
                if (_UH.PersistCacheFileName[_UH.EndPersistCacheDir] != _T('\\')) {
                    _UH.EndPersistCacheDir--;
                    continue;
                }

                _UH.EndPersistCacheDir++;
                break;
            }

            // we should set up persistent cache disk directory
            _UH.PersistCacheFileName[_UH.EndPersistCacheDir] = _T('\0');

            // Check we have enough space for the base path + the dir name
            if ((_UH.EndPersistCacheDir +
                _tcslen(CACHE_DIRECTORY_NAME) + 1) < MAX_PATH) {

                //
                // Length checked above
                //
                StringCchCopy(_UH.PersistCacheFileName + _UH.EndPersistCacheDir,
                              MAX_PATH,
                              CACHE_DIRECTORY_NAME);
            }
            else {
                _UH.bPersistenceDisable = TRUE;
            }
            
        }
        else {
            // since we can't find the mstsc path, we can't determine where
            // to store the bitmaps on disk.  So, we simply disable the
            // persistence bitmap here
            _UH.bPersistenceDisable = TRUE;
            TRC_ERR((TB,_T("GetModuleFileName() error, could not retrieve path")));
        }
#ifdef OS_WINCE // OS_WINCE
        }
#endif // OS_WINCE
    }
    _UH.EndPersistCacheDir = _tcslen(_UH.PersistCacheFileName);

    // Make sure _UH.PersistCacheFileName ends with a \ for directory name
    if (_UH.PersistCacheFileName[_UH.EndPersistCacheDir - 1] != _T('\\')) {
        _UH.PersistCacheFileName[_UH.EndPersistCacheDir] = _T('\\');
        _UH.PersistCacheFileName[++_UH.EndPersistCacheDir] = _T('\0');
    }

    // Check that our path is not too long to contain the base path
    // plus each cache filename.  If so, we can't use the path.
    if ((_UH.EndPersistCacheDir + CACHE_FILENAME_LENGTH + 1) >= MAX_PATH) {
        TRC_ERR((TB,_T("Base cache path \"%s\" too long, cannot load ")
                _T("persistent bitmaps"), _UH.PersistCacheFileName));
        _UH.bPersistenceDisable = TRUE;
    }

    /*********************************************************************/
    // To make sure we have enough space to hold the virtual memory cache
    // we should check the free disk space
    /*********************************************************************/
    // make sure we don't have a UNC app path
#ifndef OS_WINCE
    if (_UH.PersistCacheFileName[0] != _T('\\')) {
#else
    if (_UH.PersistCacheFileName[0] != _T('\0')) {   // path in wince is of the form "\Windows\Cache"
#endif
        UINT32    BytesPerSector = 0, SectorsPerCluster = 0, TotalNumberOfClusters = 0;

#ifndef OS_WINCE
        TCHAR       RootPath[4];
        _tcsncpy(RootPath, _UH.PersistCacheFileName, 3);
        RootPath[3] = _T('\0');
#endif

        // Get disk information
        if (UHGetDiskFreeSpace(
#ifndef OS_WINCE
            RootPath,
#else
            (bUseStorageCard) ? WINCE_STORAGE_CARD_DIRECTORY : WINCE_FILE_SYSTEM_ROOT ,
#endif
            (PULONG)&SectorsPerCluster,
            (PULONG)&BytesPerSector,
            &_UH.NumberOfFreeClusters,
            (PULONG)&TotalNumberOfClusters)) {
            _UH.BytesPerCluster = BytesPerSector * SectorsPerCluster;
        }
        else {
            // we can't get disk info, we have to turn the persistent flag off
            _UH.bPersistenceDisable = TRUE;
       }
    }
    else {
        // we don't support network disk
        _UH.bPersistenceDisable = TRUE;
    }

    /*********************************************************************/
    // If the persistent is not disabled,we need to lock the persistent disk
    // cache before another session grabs it.  If we failed to get the cache
    // lock, persistent caching is not supported for this session
    /*********************************************************************/
    if (!_UH.bPersistenceDisable) {
        unsigned len;

        // Compose lock name, it's based on the cache directory name
#if (defined(OS_WINCE))
        _tcscpy(_UH.PersistentLockName, TEXT("MSTSC_"));
        len = _tcslen(_UH.PersistentLockName);
#else
        // For Terminal server platforms, we need to use global in
        // persistentlockname to make sure the locking is cross sessions.
        // but on non-terminal server NT platforms, we can't use global
        // as the lock name. (in createmutex)
        if (_pUt->UT_IsTerminalServicesEnabled()) {
            hr =  StringCchCopy(_UH.PersistentLockName,
                                SIZE_TCHARS(_UH.PersistentLockName),
                                TEXT("Global\\MSTSC_"));
        }
        else {
            hr = StringCchCopy(_UH.PersistentLockName,
                               SIZE_TCHARS(_UH.PersistentLockName),
                               TEXT("MSTSC_"));
        }
        //Lock name should fit since it's a fixed format
        TRC_ASSERT(SUCCEEDED(hr),
                   (TB,_T("Error copying persistent lock name: 0x%x"), hr));
        len = _tcslen(_UH.PersistentLockName);
#endif
        for (i = 0; i < _UH.EndPersistCacheDir; i++) {
            // Tried to use _istalnum for 2nd clause, but CRTDLL doesn't
            // like it.
            if (_UH.PersistCacheFileName[i] == _T('\\'))
                _UH.PersistentLockName[len++] = _T('_');
            else if ((_UH.PersistCacheFileName[i] >= _T('0') &&
                    _UH.PersistCacheFileName[i] <= _T('9')) ||
                    (_UH.PersistCacheFileName[i] >= _T('A') &&
                    _UH.PersistCacheFileName[i] <= _T('Z')) ||
                    (_UH.PersistCacheFileName[i] >= _T('a') &&
                    _UH.PersistCacheFileName[i] <= _T('z')))
                _UH.PersistentLockName[len++] = _UH.PersistCacheFileName[i];
        }
        _UH.PersistentLockName[len] = _T('\0');

        // try to lock the cache directory for persistent caching
        if (!UHGrabPersistentCacheLock()) {
            _UH.bPersistenceDisable = TRUE;
        }
    }

    /********************************************************************/
    // We need to enumerate the disk to get the bitmap key database
    // The client will always enumerate the keys even the persistent
    // caching option might be changed later on.
    /********************************************************************/
    if (!_UH.bPersistenceDisable) {
            _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                CD_NOTIFICATION_FUNC(CUH,UHEnumerateBitmapKeyList), 0);
    }
#endif  // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
#ifdef DRAW_GDIPLUS
    // Initialize fGdipEnabled
    _UH.fGdipEnabled = FALSE;
#endif

#ifdef OS_WINCE
    bSuccess = TRUE;
DC_EXIT_POINT:
    if (!bSuccess)
    {
        _pCd->CD_DecoupleSimpleNotification(CD_UI_COMPONENT,
                                      _pUi,
                                      CD_NOTIFICATION_FUNC(CUI,UI_FatalError),
                                      (ULONG_PTR) DC_ERR_OUTOFMEMORY);
    }
#endif
    DC_END_FN();
} /* UH_Init */

/****************************************************************************/
// UH_Term
//
// Terminates _UH. Called on app exit.
/****************************************************************************/
DCVOID DCAPI CUH::UH_Term(DCVOID)
{

    DC_BEGIN_FN("UH_Term");

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

    // unlock the persistent cache directory if this session locked it earlier
    UHReleasePersistentCacheLock();

#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

#ifdef DRAW_GDIPLUS
    UHDrawGdiplusShutdown(0);
#endif

    /************************************************************************/
    /*  Free off any bitmaps that are specific to the connection.           */
    /************************************************************************/
    if (NULL != _UH.hShadowBitmap)
    {
        /********************************************************************/
        /* Delete the Shadow Bitmap.                                        */
        /********************************************************************/
        TRC_NRM((TB, _T("Delete the Shadow Bitmap")));
        UHDeleteBitmap(&_UH.hdcShadowBitmap,
                       &_UH.hShadowBitmap,
                       &_UH.hunusedBitmapForShadowDC);
    }

    if (NULL != _UH.hSaveScreenBitmap)
    {
        /********************************************************************/
        /* Delete the Save Bitmap.                                          */
        /********************************************************************/
        TRC_NRM((TB, _T("Delete save screen bitmap")));
        UHDeleteBitmap(&_UH.hdcSaveScreenBitmap,
                       &_UH.hSaveScreenBitmap,
                       &_UH.hunusedBitmapForSSBDC);
    }

    if (NULL != _UH.hbmpDisconnectedBitmap) {
        UHDeleteBitmap(&_UH.hdcDisconnected,
                       &_UH.hbmpDisconnectedBitmap,
                       &_UH.hbmpUnusedDisconnectedBitmap);
    }


    // Delete all the offscreen bitmaps
    if (NULL != _UH.hdcOffscreenBitmap) {
        unsigned i;
    
        for (i = 0; i < _UH.offscrCacheEntries; i++) {
            if (_UH.offscrBitmapCache[i].offscrBitmap) {
                SelectBitmap(_UH.hdcOffscreenBitmap, 
                        _UH.hUnusedOffscrBitmap);
                DeleteBitmap(_UH.offscrBitmapCache[i].offscrBitmap);
            }
        }
    }

#ifdef DRAW_NINEGRID
    // Delete all the drawNineGrid bitmaps
    if (NULL != _UH.hdcDrawNineGridBitmap) {
        unsigned i;
    
        for (i = 0; i < _UH.drawNineGridCacheEntries; i++) {
            if (_UH.drawNineGridBitmapCache[i].drawNineGridBitmap) {
                SelectBitmap(_UH.hdcDrawNineGridBitmap, 
                        _UH.hUnusedDrawNineGridBitmap);
                DeleteBitmap(_UH.drawNineGridBitmapCache[i].drawNineGridBitmap);
            }
        }
    }
#endif

#ifdef DC_DEBUG
    /************************************************************************/
    /* Terminate the Bitmap Cache Monitor                                   */
    /************************************************************************/
    UHTermBitmapCacheMonitor();
#endif /* DC_DEBUG */

    DeleteRgn(_UH.hrgnUpdate);
    DeleteRgn(_UH.hrgnUpdateRect);

    UHFreeCacheMemory();

    /************************************************************************/
    // Free the palette (if not the default). This needs to happen after
    // freeing bitmap cache resources so the palettes can be written to disk
    // with the bitmap files.
    /************************************************************************/
    if ((_UH.hpalCurrent != NULL) && (_UH.hpalCurrent != _UH.hpalDefault))
    {
        TRC_NRM((TB, _T("Delete current palette %p"), _UH.hpalCurrent));
        DeletePalette(_UH.hpalCurrent);
    }

    /************************************************************************/
    // If we created a decompression buffer, get rid of it now.
    /************************************************************************/
    if (_UH.bitmapDecompressionBuffer != NULL) {
        UT_Free( _pUt, _UH.bitmapDecompressionBuffer);
        _UH.bitmapDecompressionBuffer = NULL;
        _UH.bitmapDecompressionBufferSize = 0;
    }

    /************************************************************************/
    // Release cached glyph resources
    /************************************************************************/
    if (_UH.hdcGlyph != NULL)
    {
        DeleteDC(_UH.hdcGlyph);
        _UH.hdcGlyph = NULL;
    }

    if (_UH.hbmGlyph != NULL)
    {
        DeleteObject(_UH.hbmGlyph);
        _UH.hbmGlyph = NULL;
    }

    if (_UH.hdcBrushBitmap != NULL)
    {
        DeleteDC(_UH.hdcBrushBitmap);
        _UH.hdcBrushBitmap = NULL;
    }

    // Release the offscreen bitmap DC
    if (_UH.hdcOffscreenBitmap != NULL) {
        DeleteDC(_UH.hdcOffscreenBitmap);
    }

#ifdef DRAW_NINEGRID
    // Release the drawninegrid bitmap DC
    if (_UH.hdcDrawNineGridBitmap != NULL) {
        DeleteDC(_UH.hdcDrawNineGridBitmap);
        _UH.hdcDrawNineGridBitmap = NULL;
    }

    if (_UH.hDrawNineGridClipRegion != NULL) {
        DeleteObject(_UH.hDrawNineGridClipRegion);
        _UH.hdcDrawNineGridBitmap = NULL;
    }

    if (_UH.drawNineGridDecompressionBuffer != NULL) {
        UT_Free( _pUt, _UH.drawNineGridDecompressionBuffer);
        _UH.drawNineGridDecompressionBuffer = NULL;
        _UH.drawNineGridDecompressionBufferSize = 0;
    }

    if (_UH.drawNineGridAssembleBuffer != NULL) {
        UT_Free( _pUt, _UH.drawNineGridAssembleBuffer);
        _UH.drawNineGridAssembleBuffer = NULL;
    }

    if (_UH.hModuleGDI32 != NULL) { 
        FreeLibrary(_UH.hModuleGDI32);
        _UH.hModuleGDI32 = NULL;
    }

    if (_UH.hModuleMSIMG32 != NULL) { 
        FreeLibrary(_UH.hModuleMSIMG32);
        _UH.hModuleMSIMG32 = NULL;
    }
#endif

    _pClientObjects->ReleaseObjReference(UH_OBJECT_FLAG);

    DC_END_FN();
} /* UH_Term */

#ifdef DC_DEBUG
/****************************************************************************/
/* Name:      UH_ChangeDebugSettings                                        */
/*                                                                          */
/* Purpose:   Changes the current debug settings.                           */
/*                                                                          */
/* Params:    IN - flags:                                                   */
/*                   CO_CFG_FLAG_HATCH_BITMAP_PDU_DATA                      */
/*                   CO_CFG_FLAG_HATCH_SSB_ORDER_DATA                       */
/*                   CO_CFG_FLAG_HATCH_MEMBLT_ORDER_DATA                    */
/*                   CO_CFG_FLAG_LABEL_MEMBLT_ORDERS                        */
/*                   CO_CFG_FLAG_BITMAP_CACHE_MONITOR                       */
/****************************************************************************/
DCVOID DCAPI CUH::UH_ChangeDebugSettings(ULONG_PTR flags)
{
    DC_BEGIN_FN("UH_ChangeDebugSettings");

    TRC_NRM((TB, _T("flags %#x"), flags));

    _UH.hatchBitmapPDUData =
         TEST_FLAG(flags, CO_CFG_FLAG_HATCH_BITMAP_PDU_DATA) ? TRUE : FALSE;

    _UH.hatchIndexPDUData =
         TEST_FLAG(flags, CO_CFG_FLAG_HATCH_INDEX_PDU_DATA) ? TRUE : FALSE;

    _UH.hatchSSBOrderData =
         TEST_FLAG(flags, CO_CFG_FLAG_HATCH_SSB_ORDER_DATA) ? TRUE : FALSE;

    _UH.hatchMemBltOrderData =
         TEST_FLAG(flags, CO_CFG_FLAG_HATCH_MEMBLT_ORDER_DATA) ? TRUE : FALSE;

    _UH.labelMemBltOrders =
         TEST_FLAG(flags, CO_CFG_FLAG_LABEL_MEMBLT_ORDERS) ? TRUE : FALSE;

    _UH.showBitmapCacheMonitor =
         TEST_FLAG(flags, CO_CFG_FLAG_BITMAP_CACHE_MONITOR) ? TRUE : FALSE;

    ShowWindow( _UH.hwndBitmapCacheMonitor,
                _UH.showBitmapCacheMonitor ? SW_SHOWNOACTIVATE :
                                            SW_HIDE );

    DC_END_FN();
}
#endif /* DC_DEBUG */


/****************************************************************************/
// UH_SetConnectOptions
//
// Called on receive thread at session connect time. Takes some connection
// flags from CC and does connect-time init.
//
// Params:    connectFlags - flags used to determine whether to enable
//            the Shadow Bitmap and SaveScreenBitmap order support.
/****************************************************************************/
DCVOID DCAPI CUH::UH_SetConnectOptions(ULONG_PTR connectFlags)
{
    DC_BEGIN_FN("UH_SetConnectOptions");

    /************************************************************************/
    /* Get the flags out.                                                   */
    /************************************************************************/
    _UH.shadowBitmapRequested = ((connectFlags &
            CO_CONN_FLAG_SHADOW_BITMAP_ENABLED) ? TRUE : FALSE);
    _UH.dedicatedTerminal = ((connectFlags & CO_CONN_FLAG_DEDICATED_TERMINAL) ?
            TRUE : FALSE);

    TRC_NRM((TB, _T("Flags from CC shadow(%u), terminal(%u)"),
             _UH.shadowBitmapRequested, _UH.dedicatedTerminal));

    /************************************************************************/
    /* Set the capabilities to not support SSB and ScreenBlt orders by      */
    /* default.  These are only supported if the shadow bitmap is enabled.  */
    /************************************************************************/
    _pCc->_ccCombinedCapabilities.orderCapabilitySet.orderSupport[
                                                 TS_NEG_SAVEBITMAP_INDEX] = 0;
    _pCc->_ccCombinedCapabilities.orderCapabilitySet.orderSupport[
                                                     TS_NEG_SCRBLT_INDEX] = 0;

    // We have not yet sent the persistent bitmap cache keys in this session.
    _UH.bPersistentBitmapKeysSent = FALSE;

    // We have not yet set up the post-DemandActivePDU capabilities for bitmap
    // caching, nor allocated the caches.
    _UH.bEnabledOnce = FALSE;

    DC_END_FN();
} /* UH_SetConnectOptions */


/****************************************************************************/
// UH_BufferAvailable
//
// When there is available buffer, we try to send the persistent keys
// and the font list
/****************************************************************************/
VOID DCAPI CUH::UH_BufferAvailable(VOID)
{
    DC_BEGIN_FN("UH_BufferAvailable");

    // UH_BufferAvailable is called when there is an available send
    // buffer.  If so, it tries to send persistent key list if any,
    // and the font list
    UH_SendPersistentKeysAndFontList();

    DC_END_FN();
}


/****************************************************************************/
// UH_SendPersistentKeysAndFontList
//
// Send persistent key list followed by font list if they are ready to be
// send.  If we don't have to send any persistent key list, we simply send
// font list directly.
/****************************************************************************/
void DCAPI CUH::UH_SendPersistentKeysAndFontList(void)
{
    DC_BEGIN_FN("UH_BufferAvailable");

    if (_UH.bEnabled) {
#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
        if (_UH.bPersistenceActive) {
            if (_UH.bBitmapKeyEnumComplete) {
                if (!_UH.bPersistentBitmapKeysSent)
                {
                    if (_UH.currentCopyMultiplier == _UH.copyMultiplier)
                    {
                        //Great we've enumerated keys for the correct
                        //copy multiplier
                        UHSendPersistentBitmapKeyList(0);
                    }
                    else
                    {
                        //
                        // We got connected at a different copy multiplier
                        // need to enumerate keys again. Reset enumeration state
                        //
                        UHResetAndRestartEnumeration();
                    }
                }
                else 
                {
                    _pFs->FS_SendZeroFontList(0);                                    
                }                   
            }
        }
        else {
#endif //((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
            _pFs->FS_SendZeroFontList(0);
#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
        }
#endif //((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    }
    DC_END_FN();
}


/****************************************************************************/
// UH_Enable
//
// Enables _UH. Called on receive thread after receipt of DemandActivePDU
// containing the server-side capabilities, but before client caps are
// returned with a ConfirmActivePDU.
//
// Params:    IN  unused - required by the component decoupler.
/****************************************************************************/
void DCAPI CUH::UH_Enable(ULONG_PTR unused)
{
    HBRUSH hbr;
    RECT   rect;
    DCSIZE desktopSize;
#ifdef DRAW_GDIPLUS
    unsigned ProtocolColorDepth;
    unsigned rc;
#endif

#ifdef DC_HICOLOR
    int colorDepth;
    UINT16 FAR *pIndexTable;
    DWORD *pColorTable;
    unsigned i;
#endif

    DC_BEGIN_FN("UH_Enable");

    DC_IGNORE_PARAMETER(unused);

    if (NULL != _UH.hbmpDisconnectedBitmap) {
        UHDeleteBitmap(&_UH.hdcDisconnected,
                       &_UH.hbmpDisconnectedBitmap,
                       &_UH.hbmpUnusedDisconnectedBitmap);
    }

#ifdef DC_HICOLOR
    // Set up the bitmap color format.  Has to be first thing we do here!
    colorDepth = _pUi->UI_GetColorDepth();
    if ((colorDepth == 4) || (colorDepth == 8)) {
        TRC_NRM((TB, _T("Low color - use PAL")));
        _UH.DIBFormat      = DIB_PAL_COLORS;
        _UH.copyMultiplier = 1;
        _UH.protocolBpp    = 8;
        _UH.bitmapBpp      = 8;

        _UH.bitmapInfo.hdr.biCompression = BMCRGB;
        _UH.bitmapInfo.hdr.biBitCount    = 8;
        _UH.bitmapInfo.hdr.biClrUsed     = 0;

        // Update the color table cache - if we've previously connected at
        // a high color depth, the bitcounts will be wrong.
        if (_UH.pMappedColorTableCache) {
            TRC_DBG((TB, _T("Update color table cache to 8bpp")));
            for (i = 0; i < UH_COLOR_TABLE_CACHE_ENTRIES; i++) {
                _UH.pMappedColorTableCache[i].hdr.biBitCount    = 8;
                _UH.pMappedColorTableCache[i].hdr.biCompression = BI_RGB;
                _UH.pMappedColorTableCache[i].hdr.biClrUsed     = 0;

                pColorTable = (DWORD *)
                        _UH.pMappedColorTableCache[i].paletteIndexTable;
                pColorTable[0] = 0;
                pColorTable[1] = 0;
                pColorTable[2] = 0;

                // We default to identity palette flag set for 4 and 8 bits,
                // this may be changed when the server sends a color table.
                _UH.pMappedColorTableCache[i].bIdentityPalette = TRUE;
            }
        }

        // Similarly, a high color connection may have overwritten some
        // entries here too.
        pIndexTable = _UH.bitmapInfo.paletteIndexTable;
        for (i = 0; i < 256; i++)
            *pIndexTable++ = (UINT16)i;
        _UH.bitmapInfo.bIdentityPalette = TRUE;
    }
    else {
        TRC_NRM((TB, _T("Hi color - use RGB")));
        _UH.DIBFormat      = DIB_RGB_COLORS;
        _UH.protocolBpp    = colorDepth;

        // Since we don't use palettes for these color depths,
        // set the BitmapPDU palette identity flag so UHDIBCopyBits() will
        // always do a straight copy.
        _UH.bitmapInfo.bIdentityPalette = TRUE;

        if (colorDepth == 24) {
            TRC_DBG((TB, _T("24bpp")));
            _UH.bitmapInfo.hdr.biBitCount    = 24;
            _UH.bitmapBpp                    = 24;
            _UH.copyMultiplier               = 3;
            _UH.bitmapInfo.hdr.biCompression = BI_RGB;
            _UH.bitmapInfo.hdr.biClrUsed     = 0;

            // Update the color table cache - though we won't use the color
            // tables as such, the bitmap info will be used.
            if (_UH.pMappedColorTableCache) {
                TRC_DBG((TB, _T("Update color table cache to 24bpp")));
                for (i = 0; i < UH_COLOR_TABLE_CACHE_ENTRIES; i++)
                {
                    _UH.pMappedColorTableCache[i].hdr.biBitCount    = 24;
                    _UH.pMappedColorTableCache[i].hdr.biCompression = BI_RGB;
                    _UH.pMappedColorTableCache[i].hdr.biClrUsed     = 0;

                    pColorTable = (DWORD *)
                               _UH.pMappedColorTableCache[i].paletteIndexTable;
                    pColorTable[0] = 0;
                    pColorTable[1] = 0;
                    pColorTable[2] = 0;

                    // Since we don't use palettes for this color depth,
                    // set the palettes to identity so UHDIBCopyBits() will
                    // always do a straight copy.
                    _UH.pMappedColorTableCache[i].bIdentityPalette = TRUE;
                }
            }
        }
        else if (colorDepth == 16) {
            TRC_DBG((TB, _T("16bpp - 565")));

            // 16 bpp uses two bytes, with the color masks defined in the
            // bmiColors field.  This is supposedly in the order R, G, B,
            // but as ever we have to swap R & B...
            // - LS   5 bits = blue       = 0x001f
            // - next 6 bits = green mask = 0x07e0
            // - next 5 bits = red mask   = 0xf800
            _UH.bitmapInfo.hdr.biBitCount    = 16;
            _UH.bitmapBpp                    = 16;
            _UH.copyMultiplier               = 2;
            _UH.bitmapInfo.hdr.biCompression = BI_BITFIELDS;
            _UH.bitmapInfo.hdr.biClrUsed     = 3;

            pColorTable    = (DWORD *)_UH.bitmapInfo.paletteIndexTable;
            pColorTable[0] = TS_RED_MASK_16BPP;
            pColorTable[1] = TS_GREEN_MASK_16BPP;
            pColorTable[2] = TS_BLUE_MASK_16BPP;

            // Update the color table cache - though we won't use the color
            // tables as such, the bitmap info will be used.
            if (_UH.pMappedColorTableCache) {
                TRC_DBG((TB, _T("Update color table cache to 16bpp")));
                for (i = 0; i < UH_COLOR_TABLE_CACHE_ENTRIES; i++) {
                    _UH.pMappedColorTableCache[i].hdr.biBitCount = 16;
                    _UH.pMappedColorTableCache[i].hdr.biCompression =
                            BI_BITFIELDS;
                    _UH.pMappedColorTableCache[i].hdr.biClrUsed = 3;

                    pColorTable = (DWORD *)
                            _UH.pMappedColorTableCache[i].paletteIndexTable;
                    pColorTable[0] = TS_RED_MASK_16BPP;
                    pColorTable[1] = TS_GREEN_MASK_16BPP;
                    pColorTable[2] = TS_BLUE_MASK_16BPP;

                    // Since we don't use palettes for this color depth,
                    // set the palettes to identity so UHDIBCopyBits() will
                    // always do a straight copy.
                    _UH.pMappedColorTableCache[i].bIdentityPalette = TRUE;
                }
            }
        }
        else if (colorDepth == 15) {
            TRC_DBG((TB, _T("15bpp - 16bpp & 555")));

            // 15 bpp uses two bytes with - least significant 5 bits = blue
            // - next 5 bits = green - next 5 = red - most significant bit
            // = Not used
            // Note that we still have to claim to be 16 bpp to the bitmap
            // functions...
            _UH.bitmapInfo.hdr.biBitCount    = 16;
            _UH.bitmapBpp                    = 16;
            _UH.copyMultiplier               = 2;
            _UH.bitmapInfo.hdr.biCompression = BI_RGB;
            _UH.bitmapInfo.hdr.biClrUsed     = 0;

            // Update the color table cache - though we won't use the color
            // tables as such, the bitmap info will be used.
            if (_UH.pMappedColorTableCache)
            {
                TRC_DBG((TB, _T("Update color table cache to 15bpp")));
                for (i = 0; i < UH_COLOR_TABLE_CACHE_ENTRIES; i++)
                {
                    _UH.pMappedColorTableCache[i].hdr.biBitCount    = 16;
                    _UH.pMappedColorTableCache[i].hdr.biCompression = BI_RGB;
                    _UH.pMappedColorTableCache[i].hdr.biClrUsed     = 0;

                    pColorTable = (DWORD *)
                               _UH.pMappedColorTableCache[i].paletteIndexTable;
                    pColorTable[0] = 0;
                    pColorTable[1] = 0;
                    pColorTable[2] = 0;

                    // Since we don't use palettes for this color depth,
                    // set the palettes to identity so UHDIBCopyBits() will
                    // always do a straight copy.
                    _UH.pMappedColorTableCache[i].bIdentityPalette = TRUE;
                }
            }
        }
        else {
            TRC_ABORT((TB, _T("Unsupported color depth")));
        }
    }
#endif //HICOLOR

    // Check and see if we have already set up the caps and allocated the
    // memory. If so, don't repeat the work since we are simply reconnecting
    // instead of disconnecting.
    if (!_UH.bEnabledOnce)
    {
        _UH.bEnabledOnce = TRUE;

        TRC_ALT((TB, _T("Doing one-time enabling")));

        // We are connected.
        _UH.bConnected = TRUE;

#ifdef DISABLE_SHADOW_IN_FULLSCREEN
        _UH.DontUseShadowBitmap = FALSE;
#endif

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
        // reset flags
        _UH.sendBitmapCacheId = 0;
        _UH.sendBitmapCacheIndex = 0;
        _UH.sendNumBitmapKeys = 0;
        _UH.totalNumKeyEntries = 0;
        _UH.totalNumErrorPDUs = 0;
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

        _UH.bWarningDisplayed = FALSE;
        _UH.bPersistentBitmapKeysSent = FALSE;

        // No matter what we have to make sure the capabilities are initialized
        // to empty -- any leftover settings from the previous connection are
        // invalid. Also make sure it's set to rev1 caps so that the server
        // will disable bitmap caching if the bitmap caches cannot be
        // allocated.
        memset(&_pCc->_ccCombinedCapabilities.bitmapCacheCaps, 0,
                sizeof(TS_BITMAPCACHE_CAPABILITYSET));
        _pCc->_ccCombinedCapabilities.bitmapCacheCaps.lengthCapability =
                sizeof(TS_BITMAPCACHE_CAPABILITYSET);
        _pCc->_ccCombinedCapabilities.bitmapCacheCaps.capabilitySetType =
                TS_CAPSETTYPE_BITMAPCACHE;


        // Allocate the bitmap cache memory. This is done during connect time
        // because we depend on the server capabilities already processed in
        // UH_ProcessBCHostSupportCaps. It is also dependent on the color table
        // cache having been allocated on app init.
        if (_UH.pColorTableCache != NULL && _UH.pMappedColorTableCache != NULL) {
            UHAllocBitmapCacheMemory();
            _UH.fBmpCacheMemoryAlloced = TRUE;
        }
        else {
            TRC_ERR((TB,_T("Color table cache did not alloc, not allocating bitmap ")
                    _T("cache memory and caps")));
        }
#ifdef DRAW_GDIPLUS
        // Allocate the drawgdiplus cache
        if (UHAllocDrawGdiplusCacheMemory()) {
            TRC_NRM((TB, _T("DrawGdiplus cache memory OK")));
        }
        else {
            TRC_ALT((TB, _T("DrawGdiplus cache memory allocation failed!")));
        }  
#endif

#ifdef DC_DEBUG
        // Reset the Bitmap Cache Monitor.
        UHEnableBitmapCacheMonitor();
#endif /* DC_DEBUG */

#ifdef DC_HICOLOR
        // Allocate the screen data decompression buffer, allowing enough
        // space for 24bpp regardless of the actual depth, as we might find
        // ourselves shadowing a 24bpp session without the opportunity to
        // reallocate it. We don't check for success here since we can't
        // return an init error. Instead, we check the pointer whenever we
        // decode screen data.
        _UH.bitmapDecompressionBufferSize = max(
               UH_DECOMPRESSION_BUFFER_LENGTH,
               (TS_BITMAPCACHE_0_CELL_SIZE << (2*(_UH.NumBitmapCaches))) * 3);
        _UH.bitmapDecompressionBuffer = (PDCUINT8)UT_Malloc( _pUt, _UH.bitmapDecompressionBufferSize);
#else
        // Allocate the screen data decompression buffer. We don't check for
        // success here since we can't return an init error. Instead, we
        // check the pointer whenever we decode screen data.
        _UH.bitmapDecompressionBufferSize = max(
                UH_DECOMPRESSION_BUFFER_LENGTH,
                UH_CellSizeFromCacheID(_UH.NumBitmapCaches));
        _UH.bitmapDecompressionBuffer = (PBYTE)UT_Malloc( _pUt, _UH.bitmapDecompressionBufferSize);
#endif //HICOLOR

        if (NULL == _UH.bitmapDecompressionBuffer) {
            _UH.bitmapDecompressionBufferSize = 0;
        }

#ifdef OS_WINCE
        if (_UH.bitmapDecompressionBuffer == NULL)
            _pUi->UI_FatalError(DC_ERR_OUTOFMEMORY);
#endif
        // Get a DC for the Output Window.
        _UH.hdcOutputWindow = GetDC(_pOp->OP_GetOutputWindowHandle());
        TRC_ASSERT(_UH.hdcOutputWindow, (TB,_T("_UH.hdcOutputWindow is NULL, GetDC failed")));
        if (!_UH.hdcOutputWindow)
            _pUi->UI_FatalError(DC_ERR_OUTOFMEMORY);
        
        // Reset maxColorTableId. We only expect to reset our color cache
        // once in a session.
        _UH.maxColorTableId = -1;
    }
#ifdef DC_HICOLOR
    else if (_UH.BitmapCacheVersion > TS_BITMAPCACHE_REV1) {
        // 
        // If the new color depth doesn't match the one we enumerated
        // keys for the block persitent caching
        //
        if (_UH.currentCopyMultiplier != _UH.copyMultiplier)
        {
            TS_BITMAPCACHE_CAPABILITYSET_REV2 *pRev2Caps;
            pRev2Caps = (TS_BITMAPCACHE_CAPABILITYSET_REV2 *)
                    &_pCc->_ccCombinedCapabilities.bitmapCacheCaps;

            for (i = 0; i < _UH.NumBitmapCaches; i++) {
                CALC_NUM_CACHE_ENTRIES(_UH.bitmapCache[i].BCInfo.NumEntries,
                        _UH.bitmapCache[i].BCInfo.OrigNumEntries,
                        _UH.bitmapCache[i].BCInfo.MemLen - UH_CellSizeFromCacheID(i), i);

                TRC_ALT((TB, _T("Cache %d has %d entries"), i,
                        _UH.bitmapCache[i].BCInfo.NumEntries));

                pRev2Caps->CellCacheInfo[i].NumEntries =
                        _UH.bitmapCache[i].BCInfo.NumEntries;

                // If we've got persistent caching on, we'd better clear all
                // the cache entries to disk.	
                if (_UH.bitmapCache[i].BCInfo.NumVirtualEntries) {
                    pRev2Caps->CellCacheInfo[i].NumEntries =
                            _UH.bitmapCache[i].BCInfo.NumVirtualEntries;
                    UHInitBitmapCachePageTable(i);
                }
            }
            TRC_NRM((TB,_T("Blocking persiten cache (different col depth)")));
            _UH.bPersistenceDisable = TRUE;
        }
    }
#endif


    /************************************************************************/
    // Following items must be done on each reception of DemandActivePDU.
    /************************************************************************/
    _pUi->UI_GetDesktopSize(&desktopSize);

    // Possibly create the Shadow and Save Screen bitmaps and update the
    // capabilities in CC accordingly.
    UHMaybeCreateShadowBitmap();

    if (_UH.shadowBitmapEnabled ||
            (_UH.dedicatedTerminal &&
            (desktopSize.width  <= (unsigned)GetSystemMetrics(SM_CXSCREEN)) &&
            (desktopSize.height <= (unsigned)GetSystemMetrics(SM_CYSCREEN))))
    {
        TRC_NRM((TB, _T("OK to use ScreenBlt orders")));
        _pCc->_ccCombinedCapabilities.orderCapabilitySet.orderSupport[
                                                TS_NEG_SCRBLT_INDEX] = 1;
        _pCc->_ccCombinedCapabilities.orderCapabilitySet.orderSupport[
                                                TS_NEG_MULTISCRBLT_INDEX] = 1;
    }
    else {
        TRC_NRM((TB, _T("Cannot use ScreenBlt orders")));
        _pCc->_ccCombinedCapabilities.orderCapabilitySet.orderSupport[
                TS_NEG_SCRBLT_INDEX] = 0;
        _pCc->_ccCombinedCapabilities.orderCapabilitySet.orderSupport[
                TS_NEG_MULTISCRBLT_INDEX] = 0;
    }

    UHMaybeCreateSaveScreenBitmap();
    if (_UH.hSaveScreenBitmap != NULL) {
        TRC_NRM((TB, _T("Support SaveScreenBits orders")));
        _pCc->_ccCombinedCapabilities.orderCapabilitySet.orderSupport[
                TS_NEG_SAVEBITMAP_INDEX] = 1;
    }
    else {
        TRC_NRM((TB, _T("Cannot support SaveScreenBits orders")));
        _pCc->_ccCombinedCapabilities.orderCapabilitySet.orderSupport[
                TS_NEG_SAVEBITMAP_INDEX] = 0;
    }

    // Set the value of _UH.hdcDraw according to the value of
    // _UH.shadowBitmapEnabled.
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
    _UH.hdcDraw = !_UH.DontUseShadowBitmap ? _UH.hdcShadowBitmap :
            _UH.hdcOutputWindow;
#else
    _UH.hdcDraw = _UH.shadowBitmapEnabled ? _UH.hdcShadowBitmap :
            _UH.hdcOutputWindow;
#endif // DISABLE_SHADOW_IN_FULLSCREEN

#if defined (OS_WINCE)
    _UH.validClipDC      = NULL;
    _UH.validBkColorDC   = NULL;
    _UH.validBkModeDC    = NULL;
    _UH.validROPDC       = NULL;
    _UH.validTextColorDC = NULL;
    _UH.validPenDC       = NULL;
    _UH.validBrushDC     = NULL;
#endif

    UHResetDCState();

#ifdef OS_WINCE
    if (g_CEConfig != CE_CONFIG_WBT)
        UHGetPaletteCaps();
#endif
    TRC_DBG((TB, _T("_UH.shadowBitmapEnabled(%u) _UH.hShadowBitmap(%#hx)"),
            _UH.shadowBitmapEnabled, _UH.hShadowBitmap));
    TRC_DBG((TB, _T("_UH.hSaveScreenBitmap(%#hx)"), _UH.hSaveScreenBitmap));
    TRC_DBG((TB, _T("_UH.hdcDraw(%#hx) _UH.hdcShadowBitmap(%#hx)"),
            _UH.hdcDraw, _UH.hdcShadowBitmap));

    if (_UH.shadowBitmapEnabled) {
        // Fill Shadow Bitmap with black.
        TRC_NRM((TB, _T("Fill with black")));

#ifndef OS_WINCE
        hbr = CreateSolidBrush(RGB(0,0,0));
#else
        hbr = CECreateSolidBrush(RGB(0,0,0));
#endif

        TRC_ASSERT(hbr, (TB,_T("CreateSolidBrush failed")));
        if(hbr)
        {
            rect.left = 0;
            rect.top = 0;
            rect.right = desktopSize.width;
            rect.bottom = desktopSize.height;
    
            UH_ResetClipRegion();
    
            FillRect( _UH.hdcShadowBitmap,
                      &rect,
                      hbr );
    
#ifndef OS_WINCE
            DeleteBrush(hbr);
#else
            CEDeleteBrush(hbr);
#endif
        }
    }

    // Tell OP and OD that the share is coming up.
    _pOp->OP_Enable();
    _pOd->OD_Enable();

#ifdef DRAW_GDIPLUS
    if (_UH.pfnGdipPlayTSClientRecord) {
        if (!_UH.fGdipEnabled) {
            rc = _UH.pfnGdipPlayTSClientRecord(_UH.hdcShadowBitmap, DrawTSClientEnable, NULL, 0, NULL);
            _UH.fGdipEnabled = TRUE;
            if (rc != 0) {
                TRC_ERR((TB, _T("Call to GdipPlay:DrawTSClientEnable failed")));
            }
        }

        ProtocolColorDepth = _UH.protocolBpp;
        if (_UH.pfnGdipPlayTSClientRecord(_UH.hdcShadowBitmap, DrawTSClientDisplayChange, 
                                 (BYTE *)&ProtocolColorDepth, sizeof(unsigned int), NULL))
        {
            TRC_ERR((TB, _T("GdipPlay:DrawTSClientDisplayChange failed")));
        }
    }
#endif

    // We are enabled now.
    _UH.bEnabled = TRUE;

    DC_END_FN();
}


/****************************************************************************/
// UHCommonDisable
//
// Encapsulates common disable/disconnect code.
/****************************************************************************/
void DCINTERNAL CUH::UHCommonDisable(BOOL fDisplayDisabledBitmap)
{
    BOOL fUseDisabledBitmap = FALSE;
    DC_BEGIN_FN("UHCommonDisable");

    if (_UH.bEnabled) {
        _UH.bEnabled = FALSE;
    }

    // Tell OP and OD that the share is going down.

    //
    // Pass flag to OP telling it if we are now disconnected
    // this starts all the window dimming stuff
    //
    _pOp->OP_Disable(!_UH.bConnected);
    _pOd->OD_Disable();

    DC_END_FN();
}


/****************************************************************************/
// UH_Disable
//
// Disables _UH. Called at reception of DisableAllPDU from server. This
// function should not be used to do cleanup for the session (see
// UH_Disconnect), as the server may continue the session on server-side
// reconnect by starting a new share starting with a new DemandActivePDU.
//
// Params:    IN  unused - required by the component decoupler.
/****************************************************************************/
void DCAPI CUH::UH_Disable(ULONG_PTR unused)
{
    DC_BEGIN_FN("UH_Disable");

    DC_IGNORE_PARAMETER(unused);

    TRC_NRM((TB, _T("Disabling UH")));

    // We don't have anything to do here for bitmap caching. Whether we
    // are communicating with a rev1 or rev2 bitmap caching server, we
    // don't need to repeat work and allocations here. For rev2 servers
    // we cannot change the cache contents on DisableAllPDU since we
    // may actually be reconnecting and the server will assume state was
    // maintained.

    // Do work that needs doing on both UH_Disable() and UH_Disconnect().
    UHCommonDisable(TRUE);

    DC_END_FN();
}


/****************************************************************************/
// UH_Disconnect
//
// Disconnects _UH. Called at session end to indicate session cleanup should
// occur.
//
// Params:    IN  unused - required by the component decoupler.
/****************************************************************************/
void DCAPI CUH::UH_Disconnect(ULONG_PTR unused)
{
    UINT cacheId;
    UINT32 cacheIndex;

    DC_BEGIN_FN("UH_Disconnect");

    DC_IGNORE_PARAMETER(unused);

    TRC_NRM((TB, _T("Disconnecting UH")));

    // We can be called here multiple times. Don't do a lot of extra work.
    if (_UH.bConnected) {

        UHCreateDisconnectedBitmap();

        _UH.bConnected = FALSE;

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
        if (_UH.bPersistenceActive) {
            if (!_UH.bWarningDisplayed) {
                UINT32 Key1, Key2;

                for (cacheId = 0; cacheId < _UH.NumBitmapCaches; cacheId++) {
                    _UH.numKeyEntries[cacheId] = 0;
                    
                    if (_UH.pBitmapKeyDB[cacheId] != NULL) {
                        for (cacheIndex = 0; cacheIndex < _UH.bitmapCache[cacheId].
                                BCInfo.NumVirtualEntries; cacheIndex++) {
                            Key1 = _UH.bitmapCache[cacheId].PageTable.PageEntries[
                                    cacheIndex].bmpInfo.Key1;
                            Key2 = _UH.bitmapCache[cacheId].PageTable.PageEntries[
                                    cacheIndex].bmpInfo.Key2;
                            if (Key1 != 0 && Key2 != 0) {
                                // need to reset the bitmap key database to what's in
                                // the bitmap cache page table

                                _UH.pBitmapKeyDB[cacheId][_UH.numKeyEntries[cacheId]] =
                                        _UH.bitmapCache[cacheId].PageTable.PageEntries[
                                        cacheIndex].bmpInfo;
             
                                _UH.numKeyEntries[cacheId]++;
                            }
                            else {
                                break;
                            }
                        }
                    }
                }
            }
            else {
                // we had a persistent caching failure, so we should disable
                // persistent caching for next reconnect
                for (cacheId = 0; cacheId < _UH.NumBitmapCaches; cacheId++) {
                    _UH.numKeyEntries[cacheId] = 0;

                    UH_ClearOneBitmapDiskCache(cacheId, _UH.copyMultiplier);
                }
                _pUi->UI_SetBitmapPersistence(FALSE);
            }

            _UH.bBitmapKeyEnumComplete = TRUE;
            _UH.bBitmapKeyEnumerating = FALSE;
        }
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

        //
        // Reset bitmap cache alloced flag
        //
        _UH.fBmpCacheMemoryAlloced = FALSE;

        // Free bitmap cache info in use.
        for (cacheId = 0; cacheId < _UH.NumBitmapCaches; cacheId++) {
            if (_UH.bitmapCache[cacheId].Header != NULL) {
                UT_Free( _pUt, _UH.bitmapCache[cacheId].Header);
                _UH.bitmapCache[cacheId].Header = NULL;
            }
            if (_UH.bitmapCache[cacheId].Entries != NULL) {
                UT_Free( _pUt, _UH.bitmapCache[cacheId].Entries);
                _UH.bitmapCache[cacheId].Entries = NULL;
            }

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
            // reset the last time bitmap error pdu sent for all caches
            _UH.lastTimeErrorPDU[cacheId] = 0;

            // Free bitmap page table
            if (_UH.bitmapCache[cacheId].PageTable.PageEntries != NULL) {
                UT_Free( _pUt, _UH.bitmapCache[cacheId].PageTable.PageEntries);
                _UH.bitmapCache[cacheId].PageTable.PageEntries = NULL;
                _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries = 0;
            }

            // close the file handle for the cache files
            if (INVALID_HANDLE_VALUE != 
                _UH.bitmapCache[cacheId].PageTable.CacheFileInfo.hCacheFile) 
            {
                CloseHandle(_UH.bitmapCache[cacheId].PageTable.CacheFileInfo.hCacheFile);
                _UH.bitmapCache[cacheId].PageTable.CacheFileInfo.hCacheFile = INVALID_HANDLE_VALUE;

#ifdef VM_BMPCACHE
                if (_UH.bitmapCache[cacheId].PageTable.CacheFileInfo.pMappedView)
                {
                    if (!UnmapViewOfFile(
                        _UH.bitmapCache[cacheId].PageTable.CacheFileInfo.pMappedView))
                    {
                        TRC_ERR((TB,_T("UnmapViewOfFile failed 0x%d"),
                                 GetLastError()));
                    }
                }
#endif
            }

#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

        }
        _UH.NumBitmapCaches = 0;

        // free the decompression buffer
        if (_UH.bitmapDecompressionBuffer != NULL) {
            UT_Free( _pUt, _UH.bitmapDecompressionBuffer);
            _UH.bitmapDecompressionBuffer = NULL;
            _UH.bitmapDecompressionBufferSize = 0;
        }

        // Delete all the offscreen bitmaps
        if (NULL != _UH.hdcOffscreenBitmap) {
            unsigned i;
    
            for (i = 0; i < _UH.offscrCacheEntries; i++) {
                if (_UH.offscrBitmapCache[i].offscrBitmap) {
                    SelectBitmap(_UH.hdcOffscreenBitmap, 
                            _UH.hUnusedOffscrBitmap);
                    DeleteBitmap(_UH.offscrBitmapCache[i].offscrBitmap);
                    _UH.offscrBitmapCache[i].offscrBitmap = 0;
                    _UH.offscrBitmapCache[i].cx = 0;
                    _UH.offscrBitmapCache[i].cy = 0;
                }
            }
        }

#ifdef DRAW_NINEGRID
        // Delete all the drawStream bitmaps
        if (NULL != _UH.hdcDrawNineGridBitmap) {
            unsigned i;
    
            for (i = 0; i < _UH.drawNineGridCacheEntries; i++) {
                if (_UH.drawNineGridBitmapCache[i].drawNineGridBitmap) {
                    SelectBitmap(_UH.hdcDrawNineGridBitmap, 
                            _UH.hUnusedDrawNineGridBitmap);
                    DeleteBitmap(_UH.drawNineGridBitmapCache[i].drawNineGridBitmap);
                    _UH.drawNineGridBitmapCache[i].drawNineGridBitmap = 0;
                    _UH.drawNineGridBitmapCache[i].cx = 0;
                    _UH.drawNineGridBitmapCache[i].cy = 0;
                }
            }
        }
#endif

#ifdef DC_DEBUG
        // Force a redraw of the bitmap cache monitor, since it cannot any
        // longer display contents from the entries array freed above.
        UHDisconnectBitmapCacheMonitor();
#endif

        /********************************************************************/
        // We need to free up any resources we might have set up in the draw
        // DC, along with the bitmap used for pattern brushes.
        // We do this by selecting in stock objects - which we don't need to
        // free - and deleting the old object (if any)
        /********************************************************************/
        if (NULL != _UH.hdcDraw) {
            HPEN     hPenNew;
            HPEN     hPenOld;
            HBRUSH   hBrushNew;
            HBRUSH   hBrushOld;
            HFONT    hFontNew;
            HFONT    hFontOld;

            TRC_NRM((TB, _T("tidying DC resources")));

            // First the pen.
            hPenNew = (HPEN)GetStockObject(NULL_PEN);
            hPenOld = SelectPen(_UH.hdcDraw, hPenNew);
            if (NULL != hPenOld) {
                TRC_NRM((TB, _T("Delete old pen")));
                DeleteObject(hPenOld);
            }

            // Now the brush.
            hBrushNew = (HBRUSH)GetStockObject(NULL_BRUSH);
            hBrushOld = SelectBrush(_UH.hdcDraw, hBrushNew);
            if (NULL != hBrushOld) {
                TRC_NRM((TB, _T("Delete old brush")));
                DeleteObject(hBrushOld);
            }

            // Now the font.
            hFontNew = (HFONT)GetStockObject(SYSTEM_FONT);
            hFontOld = SelectFont(_UH.hdcDraw, hFontNew);
            if (NULL != hFontOld) {
                TRC_NRM((TB, _T("Delete old Font")));
                DeleteObject(hFontOld);
            }

#ifdef OS_WINCE
            //Now the palette.
            //On WinCE when the device is capable of only 8bpp, when you 
            //disconnect from a session and return to the main dialog, the 
            //palette isnt reset, and the rest of CE screen looks ugly.
            if (NULL != _UH.hpalDefault) {
                SelectPalette(_UH.hdcDraw, _UH.hpalDefault, FALSE );
                RealizePalette(_UH.hdcDraw);
            }

            if ((_UH.hpalCurrent != NULL) && (_UH.hpalCurrent != _UH.hpalDefault))
            {
                TRC_NRM((TB, _T("Delete current palette %p"), _UH.hpalCurrent));
                DeletePalette(_UH.hpalCurrent);
            }

            _UH.hpalCurrent = _UH.hpalDefault;
#endif
            // Make sure this DC is nulled out to avoid problems if we're
            // called again.  This is just a copy of _UH.hdcOutputWindow, which
            // is NULLed below.
            _UH.hdcDraw = NULL;
        }

        /********************************************************************/
        // If we're not using a shadow bitmap, we should release the DC we
        // have to the output window - remembering that it is possible that
        // we didn't successfully connect, in which case UH_OnConnected won't
        // have been called and so we won't have acquired a DC to need
        // releasing!
        /********************************************************************/
        if (NULL != _UH.hdcOutputWindow)
        {
            TRC_NRM((TB, _T("Releasing Output Window HDC")));
            ReleaseDC(_pOp->OP_GetOutputWindowHandle(), _UH.hdcOutputWindow);
            _UH.hdcOutputWindow = NULL;
        }
    }

    // Do work that needs doing on both UH_Disable() and UH_Disconnect().
    UHCommonDisable(TRUE);

    DC_END_FN();
}

#ifdef DC_DEBUG
/****************************************************************************/
/* Name:      UH_HatchRect                                                  */
/*                                                                          */
/* Purpose:   Draws a hatched rectangle in _UH.hdcOutputWindow in the given */
/*            color.                                                        */
/*                                                                          */
/* Params:    left         -   left coord of rect                           */
/*            top          -   top coord of rect                            */
/*            right        -   right coord of rect                          */
/*            bottom       -   bottom coord of rect                         */
/*            color        -   color of hatching to draw                    */
/*            hatchStyle   -   style of hatching to draw                    */
/****************************************************************************/
DCVOID DCAPI CUH::UH_HatchOutputRect(DCINT left, DCINT top, DCINT right,
        DCINT bottom, COLORREF color, DCUINT hatchStyle)
{
    DC_BEGIN_FN("UHHatchOutputRect");
    UH_HatchRectDC(_UH.hdcOutputWindow, left, top, right, bottom, color, 
            hatchStyle);
    DC_END_FN();
}

/****************************************************************************/
/* Name:      UH_HatchRect                                                   */
/*                                                                          */
/* Purpose:   Draws a hatched rectangle in _UH.hdcDraw in the given color.   */
/*                                                                          */
/* Params:    left         -   left coord of rect                           */
/*            top          -   top coord of rect                            */
/*            right        -   right coord of rect                          */
/*            bottom       -   bottom coord of rect                         */
/*            color        -   color of hatching to draw                    */
/*            hatchStyle   -   style of hatching to draw                    */
/****************************************************************************/
DCVOID DCAPI CUH::UH_HatchRect( DCINT    left,
                               DCINT    top,
                               DCINT    right,
                               DCINT    bottom,
                               COLORREF color,
                               DCUINT   hatchStyle )
{
    DC_BEGIN_FN("UHHatchRect");
    UH_HatchRectDC(_UH.hdcDraw, left, top, right, bottom, color, 
            hatchStyle);
    DC_END_FN();
}

/****************************************************************************/
/* Name:      UH_HatchRectDC                                                */
/*                                                                          */
/* Purpose:   Draws a hatched rectangle in the hDC in the given color.      */
/*                                                                          */
/* Params:    left         -   left coord of rect                           */
/*            top          -   top coord of rect                            */
/*            right        -   right coord of rect                          */
/*            bottom       -   bottom coord of rect                         */
/*            color        -   color of hatching to draw                    */
/*            hatchStyle   -   style of hatching to draw                    */
/****************************************************************************/
DCVOID DCAPI CUH::UH_HatchRectDC(HDC hdc, DCINT left, DCINT top, DCINT right,
        DCINT bottom, COLORREF color, DCUINT hatchStyle)
{
    HBRUSH   hbrHatch;
    DCUINT   oldBkMode;
    DCUINT   oldRop2;
    DCUINT   winHatchStyle = 0;
    POINT    oldOrigin;
    RECT     rect;
    HRGN     hrgn;
    HBRUSH   hbrOld;
    HPEN     hpen;
    HPEN     hpenOld;

    DC_BEGIN_FN("UHHatchRectDC");

    switch (hatchStyle)
    {
        case UH_BRUSHTYPE_FDIAGONAL:
        {
            winHatchStyle = HS_FDIAGONAL;
        }
        break;

        case UH_BRUSHTYPE_DIAGCROSS:
        {
           winHatchStyle = HS_DIAGCROSS;
        }
        break;

        case UH_BRUSHTYPE_HORIZONTAL:
        {
            winHatchStyle = HS_HORIZONTAL;
        }
        break;

        case UH_BRUSHTYPE_VERTICAL:
        {
            winHatchStyle = HS_VERTICAL;
        }
        break;

        default:
        {
            TRC_ABORT((TB, _T("Unspecified hatch type request, %u"), hatchStyle));
        }
        break;
    }

    hbrHatch = CreateHatchBrush(winHatchStyle, color);
    oldBkMode = SetBkMode(hdc, TRANSPARENT);
    oldRop2 = SetROP2(hdc, R2_COPYPEN);
    SetBrushOrgEx(hdc, 0, 0, &oldOrigin);

    rect.left   = left;
    rect.top    = top;
    rect.right  = right;
    rect.bottom = bottom;

    /************************************************************************/
    /* Fill the rectangle with the hatched brush.                           */
    /************************************************************************/
    hrgn = CreateRectRgn(rect.left, rect.top, rect.right, rect.bottom);

#ifndef OS_WINCE
    /************************************************************************/
    /* Just draw bounding rectangle on WinCE                                */
    /************************************************************************/
    FillRgn( hdc,
             hrgn,
             hbrHatch );
#endif

    DeleteRgn(hrgn);
    DeleteBrush(hbrHatch);

    hbrOld = SelectBrush(hdc, GetStockObject(HOLLOW_BRUSH));

    hpen = CreatePen(PS_SOLID, 1, color);
    hpenOld = SelectPen(hdc, hpen);

    /************************************************************************/
    /* Draw a border around the hatched rectangle.                          */
    /************************************************************************/
    Rectangle( hdc,
               rect.left,
               rect.top,
               rect.right,
               rect.bottom );

    SelectBrush(hdc, hbrOld);

    SelectPen(hdc, hpenOld);
    DeletePen(hpen);

    /************************************************************************/
    /* Reset the original DC state.                                         */
    /************************************************************************/
    SetBrushOrgEx(hdc, oldOrigin.x, oldOrigin.y, NULL);
    SetROP2(hdc, oldRop2);
    SetBkMode(hdc, oldBkMode);

    DC_END_FN();
}
#endif

#ifdef DISABLE_SHADOW_IN_FULLSCREEN
void DCAPI CUH::UH_SetBBarRect(ULONG_PTR pData)
{
    RECT *prect = (RECT *)pData;

    _UH.rectBBar.left = prect->left;
    _UH.rectBBar.top = prect->top;
    _UH.rectBBar.right = prect->right;
    _UH.rectBBar.bottom = prect->bottom;
}


void DCAPI CUH::UH_SetBBarVisible(ULONG_PTR pData)
{
     if (0 == (int)pData) 
        _UH.fIsBBarVisible = FALSE;
     else
        _UH.fIsBBarVisible = TRUE;
}


// Disable use of shadow in full-screen
void DCAPI CUH::UH_DisableShadowBitmap(ULONG_PTR)
{
    DC_BEGIN_FN("UH_DisableShadowBitmap");

    _UH.hdcDraw = _UH.hdcOutputWindow;
    _UH.DontUseShadowBitmap = TRUE;
    UHResetDCState();

    DC_END_FN();
}

// Enable use of shadow when leaving full-screen
void DCAPI CUH::UH_EnableShadowBitmap(ULONG_PTR)
{  
    DC_BEGIN_FN("UH_EnableShadowBitmap");

    DCSIZE desktopSize;
    RECT rect;

    if (_UH.DontUseShadowBitmap) 
    {    
        _pUi->UI_GetDesktopSize(&desktopSize);

        _UH.hdcDraw = _UH.hdcShadowBitmap;
        _UH.DontUseShadowBitmap = FALSE;

        rect.left = 0;
        rect.top = 0;
        rect.right = desktopSize.width;
        rect.bottom = desktopSize.height;
        // Since we have no copy of screen, ask the server to resend 
        _pCd->CD_DecoupleNotification(CD_SND_COMPONENT,
                                      _pOr,
                                      CD_NOTIFICATION_FUNC(COR,OR_RequestUpdate),
                                      &rect,
                                      sizeof(RECT));   
        UHResetDCState();
     }

    DC_END_FN();
    return;
}
#endif // DISABLE_SHADOW_IN_FULLSCREEN

#ifdef DRAW_GDIPLUS
// Ininitalize the gdiplus
BOOL DCAPI CUH::UHDrawGdiplusStartup(ULONG_PTR unused)
{
    Gdiplus::GdiplusStartupInput sti;
    unsigned GdipVersion;
    unsigned rc = FALSE;

    DC_BEGIN_FN("UHDrawGdiplusStartup");

    if (_UH.pfnGdiplusStartup(&_UH.gpToken, &sti, NULL) == Gdiplus::Ok) {
        _UH.gpValid = TRUE;  

        GdipVersion = _UH.pfnGdipPlayTSClientRecord(NULL, DrawTSClientQueryVersion, NULL, 0, NULL);
        _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.GdipVersion = GdipVersion;

        rc = TRUE;
     }
     else  {
        TRC_ERR((TB, _T("Call to GdiplusStartup failed")));
     }

    DC_END_FN();

    return rc;
}


// Shutdown the gdiplus
void DCAPI CUH::UHDrawGdiplusShutdown(ULONG_PTR unused)
{
     DC_BEGIN_FN("UHDrawGdiplusShutDown");

    if (_UH.pfnGdipPlayTSClientRecord) {
         _UH.pfnGdipPlayTSClientRecord(NULL, DrawTSClientDisable, NULL, 0, NULL);
    }
    if (_UH.gpValid) {
         _UH.pfnGdiplusShutdown(_UH.gpToken);
    }

    if (_UH.hModuleGDIPlus != NULL) {
        FreeLibrary(_UH.hModuleGDIPlus);
        _UH.pfnGdipPlayTSClientRecord = NULL;
        _UH.hModuleGDIPlus = NULL;
    }

     DC_END_FN();
}
#endif // DRAW_GDIPLUS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\uh.h ===
/****************************************************************************/
// uh.h
//
// Update Handler Class
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/

#ifndef _H_UH_
#define _H_UH_

extern "C" {
    #include <adcgdata.h>
}

#include "fs.h"
#include "op.h"
#include "or.h"
#include "gh.h"
#include "ih.h"

#include "objs.h"
#include "cd.h"

#ifdef OS_WINCE
#include <ceconfig.h>
#endif

#include "tscerrs.h"

//USE Mem mapped file for bitmap cache
//#define VM_BMPCACHE 1

class CSL;
class COD;
class CUI;
class CCC;

#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "uh"
#define TSC_HR_FILEID   TSC_HR_UH_H

typedef struct tagUH_ORDER
{
    RECT dstRect;
    BYTE orderData[1];
} UH_ORDER, FAR *PUH_ORDER;

typedef UH_ORDER UNALIGNED FAR *PUH_ORDER_UA;
#define UH_ORDER_HEADER_SIZE (FIELDOFFSET(UH_ORDER, orderData))

extern const UINT16 uhWindowsROPs[256];

/****************************************************************************/
/* Number of glyph caches.                                                  */
/****************************************************************************/
#define UH_GLC_NUM_CACHES   10

/****************************************************************************/
/* Number of entries in the color table cache.                              */
/****************************************************************************/
#define UH_COLOR_TABLE_CACHE_ENTRIES      6

/****************************************************************************/
/* Save Bitmap constants                                                    */
/****************************************************************************/
#define UH_SAVE_BITMAP_WIDTH            480
#define UH_SAVE_BITMAP_HEIGHT           480
#define UH_SAVE_BITMAP_SIZE     ((DCUINT32)UH_SAVE_BITMAP_WIDTH *            \
                                              (DCUINT32)UH_SAVE_BITMAP_HEIGHT)
#define UH_SAVE_BITMAP_X_GRANULARITY      1
#define UH_SAVE_BITMAP_Y_GRANULARITY     20


// Cache IDs have a protocol-implicit cell size, starting from 256 and
// increasing in factors of 4. Scale by the bit depth.
#ifdef DC_HICOLOR
#define UH_CellSizeFromCacheID(_id) \
        ((TS_BITMAPCACHE_0_CELL_SIZE << (2 * (_id))) * _UH.copyMultiplier)
        
#define UH_CellSizeFromCacheIDAndMult(_id,mult) \
        ((TS_BITMAPCACHE_0_CELL_SIZE << (2 * (_id))) * mult)
        
#define UH_PropVirtualCacheSizeFromMult(mult) \
        (_UH.PropBitmapVirtualCacheSize[mult-1])
#else
#define UH_CellSizeFromCacheID(_id) \
        (TS_BITMAPCACHE_0_CELL_SIZE << (2 * (_id)))
#endif        

// Tile sizes are also protocol-implied and dependent on the cache ID,
// starting at 16 per side and increasing in powers of two in each dimension.
#define UH_CACHE_0_DIMENSION 16



//
// From wuhint.h  
//

#define UH_NUM_8BPP_PAL_ENTRIES         256
#define UH_LOGPALETTE_VERSION           0x300
#define UH_LAST_PAL_ENTRY               (UH_NUM_8BPP_PAL_ENTRIES-1)
#define UH_NUM_SYSTEM_COLORS            20

#define UH_COLOR_RGB        0
#define UH_COLOR_PALETTE    1

#define UH_RGB_BLACK  RGB(0x00, 0x00, 0x00)
#define UH_RGB_RED    RGB(0xFF, 0x00, 0x00)
#define UH_RGB_GREEN  RGB(0x00, 0xFF, 0x00)
#define UH_RGB_BLUE   RGB(0x00, 0x00, 0xFF)
#define UH_RGB_MAGENTA RGB(0xFF, 0x00, 0xFF)
#define UH_RGB_CYAN   RGB(0x00, 0xFF, 0xFF)
#define UH_RGB_YELLOW RGB(0xFF, 0xFF, 0x00)
#define UH_RGB_WHITE  RGB(0xFF, 0xFF, 0xFF)

#define UH_BRUSHTYPE_FDIAGONAL  1
#define UH_BRUSHTYPE_DIAGCROSS  2
#define UH_BRUSHTYPE_HORIZONTAL 3
#define UH_BRUSHTYPE_VERTICAL   4

#define WM_RECALC_CELL_SPACING (WM_APP + 100)


/****************************************************************************/
// Size of the decompression buffer used for decompressing screen data.
// This is the maximum decompressed size the server will send.
/****************************************************************************/
#define UH_DECOMPRESSION_BUFFER_LENGTH 32000


/****************************************************************************/
// Min value configurable for the bitmap cache total size.
/****************************************************************************/
#define UH_BMC_LOW_THRESHOLD 150


/****************************************************************************/
/* Max and min values configurable for the glyph cache total size           */
/****************************************************************************/
#define UH_GLC_LOW_THRESHOLD      50
#define UH_GLC_HIGH_THRESHOLD     2000


/****************************************************************************/
/* Glyph cache constants.                                                   */
/****************************************************************************/
// Warning: data sizes must be a power of 2
#define UH_GLC_CACHE_MAXIMUMCELLSIZE    2048

#define UH_GLC_CACHE_MINIMUMCELLCOUNT   16
#define UH_GLC_CACHE_MAXIMUMCELLCOUNT   254


/****************************************************************************/
/* Frag cache constants.                                                    */
/****************************************************************************/
// Warning: data sizes must be a power of 2
#define UH_FGC_CACHE_MAXIMUMCELLSIZE    256
#define UH_FGC_CACHE_MAXIMUMCELLCOUNT   256


/****************************************************************************/
// Offscreen cache constants
/****************************************************************************/
#define UH_OBC_LOW_CACHESIZE        512          // half MB
#define UH_OBC_HIGH_CACHESIZE       7680         // 7.5 MB

#define UH_OBC_LOW_CACHEENTRIES     50
#define UH_OBC_HIGH_CACHEENTRIES    500

#ifdef DRAW_GDIPLUS
#define UH_GDIP_LOW_CACHEENTRIES     2
#define UH_GDIP_HIGH_CACHEENTRIES    20
#endif


#ifdef DC_DEBUG
/****************************************************************************/
/* Bitmap Cache Monitor Window Class name.                                  */
/****************************************************************************/
#define UH_BITMAP_CACHE_MONITOR_CLASS_NAME _T("BitmapCacheMonitorClass")

#define UH_CACHE_WINDOW_BORDER_WIDTH 20
#define UH_CACHE_BLOB_WIDTH           6
#define UH_CACHE_BLOB_HEIGHT          6
#define UH_CACHE_BLOB_SPACING         1
#define UH_INTER_CACHE_SPACING       20
#define UH_CACHE_TEXT_SPACING         5

#define UH_CACHE_BLOB_TOTAL_WIDTH     \
                                 (UH_CACHE_BLOB_WIDTH + UH_CACHE_BLOB_SPACING)

#define UH_CACHE_BLOB_TOTAL_HEIGHT    \
                                (UH_CACHE_BLOB_HEIGHT + UH_CACHE_BLOB_SPACING)

#define UH_CACHE_FLASH_PERIOD  1000

#define UH_CACHE_DISPLAY_FONT_NAME    _T("Comic Sans MS")
#define UH_CACHE_DISPLAY_FONT_SIZE    16
#define UH_CACHE_DISPLAY_FONT_WEIGHT  FW_NORMAL

#define UH_CACHE_MONITOR_UPDATE_PERIOD 200


// Cache monitor entry states. Describes where the cache entry is.
#define UH_CACHE_STATE_UNUSED                    0
#define UH_CACHE_STATE_IN_MEMORY                 1
#define UH_CACHE_STATE_ON_DISK                   2

#define UH_CACHE_NUM_STATES 3

// Cache monitor flash transitions transitions. Describes the temporary state
// of a displayed entry after an event has occurred. Each entry has an
// associated timestamp that determines when the transition flash will end.
// These should be ordered in importance, most important having higher numbers
// -- the more important events supersede other events in use of the timer.
#define UH_CACHE_TRANSITION_NONE                      0
#define UH_CACHE_TRANSITION_TOUCHED                   1
#define UH_CACHE_TRANSITION_EVICTED                   2
#define UH_CACHE_TRANSITION_LOADED_FROM_DISK          3
#define UH_CACHE_TRANSITION_KEY_LOAD_ON_SESSION_START 4
#define UH_CACHE_TRANSITION_SERVER_UPDATE             5

#define UH_CACHE_NUM_TRANSITIONS 6

#endif /* DC_DEBUG */


typedef struct tagUHBITMAPINFOPALINDEX
{
    // Set where the palette contains palette indices of 0..255.
    BOOL bIdentityPalette;

    // The following entries are used directly as a bitmap info header with
    // embedded palette when doing blts.
    BITMAPINFOHEADER hdr;
    UINT16           paletteIndexTable[256];
} UHBITMAPINFOPALINDEX, FAR *PUHBITMAPINFOPALINDEX;


typedef struct tagUHCACHEDCOLORTABLE
{
    RGBTRIPLE rgb[256];
} UHCACHEDCOLORTABLE, FAR *PUHCACHEDCOLORTABLE;


/****************************************************************************/
// Bitmap Cache Definitions
/****************************************************************************/
#define CACHE_DIRECTORY_NAME _T("cache\\")

// This value should be 13 for 8.3 file name and \0, additional 2 is for legacy 
// purpose.  Old cache structure contains cacheId\ as subcache directory name.  
// We can remove 2 if we don't need to support Win2000 Beta3.
#define CACHE_FILENAME_LENGTH 15


typedef struct tagUHBITMAPINFO
{
    UINT32 Key1, Key2;
    UINT16 bitmapWidth;
    UINT16 bitmapHeight;
    UINT32 bitmapLength;
} UHBITMAPINFO, FAR *PUHBITMAPINFO;

// File Header for bitmap file used in persistent bitmap caching
typedef struct tagUHBITMAPFILEHDR
{
    UHBITMAPINFO bmpInfo;

    UINT32 bmpVersion  : 3;
    UINT32 bCompressed : 1;
    UINT32 bNoBCHeader : 1;   // add new flag to indicate if the compressed
                              // bitmap data contains BC header or not
    UINT32 pad : 27;
} UHBITMAPFILEHDR, FAR *PUHBITMAPFILEHDR;

// Information maintained for each bitmap cache
typedef struct tagUHBITMAPCACHEINFO
{
    UINT32 NumVirtualEntries;
    UINT32 NumEntries : 31;
    UINT32 bSendBitmapKeys : 1;
#ifdef DC_HICOLOR
    UINT32 OrigNumEntries;
    UINT32 MemLen;
#endif
} UHBITMAPCACHEINFO, FAR *PUHBITMAPCACHEINFO;

#ifdef DC_DEBUG
// Used to hold bitmap cache monitor information in debug builds.
typedef struct {
    BYTE ColorTable;
    BYTE State : 2;
    BYTE FlashTransition : 6;
    unsigned UsageCount;
    UINT32 EventTime;
} UH_CACHE_MONITOR_ENTRY_DATA;
#endif

// Bitmap cache entry definitions                                           
// The fields in UHBITMAPCACHEENTRYHDR are of explicit length deliberately  
// to ensure 16 and 32 bit client match and to help force the cache entry   
// header sizes to be powers of two.                                        
typedef struct tagUHBITMAPCACHEENTRYHDR
{
    UINT16 bitmapWidth;
    UINT16 bitmapHeight;
    UINT32 bitmapLength : 31;
    UINT32 hasData : 1;
} UHBITMAPCACHEENTRYHDR, FAR *PUHBITMAPCACHEENTRYHDR,
        DCHPTR HPUHBITMAPCACHEENTRYHDR;

// bitmap cache file info
typedef struct tagUHCACHEFILEINFO
{
    HANDLE  hCacheFile;
#ifdef VM_BMPCACHE
    LPBYTE             pMappedView;
#endif
} UHCACHEFILEINFO, FAR *PUHCACHEFILEINFO;

// Doubly Linked List Node - Used to maintain MRU list
typedef struct tagUHCHAIN
{
    UINT32  next;
    UINT32  prev;
} UHCHAIN, FAR *PUHCHAIN;

typedef TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY DCHPTR HPTS_BITMAPCACHE_PERSISTENT_LIST_ENTRY;

// Bitmap Virtual Cache Page Table Entry
// We need 3 pad here to make sure the struct size be power of two
// This is required for huge memory allocation in Win16
typedef struct tagUHBITMAPCACHEPTE
{
    UHCHAIN                              mruList;
    UINT32                               iEntryToMem;
    TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY bmpInfo;

} UHBITMAPCACHEPTE, FAR *PUHBITMAPCACHEPTE, DCHPTR HPUHBITMAPCACHEPTE;

// Bitmap Virtual Cache Page Table
typedef struct tagUHBITMAPCACHEPAGETABLE
{
    UINT32             MRUHead;
    UINT32             MRUTail;
    UINT32             FreeMemList;
    UHCACHEFILEINFO    CacheFileInfo;
    HPUHBITMAPCACHEPTE PageEntries;
} UHBITMAPCACHEPAGETABLE, FAR *PUHBITMAPCACHEPAGETABLE;

// Bitmap physical memory caches
typedef struct tagUHBITMAPCACHE
{
    UHBITMAPCACHEINFO       BCInfo;
    HPUHBITMAPCACHEENTRYHDR Header;
    BYTE DCHPTR             Entries;
    UHBITMAPCACHEPAGETABLE  PageTable;
} UHBITMAPCACHE;


/****************************************************************************/
/* Brush cache entry definitions                                            */
/****************************************************************************/
typedef struct tagUHBRUSHCACHEHDR
{
    BYTE iBitmapFormat;
    BYTE cx;
    BYTE cy;
    BYTE iBytes;
} UHBRUSHCACHEHDR, FAR *PUHBRUSHCACHEHDR;

#define UH_MAX_MONO_BRUSHES  64
#define UH_MONO_BRUSH_SIZE   16
#define UH_COLOR_BRUSH_SIZE  64

#ifdef DC_HICOLOR
#define UH_COLOR_BRUSH_SIZE_16  128
#define UH_COLOR_BRUSH_SIZE_24  192
#endif

typedef struct tagUHMONOBRUSHCACHE
{
    UHBRUSHCACHEHDR  hdr;
    BYTE data[UH_MONO_BRUSH_SIZE];
} UHMONOBRUSHCACHE, FAR *PUHMONOBRUSHCACHE;

typedef struct tagUHCOLORBRUSHINFO
{
    BITMAPINFO bmi;
    RGBQUAD    rgbQuadTable[UH_NUM_8BPP_PAL_ENTRIES - 1];
    BYTE       bytes[UH_COLOR_BRUSH_SIZE];
    HBRUSH     hLastBrush;
} UHCOLORBRUSHINFO, *PUHCOLORBRUSHINFO;

#ifdef DC_HICOLOR
// We only need enough color table entries for the red, green blue bit masks
// used in 16bpp sessions.
// Note that we make this big enough to use for 15/16 and 24bpp brushes
typedef struct tagUHHICOLORBRUSHINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD    bmiColors[3];
    BYTE       bytes[UH_COLOR_BRUSH_SIZE_24];
    HBRUSH     hLastBrush;
} UHHICOLORBRUSHINFO, FAR *PUHHICOLORBRUSHINFO;
#endif


#define UH_MAX_COLOR_BRUSHES 64

#ifdef DC_HICOLOR // Need enough space for a 24bpp brush
typedef struct tagUHCOLORBRUSHCACHE
{
    UHBRUSHCACHEHDR  hdr;
    BYTE data[UH_COLOR_BRUSH_SIZE_24];
} UHCOLORBRUSHCACHE, FAR *PUHCOLORBRUSHCACHE;
#else
typedef struct tagUHCOLORBRUSHCACHE
{
    UHBRUSHCACHEHDR  hdr;
    BYTE data[UH_COLOR_BRUSH_SIZE];
} UHCOLORBRUSHCACHE, FAR *PUHCOLORBRUSHCACHE;
#endif


/****************************************************************************/
/* Glyph cache entry definitions                                            */
/****************************************************************************/
typedef struct tagUHGLYPHCACHEENTRYHDR
{
    INT32  x;
    INT32  y;
    UINT32 cx;
    UINT32 cy;
    UINT32 unicode;
} UHGLYPHCACHEENTRYHDR, FAR *PUHGLYPHCACHEENTRYHDR,
        DCHPTR HPUHGLYPHCACHEENTRYHDR;

typedef struct tagUHGLYPHCACHE
{
    HPUHGLYPHCACHEENTRYHDR  pHdr;
    UINT32 cbEntrySize;
    BYTE DCHPTR pData;
    UINT32 cbUseCount;
} UHGLYPHCACHE, FAR *PUHGLYPHCACHE, DCHPTR HPUHGLYPHCACHE;


/****************************************************************************/
/* Frag cache entry definitions                                             */
/****************************************************************************/
typedef struct tagUHFRAGCACHEENTRYHDR
{
    UINT32 cbFrag;
    INT32  cacheId;
} UHFRAGCACHEENTRYHDR, FAR *PUHFRAGCACHEENTRYHDR,
        DCHPTR HPUHFRAGCACHEENTRYHDR;

typedef struct tagUHFRAGCACHE
{
    HPUHFRAGCACHEENTRYHDR pHdr;
    UINT32 cbEntrySize;
    BYTE DCHPTR pData;
} UHFRAGCACHE, FAR *PUHFRAGCACHE, DCHPTR HPUHFRAGCACHE;


/****************************************************************************/
// Offscreen bitmap cache 
/****************************************************************************/
typedef struct tagUHOFFSCRBITMAPCACHE
{
    HBITMAP offscrBitmap;
    UINT32 cx;
    UINT32 cy;
} UHOFFSCRBITMAPCACHE, FAR *PUHOFFSCRBITMAPCACHE, DCHPTR HPUHOFFSCRBITMAPCACHE;

#ifdef DRAW_NINEGRID
/****************************************************************************/
// DrawNineGrid bitmap cache 
/****************************************************************************/
typedef struct tagUHDRAWNINEGRIDBITMAPCACHE
{
    HBITMAP drawNineGridBitmap;
    UINT32 cx;
    UINT32 cy;
    UINT32 bitmapBpp;
    TS_NINEGRID_BITMAP_INFO dngInfo;
} UHDRAWSTREAMBITMAPCACHE, FAR *PUHDRAWSTREAMBITMAPCACHE;

#ifdef DRAW_GDIPLUS
/****************************************************************************/
// Gdiplus object cache 
/****************************************************************************/
typedef struct tagUHGDIPLUSOBJECTCACHE
{
    UINT32 CacheSize;
    BYTE * CacheData;
} UHGDIPLUSOBJECTCACHE, FAR *PUHGDIPLUSOBJECTCACHE;

typedef struct tagUHGDIPLUSIMAGECACHE
{
    UINT32 CacheSize;
    UINT16 ChunkNum;
    INT16 *CacheDataIndex;
} UHGDIPLUSIMAGECACHE, FAR *PUHGDIPLUSIMAGECACHE;
#endif


typedef BOOL (FNGDI_DRAWSTREAM)(HDC, ULONG, VOID*);

#endif

#define UHROUNDUP(val, granularity) \
  ((((val)+((granularity) - 1)) / (granularity)) * (granularity))

#define UH_IS_SYSTEM_COLOR_INDEX(i)                                 \
        ((i < (UH_NUM_SYSTEM_COLORS / 2)) ||                       \
        (i > (UH_LAST_PAL_ENTRY - (UH_NUM_SYSTEM_COLORS / 2))))

#define UH_TWEAK_COLOR_COMPONENT(colorComponent)   \
            if ((colorComponent) == 0)             \
            {                                      \
                (colorComponent)++;                \
            }                                      \
            else                                   \
            {                                      \
                (colorComponent)--;                \
            }

#define TSRECT16_TO_RECTL(dst, src) \
        (dst).left = (src).left; \
        (dst).top = (src).top; \
        (dst).right = (src).right; \
        (dst).bottom = (src).bottom; 
    
#define TSPOINT16_TO_POINTL(dst, src) \
        (dst).x = (src).x; \
        (dst).y = (src).y;
    
/****************************************************************************/
// UH_DATA
/****************************************************************************/
typedef struct tagUH_DATA
{
#ifdef DC_LATENCY
    unsigned fakeKeypressCount;
#endif /* DC_LATENCY */
    HBITMAP hShadowBitmap;
    HBITMAP hunusedBitmapForShadowDC;
    HBITMAP hSaveScreenBitmap;
    HBITMAP hunusedBitmapForSSBDC;

    HDC hdcShadowBitmap;
    HDC hdcOutputWindow;
    HDC hdcDraw;
    HDC hdcSaveScreenBitmap;
    HDC hdcBrushBitmap;

    BOOL usingDIBSection;
    BOOL shadowBitmapRequested;
    BOOL dedicatedTerminal;
    unsigned drawThreshold;

    UHBITMAPINFOPALINDEX bitmapInfo;

#ifdef DC_HICOLOR
    unsigned DIBFormat;
    unsigned copyMultiplier;
    unsigned protocolBpp;
    unsigned bitmapBpp;
    unsigned shadowBitmapBpp;
#endif
    BOOL shadowBitmapEnabled;
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
    BOOL DontUseShadowBitmap;   // True: don't use shadow; False: use shadow
#endif
#ifdef OS_WINCE
    BOOL paletteIsFixed;
#endif
    HPALETTE hpalDefault;
    HPALETTE hpalCurrent;
    HWND hwndOutputWindow;
    HRGN hrgnUpdate;
    HRGN hrgnUpdateRect;
    BOOL colorIndicesEnabled;

#ifdef DC_DEBUG
    BOOL hatchBitmapPDUData;
    BOOL hatchIndexPDUData;
    BOOL hatchSSBOrderData;
    BOOL hatchMemBltOrderData;
    BOOL labelMemBltOrders;
#endif /* DC_DEBUG */

    BYTE FAR *bitmapDecompressionBuffer;
    unsigned bitmapDecompressionBufferSize;
    
    /************************************************************************/
    /* last used resource variables                                         */
    /************************************************************************/
    COLORREF lastBkColor;
    COLORREF lastTextColor;
    int lastBkMode;
    int lastROP2;
    HDC lastHDC;

    unsigned lastPenStyle;
    unsigned lastPenWidth;
    COLORREF lastPenColor;
    COLORREF lastForeColor;

    unsigned lastLogBrushStyle;
    unsigned lastLogBrushHatch;
#if defined (OS_WINCE)
    COLORREF  lastLogBrushColorRef;
#else
    DCCOLOR  lastLogBrushColor;
#endif
    BYTE lastLogBrushExtra[7];

#ifdef OS_WINCE
    HDC            hdcMemCached;
    HBITMAP        hBitmapCacheDIB;
    PBYTE          hBitmapCacheDIBits;
#endif

    COLORREF       lastBrushBkColor;
    COLORREF       lastBrushTextColor;

    unsigned lastFillMode;

#ifdef DISABLE_SHADOW_IN_FULLSCREEN
    BOOL fIsBBarVisible; // TRUE: visible,  FALSE: invisible
    RECT rectBBar;

#endif

    /************************************************************************/
    /* The following variables which describe the current clip rectangle    */
    /* are only valid if fRectReset is FALSE.  If fRectReset is true then   */
    /* no clipping is in force.                                             */
    /************************************************************************/
    BOOL rectReset;
    int lastLeft;
    int lastTop;
    int lastRight;
    int lastBottom;

#if defined (OS_WINCE)
    HDC validClipDC;
    HDC validBkColorDC;
    HDC validBkModeDC;
    HDC validROPDC;
    HDC validTextColorDC;
    HDC validPenDC;
    HDC validBrushDC;
#endif

    /************************************************************************/
    /* Bitmaps                                                              */
    /************************************************************************/
    HBITMAP bmpPattern;
    HBITMAP bmpMonoPattern;
    HBITMAP bmpColorPattern;

    /************************************************************************/
    /* Memblt color table caches                                            */
    /************************************************************************/
    PUHCACHEDCOLORTABLE   pColorTableCache;
    PUHBITMAPINFOPALINDEX pMappedColorTableCache;
    int maxColorTableId;

    /************************************************************************/
    /* Glyph caches                                                         */
    /************************************************************************/
    UHGLYPHCACHE glyphCache[UH_GLC_NUM_CACHES];
    UHFRAGCACHE fragCache;

    unsigned cxGlyphBits;
    unsigned cyGlyphBits;
    HBITMAP hbmGlyph;
    HDC hdcGlyph;

    unsigned bmShadowWidth;
    unsigned bmShadowHeight;
    PBYTE bmShadowBits;

    /************************************************************************/
    // Bitmap cache entries.
    /************************************************************************/  
#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    // Holds the persistent cache file name
    TCHAR PersistCacheFileName[MAX_PATH];
    UINT EndPersistCacheDir;

    // For locking bitmap cache directory on disk
    TCHAR PersistentLockName[MAX_PATH];
    HANDLE hPersistentCacheLock;

    // These entries are used in setting up bitmap key database and sending
    // them to the server.
    // bitmapKeyEnumTimerId: ID of timer used to schedule bitmap key enumeration.
    // currentBitmapCacheId: currently enumerating keys at bitmap cache Id
    // currentBitmapCacheIndex: currently enumerating keys at bitmap cache index
    // sendBitmapCacheId: currently we are sending keys at bitmap cache id
    // sendBitmapCacheIndex: currently we are sending keys at bitmap cache index
    // sendNumBitmapKeys: how many keys we have sent so far
    // numKeyEntries: number of keys at each bitmap cache 
    // totalNumKeyEntries: total number of keys in all caches
    // BitmapCacheSizeInUse: total disk space in use for bitmaps
    // pBitmapKeyDB: bitmap key database with all keys stored here
    // totalNumErrorPDUs: maximum number of error pdus allowed to send to server
    // lastTimeErrorPDU: last time sent error pdu for the cache
    INT_PTR bitmapKeyEnumTimerId;
    USHORT currentBitmapCacheId;
    HANDLE currentFileHandle;
    USHORT sendBitmapCacheId;
    ULONG sendBitmapCacheIndex;
    ULONG sendNumBitmapKeys;
    ULONG numKeyEntries[TS_BITMAPCACHE_MAX_CELL_CACHES];
    ULONG totalNumKeyEntries;
    ULONG bitmapCacheSizeInUse;
    ULONG totalNumErrorPDUs;
    HPTS_BITMAPCACHE_PERSISTENT_LIST_ENTRY pBitmapKeyDB[TS_BITMAPCACHE_MAX_CELL_CACHES];
    ULONG maxNumKeyEntries[TS_BITMAPCACHE_MAX_CELL_CACHES];
    ULONG lastTimeErrorPDU[TS_BITMAPCACHE_MAX_CELL_CACHES];

    ULONG BytesPerCluster;
    ULONG NumberOfFreeClusters;

    //
    // Copy multiplier we are enumerating at
    //
    ULONG currentCopyMultiplier;

    //
    // Has the bmp cache memory been allocated
    //
    BOOL  fBmpCacheMemoryAlloced;
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

    // Property settings from which we determine how to allocate bitmap
    // caches at connect time.
    ULONG RegBitmapCacheSize;
    //
    // Virtual Cache size setting is indexed by copy multiplier
    //
    ULONG PropBitmapVirtualCacheSize[3];
    ULONG RegScaleBitmapCachesByBPP;
    USHORT RegNumBitmapCaches : 15;
    USHORT RegPersistenceActive : 1;
    UINT RegBCProportion[TS_BITMAPCACHE_MAX_CELL_CACHES];
    ULONG RegBCMaxEntries[TS_BITMAPCACHE_MAX_CELL_CACHES];
    UHBITMAPCACHEINFO RegBCInfo[TS_BITMAPCACHE_MAX_CELL_CACHES];
  
    // Specifies the bitmap caching version the server has advertised.
    // This is rev1 if no TS_BITMAPCACHE_CAPABILITYSET_HOSTSUPPORT
    // capability was sent. Otherwise this version is the one advertised
    // in HOSTSUPPORT.
    unsigned BitmapCacheVersion;

    // The number of cell caches in actual use in this session, and data
    // for each cache. We need a copy of the cache attributes here
    // because the capabilities could be rev1 or rev2 but we need a
    // consistent format to work with.
    unsigned NumBitmapCaches;

    // Flags:
    //   bConnected: Used to reduce disconnect work done since it is
    //       possible to receive more than one call to UH_Disconnected()
    //       at session end.
    //   bEnabled : We can be disabled multiple times in a session. Make
    //       sure we don't do a bunch of extra work.
    //   bEnabledOnce: Indicates if we have already received a previous
    //       UH_Enable(). Used to keep from having to do work more than once
    //       on reconnect.
    //   bPersistentBitmapKeysSent: Set when we've sent the key PDUs to the
    //       server.
    //   bPersistenceActive: Session flag to determine if persistence is
    //       active.
    //   bPersistenceDisable: Property setting for persistent flag might
    //       change after UH_Init.  But, if we have this flag on, we won't
    //       enable persistent caching even the property changed.
    //   bWarningDisplayed: We only need to display once per session for 
    //       persistent caching failure
    //   bBitmapKeyEnumComplete: Set when we've done bitmap key enumeration
    //       on disk
    unsigned bConnected : 1;
    unsigned bEnabled : 1;
    unsigned bEnabledOnce : 1;
    unsigned bPersistenceActive : 1;
    unsigned bPersistenceDisable : 1;
    unsigned bPersistentBitmapKeysSent : 1;
    unsigned bWarningDisplayed : 1;
    unsigned bBitmapKeyEnumComplete : 1;
    unsigned bBitmapKeyEnumerating : 1;

    /************************************************************************/
    /* Memblt bitmap caches                                                 */
    /************************************************************************/
    UHBITMAPCACHE bitmapCache[TS_BITMAPCACHE_MAX_CELL_CACHES];

    /************************************************************************/
    // Offscreen bitmap cache
    /************************************************************************/
    HDC                   hdcOffscreenBitmap;
    HBITMAP               hUnusedOffscrBitmap;
    unsigned              offscrCacheSize;
    unsigned              offscrCacheEntries;
    HPUHOFFSCRBITMAPCACHE offscrBitmapCache;
    unsigned              sendOffscrCacheErrorPDU;

#ifdef DRAW_NINEGRID
    /************************************************************************/
    // DrawNineGrid bitmap cache
    /************************************************************************/
    BYTE                 *drawNineGridDecompressionBuffer;
    unsigned            drawNineGridDecompressionBufferSize;
    BYTE                 *drawNineGridAssembleBuffer;
    unsigned              drawNineGridAssembleBufferOffset;
    unsigned              drawNineGridAssembleBufferBpp;
    unsigned              drawNineGridAssembleBufferWidth;
    unsigned              drawNineGridAssembleBufferHeight;
    unsigned              drawNineGridAssembleBufferSize;
    BOOL                  drawNineGridAssembleCompressed;
    HDC                   hdcDrawNineGridBitmap;
    HBITMAP               hUnusedDrawNineGridBitmap;
    HRGN                  hDrawNineGridClipRegion;
    unsigned              drawNineGridCacheSize;
    unsigned              drawNineGridCacheEntries;
    PUHDRAWSTREAMBITMAPCACHE drawNineGridBitmapCache;
    unsigned              sendDrawNineGridErrorPDU;
    HMODULE               hModuleGDI32;
    HMODULE               hModuleMSIMG32;
    FNGDI_DRAWSTREAM     *pfnGdiDrawStream;
    FNGDI_ALPHABLEND     *pfnGdiAlphaBlend;
    FNGDI_TRANSPARENTBLT *pfnGdiTransparentBlt;
#endif

#ifdef DRAW_GDIPLUS
    // Graw Gdiplus
    TSUINT32                ServerGdiplusSupportLevel;
    unsigned                GdiplusCacheLevel;
    BOOL                    fSendDrawGdiplusErrorPDU;
    unsigned                DrawGdiplusFailureCount;
    #define                 DRAWGDIPLUSFAILURELIMIT 5
    // Buffer to hold Gdiplus order
    BYTE                    *drawGdipBuffer;
    BYTE                    *drawGdipBufferOffset;
    ULONG                   drawGdipBufferSize;
    // Buffer to hold Gdiplus cache order
    BYTE                    *drawGdipCacheBuffer;
    BYTE                    *drawGdipCacheBufferOffset;
    ULONG                  drawGdipCacheBufferSize;
    // Buffer to hold assembled Gdiplus
    BYTE                    *drawGdipEmfBuffer;
    BYTE                    *drawGdipEmfBufferOffset;
    //  GdipCache Index data
    PUHGDIPLUSOBJECTCACHE   GdiplusGraphicsCache;
    PUHGDIPLUSOBJECTCACHE   GdiplusObjectPenCache;
    PUHGDIPLUSOBJECTCACHE   GdiplusObjectBrushCache;
    PUHGDIPLUSIMAGECACHE    GdiplusObjectImageCache;
    PUHGDIPLUSOBJECTCACHE   GdiplusObjectImageAttributesCache;
    // Free list for the image cache chunks
    INT16                   *GdipImageCacheFreeList;
    // Head index of the free list
    INT16                   GdipImageCacheFreeListHead;
    #define                 GDIP_CACHE_INDEX_DEFAULT -1
    INT16                   *GdipImageCacheIndex;
    // GdipCache actual data
    BYTE                    *GdipGraphicsCacheData;
    BYTE                    *GdipBrushCacheData;
    BYTE                    *GdipPenCacheData;
    BYTE                    *GdipImageAttributesCacheData;
    BYTE                    *GdipImageCacheData;
    // Gdiplus CacheEntries
    unsigned                GdiplusGraphicsCacheEntries;
    unsigned                GdiplusObjectPenCacheEntries;
    unsigned                GdiplusObjectBrushCacheEntries;
    unsigned                GdiplusObjectImageCacheEntries;
    unsigned                GdiplusObjectImageAttributesCacheEntries;
    // Gdiplus CacheChunkSize
    unsigned                GdiplusGraphicsCacheChunkSize;
    unsigned                GdiplusObjectBrushCacheChunkSize;
    unsigned                GdiplusObjectPenCacheChunkSize;
    unsigned                GdiplusObjectImageAttributesCacheChunkSize;
    unsigned                GdiplusObjectImageCacheChunkSize;
    // Total cache size allowed for Gdiplus image (number of chunks)
    unsigned                GdiplusObjectImageCacheTotalSize;
    // Maximun size for a single Gdiplus image cache (number of chunks)
    unsigned                GdiplusObjectImageCacheMaxSize;
        
    HMODULE                         hModuleGDIPlus;
    FNGDIPPLAYTSCLIENTRECORD        *pfnGdipPlayTSClientRecord;
    FNGDIPLUSSTARTUP                *pfnGdiplusStartup;
    FNGDIPLUSSHUTDOWN               *pfnGdiplusShutdown;
    ULONG_PTR                       gpToken;
    BOOL                            gpValid;
    BOOL                            fGdipEnabled;
#endif // DRAW_GDIPLUS

    /************************************************************************/
    /* Brush caches                                                         */
    /************************************************************************/
    PUHMONOBRUSHCACHE   pMonoBrush;
    PUHCOLORBRUSHINFO   pColorBrushInfo;
#ifdef DC_HICOLOR
    PUHHICOLORBRUSHINFO pHiColorBrushInfo;
#endif
    PUHCOLORBRUSHCACHE  pColorBrush;

    RGBQUAD         rgbQuadTable[UH_NUM_8BPP_PAL_ENTRIES];

#ifdef DC_DEBUG
    //
    // Bitmap Cache Monitor data.
    //
    HWND     hwndBitmapCacheMonitor;
    UH_CACHE_MONITOR_ENTRY_DATA DCHPTR MonitorEntries[
            TS_BITMAPCACHE_MAX_CELL_CACHES];
    unsigned numCacheBlobsPerRow;
    unsigned yCacheStart[TS_BITMAPCACHE_MAX_CELL_CACHES];
    unsigned yDisplayedCacheBitmapStart;
    unsigned displayedCacheId;
    ULONG    displayedCacheEntry;
    BOOL     showBitmapCacheMonitor;
    INT_PTR  timerBitmapCacheMonitor;
#endif /* DC_DEBUG */

    //
    // Disabled bitmap support
    //
    HBITMAP hbmpDisconnectedBitmap;
    HBITMAP hbmpUnusedDisconnectedBitmap;
    HDC     hdcDisconnected;
#ifdef OS_WINCE
#define MAX_AOT_RECTS        10		//AOT = Always On Top
    RECT    rcaAOT[MAX_AOT_RECTS];
    ULONG   ulNumAOTRects;
#endif
} UH_DATA, FAR *PUH_DATA;


//
// Class definition
//
class CUH
{
public:
    CUH(CObjs* objs);
    ~CUH();

public:
    //
    // Public data members
    //
    UH_DATA _UH;

public:
    //
    // API
    //

    /****************************************************************************/
    /* FUNCTION PROTOTYPES                                                      */
    /****************************************************************************/
    void DCAPI UH_Init();
    void DCAPI UH_Term();
    DCBOOL DCAPI UH_SetServerFontCount(unsigned);
    
    void DCAPI UH_Enable(ULONG_PTR);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUH, UH_Enable);
    void DCAPI UH_Disable(ULONG_PTR);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUH, UH_Disable);
    void DCAPI UH_Disconnect(ULONG_PTR);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUH, UH_Disconnect);

    void DCAPI UH_SetConnectOptions(ULONG_PTR);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUH, UH_SetConnectOptions);

    void DCAPI UH_ResetFontMap();
    VOID DCAPI UH_BufferAvailable();
    VOID DCAPI UH_SendPersistentKeysAndFontList();
    VOID DCAPI UH_ClearOneBitmapDiskCache(UINT cacheId,UINT copyMultiplier);
    HRESULT DCAPI UH_ProcessOrders(unsigned, BYTE FAR *, DCUINT);
    HRESULT DCAPI UH_ProcessBitmapPDU(TS_UPDATE_BITMAP_PDU_DATA UNALIGNED FAR *, 
        DCUINT);
    HRESULT DCAPI UH_ProcessPalettePDU(
        TS_UPDATE_PALETTE_PDU_DATA UNALIGNED FAR *, DCUINT);

#ifdef DISABLE_SHADOW_IN_FULLSCREEN
    void DCAPI UH_DisableShadowBitmap(ULONG_PTR);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUH, UH_DisableShadowBitmap);
    void DCAPI UH_EnableShadowBitmap(ULONG_PTR);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUH, UH_EnableShadowBitmap);
    void DCAPI UH_SetBBarRect(ULONG_PTR pData);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUH, UH_SetBBarRect);
    void DCAPI UH_SetBBarVisible(ULONG_PTR pData);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUH, UH_SetBBarVisible);
#endif
    
    // "Internal" functions required to handle inline functions below.
    void DCINTERNAL UHUseSolidPaletteBrush(DCCOLOR);
    
    #ifdef DC_DEBUG
    void DCAPI UH_ChangeDebugSettings(ULONG_PTR);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUH, UH_ChangeDebugSettings); 
    #endif /* DC_DEBUG */
    
    void DCAPI UH_SetClipRegion(int, int, int, int);
    #ifdef DC_DEBUG
    HWND UH_GetBitmapCacheMonHwnd() {return _UH.hwndBitmapCacheMonitor;}
    #endif

#ifdef DRAW_NINEGRID
    HRESULT DCAPI UH_DrawNineGrid(PUH_ORDER, unsigned, RECT*);
#endif

#ifdef DRAW_GDIPLUS
    BOOL DCAPI UHDrawGdiplusStartup(ULONG_PTR);
    void DCAPI UHDrawGdiplusShutdown(ULONG_PTR);
#endif

    /****************************************************************************/
    /* INLINE FUNCTIONS                                                         */
    /*                                                                          */
    /****************************************************************************/
    inline void DCINTERNAL UHAddUpdateRegion(PUH_ORDER, HRGN);

    /****************************************************************************/
    /* Name:      UHResetClipRegion                                             */
    /*                                                                          */
    /* Purpose:   Disables any clipping region in the current output DC.        */
    /****************************************************************************/
    _inline void DCAPI UH_ResetClipRegion()
    {
        DC_BEGIN_FN("UHResetClipRegion");

#if defined (OS_WINCE)
        if ((! _UH.rectReset) || (_UH.validClipDC != _UH.hdcDraw))
#endif
            {
        SelectClipRgn(_UH.hdcDraw, NULL);
    
        /********************************************************************/
        /* Indicate that the region is currently reset.                     */
        /********************************************************************/
        _UH.rectReset = TRUE;        
#if defined (OS_WINCE)
            _UH.validClipDC = _UH.hdcDraw;
#endif
            }
    
        DC_END_FN();
    }

#ifdef SMART_SIZING
    /****************************************************************************/
    /* Name:      UHClearUpdateRegion                                           */
    /*                                                                          */
    /* Purpose:   Clears the update region                                      */
    /****************************************************************************/
    _inline void DCAPI UHClearUpdateRegion()
    {
        DC_BEGIN_FN("UHClearUpdateRegion");
        SetRectRgn(_UH.hrgnUpdate, 0, 0, 0, 0);
        _pOp->OP_ClearUpdateRegion();
        DC_END_FN();
    }
#endif // SMART_SIZING

#ifdef DC_HICOLOR
#define UHGetOffsetIntoCache(iEntry, cacheId)               \
            (iEntry) * UH_CellSizeFromCacheID((cacheId))
#endif

    /****************************************************************************/
    /* Name:      UH_OnUpdatePDU                                                */
    /*                                                                          */
    /* Purpose:   Process an Update PDU.                                        */
    /*                                                                          */
    /* Params:    IN - pUpdatePDU: pointer to Update PDU                        */
    /****************************************************************************/
    inline HRESULT DCAPI UH_OnUpdatePDU(
            TS_UPDATE_HDR_DATA UNALIGNED FAR *pUpdatePDU,
            DCUINT dataLen)
    {
        DC_BEGIN_FN("UH_OnUpdatePDU");
        HRESULT hr = S_OK;
        PBYTE pDataEnd = (PBYTE)pUpdatePDU + dataLen;
  
        switch (pUpdatePDU->updateType) {
            case TS_UPDATETYPE_ORDERS: {
                TS_UPDATE_ORDERS_PDU_DATA UNALIGNED FAR *pHdr;

                // SECURITY: 552403
                CHECK_READ_N_BYTES(pUpdatePDU, pDataEnd, sizeof(TS_UPDATE_ORDERS_PDU_DATA), hr,
                    (TB, _T("Bad TS_UPDATE_ORDERS_PDU_DATA; Size %u"), dataLen));                    
    
                pHdr = (TS_UPDATE_ORDERS_PDU_DATA UNALIGNED FAR *)pUpdatePDU;
                TRC_NRM((TB, _T("Order PDU")));
                hr = UH_ProcessOrders(pHdr->numberOrders, pHdr->orderList,
                    dataLen - FIELDOFFSET(TS_UPDATE_ORDERS_PDU_DATA, orderList));
                DC_QUIT_ON_FAIL(hr);
                break;
            }
    
            case TS_UPDATETYPE_BITMAP:
                TRC_NRM((TB, _T("Bitmap PDU")));

                // SECURITY: 552403
                CHECK_READ_N_BYTES(pUpdatePDU, pDataEnd, sizeof(TS_UPDATE_BITMAP_PDU_DATA), hr,
                    (TB, _T("Bad TS_UPDATE_BITMAP_PDU_DATA; Size %u"), dataLen));  
                
                hr = UH_ProcessBitmapPDU((PTS_UPDATE_BITMAP_PDU_DATA)pUpdatePDU,
                    dataLen);
                DC_QUIT_ON_FAIL(hr);
                break;
    
            case TS_UPDATETYPE_PALETTE:
                TRC_NRM((TB, _T("Palette PDU")));

                // SECURITY: 552403
                CHECK_READ_N_BYTES(pUpdatePDU, pDataEnd, sizeof(TS_UPDATE_PALETTE_PDU_DATA), hr,
                    (TB, _T("Bad TS_UPDATE_PALETTE_PDU_DATA; Size %u"), dataLen));  
                
                hr = UH_ProcessPalettePDU((PTS_UPDATE_PALETTE_PDU_DATA)pUpdatePDU,
                    dataLen);
                DC_QUIT_ON_FAIL(hr);
                break;
    
            case TS_UPDATETYPE_SYNCHRONIZE:
                TRC_NRM((TB, _T("Sync PDU")));
                break;
    
            default:
                TRC_ERR((TB, _T("Unexpected Update PDU type: %u"),
                        pUpdatePDU->updateType));
                DC_QUIT;
                break;
        }
    
        /************************************************************************/
        /* If there are a large number of PDUs arriving, messages flood the     */
        /* Receive Thread's message queue and it is possible for WM_PAINT       */
        /* messages to not get processed within a reasonable amount of time     */
        /* (as they have the lowest priority).  We therefore ensure that        */
        /* any outstanding WM_PAINTs are flushed if they have not been          */
        /* processed within UH_WORST_CASE_WM_PAINT_PERIOD.                      */
        /*                                                                      */
        /* Note that the normal processing of updates does not involve          */
        /* WM_PAINT messages - we draw directly to the Output Window.           */
        /* WM_PAINTs are only generated by resizing or obscuring/revealing      */
        /* an area of the client window.                                        */
        /************************************************************************/
        _pOp->OP_MaybeForcePaint();

DC_EXIT_POINT:
        DC_END_FN();
        return hr;
    } /* UH_OnUpdatePDU */
    
    
    /****************************************************************************/
    /* Name:      UH_GetShadowBitmapDC                                          */
    /*                                                                          */
    /* Purpose:   Returns the Shadow Bitmap DC handle.                          */
    /*                                                                          */
    /* Returns:   Shadow Bitmap DC handle.                                      */
    /****************************************************************************/
    inline HDC DCAPI UH_GetShadowBitmapDC()
    {
        DC_BEGIN_FN("UH_GetShadowBitmapDC");
        DC_END_FN();
        return _UH.hdcShadowBitmap;
    }

    /****************************************************************************/
    /* Name:      UH_GetDisconnectBitmapDC                                      */
    /*                                                                          */
    /* Purpose:   Returns the Disconnect Bitmap DC handle                       */
    /*                                                                          */
    /* Returns:   Disconnect DC handle.                                         */
    /****************************************************************************/
    inline HDC DCAPI UH_GetDisconnectBitmapDC()
    {
        DC_BEGIN_FN("UH_GetShadowBitmapDC");
        DC_END_FN();
        return _UH.hdcDisconnected;
    }

    
    
    /****************************************************************************/
    /* Name:      UH_GetCurrentOutputDC                                         */
    /*                                                                          */
    /* Purpose:   Returns the DC handle for the current output surface          */
    /*            (either the Shadow Bitmap or the Output Window).              */
    /*                                                                          */
    /* Returns:   Output DC handle.                                             */
    /****************************************************************************/
    inline HDC DCAPI UH_GetCurrentOutputDC()
    {
        DC_BEGIN_FN("UH_GetCurrentOutputDC");
        DC_END_FN();
        return _UH.hdcDraw;
    }
    
    
    /****************************************************************************/
    /* Name:      UH_ShadowBitmapIsEnabled                                      */
    /*                                                                          */
    /* Purpose:   Returns whether the Shadow Bitmap is currently enabled        */
    /*                                                                          */
    /* Returns:   TRUE if Shadow Bitmap is enabled, FALSE otherwise             */
    /****************************************************************************/
    inline BOOL DCAPI UH_ShadowBitmapIsEnabled()
    {
        DC_BEGIN_FN("UH_ShadowBitmapIsEnabled");
        DC_END_FN();
        return _UH.shadowBitmapEnabled;
    }
    
    
    /****************************************************************************/
    /* Name:      UH_GetCurrentPalette                                          */
    /*                                                                          */
    /* Purpose:   Returns the handle of the current palette                     */
    /*                                                                          */
    /* Returns:   Palette handle                                                */
    /****************************************************************************/
    inline HPALETTE DCAPI UH_GetCurrentPalette()
    {
        DC_BEGIN_FN("UH_GetCurrentPalette");
        DC_END_FN();
        return _UH.hpalCurrent;
    }
    
#ifdef OS_WINCE
#define UHGetColorRef(_color,_type,_uhinst)  (_uhinst)->UHGetColorRefCE(_color,_type)
#endif

    /****************************************************************************/
    // Convert the supplied DCCOLOR into a COLORREF.
    // Macro to force inline.
    /****************************************************************************/
#ifdef DC_HICOLOR

#ifndef OS_WINCE
#define UHGetColorRef(_color, _type, uhinst)                                 \
    (((uhinst)->_UH.protocolBpp == 24)                                                 \
      ?                                                                      \
        RGB(_color.u.rgb.red, _color.u.rgb.green, _color.u.rgb.blue)         \
      :                                                                      \
        (((uhinst)->_UH.protocolBpp == 16)                                             \
          ?                                                                  \
            RGB((((*((PDCUINT16)&(_color))) >> 8) & 0x00f8) |                \
                (((*((PDCUINT16)&(_color))) >> 13) & 0x0007),                \
                (((*((PDCUINT16)&(_color))) >> 3) & 0x00fc) |                \
                (((*((PDCUINT16)&(_color))) >> 9) & 0x0003),                 \
                (((*((PDCUINT16)&(_color))) << 3) & 0x00f8) |                \
                (((*((PDCUINT16)&(_color))) >> 2) & 0x0007))                 \
        :                                                                    \
          (((uhinst)->_UH.protocolBpp == 15)                                           \
             ?                                                               \
                RGB((((*((PDCUINT16)&(_color))) >> 7) & 0x00f8) |            \
                    (((*((PDCUINT16)&(_color))) >> 12) & 0x0007),            \
                    (((*((PDCUINT16)&(_color))) >> 2) & 0x00f8) |            \
                    (((*((PDCUINT16)&(_color))) >> 7) & 0x0007),             \
                    (((*((PDCUINT16)&(_color))) << 3) & 0x00f8) |            \
                    (((*((PDCUINT16)&(_color))) >> 2) & 0x0007))             \
              :                                                              \
                ((_type) != UH_COLOR_RGB                                     \
                  ?                                                          \
                    ((uhinst)->_UH.colorIndicesEnabled                                 \
                       ?                                                     \
                         DC_PALINDEX((_color).u.index)                       \
                       :                                                     \
                          PALETTERGB((_color).u.rgb.red,                     \
                                     (_color).u.rgb.green,                   \
                                     (_color).u.rgb.blue))                   \
                  :                                                          \
                    RGB((_color).u.rgb.red,                                  \
                        (_color).u.rgb.green,                                \
                        (_color).u.rgb.blue)))) )       

#else
inline COLORREF UHGetColorRefCE(DCCOLOR color, DCUINT type)
{
    COLORREF outCol;

    DC_BEGIN_FN("UHGetColorRef");

    if (_UH.protocolBpp == 24)
    {
        outCol = RGB(color.u.rgb.red, color.u.rgb.green, color.u.rgb.blue);
    }
    else if (_UH.protocolBpp == 16)
    {
        outCol = RGB((((*((PDCUINT16)&(color))) & TS_RED_MASK_16BPP)  >> 8),
                     (((*((PDCUINT16)&(color))) & TS_GREEN_MASK_16BPP)>> 3),
                     (((*((PDCUINT16)&(color))) & TS_BLUE_MASK_16BPP) << 3));
    }
    else if (_UH.protocolBpp == 15)
    {
        outCol = RGB((((*((PDCUINT16)&(color))) & TS_RED_MASK_15BPP)  >> 7),
                     (((*((PDCUINT16)&(color))) & TS_GREEN_MASK_15BPP)>> 2),
                     (((*((PDCUINT16)&(color))) & TS_BLUE_MASK_15BPP) << 3));
    }
    else if (type == UH_COLOR_RGB)
    {
        outCol = RGB(color.u.rgb.red, color.u.rgb.green, color.u.rgb.blue);
    }
    else
    {
        if (_UH.colorIndicesEnabled)
        {
            if (g_CEConfig != CE_CONFIG_WBT)
            {
                if (_UH.paletteIsFixed)
                {
                    PALETTEENTRY pe;
                    GetPaletteEntries(_UH.hpalCurrent, color.u.index, 1, &pe);
                    outCol = PALETTERGB(pe.peRed, pe.peGreen, pe.peBlue);
                }
                else
                {
                    outCol = DC_PALINDEX(color.u.index);
                }
            }
            else
            {
                outCol = DC_PALINDEX(color.u.index);
            }
        }
        else
        {
            outCol = PALETTERGB(color.u.rgb.red,
                                color.u.rgb.green,
                                color.u.rgb.blue);
        }
    }

    TRC_NRM((TB, "Returning rgb %08lx", outCol));
    DC_END_FN();
    return(outCol);
}

#endif // OS_WINCE
#else // not HICOLOR


    #ifndef OS_WINCE
    #define UHGetColorRef(_color, _type, uhinst) \
        ((_type) != UH_COLOR_RGB ?  \
                ((uhinst)->_UH.colorIndicesEnabled ? DC_PALINDEX((_color).u.index) :  \
                    PALETTERGB((_color).u.rgb.red, (_color).u.rgb.green,  \
                    (_color).u.rgb.blue)) :  \
                RGB((_color).u.rgb.red, (_color).u.rgb.green,  \
                    (_color).u.rgb.blue))
    #else
    
    _inline COLORREF DCINTERNAL UHGetColorRef(DCCOLOR color, DCUINT type)
    {
        COLORREF outCol;
    
        DC_BEGIN_FN("UHGetColorRef");
    
        if (type == UH_COLOR_RGB)
        {
            outCol = RGB(color.u.rgb.red, color.u.rgb.green, color.u.rgb.blue);
        }
        else
        {
            if (_UH.colorIndicesEnabled)
            {
                if (g_CEConfig != CE_CONFIG_WBT)
                {
                    if (_UH.paletteIsFixed)
                    {
                        PALETTEENTRY pe;
                        GetPaletteEntries(_UH.hpalCurrent, color.u.index, 1, &pe);
                        outCol = PALETTERGB(pe.peRed, pe.peGreen, pe.peBlue);
                    }
                    else
                    {
                        outCol = DC_PALINDEX(color.u.index);
                    }
                }
                else
                {
                    outCol = DC_PALINDEX(color.u.index);
                }
            }
            else
            {
                outCol = PALETTERGB(color.u.rgb.red,
                                    color.u.rgb.green,
                                    color.u.rgb.blue);
            }
        }
    
        TRC_NRM((TB, _T("Returning rgb %08lx"), outCol));
        DC_END_FN();
        return(outCol);
    }
    #endif // OS_WINCE
    #endif // DC_HICOLOR
    
    /****************************************************************************/
    /* Name:      UHUseBkColor                                                  */
    /*                                                                          */
    /* Purpose:   Selects a given background color into the output DC.          */
    /*                                                                          */
    /* Params:    IN: color     - background color                              */
    /*            IN: colorType - color type                                    */
    /****************************************************************************/
#if defined (OS_WINCE)

    #define UHUseBkColor(_color, _colorType, uhinst) \
    {  \
        COLORREF rgb;  \
    \
        rgb = UHGetColorRef((_color), (_colorType), (uhinst));  \
        if ((rgb != (uhinst)->_UH.lastBkColor) || \
        	((uhinst)->_UH.hdcDraw != (uhinst)->_UH.validBkColorDC))  \
        {  \
            SetBkColor((uhinst)->_UH.hdcDraw, rgb);  \
            (uhinst)->_UH.lastBkColor = rgb;  \
            (uhinst)->_UH.validBkColorDC = (uhinst)->_UH.hdcDraw;  \
        }  \
    }
    
#else

    #define UHUseBkColor(_color, _colorType, uhinst) \
    {  \
        COLORREF rgb;  \
    \
        rgb = UHGetColorRef((_color), (_colorType), (uhinst));  \
        {  \
            SetBkColor((uhinst)->_UH.hdcDraw, rgb);  \
            (uhinst)->_UH.lastBkColor = rgb;  \
        }  \
    }

#endif
    
    /****************************************************************************/
    /* Name:      UHUseTextColor                                                */
    /*                                                                          */
    /* Purpose:   Selects a given text color into the output DC.                */
    /*                                                                          */
    /* Params:    IN: color     - text color                                    */
    /*            IN: colorType - color type                                    */
    /****************************************************************************/
#if defined (OS_WINCE)

    #define UHUseTextColor(_color, _colorType, uhinst) \
    {  \
        COLORREF rgb;  \
    \
        rgb = UHGetColorRef((_color), (_colorType), uhinst);  \
        if ((rgb != (uhinst)->_UH.lastTextColor) || \
        	((uhinst)->_UH.hdcDraw != (uhinst)->_UH.validTextColorDC))  \
        {  \
            SetTextColor((uhinst)->_UH.hdcDraw, rgb);  \
            (uhinst)->_UH.lastTextColor = rgb;  \
            (uhinst)->_UH.validTextColorDC = (uhinst)->_UH.hdcDraw;  \
        }  \
    }
    
#else

    #define UHUseTextColor(_color, _colorType, uhinst) \
    {  \
        COLORREF rgb;  \
    \
        rgb = UHGetColorRef((_color), (_colorType), uhinst);  \
        {  \
            SetTextColor((uhinst)->_UH.hdcDraw, rgb);  \
            (uhinst)->_UH.lastTextColor = rgb;  \
        }  \
    }


#endif
    
    /****************************************************************************/
    /* Name:      UH_UseBrushEx                                                 */
    /*                                                                          */
    /* Purpose:   Creates and selects a given brush into the current output     */
    /*            DC.                                                           */
    /*                                                                          */
    /* Purpose:   Sets given brush origin in the output DC.                     */
    /*                                                                          */
    /* Params:    IN: x, y      - brush origin                                  */
    /*            IN: style     - brush style                                   */
    /*            IN: hatch     - brush hatch                                   */
    /*            IN: color     - brush color                                   */
    /*            IN: colorType - type of color                                 */
    /*            IN: extra     - array of bitmap bits for custom brushes       */
    /****************************************************************************/
    inline HRESULT DCAPI UH_UseBrushEx(
            int      x,
            int      y,
            unsigned style,
            unsigned hatch,
            DCCOLOR  color,
            unsigned colorType,
            PBYTE    pextra)
    {
        DC_BEGIN_FN("UH_UseBrushEx");
        HRESULT hr = S_OK;
    
        UHUseBrushOrg(x, y);
        hr = UHUseBrush(style, hatch, color, colorType, pextra);

    DC_EXIT_POINT:
        DC_END_FN();
        return hr;
    }


    /****************************************************************************/
    /* Name:      UH_ProcessServerCaps                                          */
    /*                                                                          */
    /* Purpose:   Processes the server's capabilities. Called on sender thread. */
    /* +++NOTE: Called on sender thread.                                        */
    /*                                                                          */
    /* Returns:   Nothing                                                       */
    /*                                                                          */
    /* Params:    IN: capsLength - number of bytes pointed to by pCaps          */
    /*            IN: pCaps - pointer to the combined capabilities              */
    /****************************************************************************/
    inline void DCAPI UH_ProcessServerCaps(PTS_ORDER_CAPABILITYSET pOrderCaps)
    {
        DC_BEGIN_FN("UH_ProcessServerCaps");

        TRC_ASSERT(pOrderCaps, (TB,_T("pOrderCaps == NULL in call to UH_ProcessServerCaps")));
        if (pOrderCaps)
        {
            // Look to see if the server will be sending us palette indices
            // rather than RGB values.
            if (_UH.colorIndicesEnabled)
            {
                if (pOrderCaps->orderFlags & TS_ORDERFLAGS_COLORINDEXSUPPORT)
                {
                    TRC_NRM((TB, _T("color indices ARE supported")));
                    _UH.colorIndicesEnabled = TRUE;
                }
                else
                {
                    TRC_NRM((TB, _T("color indices NOT supported")));
                    _UH.colorIndicesEnabled = FALSE;
                }
            }
        }
    
        DC_END_FN();
    } /* UH_ProcessServerCaps */
    
    
    /****************************************************************************/
    // UH_ProcessBCHostSupportCaps
    //
    // Processes a TS_BITMAPCACHE_CAPABILITYSET_HOSTSUPPORT sent by the server.
    // These caps are used to determine the bitmap caching protocol sequences
    // to be used.
    // +++NOTE: Called on sender thread.
    /****************************************************************************/
    inline void DCAPI UH_ProcessBCHostSupportCaps(
            TS_BITMAPCACHE_CAPABILITYSET_HOSTSUPPORT *pHostSupport)
    {
        DC_BEGIN_FN("UH_ProcessBCHostSupportCaps");
    
        if (pHostSupport != NULL &&
                pHostSupport->CacheVersion == TS_BITMAPCACHE_REV2)
            _UH.BitmapCacheVersion = TS_BITMAPCACHE_REV2;
        else
            _UH.BitmapCacheVersion = TS_BITMAPCACHE_REV1;
    
        TRC_NRM((TB,_T("Received HOSTSUPPORT caps, cache version %u"),
                _UH.BitmapCacheVersion));
    
        DC_END_FN();
    }

    /**************************************************************************/
    /* Name:      UHIsValidGlyphCacheID                                       */
    /**************************************************************************/
    inline HRESULT DCAPI UHIsValidGlyphCacheID(unsigned cacheId)
    {
        return (cacheId < UH_GLC_NUM_CACHES) ? S_OK : E_TSC_CORE_CACHEVALUE;
    }

    /**************************************************************************/
    /* Name:      UHIsValidGlyphCacheIDIndex                                  */
    /**************************************************************************/
    HRESULT DCAPI UHIsValidGlyphCacheIDIndex(unsigned cacheId, unsigned cacheIndex);

    /**************************************************************************/
    /* Name:      UHIsValidMonoBrushCacheIndex                                */
    /**************************************************************************/
    inline HRESULT DCAPI UHIsValidMonoBrushCacheIndex(unsigned cacheIndex) 
    {
        return cacheIndex < UH_MAX_MONO_BRUSHES ? S_OK : E_TSC_CORE_CACHEVALUE;  
    }

    /**************************************************************************/
    /* Name:      UHIsValidColorBrushCacheIndex                               */
    /**************************************************************************/
    inline HRESULT DCAPI UHIsValidColorBrushCacheIndex(unsigned cacheIndex)
    {
        return cacheIndex < UH_MAX_COLOR_BRUSHES ? S_OK : E_TSC_CORE_CACHEVALUE;  
    }

    /**************************************************************************/
    /* Name:      UHIsValidColorTableCacheIndex                               */
    /**************************************************************************/
    inline HRESULT DCAPI UHIsValidColorTableCacheIndex(unsigned cacheIndex) 
    {
        return cacheIndex < UH_COLOR_TABLE_CACHE_ENTRIES ? 
            S_OK : E_TSC_CORE_CACHEVALUE;
    }

    /**************************************************************************/
    /* Name:      UHIsValidOffsreenBitmapCacheIndex                           */
    /**************************************************************************/
    HRESULT DCAPI UHIsValidOffsreenBitmapCacheIndex(unsigned cacheIndex);

    /**************************************************************************/
    /* Name:      UHIsValidBitmapCacheID                                      */
    /**************************************************************************/
    inline HRESULT DCAPI UHIsValidBitmapCacheID(unsigned cacheId)
    {
        return cacheId < _UH.NumBitmapCaches ? S_OK : E_TSC_CORE_CACHEVALUE;
    }

    /**************************************************************************/
    /* Name:      UHIsValidBitmapCacheIndex                                   */
    /**************************************************************************/
    inline HRESULT DCAPI UHIsValidBitmapCacheIndex(unsigned cacheId, 
        unsigned cacheIndex)
    {
        HRESULT hr = UHIsValidBitmapCacheID(cacheId);
        if (SUCCEEDED(hr)) {
            if (BITMAPCACHE_WAITING_LIST_INDEX == cacheIndex) {
                hr = S_OK;
            }
            else if (_UH.bitmapCache[cacheId].BCInfo.bSendBitmapKeys) {
                hr = cacheIndex < _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries ?
                    S_OK : E_TSC_CORE_CACHEVALUE;
            } 
            else {
                hr = cacheIndex < _UH.bitmapCache[cacheId].BCInfo.NumEntries ?
                    S_OK : E_TSC_CORE_CACHEVALUE;
            }
        }
        return hr;
    }

    /**************************************************************************/
    /* Name:      UHIsValidGdipCacheType                                      */
    /**************************************************************************/
    inline HRESULT DCAPI UHIsValidGdipCacheType(TSUINT16 CacheType)
    {
        HRESULT hr;
        switch (CacheType) {
            case GDIP_CACHE_GRAPHICS_DATA:
            case GDIP_CACHE_OBJECT_BRUSH:
            case GDIP_CACHE_OBJECT_PEN:
            case GDIP_CACHE_OBJECT_IMAGE:
            case GDIP_CACHE_OBJECT_IMAGEATTRIBUTES:
                hr = S_OK;
                break;
            default:
                hr = E_TSC_CORE_CACHEVALUE;
                break;
        }
        return hr;        
    }
    
    /**************************************************************************/
    /* Name:      UHIsValidGdipCacheTypeID                                    */
    /**************************************************************************/
    inline HRESULT DCAPI UHIsValidGdipCacheTypeID(TSUINT16 CacheType, 
    TSUINT16 CacheID)
    {
        HRESULT hr;
        switch (CacheType) {
            case GDIP_CACHE_GRAPHICS_DATA:
                hr = (CacheID < _UH.GdiplusGraphicsCacheEntries) ? 
                    S_OK : E_TSC_CORE_CACHEVALUE;
                break;
            case GDIP_CACHE_OBJECT_BRUSH:
                 hr = (CacheID < _UH.GdiplusObjectBrushCacheEntries) ? 
                    S_OK : E_TSC_CORE_CACHEVALUE;
                break;
            case GDIP_CACHE_OBJECT_PEN:
                 hr = (CacheID < _UH.GdiplusObjectPenCacheEntries) ? 
                    S_OK : E_TSC_CORE_CACHEVALUE;
                break;
            case GDIP_CACHE_OBJECT_IMAGE:
                 hr = (CacheID < _UH.GdiplusObjectImageCacheEntries) ? 
                    S_OK : E_TSC_CORE_CACHEVALUE;
                break;
            case GDIP_CACHE_OBJECT_IMAGEATTRIBUTES:
                 hr = (CacheID < _UH.GdiplusObjectImageAttributesCacheEntries) ? 
                    S_OK : E_TSC_CORE_CACHEVALUE;
                break;
            default:
                hr = E_TSC_CORE_CACHEVALUE;
                break;
        }
        return hr;
    }

    /**************************************************************************/
    /* Name:      UHGdipCacheChunkSize                                        */
    /**************************************************************************/
    inline unsigned DCAPI UHGdipCacheChunkSize(TSUINT16 CacheType)
    {
        unsigned rc;
        
        switch (CacheType) {
        case GDIP_CACHE_GRAPHICS_DATA:
            rc = _UH.GdiplusGraphicsCacheChunkSize;
            break;
        case GDIP_CACHE_OBJECT_BRUSH:
            rc = _UH.GdiplusObjectBrushCacheChunkSize;
            break;
        case GDIP_CACHE_OBJECT_PEN:
            rc = _UH.GdiplusObjectPenCacheChunkSize;            
            break;
        case GDIP_CACHE_OBJECT_IMAGE:
            rc = _UH.GdiplusObjectImageCacheChunkSize;              
            break;
        case GDIP_CACHE_OBJECT_IMAGEATTRIBUTES:
            rc = _UH.GdiplusObjectImageAttributesCacheChunkSize;               
            break;
        default:
            rc = 0;
            break;
        }
        return rc;        
    }

    inline void DCAPI UH_SetServerGdipSupportLevel(
            UINT32 SupportLevel)
    {
        _UH.ServerGdiplusSupportLevel = SupportLevel;
    }

    /**************************************************************************/
    /* Name:      UHIsValidNineGridCacheIndex                                 */
    /**************************************************************************/
    inline HRESULT DCAPI UHIsValidNineGridCacheIndex(unsigned cacheIndex)
    {
        return cacheIndex < _UH.drawNineGridCacheEntries ? 
            S_OK : E_TSC_CORE_CACHEVALUE;
    }

    /**************************************************************************/
    /* Name:      UHIsValidFragmentCacheIndex                                 */
    /**************************************************************************/
    inline HRESULT DCAPI UHIsValidFragmentCacheIndex(unsigned cacheIndex)
    {
        return (cacheIndex < UH_FGC_CACHE_MAXIMUMCELLCOUNT) ? 
            S_OK : E_TSC_CORE_CACHEVALUE;
    }

#ifdef DC_DEBUG
    void DCAPI UH_HatchRect(int, int, int, int, COLORREF, unsigned);
    DCVOID DCAPI UH_HatchOutputRect(DCINT left, DCINT top, DCINT right,
            DCINT bottom, COLORREF color, DCUINT hatchStyle);
    DCVOID DCAPI UH_HatchRectDC(HDC hdc, DCINT left, DCINT top, DCINT right,
            DCINT bottom, COLORREF color, DCUINT hatchStyle);
#endif

    HRESULT DCAPI UHDrawMemBltOrder(HDC, MEMBLT_COMMON FAR *);

#ifdef DC_DEBUG
    void DCAPI UHLabelMemBltOrder(int, int, unsigned, unsigned);
#endif

    void DCAPI UHUsePen(unsigned, unsigned, DCCOLOR, unsigned);

    /****************************************************************************/
    /* Name:      UHConvertToWindowsROP                                         */
    /*                                                                          */
    /* Purpose:   Converts a rop index (in the range 0-255) to a 32-bit Windows */
    /*            rop code.                                                     */
    /*                                                                          */
    /* Returns:   32-bit rop value.                                             */
    /****************************************************************************/
    inline UINT32 DCAPI UHConvertToWindowsROP(unsigned ropIndex)
    {
        UINT32 rc;
    
        DC_BEGIN_FN("UHConvertToWindowsROP");
    
        TRC_ASSERT((ropIndex <= 0xFF), (TB, _T("ropIndex (%u) invalid"), ropIndex));
    
        /************************************************************************/
        /* Simply take the ROP value from the uhWindowsROPs lookup table and    */
        /* place the ropIndex in the upper 16-bits.                             */
        /************************************************************************/
        rc = (((UINT32)ropIndex) << 16) | (UINT32)(uhWindowsROPs[ropIndex]);
    
        DC_END_FN();
        return rc;
    }


    HRESULT DCAPI UHUseBrush(unsigned, unsigned, DCCOLOR, unsigned, BYTE [7]);

    void DCAPI UHUseBrushOrg(int, int);


    /****************************************************************************/
    /* Name:      UHDrawGlyphOrder                                              */
    /*                                                                          */
    /* Purpose:   Initiates the drawing of a glyph order                        */
    /****************************************************************************/
    inline HRESULT DCAPI UHDrawGlyphOrder(
            LPINDEX_ORDER pOrder, 
            LPVARIABLE_INDEXBYTES pVariableBytes)
    {
        HRESULT hr = S_OK;
        DC_BEGIN_FN("UHDrawGlyphOrder");
    
        if (pOrder->cacheId >= UH_GLC_NUM_CACHES) {
            TRC_ABORT((TB,_T("Invalid glyph cacheId=%d"), pOrder->cacheId));
            hr = E_TSC_CORE_CACHEVALUE;
            DC_QUIT;
        }

        // The structure is defined with 255 elements
        if (0 >= pVariableBytes->len ||255 < pVariableBytes->len) {
            TRC_ABORT((TB,_T("Invalid glyph order length")));
            hr = E_TSC_CORE_LENGTH;
            DC_QUIT;
        }
    
        hr = _pGh->GH_GlyphOut(pOrder, pVariableBytes);

DC_EXIT_POINT:
        DC_END_FN();
        return hr;
    }

    HRESULT DCAPI UHProcessCacheGlyphOrderRev2(BYTE, unsigned, BYTE FAR *,
            unsigned);

    VOID DCINTERNAL UHResetAndRestartEnumeration();

    VOID DCINTERNAL UHSendPersistentBitmapKeyList(ULONG_PTR unusedParm);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUH, UHSendPersistentBitmapKeyList);
    inline BOOL DCINTERNAL UHReadFromCacheFileForEnum(VOID);
    VOID DCINTERNAL UHEnumerateBitmapKeyList(ULONG_PTR unusedParm);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUH, UHEnumerateBitmapKeyList);
    BOOL DCINTERNAL UHSendBitmapCacheErrorPDU(ULONG_PTR cacheId);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUH, UHSendBitmapCacheErrorPDU);
    BOOL DCINTERNAL UHSendOffscrCacheErrorPDU(DCUINT unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUH, UHSendOffscrCacheErrorPDU);
#ifdef DRAW_NINEGRID
    BOOL DCINTERNAL UHSendDrawNineGridErrorPDU(DCUINT unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUH, UHSendDrawNineGridErrorPDU);
#endif
    BOOL DCINTERNAL UHReadFromCacheIndexFile(VOID);
#ifdef DRAW_GDIPLUS
    BOOL DCINTERNAL UHSendDrawGdiplusErrorPDU(DCUINT unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUH, UHSendDrawGdiplusErrorPDU);
#endif

private:

    //
    // Internal functions (from wuhint.h)
    //

    /****************************************************************************/
    /* FUNCTIONS                                                                */
    /****************************************************************************/

#ifndef OS_WINCE    
    inline HRESULT UHSetCurrentCacheFileName(UINT cacheId, UINT copyMultiplier);
#else
    VOID UHSetCurrentCacheFileName(UINT cacheId, UINT copyMultiplier);
#endif

    inline BOOL UHGrabPersistentCacheLock();
    inline VOID UHReleasePersistentCacheLock();
    inline HANDLE UHFindFirstFile(const TCHAR *, TCHAR *, long *);
    inline BOOL UHFindNextFile(HANDLE, TCHAR *, long *);
    inline void UHFindClose(HANDLE);
    inline BOOL UHGetDiskFreeSpace(TCHAR *, ULONG *, ULONG *, ULONG *, ULONG *);

    inline DCBOOL DCINTERNAL UHIsHighVGAColor(BYTE, BYTE, BYTE);
    
    HRESULT DCINTERNAL UHCacheBitmap(UINT, UINT32,
            TS_SECONDARY_ORDER_HEADER *, PUHBITMAPINFO, PBYTE);

    inline VOID DCINTERNAL UHLoadBitmapBits(UINT, UINT32,
            PUHBITMAPCACHEENTRYHDR *, PBYTE *);

    inline VOID DCINTERNAL UHInitBitmapCachePageTable(UINT);

    inline BOOL DCINTERNAL UHAllocBitmapCachePageTable(UINT32, UINT);

    BOOL DCINTERNAL UHCreateCacheDirectory();

    DCBOOL DCINTERNAL UHAllocOneGlyphCache(PUHGLYPHCACHE, DCUINT32);

    DCBOOL DCINTERNAL UHAllocOneFragCache(PUHFRAGCACHE   pCache,
                                      DCUINT32       numEntries);

    void DCINTERNAL GHSetShadowBitmapInfo();

    unsigned DCINTERNAL UHGetANSICodePage();

    void DCINTERNAL UHCommonDisable(BOOL fDisplayDisabledBitmap);

    HRESULT DCINTERNAL UHProcessBitmapRect(TS_BITMAP_DATA UNALIGNED FAR *);
    
    void DCINTERNAL UHResetDCState();
    
    HRESULT DCINTERNAL UHProcessCacheBitmapOrder(void *, DCUINT);
    HRESULT DCINTERNAL UHProcessCacheColorTableOrder(
            PTS_CACHE_COLOR_TABLE_ORDER, DCUINT);
    HRESULT DCINTERNAL UHProcessCacheGlyphOrder(PTS_CACHE_GLYPH_ORDER, DCUINT);
    HRESULT DCINTERNAL UHProcessCacheBrushOrder(const TS_CACHE_BRUSH_ORDER *, DCUINT);
    HRESULT DCINTERNAL UHCreateOffscrBitmap(PTS_CREATE_OFFSCR_BITMAP_ORDER, 
        DCUINT, unsigned *);
    HRESULT DCINTERNAL UHSwitchBitmapSurface(PTS_SWITCH_SURFACE_ORDER, DCUINT);

    HRESULT DCINTERNAL UHDrawOffscrBitmapBits(HDC hdc, MEMBLT_COMMON FAR *pMB);

#ifdef DRAW_GDIPLUS
    HRESULT DCINTERNAL UHDrawGdiplusPDUComplete( ULONG, ULONG);
    HRESULT DCINTERNAL UHDrawGdiplusPDUFirst(PTS_DRAW_GDIPLUS_ORDER_FIRST pOrder, DCUINT, unsigned *);
    HRESULT DCINTERNAL UHDrawGdiplusPDUNext(PTS_DRAW_GDIPLUS_ORDER_NEXT pOrder, DCUINT, unsigned *);
    HRESULT DCINTERNAL UHDrawGdiplusPDUEnd(PTS_DRAW_GDIPLUS_ORDER_END pOrder, DCUINT, unsigned *);
    HRESULT DCINTERNAL UHDrawGdiplusCacheData(TSUINT16 CacheType, TSUINT16 CacheID, unsigned cbTotalSize);
    HRESULT DCINTERNAL UHAssembleGdipEmfRecord(unsigned EmfSize, unsigned TotalSize);

    HRESULT DCINTERNAL UHDrawGdiplusCachePDUFirst(PTS_DRAW_GDIPLUS_CACHE_ORDER_FIRST pOrder, DCUINT, unsigned *);
    HRESULT DCINTERNAL UHDrawGdiplusCachePDUNext(PTS_DRAW_GDIPLUS_CACHE_ORDER_NEXT pOrder, DCUINT, unsigned *);
    HRESULT DCINTERNAL UHDrawGdiplusCachePDUEnd(PTS_DRAW_GDIPLUS_CACHE_ORDER_END pOrder, DCUINT, unsigned *);

    BOOL DCINTERNAL UHDrawGdipRemoveImageCacheEntry(TSUINT16 CacheID);
#endif


#ifdef DRAW_NINEGRID
#if 0
    void DCINTERNAL UHCreateDrawStreamBitmap(PTS_CREATE_DRAW_STREAM_ORDER);
    void DCINTERNAL UHDecodeDrawStream(PBYTE streamIn, unsigned streamSize, PBYTE streamOut,
            unsigned *streamOutSize);                           
    unsigned DCINTERNAL UHDrawStream(PTS_DRAW_STREAM_ORDER pOrder);
#endif

    HRESULT DCINTERNAL UHCreateNineGridBitmap(PTS_CREATE_NINEGRID_BITMAP_ORDER, DCUINT, unsigned *);
    HRESULT DCINTERNAL CUH::UHCacheStreamBitmapFirstPDU(
            PTS_STREAM_BITMAP_FIRST_PDU pOrder, DCUINT, unsigned *);
    HRESULT DCINTERNAL CUH::UHCacheStreamBitmapNextPDU(
            PTS_STREAM_BITMAP_NEXT_PDU pOrder, DCUINT, unsigned *);
#endif

    PBYTE DCINTERNAL UHGetMemBltBits(HDC, unsigned, unsigned, unsigned *,
            PUHBITMAPCACHEENTRYHDR *);

    BOOL DCINTERNAL UHDIBCopyBits(HDC, int, int, int, int, int, int, PBYTE,
            UINT, PBITMAPINFO, BOOL);
    
    void DCINTERNAL UHCalculateColorTableMapping(unsigned);
    
    BOOL DCINTERNAL UHAllocColorTableCacheMemory();
    
    DCBOOL DCINTERNAL UHAllocGlyphCacheMemory();
    
    DCBOOL DCINTERNAL UHAllocBrushCacheMemory();

    DCBOOL DCINTERNAL UHAllocOffscreenCacheMemory();

#ifdef DRAW_NINEGRID
    DCBOOL DCINTERNAL UHAllocDrawNineGridCacheMemory();
#endif

#ifdef DRAW_GDIPLUS
    DCBOOL DCINTERNAL UHAllocDrawGdiplusCacheMemory();
#endif

    void DCINTERNAL UHReadBitmapCacheSettings();
    
    void DCINTERNAL UHAllocBitmapCacheMemory();
    
    void DCINTERNAL UHFreeCacheMemory();
    
#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    
    UINT32 DCINTERNAL UHEvictLRUCacheEntry(UINT cacheId);
    
    UINT32 DCINTERNAL UHFindFreeCacheEntry(UINT cacheId);
    
    VOID DCINTERNAL UHTouchMRUCacheEntry(UINT cacheId, UINT32 iEntry);
    
#endif //((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    
#ifdef DC_HICOLOR
DCUINT32 DCINTERNAL UHAllocOneBitmapCache(DCUINT32       maxMemToUse,
                                          DCUINT         entrySize,
                                          HPDCVOID DCPTR ppCacheData,
                                          HPDCVOID DCPTR ppCacheHdr);
#else
DCBOOL DCINTERNAL UHAllocOneBitmapCache(DCUINT32       maxMemToUse,
                                        DCUINT         entrySize,
                                        HPDCVOID DCPTR ppCacheData,
                                        HPDCVOID DCPTR ppCacheHdr);
#endif
    DCBOOL DCINTERNAL UHCreateBitmap(HBITMAP* hBitmap,
                                     HDC*     hdcBitmap,
                                     HBITMAP* hUnusedBitmap,
                                     DCSIZE   bitmapSize,
                                     INT      nForceBmpBpp=0);
    
    void DCINTERNAL UHDeleteBitmap(HDC *, HBITMAP *, HBITMAP *);

    #if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    
    BOOL DCINTERNAL UHSavePersistentBitmap(
#ifndef VM_BMPCACHE
            HANDLE                 hFile,
#else
            UINT                   cacheId,
#endif
            UINT32                 fileNum,
            PDCUINT8               pCompressedBitmapBits,
            UINT                   noBCHeader,
            PUHBITMAPINFO          pBitmapInfo);
    
    HRESULT DCINTERNAL UHLoadPersistentBitmap(
            HANDLE      hFile,
            UINT32      offset,
            UINT         cacheId,
            UINT32       cacheIndex,
            PUHBITMAPCACHEPTE pPTE);
    
    #endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    
    
    void DCINTERNAL UHMaybeCreateShadowBitmap();
    
    void DCINTERNAL UHMaybeCreateSaveScreenBitmap();

    #ifdef OS_WINCE
    void DCINTERNAL UHGetPaletteCaps();
    #endif
    
    #ifdef DC_DEBUG

    
    void DCINTERNAL UHInitBitmapCacheMonitor();

    void DCINTERNAL UHTermBitmapCacheMonitor();
    
    LRESULT CALLBACK UHBitmapCacheWndProc( HWND hwnd,
                                           UINT message,
                                           WPARAM wParam,
                                           LPARAM lParam );

    static LRESULT CALLBACK UHStaticBitmapCacheWndProc( HWND hwnd,
                                           UINT message,
                                           WPARAM wParam,
                                           LPARAM lParam );

    
    void DCINTERNAL UHSetMonitorEntryState(unsigned, ULONG, BYTE, BYTE);
    
    void DCINTERNAL UHCacheDataReceived(unsigned cacheId, ULONG cacheIndex);
    
    void DCINTERNAL UHCacheEntryUsed(
            unsigned cacheId,
            ULONG    cacheEntry,
            unsigned colorTableCacheEntry);
    
    #define UHCacheEntryEvictedFromMem(_id, _entry) \
            UHSetMonitorEntryState(_id, _entry, UH_CACHE_STATE_ON_DISK, \
                    UH_CACHE_TRANSITION_EVICTED)
    
    #define UHCacheEntryEvictedFromDisk(_id, _entry) \
            UHSetMonitorEntryState(_id, _entry, UH_CACHE_STATE_UNUSED, \
                    UH_CACHE_TRANSITION_EVICTED)
    
    #define UHCacheEntryKeyLoadOnSessionStart(_id, _entry) \
            UHSetMonitorEntryState(_id, _entry, UH_CACHE_STATE_ON_DISK, \
                    UH_CACHE_TRANSITION_KEY_LOAD_ON_SESSION_START)
    
    #define UHCacheEntryLoadedFromDisk(_id, _entry) \
            UHSetMonitorEntryState(_id, _entry, UH_CACHE_STATE_IN_MEMORY, \
                    UH_CACHE_TRANSITION_LOADED_FROM_DISK)
    
    
    void DCINTERNAL UHGetCacheBlobRect(unsigned, ULONG, LPRECT);
    
    BOOL DCINTERNAL UHGetCacheBlobFromPoint(LPPOINT, unsigned *, ULONG *);
    
    void DCINTERNAL UHDisplayCacheEntry(HDC, unsigned, ULONG);
    
    void DCINTERNAL UHRefreshDisplayedCacheEntry();
    
    void DCINTERNAL UHEnableBitmapCacheMonitor(void);
    
    void DCINTERNAL UHDisconnectBitmapCacheMonitor(void);
    #endif /* DC_DEBUG */
    
    #if ((defined(OS_WINCE)) && (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    
    #ifndef _tremove
    #define _tremove DeleteFile
    #endif
    
    #define WINCE_STORAGE_CARD_DIRECTORY    _T("\\Storage Card\\")
    #define WINCE_FILE_SYSTEM_ROOT          _T("\\")
    
    #endif
    
    
    /****************************************************************************/
    /* Name:      UHUseBkMode                                                   */
    /*                                                                          */
    /* Purpose:   Sets given background mode in output DC.                      */
    /****************************************************************************/

#if defined (OS_WINCE)

    #define UHUseBkMode(_mode, uhinst)  \
        if (((_mode) != (uhinst)->_UH.lastBkMode) || \
        	    ((uhinst)->_UH.hdcDraw != (uhinst)->_UH.validBkModeDC))  \
        {  \
            SetBkMode((uhinst)->_UH.hdcDraw, (_mode));  \
            (uhinst)->_UH.lastBkMode = (_mode);  \
            (uhinst)->_UH.validBkModeDC = (uhinst)->_UH.hdcDraw;  \
        }

#else

    #define UHUseBkMode(_mode, uhinst)  \
        {  \
            SetBkMode((uhinst)->_UH.hdcDraw, (_mode));  \
            (uhinst)->_UH.lastBkMode = (_mode);  \
        }
    
    
#endif
    
    /****************************************************************************/
    /* Name:      UHUseROP2                                                     */
    /*                                                                          */
    /* Purpose:   Sets given ROP2 in the output DC.                             */
    /****************************************************************************/
#if defined (OS_WINCE)

    #define UHUseROP2(_rop2, uhinst)  \
        if (((_rop2) != (uhinst)->_UH.lastROP2) || \
        	    ((uhinst)->_UH.hdcDraw != (uhinst)->_UH.validROPDC))  \
        {  \
            SetROP2((uhinst)->_UH.hdcDraw, (int)(_rop2));  \
            (uhinst)->_UH.lastROP2 = (_rop2);  \
            (uhinst)->_UH.validROPDC = (uhinst)->_UH.hdcDraw;  \
        }
    
    
#else

    #define UHUseROP2(_rop2, uhinst)  \
        {  \
            SetROP2((uhinst)->_UH.hdcDraw, (int)(_rop2));  \
            (uhinst)->_UH.lastROP2 = (_rop2);  \
        }
    
#endif    
    
    
    /****************************************************************************/
    /* Name:      UHUseBrushOrg                                                 */
    /*                                                                          */
    /* Purpose:   Sets given brush origin in the output DC.                     */
    /****************************************************************************/
    
    /************************************************************************/
    /* JPB: There is a bug in WinNT as follows (as far as I can determine   */
    /* from observing the external behavior!)...                            */
    /*                                                                      */
    /* When drawing to DIBSections, a particular (unknown) graphics         */
    /* operation occasionally modifies the brush origin in the DC state (in */
    /* kernel mode).  I don't know what this operation is, and think that   */
    /* it probably shouldn't be doing it. But it does.                      */
    /*                                                                      */
    /* If this was the only problem, we could handle it by simply setting   */
    /* the origin to the desired value before every graphics call.          */
    /* However, this doesn't work!  It appears that there is a "fastpath"   */
    /* check in the GDI that compares the supplied parameters with the      */
    /* previously set parameters, and takes an early exit if they are the   */
    /* same (i.e. does not update the DC). Therefore if we set the origin   */
    /* to (0,0), it gets mangled by the DIBSection code, then we try to     */
    /* set it to (0,0) again the actual DC value is NOT updated (i.e. stays */
    /* in the mangled state).                                               */
    /*                                                                      */
    /* We therefore have to force the new origin to be set correctly in the */
    /* DC by setting it twice: once to a value different from the one we    */
    /* want, then once to the actual value.  Not pretty, but unfortunately  */
    /* seems to be the only way to ensure that the origin is set correctly! */
    /*                                                                      */
    /* This problem has only been observed when drawing to 8bpp DIBSections */
    /* on 16bpp and 24bpp machines.                                         */
    /************************************************************************/

    /************************************************************************/
    /* For Win9x we need to unrealise and re-select the brush before the    */
    /* new origin will take effect (BLAH!).  On NT this does nothing.       */
    /************************************************************************/
    
    #define UHUseBrushOrg(_x, _y, uhinst) \
        SetBrushOrgEx((uhinst)->_UH.hdcDraw, (_x) + 1, (_y) + 1, NULL);  \
        SetBrushOrgEx((uhinst)->_UH.hdcDraw, (_x), (_y), NULL);
    
#ifdef DC_HICOLOR
/****************************************************************************/
/* Macro to calculate the number of cache entries that fit in a given space */
/****************************************************************************/
#define CALC_NUM_CACHE_ENTRIES(newNumEntries, origNumEntries, memLen, cacheId) \
    {                                                                        \
        DCUINT32 numEntries = (memLen) / UH_CellSizeFromCacheID((cacheId));  \
        newNumEntries = DC_MIN(numEntries, origNumEntries);                  \
    }
#endif
    
    /****************************************************************************/
    /* Name:      UHUseFillMode                                                 */
    /*                                                                          */
    /* Purpose:   Sets given fill mode in the output DC.                        */
    /****************************************************************************/
    #if !defined(OS_WINCE) || defined(OS_WINCE_POLYFILLMODE)
    #define UHUseFillMode(_mode, uhinst) \
        {  \
            SetPolyFillMode((uhinst)->_UH.hdcDraw, ((_mode) == ORD_FILLMODE_WINDING) ?  \
                    WINDING : ALTERNATE);  \
            (uhinst)->_UH.lastFillMode = (unsigned)(_mode);  \
        }
    
    #else
    
    #define UHUseFillMode(_mode, uhinst) \
        (uhinst)->_UH.lastFillMode = (_mode);
    
    #endif
    
    BOOL UHCreateDisconnectedBitmap();

private:
    CGH* _pGh;
    COP* _pOp;
    CSL* _pSl;
    CUT* _pUt;
    CFS* _pFs;
    COD* _pOd;
    CIH* _pIh;
    CCD* _pCd;
    CUI* _pUi;
    CCC* _pCc;
    CCLX* _pClx;
    COR* _pOr;

private:
    CObjs* _pClientObjects;

};

#undef TRC_GROUP
#undef TRC_FILE
#undef TSC_HR_FILEID

#endif // _H_UH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\tdint.cpp ===
/****************************************************************************/
// atdint.c
//
// Transport driver - portable internal functions.
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/
#include <adcg.h>

extern "C" {
#define TRC_FILE "atdint"
#define TRC_GROUP TRC_GROUP_NETWORK
#include <atrcapi.h>
#include <adcgfsm.h>
}

#include "autil.h"
#include "td.h"
#include "xt.h"
#include "cd.h"
#include "nl.h"
#include "wui.h"


/****************************************************************************/
/* TD FSM TABLE                                                             */
/* ============                                                             */
/*                                                                          */
/* EVENTS                          STATES                                   */
/* 0 TD_EVT_TDINIT                 0  TD_ST_NOTINIT                         */
/* 1 TD_EVT_TDTERM                 1  TD_ST_DISCONNECTED                    */
/* 2 TD_EVT_TDCONNECT_IP           2  TD_ST_WAITFORDNS                      */
/* 3 TD_EVT_TDCONNECT_DNS          3  TD_ST_WAITFORSKT                      */
/* 4 TD_EVT_TDDISCONNECT           4  TD_ST_CONNECTED                       */
/* 5 TD_EVT_WMTIMER                5  TD_ST_WAITFORCLOSE                    */
/* 6 TD_EVT_OK                                                              */
/* 7 TD_EVT_ERROR                                                           */
/* 8 TD_EVT_CONNECTWITHENDPOINT                                             */
/*                                                                          */
/*     Stt | 0    1    2    3    4    5                                     */
/*     ====================================                                 */
/*     Evt |                                                                */
/*     0   | 1A   /    /    /    /    /      (TD_EVT_TDINIT)                */
/*         |                                                                */
/*     1   | /    0X   0Z   0Z   0Z   0Z     (TD_EVT_TDTERM)                */
/*         |                                                                */
/*     2   | /    3B   /    /    /    /      (TD_EVT_TDCONNECT_IP)          */
/*         |                                                                */
/*     3   | /    2C   /    /    /    /      (TD_EVT_TDCONNECT_DNS)         */
/*         |                                                                */
/*     4   | /    /    1Y   1Y   5D   5-     (TD_EVT_DISCONNECT)            */
/*         |                                                                */
/*     5   | 0-   1-   1Y   1Y   4-   1W     (TD_EVT_WMTIMER)               */
/*         |                                                                */
/*     6   | 0-   1-   3B   4E   4-   1Y     (TD_EVT_OK)                    */
/*         |                                                                */
/*     7   | 0-   1-   1Y   1Y   1Y   1W     (TD_EVT_ERROR)                 */
/*                                                                          */
/*     8   | 0-  Conn  /    /    /    /      (ACT_CONNECTENDPOINT)          */
/*                                                                          */
/*     9   | /    /    1W   1W   1W   1-     (TD_EVT_DROPLINK)              */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/* '/' = illegal event/state combination                                    */
/* '-' = no action                                                          */
/*                                                                          */
/****************************************************************************/
const FSM_ENTRY tdFSM[TD_FSM_INPUTS][TD_FSM_STATES] =
/* TD_EVT_TDINIT */
  {{{TD_ST_DISCONNECTED, ACT_A},
    {STATE_INVALID,      ACT_NO},
    {STATE_INVALID,      ACT_NO},
    {STATE_INVALID,      ACT_NO},
    {STATE_INVALID,      ACT_NO},
    {STATE_INVALID,      ACT_NO}},

/* TD_EVT_TDTERM */
   {{STATE_INVALID,      ACT_NO},
    {TD_ST_NOTINIT,      ACT_X},
    {TD_ST_NOTINIT,      ACT_Z},
    {TD_ST_NOTINIT,      ACT_Z},
    {TD_ST_NOTINIT,      ACT_Z},
    {TD_ST_NOTINIT,      ACT_Z}},


/* TD_EVT_TDCONNECT_IP */
   {{STATE_INVALID,      ACT_NO},
    {TD_ST_WAITFORSKT,   ACT_B},
    {STATE_INVALID,      ACT_NO},
    {STATE_INVALID,      ACT_NO},
    {STATE_INVALID,      ACT_NO},
    {STATE_INVALID,      ACT_NO}},

/* TD_EVT_TDCONNECT_DNS */
   {{STATE_INVALID,      ACT_NO},
    {TD_ST_WAITFORDNS,   ACT_C},
    {STATE_INVALID,      ACT_NO},
    {STATE_INVALID,      ACT_NO},
    {STATE_INVALID,      ACT_NO},
    {STATE_INVALID,      ACT_NO}},

/* TD_EVT_TDDISCONNECT */
   {{STATE_INVALID,      ACT_NO},
    {TD_ST_DISCONNECTED, ACT_NO},
    {TD_ST_DISCONNECTED, ACT_Y},
    {TD_ST_DISCONNECTED, ACT_Y},
    {TD_ST_WAITFORCLOSE, ACT_D},
    {TD_ST_WAITFORCLOSE, ACT_NO}},

/* TD_EVT_WMTIMER */
   {{TD_ST_NOTINIT,      ACT_NO},
    {TD_ST_DISCONNECTED, ACT_NO},
    {TD_ST_DISCONNECTED, ACT_Y},
    {TD_ST_DISCONNECTED, ACT_Y},
    {TD_ST_CONNECTED,    ACT_NO},
    {TD_ST_DISCONNECTED, ACT_W}},

/* TD_EVT_OK */
   {{TD_ST_NOTINIT,      ACT_NO},
    {TD_ST_DISCONNECTED, ACT_NO},
    {TD_ST_WAITFORSKT,   ACT_B},
    {TD_ST_CONNECTED,    ACT_E},
    {TD_ST_CONNECTED,    ACT_NO},
    {TD_ST_DISCONNECTED, ACT_Y}},

/* TD_EVT_ERROR */
   {{TD_ST_NOTINIT,      ACT_NO},
    {TD_ST_DISCONNECTED, ACT_NO},
    {TD_ST_DISCONNECTED, ACT_Y},
    {TD_ST_DISCONNECTED, ACT_Y},
    {TD_ST_DISCONNECTED, ACT_Y},
    {TD_ST_DISCONNECTED, ACT_W}},

/* TD_EVT_CONNECTWITHENDPOINT */
   {{STATE_INVALID,      ACT_NO},
    {TD_ST_WAITFORSKT,   ACT_CONNECTENDPOINT},  // TDBeginSktConnectWithConnectedEndpoint() will post
    {STATE_INVALID,      ACT_NO},               // itself a FD_CONNECT message to setups rest of data
    {STATE_INVALID,      ACT_NO},
    {STATE_INVALID,      ACT_NO},
    {STATE_INVALID,      ACT_NO}},

/* TD_EVT_DROPLINK */
   {{STATE_INVALID,      ACT_NO},
    {TD_ST_DISCONNECTED, ACT_NO},
    {TD_ST_DISCONNECTED, ACT_W},
    {TD_ST_DISCONNECTED, ACT_W},
    {TD_ST_DISCONNECTED, ACT_W},
    {TD_ST_DISCONNECTED, ACT_NO}},
  };


/****************************************************************************/
/* Name:      TDConnectFSMProc                                              */
/*                                                                          */
/* Purpose:   The TD connection FSM.                                        */
/*                                                                          */
/* Params:    IN  fsmEvent  - an external event.                            */
/*            IN  eventData - four bytes of event related data.             */
/****************************************************************************/
DCVOID DCINTERNAL CTD::TDConnectFSMProc(DCUINT fsmEvent, ULONG_PTR eventData)
{
    DCUINT action;

    DC_BEGIN_FN("TDConnectFSMProc");

    /************************************************************************/
    /* Run the FSM.                                                         */
    /************************************************************************/
    EXECUTE_FSM(tdFSM, fsmEvent, _TD.fsmState, action,tdEventText,tdStateText);
    TRC_NRM((TB, _T("eventData:%p"), eventData));

    /************************************************************************/
    /* Now perform the action.                                              */
    /************************************************************************/
    switch (action)
    {
        case ACT_A:
        {
            /****************************************************************/
            /* Initialize _TD.  Note that any errors in this function are    */
            /* fatal and are handled by directly calling the UT fatal       */
            /* error handler.                                               */
            /****************************************************************/
            TDInit();
        }
        break;

        case ACT_CONNECTENDPOINT:
        {
            /****************************************************************/
            /* Socket connection pre-established                            */
            /****************************************************************/
            TDBeginSktConnectWithConnectedEndpoint();
        }
        break;

        case ACT_B:
        {
            /****************************************************************/
            /* Begin the socket connection process.                         */
            /****************************************************************/
            TDBeginSktConnect((u_long) eventData);
        }
        break;

        case ACT_C:
        {
            /****************************************************************/
            /* We need to perform a DNS lookup, so resolve the address and  */
            /* call the state machine again to check the result of the      */
            /* resolution call.                                             */
            /****************************************************************/
            TDBeginDNSLookup((PDCACHAR) eventData);
        }
        break;

        case ACT_D:
        {
            /****************************************************************/
            /* Disconnect processing.  First of all start the disconnect    */
            /* timer.  Normally the server will respond to our graceful     */
            /* close attempt prior to this timer popping.  However, just in */
            /* the case the server decides to take a hike, we have this     */
            /* timer which ensures that we tidy up.                         */
            /****************************************************************/
            TDSetTimer(TD_DISCONNECTTIMEOUT);

            /****************************************************************/
            /* Set the flag to indicate that there is no more data          */
            /* available in _TD.                                             */
            /****************************************************************/
            _TD.dataInTD = FALSE;

            /****************************************************************/
            /* Decouple to the sender thread and clear the send queue.      */
            /****************************************************************/

            _pCd->CD_DecoupleSyncNotification(CD_SND_COMPONENT, this,
                                        CD_NOTIFICATION_FUNC(CTD,TDClearSendQueue),
                                        0);

            /****************************************************************/
            /* Initiate the graceful close by calling shutdown with         */
            /* SD_SEND specified.  This lets the server know that we've     */
            /* finished sending.  If it's feeling up to it, the server will */
            /* shortly get back to us with an FD_CLOSE which signifies that */
            /* the graceful close has completed.                            */
            /*                                                              */
            /* However just in case the server misses a beat, we've got a   */
            /* timer running as well.  If it pops before the server gets    */
            /* back to us, we'll just pull everything down anyway.          */
            /****************************************************************/
            TRC_NRM((TB, _T("Issue shutdown (SD_SEND)")));
            if (shutdown(_TD.hSocket, SD_SEND) != 0)
            {
                TRC_ALT((TB, _T("Shutdown error: %d"), WSAGetLastError()));
            }

            /****************************************************************/
            /* Now hang around waiting for the server to get back to us,    */
            /* or the timer to pop.                                         */
            /****************************************************************/
        }
        break;

        case ACT_E:
        {
            /****************************************************************/
            /* We're now connected - so get rid of the connection timeout   */
            /* timer.                                                       */
            /****************************************************************/
            TDKillTimer();

            /****************************************************************/
            /* Set the required options on this socket.  We do the          */
            /* following:                                                   */
            /*                                                              */
            /*  - set the receive buffer size to TD_WSRCVBUFSIZE            */
            /*  - set the send buffer size to TD_WSSNDBUFSIZE               */
            /*  - disable Keep Alives                                       */
            /*                                                              */
            /* Note that these calls should not be made until the           */
            /* connection is established.                                   */
            /****************************************************************/
#ifndef OS_WINCE
            TDSetSockOpt(SOL_SOCKET,  SO_RCVBUF,     TD_WSRCVBUFSIZE);
            TDSetSockOpt(SOL_SOCKET,  SO_SNDBUF,     TD_WSSNDBUFSIZE);
#endif
            TDSetSockOpt(SOL_SOCKET,  SO_KEEPALIVE,  0);

			_pXt->XT_OnTDConnected();
		}
        break;

        case ACT_W:
        {
            /****************************************************************/
            /* Disconnect has timed out or failed.  Close the socket but    */
            /* don't pass an error indication to the user.                  */
            /****************************************************************/
            TRC_NRM((TB, _T("Disconnection timeout / failure")));
            TDDisconnect();
            _pXt->XT_OnTDDisconnected(NL_DISCONNECT_LOCAL);
        }
        break;

        case ACT_X:
        {
            /****************************************************************/
            /* Termination action - reverse of Action A.  Just call TDTerm. */
            /****************************************************************/
            TDTerm();
        }
        break;

        case ACT_Y:
        {
            /****************************************************************/
            /* Begin tidying up.                                            */
            /****************************************************************/
            TDDisconnect();

            /****************************************************************/
            /* Now call the layer above to let it know that we've           */
            /* disconnected.  <eventData> contains the disconnect reason    */
            /* code which must be non-zero.                                 */
            /****************************************************************/
            TRC_ASSERT((eventData != 0), (TB, _T("eventData is zero")));
            TRC_ASSERT((HIWORD(eventData) == 0),
                  (TB, _T("disconnect reason code unexpectedly using 32 bits")));
            _pXt->XT_OnTDDisconnected((DCUINT)eventData);
        }
        break;

        case ACT_Z:
        {
            /****************************************************************/
            /* Termination action.  First of all tidy up.  Then call        */
            /* TDTerm.                                                      */
            /****************************************************************/
            TDDisconnect();
            TDTerm();
        }
        break;

        case ACT_NO:
        {
            TRC_NRM((TB, _T("No action required")));
        }
        break;

        default:
        {
            TRC_ABORT((TB, _T("Unknown action:%u"), action));
        }
    }

    DC_END_FN();
} /* TDConnectFSMProc */


/****************************************************************************/
/* Name:      TDAllocBuf                                                    */
/*                                                                          */
/* Purpose:   This function allocates the memory for a send buffer and then */
/*            stores a pointer to this memory in the buffer information     */
/*            structure.                                                    */
/*                                                                          */
/* Params:    IN  pSndBufInf - a pointer to send buffer info structure.     */
/*            IN  size       - the size of the buffer to allocate.          */
/****************************************************************************/
DCVOID DCINTERNAL CTD::TDAllocBuf(PTD_SNDBUF_INFO pSndBufInf, DCUINT size)
{
    DC_BEGIN_FN("TDAllocBuf");

    /************************************************************************/
    /* Allocate the memory for the send buffer.                             */
    /************************************************************************/
    pSndBufInf->pBuffer = (PDCUINT8) UT_Malloc( _pUt, size);
    pSndBufInf->size    = size;

    /************************************************************************/
    /* Check that the memory allocation succeeded.                          */
    /************************************************************************/
    if (NULL == pSndBufInf->pBuffer)
    {
        TRC_ERR((TB, _T("Failed to allocate %u bytes of memory"),
                 size));
        _pUi->UI_FatalError(DC_ERR_OUTOFMEMORY);
    }

    TRC_NRM((TB, _T("SndBufInf:%p size:%u buffer:%p"),
             pSndBufInf,
             pSndBufInf->size,
             pSndBufInf->pBuffer));

    DC_END_FN();
} /* TDAllocBuf */


/****************************************************************************/
/* Name:      TDInitBufInfo                                                 */
/*                                                                          */
/* Purpose:   This function initializes a buffer.                           */
/*                                                                          */
/* Params:    IN  pSndBufInf - a pointer to send buffer info structure.     */
/****************************************************************************/
DCVOID DCINTERNAL CTD::TDInitBufInfo(PTD_SNDBUF_INFO pSndBufInf)
{
    DC_BEGIN_FN("TDInitBufInfo");

    TRC_ASSERT((NULL != pSndBufInf), (TB, _T("pSndBufInf is NULL")));

    /************************************************************************/
    /* Initialize the buffer fields.                                        */
    /************************************************************************/
    pSndBufInf->pNext           = 0;
    pSndBufInf->inUse           = FALSE;
    pSndBufInf->pDataLeftToSend = NULL;
    pSndBufInf->bytesLeftToSend = 0;

    DC_END_FN();
} /* TDInitBufInfo */


/****************************************************************************/
// TDClearSendQueue
//
// Called on sender context (via direct or decoupled call) to clear the
// send queue on disconnect.
/****************************************************************************/
void DCINTERNAL CTD::TDClearSendQueue(ULONG_PTR unused)
{
    DCUINT i;

    DC_BEGIN_FN("TDClearSendQueue");

    DC_IGNORE_PARAMETER(unused);

    TRC_NRM((TB, _T("Clearing the send queue - initial buffers:")));
    TD_TRACE_SENDINFO(TRC_LEVEL_NRM);
    _TD.pFQBuf = NULL;

    // Buffers can get taken from the pool, but not added to the
    // send queue. This happens when the call goes down between
    // the get and the send. Answer?  Mark all the buffers in the
    // pools as not in use.
    for (i = 0; i < TD_SNDBUF_PUBNUM; i++) {
        TRC_DBG((TB, _T("Tidying pub buf:%u inUse:%s size:%u"),
                 i,
                 _TD.pubSndBufs[i].inUse ? "TRUE" : "FALSE",
                 _TD.pubSndBufs[i].size));
        _TD.pubSndBufs[i].pNext           = NULL;
        _TD.pubSndBufs[i].inUse           = FALSE;
        _TD.pubSndBufs[i].bytesLeftToSend = 0;
        _TD.pubSndBufs[i].pDataLeftToSend = NULL;
    }

    for (i = 0; i < TD_SNDBUF_PRINUM; i++) {
        TRC_DBG((TB, _T("Tidying pri buf:%u inUse:%s size:%u"),
                 i,
                 _TD.priSndBufs[i].inUse ? "TRUE" : "FALSE",
                 _TD.priSndBufs[i].size));
        _TD.priSndBufs[i].pNext           = NULL;
        _TD.priSndBufs[i].inUse           = FALSE;
        _TD.priSndBufs[i].bytesLeftToSend = 0;
        _TD.priSndBufs[i].pDataLeftToSend = NULL;
    }

    TRC_NRM((TB, _T("Send queue cleared - final buffers:")));
    TD_TRACE_SENDINFO(TRC_LEVEL_NRM);

    DC_END_FN();
}


/****************************************************************************/
// TDSendError
//
// Called on receive thread (possibly decoupled) to notify a send error.
/****************************************************************************/
void DCINTERNAL CTD::TDSendError(ULONG_PTR unused)
{
    DC_BEGIN_FN("TDSendError");

    DC_IGNORE_PARAMETER(unused);

    // Call the FSM with an error.
    TDConnectFSMProc(TD_EVT_ERROR,
            NL_MAKE_DISCONNECT_ERR(NL_ERR_TDONCALLTOSEND));

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\uidata.h ===
/****************************************************************************/
// uidata.h
//
// Data for the UI component.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_WUIDATA
#define _H_WUIDATA

#ifdef AXCORE
#include <wuiids.h>
#endif // AXCORE

/****************************************************************************/
/* Structure: UI_DATA                                                       */
/*                                                                          */
/* Description: Component data in the User Interface                        */
/****************************************************************************/

#define UI_MAX_DOMAIN_LENGTH            512
#define UI_MAX_USERNAME_LENGTH          512
#define UI_MAX_PASSWORD_LENGTH          512
#define UI_MAX_PASSWORD_LENGTH_OLD      32  
#define UI_FILENAME_MAX_LENGTH          15
#define UI_MAX_WORKINGDIR_LENGTH        MAX_PATH
#define UI_MAX_ALTERNATESHELL_LENGTH    MAX_PATH
#define UI_MAX_TSCFILE_LENGTH           512
#define UI_MAX_CLXCMDLINE_LENGTH        256


//
// From uierr.h
//

#include "auierr.h"


//
// Connection mode - start connection, listen, or use connected socket
//
typedef enum {
    CONNECTIONMODE_INITIATE,            // Initiate connection
    CONNECTIONMODE_CONNECTEDENDPOINT,   // Connect with connected socket.
} CONNECTIONMODE;

/****************************************************************************/
/* Number of glyph caches.                                                  */
/****************************************************************************/
#define GLYPH_NUM_CACHES   10

typedef struct tagUI_DATA
{
    HINSTANCE  hResDllInstance;

    //Comma separated list of virtual channel addin DLL's
    TCHAR *pszVChanAddinDlls;

    HINSTANCE hInstance;
    BOOL coreInitialized;
    UINT32 shareID;
    unsigned channelID;                  /* Broadcast channel to send on  */
    unsigned osMinorType;
    SOCKET TDSocket;

    HWND       hwndMain;
    HWND       hwndUIContainer;
    HWND       hwndUIMain;
    HWND       hWndCntrl;

    #if defined(OS_WIN32) && !defined(OS_WINCE)
    DCTCHAR    szIconFile[MAX_PATH];
    DCINT      iconIndex;
    #endif

    HWND       hwndContainer;
    HDC        hdcBitmap;

    WINDOWPLACEMENT windowPlacement;
    DCSIZE     controlSize;
    DCSIZE     mainWindowClientSize;
    DCSIZE     containerSize;
    DCSIZE     maxMainWindowSize;

    DCPOINT    scrollMax;
    DCPOINT    scrollPos;

    TCHAR strAddress[UT_MAX_ADDRESS_LENGTH];
    char ansiAddress[UT_MAX_ADDRESS_LENGTH];
    BOOL acceleratorCheckState;

    //
    // User requested color depth identifier
    //
    unsigned colorDepthID;

    BOOL     autoConnectEnabled;
    BOOL     smoothScrolling;
    BOOL     shadowBitmapEnabled;
    BOOL     dedicatedTerminal;
    BOOL     encryptionEnabled;
    UINT16   sasSequence;
    UINT16   transportType;
    UINT16   MCSPort;

    UINT16 clientMCSID;
    UINT16 serverMCSID;
    DCSIZE desktopSize;

    //
    // Actual color depth we connected at
    //
    int connectedColorDepth;
    UINT32 SessionId;

    BOOL fCompress;
    // Decompression context.
    RecvContext1 Context1;
    RecvContext2_64K* pRecvContext2;
    
    //
    // Internal props that are passed down
    // from the control
    //

    //Control settable properties for UH
    unsigned   orderDrawThreshold;
    ULONG      RegBitmapCacheSize;
    ULONG      RegBitmapVirtualCache8BppSize;
    ULONG      RegBitmapVirtualCache16BppSize;
    ULONG      RegBitmapVirtualCache24BppSize;
    ULONG      RegScaleBitmapCachesByBPP;
    USHORT     RegNumBitmapCaches : 15;
    USHORT     RegPersistenceActive : 1;
    UINT       RegBCProportion[TS_BITMAPCACHE_MAX_CELL_CACHES];
    ULONG      RegBCMaxEntries[TS_BITMAPCACHE_MAX_CELL_CACHES];
    TCHAR      PersistCacheFileName[MAX_PATH];
    UINT32     bSendBitmapKeys[TS_BITMAPCACHE_MAX_CELL_CACHES];
    unsigned GlyphSupportLevel;
    UINT32   cbGlyphCacheEntrySize[GLYPH_NUM_CACHES];
    unsigned fragCellSize;
    unsigned brushSupportLevel;

    //Control settable properties for IH
    UINT32   minSendInterval; /* Min time between mousemove sends (ms)*/
    UINT32   eventsAtOnce;    /* Max events to pull off in one go     */
    UINT32   maxEventCount;   /* Max number of events in InputPDU     */
    UINT32   keepAliveInterval; /* keep-alive time (seconds)          */
    BOOL     allowBackgroundInput;


#ifdef OS_WINCE
    //Flag set if user wants to override default
    //paletteIsFixed setting
    BOOL fOverrideDefaultPaletteIsFixed;
    unsigned paletteIsFixed;
#endif

#ifdef DC_DEBUG
    BOOL hatchBitmapPDUData;
    BOOL hatchIndexPDUData;
    BOOL hatchSSBOrderData;
    BOOL hatchMemBltOrderData;
    BOOL labelMemBltOrders;
    BOOL bitmapCacheMonitor;
    //
    // Random failure item passed to randomfailure dialog box
    //
    int randomFailureItem;
#endif /* DC_DEBUG */

    //
    // Scroll bar visibility flags
    //
    BOOL fVerticalScrollBarVisible;
    BOOL fHorizontalScrollBarVisible;

    unsigned connectionStatus;

    TCHAR errorString[UI_ERR_MAX_STRLEN];

    UINT32 connectFlags;

    BOOL fMouse;
    BOOL fDisableCtrlAltDel;
    BOOL fEnableWindowsKey;
    BOOL fDoubleClickDetect;
    BOOL fAutoLogon;
    BOOL fMaximizeShell;
    BOOL fBitmapPersistence;

    //
    // These properties are always Unicode
    //
    WCHAR Domain[UI_MAX_DOMAIN_LENGTH];
    WCHAR UserName[UI_MAX_USERNAME_LENGTH];
    WCHAR AlternateShell[UI_MAX_ALTERNATESHELL_LENGTH];
    WCHAR WorkingDir[UI_MAX_WORKINGDIR_LENGTH];

    //
    // Load balance info -- two, one for redirection case, one for 
    // non-redirection.  If these are NULL they are not valid.  A flag indicates
    // whether we are in the middle of a redirection.
    //
    BSTR bstrScriptedLBInfo;
    BSTR bstrRedirectionLBInfo;
    BOOL ClientIsRedirected;

    // Client load balancing redirection data.
    BOOL DoRedirection;
    UINT32 RedirectionSessionID;
    WCHAR RedirectionServerAddress[TS_MAX_SERVERADDRESS_LENGTH];
    WCHAR RedirectionUserName[UI_MAX_USERNAME_LENGTH];
    BOOL UseRedirectionUserName;
    // if client is using smartcard to logon
    BOOL fUseSmartcardLogon;



    //
    // Password/salt are binary buffers
    //
    BYTE Password[UI_MAX_PASSWORD_LENGTH];
    BYTE Salt[UT_SALT_LENGTH];

    TCHAR CLXCmdLine[UI_MAX_CLXCMDLINE_LENGTH];

    DCHOTKEY hotKey;

    CONNECTSTRUCT connectStruct;
    u_long        hostAddress;
    HANDLE        hGHBN;
    DCUINT        addrIndex;
    DCUINT        singleTimeout;
    DCUINT        licensingTimeout;
    DCUINT        disconnectReason;
    DCBOOL        fOnCoreInitializeEventCalled;
    DCBOOL        bConnect;
    HANDLE        hEvent;
    
    INT_PTR       shutdownTimer;
    DCUINT        shutdownTimeout;

    //winCE does not have GetKeyBoardType API so these
    //values are properties on the control.
    #ifdef OS_WINCE
    DCUINT32      winceKeyboardType;
    DCUINT32      winceKeyboardSubType;
    DCUINT32      winceKeyboardFunctionKey;
    #endif
    
    //
    // Fullscreen title
    //
    DCTCHAR       szFullScreenTitle[MAX_PATH];

    
    //
    // Overall connection timeout property
    //
    DCUINT        connectionTimeOut;
    DCTCHAR       szKeyBoardLayoutStr[UTREG_UI_KEYBOARD_LAYOUT_LEN];
    //
    // Flag set when the ActiveX control has 'left' it's container
    // and gone to real full screen mode.
    //
    DCBOOL          fControlIsFullScreen;
    //
    // Flag set by property on control to indicate fullscreen is handled by container
    //
    DCBOOL          fContainerHandlesFullScreenToggle;
    //
    //We are in container full screen mode
    //
    DCBOOL          fContainerInFullScreen;
    //
    // Flag set by control to indicate a request
    // to startup in fullscreen mode
    //
    DCBOOL          fStartFullScreen;

    //Instance pointer to the active x control
    //this is passed to the virtual channel Ex API's
    //so the addin can know which control instance to talk to
    IUnknown*       pUnkAxControlInstance;

    //
    // Desktop size
    //
    DCUINT        uiSizeTable[2];

    //
    // Keyboard hooking mode
    //
    DCUINT        keyboardHookMode;

    //
    // Audio redirection options
    //
    DCUINT        audioRedirectionMode;

    //
    // Device redirection
    //
    BOOL          fEnableDriveRedirection;
    BOOL          fEnablePrinterRedirection;
    BOOL          fEnablePortRedirection;
    BOOL          fEnableSCardRedirection;

    //
    // Connect to server console setting
    //
    BOOL          fConnectToServerConsole;

    // Flag set to disable internal RDPDR (only works on initialisation).
    //
    DCBOOL        fDisableInternalRdpDr;

    //
    // Smart sizing - Scale the client window
    //

#ifdef SMART_SIZING
    BOOL          fSmartSizing;
#endif // SMART_SIZING

    //
    // Event that is signaled to notify the
    // core has completed initialization
    //
    HANDLE        hEvtNotifyCoreInit;

    //
    // Set at init time, indicates if the client
    // is running on a PTS box
    //
    BOOL          fRunningOnPTS;

    //
    // Minutes to idle timeout
    //
    LONG          minsToIdleTimeout;
    HANDLE        hIdleInputTimer;

    //
    // Last error info sent from (SET_ERROR_INFO_PDU)
    // this is used to present the user with meaningful
    // error messages about why the disconnection occurred
    //
    UINT          lastServerErrorInfo;

    //
    // BBAR enabled
    //
    BOOL          fBBarEnabled;
    BOOL          fBBarPinned;
    BOOL          fBBarShowMinimizeButton;
    BOOL          fBBarShowRestoreButton;

    //
    // Grabs the focus on connection
    //
    BOOL          fGrabFocusOnConnect;

    //
    // Disconnection timeout
    //
    HANDLE        hDisconnectTimeout;

    //
    // List of server features to disable for perf reasons (e.g wallpaper)
    //
    DWORD           dwPerformanceFlags;

    //
    // Flag to indicate connect with connected endpoint
    //
    CONNECTIONMODE ConnectMode;

    //
    // TRUE to fire OnReceivedTSPublicKey() FALSE otherwise.
    //
    BOOL           fNotifyTSPublicKey;

    //
    // Enable the autoreconnect feature
    //
    BOOL           fEnableAutoReconnect;

    //
    // Allow the use of the autoreconnect cookie
    //
    BOOL           fUseAutoReconnectCookie;

    //
    // Max # of autoreconnection attempts
    //
    LONG           MaxAutoReconnectionAttempts;

    //
    // Autoreconnect cookie (this is an Opaque blob)
    //
    PBYTE          pAutoReconnectCookie;
    ULONG          cbAutoReconnectCookieLen;

    //
    // Flag to detect re-entrant call to Connect()
    // e.g. from the OnDisconnected handler
    //
    BOOL           fConnectCalledWatch;

    //
    // Flag to indicate if client requires FIPS
    //
    BOOL           fUseFIPS;
} UI_DATA;


//
// User defined messages to notify ActiveX layer
//
#define WM_INITTSC                      (WM_APP + 100)
#define WM_TERMTSC                      (WM_INITTSC + 1)
#define WM_TS_CONNECTING                (WM_INITTSC + 2)
#define WM_TS_CONNECTED                 (WM_INITTSC + 3)
#define WM_TS_LOGINCOMPLETE             (WM_INITTSC + 4)
#define WM_TS_DISCONNECTED              (WM_INITTSC + 5)
#define WM_TS_GONEFULLSCREEN            (WM_INITTSC + 6)
#define WM_TS_LEFTFULLSCREEN            (WM_INITTSC + 7)
#define WM_TS_REQUESTFULLSCREEN         (WM_INITTSC + 8)
#define WM_TS_FATALERROR                (WM_INITTSC + 9)
#define WM_TS_WARNING                   (WM_INITTSC + 10)
#define WM_TS_DESKTOPSIZECHANGE         (WM_INITTSC + 11)
#define WM_TS_IDLETIMEOUTNOTIFICATION   (WM_INITTSC + 12)
#define WM_TS_REQUESTMINIMIZE           (WM_INITTSC + 13)
#define WM_TS_ASKCONFIRMCLOSE           (WM_INITTSC + 14)
#define WM_TS_RECEIVEDPUBLICKEY         (WM_INITTSC + 15)

#define CO_MAX_COMMENT_LENGTH 64

//-----------------------------------------------------------------------------
//
// Default licensing phase timeout: 300 seconds
//
//-----------------------------------------------------------------------------

#define DEFAULT_LICENSING_TIMEOUT   300

#endif /* _H_WUIDATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\uiapi.cpp ===
//
// uiapi.cpp
//
// UI Class
//
// Copyright (C) 1997-2000 Microsoft Corporation
//

#include <adcg.h>
#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "uiapi"
#include <atrcapi.h>

#include "wui.h"

#ifdef OS_WINCE
#include <ceconfig.h>
#endif

extern "C"
{
#ifndef OS_WINCE
#include <stdio.h>
#endif // OS_WINCE
}

#include "clx.h"
#include "aco.h"
#include "nl.h"
#include "autil.h"

//
// Debugging globals
// Do not use these values for anything
// but debugging
//
CObjs* g_pTscObjects      = (CObjs*)-1;
CUI*   g_pUIObject        = (CUI*)-1;
LONG   g_cUIref           = 0;
DWORD  g_cUITotalCount    = 0;
#define DBG_EXIT_WITHACTIVE_REFS            0x0001
#define DBG_STAT_UI_INIT_CALLED             0x0002
#define DBG_STAT_UI_INIT_RET_PASS           0x0004
#define DBG_STAT_UI_TERM_CALLED             0x0008
#define DBG_STAT_UI_TERM_RETURNED           0x0010
#define DBG_STAT_TERMTSC_SENT               0x0020
#define DBG_STAT_UIREQUESTEDCLOSE_CALLED    0x0040
#define DBG_STAT_UIREQUESTEDCLOSE_RET       0x0080
#define DBG_STAT_UI_INIT_RET_FAIL           0x0100
DWORD  g_dwTscCoreDbgStatus = 0;
#define UI_DBG_SETINFO(x)   g_dwTscCoreDbgStatus |= x;

CUI::CUI()
{
    DC_BEGIN_FN("CUI");

    DC_MEMSET(&_UI, 0, sizeof(_UI));
    DC_MEMSET(&_drInitData, 0, sizeof(_drInitData));
    _Objects._pUiObject = this;

    //
    // Only used for debugging
    //
    g_pTscObjects = &_Objects;
    g_pUIObject   = this;

    #ifdef DC_DEBUG
    //
    // This will dump debug output if there was a problem creating objects
    //
    _Objects.CheckPointers();
    #endif

    _pCo = _Objects._pCoObject;
    _pUt = _Objects._pUtObject;
    _clx = _Objects._pCLXObject;
    _pTd = _Objects._pTDObject;
    _pIh = _Objects._pIhObject;
    _pCd = _Objects._pCdObject;
    _pOp = _Objects._pOPObject;
    _pUh = _Objects._pUHObject;
    _pCChan = _Objects._pChanObject;

#ifdef USE_BBAR
    _pBBar = NULL;
    _ptBBarLastMousePos.x = -0x0FFF;
    _ptBBarLastMousePos.y = -0x0FFF;
    _fBBarUnhideTimerActive = TRUE;

#endif
    _pHostData = NULL;
    _fRecursiveScrollBarMsg = FALSE;

    _fRecursiveSizeMsg = FALSE;

#ifndef OS_WINCE
    _dwLangBarFlags = 0;
    _fLangBarWasHidden = FALSE;
    _fIhHasFocus = FALSE;
    _pITLBM = NULL;
    _fLangBarStateSaved = FALSE;
#endif
    _fTerminating = FALSE;

#ifdef DC_DEBUG
    //
    // Important that these are set very early
    // otherwise the failure tables in UT will not be initialized
    // and mallocs could fail randomly
    //
    
    UI_SetRandomFailureItem(UT_FAILURE_MALLOC, 0);
    UI_SetRandomFailureItem(UT_FAILURE_MALLOC_HUGE, 0);
#endif
    
#ifndef OS_WINCE
    _pTaskBarList2 = NULL;
    _fQueriedForTaskBarList2 = FALSE;
#endif

    _pArcUI = NULL;

    InterlockedIncrement(&g_cUIref);
    g_cUITotalCount++;

    DC_END_FN();
}

CUI::~CUI()
{
    DC_BEGIN_FN("~CUI");

    if(_UI.pszVChanAddinDlls)
    {
        UT_Free(_pUt, _UI.pszVChanAddinDlls);
    }

    InterlockedDecrement(&g_cUIref);

    if(_Objects.CheckActiveReferences())
    {
        UI_DBG_SETINFO(DBG_EXIT_WITHACTIVE_REFS);
        TRC_ABORT((TB,_T("!!!!!****Deleting objs with outstanding references")));
    }

#ifdef OS_WINCE
    UI_SetCompress(FALSE);
#endif

    DC_END_FN();
}

//
// API functions
//

//
// Name:      UI_Init
//                                                                          
// Purpose:   Creates the Main and Container windows and initializes the
//            Core and Component Decoupler
//                                                                          
// Returns:   HRESULT
//                                                                          
// Params:    IN - hInstance - window information
//            IN - hprevInstance
//                                                                          
//
HRESULT DCAPI CUI::UI_Init(HINSTANCE hInstance,
                           HINSTANCE hPrevInstance,
                           HINSTANCE hResInstance,
                           HANDLE    hEvtNotifyCoreInit)
{
    WNDCLASS    mainWindowClass;
    WNDCLASS    containerWindowClass;
    WNDCLASS    tmpWndClass;
    ATOM        registerClassRc;
    DWORD       dwStyle;
    DWORD       dwExStyle = 0;

#ifndef OS_WINCE
    OSVERSIONINFO   osVersionInfo;
#endif
    HRESULT     hr = E_FAIL;

#if !defined(OS_WINCE) || defined(OS_WINCE_WINDOWPLACEMENT)
    UINT        showCmd;
#endif
    BOOL        fAddedRef = FALSE;

    DC_BEGIN_FN("UI_Init");

    _fTerminating = FALSE;

    if(!_Objects.CheckPointers())
    {
        TRC_ERR((TB,_T("Objects not all setup")));
        hr = E_OUTOFMEMORY;
        DC_QUIT;
    }
    if(!hInstance && !hResInstance)
    {
        TRC_ERR((TB,_T("Instance pointer not specified")));
        hr = E_OUTOFMEMORY;
        DC_QUIT;
    }

    if(UI_IsCoreInitialized())
    {
        //Don't allow re-entrant core init
        //one example of how this can happen
        //  Connect() method called.
        //  Core init starts
        //  Core init times out and fails in control
        //  Core completes init (and is now initialized)
        //  Connect() called again
        hr = E_FAIL;
        DC_QUIT;
    }

    _Objects.AddObjReference(UI_OBJECT_FLAG);
    fAddedRef = TRUE;

    UI_DBG_SETINFO(DBG_STAT_UI_INIT_CALLED);

    //
    // UI initialisation
    //
    TRC_DBG((TB, _T("UI initialising UT")));
    _pUt->UT_Init();

    //
    // Resources are in the executable.  Keep this separate in case the
    // resources are moved to a separate DLL: in this case just call
    // GetModuleHandle() to get hResDllInstance.
    //
    _UI.hResDllInstance = hResInstance;
    TRC_ASSERT((0 != _UI.hResDllInstance), (TB,_T("Couldn't get res dll handle")));

    //
    // Initialize External DLL
    //
    _pUt->InitExternalDll();

    //
    // Register the class for the Main Window
    //
    if (!hPrevInstance &&
        !GetClassInfo(hInstance, UI_MAIN_CLASS, &tmpWndClass))
    {
        HICON hIcon= NULL;
#if defined(OS_WIN32) && !defined(OS_WINCE)
        if(_UI.szIconFile[0] != 0)
        {
            hIcon = ExtractIcon(hResInstance, _UI.szIconFile, _UI.iconIndex);
        }
        if(NULL == hIcon)
        {
            hIcon = LoadIcon(hResInstance, MAKEINTRESOURCE(UI_IDI_MSTSC_ICON));
        }
#else
        hIcon = LoadIcon(hResInstance, MAKEINTRESOURCE(UI_IDI_MSTSC_ICON));
#endif

        TRC_NRM((TB, _T("Register Main Window class")));
        mainWindowClass.style         = 0;
        mainWindowClass.lpfnWndProc   = UIStaticMainWndProc;
        mainWindowClass.cbClsExtra    = 0;
        mainWindowClass.cbWndExtra    = sizeof(void*); //store 'this' pointer
        mainWindowClass.hInstance     = hInstance;
        mainWindowClass.hIcon         = hIcon;
        mainWindowClass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        mainWindowClass.hbrBackground = (HBRUSH) GetStockObject(HOLLOW_BRUSH);
        mainWindowClass.lpszMenuName  = NULL;
        mainWindowClass.lpszClassName = UI_MAIN_CLASS;

        registerClassRc = RegisterClass (&mainWindowClass);

        if (registerClassRc == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            TRC_ERR((TB,_T("RegisterClass failed: 0x%x"), hr));
            DC_QUIT;
        }
    }

    
#ifdef OS_WINCE
    dwStyle = WS_VSCROLL |
              WS_HSCROLL |
              WS_CLIPCHILDREN;
#else // OS_WINCE
    dwStyle = WS_VSCROLL | WS_HSCROLL | WS_CLIPCHILDREN | WS_SYSMENU;

    //
    // Main window is child to control main window.
    //
    dwStyle = dwStyle | WS_CHILD | WS_CLIPSIBLINGS;

#endif // OS_WINCE

    //
    // Create the main window Initialize the window size from the
    // windowPlacement.  Will be recalculated to allow for scrollbars or
    // fullscreen mode later.
    //
    // Note that on Win16, the SetWindowPlacement below will cause the
    // window to be shown if its position or size are changed (even though
    // we explicitly specify SW_HIDE).  We avoid this by setting the window
    // position on creation to be the same as that set later by
    // SetWindowPlacement.
    //
    _UI.hwndMain = CreateWindow(
                UI_MAIN_CLASS,                      // window class name
                _UI.szFullScreenTitle,              // window caption
                dwStyle,                            // window style
                _UI.windowPlacement.rcNormalPosition.left,
                _UI.windowPlacement.rcNormalPosition.top,
                _UI.windowPlacement.rcNormalPosition.right -
                    _UI.windowPlacement.rcNormalPosition.left,
                _UI.windowPlacement.rcNormalPosition.bottom -
                    _UI.windowPlacement.rcNormalPosition.top,
                _UI.hWndCntrl,                      // parent window handle
                NULL,                               // window menu handle
                hInstance,                          // program inst handle
                this );                             // creation parameters

    TRC_NRM((TB, _T("Main Window handle: %p"), _UI.hwndMain));

    if (_UI.hwndMain == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB,_T("CreateWindow failed: 0x%x"), hr));
        DC_QUIT;
    }

    #ifndef OS_WINCE
    HMENU hSysMenu = GetSystemMenu( _UI.hwndMain, FALSE);
    if(hSysMenu)
    {
        //
        // Always disable the move item on the window menu
        // Window menu only appears if the control goes fullscreen
        // in the non-container handled fullscreen case.
        //
        EnableMenuItem((HMENU)hSysMenu,  SC_MOVE,
                 MF_GRAYED | MF_BYCOMMAND);
    }
    #endif

    //
    // Register the Container class
    //
    TRC_DBG((TB, _T("Registering Container window class")));
    if (!hPrevInstance &&
        !GetClassInfo(hInstance, UI_CONTAINER_CLASS, &tmpWndClass))
    {
        TRC_NRM((TB, _T("Register class")));
        containerWindowClass.style         = CS_HREDRAW | CS_VREDRAW;
        containerWindowClass.lpfnWndProc   = UIStaticContainerWndProc;
        containerWindowClass.cbClsExtra    = 0;
        containerWindowClass.cbWndExtra    = sizeof(void*); //store 'this'
        containerWindowClass.hInstance     = hInstance;
        containerWindowClass.hIcon         = NULL;
        containerWindowClass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        containerWindowClass.hbrBackground = (HBRUSH) GetStockObject(HOLLOW_BRUSH);
        containerWindowClass.lpszMenuName  = NULL;
        containerWindowClass.lpszClassName = UI_CONTAINER_CLASS;

        registerClassRc = RegisterClass(&containerWindowClass);

        if (registerClassRc == 0)
        {
            //
            // Failed to register container window so terminate app
            //
            hr = HRESULT_FROM_WIN32(GetLastError());
            TRC_ERR((TB,_T("RegisterClass failed: 0x%x"), hr));
            DC_QUIT;
        }
    }

#ifndef OS_WINCE
    osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
    dwExStyle = WS_EX_NOPARENTNOTIFY; 
    if (GetVersionEx(&osVersionInfo) &&
        osVersionInfo.dwMajorVersion >= 5)
    {
        //
        // Only allow this style on NT5+ as otherwise the
        // create window can fail
        //
        dwExStyle |= WS_EX_NOINHERITLAYOUT;
    }
#else
    dwExStyle = 0; 
#endif

    //
    // Create the Container Window
    //
    TRC_DBG((TB, _T("Creating Container Window")));
    _UI.hwndContainer = CreateWindowEx(
                                     dwExStyle,
                                     UI_CONTAINER_CLASS,
                                     NULL,
                                     WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                                     0,
                                     0,
                                     _UI.containerSize.width,
                                     _UI.containerSize.height,
                                     _UI.hwndMain,
                                     NULL,
                                     hInstance,
                                     this );

    if (_UI.hwndContainer == NULL)
    {
        //
        // Failed to create container window so terminate app
        //
        TRC_ERR((TB,_T("CreateWindowEx for container failed 0x%x"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB,_T("CreateWindowEx failed: 0x%x"), hr));
        DC_QUIT;
    }

#if defined (OS_WINCE)
    /********************************************************************/
    /* Disable IME                                                      */
    /* IME is different on 98/NT than on WinCE, on 98/NT one call to    */
    /* DisableIME is enough for entire process, on WinCE we must call it*/
    /* on each window thread that is running to disable it.             */
    /********************************************************************/
    DisableIME(_UI.hwndContainer);
#endif

#if !defined(OS_WINCE) || defined(OS_WINCE_WINDOWPLACEMENT)
    UISetMinMaxPlacement();
    showCmd = _UI.windowPlacement.showCmd;
    _UI.windowPlacement.showCmd = SW_HIDE;
    SetWindowPlacement(_UI.hwndMain, &_UI.windowPlacement);
    _UI.windowPlacement.showCmd = showCmd;
#endif // !defined(OS_WINCE) || defined(OS_WINCE_WINDOWPLACEMENT)

    UISmoothScrollingSettingChanged();

#ifndef OS_WINCE
    //
    // Set up our lovely Cicero interface
    // 
    HRESULT hrLangBar = CoCreateInstance(CLSID_TF_LangBarMgr, NULL, 
            CLSCTX_INPROC_SERVER, IID_ITfLangBarMgr, (void **)&_pITLBM);
    TRC_DBG((TB, _T("CoCreateInstance(CLSID_TF_LangBarMgr) hr= 0x%08xl"), hr));
    if (FAILED(hrLangBar))
    {
        _pITLBM = NULL;
    }
#endif

    //
    // Initialize Core, much of this will happen
    // asynchrously. An event will be signaled when core init has completed
    //
    TRC_DBG((TB, _T("UI Initialising Core")));
    _pCo->CO_Init(hInstance, _UI.hwndMain, _UI.hwndContainer);

    UI_DBG_SETINFO(DBG_STAT_UI_INIT_RET_PASS);
    hr = S_OK;

    if (!DuplicateHandle(
            GetCurrentProcess(),
            hEvtNotifyCoreInit,
            GetCurrentProcess(),
            &_UI.hEvtNotifyCoreInit,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        
        // Hack: Increment the objects reference count as it will be
        //       released again on UI_TERM
        _Objects.AddObjReference(UI_OBJECT_FLAG);
        
        TRC_ERR((TB, _T("Duplicate handle call failed. hr = 0x%x"), hr));
        DC_QUIT;
    }

DC_EXIT_POINT:
    if (FAILED(hr))
    {
        if (fAddedRef)
        {
            _Objects.ReleaseObjReference(UI_OBJECT_FLAG);
        }
        UI_DBG_SETINFO(DBG_STAT_UI_INIT_RET_FAIL);
    }

    DC_END_FN();
    return hr;
}

//
// Name:      UI_ResetState
//                                                                          
// Purpose:   Resets all UI state in this component
//                                                                          
//                                                                          
// Returns:   Nothing
//                                                                          
// Params:    Nothing
//                                                                          
//                                                                          
//
DCVOID DCAPI CUI::UI_ResetState()
{
    DC_MEMSET(&_UI, 0, sizeof(_UI));
    DC_MEMSET(&_drInitData, 0, sizeof(_drInitData));
    UIInitializeDefaultSettings();
}

//
// Name:      UI_Connect
//                                                                          
// Purpose:   Connects with current settings
//                                                                          
// Returns:   HRESULT
//                                                                          
// Params:    Nothing
//                                                                          
//                                                                          
//
HRESULT DCAPI CUI::UI_Connect(CONNECTIONMODE connMode)
{
    DC_BEGIN_FN("UI_Connect");

    if(!UI_IsCoreInitialized())
    {
        TRC_ERR((TB,_T("Attempt to connect before core intialize")));
        return E_FAIL;
    }

    //Reset server error state
    UI_SetServerErrorInfo( TS_ERRINFO_NOERROR );

    //Initialiaze the RDPDR settings struct
    //this gets reset on each connection
    //rdpdr gets passed down a pointer to the struct
    //when it is initialized
    UI_InitRdpDrSettings();

    //Clean up the load balance redirect state
    if (!UI_IsAutoReconnecting()) {
        TRC_NRM((TB,_T("Cleaning up LB state")));
        UI_CleanupLBState();
    }
    else {
        TRC_NRM((TB,_T("AutoReconnecting don't cleanup lb state")));
    }
    

    _fRecursiveSizeMsg = FALSE;
#ifndef OS_WINCE
    _fLangBarStateSaved = FALSE;
#endif

    InitInputIdleTimer( UI_GetMinsToIdleTimeout() );

    _fRecursiveScrollBarMsg = FALSE;

    if (UIValidateCurrentParams(connMode))
    {
        TRC_NRM((TB, _T("Connecting")));

        UISetConnectionStatus(UI_STATUS_DISCONNECTED);
        _pCo->CO_SetConfigurationValue( CO_CFG_ACCELERATOR_PASSTHROUGH,
                                  _UI.acceleratorCheckState );
        _pCo->CO_SetHotkey(&(_UI.hotKey));
        _pCo->CO_SetConfigurationValue( CO_CFG_ENCRYPTION,
                                  _UI.encryptionEnabled);
        UIShadowBitmapSettingChanged();
    #ifdef DC_DEBUG
        UI_CoreDebugSettingChanged();
    #endif // DC_DEBUG
    

#ifdef USE_BBAR
        if(!_pBBar)
        {
            _pBBar = new CBBar( _UI.hwndMain,
                                UI_GetInstanceHandle(),
                                this,
                                _UI.fBBarEnabled);
        }

        if(!_pBBar)
        {
            TRC_ERR((TB,_T("Alloc for CBBar failed")));
            return E_OUTOFMEMORY;
        }

        _pBBar->SetPinned( _UI.fBBarPinned );
        _pBBar->SetShowMinimize(UI_GetBBarShowMinimize());
        _pBBar->SetShowRestore(UI_GetBBarShowRestore());

        //
        // Set the display name here instead of OnConnected so it
        // doesn't change w.r.t to redirections (which can change strAddress)
        //
        _pBBar->SetDisplayedText( _UI.strAddress );
#endif

        //
        // Errors from the connection are
        // signaled by Disconnect's that are fired
        // with the appropriate disconnect code
        //
        UIConnectWithCurrentParams(connMode);
        return S_OK;
    }
    else
    {
        TRC_ALT((TB, _T("UIValidateCurrentParams failed: not auto-connecting")));
        return E_FAIL;
    }

    DC_END_FN();
}

//
// Name:      UI_Term
//                                                                          
// Purpose:   Calls _pCo->CO_Term and CD_Term and destroys the main window
//                                                                          
// Returns:   HRESULT
//                                                                          
// Params:    None
//                                                                          
//
HRESULT DCAPI CUI::UI_Term(DCVOID)
{
    HWND    hwndTmp = NULL;
    HWND    hwndHasFocus = NULL;

    DC_BEGIN_FN("UI_Term");

    UI_DBG_SETINFO(DBG_STAT_UI_TERM_CALLED);

    if(!UI_IsCoreInitialized())
    {
        return E_FAIL;
    }

    _fTerminating = TRUE;
    
#ifdef OS_WINCE
    //
    // Some device are failing to restore the correct palette when the TSC
    // exits.  In an attempt to correct this behavior, we'll send the
    // necessary message to the shell that will prompt its DefWindowProc to
    // re-realize the correct palette.  Non WBT only
    //

    if (g_CEConfig != CE_CONFIG_WBT)
    {
        hwndTmp = FindWindow(TEXT("DesktopExplorerWindow"), 0);
        if(0 != hwndTmp)
        {
            PostMessage(hwndTmp, WM_QUERYNEWPALETTE, 0, 0);
            hwndTmp = 0;
        }
    }
#endif // OS_WINCE

    //
    // Here's a problem.  - _pCo->CO_Term terminates the SND thread (causes
    // call to SND_Term) - SND_Term calls IH_Term - IH_Term calls
    // DestroyWindow to destroy the input window - Because the input window
    // has the focus, DestroyWindow calls SendMessage to set the focus to
    // its parent.
    //
    // Now we have a deadly embrace: UI thread is waiting for SND thread to
    // terminate; SND thread is waiting for UI thread to process
    // SendMessage.
    //
    // The solution is to set the focus to the UI window here, so that the
    // input window no longer has the focus when it is destroyed, so that
    // DestroyWindow doesn't call SendMessage.
    //
    // WinCE has the additional problem that it doesn't set the focus to
    // another application correctly when mstsc exits.  (Something about
    // not being able to SendMessage a WM_FOCUS during thread exit).  So in
    // that case we hide the main window, which removes the need for a
    // separate SetFocus call.
    //
#ifndef OS_WINCE
    //
    // Only steal the focus if our IH has it, otherwise
    // there is no deadlock above. The main reason for not stealing
    // the focus is that in mutli-instance environments e.g the MMC snapin
    // stealing focus from another session is a bad thing (especially if the
    // session we are stealing the focus from is the one the user is working on)
    //
    hwndHasFocus = GetFocus();
    if(hwndHasFocus &&
       (hwndHasFocus == UI_GetInputWndHandle() ||
        hwndHasFocus == UI_GetBmpCacheMonitorHandle()))
    {
        TRC_NRM((TB,_T("Setting focus to main window to prevent deadlock")));
        SetFocus(_UI.hwndMain);
    }
#else // OS_WINCE
    ShowWindow(_UI.hwndMain, SW_HIDE);
#endif // OS_WINCE
    

    ShowWindow(_UI.hwndMain, SW_HIDE);

    //
    // The next lines appear to Destroy the windows OK.  In the past this
    // has not been the case.  If the process hangs in future then the fix
    // is to comment out the DestroyWindows.
    //
    // Note we null out our copies of the window handle before doing the
    // destroy to stop anyone accessing it during the detroy processing.
    //

    //
    // Very important to destory the windows before terminating the core
    // to prevent messages from getting processed while we are terminating
    //
    TRC_NRM((TB, _T("Destroying windows...")));

    hwndTmp = _UI.hwndContainer;
    _UI.hwndContainer = NULL;

    if(hwndTmp)
    {
        DestroyWindow(hwndTmp);
    }

    hwndTmp = _UI.hwndMain;
    _UI.hwndMain = NULL;

    if(hwndTmp)
    {
        DestroyWindow(hwndTmp);
    }

    //
    // Terminate the Core and Component Decoupler
    //
    TRC_DBG((TB, _T("UI Terminating Core")));
    _pCo->CO_Term();


    //
    // Free the decompression receive context (if any)
    //
    if (_UI.pRecvContext2) {
        UT_Free(_pUt, _UI.pRecvContext2);
        _UI.pRecvContext2 = NULL;
    }

    //
    // Clear and free any autoreconnect cookies
    //
    UI_SetAutoReconnectCookie(NULL, 0);


    TRC_NRM((TB, _T("Destroyed windows")));

    UnregisterClass(UI_MAIN_CLASS, UI_GetInstanceHandle());
    UnregisterClass(UI_CONTAINER_CLASS, UI_GetInstanceHandle());

    //
    // Cleanup any timers that are hanging around
    //
    if( _UI.connectStruct.hConnectionTimer )
    {
        _pUt->UTDeleteTimer( _UI.connectStruct.hConnectionTimer );
        _UI.connectStruct.hConnectionTimer = NULL;
    }

    if( _UI.connectStruct.hSingleConnectTimer )
    {
        _pUt->UTDeleteTimer( _UI.connectStruct.hSingleConnectTimer );
        _UI.connectStruct.hSingleConnectTimer = NULL;
    }

    if( _UI.connectStruct.hLicensingTimer )
    {
        _pUt->UTDeleteTimer( _UI.connectStruct.hLicensingTimer );
        _UI.connectStruct.hLicensingTimer = NULL;
    }

    if (_UI.hDisconnectTimeout)
    {
        _pUt->UTDeleteTimer( _UI.hDisconnectTimeout );
        _UI.hDisconnectTimeout = NULL;
    }

    //
    // Free up BSTRs (if any) used by redirection
    //
    if (_UI.bstrRedirectionLBInfo)
    {
        SysFreeString(_UI.bstrRedirectionLBInfo);
        _UI.bstrRedirectionLBInfo = NULL;

    }

    if (_UI.bstrScriptedLBInfo)
    {
        SysFreeString(_UI.bstrScriptedLBInfo);
        _UI.bstrRedirectionLBInfo = NULL;
    }

#ifndef OS_WINCE
    if (_pITLBM != NULL) 
    {
        _pITLBM->Release();
        _pITLBM = NULL;
    }
#endif

#ifdef USE_BBAR
    if( _pBBar )
    {
        delete _pBBar;
        _pBBar = NULL;
    }
#endif


    //
    // Release our cached interface ptr to the taskbar
    //
#ifndef OS_WINCE
    if (_pTaskBarList2)
    {
        _pTaskBarList2->Release();
        _pTaskBarList2 = NULL;
    }
#endif

    //
    // Release reference to control parent
    //
    UI_SetControlInstance(NULL);

    //
    // Cleanup our state to allow re-initialisation
    //
    UI_ResetState();

    _Objects.ReleaseObjReference(UI_OBJECT_FLAG);

    UI_DBG_SETINFO(DBG_STAT_UI_TERM_RETURNED);

    DC_END_FN();
    return S_OK;
} // UI_Term


//
// Name:      UI_FatalError
//                                                                          
// Purpose:   notify control that a fatal error has occurred
//                                                                          
// Returns:   None
//                                                                          
// Params:    IN     error  - error code
//                                                                          
//
DCVOID DCAPI CUI::UI_FatalError(DCINT error)
{
    DC_BEGIN_FN("UI_FatalError");

    TRC_ERR((TB, _T("Fatal Error - code %d"), error));

    //
    // Notify the control that a fatal error has ocurred
    //
    SendMessage(_UI.hWndCntrl,WM_TS_FATALERROR,(WPARAM)error,0);

    //
    // Container should pop up a dialog and give the user
    // the choice of exiting or launching a debugger..
    // continuing after this point will usually lead to a crash
    // as the errors are indeed fatal....
    //

    DC_END_FN();
    return;

} // UI_FatalError

//
// Name:      UI_DisplayBitmapCacheWarning
//                                                                          
// Purpose:   Display a bitmap cache warning popup
//                                                                          
// Returns:   None
//                                                                          
// Params:    IN     unusedParm
//                                                                          
//
void DCAPI CUI::UI_DisplayBitmapCacheWarning(ULONG_PTR unusedParm)
{
    DC_BEGIN_FN("UI_DisplayBitmapCacheWarning");

    DC_IGNORE_PARAMETER(unusedParm);

    //
    // Notify the control that a warning has ocurred
    // pass the warn code for bitmap cache
    //
    SendMessage(_UI.hWndCntrl,WM_TS_WARNING,
                (WPARAM)DC_WARN_BITMAPCACHE_CORRUPTED,0);
                                  
    DC_END_FN();
} // UI_DisplayBitmapCacheWarning


//Called when the desktop size has changed..e.g in response
//to a shadow.
//pDesktopSize contains the new desktop size
void DCAPI CUI::UI_OnDesktopSizeChange(PDCSIZE pDesktopSize)
{
    DC_BEGIN_FN("UI_OnShadowDesktopSizeChange");
    TRC_ASSERT(pDesktopSize, (TB,_T("UI_OnShadowDesktopSizeChange received NULL desktop size")));
    if(pDesktopSize)
    {
        if (pDesktopSize->width != _UI.desktopSize.width || 
            pDesktopSize->height != _UI.desktopSize.height)
        {
            UI_SetDesktopSize( pDesktopSize);
#ifdef SMART_SIZING
            //
            // Notify OP and IH 
            //
            LPARAM newSize = MAKELONG(_UI.mainWindowClientSize.width,
                                      _UI.mainWindowClientSize.height);

            UI_NotifyOfDesktopSizeChange( newSize );
#endif
            //Notify the control of the change
            SendMessage(_UI.hWndCntrl, WM_TS_DESKTOPSIZECHANGE,
                        (WPARAM)pDesktopSize->width,
                        (LPARAM)pDesktopSize->height);
        }
    }
    DC_END_FN();
}


//
// Get default langID
//

DCLANGID CUI::UIGetDefaultLangID()
{
#if defined(OS_WIN32)
    LANGID   LangId;

    LangId = GetSystemDefaultLangID();
    switch (PRIMARYLANGID(LangId)) {
        case LANG_JAPANESE:                       return DC_LANG_JAPANESE;            break;
        case LANG_KOREAN:                         return DC_LANG_KOREAN;              break;
        case LANG_CHINESE:
            switch (SUBLANGID(LangId)) {
                case SUBLANG_CHINESE_TRADITIONAL: return DC_LANG_CHINESE_TRADITIONAL; break;
                case SUBLANG_CHINESE_SIMPLIFIED:  return DC_LANG_CHINESE_SIMPLIFIED;  break;
            }
    }

#else // defined(OS_WIN32)
    DCUINT acp;

    acp = GetKBCodePage();
    switch (acp) {
        case 932: return DC_LANG_JAPANESE;            break;
        case 949: return DC_LANG_KOREAN;              break;
        case 950: return DC_LANG_CHINESE_TRADITIONAL; break;
        case 936: return DC_LANG_CHINESE_SIMPLIFIED;  break;
    }
#endif // defined(OS_WIN32)

    return DC_LANG_UNKNOWN;
}

//
// Get default IME file name
//
DCUINT CUI::UIGetDefaultIMEFileName(PDCTCHAR imeFileName, DCUINT Size)
{
    DCTCHAR  DefaultIMEStr[MAX_PATH];
    DCUINT   intRC;
    DCUINT   stringID = 0;

    switch (UIGetDefaultLangID()) {
        case DC_LANG_JAPANESE:            stringID = UI_IDS_IME_NAME_JPN; break;
        case DC_LANG_KOREAN:              stringID = UI_IDS_IME_NAME_KOR; break;
        case DC_LANG_CHINESE_TRADITIONAL: stringID = UI_IDS_IME_NAME_CHT; break;
        case DC_LANG_CHINESE_SIMPLIFIED:  stringID = UI_IDS_IME_NAME_CHS; break;
    }

    if (stringID) {
        intRC = LoadString(_UI.hResDllInstance,
                           stringID,
                           DefaultIMEStr,
                           MAX_PATH);
        if (intRC) {
            if (intRC + 1< Size) {
                StringCchCopy(imeFileName, Size, DefaultIMEStr);
                return intRC;
            }
            else {
                *imeFileName = _T('\0');
                return intRC;
            }
        }
    }

    return 0;
}

//
// Get IME Mapping table name
//
DCUINT CUI::UIGetIMEMappingTableName(PDCTCHAR ImeMappingTableName, DCUINT Size)
{
    DCUINT   len;
    PDCTCHAR string = NULL;

    switch (UIGetDefaultLangID()) {
        case DC_LANG_JAPANESE:            string = UTREG_IME_MAPPING_TABLE_JPN; break;
        case DC_LANG_KOREAN:              string = UTREG_IME_MAPPING_TABLE_KOR; break;
        case DC_LANG_CHINESE_TRADITIONAL: string = UTREG_IME_MAPPING_TABLE_CHT; break;
        case DC_LANG_CHINESE_SIMPLIFIED:  string = UTREG_IME_MAPPING_TABLE_CHS; break;
    }

    if (string) {
        if ( (len=DC_TSTRLEN(string)) < Size - 1) {
            StringCchCopy(ImeMappingTableName, Size, string);
            return len;
        }
        else {
            *ImeMappingTableName = _T('\0');
            return len;
        }
    }

    return 0;
}


//
// Disable IME
//
VOID CUI::DisableIME(HWND hwnd)
{
#if defined(OS_WIN32)
    if (_pUt->lpfnImmAssociateContext != NULL)
    {
        _pUt->lpfnImmAssociateContext(hwnd, (HIMC)NULL);
    }
#else // defined(OS_WIN32)
    if (_pUt->lpfnWINNLSEnableIME != NULL)
    {
        _pUt->lpfnWINNLSEnableIME(hwnd, FALSE);
    }
#endif // defined(OS_WIN32)
}

//
// Get IME file name
//
VOID CUI::UIGetIMEFileName(PDCTCHAR imeFileName, DCUINT cchSize)
{
    HRESULT hr;
    DC_BEGIN_FN("UIGetIMEFileName");

#if defined(OS_WIN32)
    imeFileName[0] = _T('\0');
#if !defined(OS_WINCE) || defined(OS_WINCE_KEYBOARD_LAYOUT)
    {
        if (_pUt->UT_ImmGetIMEFileName(CicSubstGetKeyboardLayout(NULL),
                                       imeFileName, cchSize) > 0)
        {
            /*
             * For Win95 issue
             * If IME name have contains "$$$.DLL",
             * then this is a process IME (i.e EXE type)
             */
            PDCTCHAR str = DC_TSTRCHR(imeFileName, _T('$'));
            if (str != NULL)
            {
                if (DC_TSTRCMP(str, _T("$$$.DLL")) == 0)
                {
                    UIGetIMEFileName16(imeFileName, cchSize);
                }
            }
            else
            {
                /*
                 * For NT3.51-J issue
                 * If IME name have contains ".EXE",
                 * then this is a process IME (i.e EXE type)
                 */
                PDCTCHAR str = DC_TSTRCHR(imeFileName, _T('.'));
                if (str != NULL)
                {
                    if (DC_TSTRCMP(str, _T(".EXE")) == 0)
                    {
                        UIGetIMEFileName16(imeFileName, cchSize);
                    }
                    else
                    {
                        DCUINT   len;
                        DCTCHAR  MappedImeFileName[MAX_PATH];
                        DCTCHAR  ImeMappingTableName[MAX_PATH];

                        //
                        // Now look for this key in the [IME Mapping Table] section of
                        // the client's INI file
                        //
                        len = UIGetIMEMappingTableName(ImeMappingTableName,
                                                       sizeof(ImeMappingTableName)/sizeof(DCTCHAR));
                        if (len != 0 &&
                            len < sizeof(ImeMappingTableName)/sizeof(DCTCHAR)) {
                            *MappedImeFileName = _T('\0');
                            _pUt->UT_ReadRegistryString(ImeMappingTableName,
                                                  imeFileName,
                                                  NULL,
                                                  MappedImeFileName,
                                                  sizeof(MappedImeFileName)/sizeof(DCTCHAR));
                            if (*MappedImeFileName) {
                                hr = StringCchCopy(imeFileName, cchSize,
                                                   MappedImeFileName);
                            }
                        }
                    }
                }
            }
        }
    }
#else // !defined(OS_WINCE) || defined(OS_WINCE_KEYBOARD_LAYOUT)
    UIGetDefaultIMEFileName(imeFileName, Size);
#endif // !defined(OS_WINCE) || defined(OS_WINCE_KEYBOARD_LAYOUT)
#else // defined(OS_WIN32)
    UIGetIMEFileName16(imeFileName, Size);
#endif // defined(OS_WIN32)
    DC_END_FN();
}

#if !defined(OS_WINCE)
//
// Get IME file name for WINNLS functionality
//
VOID CUI::UIGetIMEFileName16(PDCTCHAR imeFileName, DCUINT Size)
{
    IMEPRO   IMEPro;
    DCTCHAR  DefaultImeFileName[MAX_PATH];
    DCTCHAR  ImeMappingTableName[MAX_PATH];
    DCUINT   intRC;

    DC_BEGIN_FN("UIGetIMEFileName16");

    imeFileName[0] = _T('\0');
    {
        if (_pUt->UT_IMPGetIME(NULL, &IMEPro) == 0)
        {
            TRC_ERR((TB, _T("Fatal Error -  IMPGetIME returns FALSE")));
        }
        else
        {
            /*
             * Get file name of 8.3 form, if include directory path in IMEPro.szName
             */
            DCTCHAR  szBuffer[MAX_PATH];
            PDCTCHAR imeFilePart;
            _pUt->UT_GetFullPathName((PDCTCHAR)IMEPro.szName, sizeof(szBuffer)/sizeof(DCTCHAR),
                               szBuffer, &imeFilePart);

            //
            // Now look for this key in the [IME Mapping Table] section of
            // the client's INI file
            //
            intRC = UIGetDefaultIMEFileName(DefaultImeFileName,
                                            sizeof(DefaultImeFileName)/sizeof(DCTCHAR));
            if (intRC && *DefaultImeFileName) {
                DCUINT   len;

                len = UIGetIMEMappingTableName(ImeMappingTableName,
                                               sizeof(ImeMappingTableName)/sizeof(DCTCHAR));
                if (len != 0 &&
                    len < sizeof(ImeMappingTableName)/sizeof(DCTCHAR)) {
                    _pUt->UT_ReadRegistryString(ImeMappingTableName,
                                          imeFilePart,
                                          DefaultImeFileName,
                                          imeFileName,
                                          Size);
                }
            }
        }
    }
    DC_END_FN();
}
#endif // !defined(OS_WINCE)


//
// Static window procs
//


LRESULT CALLBACK CUI::UIStaticMainWndProc (HWND hwnd, UINT message,
                                                 WPARAM wParam, LPARAM lParam)
{
    CUI* pUI = (CUI*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(WM_CREATE == message)
    {
        //pull out the this pointer and stuff it in the window class
        LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
        pUI = (CUI*)lpcs->lpCreateParams;

        SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)pUI);
    }
    
    //
    // Delegate the message to the appropriate instance
    //

    if(pUI)
    {
        return pUI->UIMainWndProc(hwnd, message, wParam, lParam);
    }
    else
    {
        return DefWindowProc(hwnd, message, wParam, lParam);
    }
}


LRESULT CALLBACK CUI::UIStaticContainerWndProc (HWND hwnd, UINT message,
                                                 WPARAM wParam, LPARAM lParam)
{
    CUI* pUI = (CUI*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(WM_CREATE == message)
    {
        //pull out the this pointer and stuff it in the window class
        LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
        pUI = (CUI*)lpcs->lpCreateParams;

        SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)pUI);
    }
    
    if(pUI)
    {
        return pUI->UIContainerWndProc(hwnd, message, wParam, lParam);
    }
    else
    {
        return DefWindowProc(hwnd, message, wParam, lParam);
    }

}


//
// Callbacks
//

//
// Name:      UI_OnCoreInitialized
//                                                                          
// Purpose:   For the CD to inform the UI that the Core has initialized
//
DCVOID DCAPI CUI::UI_OnCoreInitialized(ULONG_PTR unused)
{
#ifndef OS_WINCE
    BOOL bPrevMenustate;
#endif // OS_WINCE
    HWND  hwndDlgItem = NULL;
    HWND  hwndAddress = NULL;

    DC_BEGIN_FN("UI_OnCoreInitialized");

    DC_IGNORE_PARAMETER(unused);

    DC_EXIT_POINT:
    _UI.fOnCoreInitializeEventCalled = TRUE;


    //
    // Notify the IH of the size since there is a small window
    // when the core hasn't been intitialized but we receive
    // the WM_SIZE's that size the control and so the IH
    // would not have received the correct sizes
    //
    ULONG_PTR size = MAKELONG(_UI.mainWindowClientSize.width,
                              _UI.mainWindowClientSize.height);
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
            _pIh,
            CD_NOTIFICATION_FUNC(CIH,IH_SetVisibleSize),
            (ULONG_PTR)size);


    DC_END_FN();
    return;

} // UI_OnCoreInitialised


//
// Name:      UI_OnInputFocusLost
//                                                                          
// Purpose:   When the IH loses the input
//                                                                          
// Returns:   Nothing
//                                                                          
// Params:    None
//                                                                          
//
DCVOID DCAPI CUI::UI_OnInputFocusLost(ULONG_PTR unused)
{
    DC_BEGIN_FN("UI_OnInputFocusLost");

    DC_IGNORE_PARAMETER(unused);
    TRC_DBG((TB, _T("UI_OnInputFocusLost called")));

    if (_fIhHasFocus)
    {
        _fIhHasFocus = FALSE;

#ifndef OS_WINCE
        if (!UI_IsFullScreen())
        {
            UI_RestoreLangBar();
        }
#endif
    }
}

//
// Name:      UI_OnInputFocusGained
//                                                                          
// Purpose:   When the IH gets the input
//                                                                          
// Returns:   Nothing
//                                                                          
// Params:    None
//                                                                          
//
DCVOID DCAPI CUI::UI_OnInputFocusGained(ULONG_PTR unused)
{
    DC_BEGIN_FN("UI_OnInputFocusGained");

    DC_IGNORE_PARAMETER(unused);
    TRC_DBG((TB, _T("UI_OnInputFocusGained called")));

    TRC_ALT((TB, _T("UI_OnInputFocusGained gain _fIhHas=%d"),_fIhHasFocus));

    if (!_fIhHasFocus)
    {
        _fIhHasFocus = TRUE;
#ifndef OS_WINCE
        if (!UI_IsFullScreen())
        {
            UI_HideLangBar();
        }
#endif
    }
    else
    {
        TRC_ERR((TB,_T("OnInputFocusGained called when we already have focus")));
    }

    DC_END_FN();
}

//
// Hides the lang bar if not already hidden
// saves previous lang bar state
//
#ifndef OS_WINCE
void CUI::UI_HideLangBar()
{
    DC_BEGIN_FN("UI_HideLangBar");

    if (_pITLBM != NULL)
    {
        HRESULT hr;
    
        hr = _pITLBM->GetShowFloatingStatus(&_dwLangBarFlags);
        TRC_ALT((TB,_T("Hiding langbar GetShow: 0x%x"), _dwLangBarFlags));
        if (SUCCEEDED(hr))
        {
            _fLangBarStateSaved = TRUE;
            _fLangBarWasHidden = _dwLangBarFlags & TF_SFT_HIDDEN;
    
            if (!_fLangBarWasHidden)
            {
                hr = _pITLBM->ShowFloating(TF_SFT_HIDDEN);
                if (FAILED(hr))
                {
                    TRC_ERR((TB,_T("ShowFloating failed: 0x%x"),
                             hr));
                }
            }
        }
    }
    DC_END_FN();
}
#endif

//
// Restores lang bar state to that set before hiding
// in UI_HideLangBar
//
//
#ifndef OS_WINCE
void CUI::UI_RestoreLangBar()
{
    DC_BEGIN_FN("UI_RestoreLangBar");

    TRC_ALT((TB,_T("Restore _dwLangBarFlags: 0x%x _fWasHid:%d _fSaved:%d"),
             _dwLangBarFlags, _fLangBarWasHidden, _fLangBarStateSaved));

    if (_pITLBM != NULL)
    {
        HRESULT hr;

        if (!_fLangBarWasHidden && _fLangBarStateSaved)
        {
            hr = _pITLBM->ShowFloating(_dwLangBarFlags);
            if (FAILED(hr))
            {
                TRC_ERR((TB,_T("ShowFloating failed: 0x%x"),
                         hr));
            }
        }
    }
    DC_END_FN();
}
#endif


//
// Name:      UI_OnConnected
//                                                                          
// Purpose:   For the CD to inform the UI of connection success
//            and to enable the disconnect menu item
//                                                                          
// Returns:   Nothing
//                                                                          
// Params:    None
//                                                                          
//
DCVOID DCAPI CUI::UI_OnConnected(ULONG_PTR unused)
{
    BOOL fWasAutoReconnect = FALSE;

    DC_BEGIN_FN("UI_OnConnected");

    DC_IGNORE_PARAMETER(unused);
    TRC_DBG((TB, _T("UI_OnConnected called")));

    //
    // Make sure the shutdown timer isn't hanging around
    //
    if (0 != _UI.shutdownTimer)
    {
        TRC_NRM((TB, _T("Killing shutdown timer")));
        KillTimer(_UI.hwndMain, _UI.shutdownTimer);
        _UI.shutdownTimer = 0;
    }

    //OnConnected can also be called if we are already connected
    //we only want to fire an event to the Ax control on the 
    //initial connect action.
    DCBOOL  fJustConnected = (_UI.connectionStatus == UI_STATUS_CONNECT_PENDING) ||
                             (_UI.connectionStatus == UI_STATUS_PENDING_CONNECTENDPOINT);

    //
    // Notify the CLX test harness of the actual connection
    // address and other interesting ARC/Redirection info
    //
    _clx->CLX_ConnectEx(
        _UI.strAddress,
        UI_IsAutoReconnecting(),
        UI_IsClientRedirected(),
        UI_GetRedirectedLBInfo()
        );

       
    //
    // Dismiss the autoreconnection dialog if we get
    // connected
    //

    if (_pArcUI) {
        fWasAutoReconnect = TRUE;
        UI_StopAutoReconnectDlg();
    }

    UISetConnectionStatus(UI_STATUS_CONNECTED);

    //
    // Set the disconnection reason - now we are connected, we don't expect
    // a disconnect, unless user-initiated.
    //
    _UI.disconnectReason =
                         UI_MAKE_DISCONNECT_ERR(UI_ERR_UNEXPECTED_DISCONNECT);

    //
    // Update the screen mode (do not grab the focus here)
    //
    UIUpdateScreenMode( FALSE );

    //
    // Show the Main Window. Put this here so that the main window is seen
    // only on connection
    //
    ShowWindow(_UI.hwndMain, SW_SHOW);
    UISmoothScrollingSettingChanged();

    //
    // Show the Container Window.
    //
    ShowWindow(_UI.hwndContainer, SW_SHOW);

#ifdef OS_WINCE
    //
    // WinCE doesn't send a WM_SHOWINDOW to the Container, so do that work
    //
    SetFocus(_UI.hwndContainer);
#endif

    //
    // Tell the Client extension dll of the connection
    //
    _clx->CLX_OnConnected();


    //
    // On first connection set the fullscreen state
    // note that UI_OnConnected also fires after logon
    // don't reset the fullscreen state as the user may
    // have changed it.
    //
    if (fJustConnected)
    {
        if (UI_GetStartFullScreen())
        {
            if (!UI_IsFullScreen())
            {
                UI_GoFullScreen();
            }
        }
        else
        {
            //
            // If a previous connection left us fullscreen
            // leave fullscreen
            //
            if (UI_IsFullScreen())
            {
                UI_LeaveFullScreen();
            }
        }
    }

    //
    // We're done with the winsock hostname
    // buffer at this point.
    //
#ifdef OS_WINCE
    if (_pHostData)
    {
#endif
        LocalFree(_pHostData);
        _pHostData = NULL;
#ifdef OS_WINCE
    }
    else
    {
        TRC_ERR((TB,_T("_pHostData is NULL")));
    }
#endif

#ifdef SMART_SIZING
    //
    // Notify OP and IH 
    //
    LPARAM newSize = MAKELONG(_UI.mainWindowClientSize.width,
                              _UI.mainWindowClientSize.height);

    UI_NotifyOfDesktopSizeChange( newSize );
#endif

    //Inform the ActiveX control of the connection
    //so it can fire an event to it's container
    if(IsWindow(_UI.hWndCntrl))
    {
        //
        // Only notify it's a new connection.
        //
        if(fJustConnected)
        {
            SendMessage(_UI.hWndCntrl,WM_TS_CONNECTED,0,0);

#ifdef USE_BBAR
            if (_pBBar) {
                _pBBar->SetEnabled(_UI.fBBarEnabled);
                _pBBar->SetShowMinimize(UI_GetBBarShowMinimize());
                _pBBar->SetShowRestore(UI_GetBBarShowRestore());

                if (!_pBBar->StartupBBar(_UI.desktopSize.width,
                                    _UI.desktopSize.height,
                                    TRUE)) {
                    // BBar is a security feature drop link if it can't start
                    TRC_ERR((TB,_T("BBar failed to init disconnecting")));
                    UIGoDisconnected(_UI.disconnectReason, TRUE);
                }
            }
#endif
        }
    }

    //
    // Make sure we have the focus after a screen mode toggle
    // and after the container has been notified of the connection
    // (so it has a chance to restore the window if it was minimized)
    // Otherwise we can hit problems because we can't assign focus to
    // the minimized Container then IH window. Also the BBar won't start
    // lowering if we connect in the minimized state.
    //
    if(_UI.fGrabFocusOnConnect)
    {
        HWND hwndPrevFocus;

        TRC_NRM((TB,_T("CONNECT GRAB focus")));
        hwndPrevFocus = SetFocus(_UI.hwndContainer);
        TRC_NRM((TB,_T("SetFocus to container, prev focus 0x%x gle 0x%x"),
                 hwndPrevFocus, GetLastError()));
    }


    DC_END_FN();
    return;

} // UI_OnConnected

//
// Name:      UI_OnDeactivateAllPDU
//                                                                          
// Purpose:   For the CD to inform the UI of DeactivateAllPDU
//                                                                          
//                                                                          
// Returns:   Nothing
//                                                                          
// Params:    reason (unused)
//                                                                          
//
DCVOID DCAPI CUI::UI_OnDeactivateAllPDU(ULONG_PTR reason)
{

    DC_BEGIN_FN("UI_OnDeactivateAllPDU");

    TRC_NRM((TB, _T("DeactivateAllPDU received")));
    DC_IGNORE_PARAMETER(reason);
    _UI.disconnectReason = UI_MAKE_DISCONNECT_ERR(UI_ERR_NORMAL_DISCONNECT);


    //
    // Create a timer to ensure that we either get disconnected
    // or reconnected in a reasonable time interval otherwise
    // force a disconnect (Because the user can be left hanging with
    // a disabled client).
    //
    if (_UI.hDisconnectTimeout)
    {
        _pUt->UTDeleteTimer( _UI.hDisconnectTimeout );
        _UI.hDisconnectTimeout = NULL;
    }
    _UI.hDisconnectTimeout = _pUt->UTCreateTimer(
                                                _UI.hwndMain,
                                                UI_TIMER_DISCONNECT_TIMERID,
                                                UI_TOTAL_DISCONNECTION_TIMEOUT);
    
    if (_UI.hDisconnectTimeout)
    {
        _pUt->UTStartTimer( _UI.hDisconnectTimeout );
    }
    else
    {
        TRC_ERR((TB,_T("Failed to create disconnect timer")));
    }

    DC_END_FN();
    return;
} // UI_OnDeactivateAllPDU


//
// Name:      UI_OnDemandActivePDU
//                                                                          
// Purpose:   For the CD to inform the UI of DemandActivePDU
//                                                                          
//                                                                          
// Returns:   Nothing
//                                                                          
// Params:    reason (unused)
//                                                                          
//
DCVOID DCAPI CUI::UI_OnDemandActivePDU(ULONG_PTR reason)
{
   DCUINT32	sessionId;
	
   DC_BEGIN_FN("UI_OnDemandActivePDU");

   TRC_NRM((TB, _T("DemandActivePDU received")));

   DC_IGNORE_PARAMETER(reason);

   if (_UI.hDisconnectTimeout )
   {
       _pUt->UTDeleteTimer( _UI.hDisconnectTimeout );
       _UI.hDisconnectTimeout = NULL;
   }
   
   _UI.disconnectReason =
      UI_MAKE_DISCONNECT_ERR(UI_ERR_UNEXPECTED_DISCONNECT);

   //
   // Notify CLX the reconnected session Id if client reconnects a session
   //
   
   sessionId = UI_GetSessionId();
   if (sessionId) {
       UI_OnLoginComplete();
   }

   DC_END_FN();
   return;
} // UI_OnDemandActivePDU


//
// UI_OnSecurityExchangeComplete
//
// For the SL to notify us that the security exchange has completed
//
DCVOID DCAPI CUI::UI_OnSecurityExchangeComplete(ULONG_PTR reason)
{
    DC_BEGIN_FN("UI_OnSecurityExchangeComplete");

    //
    // stop the single and overall connection timer and start the licensing
    // timer. This has to happen on the UI thread as otherwise there could
    // be a race between the timers popping and the SL directly modifying
    // them (see ntbug9!160001)
    //
    if( _UI.connectStruct.hSingleConnectTimer)
    {
        _pUt->UTStopTimer( _UI.connectStruct.hSingleConnectTimer);
    }
    if( _UI.connectStruct.hConnectionTimer )
    {
        _pUt->UTStopTimer( _UI.connectStruct.hConnectionTimer );
    }
    if( _UI.connectStruct.hLicensingTimer )
    {
        _pUt->UTStartTimer( _UI.connectStruct.hLicensingTimer );
    }
    DC_END_FN();
}

//
// UI_OnLicensingComplete
//
// For the SL to notify us that the licensing has completed
//
DCVOID DCAPI CUI::UI_OnLicensingComplete(ULONG_PTR reason)
{
    DC_BEGIN_FN("UI_OnLicensingComplete");

    //
    // stop the licensing timer.
    // This has to happen on the UI thread as otherwise there could
    // be a race between the timers popping and the SL directly modifying
    // them (see ntbug9!160001)
    //
    if( _UI.connectStruct.hLicensingTimer )
    {
        _pUt->UTStopTimer( _UI.connectStruct.hLicensingTimer );
    }
    DC_END_FN();
}


//
// Name:      UI_OnDisconnected
//                                                                          
// Purpose:   For the CD to inform the UI of disconnection
//
void DCAPI CUI::UI_OnDisconnected(ULONG_PTR disconnectID)
{
    unsigned mainDiscReason;

    DC_BEGIN_FN("UI_OnDisconnected");

    TRC_NRM((TB, _T("Disconnected with Id %#x"), disconnectID));

    //
    // Make sure the shutdown timer isn't hanging around
    //
    if (0 != _UI.shutdownTimer)
    {
        TRC_NRM((TB, _T("Killing shutdown timer")));
        KillTimer(_UI.hwndMain, _UI.shutdownTimer);
        _UI.shutdownTimer = 0;
    }

    if (_UI.hDisconnectTimeout )
    {
        _pUt->UTDeleteTimer( _UI.hDisconnectTimeout );
        _UI.hDisconnectTimeout = NULL;
    }

    //Disable and free any idle input timers
    InitInputIdleTimer(0);

    //
    // Restore the lang bar to it's previous state
    // this is important because we won't always receive
    // an OnFocusLost notification from the IH (e.g if it is
    // in the disabled state when it loses focus)
    //
#ifndef OS_WINCE
    UI_RestoreLangBar();
#endif

    //
    // Special case for error handling:
    // if we get disconnected while the connection is still pending
    // with a network error the most likely case is that the server
    // broke the link because (a) connections are disabled or (b)
    // max number of connections exceeded. We can't actually send
    // back status from the server at this early stage in the connection
    // so instead we just make a very educated 'guess' on the client.
    // UI shells should parse this error code and display the likely
    // error cases:
    //      Server does not allow connections/max number of connections exceeded
    //      Network error
    //
    if (TS_ERRINFO_NOERROR == UI_GetServerErrorInfo()       &&
        UI_STATUS_CONNECT_PENDING == _UI.connectionStatus   &&
        NL_MAKE_DISCONNECT_ERR(NL_ERR_TDFDCLOSE) == disconnectID)
    {
        TRC_NRM((TB, _T(" Setting error info to TS_ERRINFO_SERVER_DENIED_CONNECTION"))); 
        if (_UI.fUseFIPS) {
            UI_SetServerErrorInfo( TS_ERRINFO_SERVER_DENIED_CONNECTION_FIPS );
        }
        else {
            UI_SetServerErrorInfo( TS_ERRINFO_SERVER_DENIED_CONNECTION );
        }
    }

    // When server redirection is in progress, we simply to the redirection
    // without translating disconnection codes or anything else.
    if (_UI.DoRedirection) {
        TRC_NRM((TB,_T("DoRedirection set, doing it")));
        //
        // Free the previous connection's host name lookup
        // buffer before continuing.
        //
        if(_pHostData)
        {
            LocalFree(_pHostData);
            _pHostData = NULL;
        }
        UIRedirectConnection();
    }
    else if ((_UI.connectionStatus == UI_STATUS_CONNECT_PENDING) ||
            (_UI.connectionStatus == UI_STATUS_CONNECT_PENDING_DNS)) {
        // Try the next connection. Pass the disconnect code on unless we
        // already have a UI-specific code that we can use. This code will
        // be used if we have tried all the IP addresses.
        TRC_NRM((TB, _T("ConnectPending: try next IP address?")));
        if ((_UI.disconnectReason ==
                      UI_MAKE_DISCONNECT_ERR(UI_ERR_UNEXPECTED_DISCONNECT)) ||
            (_UI.disconnectReason ==
                      UI_MAKE_DISCONNECT_ERR(UI_ERR_NORMAL_DISCONNECT)) ||
            (NL_GET_MAIN_REASON_CODE(_UI.disconnectReason) !=
                                                         UI_DISCONNECT_ERROR))
        {
            _UI.disconnectReason = disconnectID;
        }

        UITryNextConnection();
    }
    else {
        TRC_NRM((TB, _T("Disconnect id %#x/%#x"),
                _UI.disconnectReason, disconnectID));

        // See if this is due to an 'expected' disconnect - such as a
        // timeout.
        if (_UI.disconnectReason ==
                UI_MAKE_DISCONNECT_ERR(UI_ERR_UNEXPECTED_DISCONNECT)) {
            // Unexpected disconnection - use the code passed in.
            UIGoDisconnected(disconnectID, TRUE);
        }
        else if (_UI.disconnectReason ==
                UI_MAKE_DISCONNECT_ERR(UI_ERR_NORMAL_DISCONNECT)) {
            // Normal disconnection (ie we've received a DeactivateAllPDU).
            // Use the reason code set by MCS if a DPUM has been received.
            // Otherwise, leave it unchanged.
            mainDiscReason = NL_GET_MAIN_REASON_CODE(disconnectID);
            if ((mainDiscReason == NL_DISCONNECT_REMOTE_BY_SERVER) ||
                   (mainDiscReason == NL_DISCONNECT_REMOTE_BY_USER))
                UIGoDisconnected(disconnectID, TRUE);
            else
                UIGoDisconnected(_UI.disconnectReason, TRUE);
        }
        else {
            // UI-initiated disconnection - use the UI's code.
            UIGoDisconnected(_UI.disconnectReason, TRUE);
        }
    }

    DC_END_FN();
} // UI_OnDisconnected


//
// Name:    UI_OnShutDown
//                                                                          
// Purpose: Shuts down the application if called with success from the
//          core.  If the called with failure informs the user to
//          disconnect or log off if they wish to shut down.
//                                                                          
// Params: IN - successID - information on whether server allowed
//                          termination
//
DCVOID DCAPI CUI::UI_OnShutDown(ULONG_PTR successID)
{
    DC_BEGIN_FN("UI_OnShutDown");

    if (successID == UI_SHUTDOWN_SUCCESS)
    {
        //
        // If the Core has replied to _pCo->CO_Shutdown(CO_SHUTDOWN) with
        // UI_OnShutdown(UI_SHUTDOWN_SUCCESS) then the UI is free to
        // terminate, so starts the process here.
        //

        //
        // Notify axcontrol of shutdown. 
        //
        SendMessage(_UI.hWndCntrl,WM_TERMTSC,0,0);
        UI_DBG_SETINFO(DBG_STAT_TERMTSC_SENT);

        //
        // Must restore the langbar state just as we do in UI_OnDisconnected
        // as in this disconnect path (shutdown) the disconnect notification
        // is fired from the ActiveX layer.
        //
#ifndef OS_WINCE
        UI_RestoreLangBar();
#endif

        //
        // Do tail end processing for the disconnection but do not
        // fire the disconnect event, that is handled by TERMTSC
        //
        if (_UI.connectionStatus != UI_STATUS_DISCONNECTED) {
            UIGoDisconnected(_UI.disconnectReason, FALSE);
        }
    }
    else
    {
        //
        // We can kill the shutdown timer here since the server must have
        // responded to our shutdown PDU.
        //
        if (0 != _UI.shutdownTimer)
        {
            TRC_NRM((TB, _T("Killing shutdown timer")));
            KillTimer(_UI.hwndMain, _UI.shutdownTimer);
            _UI.shutdownTimer = 0;
        }

        //
        // If successID is not UI_SHUTDOWN_SUCCESS then the UI has been
        // denied shutdown by the server (e.g the user has logged in so 
        // we need to prompt him if it's Ok to continue shutdown).
        // Fire an event to the shell to ask the user if it is OK to
        // proceed with the close
        //
        TRC_NRM((TB,_T("Firing WM_TS_ASKCONFIRMCLOSE")));
        BOOL bOkToClose = TRUE;
        SendMessage( _UI.hWndCntrl, WM_TS_ASKCONFIRMCLOSE,
                     (WPARAM)&bOkToClose, 0 );
        if( bOkToClose)
        {
            TRC_NRM((TB,_T("User OK'd close request"))); 
            _pCo->CO_Shutdown(CO_DISCONNECT_AND_EXIT);
        }
        else
        {
            TRC_NRM((TB,_T("User denied close request"))); 
        }
    }

    DC_END_FN();
} // UI_OnShutDown


//
// Name:    UI_UpdateSessionInfo
//                                                                          
// Purpose: Updates the registry with the latest session info.
//                                                                          
// Params: IN - pDomain     Domain
//              cbDomain    Length of pDomain (in bytes)
//              pUserName   UserName
//              cbUsername  Length of pUserName (in bytes)
//
DCVOID DCAPI CUI::UI_UpdateSessionInfo(PDCWCHAR pDomain,
                                  DCUINT   cbDomain,
                                  PDCWCHAR pUserName,
                                  DCUINT   cbUsername,
                                  DCUINT32 SessionId)
{
    UNREFERENCED_PARAMETER(cbUsername);
    UNREFERENCED_PARAMETER(cbDomain);
    
    DC_BEGIN_FN("UI_UpdateSessionInfo");

    //
    // Update the UT variables
    //
    UI_SetDomain(pDomain);
    UI_SetUserName(pUserName);
    UI_SetSessionId(SessionId);
    
    UI_OnLoginComplete();

DC_EXIT_POINT:    
    DC_END_FN();
}


//
// Name:      UI_GoFullScreen
//
DCVOID CUI::UI_GoFullScreen(DCVOID)
{
    DWORD dwWebCtrlStyle;
    DC_BEGIN_FN("UI_GoFullScreen");

    //
    // Before going fullscreen restore
    // the lang bar to it's previous state
    // since the system will take care of hiding
    // it with it's built in fullscreen detection
    //
#ifndef OS_WINCE
    if (!UI_IsFullScreen())
    {
        UI_RestoreLangBar();
    }
#endif

    if(_UI.fContainerHandlesFullScreenToggle)
    {
        //
        // FullScreen is handled by the container
        // notify the control to fire an event
        //
        //Notify activeX control of screen mode change
        if(IsWindow(_UI.hWndCntrl))
        {
            //
            // wparam = 1 means go fullscreen
            //

            _UI.fContainerInFullScreen = TRUE;
            SendMessage( _UI.hWndCntrl, WM_TS_REQUESTFULLSCREEN, (WPARAM)1, 0);
            
            UIUpdateScreenMode( TRUE );
        }
    }
    else
    {
        //
        // Control handles fullscreen
        //
        dwWebCtrlStyle = GetWindowLong(_UI.hwndMain, GWL_STYLE);
        if(!dwWebCtrlStyle)
        {
            TRC_ABORT((TB, _T("GetWindowLong failed")));
            DC_QUIT;
        }
    
        //
        // Going to real full screen mode
        //
        dwWebCtrlStyle &= ~WS_CHILD;
        dwWebCtrlStyle |= WS_POPUP;
        _UI.fControlIsFullScreen = TRUE;
        SetParent(_UI.hwndMain, NULL);
    
        if(!SetWindowLong(_UI.hwndMain, GWL_STYLE, dwWebCtrlStyle))
        {
            TRC_ABORT((TB, _T("SetWindowLong failed for webctrl")));
        }
        UIUpdateScreenMode( TRUE );
    
        TRC_ASSERT(IsWindow(_UI.hWndCntrl), (TB, _T("hWndCntrl is NULL")));

#ifndef OS_WINCE
        //Notify the shell that we've gone fullscreen
        CUT::NotifyShellOfFullScreen( _UI.hwndMain,
                                      TRUE,
                                      &_pTaskBarList2,
                                      &_fQueriedForTaskBarList2 );
#endif

    
        //Notify activeX control of screen mode change
        if(IsWindow(_UI.hWndCntrl))
        {
            SendMessage( _UI.hWndCntrl, WM_TS_GONEFULLSCREEN, 0, 0);
        }
    }
    if(UI_IsFullScreen())
    {
        _pIh->IH_NotifyEnterFullScreen();
#ifdef USE_BBAR
        if(_pBBar)
        {
            _pBBar->OnNotifyEnterFullScreen();
        }
#endif
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
        // When the fullscreen window size is smaller than the desktop size
        // we don't disable shadow bitmap
        if ((_UI.mainWindowClientSize.width >= _UI.desktopSize.width) &&
            (_UI.mainWindowClientSize.height >= _UI.desktopSize.height)) 
        {
            _pCd->CD_DecoupleSyncNotification(CD_RCV_COMPONENT,
                                              _pUh,
                                              CD_NOTIFICATION_FUNC(CUH,UH_DisableShadowBitmap),
                                              NULL);
        }
#endif // DISABLE_SHADOW_IN_FULLSCREEN
    }

DC_EXIT_POINT:
    DC_END_FN();
}


//
// Name:      UI_LeaveFullScreen
//
DCVOID CUI::UI_LeaveFullScreen(DCVOID)
{
    DWORD dwWebCtrlStyle;

    DC_BEGIN_FN("UI_LeaveFullScreen");
    if(_UI.fContainerHandlesFullScreenToggle)
    {
        //
        // FullScreen is handled by the container
        // notify the control to fire an event
        //
        //Notify activeX control of screen mode change
        if(IsWindow(_UI.hWndCntrl))
        {
            //
            // wparam = 1 means go fullscreen
            //

            _UI.fContainerInFullScreen = FALSE;
            SendMessage( _UI.hWndCntrl, WM_TS_REQUESTFULLSCREEN, (WPARAM)0, 0);

            UIUpdateScreenMode( TRUE );
        }
    }
    else
    {
        dwWebCtrlStyle = GetWindowLong(_UI.hwndMain, GWL_STYLE);
        if(!dwWebCtrlStyle)
        {
            TRC_ABORT((TB, _T("GetWindowLong failed for webctrl")));
            DC_QUIT;
        }
    
        //
        // Leaving real full screen mode
        //
        dwWebCtrlStyle &= ~WS_POPUP;
        dwWebCtrlStyle |= WS_CHILD;
        _UI.fControlIsFullScreen = FALSE;
        SetParent(_UI.hwndMain, _UI.hWndCntrl);
    
        if(!SetWindowLong(_UI.hwndMain, GWL_STYLE, dwWebCtrlStyle))
        {
            TRC_ABORT((TB, _T("SetWindowLong failed for webctrl")));
        }
        
        //ActiveX control is always in 'Full screen mode'
        UIUpdateScreenMode( TRUE );
        TRC_ASSERT(IsWindow(_UI.hWndCntrl),(TB, _T("hWndCntrl is NULL")));

#ifndef OS_WINCE
        //Notify the shell that we've left fullscreen
        CUT::NotifyShellOfFullScreen( _UI.hwndMain,
                                      FALSE,
                                      &_pTaskBarList2,
                                      &_fQueriedForTaskBarList2 );
#endif

    
        //Notify activeX control of screen mode change
        if(IsWindow(_UI.hWndCntrl))
        {
            SendMessage( _UI.hWndCntrl, WM_TS_LEFTFULLSCREEN, 0, 0);
        }
    }

    if(!UI_IsFullScreen())
    {
        //Notify IH
        _pIh->IH_NotifyLeaveFullScreen();
#ifdef USE_BBAR
        if(_pBBar)
        {
            _pBBar->OnNotifyLeaveFullScreen();
        }
#endif
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
        // When leaving fullscreen, enable the use of shadow bitmap
        _pCd->CD_DecoupleSyncNotification(CD_RCV_COMPONENT,
                                          _pUh,
                                          CD_NOTIFICATION_FUNC(CUH,UH_EnableShadowBitmap),
                                          NULL);
#endif // DISABLE_SHADOW_IN_FULLSCREEN

        //
        // After leaving fullscreen we need to handle
        // hiding the langbar if the IH has the focus
        //
#ifndef OS_WINCE
        if (_fIhHasFocus)
        {
            UI_HideLangBar();
        }
#endif
    }

DC_EXIT_POINT:
    DC_END_FN();
}


//
// Name:      UI_ToggleFullScreenMode
//                                                                          
// Purpose:   Toggle web ctrl/full screen mode
//
DCVOID CUI::UI_ToggleFullScreenMode(DCVOID)
{
    DC_BEGIN_FN("UI_ToggleFullScreenMode");

    if(UI_IsFullScreen())
    {
        UI_LeaveFullScreen();
    }
    else
    {
        UI_GoFullScreen();
    }

    DC_END_FN();
}  // UI_ToggleFullScreenMode


//
// Name:      UI_IsFullScreen
//                                                                          
// Purpose:   Returns true if we are in fullscreen mode
//            (for both container and control handled fullscreen)
//
DCBOOL CUI::UI_IsFullScreen()
{
    return _UI.fContainerHandlesFullScreenToggle ?
           _UI.fContainerInFullScreen : _UI.fControlIsFullScreen;
}


#ifdef DC_DEBUG
//
// Name:      UI_CoreDebugSettingChanged
//                                                                          
// Purpose:   Performs necessary actions when any of the Core debug
//            setings are updated.
//
void DCINTERNAL CUI::UI_CoreDebugSettingChanged()
{
    unsigned configFlags;

    DC_BEGIN_FN("UICoreDebugSettingChanged");

    if (!_UI.coreInitialized)
        return;

    configFlags = 0;

    if (_UI.hatchBitmapPDUData)
        configFlags |= CO_CFG_FLAG_HATCH_BITMAP_PDU_DATA;

    if (_UI.hatchIndexPDUData)
        configFlags |= CO_CFG_FLAG_HATCH_INDEX_PDU_DATA;

    if (_UI.hatchSSBOrderData)
        configFlags |= CO_CFG_FLAG_HATCH_SSB_ORDER_DATA;

    if (_UI.hatchMemBltOrderData)
        configFlags |= CO_CFG_FLAG_HATCH_MEMBLT_ORDER_DATA;

    if (_UI.labelMemBltOrders)
        configFlags |= CO_CFG_FLAG_LABEL_MEMBLT_ORDERS;

    if (_UI.bitmapCacheMonitor)
        configFlags |= CO_CFG_FLAG_BITMAP_CACHE_MONITOR;

    _pCo->CO_SetConfigurationValue(CO_CFG_DEBUG_SETTINGS, configFlags);

    DC_END_FN();
}


//
// Name: UI_SetRandomFailureItem
//                                                                          
// Purpose: Sets the percentage failure of a specified function
//                                                                          
// Params: IN - itemID - identifies the function
//         IN - percent - the new percentage failure
//
void DCAPI CUI::UI_SetRandomFailureItem(unsigned itemID, int percent)
{
    DC_BEGIN_FN("UI_SetRandomFailureItem");

    _pUt->UT_SetRandomFailureItem(itemID, percent);

    DC_END_FN();
} // UI_SetRandomFailureItem


//
// Name: UI_GetRandomFailureItem
//                                                                          
// Purpose: Gets the percentage failure for a specified function
//                                                                          
// Returns: The percentage
//                                                                          
// Params: IN - itemID - identifies the function
//
int DCAPI CUI::UI_GetRandomFailureItem(unsigned itemID)
{
    DC_BEGIN_FN("UI_GetRandomFailureItem");
    DC_END_FN();
    return _pUt->UT_GetRandomFailureItem(itemID);
} // UI_GetRandomFailureItem


//
// Name: UI_SetNetworkThroughput
//                                                                          
// Purpose: Set the network throughput in bytes per second
//                                                                          
// Params: IN - bytesPerSec to set for the maximum network throughput
//
void DCAPI CUI::UI_SetNetworkThroughput(unsigned bytesPerSec)
{
    DC_BEGIN_FN("UI_SetNetworkThroughput");

    TRC_ASSERT(((bytesPerSec <= 50000)),
               (TB,_T("bytesPerSec is out of range")));
    _pTd->NL_SetNetworkThroughput(bytesPerSec);

    DC_END_FN();
} // UI_SetNetworkThroughput


//
// Name: UI_GetNetworkThroughput
//                                                                          
// Purpose: Gets the percentage failure for a specified function
//
unsigned DCAPI CUI::UI_GetNetworkThroughput()
{
    DC_BEGIN_FN("UI_GetNetworkThroughput");
    DC_END_FN();
    return _pTd->NL_GetNetworkThroughput();
} // UI_GetNetworkThroughput

#endif // DC_DEBUG


//
// Set the list of virtual channel plugins to load
//
BOOL DCAPI CUI::UI_SetVChanAddinList(TCHAR *szVChanAddins)
{
    DC_BEGIN_FN("UI_SetVChanAddinList");

    if(_UI.pszVChanAddinDlls)
    {
        //If previously set, free
        UT_Free(_pUt, _UI.pszVChanAddinDlls);
    }

    if(!szVChanAddins || szVChanAddins[0] == 0)
    {
        _UI.pszVChanAddinDlls = NULL;
        return TRUE;
    }
    else
    {
        DCUINT len = DC_TSTRLEN(szVChanAddins);
        _UI.pszVChanAddinDlls = (PDCTCHAR)UT_Malloc(_pUt, (len +1) * sizeof(DCTCHAR));
        if(_UI.pszVChanAddinDlls)
        {
            StringCchCopy(_UI.pszVChanAddinDlls, len+1, szVChanAddins);
        }
        else
        {
            return FALSE;
        }

    }

    DC_END_FN();
    return TRUE;
}

//
// Set the load balance info
//
BOOL DCAPI CUI::UI_SetLBInfo(PBYTE pLBInfo, unsigned LBInfoSize)
{
    DC_BEGIN_FN("UI_SetLBInfo");

    if(_UI.bstrScriptedLBInfo)
    {
        //If previously set, free
        SysFreeString(_UI.bstrScriptedLBInfo);        
    }

    if(!pLBInfo)
    {
        _UI.bstrScriptedLBInfo = NULL;
        return TRUE;
    }
    else
    {
        _UI.bstrScriptedLBInfo= SysAllocStringByteLen((LPCSTR)pLBInfo, LBInfoSize);

        if (_UI.bstrScriptedLBInfo == NULL) 
        {
            return FALSE;
        }
    }

    DC_END_FN();
    return TRUE;
}

//
// Name:      UI_SetCompress
//
void DCAPI CUI::UI_SetCompress(BOOL fCompress)
{
    DC_BEGIN_FN("UI_SetCompress");

    TRC_NRM((TB, _T("Setting _UI.fCompress to %d"), fCompress));

    _UI.fCompress = fCompress;
    //
    // If compression is enabled, then allocate a receive context
    //
    if (fCompress && !_UI.pRecvContext2)
    {
        _UI.pRecvContext2 = (RecvContext2_64K *)
                    UT_Malloc(_pUt,sizeof(RecvContext2_64K));
        if (_UI.pRecvContext2)
        {
            _UI.pRecvContext2->cbSize = sizeof(RecvContext2_64K);
            initrecvcontext(&_UI.Context1,
                            (RecvContext2_Generic*)_UI.pRecvContext2,
                            PACKET_COMPR_TYPE_64K);
        }
        else
            _UI.fCompress = FALSE;
    }
    else if (!fCompress && _UI.pRecvContext2)
    {
        UT_Free(_pUt, _UI.pRecvContext2);
        _UI.pRecvContext2 = NULL;
    }

    DC_END_FN();
} // UI_SetCompress


//
// Name:      UI_GetCompress
//
BOOL DCAPI CUI::UI_GetCompress()
{
    DC_BEGIN_FN("UI_GetCompress");
    DC_END_FN();
    return _UI.fCompress;
} // UI_GetCompress

DCUINT CUI::UI_GetAudioRedirectionMode()
{
    return _UI.audioRedirectionMode;
}

VOID CUI::UI_SetAudioRedirectionMode(DCUINT audioMode)
{
    DC_BEGIN_FN("UI_SetAudioRedirectionMode");
    TRC_ASSERT((audioMode == UTREG_UI_AUDIO_MODE_REDIRECT       ||
                audioMode == UTREG_UI_AUDIO_MODE_PLAY_ON_SERVER ||
                audioMode == UTREG_UI_AUDIO_MODE_NONE),
               (TB,_T("Invalid audio mode passed to UI_SetAudioRedirectionMode")));
    _UI.audioRedirectionMode = audioMode;
    DC_END_FN();
}

BOOL CUI::UI_GetDriveRedirectionEnabled()
{
    return _UI.fEnableDriveRedirection;
}

VOID CUI::UI_SetDriveRedirectionEnabled(BOOL fEnable)
{
    _UI.fEnableDriveRedirection = fEnable;
}

BOOL CUI::UI_GetPrinterRedirectionEnabled()
{
    return _UI.fEnablePrinterRedirection;
}

VOID CUI::UI_SetPrinterRedirectionEnabled(BOOL fEnable)
{
    _UI.fEnablePrinterRedirection = fEnable;
}

BOOL CUI::UI_GetPortRedirectionEnabled()
{
    return _UI.fEnablePortRedirection;
}

VOID CUI::UI_SetPortRedirectionEnabled(BOOL fEnable)
{
    _UI.fEnablePortRedirection = fEnable;
}

BOOL CUI::UI_GetSCardRedirectionEnabled()
{
    return _UI.fEnableSCardRedirection;
}

VOID CUI::UI_SetSCardRedirectionEnabled(BOOL fEnable)
{
    _UI.fEnableSCardRedirection = fEnable;
}

VOID CUI::UI_OnDeviceChange(WPARAM wParam, LPARAM lParam)
{
    DEVICE_PARAMS DeviceParams;

    DC_BEGIN_FN("UI_OnDeviceChange");

    if (_fTerminating) {
        DC_QUIT;
    }

    DeviceParams.wParam = wParam;
    DeviceParams.lParam = lParam;
    DeviceParams.deviceObj = _drInitData.pUpdateDeviceObj;

    if (_drInitData.pUpdateDeviceObj != NULL) {

        _pCd->CD_DecoupleSyncNotification(CD_RCV_COMPONENT,
            _pCChan,
            CD_NOTIFICATION_FUNC(CChan, OnDeviceChange),
            (ULONG_PTR)(PVOID)(&DeviceParams));           
    }

DC_EXIT_POINT:
    DC_END_FN();
}

//Initialize the rdpdr settings struct for this connection
//these settings get passed down to the rdpdr plugin
void CUI::UI_InitRdpDrSettings()
{
    DC_BEGIN_FN("UI_InitRdpDrSettings");

    // Need to reset the data only when necessary 
    _drInitData.fEnableRedirectedAudio = FALSE;
    _drInitData.fEnableRedirectDrives = FALSE;
    _drInitData.fEnableRedirectPorts = FALSE;
    _drInitData.fEnableRedirectPrinters = FALSE;

    _drInitData.fEnableRedirectedAudio = UI_GetAudioRedirectionMode() == 
        UTREG_UI_AUDIO_MODE_REDIRECT;

    _drInitData.fEnableRedirectDrives =  UI_GetDriveRedirectionEnabled();
    _drInitData.fEnableRedirectPrinters =  UI_GetPrinterRedirectionEnabled();
    _drInitData.fEnableRedirectPorts =  UI_GetPortRedirectionEnabled();
    _drInitData.fEnableSCardRedirection = UI_GetSCardRedirectionEnabled();

    memset(_drInitData.szLocalPrintingDocName, 0,
           sizeof(_drInitData.szLocalPrintingDocName));
    if(!LoadString(_UI.hResDllInstance,
                   IDS_RDPDR_PRINT_LOCALDOCNAME,
                   _drInitData.szLocalPrintingDocName,
                   SIZECHAR(_drInitData.szLocalPrintingDocName))) {
        TRC_ERR((TB,_T("LoadString IDS_RDPDR_PRINT_LOCALDOCNAME failed"))); 
    }

    memset(_drInitData.szClipCleanTempDirString, 0,
           sizeof(_drInitData.szClipCleanTempDirString));
    if(!LoadString(_UI.hResDllInstance,
                   IDS_RDPDR_CLIP_CLEANTEMPDIR,
                   _drInitData.szClipCleanTempDirString,
                   SIZECHAR(_drInitData.szClipCleanTempDirString))) {
        TRC_ERR((TB,_T("LoadString IDS_RDPDR_CLIP_CLEANTEMPDIR failed"))); 
    }

    memset(_drInitData.szClipPasteInfoString, 0,
           sizeof(_drInitData.szClipPasteInfoString));
    if(!LoadString(_UI.hResDllInstance,
                   IDS_RDPDR_CLIP_PASTEINFO,
                   _drInitData.szClipPasteInfoString,
                   SIZECHAR(_drInitData.szClipPasteInfoString))) {
        TRC_ERR((TB,_T("LoadString IDS_RDPDR_CLIP_PASTEINFO failed"))); 
    }

    DC_END_FN();
}

// Clean up the LB redirect state.  The load balancing cookie stuff needs to
// know when it's in the middle of a redirection.
void CUI::UI_CleanupLBState()
{
    if (_UI.bstrRedirectionLBInfo)
    {
        SysFreeString(_UI.bstrRedirectionLBInfo);
        _UI.bstrRedirectionLBInfo = NULL;
    }

    _UI.ClientIsRedirected = FALSE;
}

//
// Trigger a user initiated disconnection
//
// Params: discReason - disconnect reason to set
//                      default is NL_DISCONNECT_LOCAL
//
BOOL CUI::UI_UserInitiatedDisconnect(UINT discReason)
{
    DC_BEGIN_FN("UI_UserInitiatedDisconnect");

    if(UI_STATUS_DISCONNECTED == _UI.connectionStatus ||
       UI_STATUS_INITIALIZING == _UI.connectionStatus)
    {
        return FALSE;
    }
    else
    {
        _UI.disconnectReason = discReason;
        UIInitiateDisconnection();
        return TRUE;
    }

    DC_END_FN();
}

//
// Notify the activeX layer that core init has completed
//
BOOL CUI::UI_NotifyAxLayerCoreInit()
{
    DC_BEGIN_FN("UI_NotifyAxLayerCoreInit");

    if(_UI.hEvtNotifyCoreInit)
    {
        BOOL bRet = SetEvent(_UI.hEvtNotifyCoreInit);
        
        // We can now close the handle to the event. This will not affect the
        // waiting UI thread as hEvtNotifyCoreInit was duplicated and will
        // only be destroyed if the reference count becomes zero.
        
        CloseHandle(_UI.hEvtNotifyCoreInit);
        _UI.hEvtNotifyCoreInit = NULL;
        
        if(bRet)
        {
            return TRUE;
        }
        else
        {
            TRC_ABORT((TB,_T("SetEvent _UI.hEvtNotifyCoreInit failed, err: %d"),
                       GetLastError()));
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    DC_END_FN();
}

HWND CUI::UI_GetInputWndHandle()
{
    DC_BEGIN_FN("UI_GetInputWndHandle");

    if(_pIh)
    {
        return _pIh->IH_GetInputHandlerWindow();
    }
    else
    {
        return NULL;
    }
    DC_END_FN();
}

HWND CUI::UI_GetBmpCacheMonitorHandle()
{
    DC_BEGIN_FN("UI_GetBmpCacheMonitorHandle");

#ifdef DC_DEBUG
    if(_pUh)
    {
        return _pUh->UH_GetBitmapCacheMonHwnd();
    }
    else
    {
        return NULL;
    }
#else
    //Free build has no cache monitor
    return NULL;
#endif

    DC_END_FN();
}


//
// Injects vKeys to the IH
//
BOOL CUI::UI_InjectVKeys(/*[in]*/ LONG  numKeys,
                         /*[in]*/ short* pfArrayKeyUp,
                         /*[in]*/ LONG* plKeyData)
{
    BOOL fRet = FALSE;
    IH_INJECT_VKEYS_REQUEST ihrp;
    DC_BEGIN_FN("UI_InjectVKeys");

    if (_fTerminating) {
        DC_QUIT;
    }
    
    if(UI_STATUS_CONNECTED == _UI.connectionStatus)
    {
        //Build a request packet and decouple the work
        //to the IH. We use a sync decouple so there is 
        //no need to make copies of the array params
        ihrp.numKeys = numKeys;
        ihrp.pfArrayKeyUp = pfArrayKeyUp; 
        ihrp.plKeyData = plKeyData;
        ihrp.fReturnStatus = FALSE;
    
        _pCd->CD_DecoupleSyncNotification(CD_SND_COMPONENT,
                     _pIh,
                     CD_NOTIFICATION_FUNC(CIH, IH_InjectMultipleVKeys),
                     (ULONG_PTR)&ihrp);
        fRet = ihrp.fReturnStatus;
    }
    else
    {
        fRet = FALSE;
    }

DC_EXIT_POINT:

    DC_END_FN();
    return fRet;
}

BOOL CUI::UI_SetMinsToIdleTimeout(LONG minsToTimeout)
{
    DC_BEGIN_FN("UI_SetMinsToIdleTimeout");

    //Timers will be initialized at connection time
    //see InitInputIdleTimer
    if(minsToTimeout < MAX_MINS_TOIDLETIMEOUT)
    {
        _UI.minsToIdleTimeout = minsToTimeout;
    }

    DC_END_FN();
    return TRUE;
}

LONG CUI::UI_GetMinsToIdleTimeout()
{
    DC_BEGIN_FN("UI_SetMinsToIdleTimeout");

    DC_END_FN();
    return _UI.minsToIdleTimeout;
}

DCVOID DCAPI CUI::UI_SetServerErrorInfo(ULONG_PTR errInfo)
{
    DC_BEGIN_FN("UI_SetServerErrorInfo");

    TRC_NRM((TB,_T("SetServerErrorInfo prev:0x%x new:0x%x"),
             _UI.lastServerErrorInfo, errInfo));

    _UI.lastServerErrorInfo = errInfo;

    DC_END_FN();
}

UINT32 CUI::UI_GetServerErrorInfo()
{
    DC_BEGIN_FN("UI_GetServerErrorInfo");


    DC_END_FN();
    return _UI.lastServerErrorInfo;
}

//
// Sets the disconnect reason. Can be called by the CD
// from other threads
//
void CUI::UI_SetDisconnectReason(ULONG_PTR reason)
{
    DC_BEGIN_FN("UI_SetDisconnectReason");

    _UI.disconnectReason = (DCUINT) reason;

    DC_END_FN();
}

#ifdef USE_BBAR
void CUI::UI_OnBBarHotzoneTimerFired(ULONG_PTR unused)
{
    DC_BEGIN_FN("UI_OnBBarHotzoneTimerFired");

    if (_pBBar) {
        _pBBar->OnBBarHotzoneFired();
    }

    DC_END_FN();
}

//
// Requests a minimize, this only works in fullscreen
// If we're in container handled fullscreen then the
// request is dispatched to the container but there
// is no way to know if it was actually serviced.
//
// If we're in control handled fullscreen then
// just minimize the fullscreen window ourselves
//
BOOL CUI::UI_RequestMinimize()
{
    DC_BEGIN_FN("UI_RequestMinimize");

    if(UI_IsFullScreen())
    {
        if(_UI.fContainerHandlesFullScreenToggle)
        {
            //Dispatch a request to the control so
            //it can fire an event requesting minimze
            TRC_ASSERT( IsWindow(_UI.hWndCntrl),
                        (TB,_T("_UI.hWndCntrl is bad 0x%x"),
                         _UI.hWndCntrl));
            if( IsWindow( _UI.hWndCntrl) )
            {
                SendMessage( _UI.hWndCntrl,
                             WM_TS_REQUESTMINIMIZE,
                             0, 0 );
            }

            //
            // No way to know if container actually did
            // what we asked, but it doesn't matter
            //
            return TRUE;
        }
        else
        {
            //
            // This minimizes but does not destroy the window
            //
#ifndef OS_WINCE
            return CloseWindow(_UI.hwndMain);
#else
            ShowWindow(_UI.hwndMain, SW_MINIMIZE);
            return TRUE;
#endif
        }
    }
    else
    {
        TRC_NRM((TB,_T("Not fullscreen minimize denied")));
        return FALSE;
    }

    DC_END_FN();
}
#endif

int CUI::UI_BppToColorDepthID(int bpp)
{
    int colorDepthID = CO_BITSPERPEL8;
    DC_BEGIN_FN("UI_BppToColorDepthID");

    switch (bpp)
    {
        case 8:
        {
            colorDepthID = CO_BITSPERPEL8;
        }
        break;

        case 15:
        {
            colorDepthID = CO_BITSPERPEL15;
        }
        break;

        case 16:
        {
            colorDepthID = CO_BITSPERPEL16;
        }
        break;

        case 24:
        case 32:
        {
            colorDepthID = CO_BITSPERPEL24;
        }
        break;

        case 4:
        default:
        {
            TRC_ERR((TB, _T("color depth %u unsupported - default to 8"),
                                                          bpp));
            colorDepthID = CO_BITSPERPEL8;
        }
        break;
    }

    DC_END_FN();
    return colorDepthID;
}

int CUI::UI_GetScreenBpp()
{
    HDC hdc;
    int screenBpp;
    DC_BEGIN_FN("UI_GetScreenBpp");

    hdc = GetDC(NULL);
    if(hdc)
    {
        screenBpp = GetDeviceCaps(hdc, BITSPIXEL);
        TRC_NRM((TB, _T("HDC %p has %u bpp"), hdc, screenBpp));
        ReleaseDC(NULL, hdc);
    }

    DC_END_FN();
    return screenBpp;
}

#ifdef SMART_SIZING
//
// Name:      UI_SetSmartSizing
//
// Purpose:   Save the fSmartSizing flag
//
// Params:    IN     fSmartSizing
//
HRESULT DCAPI CUI::UI_SetSmartSizing(BOOL fSmartSizing)
{
    HWND hwndOp;
    HRESULT hr = S_OK;
    DC_BEGIN_FN("UI_SetSmartSizing");

    TRC_NRM((TB, _T("Setting _UI.fSmartSizing to %d"), fSmartSizing));
    _UI.fSmartSizing = fSmartSizing;
    _UI.scrollPos.x = 0;
    _UI.scrollPos.y = 0;

    UIRecalculateScrollbars();
    UIMoveContainerWindow();

    if (_pOp) {
        hwndOp = _pOp->OP_GetOutputWindowHandle();
        if (hwndOp)
        {
            InvalidateRect(hwndOp, NULL, FALSE);
        }
    }
    else {
        hr = E_OUTOFMEMORY;
    }


    DC_END_FN();
    return hr;
} // UI_SetSmartSizing
#endif // SMART_SIZING

BOOL CUI::UI_UserRequestedClose()
{
    BOOL fRet = FALSE;
    DC_BEGIN_FN("UI_UserRequestedClose");

    UI_DBG_SETINFO(DBG_STAT_UIREQUESTEDCLOSE_CALLED);

    //
    // Call  _pCo->CO_Shutdown.
    //
    if (UI_STATUS_CONNECTED == _UI.connectionStatus)
    {
        //
        // Since we're connected we will start a timer in case the
        // server gets stuck and doesn't process our shutdown PDU.
        //
        if (0 == _UI.shutdownTimer)
        {

            TRC_NRM((TB, _T("Setting shutdown timer is set for %u seconds"),
                         _UI.shutdownTimeout));

            _UI.shutdownTimer = SetTimer(_UI.hwndMain,
                                        UI_TIMER_SHUTDOWN,
                                        1000 * _UI.shutdownTimeout,
                                        NULL);

            if (_UI.shutdownTimer)
            {
                fRet = TRUE;
            }
            else
            {
                //
                // This is a shame.  If the server doesn't do
                // anything with our shutdown PDU we'll wait
                // forever. Report this as a failure so that the shell
                // has an oppurtunity to do an immediate close
                //
                fRet = FALSE;
                TRC_ERR((TB, _T("Failed to set shutdown timeout")));
            }
        }
        else
        {
            TRC_NRM((TB, _T("Shutdown timer already set - leave it")));
            fRet = TRUE;
        }
    }
    else
    {
        fRet = TRUE;
    }

    _pCo->CO_Shutdown( CO_SHUTDOWN);

    UI_DBG_SETINFO(DBG_STAT_UIREQUESTEDCLOSE_RET);

    DC_END_FN();
    return fRet;
}

//
// Notification that login has completed
// forward on to control (which fires an event)
// and CLX for debugging/test
//
void CUI::UI_OnLoginComplete()
{
    DCUINT32 sessionId;
    DC_BEGIN_FN("UI_OnLoginComplete");

    sessionId = UI_GetSessionId();
    _clx->CLX_ClxEvent(CLX_EVENT_LOGON, sessionId);
    //Notify the control of the login event
    SendMessage(_UI.hWndCntrl, WM_TS_LOGINCOMPLETE, 0, 0);

    _pCd->CD_DecoupleSimpleNotification(CD_RCV_COMPONENT,
            _pOp,
            CD_NOTIFICATION_FUNC(COP,OP_DimWindow),
            (ULONG_PTR)FALSE);


    DC_END_FN();
}

#ifdef OS_WINCE
#define LOGONID_NONE -1
#endif

/****************************************************************************/
/* Name:      UI_GetLocalSessionId                                          */
/*                                                                          */
/* Purpose:   Retrieves the session id where the client is running.         */
/****************************************************************************/
BOOL CUI::UI_GetLocalSessionId(PDCUINT32 pSessionId)
{
    BOOL rc = FALSE;
    DWORD dwSessionId = RNS_INFO_INVALID_SESSION_ID;

    DC_BEGIN_FN("UI_GetLocalSessionId");

#ifndef OS_WINCE

    HMODULE hmodule;

    typedef BOOL (FNPROCESSID_TO_SESSIONID)(DWORD, DWORD*);
    FNPROCESSID_TO_SESSIONID *pfnProcessIdToSessionId;

    // get the handle to kernel32.dll library
    hmodule = LoadLibrary(TEXT("KERNEL32.DLL"));

    if (hmodule != NULL) {

        rc = TRUE;

        // get the proc address for ProcessIdToSessionId
        pfnProcessIdToSessionId = (FNPROCESSID_TO_SESSIONID *)GetProcAddress(
            hmodule, "ProcessIdToSessionId");

        // get the session id
        if (pfnProcessIdToSessionId != NULL) {

            // We found the feature ProcessIdToSessionId.
            // See if TS is really enabled on this machine
            // (test valid only on Win2K and above).
            if (UIIsTSOnWin2KOrGreater()) {
                (*pfnProcessIdToSessionId) (GetCurrentProcessId(), &dwSessionId);
            }
        }

        FreeLibrary(hmodule);
    }
#endif //OS_WINCE

    *((PDCUINT32_UA)pSessionId) = dwSessionId;

    DC_END_FN()
    return rc;
}

#ifdef USE_BBAR
VOID CUI::UI_SetBBarPinned(BOOL b)
{
    DC_BEGIN_FN("UI_SetBBarPinned");

    _UI.fBBarPinned = b;
    if (_pBBar) {
        _pBBar->SetPinned(b);
    }

    DC_END_FN();
}

BOOL CUI::UI_GetBBarPinned()
{
    DC_BEGIN_FN("UI_GetBBarPinned");

    if (_pBBar) {
        return _pBBar->IsPinned();
    }
    else {
        return _UI.fBBarPinned;
    }

    DC_END_FN();
}
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
DCVOID CUI::UI_OnNotifyBBarRectChange(RECT *prect)
{
    if(UI_IsCoreInitialized())
        _pCd->CD_DecoupleSyncNotification(CD_RCV_COMPONENT,
                                          _pUh,
                                          CD_NOTIFICATION_FUNC(CUH,UH_SetBBarRect),
                                          (ULONG_PTR)prect);
}


DCVOID CUI::UI_OnNotifyBBarVisibleChange(int BBarVisible)
{
    if(UI_IsCoreInitialized())
        _pCd->CD_DecoupleSyncNotification(CD_RCV_COMPONENT,
                                          _pUh,
                                          CD_NOTIFICATION_FUNC(CUH, UH_SetBBarVisible),
                                          (ULONG_PTR)BBarVisible);
}
#endif // DISABLE_SHADOW_IN_FULLSCREEN
#endif //USE_BBAR

VOID  CUI::UI_SetControlInstance(IUnknown* pUnkControl)
{
    DC_BEGIN_FN("UI_SetControlInstance");

    if (_UI.pUnkAxControlInstance) {
        _UI.pUnkAxControlInstance->Release();
    }

    _UI.pUnkAxControlInstance = pUnkControl;

    if (_UI.pUnkAxControlInstance) {
        _UI.pUnkAxControlInstance->AddRef();
    }

    DC_END_FN();
}

IUnknown* CUI::UI_GetControlInstance()
{
    DC_BEGIN_FN("UI_GetControlInstance");

    if (_UI.pUnkAxControlInstance) {
        _UI.pUnkAxControlInstance->AddRef();
    }

    DC_END_FN();
    return _UI.pUnkAxControlInstance;
}

//
// Sets the autoreconnect cookie replacing existing
// Params:
//  pCookie - new cookie, clear existing if NULL
//  cbLen   - new cookie length
// Returns status (e.g FALSE if failed)
//
BOOL CUI::UI_SetAutoReconnectCookie(PBYTE pCookie, ULONG cbLen)
{
    BOOL fRet = TRUE;
    DC_BEGIN_FN("UI_SetAutoReconnectCookie");

    if (_UI.pAutoReconnectCookie)
    {
        //For security wipe the cookie
        memset(_UI.pAutoReconnectCookie, 0, _UI.cbAutoReconnectCookieLen);
        //Free existing cookie
        LocalFree(_UI.pAutoReconnectCookie);
		_UI.pAutoReconnectCookie = NULL;
        _UI.cbAutoReconnectCookieLen = 0;
    }

    if (pCookie && cbLen)
    {
        _UI.pAutoReconnectCookie = (PBYTE)LocalAlloc(LPTR,
                                                     cbLen);
        if (_UI.pAutoReconnectCookie)
        {
            memcpy(_UI.pAutoReconnectCookie,
                   pCookie,
                   cbLen);

#ifdef INSTRUMENT_ARC
            PARC_SC_PRIVATE_PACKET pArcSCPkt = (PARC_SC_PRIVATE_PACKET)
                                                    _UI.pAutoReconnectCookie;
            LPDWORD pdwArcBits = (LPDWORD)pArcSCPkt->ArcRandomBits;
            KdPrint(("ARC-Client:RECEIVED ARC for SID:%d"
                     "RAND: 0x%x,0x%x,0x%x,0x%x\n",
                     pArcSCPkt->LogonId,
                     pdwArcBits[0],pdwArcBits[1],
                     pdwArcBits[2],pdwArcBits[3]));

#endif
            _UI.cbAutoReconnectCookieLen = cbLen;
        }
        else
        {
            TRC_ERR((TB,_T("LocalAlloc failed for autoreconnect cookie")));
            fRet = FALSE;
        }
    }

    DC_END_FN();
    return fRet;
}

//
// Returns TRUE if the client has the ability to autoreconnect
//
BOOL CUI::UI_CanAutoReconnect()
{
    BOOL fCanARC = FALSE;
    DC_BEGIN_FN("UI_CanAutoReconnect");

    if (UI_GetEnableAutoReconnect() &&
        UI_GetAutoReconnectCookieLen() &&
        UI_GetAutoReconnectCookie())
    {
        fCanARC = TRUE;
    }

    DC_END_FN();
    return fCanARC;
}

BOOL CUI::UI_StartAutoReconnectDlg()
{
    BOOL fRet = FALSE;

    DC_BEGIN_FN("UI_StartAutoReconnectDlg");

    TRC_ASSERT(_pArcUI == NULL,
               (TB,_T("_pArcUI is already set. Clobbering!")));

    //
    // Startup the ARC UI
    //
#ifdef ARC_MINIMAL_UI
    _pArcUI = new CAutoReconnectPlainUI(_UI.hwndMain,
                                     _UI.hInstance,
                                     this);
#else
    _pArcUI = new CAutoReconnectDlg(_UI.hwndMain,
                                     _UI.hInstance,
                                     this);
#endif
    if (_pArcUI) {
        if (_pArcUI->StartModeless()) {
            _pArcUI->ShowTopMost();

            //
            // Start dimming the OP
            //
            if (_pOp) {
                _pCd->CD_DecoupleSimpleNotification(CD_RCV_COMPONENT,
                        _pOp,
                        CD_NOTIFICATION_FUNC(COP,OP_DimWindow),
                        (ULONG_PTR)TRUE);
            }

#ifdef USE_BBAR
            //
            // In fullscreen mode lower and lock the bbar
            //
            if (UI_IsFullScreen() && _pBBar && _pBBar->GetEnabled()) {
                _pBBar->StartLowerBBar();
                _pBBar->SetLocked(TRUE);
            }
#endif
        }
        else {
            TRC_ERR((TB,_T("Arc dlg failed to start modeless")));
        }
    }

    fRet = (_pArcUI != NULL);

    DC_END_FN();
    return fRet;
}

BOOL CUI::UI_StopAutoReconnectDlg()
{
    DC_BEGIN_FN("UI_StopAutoReconnectDlg");

    if (_pArcUI) {
        _pArcUI->Destroy();
        delete _pArcUI;
        _pArcUI = NULL;
    }

#ifdef USE_BBAR
    //
    // Force the bbar unlocked
    //
    if (_pBBar) {
        _pBBar->SetLocked(FALSE);
    }
#endif

    DC_END_FN();
    return TRUE;
}

//
// Notification that we are autoreconnecting
//
// This is the intenal core event that is fired before
// the activex layer fires one out to the outside world
// Params:
//  discReason - disconnection reason
//  attemptCount - number of tries so far
//  maxAttemptCount - total number of times to try
//  pfContinueArc - OUT param set to FALSE to stop ARC'ing
//
VOID
CUI::UI_OnAutoReconnecting(
    LONG discReason,
    LONG attemptCount,
    LONG maxAttemptCount,
    BOOL* pfContinueArc)
{
    DC_BEGIN_FN("UI_OnAutoReconnecing");

    if (1 == attemptCount) {
        TRC_NRM((TB,_T("Trying to start ARC dlg. Attempt count is 1")));
        UI_StartAutoReconnectDlg();
    }

    //
    // If the arc dialog is up just pass it the event
    //
    if (_pArcUI) {
        _pArcUI->OnNotifyAutoReconnecting(discReason,
                                           attemptCount,
                                           maxAttemptCount,
                                           pfContinueArc);
    }
    else {
        //
        // If no ARC dialog then don't stop ARC'ing
        //
        *pfContinueArc = TRUE;
    }

    DC_END_FN();
}

//
// Received autoreconenct status from the server
//
VOID
CUI::UI_OnReceivedArcStatus(LONG arcStatus)
{
    DC_BEGIN_FN("UI_OnReceivedArcStatus");

    TRC_NRM((TB,_T("arcStatus: 0x%x"), arcStatus));

    //
    // This is our signal to undim the OP and go back to normal
    // painting because ARC failed and we are sitting at winlogon
    //

    //
    // All events are signals that autoreconnect has stopped
    //
    UI_OnAutoReconnectStopped();

    DC_END_FN();
}


VOID
CUI::UI_OnAutoReconnectStopped()
{
    DC_BEGIN_FN("UI_OnAutoReconnectStopped");


    if (_pArcUI) {
        UI_StopAutoReconnectDlg();
    }

    if (_pCd && _pOp) {

        _pCd->CD_DecoupleSimpleNotification(CD_RCV_COMPONENT,
                _pOp,
                CD_NOTIFICATION_FUNC(COP,OP_DimWindow),
                (ULONG_PTR)FALSE);
    }

    DC_END_FN();
}

/****************************************************************************/
// SetServerRedirectionInfo
//
// Used on receipt of a TS_SERVER_REDIRECT_PDU to store the info needed to
// redirect the client to a new server. Sets the DoRedirection flag as well
// to indicate these data members are set and ready for use.  Also sets the
// ClientIsRedirected flag, which is longer-lived than the DoRedirection
// flag and is used to send the correct cookie when redirected.
/****************************************************************************/
HRESULT
CUI::UI_SetServerRedirectionInfo(
                    UINT32 SessionID,
                    LPTSTR pszServerAddress,
                    PBYTE LBInfo,
                    unsigned LBInfoSize,
                    BOOL fNeedRedirect
                    )
{
    HRESULT hr = E_FAIL;

    DC_BEGIN_FN("UI_SetServerRedirectionInfo");

    _UI.RedirectionSessionID = SessionID;

    //
    // We were redirected so set the flag
    //
    _UI.ClientIsRedirected = TRUE;

    TRC_NRM((TB,_T("Set server redir info: sid:%d addr:%s lpinfo: %p")
             _T("lbsize: %d fRedir:%d"),
             SessionID, pszServerAddress, LBInfo,
             LBInfoSize, fNeedRedirect));

    if (pszServerAddress) {

        hr = StringCchCopy(_UI.RedirectionServerAddress,
                           SIZE_TCHARS(_UI.RedirectionServerAddress),
                           pszServerAddress);
        if (SUCCEEDED(hr)) {

            _UI.DoRedirection = fNeedRedirect;

            if (LBInfoSize > 0) {
                _UI.bstrRedirectionLBInfo = SysAllocStringByteLen(
                        (LPCSTR)LBInfo, LBInfoSize);

                if (_UI.bstrRedirectionLBInfo == NULL) 
                {
                    hr = E_OUTOFMEMORY;
                    TRC_ERR((TB,
                        _T("RDP_SERVER_REDIRECTION_PACKET, failed to set the LB info")));
                }
            }
        }
    }
    else {
        hr = E_INVALIDARG;
    }

    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\uiint.cpp ===
//
// uiint.cpp
//
// UI Class internal functions
//
// Implements the root object in the rdp client core hierarchy
// this object owns the top level windows in the core.
//
// Copyright (C) 1997-2000 Microsoft Corporation
//

#include <adcg.h>
#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "wuiint"
#include <atrcapi.h>

#include "wui.h"

extern "C"
{
#include <aver.h>
// multi-monitor support
#ifdef OS_WINNT
#define COMPILE_MULTIMON_STUBS
#include <multimon.h>
#endif // OS_WINNT
}

//
// Cicero keyboard layout API's
//
#ifndef OS_WINCE
#include "cicsthkl.h"
#endif

#include "sl.h"
#include "aco.h"
#include "clx.h"
#include "autil.h"

//
// Internal functions
//

//
// draw a solid color rectangle quickly
//
VOID near CUI::FastRect(HDC hDC, int x, int y, int cx, int cy)
{
    RECT rc;

    rc.left = x;
    rc.right = x+cx;
    rc.top = y;
    rc.bottom = y+cy;
    ExtTextOut(hDC,x,y,ETO_OPAQUE,&rc,NULL,0,NULL);
}


DWORD near CUI::RGB2BGR(DWORD rgb)
{
    return RGB(GetBValue(rgb),GetGValue(rgb),GetRValue(rgb));
}


//
// Name:      UIContainerWndProc
//                                                                          
// Purpose:   Handles messages to Container Window
//
LRESULT CALLBACK CUI::UIContainerWndProc( HWND hwnd,
                                     UINT message,
                                     WPARAM wParam,
                                     LPARAM lParam )
{
    LRESULT     rc = 0;
    HDC         hdc;
    PAINTSTRUCT ps;

    DC_BEGIN_FN("UIContainerWndProc");

    TRC_DBG((TB, _T("msg(%#x)"), message));

    switch (message)
    {
        case WM_PAINT:
        {
            TRC_DBG((TB, _T("Container WM_PAINT")));

            hdc = BeginPaint(hwnd, &ps);

            //
            // Do nothing.  All UI painting is done by the Main Window.
            //
            EndPaint(hwnd, &ps);
        }
        break;

        case WM_SETFOCUS:
        {
            HWND hwndFocus;
            if (_pArcUI) {
                hwndFocus = _pArcUI->GetHwnd();
                TRC_NRM((TB, _T("Passing focus to ARC dlg")));
                SetFocus(hwndFocus);
            }
            else {
                //
                // Flag as not handled so subclass proc does the right thing
                //
                rc = TRUE;
            }
        }
        break;

        default:
        {
            rc = DefWindowProc(hwnd, message, wParam, lParam);
        }
        break;
    }

    DC_END_FN();
    return rc;
} // UIContainerProc


//
// Name:     UIGetMaximizedWindowSize
//                                                                          
// Purpose:  Calculates the size to which the main window should be
//           maximized, base on the screen size and the size of window
//           which would have a client area the same size as the
//           container (_UI.maxMainWindowSize).
//
DCSIZE DCINTERNAL CUI::UIGetMaximizedWindowSize(DCVOID)
{
    DCSIZE maximizedSize;
    DCUINT xSize;
    DCUINT ySize;

    DC_BEGIN_FN("UIGetMaximizedWindowSize");

    //
    // The maximum size we set a window to is the smaller of:
    // -  _UI.maxMainWindowSize
    // -  the screen size plus twice the border width (so the borders are
    //    not visible).
    // Always call GetSystemMetrics to get the screen size and border
    // width, as these can change dynamically.
    //
    if(!_UI.fControlIsFullScreen)
    {
        xSize = _UI.controlSize.width;
        ySize = _UI.controlSize.height;
    }
    else
    {
        xSize = GetSystemMetrics(SM_CXSCREEN);
        ySize = GetSystemMetrics(SM_CYSCREEN);
    }

#ifdef OS_WINCE
    maximizedSize.width = DC_MIN(_UI.maxMainWindowSize.width,xSize);

    maximizedSize.height = DC_MIN(_UI.maxMainWindowSize.height,ySize);

#else // This section NOT OS_WINCE
    maximizedSize.width = DC_MIN(_UI.maxMainWindowSize.width,
                              xSize + (2 * GetSystemMetrics(SM_CXFRAME)));

    maximizedSize.height = DC_MIN(_UI.maxMainWindowSize.height,
                              ySize + (2 * GetSystemMetrics(SM_CYFRAME)));
#endif // OS_WINCE

    TRC_NRM((TB, _T("Main Window maxSize (%d,%d) maximizedSize (%d,%d) "),
                                          _UI.maxMainWindowSize.width,
                                          _UI.maxMainWindowSize.height,
                                          maximizedSize.width,
                                          maximizedSize.height));

    DC_END_FN();
    return maximizedSize;
}


//
// Name:     UIMainWndProc
//                                                                          
// Purpose:  Main Window event handling procedure
//
LRESULT CALLBACK CUI::UIMainWndProc( HWND hwnd,
                                UINT message,
                                WPARAM wParam,
                                LPARAM lParam )
{
    LRESULT       rc = 0;
    RECT          rect;
    HDC           hdc;
    PAINTSTRUCT   ps;
    DCSIZE        maximized;

    DC_BEGIN_FN("UIMainWndProc");

    TRC_DBG((TB, _T("msg(%#x)"), message));

    switch (message)
    {
        case WM_CREATE:
        {
            TRC_DBG((TB, _T("Main window created and initializing")));

            //
            // Initialize states
            //
            UISetConnectionStatus(UI_STATUS_INITIALIZING);


            TRC_DBG((TB, _T("Setting up container window size")));

            //
            // In WebUI, Main window is a child window of the ActiveX
            // control window. A WM_SIZE message will be sent to child
            // while CreatWindow. Handler for this message in WinUI is
            // assuming that  _UI.hWndMain is already set, but not true
            // the case _UI. So Set _UI.hWndMain while creating the
            // main the main window.
            //
            _UI.hwndMain = hwnd;
            //
            // Set the Container to be as large as the desk top size
            // requested - but no bigger than the control size.
            //

            if(!_UI.fControlIsFullScreen)
            {
                _UI.containerSize.width =
                   DC_MIN(_UI.uiSizeTable[0],
                                        _UI.controlSize.width);

                _UI.containerSize.height =
                   DC_MIN(_UI.uiSizeTable[1],
                                        _UI.controlSize.height);
            }
            else
            {
                _UI.containerSize.width =
                                   DC_MIN(_UI.uiSizeTable[0],
                                           (DCUINT)GetSystemMetrics(SM_CXSCREEN));

                _UI.containerSize.height =
                                   DC_MIN(_UI.uiSizeTable[1],
                                           (DCUINT)GetSystemMetrics(SM_CYSCREEN));
            }

            UIRecalcMaxMainWindowSize();

            //
            // Set Container to be initially positioned at top left of
            // client area
            //
            TRC_DBG((TB, _T("Setting scrollbars to (0,0)")));
            _UI.scrollPos.x = 0;
            _UI.scrollPos.y = 0;
        }
        break;

        case WM_ACTIVATE:
        {
            TRC_NRM((TB, _T("WM_ACTIVATE")));

            if ( (DC_GET_WM_ACTIVATE_ACTIVATION(wParam) != WA_INACTIVE) &&
                 (_UI.hwndContainer != NULL)) {

                HWND hwndFocus = NULL;

                if (_pArcUI) {
                    hwndFocus = _pArcUI->GetHwnd();
                    TRC_NRM((TB, _T("Passing focus to ARC dlg")));

                }
                else if (IsWindowVisible(_UI.hwndContainer)) {
                    hwndFocus = _UI.hwndContainer;
                    TRC_NRM((TB, _T("Passing focus to Container")));
                }

                if (hwndFocus) {
                    SetFocus(hwndFocus);
                }
            }
                 
        }
        break;

        case WM_KEYDOWN:
        {
            TRC_DBG((TB, _T("WM_KEYDOWN: %u"), wParam));
            if (wParam == _UI.hotKey.fullScreen)
            {
                TRC_DBG((TB, _T("AXCORE Got a full screen VK")));
                if ((GetKeyState(VK_MENU) & (UI_ALT_DOWN_MASK)) != 0)
                {
                    TRC_NRM((TB,
                        _T("AXCORE Alt down also - Got a Screen Mode Hotkey")));
                    //
                    // Only do this if we are connected
                    //
                    if(UI_STATUS_CONNECTED == _UI.connectionStatus)
                    {
                        //
                        // Toggle the ctrl to/from real full screen mode
                        //
                        UI_ToggleFullScreenMode();
                    }
                }
            }
        }
        break;

        case WM_INITMENUPOPUP:
        {
            //
            // If fullscreen, disable the move item on the system menu
            // we show sys menu so an ICON for the client appears in 
            // the taskbar
            //
            HMENU hSysMenu = GetSystemMenu( hwnd, FALSE);
            if(hSysMenu)
            {
                TRC_ERR((TB,(_T("ENABLEMENUITEM....FSCREEN IS %s")),
                         UI_IsFullScreen() ? "TRUE" : "FALSE"));
                #ifndef OS_WINCE
                EnableMenuItem((HMENU)hSysMenu,  SC_MOVE,
                         MF_GRAYED | MF_BYCOMMAND);
                #endif
            }
        }
        break;

        case WM_SIZE:
        {
            //
            // Store the new size
            //
            _UI.mainWindowClientSize.width  = LOWORD(lParam);
            _UI.mainWindowClientSize.height = HIWORD(lParam);

            if (UI_IsCoreInitialized()) {
#ifdef SMART_SIZING
                UI_NotifyOfDesktopSizeChange(lParam);
#endif // SMART_SIZING

                _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
                        _pIh,
                        CD_NOTIFICATION_FUNC(CIH,IH_SetVisibleSize),
                        (ULONG_PTR)lParam);
            }

            //
            // Notify the ARC dialog
            //
            if (_pArcUI) {
                _pArcUI->OnParentSizePosChange();
            }

            //  
            // Web control is special.. it runs 'full screen' but can and
            // does need to be resized
            //
            if(_UI.fControlIsFullScreen)
            {
                TRC_DBG((TB, _T("Ignoring WM_SIZE while in full-screen mode")));
                DC_QUIT;
            }

#if !defined(OS_WINCE) || defined(OS_WINCE_WINDOWPLACEMENT)
            //
            // We're non-fullscreen, so keep the window placement structure
            // up-to-date
            //
            GetWindowPlacement(_UI.hwndMain, &_UI.windowPlacement);
            TRC_DBG((TB, _T("Got window placement in WM_SIZE")));
#endif // !defined(OS_WINCE) || defined(OS_WINCE_WINDOWPLACEMENT)

            if (wParam == SIZE_MAXIMIZED)
            {
#if !defined(OS_WINCE) || defined(OS_WINCE_LOCKWINDOWUPDATE)
                LockWindowUpdate(_UI.hwndMain);
#endif // !defined(OS_WINCE) || defined(OS_WINCE_LOCKWINDOWUPDATE)

                TRC_DBG((TB, _T("Maximize")));

#if !defined(OS_WINCE) || defined(OS_WINCE_WINDOWPLACEMENT)
                //
                // Override the maximized / minimized positions with our
                // hardcoded valued - required if the maximized window is
                // moved.
                //
                UISetMinMaxPlacement();
                SetWindowPlacement(_UI.hwndMain, &_UI.windowPlacement);
#endif // !defined(OS_WINCE) || defined(OS_WINCE_WINDOWPLACEMENT)

                //
                // We need to be accurate about the maximized window size.
                // It is not possible to use _UI.maxMainWindowSize as this
                // may be greater than screen size, eg server and client
                // are 640x480, container is 640x480 then _UI.maxWindowSize
                // (obtained via AdjustWindowRect in UIRecalcMaxMainWindow)
                // is something like 648x525.
                // Passing this value to SetWindowPos has results which
                // vary with different shells:
                // Win95/NT4.0: the resulting window is 648x488 at -4, -4,
                //              ie all the window, except the border, is
                //              on-screen
                // Win31/NT3.51: the resulting window is 648x525 at -4, -4,
                //               ie the size passed to SetWindowPos, so
                //               the bottom 40 pixels are off-screen.
                // To avoid such differences calculate a maximized window
                // size value which takes account of both the physical
                // screen size and the ideal window size.
                //
                UIRecalcMaxMainWindowSize();
                maximized = UIGetMaximizedWindowSize();
                SetWindowPos( _UI.hwndMain,
                              NULL,
                              0, 0,
                              maximized.width,
                              maximized.height,
                              SWP_NOZORDER | SWP_NOMOVE |
                                     SWP_NOACTIVATE | SWP_NOOWNERZORDER );

#if !defined(OS_WINCE) || defined(OS_WINCE_LOCKWINDOWUPDATE)
                LockWindowUpdate(NULL);
#endif // !defined(OS_WINCE) || defined(OS_WINCE_LOCKWINDOWUPDATE)
            }

            //
            // Set scrollbars correctly.
            //

            if (!_fRecursiveSizeMsg)
            {
                _fRecursiveSizeMsg = TRUE;
                UIRecalculateScrollbars();
                _fRecursiveSizeMsg = FALSE;
            }
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
            // When in full-screen mode, the client workstation resolution can change
            // we enable use of shadow bitmap when fullscreen window size is smallerer than desktop size
            // otherwise disable the use of shadow bitmap 
            if(UI_IsFullScreen())
            {
                if ((_UI.mainWindowClientSize.width < _UI.desktopSize.width) ||
                    (_UI.mainWindowClientSize.height < _UI.desktopSize.height)) 
                {
                    _pCd->CD_DecoupleSyncNotification(CD_RCV_COMPONENT,
                                                      _pUh,
                                                      CD_NOTIFICATION_FUNC(CUH,UH_EnableShadowBitmap),
                                                      NULL);
                }
                else
                {
                    _pCd->CD_DecoupleSyncNotification(CD_RCV_COMPONENT,
                                                      _pUh,
                                                      CD_NOTIFICATION_FUNC(CUH,UH_DisableShadowBitmap),
                                                      NULL);
                }
            }
#endif // DISABLE_SHADOW_IN_FULLSCREEN
        }
        break;


        case WM_PAINT:
        {
            //
            // Paint the Main Window
            //
            TRC_DBG((TB, _T("Main Window WM_PAINT")));

            hdc = BeginPaint(hwnd, &ps);
            if (hdc == NULL)
            {
                TRC_SYSTEM_ERROR("BeginPaint failed");
                break;
            }

            GetClientRect(hwnd, &rect);

            if ((_UI.connectionStatus == UI_STATUS_CONNECTED))
            {
                //
                // We only paint the main window if it is bigger than the container
                // window. Hierarchy is
                // -Main
                //    -Container
                // this can happen even in windowed mode if the control is
                // sized bigger than the required desktop size
                RECT rcContainer;
                GetClientRect( _UI.hwndContainer, &rcContainer);
                if( (rcContainer.right < rect.right) ||
                    (rcContainer.bottom  < rect.bottom))
                {
                    //
                    // If we're full screen the paint a black frame around 
                    // the container..Else paint in the system background color
                    //
                    if(UI_IsFullScreen())
                    {
                        PatBlt( hdc,
                            rect.left,
                            rect.top,
                            rect.right - rect.left,
                            rect.bottom - rect.top,
                            BLACKNESS);
                    }
                    else
                    {
                        DWORD	dwBackColor = GetSysColor( COLOR_APPWORKSPACE);
#ifndef OS_WINCE
                        HBRUSH  hNewBrush = CreateSolidBrush( dwBackColor);
#else
                        HBRUSH  hNewBrush = CECreateSolidBrush( dwBackColor);
#endif
                        HBRUSH  hOldBrush = (HBRUSH)SelectObject( hdc, hNewBrush);

                        Rectangle( hdc,
                            rect.left,
                            rect.top,
                            rect.right,
                            rect.bottom);

                        SelectObject( hdc, hOldBrush);
#ifndef OS_WINCE
                        DeleteObject(hNewBrush);
#else
                        CEDeleteBrush(hNewBrush);
#endif

                    }
                }
            }
            EndPaint(hwnd, &ps);
        }
        break;

        case WM_VSCROLL:
        {
            DCINT   yStart;
            DCBOOL  smoothScroll = FALSE;

            TRC_DBG((TB, _T("Vertical scrolling")));

            yStart = _UI.scrollPos.y;

            //
            // Deal with vertical scrolling
            //
            switch (DC_GET_WM_SCROLL_CODE(wParam))
            {
                case SB_TOP:
                {
                    _UI.scrollPos.y = 0;
                }
                break;

                case SB_BOTTOM:
                {
                    _UI.scrollPos.y = _UI.scrollMax.y;
                }
                break;

                case SB_LINEUP:
                {
                    _UI.scrollPos.y -= UI_SCROLL_LINE_DISTANCE;
                }
                break;

                case SB_LINEDOWN:
                {
                    _UI.scrollPos.y += UI_SCROLL_LINE_DISTANCE;
                }
                break;

                case SB_PAGEUP:
                {
                    _UI.scrollPos.y -= UI_SCROLL_VERT_PAGE_DISTANCE;
                    smoothScroll = TRUE;
                }
                break;

                case SB_PAGEDOWN:
                {
                    _UI.scrollPos.y += UI_SCROLL_VERT_PAGE_DISTANCE;
                    smoothScroll = TRUE;
                }
                break;

                case SB_THUMBTRACK:
                {
                    _UI.scrollPos.y =
                                    DC_GET_WM_SCROLL_POSITION(wParam, lParam);
                }
                break;

                case SB_ENDSCROLL:
                {
                }
                break;

                default:
                {
                }
                break;
            }

            //
            // Move the Container and scrollbars appropriately
            //
            _UI.scrollPos.y = DC_MAX( 0,
                                     DC_MIN(_UI.scrollPos.y, _UI.scrollMax.y) );

            //
            // Don't smooth scroll unless specifically configured in the
            // registry.
            //
            if (smoothScroll && _UI.smoothScrolling)
            {
                DCINT   y;
                DCINT   step;
                DCUINT  numSteps;
                DCUINT  i;

                TRC_DBG((TB, _T("Smooth scroll")));
                step = (_UI.scrollPos.y < yStart) ? -UI_SMOOTH_SCROLL_STEP :
                                                    UI_SMOOTH_SCROLL_STEP;
                numSteps = DC_ABS(_UI.scrollPos.y - yStart) /
                                                        UI_SMOOTH_SCROLL_STEP;
                for ( i = 0,         y = yStart + step;
                      i < numSteps;
                      i++,           y += step )
                {
                    MoveWindow( _UI.hwndContainer,
                                -_UI.scrollPos.x,
                                -y,
                                _UI.containerSize.width,
                                _UI.containerSize.height,
                                TRUE );
                }
            }

            UIMoveContainerWindow();

            SetScrollPos(hwnd, SB_VERT, _UI.scrollPos.y, TRUE);
        }
        break;

        case WM_HSCROLL:
        {
            DCINT   xStart;
            DCBOOL  smoothScroll = FALSE;

            TRC_DBG((TB, _T("Horizontal scrolling")));

            xStart = _UI.scrollPos.x;

            //
            // Deal with horizontal scrolling
            //
            switch (DC_GET_WM_SCROLL_CODE(wParam))
            {
                case SB_TOP:
                {
                    _UI.scrollPos.x = 0;
                }
                break;

                case SB_BOTTOM:
                {
                    _UI.scrollPos.x = _UI.scrollMax.x;
                }
                break;

                case SB_LINELEFT:
                {
                    _UI.scrollPos.x -= UI_SCROLL_LINE_DISTANCE;
                }
                break;

                case SB_LINERIGHT:
                {
                    _UI.scrollPos.x += UI_SCROLL_LINE_DISTANCE;
                }
                break;

                case SB_PAGELEFT:
                {
                    _UI.scrollPos.x -= UI_SCROLL_HORZ_PAGE_DISTANCE;
                    smoothScroll = TRUE;
                }
                break;

                case SB_PAGERIGHT:
                {
                    _UI.scrollPos.x += UI_SCROLL_HORZ_PAGE_DISTANCE;
                    smoothScroll = TRUE;
                }
                break;

                case SB_THUMBTRACK:
                {
                    _UI.scrollPos.x =
                                    DC_GET_WM_SCROLL_POSITION(wParam, lParam);
                }
                break;

                case SB_ENDSCROLL:
                {
                }
                break;

                default:
                {
                }
                break;
            }

            //
            // Move the Container and scrollbar appropriately
            //
            _UI.scrollPos.x = DC_MAX( 0,
                                     DC_MIN(_UI.scrollPos.x, _UI.scrollMax.x) );

            //
            // Don't smooth scroll unless specifically configured in the
            // registry.
            //
            if (smoothScroll && _UI.smoothScrolling)
            {
                DCINT   x;
                DCINT   step;
                DCUINT  numSteps;
                DCUINT  i;

                TRC_DBG((TB, _T("Smooth scroll")));
                step = (_UI.scrollPos.x < xStart) ? -UI_SMOOTH_SCROLL_STEP :
                                                    UI_SMOOTH_SCROLL_STEP;
                numSteps = DC_ABS(_UI.scrollPos.x - xStart) /
                                                        UI_SMOOTH_SCROLL_STEP;
                for ( i = 0,         x = xStart + step;
                      i < numSteps;
                      i++,           x += step )
                {
                    MoveWindow( _UI.hwndContainer,
                                -x,
                                -_UI.scrollPos.y,
                                _UI.containerSize.width,
                                _UI.containerSize.height,
                                TRUE );
                }
            }

            UIMoveContainerWindow();

            SetScrollPos(hwnd, SB_HORZ, _UI.scrollPos.x, TRUE);
        }
        break;

        case WM_COMMAND:
        {
            //
            // Now switch on the command.
            //
            switch (DC_GET_WM_COMMAND_ID(wParam))
            {
                case UI_IDM_ACCELERATOR_PASSTHROUGH:
                {
                    //
                    // Toggle the accelerator passthrough menu item
                    //
                    _UI.acceleratorCheckState = !_UI.acceleratorCheckState;

                     _pCo->CO_SetConfigurationValue( CO_CFG_ACCELERATOR_PASSTHROUGH,
                                              _UI.acceleratorCheckState );
                }
                break;

                case UI_IDM_SMOOTHSCROLLING:
                {
                    //
                    // Toggle the smooth scrolling setting
                    //
                    _UI.smoothScrolling = !_UI.smoothScrolling;

                    UISmoothScrollingSettingChanged();
                }
                break;


                default:
                {
                    //
                    // Do Nothing
                    //
                }
                break;
            }
        }
        break;

        case WM_SYSCOMMAND:
        {
            rc = DefWindowProc(hwnd, message, wParam, lParam);
        }
        break;

        case WM_SYSCOLORCHANGE:
        {
#ifdef USE_BBAR
            //
            // Notify the bbar
            //
            if (_pBBar)
            {
                _pBBar->OnSysColorChange();
            }
#endif
        }
        break;

        case WM_DESTROY:
        {
            rc = DefWindowProc(hwnd, message, wParam, lParam);
        }
        break;

        case WM_CLOSE:
        {
            UI_UserRequestedClose();
        }
        break;

        case WM_TIMER:
        {
            TRC_DBG((TB, _T("Timer id %d"), wParam));

            if (_fTerminating) {
                //
                // Drop any defered processing such as timer messages
                // during termination
                //

                TRC_ERR((TB,_T("Received timer msg %d while terminating!"),
                         wParam));
                break;
            }

            switch (wParam)
            {
                case UI_TIMER_SHUTDOWN:
                {
                    TRC_DBG((TB, _T("Killing shutdown timer")));
                    KillTimer(_UI.hwndMain, _UI.shutdownTimer);
                    _UI.shutdownTimer = 0;
                    if (_UI.connectionStatus == UI_STATUS_CONNECTED)
                    {
                        //
                        // We've tried asking the server if we can shut
                        // down but it obviously hasn't responded.  We need
                        // to be more forceful.
                        //
                        TRC_ALT((TB, _T("Shutdown timeout: forcing shutdown")));
                         _pCo->CO_Shutdown(CO_DISCONNECT_AND_EXIT);
                    }
                    else
                    {
                        TRC_ALT((TB, _T("Spare shutdown timeout; conn status %u"),
                                     _UI.connectionStatus));
                    }
                }
                break;

                case UI_TIMER_SINGLE_CONN:
                {
                    TRC_NRM((TB, _T("Single connection timer")));

                    //
                    // We no longer need this timer.
                    //
                    
                    if( NULL != _UI.connectStruct.hSingleConnectTimer )
                    {
                        _pUt->UTDeleteTimer( _UI.connectStruct.hSingleConnectTimer );
                        TRC_NRM((TB, _T("Kill single connection timer")));
                        _UI.connectStruct.hSingleConnectTimer = NULL;
                    }
                    else
                    {
                        TRC_ALT((TB,_T("NULL timer handle for hSingleConnectTimer")));
                    }

                    if (_UI.connectionStatus == UI_STATUS_CONNECT_PENDING)
                    {
                        TRC_ALT((TB, _T("Timeout for IP address: try next")));

                        _UI.disconnectReason =
                            UI_MAKE_DISCONNECT_ERR(UI_ERR_DISCONNECT_TIMEOUT);

                        //
                        // Next connection will be attempted on receiving
                        // the OnDisconnected message
                        //
                         _pCo->CO_Disconnect();
                    }
                }
                break;

                case UI_TIMER_OVERALL_CONN:
                {
                    TRC_NRM((TB, _T("Overall connection timer")));

                    if( NULL != _UI.connectStruct.hConnectionTimer )
                    {
                        _pUt->UTDeleteTimer( _UI.connectStruct.hConnectionTimer );
                        _UI.connectStruct.hConnectionTimer = NULL;
                    }
                    else
                    {
                        TRC_ALT((TB,_T("NULL timer handle for hConnectionTimer")));
                    }

                    if ((_UI.connectionStatus == UI_STATUS_CONNECT_PENDING) ||
                        (_UI.connectionStatus == UI_STATUS_CONNECT_PENDING_DNS))
                    {
                        TRC_ALT((TB, _T("Timeout for connection")));

                        //
                        // Disconnect; display the timeout dialog
                        //
                        _UI.disconnectReason =
                            UI_MAKE_DISCONNECT_ERR(UI_ERR_DISCONNECT_TIMEOUT);
                        UIInitiateDisconnection();
                    }
                }
                break;

                case UI_TIMER_LICENSING:
                {
                    TRC_NRM((TB, _T("Licensing timer")));

                    if( NULL != _UI.connectStruct.hLicensingTimer )
                    {
                        _pUt->UTDeleteTimer( _UI.connectStruct.hLicensingTimer );
                        _UI.connectStruct.hLicensingTimer = NULL;
                    }
                    else
                    {
                        TRC_ALT((TB,_T("NULL timer handle for hLicensingTimer")));
                    }


                    TRC_ALT((TB, _T("Timeout for connection")));

                    // Disconnect due to licensing timeout
                    _UI.disconnectReason =
                            UI_MAKE_DISCONNECT_ERR( UI_ERR_LICENSING_TIMEOUT );

                    UIInitiateDisconnection();

                }
                break;

                //
                // Idle input notification timer
                //
                case UI_TIMER_IDLEINPUTTIMEOUT:
                {
                    //If no input was received during the idle period
                    //then fire an event to the control. Otherwise
                    //queue another timer interval. This only matters
                    //while we are connected and the timeout is still
                    //active
                    TRC_NRM((TB,_T("Idle timeout monitoring period elapsed")));
                    if(UI_STATUS_CONNECTED == _UI.connectionStatus &&
                       UI_GetMinsToIdleTimeout()) 
                    {
                        if(!_pIh->IH_GetInputWasSentFlag())
                        {
                            //Disable the timer. To prevent weird re-entrancy
                            //problems. E.g the if the event is fired and script
                            //pops a message box then we will be blocked and might
                            //receive another timer notification and re-enter
                            //this code path. Prevent that by ending the timer
                            //before firing the notification, you get a on-shot notify.
                            InitInputIdleTimer(0);

                            //Fire event to control.
                            SendMessage( _UI.hWndCntrl,
                                         WM_TS_IDLETIMEOUTNOTIFICATION, 0, 0);
                        }
                        else
                        {
                            //Input was sent during monitoring
                            //interval. Queue another wait interval
                            TRC_ASSERT(_UI.hIdleInputTimer,
                                       (TB,_T("_UI.hIdleInputTimer is null")));
                            _pIh->IH_ResetInputWasSentFlag();
                            if(!_pUt->UTStartTimer(_UI.hIdleInputTimer))
                            {
                                TRC_ERR((TB,_T("InitInputIdleTimer failed")));
                            }
                        }
                    }
                }
                break;

                #ifdef USE_BBAR
                case UI_TIMER_BBAR_UNHIDE_TIMERID:
                {
                    //
                    // This timer elapses when the mouse has hovered
                    // for a set amount of time within the dbl click rectangle
                    // the next part of the logic determines if the current
                    // mouse position is within the bbar hotzone and if so
                    // the bbar is lowered.
                    //
                    KillTimer( hwnd, UI_TIMER_BBAR_UNHIDE_TIMERID );
                    TRC_NRM((TB, _T("Timer fired: UI_TIMER_BBAR_UNHIDE_TIMERID")));
                    if(_UI.fBBarEnabled)
                    {
                        POINT pt;
                        RECT rc;

                        _ptBBarLastMousePos.x = -0x0fff;
                        _ptBBarLastMousePos.y = -0x0fff;

                        GetCursorPos(&pt);
                        GetWindowRect( hwnd, &rc);
                        rc.bottom = rc.top + IH_BBAR_HOTZONE_HEIGHT;
                        //
                        // Figure out if the cursor was in the
                        // bbar hotzone when the timer elapsed
                        //
                        if (PtInRect(&rc, pt))
                        {
                            //
                            // Notify that the bbar hotzone timer
                            // has elapsed. This may trigger a lowering
                            // of the bbar
                            //
                            UI_OnBBarHotzoneTimerFired(NULL);
                        }
                    }

                }
                break;
                #endif
                
                case UI_TIMER_DISCONNECT_TIMERID:
                {
                    TRC_NRM((TB, _T("Disconnect timer")));

                    TRC_ASSERT(( NULL != _UI.hDisconnectTimeout ),
                               (TB, _T("Unexpected NULL timer")));

                    if (NULL != _UI.hDisconnectTimeout)
                    {
                        _pUt->UTDeleteTimer( _UI.hDisconnectTimeout );
                        _UI.hDisconnectTimeout = NULL;
                    }

                    if (UI_STATUS_CONNECTED == _UI.connectionStatus)
                    {
                        //
                        // We've been left hanging too long in the connected
                        // but deactivated state
                        //
                        TRC_ALT((TB, _T("Timeout for not disconnecting in time")));
                        _UI.disconnectReason =
                                UI_MAKE_DISCONNECT_ERR( UI_ERR_DISCONNECT_TIMEOUT );

                        UIInitiateDisconnection();
                    }
                }
                break;

                default:
                {                                            
                    TRC_ABORT((TB, _T("Unexpected UI timer ID %d"), wParam));
                }
                break;
            }
        }
        break;

        case UI_WSA_GETHOSTBYNAME:
        {
            WORD    errorWSA;

            //
            // Drop any defered processing such as DNS lookups
            // during termination
            //
            if (_fTerminating) {
                TRC_ERR((TB, _T("Ignoring UI_WSA_GETHOSTBYNAME during termination")));
                break;
            }

            TRC_NRM((TB, _T("Got the host address list")));

            //
            // We've observed some cases in stress where there can be a pending
            // WSA_GETHOSTBYNAME message that gets processed after we disconnect
            // and delete the _pHostData. If that is the case just drop the message
            //
            if (!_pHostData) {
                TRC_ERR((TB,_T("_pHostData is NULL, ignoring UI_WSA_GETHOSTBYNAME")));
                break;
            }


            //
            // We've received the result of a WSAAsyncGetHostByName
            // operation.  Split the message apart and call the FSM.
            //
            errorWSA = WSAGETASYNCERROR(lParam);

            if (errorWSA != 0)
            {
                TRC_NRM((TB, _T("GHBN failed:%hu. Trying inet_addr(%s)"),
                         errorWSA, _UI.ansiAddress));

                _UI.hostAddress = inet_addr(_UI.ansiAddress);
                if (_UI.hostAddress != INADDR_NONE)
                {
                    //
                    // Great, we have an IP address.
                    //
                    TRC_NRM((TB, _T("%s looks like an IP address:%#lx"),
                             _UI.ansiAddress,
                             _UI.hostAddress));

                    UITryNextConnection();
                }
                else
                {
                    //
                    // Didn't recognise the address.  Disconnect and
                    // indicate the error event.
                    //
                    TRC_ALT((TB, _T("GHBN (%hu) and inet_addr() both failed"),
                            errorWSA));

                    //
                    // Yet another case where we are sure that
                    // we are now done with the winsock lookup
                    // buffer and can free it.
                    //
                    if(_pHostData)
                    {
                        LocalFree(_pHostData);
                        _pHostData = NULL;
                    }
                    UIInitiateDisconnection();
                    break;
                }
            }
            else
            {
                //
                // If there are no addresses to try, display the 'bad
                // server name' error.
                //
                UITryNextConnection();
            }
        }
        break;

        case WM_DESKTOPSIZECHANGE:
        {
            DCUINT  visibleScrollBars;
            DCSIZE  windowSize;
            DCSIZE  newSize;
#ifndef OS_WINCE
            DCSIZE  screenSize;
#endif

#ifdef OS_WINNT
            HMONITOR    hMonitor;
            MONITORINFO monInfo;
            RECT        screenRect;
#endif

            //
            // Handle client window resizing on connection
            //
            newSize.width  = LOWORD(lParam);
            newSize.height = HIWORD(lParam);
            TRC_NRM((TB, _T("Got new window size %d x %d"), newSize.width,
                                                        newSize.height ));

            //
            // Before we do anything with the new size, see if we are
            // currently showing scroll bars.
            //
            GetWindowRect(_UI.hwndMain, &rect);
            windowSize.width  = rect.right - rect.left;
            windowSize.height = rect.bottom - rect.top;

            visibleScrollBars = UICalculateVisibleScrollBars(windowSize.width,
                                                             windowSize.height);

            //
            // Now update the size of the desktop container
            //
            _UI.containerSize.width  = newSize.width;
            _UI.containerSize.height = newSize.height;

            //
            // Recalculate the new Main Window max size from the new
            // Container Window size
            //
            UIRecalcMaxMainWindowSize();

            //
            // And resize the container window
            //
            SetWindowPos( _UI.hwndContainer,
                          NULL,
                          0, 0,
                          _UI.containerSize.width,
                          _UI.containerSize.height,
                          SWP_NOZORDER | SWP_NOMOVE |
                                 SWP_NOACTIVATE | SWP_NOOWNERZORDER );

#ifndef OS_WINCE
            //
            // Do we need to adjust the window size?  Only if
            // 1.  we're not in full screen mode
            // 2.  we're not maximized
            // 3.  we were showing all of the old desktop (ie we had no
            //     scroll bars showing
            //
            if (((GetWindowLong(_UI.hwndMain,GWL_STYLE) & WS_MAXIMIZE) == 0) &&
                (visibleScrollBars == 0))
            {
                TRC_NRM((TB, _T("Adjusting window size...")));
                //
                // We adjust the window to display the new desktop size,
                // ensuring that it still fits on the screen.  First, find
                // out how big the screen is!
                //
                screenSize.width  = GetSystemMetrics(SM_CXSCREEN);
                screenSize.height = GetSystemMetrics(SM_CYSCREEN);
            
                if(_UI.fControlIsFullScreen)
                {
                #ifdef OS_WINNT
                    //
                    // For multi monitor systems, we need to find out which
                    // monitor the client window is on, and then get the screen
                    // size of that monitor
                    //
                    if (GetSystemMetrics(SM_CMONITORS))
                    {
                        hMonitor = MonitorFromWindow(_UI.hWndCntrl,
                                                     MONITOR_DEFAULTTONULL);
                        if (hMonitor != NULL)
                        {
                            monInfo.cbSize = sizeof(MONITORINFO);
                            if (GetMonitorInfo(hMonitor, &monInfo))
                            {
                                screenRect = monInfo.rcMonitor;
                                screenSize.width  = screenRect.right
                                                    - screenRect.left;
                                screenSize.height = screenRect.bottom
                                                    - screenRect.top;
                            }
                        }
                    }
                #endif // OS_WINNT
                } // (_UI.fControlIsFullScreen)

                //
                // Now limit the window size to fit on the screen
                //
                windowSize.width  = DC_MIN(_UI.maxMainWindowSize.width,
                                                           screenSize.width);
                windowSize.height = DC_MIN(_UI.maxMainWindowSize.height,
                                                           screenSize.height);

                SetWindowPos( _UI.hwndMain,
                              NULL,
                              0, 0,
                              windowSize.width,
                              windowSize.height,
                              SWP_NOZORDER | SWP_NOMOVE |
                                     SWP_NOACTIVATE | SWP_NOOWNERZORDER );
            }
#endif // ndef OS_WINCE
            
            //
            // Update the scroll bar settings
            //
            UIRecalculateScrollbars();
        }
        break;

        case WM_SETCURSOR:
        {
#ifdef USE_BBAR
            if (UI_IsFullScreen())
            {
                POINT pt;
                GetCursorPos(&pt);
                UISetBBarUnhideTimer( pt.x, pt.y );
            }
            else
            {
                if(_fBBarUnhideTimerActive)
                {
                    KillTimer( _UI.hwndMain,
                               UI_TIMER_BBAR_UNHIDE_TIMERID );
                    _fBBarUnhideTimerActive = FALSE;
                }
            }
#endif
            //
            // Pass the message on to windows otherwise
            // we get problems with cursors not getting updated
            // over scrollbars
            //
            rc = DefWindowProc(hwnd, message, wParam, lParam);
        }
        break;

        default:
        {
            rc = DefWindowProc(hwnd, message, wParam, lParam);
        }
        break;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


//
// Name:      UIRecalcMaxMainWindowSize
//                                                                          
// Purpose:   Recalculates _UI.maxMainWindowSize given the current Container
//            size and frame style. The maximum main window size is the
//            size of window needed such that the client area is the same
//            size as the container.
//
DCVOID DCINTERNAL CUI::UIRecalcMaxMainWindowSize(DCVOID)
{
    DCSIZE  screenSize;
#ifndef OS_WINCE
    RECT    rect;
#ifdef OS_WIN32
    BOOL    errorRc;
#endif
#endif
    RECT rcWebCtrl;

    DC_BEGIN_FN("UIRecalcMaxMainWindowSize");

    //
    // Get the screen size - this can change, so do it every time we need
    // it.
    //
    if(!_UI.fControlIsFullScreen)
    {
        GetClientRect( _UI.hWndCntrl, &rcWebCtrl);
        screenSize.width  = rcWebCtrl.right - rcWebCtrl.left;
        screenSize.height = rcWebCtrl.bottom - rcWebCtrl.top;
    }
    else
    {
        screenSize.width  = GetSystemMetrics(SM_CXSCREEN);
        screenSize.height = GetSystemMetrics(SM_CYSCREEN);
    }

    TRC_NRM((TB, _T("ActiveX control maxSize (%d,%d)"),
                                            screenSize.width,
                                            screenSize.height));

    //
    // If current mode is full screen, then the maximum window size is the
    // same as the screen size - unless the container is larger still,
    // which is possible if we're shadowing a session larger than
    // ourselves.
    //                                                                      
    // In this case, or if the current mode is not full screen then we want
    // the size of window which is required for a client area of the size
    // of the container.  Passing the container size to AdjustWindowRect
    // returns this window size.  Such a window may be bigger than the
    // screen, eg server and client are 640x480, container is 640x480.
    // AdjustWindowRect adds on the border, title bar and menu sizes and
    // returns something like 648x525.  So, _UI.maxMainWindowSize can only
    // match the actual window size when the client screen is bigger than
    // the server screen or when operating in full screen mode.  This means
    // that _UI.maxMainWindowSize should *never* be used to set the window
    // size, eg by passing it to SetWindowPos.  It can be used to determine
    // whether scroll bars are required, ie they are needed if the current
    // window size is less than _UI.maxMainWindowSize (in other words,
    // always unless in full screen mode or client screen is larger than
    // server screen).
    //                                                                      
    // To set the window size, calculate a value based on:
    // - the desired window size given the container size
    // - the size of the client screen.
    //

#ifndef OS_WINCE
    if ( _UI.fControlIsFullScreen && (            
        (_UI.containerSize.width > screenSize.width) ||
        (_UI.containerSize.height > screenSize.height)))
    {
        //
        // Recalc window size based on container
        //
        rect.left   = 0;
        rect.right  = _UI.containerSize.width;
        rect.top    = 0;
        rect.bottom = _UI.containerSize.height;

#ifdef OS_WIN32
        errorRc = AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, FALSE);
        TRC_ASSERT((errorRc != 0), (TB, _T("AdjustWindowRect failed")));
#else
        AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, FALSE);
#endif

        _UI.maxMainWindowSize.width = rect.right - rect.left;
        _UI.maxMainWindowSize.height = rect.bottom - rect.top;
    }
    else
#endif
    {
        //
        // Window size is simply the whole screen
        //
        _UI.maxMainWindowSize.width  = screenSize.width;
        _UI.maxMainWindowSize.height = screenSize.height;
    }
    TRC_NRM((TB, _T("Main Window maxSize (%d,%d)"),
                                       _UI.maxMainWindowSize.width,
                                       _UI.maxMainWindowSize.height));

    DC_END_FN();
} // UIRecalcMaxMainWindowSize


//
// Name:    UIConnectWithCurrentParams
//                                                                          
// Purpose: To connect to the host with the current set of parameters and
//          tidy up the main window and container sizes
//
DCVOID DCINTERNAL CUI::UIConnectWithCurrentParams(CONNECTIONMODE connMode)
{
    DCUINT timeout;
    int screenBpp;
    UINT screenColorDepthID;
    HRESULT hr;

    DC_BEGIN_FN("UIConnectWithCurrentParams");

    TRC_DBG((TB, _T("UIConnectWithCurrentParams called")));

    SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // If we're autoreconnecting and were connected to a cluster replace
    // the server name with the actual IP as we need to hit the same
    // server we were connected to.
    //
    if (UI_IsClientRedirected() &&
        UI_IsAutoReconnecting() &&
        _UI.RedirectionServerAddress[0]
        ) {
        TRC_NRM((TB,_T("ARC SD redirect target from %s to %s"),
                _UI.strAddress,
                 _UI.RedirectionServerAddress
                 ));
        hr = StringCchCopy(_UI.strAddress,
                          SIZE_TCHARS(_UI.strAddress),
                           _UI.RedirectionServerAddress);
        if (FAILED(hr)) {
            TRC_ERR((TB,_T("StringCchCopy for strAddress failed: 0x%x"),hr));
            DC_QUIT;
        }
    }


    //
    // Set connect watch flag to correctly handle connects
    // that are called in OnDisconnected event handlers
    //
    _UI.fConnectCalledWatch = TRUE;

    if( connMode != CONNECTIONMODE_INITIATE &&
        connMode != CONNECTIONMODE_CONNECTEDENDPOINT )
    {
        //
        // Invalid connection mode.
        //
        TRC_ERR((TB, _T("Invalid connect mode %d"), connMode));
        _UI.disconnectReason = 
                    UI_MAKE_DISCONNECT_ERR(UI_ERR_UNEXPECTED_DISCONNECT);
        UIInitiateDisconnection();
        DC_QUIT;
    }

    //
    // Get x and y ContainerSizes, relies on ordering of desktop size IDs
    //
    _UI.containerSize.width  = _UI.uiSizeTable[0];
    _UI.containerSize.height = _UI.uiSizeTable[1];

    _UI.connectStruct.desktopWidth  = (DCUINT16)_UI.containerSize.width;
    _UI.connectStruct.desktopHeight = (DCUINT16)_UI.containerSize.height;

    //
    // Recalculate the new Main Window max size from the new Container
    // Window size
    //
    UIRecalcMaxMainWindowSize();

    //
    // Resize the Container Window (but leave it invisible - it will
    // be shown when the connection is made).
    //
    SetWindowPos( _UI.hwndContainer,
                  NULL,
                  0, 0,
                  _UI.containerSize.width,
                  _UI.containerSize.height,
                  SWP_NOZORDER | SWP_NOMOVE |
                         SWP_NOACTIVATE | SWP_NOOWNERZORDER );

    TRC_DBG((TB, _T("Filling a connect struct")));

    screenBpp = UI_GetScreenBpp();
    screenColorDepthID = (UINT)UI_BppToColorDepthID(screenBpp);
    if(screenColorDepthID < _UI.colorDepthID)
    {
        TRC_NRM((TB,_T("Lowering color depth to match screen (from %d to %d)"),
                 _UI.colorDepthID, screenColorDepthID));
        _UI.colorDepthID =  screenColorDepthID;
    }

    _UI.connectStruct.colorDepthID = _UI.colorDepthID;
    _UI.connectStruct.transportType = _UI.transportType;
    _UI.connectStruct.sasSequence = _UI.sasSequence;

    //
    // Read the keyboard layout
    //
    _UI.connectStruct.keyboardLayout = UIGetKeyboardLayout();
    TRC_NRM((TB, _T("keyboard layout %#lx"), _UI.connectStruct.keyboardLayout));

    //
    // Read the keyboard type.
    // GetKeyboardType(0) is returned keyboard type.
    // GetKeyboardType(1) is returned sub keyboard type.
    // GetKeyboardType(2) is returned number of function keys.
    //
#if !defined(OS_WINCE)
    _UI.connectStruct.keyboardType        = GetKeyboardType(0);
    _UI.connectStruct.keyboardSubType     = GetKeyboardType(1);
    _UI.connectStruct.keyboardFunctionKey = GetKeyboardType(2);
    if (_pUt->UT_IsNEC98platform())
    {
        if (UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95 ||
            UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_31X)
        {
            /*
             * Hiword of "1" is a magic number for handling NEC PC-98 Win9x
             * keyboard layout on the Hydra server.
             */
            _UI.connectStruct.keyboardSubType = MAKELONG(
                _UI.connectStruct.keyboardSubType, 1);
        }
        else if (UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_NT)
        {
            OSVERSIONINFO   osVersionInfo;
            BOOL            bRc;

            osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
            bRc = GetVersionEx(&osVersionInfo);
            if (osVersionInfo.dwMajorVersion >= 5)
            {
                /*
                 * Hiword of "2" is a magic number for handling NEC PC-98 NT5
                 * keyboard layout on the Hydra server.
                 */
                _UI.connectStruct.keyboardSubType = MAKELONG(
                    _UI.connectStruct.keyboardSubType, 2);
            }
        }
    }
    else if (_pUt->UT_IsNew106Layout())
    {
        /*
         * Hiword of "1" is a magic number for handling 106 keyboard layout
         * on the Hydra server.
         * Because, Old 106 and New one has the same sub keyboard type.
         */
        _UI.connectStruct.keyboardSubType = MAKELONG(_UI.connectStruct.keyboardSubType, 1);
    }
    else if (_pUt->UT_IsFujitsuLayout())
    {
        /*
         * Hiword of "2" is a magic number for handling Fujitsu keyboard layout
         * on the Hydra server.
         */
        _UI.connectStruct.keyboardSubType = MAKELONG(_UI.connectStruct.keyboardSubType, 2);
    }
#else // !defined(OS_WINCE)
    //
    // WinCE doesn't have GetKeyboardType API.
    // Read the keyboard type/subtype/function keys from values set by
    // control properties
    //

    _UI.connectStruct.keyboardType     = _UI.winceKeyboardType;
    _UI.connectStruct.keyboardSubType  = _UI.winceKeyboardSubType;
    _UI.connectStruct.keyboardFunctionKey  = _UI.winceKeyboardFunctionKey;

#endif // !defined(OS_WINCE)
    TRC_NRM((TB, _T("keyboard type %#lx sub type %#lx func key %#lx"),
        _UI.connectStruct.keyboardType,
        _UI.connectStruct.keyboardSubType,
        _UI.connectStruct.keyboardFunctionKey));


    //
    // Read the IME file name.
    //
    UIGetIMEFileName(_UI.connectStruct.imeFileName,
                     sizeof(_UI.connectStruct.imeFileName) / sizeof(TCHAR));
    TRC_NRM((TB, _T("IME file name %s"), _UI.connectStruct.imeFileName));

    //
    // The shadow bitmap flag should already be set.
    // Set the dedicated termianl flag.
    // Then copy the connect flags.
    //
    if (_UI.dedicatedTerminal)
    {
        SET_FLAG(_UI.connectFlags, CO_CONN_FLAG_DEDICATED_TERMINAL);
    }
    else
    {
        CLEAR_FLAG(_UI.connectFlags, CO_CONN_FLAG_DEDICATED_TERMINAL);
    }

    _UI.connectStruct.connectFlags = _UI.connectFlags;


    //
    // And start a connection timeout timer.  If one is already running
    // (from a prevous attempt) then restart it.
    //

    if( _UI.connectStruct.hConnectionTimer )
    {
        _pUt->UTStopTimer( _UI.connectStruct.hConnectionTimer );
    }

    TRC_NRM((TB, _T("Single connection timeout %u seconds"), _UI.singleTimeout));

    //
    // Set the licensing phase timeout
    //

    _UI.licensingTimeout = DEFAULT_LICENSING_TIMEOUT;

    TRC_NRM((TB, _T("Licensing timeout %u seconds"), _UI.licensingTimeout));

    UI_SetConnectionMode( connMode );

    if( connMode == CONNECTIONMODE_INITIATE )
    {
        UISetConnectionStatus(UI_STATUS_CONNECT_PENDING_DNS);

        timeout = _UI.connectionTimeOut;

        TRC_NRM((TB, _T("Connection timeout %d seconds"), timeout));

        if( NULL == _UI.connectStruct.hConnectionTimer )
        {
            _UI.connectStruct.hConnectionTimer = _pUt->UTCreateTimer(
                                                        _UI.hwndMain,
                                                        UI_TIMER_OVERALL_CONN,
                                                        timeout * 1000 );
        }

        if( NULL == _UI.connectStruct.hConnectionTimer )
        {
            //
            // Cannot connect without a timeout - fail with an error
            //
            TRC_ERR((TB, _T("Failed to create connection timeout timer")));
            _UI.disconnectReason = UI_MAKE_DISCONNECT_ERR(UI_ERR_NOTIMER);
            UIInitiateDisconnection();
            DC_QUIT;
        }

        if( FALSE == _pUt->UTStartTimer( _UI.connectStruct.hConnectionTimer ) )
        {
            //
            // Cannot connect without a timeout - fail with an error
            //
            TRC_ERR((TB, _T("Failed to start connection timeout timer")));
            _UI.disconnectReason = UI_MAKE_DISCONNECT_ERR(UI_ERR_NOTIMER);
            UIInitiateDisconnection();
            DC_QUIT;
        }

        _UI.connectStruct.bInitiateConnect = TRUE;
        UIStartDNSLookup();
    }
    else
    {
        // A new state is necessary so when disconnect come in, it won't
        // triggle CUI::UI_OnDisconnected()'s UITryNextConnection()
        // code path.
        UISetConnectionStatus(UI_STATUS_PENDING_CONNECTENDPOINT);

        // socket already connected, start various timer
        if( NULL == _UI.connectStruct.hSingleConnectTimer )
        {
            _UI.connectStruct.hSingleConnectTimer = 
                        _pUt->UTCreateTimer(_UI.hwndMain, 
                                            UI_TIMER_SINGLE_CONN,
                                            _UI.singleTimeout * 1000 );
        }

        if( NULL == _UI.connectStruct.hSingleConnectTimer )
        {
            TRC_ERR(
                (TB, _T("Failed to create single connection timeout timer")));

            _UI.disconnectReason = UI_MAKE_DISCONNECT_ERR(UI_ERR_NOTIMER);
            UIInitiateDisconnection();
            DC_QUIT;
        }

        if( NULL == _UI.connectStruct.hLicensingTimer )
        {
            _UI.connectStruct.hLicensingTimer = 
                        _pUt->UTCreateTimer(_UI.hwndMain,
                                            UI_TIMER_LICENSING,
                                            _UI.licensingTimeout * 1000 );
        }

        if( NULL == _UI.connectStruct.hLicensingTimer )
        {
            TRC_ERR((TB, _T("Failed to create licensing timeout timer")));
            _UI.disconnectReason = UI_MAKE_DISCONNECT_ERR(UI_ERR_NOTIMER);
            UIInitiateDisconnection();
            DC_QUIT;
        }

        _UI.connectStruct.bInitiateConnect = FALSE;
        UIStartConnectWithConnectedEndpoint();
    }

    //Notify the Ax control that we are connecting
    TRC_DBG((TB, _T("Connecting...")));
    SendMessage( _UI.hWndCntrl, WM_TS_CONNECTING, 0, 0);

DC_EXIT_POINT:

    SetCursor(LoadCursor(NULL, IDC_ARROW));

    DC_END_FN();
} // UIConnectWithCurrentParams


//
// Name:    UICalculateVisibleScrollBars
//                                                                          
// Purpose: Calculates whether scrollbars are needed
//                                                                          
// Returns: DCUINT containing flags whether or not the vertical and
//          horizontal scrollbars are needed
//                                                                          
// Params:  IN - width and height of frame
//
DCUINT DCINTERNAL CUI::UICalculateVisibleScrollBars( DCUINT mainFrameWidth,
                                                DCUINT mainFrameHeight )
{
    DCUINT  rc;
    DCSIZE  screenSize;
#ifndef OS_WINCE
    RECT    rect;
    BOOL    errorRc;
#endif


#ifdef OS_WINNT
    HMONITOR  hMonitor;
    MONITORINFO monInfo;
#endif // OS_WINNT

    DC_BEGIN_FN("UICalculateVisibleScrollBars");

    // for multi monitor, need to find which monitor the client window
    // resides, then get the correct screen size of the corresponding
    // monitor

    // default screen size
    screenSize.height = _UI.containerSize.height;
    screenSize.width  = _UI.containerSize.width;

    if(_UI.fControlIsFullScreen)
    {
#ifdef OS_WINNT
        if (GetSystemMetrics(SM_CMONITORS)) {
            hMonitor = MonitorFromWindow(_UI.hWndCntrl, MONITOR_DEFAULTTONULL);
            if (hMonitor != NULL) {
                monInfo.cbSize = sizeof(MONITORINFO);
                if (GetMonitorInfo(hMonitor, &monInfo)) {
                    screenSize.height = max(screenSize.height,
                            (unsigned)(monInfo.rcMonitor.bottom - monInfo.rcMonitor.top));
                    screenSize.width = max(screenSize.width,
                            (unsigned)(monInfo.rcMonitor.right - monInfo.rcMonitor.left));
                }
            }
        }
#endif // OS_WINNT
    } // (_UI.fControlIsFullScreen)

    TRC_DBG((TB, _T("mainFrameWidth = %d"), mainFrameWidth));
    TRC_DBG((TB, _T("mainFrameHeight = %d"), mainFrameHeight));

    TRC_DBG((TB, _T("ScreenSize.width = %d"), screenSize.width));
    TRC_DBG((TB, _T("ScreenSize.height = %d"), screenSize.height));

    //
    // Calculate the neccessity for the scrollbars
    //
#ifdef SMART_SIZING
    if (_UI.fSmartSizing) {
        rc = UI_NO_SCROLLBARS;
    }  
    else 
#endif // SMART_SIZING
    if ( (mainFrameWidth >= screenSize.width) &&
         (mainFrameHeight >= screenSize.height) )
    {
        rc = UI_NO_SCROLLBARS;
    }
    else if ( (mainFrameWidth < screenSize.width) &&
              (mainFrameHeight >=
                   (screenSize.height + GetSystemMetrics(SM_CYHSCROLL))) )
    {
        rc = UI_BOTTOM_SCROLLBAR;
    }
    else if ( (mainFrameHeight < screenSize.height) &&
              (mainFrameWidth >=
                   (screenSize.width + GetSystemMetrics(SM_CXVSCROLL))) )
    {
        rc = UI_RIGHT_SCROLLBAR;
    }
    else
    {
        rc = UI_BOTH_SCROLLBARS;
    }

#ifndef OS_WINCE
    //
    // Check specifically for a main window size that corresponds to a
    // zero-height client area.  This special case requires that we disable
    // the right-hand scrollbar, because GetClientArea returns values that
    // indicate it is disabled.
    //
    rect.left   = 0;
    rect.right  = _UI.containerSize.width;
    rect.top    = 0;
    rect.bottom = 0;

#ifdef OS_WIN32
    errorRc =
#endif
        AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, FALSE);

#ifdef OS_WIN32
    TRC_ASSERT((errorRc != 0), (TB, _T("AdjustWindowRect failed")));
#endif

    TRC_DBG((TB, _T("Zero-height client area => main window height %d"),
                 rect.bottom - rect.top));

    if (mainFrameHeight == (DCUINT)(rect.bottom - rect.top))
    {
        //
        // The client size is zero height - turn off the right scrollbar
        //
        rc &= ~(DCUINT)UI_RIGHT_SCROLLBAR;
    }
#endif //OS_WINCE

    DC_END_FN();
    return(rc);
}

//
// Name:    UIRecalculateScrollbars
//                                                                          
// Purpose: Calculates where to position the Container window within the
//          Main Window
//
DCVOID DCINTERNAL CUI::UIRecalculateScrollbars(DCVOID)
{
    RECT        rect;
    RECT        clientRect;
    DCBOOL      horzScrollBarIsVisible = TRUE;
    DCBOOL      vertScrollBarIsVisible = TRUE;
    SCROLLINFO  scrollInfo;
    DCSIZE      windowSize;
    DCSIZE      clientSize;
    DCBOOL      needMove = FALSE;
    DCUINT      visibleScrollBars;
#ifdef OS_WINCE
    DCUINT32    style;
#endif // OS_WINCE

    DC_BEGIN_FN("UIRecalculateScrollbars");

    //
    // Get the dimensions of the window. Use this to determine the need
    // for scrolling, rather than using the client rect, as it is constant
    // for a given window size (obviously) while the client area varies as
    // scroll bars appear and disappear. We can use the window size since
    // we previously calculated the window size needed to accomodate the
    // entire container (this is the _UI.maxMainWindowSize). If the current
    // window size is less than _UI.maxMainWindowSize we know that the
    // client area is less than the container size and scroll bars are
    // needed.
    //
    GetWindowRect(_UI.hwndMain, &rect);
    windowSize.width  = rect.right - rect.left;
    windowSize.height = rect.bottom - rect.top;

    if(_UI.fControlIsFullScreen)
    {
        windowSize.width  = DC_MIN(windowSize.width,
                                   (DCUINT)GetSystemMetrics(SM_CXSCREEN));
        windowSize.height = DC_MIN(windowSize.height,
                                   (DCUINT)GetSystemMetrics(SM_CYSCREEN));
    }
    
    //
    // First establish whether scrollbars are needed
    //
    visibleScrollBars = UICalculateVisibleScrollBars(windowSize.width,
                                                     windowSize.height);
#ifdef OS_WINCE
    //
    // ShowScrollBar is unsupported in WinCE - instead, set the window
    // styles ourself
    //
    style = GetWindowLong( _UI.hwndMain,
                           GWL_STYLE );

    if (visibleScrollBars & UI_BOTTOM_SCROLLBAR)
    {
        style |= WS_HSCROLL;
    }
    else
    {
        style &= ~WS_HSCROLL;
    }

    if (visibleScrollBars & UI_RIGHT_SCROLLBAR)
    {
        style |= WS_VSCROLL;
    }
    else
    {
        style &= ~WS_VSCROLL;
    }

    SetWindowLong( _UI.hwndMain,
                   GWL_STYLE,
                   style );

#else

    _UI.fHorizontalScrollBarVisible = ((visibleScrollBars & UI_BOTTOM_SCROLLBAR) != 0) ?
                                      TRUE : FALSE;
    ShowScrollBar( _UI.hwndMain,
                   SB_HORZ,
                   _UI.fHorizontalScrollBarVisible);

    _UI.fVerticalScrollBarVisible = ((visibleScrollBars & UI_RIGHT_SCROLLBAR) != 0) ?
                                    TRUE : FALSE;    
    ShowScrollBar( _UI.hwndMain,
                   SB_VERT,
                   _UI.fVerticalScrollBarVisible);

#endif // OS_WINCE

    //
    // Get the client area width and height
    //
    GetClientRect(_UI.hwndMain, &clientRect);

    clientSize.width  = clientRect.right - clientRect.left;
    clientSize.height = clientRect.bottom - clientRect.top;

    TRC_DBG((TB, _T("Window rect %d,%d %d,%d"), rect.left,
                                            rect.top,
                                            rect.right,
                                            rect.bottom));
    TRC_DBG((TB, _T("Client:= width %d, height %d"),
                                      clientSize.width, clientSize.height));
    TRC_DBG((TB, _T("Container:= width %d, height %d"),
                          _UI.containerSize.width, _UI.containerSize.height));
    _UI.scrollMax.x = _UI.containerSize.width - clientSize.width;
    _UI.scrollMax.y = _UI.containerSize.height - clientSize.height;

    TRC_NRM((TB, _T("scrollMax (%d,%d)"), _UI.scrollMax.x, _UI.scrollMax.y));

    //
    // If the Container is larger than the client, adjust the scrollbars
    // appropriately
    //
    if (clientSize.width <= _UI.containerSize.width) {
        if (_UI.scrollPos.x > _UI.scrollMax.x) {
            _UI.scrollPos.x = _UI.scrollMax.x;
            needMove = TRUE;
        } else if (_UI.scrollPos.x < 0) {
            _UI.scrollPos.x = 0;
            needMove = TRUE;
        }
    } else {
        //
        // else put the Container in the middle of the client area
        //
        _UI.scrollPos.x = _UI.scrollMax.x / 2;
        needMove = TRUE;
    }

    if (clientSize.height <= _UI.containerSize.height) {
        if (_UI.scrollPos.y > _UI.scrollMax.y) {
            _UI.scrollPos.y = _UI.scrollMax.y;
            needMove = TRUE;
        } else if (_UI.scrollPos.y < 0) {
            _UI.scrollPos.y = 0;
            needMove = TRUE;
        }
    } else {
        //
        // else put the Container in the middle of the client area
        //
        _UI.scrollPos.y = _UI.scrollMax.y / 2;

        needMove = TRUE;
    }

    if (needMove) {
        UIMoveContainerWindow();
    }

    TRC_DBG((TB, _T("scrollPos (%d,%d)"), _UI.scrollPos.x, _UI.scrollPos.y));

    //
    // Common header fields
    //
    scrollInfo.cbSize = sizeof(scrollInfo);
    scrollInfo.fMask  = SIF_ALL;

    if ((visibleScrollBars & UI_BOTTOM_SCROLLBAR) != 0)
    {
        //
        // Set horizontal values
        //
        scrollInfo.nMin  = 0;
        scrollInfo.nMax  = _UI.containerSize.width - 1;
        scrollInfo.nPage = clientSize.width;
        scrollInfo.nPos  = _UI.scrollPos.x;

        UISetScrollInfo(SB_HORZ,
                        &scrollInfo,
                        TRUE);
    }

    if ((visibleScrollBars & UI_RIGHT_SCROLLBAR) != 0)
    {
        //
        // Set vertical values
        //
        scrollInfo.nMin  = 0;
        scrollInfo.nMax  = _UI.containerSize.height - 1;
        scrollInfo.nPage = clientSize.height;
        scrollInfo.nPos  = _UI.scrollPos.y;

        UISetScrollInfo(SB_VERT,
                        &scrollInfo,
                        TRUE);
    }

DC_EXIT_POINT:
    DC_END_FN();
    return;
}

//
// Name:    UIMoveContainerWindow
//                                                                          
// Purpose: Moves the container window to its new position and flags it to
//          be repainted
//
DCVOID DCINTERNAL CUI::UIMoveContainerWindow(DCVOID)
{
#ifdef OS_WINCE
    RECT rect;
#endif

    DC_BEGIN_FN("UIMoveContainerWindow");

    if(!_UI.hwndContainer)
    {
        #ifdef DEFER_CORE_INIT
        TRC_ASSERT((NULL != _UI.hwndContainer), (TB, _T("_UI.hwndContainer is NULL")));
        #endif
        DC_QUIT;
    }

#ifdef OS_WINCE
    //
    // WinCE will do a move even if one isn't required.  Stop that here.
    //
    GetWindowRect(_UI.hwndContainer, &rect);

    if ((rect.left != -_UI.scrollPos.x) ||
        (rect.top  != -_UI.scrollPos.y) ||
        ((DCUINT)(rect.right - rect.left) != _UI.containerSize.width) ||
        ((DCUINT)(rect.bottom - rect.top) != _UI.containerSize.height))
#endif
    {
        MoveWindow( _UI.hwndContainer,
                    -_UI.scrollPos.x,
                    -_UI.scrollPos.y,
                    _UI.containerSize.width,
                    _UI.containerSize.height,
                    TRUE );
    }

    DC_END_FN();
DC_EXIT_POINT:
    ;
}


//
// Name:      UIUpdateScreenMode
//
// Purpose:   Updates the window settings after a switch to/from fullscreen
//
// Params:
//          fGrabFocus - if true grabs the focus
//
DCVOID DCINTERNAL CUI::UIUpdateScreenMode(BOOL fGrabFocus)
{
    DCUINT32  style;
    LONG      wID;

    // multi-monitor support
    RECT screenRect;
#ifdef OS_WINNT
    HMONITOR  hMonitor;
    MONITORINFO monInfo;
#endif // OS_WINNT

    DC_BEGIN_FN("UIUpdateScreenMode");

    TRC_NRM((TB, _T("Entering Fullscreen mode")));

#if !defined(OS_WINCE) || defined(OS_WINCE_LOCKWINDOWUPDATE)
    LockWindowUpdate( _UI.hwndMain );
#endif // !defined(OS_WINCE) || defined(OS_WINCE_LOCKWINDOWUPDATE)

    UIRecalcMaxMainWindowSize();

    //
    // Take away the title bar and borders
    //
    style = GetWindowLong( _UI.hwndMain,
                           GWL_STYLE );

#if !defined(OS_WINCE) || defined(OS_WINCE_NONFULLSCREEN)
    style &= ~(WS_DLGFRAME |
               WS_THICKFRAME | WS_BORDER |
               WS_MAXIMIZEBOX);

#else // !defined(OS_WINCE) || defined(OS_WINCE_NONFULLSCREEN)
    style &= ~(WS_DLGFRAME | WS_SYSMENU | WS_BORDER);
#endif // !defined(OS_WINCE) || defined(OS_WINCE_NONFULLSCREEN)
    SetWindowLong( _UI.hwndMain,
                   GWL_STYLE,
                   style );

    //
    // Set the window ID (to remove the menu titles).
    //
    wID = SetWindowLong( _UI.hwndMain, GWL_ID, 0 );

    //
    /// Note that two calls to SetWindowPos are required here in order to
    /// adjust the position to allow for frame removal and also to correctly
    // set the Z-ordering.
    //

    // default screen size
    screenRect.top  = 0;
    screenRect.left = 0;

    //
    // Win32 sets the window size clipped to the physical screen; Win16
    // seems to store the size you set regardless - which is not the
    // behavior we want later on when we query the window size to work out
    // if we need scroll bars
    //
    screenRect.bottom = _UI.maxMainWindowSize.height;
    screenRect.right = _UI.maxMainWindowSize.width;

    // for multi monitor, need to find which monitor the client window
    // resides, then get the correct screen size of the corresponding
    // monitor

    if(_UI.fControlIsFullScreen)
    {
#ifdef OS_WINNT
        if (GetSystemMetrics(SM_CMONITORS)) {
            hMonitor = MonitorFromWindow(_UI.hWndCntrl, MONITOR_DEFAULTTONULL);
            if (hMonitor != NULL) {
                monInfo.cbSize = sizeof(MONITORINFO);
                if (GetMonitorInfo(hMonitor, &monInfo)) {
                    screenRect = monInfo.rcMonitor;
                }
            }
        }
#endif // OS_WINNT
    } //(_UI.fControlIsFullScreen)

    
    //
    // Reposition and size the window with the frame changes, and place at
    // the top of the Z-order (by not setting SWP_NOOWNERZORDER or
    // SWP_NOZORDER and specifying HWND_TOP).
    //
    SetWindowPos( _UI.hwndMain,
                  HWND_TOP,
                  screenRect.left, screenRect.top,
                  screenRect.right - screenRect.left,
                  screenRect.bottom - screenRect.top,
                  SWP_NOACTIVATE | SWP_FRAMECHANGED );

    //
    // Reposition the window again - otherwise the fullscreen window is
    // positioned as if it still had borders.
    //
    SetWindowPos( _UI.hwndMain,
                  NULL,
                  screenRect.left, screenRect.top,
                  0, 0,
                  SWP_NOZORDER | SWP_NOACTIVATE |
                      SWP_NOOWNERZORDER | SWP_NOSIZE );

    //
    // Reset the container to top left
    //
    _UI.scrollPos.x = 0;
    _UI.scrollPos.y = 0;

    UIRecalculateScrollbars();

    UIMoveContainerWindow();

#if !defined(OS_WINCE) || defined(OS_WINCE_LOCKWINDOWUPDATE)
    LockWindowUpdate( NULL );
#endif // !defined(OS_WINCE) || defined(OS_WINCE_LOCKWINDOWUPDATE)

    //
    // Make sure we have the focus after a screen mode toggle
    //
    if(fGrabFocus)
    {
        SetFocus(_UI.hwndContainer);
    }

    DC_END_FN();
} // UIUpdateScreenMode


//
// Name: UIValidateCurrentParams
//                                                                          
// Purpose: To check whether the current connection parameters are valid
//                                                                          
// Returns: TRUE - if the parameters are valid
//          FALSE otherwise
//
BOOL DCINTERNAL CUI::UIValidateCurrentParams(CONNECTIONMODE connMode)
{
    BOOL rc = TRUE;
    unsigned xSize = _UI.controlSize.width;
    unsigned ySize = _UI.controlSize.height;

    DC_BEGIN_FN("UIValidateCurrentParams");

    if( CONNECTIONMODE_INITIATE == connMode )
    {
        //
        // If the Address is empty, the params are invalid
        //
        if ((DC_TSTRCMP(_UI.strAddress, _T("")) == 0))
        {
            rc = FALSE;
            DC_QUIT;
        }
    }

    //
    // Make sure we have a screen big enough for the the remote desktop
    //
    if ((xSize < _UI.uiSizeTable[0]) ||
        (ySize < _UI.uiSizeTable[1]) )
    {
        rc = FALSE;
        DC_QUIT;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
} // UIValidateCurrentParams


//
// Name:      UIShadowBitmapSettingChanged
//
// Purpose:   Performs necessary actions when _UI.shadowBitmapEnabled
//            is updated.
//
DCVOID DCINTERNAL CUI::UIShadowBitmapSettingChanged(DCVOID)
{
    DC_BEGIN_FN("UIShadowBitmapSettingChanged");

    if (_UI.shadowBitmapEnabled)
    {
        SET_FLAG(_UI.connectFlags, CO_CONN_FLAG_SHADOW_BITMAP_ENABLED);
    }
    else
    {
        CLEAR_FLAG(_UI.connectFlags, CO_CONN_FLAG_SHADOW_BITMAP_ENABLED);
    }

    DC_END_FN();
    return;
}


//
// Name:      UISmoothScrollingSettingChanged
//                                                                          
// Purpose:   Performs necessary actions when _UI.smoothScrolling
//            is updated.
//
DCVOID DCINTERNAL CUI::UISmoothScrollingSettingChanged(DCVOID)
{
    DC_BEGIN_FN("UISmoothScrollingSettingChanged");

    DC_END_FN();
}

//
// Name:      UISetScrollInfo
//                                                                          
// Purpose:   Sets scroll bar parameters
//                                                                          
// Returns:   DC_RC_OK if successful, error code otherwise
//                                                                          
// Params:    IN     hwnd - handle of window with scroll bar
//            IN     scrollBarFlag - type of scroll bar
//            IN     pScrollInfo - info to set for the scrollbar
//            IN     redraw - TRUE if scrollbar to be redrawn
//
unsigned DCINTERNAL CUI::UISetScrollInfo(
        int scrollBarFlag,
        LPSCROLLINFO pScrollInfo,
        BOOL         redraw)
{
    unsigned rc = DC_RC_OK;

    DC_BEGIN_FN("UISetScrollInfo");

    //
    // This only works for scroll bar flags indicating horizontal and/or
    // vertical scrollbar.
    //
    TRC_ASSERT((!TEST_FLAG(scrollBarFlag, ~(SB_HORZ | SB_VERT))),
                          (TB, _T("Invalid scroll bar flag %#x"), scrollBarFlag));

    TRC_ASSERT((!IsBadReadPtr(pScrollInfo, sizeof(*pScrollInfo))),
                           (TB, _T("Bad scroll info memory %p"), pScrollInfo));

    //
    // Call the Windows API to set the information.
    //
    SetScrollInfo(_UI.hwndMain,
                  scrollBarFlag,
                  pScrollInfo,
                  redraw);
    DC_END_FN();
    return rc;
}


//
// Name:      UISetConnectionStatus
//                                                                          
// Purpose:   Sets the UI connection status
//
DCVOID DCINTERNAL CUI::UISetConnectionStatus(DCUINT status)
{
    DC_BEGIN_FN("UISetConnectionStatus");

    if (_UI.connectionStatus == status)
    {
        DC_QUIT;
    }

    //
    // Store the new connection status.
    //
    TRC_NRM((TB, _T("UI connection status %u->%u"), _UI.connectionStatus, status));
    _UI.connectionStatus = status;

DC_EXIT_POINT:
    DC_END_FN();
}


//
// Name:      UIInitializeDefaultSettings
//                                                                          
// Purpose:   Initialize connection settings with defaults. This is mainly
//            for advanced settings that can optionally be overwridden by
//            the user
//
void DCINTERNAL CUI::UIInitializeDefaultSettings()
{
    unsigned nRead = 0;
    unsigned i;
    int defaultValue;
    HDC hdc;
    int colorDepthID;
    TCHAR szWPosDflt[] = UTREG_UI_WIN_POS_STR_DFLT;
    HRESULT hr;

    DC_BEGIN_FN("UIInitializeDefaultSettings");

    //
    // Get screen mode before creating windows
    //
    _UI.windowPlacement.length = sizeof(_UI.windowPlacement);

    //
    // Set the maximized / minimized positions to the hardcoded defaults.
    //
    UISetMinMaxPlacement();

    //
    // Find out the actual display depth
    //
    // Don't worry about these functions failing - if they do, we'll use
    // the default setting, or 8bpp if no registry setting.
    //
    colorDepthID = CO_BITSPERPEL8;
    hdc = GetDC(NULL);
    TRC_ASSERT((NULL != hdc), (TB,_T("Failed to get DC")));
    if(hdc)
    {
#ifdef DC_HICOLOR
        DCINT       screenBpp;
        screenBpp = GetDeviceCaps(hdc, BITSPIXEL);
        TRC_NRM((TB, _T("HDC %p has %u bpp"), hdc, screenBpp));
        //
        // Clamp the default color depth to 16bpp for best perf
        //
        screenBpp = screenBpp > 16 ? 16 : screenBpp;
        colorDepthID = UI_BppToColorDepthID( screenBpp );
#else
        DCINT numColors = GetDeviceCaps(hdc, NUMCOLORS);
        TRC_NRM((TB, _T("HDC %p, num colors"), hdc, numColors));
        colorDepthID = (numColors == 16) ?  CO_BITSPERPEL4 :  CO_BITSPERPEL8;
#endif
        ReleaseDC(NULL, hdc);
    }
    
    TRC_NRM((TB, _T("Color depth ID %d"), colorDepthID));
    _UI.colorDepthID = colorDepthID;
    //
    // Read auto connect flag
    //
    TRC_NRM((TB, _T("AutoConnect = %d"), _UI.autoConnectEnabled));

    //
    // Read the smooth scrolling option
    //
    _UI.smoothScrolling = UTREG_UI_SMOOTH_SCROLL_DFLT;

    //
    // Read the accelerator check state
    //
    _UI.acceleratorCheckState = UTREG_UI_ACCELERATOR_PASSTHROUGH_ENABLED_DFLT;

    //
    // Read the Shadow Bitmap option
    //
#ifndef OS_WINCE
    _UI.shadowBitmapEnabled = UTREG_UI_SHADOW_BITMAP_DFLT;
#else
    _UI.shadowBitmapEnabled = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                                  UTREG_UI_SHADOW_BITMAP,
                                                  UTREG_UI_SHADOW_BITMAP_DFLT);
#endif

    _UI.fMaximizeShell      = UTREG_UI_MAXIMIZESHELL50_DFLT;

    //
    // Keyboard hooking mode
    //
    _UI.keyboardHookMode = UTREG_UI_KEYBOARD_HOOK_DFLT;

    //
    // Audio redirection mode
    //
    _UI.audioRedirectionMode = UTREG_UI_AUDIO_MODE_DFLT;

    //
    // !WARNING! if you change this default to TRUE revisit the security
    // code that disables drive redirection in response to a reg key
    // in the control's put_RedirectDrives method. It only does the check
    // on the property set to avoid a reg access in the connect path.
    //
    // Drive
    //
    _UI.fEnableDriveRedirection = FALSE; //off by default for security

    //
    // Printers
    //
    _UI.fEnablePrinterRedirection = FALSE; //off by default for security

    //
    // COM ports
    //
    _UI.fEnablePortRedirection = FALSE;  //off by default for security

    //
    // Smart card
    //
    _UI.fEnableSCardRedirection = FALSE; //off by default for security

    //
    // Connect to server console is disabled by default
    //
    UI_SetConnectToServerConsole(FALSE);

    //
    // Order draw threshold
    //
    _UI.orderDrawThreshold  = UTREG_UH_DRAW_THRESHOLD_DFLT;
    _UI.RegBitmapCacheSize  = UTREG_UH_TOTAL_BM_CACHE_DFLT;
    _UI.RegBitmapVirtualCache8BppSize = TSC_BITMAPCACHEVIRTUALSIZE_8BPP;
    _UI.RegBitmapVirtualCache16BppSize = TSC_BITMAPCACHEVIRTUALSIZE_16BPP;
    _UI.RegBitmapVirtualCache24BppSize = TSC_BITMAPCACHEVIRTUALSIZE_24BPP;

    _UI.RegScaleBitmapCachesByBPP = UTREG_UH_SCALE_BM_CACHE_DFLT;
    _UI.PersistCacheFileName[0] = NULL;
    _UI.RegNumBitmapCaches  = UTREG_UH_BM_NUM_CELL_CACHES_DFLT;

    const unsigned ProportionDefault[TS_BITMAPCACHE_MAX_CELL_CACHES] =
    {
        UTREG_UH_BM_CACHE1_PROPORTION_DFLT,
        UTREG_UH_BM_CACHE2_PROPORTION_DFLT,
        UTREG_UH_BM_CACHE3_PROPORTION_DFLT,
        UTREG_UH_BM_CACHE4_PROPORTION_DFLT,
        UTREG_UH_BM_CACHE5_PROPORTION_DFLT,
    };
    #if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    
    const unsigned PersistenceDefault[TS_BITMAPCACHE_MAX_CELL_CACHES] =
    {
        UTREG_UH_BM_CACHE1_PERSISTENCE_DFLT,
        UTREG_UH_BM_CACHE2_PERSISTENCE_DFLT,
        UTREG_UH_BM_CACHE3_PERSISTENCE_DFLT,
        UTREG_UH_BM_CACHE4_PERSISTENCE_DFLT,
        UTREG_UH_BM_CACHE5_PERSISTENCE_DFLT,
    };
    #endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    
    const unsigned MaxEntriesDefault[TS_BITMAPCACHE_MAX_CELL_CACHES] =
    {
        UTREG_UH_BM_CACHE1_MAXENTRIES_DFLT,
        UTREG_UH_BM_CACHE2_MAXENTRIES_DFLT,
        UTREG_UH_BM_CACHE3_MAXENTRIES_DFLT,
        UTREG_UH_BM_CACHE4_MAXENTRIES_DFLT,
        UTREG_UH_BM_CACHE5_MAXENTRIES_DFLT,
    };


    for (i = 0; i < TS_BITMAPCACHE_MAX_CELL_CACHES; i++)
    {
        _UI.RegBCProportion[i] = ProportionDefault[i];

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
        _UI.bSendBitmapKeys[i] = PersistenceDefault[i] ? TRUE: FALSE;
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    
        _UI.RegBCMaxEntries[i] = MaxEntriesDefault[i];

        if (_UI.RegBCMaxEntries[i] < MaxEntriesDefault[i]) {
            _UI.RegBCMaxEntries[i] = MaxEntriesDefault[i];
        }
    }

    _UI.GlyphSupportLevel = UTREG_UH_GL_SUPPORT_DFLT;

    _UI.cbGlyphCacheEntrySize[0] = UTREG_UH_GL_CACHE1_CELLSIZE_DFLT;
    _UI.cbGlyphCacheEntrySize[1] = UTREG_UH_GL_CACHE2_CELLSIZE_DFLT;
    _UI.cbGlyphCacheEntrySize[2] = UTREG_UH_GL_CACHE3_CELLSIZE_DFLT;
    _UI.cbGlyphCacheEntrySize[3] = UTREG_UH_GL_CACHE4_CELLSIZE_DFLT;
    _UI.cbGlyphCacheEntrySize[4] = UTREG_UH_GL_CACHE5_CELLSIZE_DFLT;
    _UI.cbGlyphCacheEntrySize[5] = UTREG_UH_GL_CACHE6_CELLSIZE_DFLT;
    _UI.cbGlyphCacheEntrySize[6] = UTREG_UH_GL_CACHE7_CELLSIZE_DFLT;
    _UI.cbGlyphCacheEntrySize[7] = UTREG_UH_GL_CACHE8_CELLSIZE_DFLT;
    _UI.cbGlyphCacheEntrySize[8] = UTREG_UH_GL_CACHE9_CELLSIZE_DFLT;
    _UI.cbGlyphCacheEntrySize[9] = UTREG_UH_GL_CACHE10_CELLSIZE_DFLT;
    
    _UI.fragCellSize = UTREG_UH_FG_CELLSIZE_DFLT;
    _UI.brushSupportLevel = UTREG_UH_BRUSH_SUPPORT_DFLT;

    _UI.maxEventCount = UTREG_IH_MAX_EVENT_COUNT_DFLT;
    _UI.eventsAtOnce  = UTREG_IH_NRM_EVENT_COUNT_DFLT;
    _UI.minSendInterval = UTREG_IH_MIN_SEND_INTERVAL_DFLT;
    _UI.keepAliveInterval = UTREG_IH_KEEPALIVE_INTERVAL_DFLT;
    _UI.allowBackgroundInput = UTREG_IH_ALLOWBACKGROUNDINPUT_DFLT;


    _UI.shutdownTimeout = UTREG_UI_SHUTDOWN_TIMEOUT_DFLT;

    #ifdef OS_WINCE
    _UI.winceKeyboardType        = UTREG_UI_KEYBOARD_TYPE_DFLT;
    _UI.winceKeyboardSubType     = UTREG_UI_KEYBOARD_SUBTYPE_DFLT;
    _UI.winceKeyboardFunctionKey = UTREG_UI_KEYBOARD_FUNCTIONKEY_DFLT;
    #endif
    
    _UI.connectionTimeOut = UTREG_UI_OVERALL_CONN_TIMEOUT_DFLT;
    _UI.singleTimeout     = UTREG_UI_SINGLE_CONN_TIMEOUT_DFLT;
    hr = StringCchCopy(
            _UI.szKeyBoardLayoutStr,
            SIZE_TCHARS(_UI.szKeyBoardLayoutStr),
            UTREG_UI_KEYBOARD_LAYOUT_DFLT
            );
    TRC_ASSERT(SUCCEEDED(hr),
               (TB,_T("StringCchCopy for keyblayout str failed: 0x%x"), hr));

    //
    // Read the transport type
    // VER1: Restricted to TCP only.
    //
    _UI.transportType = UTREG_UI_TRANSPORT_TYPE_DFLT;
    if (_UI.transportType != CO_TRANSPORT_TCP)
    {
        TRC_ABORT((TB, _T("Illegal Tansport Type %d configured"),
                        _UI.transportType));
        _UI.transportType = UTREG_UI_TRANSPORT_TYPE_DFLT;
    }

    //
    // SAS sequence
    //
    _UI.sasSequence = UTREG_UI_SAS_SEQUENCE_DFLT;
    if ((_UI.sasSequence != RNS_UD_SAS_DEL) &&
        (_UI.sasSequence != RNS_UD_SAS_NONE))
    {
        TRC_ABORT((TB, _T("Illegal SAS Sequence %#x configured"),_UI.sasSequence));
        _UI.sasSequence = UTREG_UI_SAS_SEQUENCE_DFLT;
    }

    //
    // encryption enabled flag
    //
    _UI.encryptionEnabled = UTREG_UI_ENCRYPTION_ENABLED_DFLT;

    //
    // dedicated terminal flag
    //
    _UI.dedicatedTerminal = UTREG_UI_DEDICATED_TERMINAL_DFLT;

    _UI.MCSPort = UTREG_UI_MCS_PORT_DFLT;

    //
    // fMouse flag
    //
    _UI.fMouse = UTREG_UI_ENABLE_MOUSE_DFLT;

    //
    // Read the DisableCtrlAltDel flag
    //
    _UI.fDisableCtrlAltDel = UTREG_UI_DISABLE_CTRLALTDEL_DFLT;

#ifdef SMART_SIZING
    //
    // Read the SmartSizing flag
    //
    _UI.fSmartSizing = UTREG_UI_SMARTSIZING_DFLT;
#endif // SMART_SIZING

    //
    // Read the EnableWindowsKey flag
    //
    _UI.fEnableWindowsKey = UTREG_UI_ENABLE_WINDOWSKEY_DFLT;

    //
    // Read the DoubleClickDetect flag
    //
    _UI.fDoubleClickDetect = UTREG_UI_DOUBLECLICK_DETECT_DFLT;

    //
    // Set screen mode hotkey
    //
#ifndef OS_WINCE // Only full screen on WinCE
    defaultValue = UTREG_UI_FULL_SCREEN_VK_CODE_DFLT;
    if (_pUt->UT_IsNEC98platform())
    {
        defaultValue = UTREG_UI_FULL_SCREEN_VK_CODE_NEC98_DFLT;
    }
    _UI.hotKey.fullScreen = defaultValue;
#endif // OS_WINCE

    //
    // Set the ctrl-esc key to it's default.
    //
    _UI.hotKey.ctrlEsc = UTREG_UI_CTRL_ESC_VK_CODE_DFLT;

    //
    // Set the alt-esc key to it's default.
    //
    _UI.hotKey.altEsc = UTREG_UI_ALT_ESC_VK_CODE_DFLT;

    //
    // Set the alt-tab key to it's default.
    //
    _UI.hotKey.altTab = UTREG_UI_ALT_TAB_VK_CODE_DFLT;

    //
    // Set the alt-shift-tab key to it's default.
    //
    _UI.hotKey.altShifttab =  UTREG_UI_ALT_SHFTAB_VK_CODE_DFLT;

    //
    // Set the alt-space key to it's default.
    //
    _UI.hotKey.altSpace = UTREG_UI_ALT_SPACE_VK_CODE_DFLT;

    //
    // Set the ctrl-alt-del key to it's default.
    //
    defaultValue = UTREG_UI_CTRL_ALTDELETE_VK_CODE_DFLT;
    if (_pUt->UT_IsNEC98platform())
    {
        defaultValue = UTREG_UI_CTRL_ALTDELETE_VK_CODE_NEC98_DFLT;
    }
    _UI.hotKey.ctlrAltdel = defaultValue;

    //
    // Read the compression option
    //
    UI_SetCompress(UTREG_UI_COMPRESS_DFLT);

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    _UI.fBitmapPersistence = UTREG_UI_BITMAP_PERSISTENCE_DFLT;
#else
    _UI.fBitmapPersistence = UTREG_UI_BITMAP_PERSISTENCE_DFLT;
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    TRC_NRM((TB, _T("Bitmap Persistence Enabled = %d"), _UI.fBitmapPersistence));

#ifdef DC_DEBUG
    //
    // Set the debug options to their defaults
    //
    _UI.hatchBitmapPDUData   = UTREG_UI_HATCH_BITMAP_PDU_DATA_DFLT;

    _UI.hatchSSBOrderData    = UTREG_UI_HATCH_SSB_ORDER_DATA_DFLT;

    _UI.hatchMemBltOrderData = UTREG_UI_HATCH_MEMBLT_ORDER_DATA_DFLT;

    _UI.labelMemBltOrders    = UTREG_UI_LABEL_MEMBLT_ORDERS_DFLT;

    _UI.bitmapCacheMonitor   = UTREG_UI_BITMAP_CACHE_MONITOR_DFLT;
#endif // DC_DEBUG

    _UI.coreInitialized = FALSE;

    OSVERSIONINFO   osVersionInfo;
    BOOL            bRc;

    //
    // Set the OS version
    //
    osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
    bRc = GetVersionEx(&osVersionInfo);

    TRC_ASSERT((bRc), (TB,_T("GetVersionEx failed")));
#ifdef OS_WINCE
    TRC_ASSERT((osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_CE),
               (TB,_T("Unknown os version %d"), osVersionInfo.dwPlatformId));
#else
    TRC_ASSERT(((osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ||
                (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)),
                (TB,_T("Unknown os version %d"), osVersionInfo.dwPlatformId));

    _UI.osMinorType =
                  (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ?
                        TS_OSMINORTYPE_WINDOWS_95 : TS_OSMINORTYPE_WINDOWS_NT;
#endif

    _UI.fRunningOnPTS = IsRunningOnPTS();

#ifdef USE_BBAR    
    _UI.fBBarEnabled  = TRUE;
    _UI.fBBarPinned   = TRUE;
    _UI.fBBarShowMinimizeButton = TRUE;
    _UI.fBBarShowRestoreButton = TRUE;
#endif

    _UI.fGrabFocusOnConnect = TRUE;
    //
    // Perf optimization settings (which features to disable)
    // Default is to disable nothing
    //
    _UI.dwPerformanceFlags = TS_PERF_DISABLE_NOTHING;

    // default to don't notify TS public key
    // currently only RemoteAssistance uses this.
    _UI.fNotifyTSPublicKey = FALSE;

    //
    // Max number of ARC retries
    //
    UI_SetMaxArcAttempts(MAX_ARC_CONNECTION_ATTEMPTS);

    //
    // By default allow autoreconnection
    //
    UI_SetEnableAutoReconnect(TRUE);

    DC_END_FN();
}

//
// Name:      UISetMinMaxPlacement
//                                                                          
// Purpose:   Reset the minimized / maximized placement
// Operation: Allow for the window border width.
//
void DCINTERNAL CUI::UISetMinMaxPlacement()
{
    DC_BEGIN_FN("UISetMinMaxPlacement");

    //
    // Set the maximized position to the top left - allow for the window
    // frame width.
    //
#if !defined(OS_WINCE) || defined(OS_WINCE_NONFULLSCREEN)
    _UI.windowPlacement.ptMaxPosition.x = -GetSystemMetrics(SM_CXFRAME);
    _UI.windowPlacement.ptMaxPosition.y = -GetSystemMetrics(SM_CYFRAME);
#else // !defined(OS_WINCE) || defined(OS_WINCE_NONFULLSCREEN)
    _UI.windowPlacement.ptMaxPosition.x = 0;
    _UI.windowPlacement.ptMaxPosition.y = 0;
#endif // !defined(OS_WINCE) || defined(OS_WINCE_NONFULLSCREEN)

    //
    // Minimized position is 0, 0
    //
    _UI.windowPlacement.ptMinPosition.x = 0;
    _UI.windowPlacement.ptMinPosition.y = 0;

    DC_END_FN();
} // UISetMinMaxPlacement


//
// Name:      UIInitiateDisconnection
//                                                                          
// Purpose:   Call  _pCo->CO_Disconnect, set UI states and menus
//
void DCINTERNAL CUI::UIInitiateDisconnection()
{
#ifndef OS_WINCE
    int intRC;
#endif

    DC_BEGIN_FN("UIInitiateDisconnection");

    TRC_NRM((TB, _T("Disconnecting...")));

    if (_UI.connectionStatus != UI_STATUS_CONNECT_PENDING_DNS)
    {
        //
        // Only disconnect if we have issued  CO_Connect - not if we are
        // still awaiting the host name lookup.
        //
        TRC_NRM((TB, _T("UI calling  _pCo->CO_Disconnect")));
         _pCo->CO_Disconnect();
    }
    else
    {
        if (!UIFreeAsyncDNSBuffer()) {
            if (_pHostData) {
                TRC_ERR((TB,
                _T("Failed to free async dns buffer. Status: %d hghbn: 0x%x"),
                _UI.connectionStatus, _UI.hGHBN));
            }
        }

        //
        // Now indicate that disconnection has completed
        // and fire the event
        //
        UIGoDisconnected(_UI.disconnectReason, TRUE);
    }

    DC_END_FN();
} // UIInitiateDisconnection


//
// Name:      UIGetKeyboardLayout
//                                                                          
// Purpose:   Get the keyboard layout ID
//                                                                          
// Returns:   layout ID
//                                                                          
// Operation: Win16: Read SYSTEM.INI to find the keyboard DLL name.  Look
//            this up in the Client INI file to find the keyboard layout ID
//            Win32: use GetKeyboardLayout()
//
UINT32 DCINTERNAL CUI::UIGetKeyboardLayout()
{
    UINT32 layout = RNS_UD_KBD_DEFAULT;
    TCHAR  szLayoutStr[UTREG_UI_KEYBOARD_LAYOUT_LEN];
    CHAR   kbdName[KL_NAMELENGTH];
    HRESULT hr;

    DC_BEGIN_FN("UIGetKeyboardLayout");

    //
    // Read the keyboard type.
    // First look for a registry / ini entry
    //
    hr = StringCchCopy(szLayoutStr,
                       SIZE_TCHARS(szLayoutStr),
                       _UI.szKeyBoardLayoutStr);
    if (FAILED(hr)) {
        TRC_ERR((TB,_T("StringCchCopy for keyboard layout str failed: 0x%x"),hr));
        DC_QUIT;
    }

    if (!DC_TSTRCMP(szLayoutStr, UTREG_UI_KEYBOARD_LAYOUT_DFLT))
    {
        //
        // Read the layout - OS dependent method.
        //
        TRC_DBG((TB, _T("No registry setting - determine the layout")));

        //
        // GetKeyboardLayout does not return the correct information, so
        // use CicSubstGetKeyboardLayout (a Cicero replacement for
        // GetKeyboardLayoutName that can correctly return the physical hKL
        // even when Cicero is active such as with CUAS). 
        //
#ifndef OS_WINCE
        if (!CicSubstGetKeyboardLayout(kbdName))
#else
        if (!GetKeyboardLayoutName(kbdName))
#endif
        {
            TRC_ALT((TB, _T("Failed to get keyboard layout name")));
            DC_QUIT;
        }
        hr = StringCchPrintf(szLayoutStr, SIZE_TCHARS(szLayoutStr),
                             _T("0x%S"), kbdName);
    }

    //
    // Convert from hex string to int.
    //
    TRC_DBG((TB, _T("Layout Name %s"), szLayoutStr));
    if (DC_TSSCANF(szLayoutStr, _T("%lx"), &layout) != 1)
    {
        TRC_ALT((TB, _T("Invalid keyboard layout %s"), szLayoutStr));
        layout = RNS_UD_KBD_DEFAULT;
    }

    /*
     * The HKL of US-Dvorak, US-International on Win95 have a difference to WinNT.
     * This code is swaped HKL value if platform is Win95.
     */
    if (UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_95 &&
        (layout == 0x00010409 || layout == 0x00020409))
    {
        if (layout == 0x00010409)
            layout = 0x00020409;
        else
            layout = 0x00010409;
    }

DC_EXIT_POINT:
    TRC_NRM((TB, _T("Layout ID %#lx"), layout));
    DC_END_FN();
    return layout;
} // UIGetKeyboardLayout

//
// Name:      UIStartConnectWithConnectedEndpoint
//                                                                          
// Purpose:   Connect with a connected socket
//                                                                          
// Params:    IN      disconnectCode - error code to be displayed if there
//                                     are no more connections to try.
//                                                                          
// Notes:     The disconnectCode is either a timeout, or the ID passed in
//            to UI_OnDisconnected().
//
void DCINTERNAL CUI::UIStartConnectWithConnectedEndpoint()
{
    DC_BEGIN_FN("UIStartConnectWithConnectedEndpoint");

    //
    // Call CC_Connect via the Component Decoupler
    //
    _UI.disconnectReason =UI_MAKE_DISCONNECT_ERR(UI_ERR_UNEXPECTED_DISCONNECT);
    _pCo->CO_Connect(&_UI.connectStruct);

    UISetConnectionStatus(UI_STATUS_PENDING_CONNECTENDPOINT);

DC_EXIT_POINT:
    DC_END_FN();
} // UIStartListen


//
// Name:      UITryNextConnection
//                                                                          
// Purpose:   Attempt to connect to an IP address
//                                                                          
// Params:    IN      disconnectCode - error code to be displayed if there
//                                     are no more connections to try.
//                                                                          
// Notes:     The disconnectCode is either a timeout, or the ID passed in
//            to UI_OnDisconnected().
//
void DCINTERNAL CUI::UITryNextConnection()
{
    u_long       addr;
    u_long DCPTR pAddr;
    HRESULT      hr;

    DC_BEGIN_FN("UITryNextConnection");

    addr = _UI.hostAddress;

    //
    // Stop the single connection timer.
    //
    if( _UI.connectStruct.hSingleConnectTimer )
    {
        _pUt->UTStopTimer( _UI.connectStruct.hSingleConnectTimer );
    }

    //
    // Check for the DNS case
    //
    if (addr == INADDR_NONE)
    {
        pAddr = (u_long DCPTR)
              ((struct hostent DCPTR)_pHostData)->h_addr_list[_UI.addrIndex];
        if (pAddr != NULL)
        {
            addr = *pAddr;
        }
        else
        {
            TRC_NRM((TB, _T("No more addresses in list")));
            addr = 0;
        }

        TRC_NRM((TB, _T("DNS lookup address [%d] %#lx"), _UI.addrIndex, addr));
        _UI.addrIndex++;
    }
    else
    {
        //
        // Not DNS - just a single address, so set to zero for next time.
        //
        TRC_NRM((TB, _T("Normal address %#lx"), addr));
        _UI.hostAddress = 0;
    }

    if (addr == 0)
    {
        //
        // Cannot connect - so put up the failure dialog.
        //
        TRC_NRM((TB, _T("No more IP addresses")));

        //
        // Kill the overall connection timer, as this is the last in the
        // list.
        //
        if( _UI.connectStruct.hConnectionTimer )
        {
            _pUt->UTDeleteTimer( _UI.connectStruct.hConnectionTimer );
            _UI.connectStruct.hConnectionTimer = NULL;
        }

        UIGoDisconnected(_UI.disconnectReason, TRUE);
        DC_QUIT;
    }

    DCUINT32 localSessionId;
    UI_GetLocalSessionId( &localSessionId );

    //
    // Prevent loopback connections to (really session 0)
    // Requirments for loopback are
    // 1) Connecting to same machine client is running on
    // 2) Either of
    //    -this is a PTS box
    //    -Connect to console (session 0) is set and this _is_ session 0.
    //
    if(((_UI.fRunningOnPTS ||
        (UI_GetConnectToServerConsole() && 0 == localSessionId)) &&
        IsConnectingToOwnAddress(addr)))
    {
        //Disconnect don't allow loopback connects to own console
        _UI.disconnectReason =
            UI_MAKE_DISCONNECT_ERR(UI_ERR_LOOPBACK_CONSOLE_CONNECT);
        UIGoDisconnected(_UI.disconnectReason, TRUE);
        DC_QUIT;
    }

    //
    // Network Layer currently still uses inet_addr() - so write the
    // address as a dotted xx.xx.xx.xx string
    //
    hr = StringCchPrintf(
                _UI.connectStruct.RNSAddress,
                SIZE_TCHARS(_UI.connectStruct.RNSAddress),
                _T("%ld.%ld.%ld.%ld"),
                addr & 0xFF,
                (addr>>8) & 0xFF,
                (addr>>16) & 0xFF,
                (addr>>24) & 0xFF);
    if (SUCCEEDED(hr)) {
        TRC_NRM((TB, _T(" _pCo->CO_Connect: Try address %#lx = %s"),
                     addr, _UI.connectStruct.RNSAddress));
    }
    else {
        TRC_ERR((TB,_T("Unable to sprintf RNSAddress: 0x%x"), hr));
        _UI.disconnectReason =
            UI_MAKE_DISCONNECT_ERR(UI_ERR_GHBNFAILED);
        UIGoDisconnected(_UI.disconnectReason, TRUE);
        DC_QUIT;
    }

    //
    // create the various timer handles for the connection process
    //
    if( NULL == _UI.connectStruct.hSingleConnectTimer )
    {
        _UI.connectStruct.hSingleConnectTimer = _pUt->UTCreateTimer(
                                                    _UI.hwndMain,
                                                    UI_TIMER_SINGLE_CONN,
                                                    _UI.singleTimeout * 1000 );
    }

    if( NULL == _UI.connectStruct.hSingleConnectTimer )
    {
        TRC_ERR((TB, _T("Failed to create single connection timeout timer")));
    }

    if( NULL == _UI.connectStruct.hLicensingTimer )
    {
        _UI.connectStruct.hLicensingTimer = _pUt->UTCreateTimer(
                                                    _UI.hwndMain,
                                                    UI_TIMER_LICENSING,
                                                    _UI.licensingTimeout * 1000 );
    }

    if( NULL == _UI.connectStruct.hLicensingTimer )
    {
        TRC_ERR((TB, _T("Failed to create licensing timeout timer")));
    }

    //
    // Call CC_Connect via the Component Decoupler
    //
    _UI.disconnectReason =UI_MAKE_DISCONNECT_ERR(UI_ERR_UNEXPECTED_DISCONNECT);
     _pCo->CO_Connect(&_UI.connectStruct);

    //
    // start the single connection timer
    //

    if( _UI.connectStruct.hSingleConnectTimer )
    {
        if( FALSE == _pUt->UTStartTimer( _UI.connectStruct.hSingleConnectTimer ) )
        {
            TRC_ERR((TB, _T("Failed to start single connection timeout timer")));
        }
    }

    UISetConnectionStatus(UI_STATUS_CONNECT_PENDING);

DC_EXIT_POINT:
    DC_END_FN();
} // UITryNextConnection


//
// UIRedirectConnection
//
// Used for load balancing redirection for force the client to reflect
// to the target server.
//
void DCINTERNAL CUI::UIRedirectConnection()
{
    HRESULT hr;
    DC_BEGIN_FN("UIRedirectConnection");

    TRC_ASSERT((_UI.DoRedirection),(TB,_T("DoRedir is not set!")));

    // Stop the single connection timer.
    if (_UI.connectStruct.hSingleConnectTimer)
        _pUt->UTStopTimer(_UI.connectStruct.hSingleConnectTimer);

#ifdef UNICODE
    TRC_NRM((TB,_T("Target address before redirection replacement: %S"),
            _UI.strAddress));
    hr = StringCchCopy(_UI.strAddress,
                       SIZE_TCHARS(_UI.strAddress),
                       _UI.RedirectionServerAddress);
    if (FAILED(hr)) {
        TRC_ERR((TB,_T("StringCchCopy for strAddress failed: 0x%x"),hr));
        DC_QUIT;
    }

#else
    TRC_NRM((TB,_T("Target address before redirection replacement: %s"),
            _UI.strAddress));

#ifdef OS_WIN32
    // Translate the Unicode server name to ANSI.
    WideCharToMultiByte(CP_ACP, 0, _UI.RedirectionServerAddress, -1,
            _UI.strAddress, 256, NULL, NULL);
#else
    {
        // For Win16, need to manually convert Unicode to ANSI.
        int i = 0;

        while (_UI.RedirectionServerAddress[i]) {
            _UI.strAddress[i] = (BYTE)_UI.RedirectionServerAddress[i];
            i++;
        }
        _UI.strAddress[i] = 0;
    }
#endif

#endif  // UNICODE

    TRC_NRM((TB,_T("Setting redirection server address to %S"),
            _UI.RedirectionServerAddress));

    // Reset the redirection server string.
    _UI.RedirectionServerAddress[0] = L'\0';

    // Start the DNS lookup for the server name, and hence the rest of the
    // connection sequence.
    UIStartDNSLookup();

DC_EXIT_POINT:

    DC_END_FN();
}


//
// Name:      UIStartDNSLookup
//                                                                          
// Purpose:   Initiate lookup of the host IP address(es)
//
void DCINTERNAL CUI::UIStartDNSLookup()
{
    UINT32 errorCode;

    DC_BEGIN_FN("UIStartDNSLookup");

    UISetConnectionStatus(UI_STATUS_CONNECT_PENDING_DNS);

    _UI.addrIndex = 0;

#ifdef UNICODE
    //
    // WinSock 1.1 only supports ANSI, so we need to convert any Unicode
    // strings at this point.
    //
    if (!WideCharToMultiByte(CP_ACP,
                             0,
                             _UI.strAddress,
                             -1,
                             _UI.ansiAddress,
                             256,
                             NULL,
                             NULL))
    {
        //
        // Conversion failed
        //
        TRC_ERR((TB, _T("Failed to convert address to ANSI")));

        //
        // Generate the error code.
        //
        errorCode = UI_MAKE_DISCONNECT_ERR(UI_ERR_ANSICONVERT);

        TRC_ASSERT((HIWORD(errorCode) == 0),
                   (TB, _T("disconnect reason code unexpectedly using 32 bits")));
        UIGoDisconnected((DCUINT)errorCode, TRUE);
        DC_QUIT;
    }

#else
    StringCchCopyA(_UI.ansiAddress, sizeof(_UI.ansiAddress), _UI.strAddress);
#endif // UNICODE

    //
    // Check that the address is not the limited broadcast address
    // (255.255.255.255).  inet_addr() doesn't distinguish between this and
    // an invalid IP address.
    //
    if (!strcmp(_UI.ansiAddress, "255.255.255.255")) {
        TRC_ALT((TB, _T("Cannot connect to the limited broadcast address")));

        //
        // Generate the error code.
        //
        errorCode = UI_MAKE_DISCONNECT_ERR(UI_ERR_BADIPADDRESS);

        TRC_ASSERT((HIWORD(errorCode) == 0),
                   (TB, _T("disconnect reason code unexpectedly using 32 bits")));
        UIGoDisconnected((DCUINT)errorCode, TRUE);
        DC_QUIT;
    }

    //
    // Now determine whether a DNS lookup is required.
    //
    TRC_NRM((TB, _T("ServerAddress:%s"), _UI.ansiAddress));

    //
    // Check that we have a string.
    //
    TRC_ASSERT((_UI.ansiAddress[0] != '\0'),
               (TB, _T("Empty server address string")));

    //
    // Set this to a known value.  It's used later to decide whether we're
    // using DNS or a straight IP address.
    //
    _UI.hostAddress = INADDR_NONE;


    if(NULL == _pHostData)
    {
        //
        // Allocate new buffer
        //
        _pHostData = (PBYTE)LocalAlloc( LPTR, MAXGETHOSTSTRUCT);
        if(_pHostData)
        {
            DC_MEMSET(_pHostData, 0, MAXGETHOSTSTRUCT);
        }
        else
        {
            UI_FatalError(DC_ERR_OUTOFMEMORY);
            DC_QUIT;
        }
    }
    else
    {
        //
        // Use existing
        //

        TRC_ERR((TB,_T("_pHostData already allocated!!! Possibly leaking!")));
    }


    //
    // Start DNS lookup, assuming this is a server name.  If it's an IP
    // address, this call will fail and we'll use inet_addr() instead.
    // This mechanism allows us to specify server names that are
    // all-numeric.  inet_addr() interprets a single number as an IP
    // address (see inet_addr() documentation in MSDN).
    //
    TRC_NRM((TB, _T("Doing DNS lookup for '%s'"), _UI.ansiAddress));
    _UI.disconnectReason = UI_MAKE_DISCONNECT_ERR(UI_ERR_GHBNFAILED);

    _UI.hGHBN = WSAAsyncGetHostByName(_UI.hwndMain,
                                     UI_WSA_GETHOSTBYNAME,
                                     _UI.ansiAddress,
                                     (char*)_pHostData,
                                     MAXGETHOSTSTRUCT);
    if (_UI.hGHBN == 0)
    {
        //
        // Failed to start the async operation. Free the buffer here
        // an find out what went wrong.
        //
        LocalFree(_pHostData);
        _pHostData = NULL;

        TRC_ALT((TB, _T("Failed to initiate GetHostByName")));
        UIGoDisconnected(UI_MAKE_DISCONNECT_ERR(UI_ERR_DNSLOOKUPFAILED), TRUE);
        DC_QUIT;
    }

    //
    // Now just wait for the callback.
    //

DC_EXIT_POINT:
    DC_END_FN();
} // UIStartDNSLookup


//
// Name:      UIGoDisconnected
//                                                                          
// Purpose:   Tail processing for disconnection process
//            Does final cleanup, hides connection windows etc
//                                                                          
// Params:    IN     disconnectID - disconnection error code
//            IN     fFireEvent   - true to fire a disconnect event
//                                                                          
// Operation: Called from UI_OnDisconnected, or whenever the UI cannot
//            start or continue the connection process.
//
void DCINTERNAL CUI::UIGoDisconnected(unsigned disconnectID, BOOL fFireEvent)
{
    BOOL rc = FALSE;

    DC_BEGIN_FN("UIGoDisconnected");

    TRC_NRM((TB, _T("disconnectID %#x"), disconnectID));

    //
    // make sure that all timers are dead
    //
    if (_UI.connectStruct.hSingleConnectTimer) {
        _pUt->UTDeleteTimer(_UI.connectStruct.hSingleConnectTimer);
        _UI.connectStruct.hSingleConnectTimer = NULL;
    }
    if (_UI.connectStruct.hConnectionTimer) {
        _pUt->UTDeleteTimer(_UI.connectStruct.hConnectionTimer);
        _UI.connectStruct.hConnectionTimer = NULL;
    }
    if(_UI.connectStruct.hLicensingTimer) {
        _pUt->UTDeleteTimer(_UI.connectStruct.hLicensingTimer);
        _UI.connectStruct.hLicensingTimer = NULL;
    }


    UI_OnInputFocusLost(0);
    // Tell the Client extension dll of the disconnection
    _clx->CLX_OnDisconnected(disconnectID);

    //
    // Set watch flag so we can determine if the user tried to connect
    // from the event handler
    //
    _UI.fConnectCalledWatch = FALSE;

    //
    // Notify Ax control of the disconnection
    //
    if (fFireEvent && IsWindow(_UI.hWndCntrl)) {
        rc = SendMessage(_UI.hWndCntrl,
                         WM_TS_DISCONNECTED,
                         (WPARAM)disconnectID,
                         0);

        //
        // Bail out immediately AND avoid touching any instance
        // data as we may have been deleted in the event fired
        // to the outside world
        //
        if (!rc) {
            DC_QUIT;
        }
    }


    if (!UI_IsAutoReconnecting() && !_UI.fConnectCalledWatch) {
        TRC_NRM((TB,_T("Not autoreconnecting doing tail cleanup!")));

        UIFinishDisconnection();

#ifdef USE_BBAR
        if (_pBBar) {
            _pBBar->KillAndCleanupBBar();
        }
#endif
    }
    else {
        TRC_NRM((TB,_T("Skipping tail disconnect: arc: %d - conwatch: %d"),
                 UI_IsAutoReconnecting(),
                 _UI.fConnectCalledWatch));
    }

    //
    // Reset connect watch flag
    //
    _UI.fConnectCalledWatch = FALSE;

DC_EXIT_POINT:
    DC_END_FN();
} // UIGoDisconnected


//
// Name:      UIFinishDisconnection
//                                                                          
// Purpose:   Do final actions for disconnection and put up connection
//            dialog ready for next connection (or just exit if we
//            auto-connected or if we're on WinCE).
//
void DCINTERNAL CUI::UIFinishDisconnection()
{
    DC_BEGIN_FN("UIFinishDisconnection");

#ifndef OS_WINCE
    //
    // For WinCE, the connect dialog is not brought up again - we're about
    // to quit.
    //
    if (_UI.connectionStatus == UI_STATUS_CONNECTED)
    {
        TRC_NRM((TB, _T("Hiding main window and bringing up connection dialog")));
        // We do ShowWindow twice for the main window because the first
        // call can be ignored if the main window was maximized.
        ShowWindow(_UI.hwndContainer, SW_HIDE);
        ShowWindow(_UI.hwndMain, SW_HIDE);
        ShowWindow(_UI.hwndMain, SW_HIDE);
    }
#endif //OS_WINCE

    if(_pHostData &&
       _UI.connectionStatus != UI_STATUS_CONNECT_PENDING_DNS &&
       _UI.connectionStatus != UI_STATUS_CONNECT_PENDING)
    {
        //
        // We're done with the winsock buffer
        //
        LocalFree(_pHostData);
        _pHostData = NULL;
    }
    else if (_pHostData &&
             _UI.connectionStatus == UI_STATUS_CONNECT_PENDING_DNS) {
        if (!UIFreeAsyncDNSBuffer()) {
            TRC_ERR((TB,
                _T("Failed to free async dns buffer. Status: %d hghbn: 0x%x"),
                _UI.connectionStatus, _UI.hGHBN));
        }
    }


    TRC_NRM((TB, _T("Set disconnected state")));
    UISetConnectionStatus(UI_STATUS_DISCONNECTED);

    DC_END_FN();
} // UIFinishDisconnection

//
// IsConnectingToOwnAddress
// return true if this is an attempt to reconnect to our
// own address.
// e.g On PTS doing a loopback
//     or on server doing a loopback with /CONSOLE
//
BOOL CUI::IsConnectingToOwnAddress(u_long connectAddr)
{
    DC_BEGIN_FN("IsConnectingToOwnConsole");

    //
    // Check if this is a loopback connection attempt
    //

    //32-bit form of 127.0.0.1 addr
    #define LOOPBACK_ADDR ((u_long)0x0100007f)
    
    //
    // First the quick check for localhost/127.0.0.1
    //
    if( LOOPBACK_ADDR == connectAddr)
    {
        return TRUE;
    }

    //
    // More extensive check, i.e resolve the local hostname
    //

    char hostname[(512+1)*sizeof(TCHAR)];
    int err;
    int j;
    struct hostent* phostent;

    err=gethostname(hostname, sizeof(hostname));
    if (err == 0)
    {
        if ((phostent = gethostbyname(hostname)) !=NULL)
        {
            switch (phostent->h_addrtype)
            {
                case AF_INET:
                    j=0;
                    while (phostent->h_addr_list[j] != NULL)
                    {
                        if(!memcmp(&connectAddr,
                                   phostent->h_addr_list[j],
                                   sizeof(u_long)))
                        {
                            return TRUE;
                        }
                        j++;
                    }
                default:
                    break;
            }
        }
    }

    DC_END_FN();
    return FALSE;
}

BOOL CUI::IsRunningOnPTS()
{
    DC_BEGIN_FN("IsRunningOnPTS");

    #ifndef OS_WINCE
    if(UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_NT)
    {
        OSVERSIONINFOEX osVer;
        memset(&osVer, 0, sizeof(OSVERSIONINFOEX));
        osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
		if(GetVersionEx( (LPOSVERSIONINFO ) &osVer))
		{
            return ((osVer.wProductType == VER_NT_WORKSTATION)   &&
                    !(osVer.wSuiteMask & VER_SUITE_PERSONAL)  &&
                    (osVer.wSuiteMask & VER_SUITE_SINGLEUSERTS));
		}
        else
        {
            TRC_ERR((TB,_T("GetVersionEx failed: 0x%x"),
                           GetLastError()));
            return FALSE;
        }
    }
    else
    {
        //can't be PTS if its not NT
        return FALSE;
    }

    #else
    return FALSE;
    #endif
    
    DC_END_FN();
}


//
// Do the work of initializing or reinitializing
// the Input idle timers
//
BOOL CUI::InitInputIdleTimer(LONG minsToTimeout)
{
    DC_BEGIN_FN("InitInputIdleTimer");

    TRC_ASSERT(_UI.hwndMain,
               (TB,_T("InitInputIdleTimer called before main window is up")));
    if(minsToTimeout < MAX_MINS_TOIDLETIMEOUT)
    {
        //Reset the marker indicating if input was sent
        _pIh->IH_ResetInputWasSentFlag();

        //Reset any existing idle timer
        if(_UI.hIdleInputTimer)
        {
            HANDLE hTimer = _UI.hIdleInputTimer;
            _UI.hIdleInputTimer = NULL;
            _UI.minsToIdleTimeout = 0;
            if(!_pUt->UTDeleteTimer( hTimer ))
            {
                return FALSE;
            }
        }
        if(minsToTimeout)
        {
            _UI.hIdleInputTimer = _pUt->UTCreateTimer(
                                           _UI.hwndMain,
                                           UI_TIMER_IDLEINPUTTIMEOUT,
                                           minsToTimeout * 60 * 1000 );
            if(_UI.hIdleInputTimer)
            {
                if(_pUt->UTStartTimer( _UI.hIdleInputTimer ))
                {
                    _UI.minsToIdleTimeout =  minsToTimeout;
                    return TRUE;
                }
                else
                {
                    TRC_ERR((TB,_T("UTStartTimer hIdleInputTimer failed")));
                    _UI.minsToIdleTimeout = 0;
                    return FALSE;
                }
            }
            else
            {
                TRC_ERR((TB,_T("UTCreateTimer hIdleInputTimer failed")));
                _UI.minsToIdleTimeout = 0;
                return FALSE;
            }
        }
        else
        {
            //We've reset the timer and no new one
            //was requested
            return TRUE;
        }
    }
    else
    {
        return FALSE;
    }


    DC_END_FN();
}

#ifdef USE_BBAR
//
// Set or update the bbar unhide timer
// based on the last mouse move
//
// Params:
//  x - mouse x pos
//  y - mouse y pos
//
VOID CUI::UISetBBarUnhideTimer(LONG x, LONG y)
{
    DC_BEGIN_FN("IHSetBBarUnhideTimer");

    TRC_ASSERT(_UI.hwndMain,
               (TB,_T("hwndMain is NULL")));

    if (_UI.fBBarEnabled && _pBBar && _pBBar->IsRaised())
    {
        LONG dx = x-_ptBBarLastMousePos.x;
        LONG dy = y-_ptBBarLastMousePos.y;
        LONG rr = dx*dx + dy*dy;
        LONG dd = GetSystemMetrics(SM_CXDOUBLECLK) *
                  GetSystemMetrics(SM_CYDOUBLECLK);

        if (rr > dd) 
        {
            _fBBarUnhideTimerActive = TRUE;
            SetTimer(_UI.hwndMain,
                     UI_TIMER_BBAR_UNHIDE_TIMERID,
                     IH_BBAR_UNHIDE_TIMEINTERVAL,
                     NULL);
            _ptBBarLastMousePos.x = x;
            _ptBBarLastMousePos.y = y;
        }
    }
    else
    {
        if(_fBBarUnhideTimerActive)
        {
            KillTimer( _UI.hwndMain,
                       UI_TIMER_BBAR_UNHIDE_TIMERID );
            _fBBarUnhideTimerActive = FALSE;
        }
    }

    DC_END_FN();
}
#endif //USE_BBAR


#ifndef OS_WINCE


// TS detection code from MSDN and modified.
/* -------------------------------------------------------------
   Note that the ValidateProductSuite and IsTerminalServices
   functions use ANSI versions of Win32 functions to maintain
   compatibility with Windows 95/98.
   ------------------------------------------------------------- */
/****************************************************************************/
/* Name:      UIIsTSOnWin2KOrGreater                                        */
/*                                                                          */
/* Purpose:   This function is called when we know that TS can be enabled   */
/*            but we need to see if TS is really enabled.                   */
/*            It means:                                                     */
/*            - not Win2K or above, then it's TS4                           */
/*            - Win2K or above: test if TS is installed                     */
/****************************************************************************/
BOOL CUI::UIIsTSOnWin2KOrGreater( VOID ) 
{
  BOOL    bResult = FALSE;
  DWORD   dwVersion;
  OSVERSIONINFOEXA osVersion;
  DWORDLONG dwlCondition = 0;
  HMODULE hmodK32 = NULL;
  HMODULE hmodNtDll = NULL;
  typedef ULONGLONG (WINAPI *PFnVerSetCondition) (ULONGLONG, ULONG, UCHAR);
  typedef BOOL (WINAPI *PFnVerifyVersionA) (POSVERSIONINFOEXA, DWORD, DWORDLONG);
  PFnVerSetCondition pfnVerSetCondition;
  PFnVerifyVersionA pfnVerifyVersionA;

  dwVersion = GetVersion();

  // Are we running Windows NT?

  if (!(dwVersion & 0x80000000)) 
  {
    // Is it Windows 2000 or greater?
    
    if (LOBYTE(LOWORD(dwVersion)) > 4) 
    {
      // In Windows 2000, use the VerifyVersionInfo and 
      // VerSetConditionMask functions. Don't static link because 
      // it won't load on earlier systems.

      hmodNtDll = GetModuleHandleA( "ntdll.dll" );
      if (hmodNtDll) 
      {
        pfnVerSetCondition = (PFnVerSetCondition) GetProcAddress( 
            hmodNtDll, "VerSetConditionMask");
        if (pfnVerSetCondition != NULL) 
        {
          dwlCondition = (*pfnVerSetCondition) (dwlCondition, 
              VER_SUITENAME, VER_OR);

          // Get a VerifyVersionInfo pointer.

          hmodK32 = GetModuleHandleA( "KERNEL32.DLL" );
          if (hmodK32 != NULL) 
          {
            pfnVerifyVersionA = (PFnVerifyVersionA) GetProcAddress(
               hmodK32, "VerifyVersionInfoA") ;
            if (pfnVerifyVersionA != NULL) 
            {
              ZeroMemory(&osVersion, sizeof(osVersion));
              osVersion.dwOSVersionInfoSize = sizeof(osVersion);
              osVersion.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;
              bResult = (*pfnVerifyVersionA) (&osVersion,
                  VER_SUITENAME, dwlCondition);
            }
          }
        }
      }
    }
    else  // This is Windows NT 4.0 or earlier.
      // since we know that TS can be enabled, then it's TS4.
      bResult = TRUE;
  }

  return bResult;
}
#endif //OS_WINCE

#ifdef SMART_SIZING
//
// Notify the IH and OP of the desktop size change
// Params:
//  size - lParam encoded size (LOWORD - width, HIWORD height)
//
void CUI::UI_NotifyOfDesktopSizeChange(LPARAM size)
{
    DC_BEGIN_FN("UI_NotifyOfDesktopSizeChange");

    //
    // NOTE: Can only use async notifications from the UI thread
    //       otherwise the following can happen: SendMessage to
    //       another thread dispatches messages, this means that
    //       the containing app could receive a message to destroy
    //       the control (e.g Salem tests do this). Destroying
    //       the control while in a CD call is not a good thing.
    //       As we would blow up on return.
    //
    _pCd->CD_DecoupleSimpleNotification(CD_RCV_COMPONENT,
            _pOp,
            CD_NOTIFICATION_FUNC(COP,OP_MainWindowSizeChange),
            (ULONG_PTR)size);
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT,
            _pIh,
            CD_NOTIFICATION_FUNC(CIH,IH_MainWindowSizeChange),
            (ULONG_PTR)size);

    DC_END_FN();
}
#endif //SMART_SIZING

//
// Free the ASYNC DNS buffer.
// If there is a pending async operation it is canceled first
//
// Returns: TRUE if the buffer was freed (or was already freed)
//
BOOL CUI::UIFreeAsyncDNSBuffer()
{
    BOOL fFreeHostData = FALSE;
    int intRC;
    DC_BEGIN_FN("UIFreeAsyncDNSBuffer");

    if (_UI.hGHBN) {
        //
        // Cancel the DNS lookup
        //
        TRC_NRM((TB, _T("Cancel DNS lookup")));
        intRC = WSACancelAsyncRequest(_UI.hGHBN);

        if (intRC == SOCKET_ERROR) {
            TRC_NRM((TB, _T("Failed to cancel async DNS request")));

            //
            // Can't free the buffer here, because it may still be
            // in use, or the request may have already completed
            // and the completion message may still be in transit
            // in which case the buffer will be freed when we receive
            // the message.
            //
        } else {
            fFreeHostData = TRUE;
        }
    }
    else {
        fFreeHostData = TRUE;
    }

    if (fFreeHostData) {
        //Succesfully canceled the request
        //Free the buffer passed to winsock
        if(_pHostData)
        {
            LocalFree(_pHostData);
            _pHostData = NULL;
        }
    }

    DC_END_FN();
    return fFreeHostData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\uhint.cpp ===
/****************************************************************************/
// uhint.cpp
//
// Update Handler internal functions
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <adcg.h>
#include <tsgdiplusenums.h>

extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "uhint"
#include <atrcapi.h>
}
#define TSC_HR_FILEID TRC_HR_UINT_CPP

#include "autil.h"
#include "uh.h"
#include "op.h"
#include "wui.h"
#include "od.h"
#include "cc.h"
#include "aco.h"
#include "ih.h"
#include "gh.h"
#include "cd.h"
#include <abdapi.h>

#include "clx.h"
#include "objs.h"
#if 0
#include "drawstream.h"
#endif

extern "C" {
#ifdef OS_WINCE
#ifdef DC_DEBUG
#include <eosint.h>
#endif
#ifdef HDCL1171PARTIAL
BOOL VirtualCopy(LPVOID, LPVOID, DWORD, DWORD);
#endif // HDCL1171PARTIAL
#endif // OS_WINCE

#define DC_INCLUDE_DATA
#include <acpudata.h>
#undef DC_INCLUDE_DATA

#ifndef OS_WINCE
#include <direct.h>
#include <io.h>
#endif
}

/****************************************************************************/
/* Win16 does not support DibSections.                                      */
/* WinCE supports them, but the current data says the OPAQUERECT order and  */
/* the SCRBLT order times are severely impacted by USEDIBSECTION            */
/****************************************************************************/
#ifdef OS_WINNT
#define USE_DIBSECTION
#endif /* OS_WINNT */

/****************************************************************************/
/* uhWindowsROPs                                                            */
/*                                                                          */
/* A table of Windows ROPs used to generate a 32-bit Windows ROP from the   */
/* 0x00-0xFF range of ROPs sent in the protocol.                            */
/*                                                                          */
/* All of the values in the table are 16-bit.  The 32-bit ROP is generated  */
/* by putting the ROP index into the high 16-bits of the 32-bit value. See  */
/* UHConvertToWindowsROP for the code.                                      */
/****************************************************************************/
const UINT16 uhWindowsROPs[256] =
{
    0x0042, 0x0289, 0x0C89, 0x00AA,
    0x0C88, 0x00A9, 0x0865, 0x02C5,
    0x0F08, 0x0245, 0x0329, 0x0B2A,
    0x0324, 0x0B25, 0x08A5, 0x0001,
    0x0C85, 0x00A6, 0x0868, 0x02C8,
    0x0869, 0x02C9, 0x5CCA, 0x1D54,
    0x0D59, 0x1CC8, 0x06C5, 0x0768,
    0x06CA, 0x0766, 0x01A5, 0x0385,
    0x0F09, 0x0248, 0x0326, 0x0B24,
    0x0D55, 0x1CC5, 0x06C8, 0x1868,
    0x0369, 0x16CA, 0x0CC9, 0x1D58,
    0x0784, 0x060A, 0x064A, 0x0E2A,
    0x032A, 0x0B28, 0x0688, 0x0008,
    0x06C4, 0x1864, 0x01A8, 0x0388,
    0x078A, 0x0604, 0x0644, 0x0E24,
    0x004A, 0x18A4, 0x1B24, 0x00EA,
    0x0F0A, 0x0249, 0x0D5D, 0x1CC4,
    0x0328, 0x0B29, 0x06C6, 0x076A,
    0x0368, 0x16C5, 0x0789, 0x0605,
    0x0CC8, 0x1954, 0x0645, 0x0E25,
    0x0325, 0x0B26, 0x06C9, 0x0764,
    0x08A9, 0x0009, 0x01A9, 0x0389,
    0x0785, 0x0609, 0x0049, 0x18A9,
    0x0649, 0x0E29, 0x1B29, 0x00E9,
    0x0365, 0x16C6, 0x0786, 0x0608,
    0x0788, 0x0606, 0x0046, 0x18A8,
    0x58A6, 0x0145, 0x01E9, 0x178A,
    0x01E8, 0x1785, 0x1E28, 0x0C65,
    0x0CC5, 0x1D5C, 0x0648, 0x0E28,
    0x0646, 0x0E26, 0x1B28, 0x00E6,
    0x01E5, 0x1786, 0x1E29, 0x0C68,
    0x1E24, 0x0C69, 0x0955, 0x03C9,
    0x03E9, 0x0975, 0x0C49, 0x1E04,
    0x0C48, 0x1E05, 0x17A6, 0x01C5,
    0x00C6, 0x1B08, 0x0E06, 0x0666,
    0x0E08, 0x0668, 0x1D7C, 0x0CE5,
    0x0C45, 0x1E08, 0x17A9, 0x01C4,
    0x17AA, 0x01C9, 0x0169, 0x588A,
    0x1888, 0x0066, 0x0709, 0x07A8,
    0x0704, 0x07A6, 0x16E6, 0x0345,
    0x00C9, 0x1B05, 0x0E09, 0x0669,
    0x1885, 0x0065, 0x0706, 0x07A5,
    0x03A9, 0x0189, 0x0029, 0x0889,
    0x0744, 0x06E9, 0x0B06, 0x0229,
    0x0E05, 0x0665, 0x1974, 0x0CE8,
    0x070A, 0x07A9, 0x16E9, 0x0348,
    0x074A, 0x06E6, 0x0B09, 0x0226,
    0x1CE4, 0x0D7D, 0x0269, 0x08C9,
    0x00CA, 0x1B04, 0x1884, 0x006A,
    0x0E04, 0x0664, 0x0708, 0x07AA,
    0x03A8, 0x0184, 0x0749, 0x06E4,
    0x0020, 0x0888, 0x0B08, 0x0224,
    0x0E0A, 0x066A, 0x0705, 0x07A4,
    0x1D78, 0x0CE9, 0x16EA, 0x0349,
    0x0745, 0x06E8, 0x1CE9, 0x0D75,
    0x0B04, 0x0228, 0x0268, 0x08C8,
    0x03A5, 0x0185, 0x0746, 0x06EA,
    0x0748, 0x06E5, 0x1CE8, 0x0D79,
    0x1D74, 0x5CE6, 0x02E9, 0x0849,
    0x02E8, 0x0848, 0x0086, 0x0A08,
    0x0021, 0x0885, 0x0B05, 0x022A,
    0x0B0A, 0x0225, 0x0265, 0x08C5,
    0x02E5, 0x0845, 0x0089, 0x0A09,
    0x008A, 0x0A0A, 0x02A9, 0x0062
};

#define BMP_SIZE(bmih) \
    ((ULONG)((bmih).biHeight *(((bmih).biBitCount * (bmih).biWidth + 31) & ~31) >> 3))

/****************************************************************************/
/* Name:      UHAddUpdateRegion                                             */
/*                                                                          */
/* Purpose:   Adds the bounds of a given order to the supplied update       */
/*            region.                                                       */
/****************************************************************************/
inline void DCINTERNAL CUH::UHAddUpdateRegion(
        PUH_ORDER pOrder,
        HRGN      hrgnUpdate)
{
    RECT rect;

    DC_BEGIN_FN("UHAddUpdateRegion");

    TIMERSTART;

    if (pOrder->dstRect.left <= pOrder->dstRect.right &&
            pOrder->dstRect.top <= pOrder->dstRect.bottom) {
        // Windows wants exclusive coordinates.
        SetRectRgn(_UH.hrgnUpdateRect, pOrder->dstRect.left,
                pOrder->dstRect.top, pOrder->dstRect.right + 1,
                pOrder->dstRect.bottom + 1);

#ifdef SMART_SIZING
        //only update smartsizing region when UI_Smart_Sizing is enabled
        if (_pUi->UI_GetSmartSizing()) {
            _pOp->OP_AddUpdateRegion(pOrder->dstRect.left,
                pOrder->dstRect.top, pOrder->dstRect.right + 1,
                pOrder->dstRect.bottom + 1);
        }
#endif // SMART_SIZING

        // Combine the rectangle region with the update region.
        if (!UnionRgn(hrgnUpdate, hrgnUpdate, _UH.hrgnUpdateRect)) {
            // The region union failed so we must simplify the region. This
            // means that we may paint areas which we have not received an
            // updates for - but this is better than not painting areas which
            // we have received updates for.
            TRC_ALT((TB, _T("UnionRgn failed")));
            GetRgnBox(hrgnUpdate, &rect);
            SetRectRgn(hrgnUpdate, rect.left, rect.top, rect.right + 1,
                    rect.bottom + 1);

            if (!UnionRgn(hrgnUpdate, hrgnUpdate, _UH.hrgnUpdateRect))
            {
                TRC_ERR((TB, _T("UnionRgn failed after simplification")));
            }
        }
    }
    else {
        // NULL rectangle - do not add to update region.
        TRC_NRM(( TB, _T("NULL rect: %d,%d %d,%d"),
                (int)pOrder->dstRect.left,
                (int)pOrder->dstRect.top,
                (int)pOrder->dstRect.right,
                (int)pOrder->dstRect.bottom));
    }

    TIMERSTOP;
    UPDATECOUNTER(FC_UHADDUPDATEREGION);
    DC_END_FN();
}


/****************************************************************************/
/* Name:      UHSetClipRegion                                               */
/*                                                                          */
/* Purpose:   Sets the clip retangle in the current output DC.              */
/****************************************************************************/
void DCINTERNAL CUH::UH_SetClipRegion(int left, int top, int right, int bottom)
{
    POINT points[2];
    HRGN  hrgnRect;
    HDC   hdc;

    DC_BEGIN_FN("UHSetClipRegion");

    TIMERSTART;
#if defined (OS_WINCE)
    if ((_UH.validClipDC != _UH.hdcDraw) ||
            (_UH.rectReset)            ||
            (left   != _UH.lastLeft)   ||
            (top    != _UH.lastTop)    ||
            (right  != _UH.lastRight)  ||
            (bottom != _UH.lastBottom))
#endif
    {
        /********************************************************************/
        /* The region clip rectangle has changed, so we change the region   */
        /* in the screen bitmap DC.                                         */
        /********************************************************************/
        points[0].x = left;
        points[0].y = top;
        points[1].x = right;
        points[1].y = bottom;

        /********************************************************************/
        /* Windows requires that the coordinates are in Device space for    */
        /* its SelectClipRgn call.                                          */
        /********************************************************************/
        hdc = _UH.hdcDraw;

#if !defined(OS_WINCE) || defined(OS_WINCE_LPTODP)
        LPtoDP(hdc, points, 2);
#endif // !defined(OS_WINCE) || defined(OS_WINCE_LPTODP)

        if ((left > right) || (top > bottom))
        {
            /****************************************************************/
            /* We get this for SaveScreenBitmap orders.                     */
            /****************************************************************/
            TRC_NRM((TB, _T("Null bounds: %d,%d %d,%d"),
                    left, top, right, bottom));
            hrgnRect = CreateRectRgn(0, 0, 0, 0);
        }
        else
        {
            hrgnRect = CreateRectRgn( points[0].x,
                                      points[0].y,
                                      points[1].x + 1,
                                      points[1].y + 1 );

        }
        SelectClipRgn(hdc, hrgnRect);

        _UH.lastLeft   = left;
        _UH.lastTop    = top;
        _UH.lastRight  = right;
        _UH.lastBottom = bottom;

        _UH.rectReset = FALSE;

#if defined (OS_WINCE)
        _UH.validClipDC = _UH.hdcDraw;
#endif

        if (hrgnRect != NULL)
            DeleteRgn(hrgnRect);
    }

    TIMERSTOP;
    UPDATECOUNTER(FC_UHSETCLIPREGION);

    DC_END_FN();
}


/****************************************************************************/
// UH_ProcessBitmapPDU
//
// Unpacks a BitmapPDU.
/****************************************************************************/
HRESULT DCAPI CUH::UH_ProcessBitmapPDU(
        TS_UPDATE_BITMAP_PDU_DATA UNALIGNED FAR *pBitmapPDU,
        DCUINT dataLength)
{
    HRESULT hr = S_OK;
    unsigned i;
    PBYTE ptr;
    PBYTE pdataEnd = (PBYTE)pBitmapPDU + dataLength;
    unsigned numRects;
    TS_BITMAP_DATA UNALIGNED FAR *pRectangle;

    DC_BEGIN_FN("UH_ProcessBitmapPDU");

    /************************************************************************/
    /* Extract the number of rectangles.                                    */
    /************************************************************************/
    numRects = (unsigned)pBitmapPDU->numberRectangles;
    TRC_NRM((TB, _T("%u rectangles to draw"), numRects));
    TRC_ASSERT((numRects > 0), (TB, _T("Invalid rectangle count in BitmapPDU")));

    ptr = (PBYTE)(&(pBitmapPDU->rectangle[0]));
    for (i = 0; i < numRects; i++) {
        TRC_DBG((TB, _T("Process rectangle %u"), i));

        // Draw the rectangle.
        pRectangle = (TS_BITMAP_DATA UNALIGNED FAR *)ptr;

        // SECURITY: 552403
        CHECK_READ_N_BYTES(ptr, pdataEnd, sizeof(TS_BITMAP_DATA), hr,
            ( TB, _T("Bad BitmapPDU length")));
        CHECK_READ_N_BYTES(ptr, pdataEnd,  
            FIELDOFFSET(TS_BITMAP_DATA,bitmapData)+pRectangle->bitmapLength, 
            hr, ( TB, _T("Bad BitmapPDU length")));
        
        hr = UHProcessBitmapRect(pRectangle);
        DC_QUIT_ON_FAIL(hr);

        TRC_DBG((TB, _T("bitmap rect: %d %d %d %d"),
                pRectangle->destLeft, pRectangle->destTop,
                pRectangle->destRight, pRectangle->destBottom));

        // Move on to next rectangle.
        ptr += FIELDOFFSET(TS_BITMAP_DATA, bitmapData[0]) +
                pRectangle->bitmapLength;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
/* Name:      UHProcessBitmapRect                                           */
/*                                                                          */
/* Purpose:   Draw a single BitmapPDU rectangle                             */
/*                                                                          */
/* Params:    In       pRectangle                                           */
/*                                                                          */
/* Operation: Decompresses the Bitmap PDU (if compressed), then store       */
/*            the data in the Shadow Bitmap (if present) and display        */
/*            the relevant area in the Output Window.                       */
/****************************************************************************/
// SECURITY: Caller must validate that enough data is passed for pRectangle
//  and pRectangle->bitmapLength
HRESULT DCINTERNAL CUH::UHProcessBitmapRect(
        TS_BITMAP_DATA UNALIGNED FAR *pRectangle)
{
    HRESULT hr = S_OK;
    DCSIZE bltSize;
    HDC hdcDrawOld;

#ifndef OS_WINCE
    PBYTE pBitmapBits;
    ULONG ulBitmapBitsLen = 0;
#else // OS_WINCE
    VOID *pv;
    HBITMAP         hbm = NULL;
    HBITMAP         hbmOld;
    HDC             hdcMem;
    HPALETTE        hpalOld = NULL;
    INT                 nDibBitsLen = 0;
#endif // OS_WINCE

#ifdef DC_PERF
    UTPERFCOUNTER   counter1;
    UTPERFCOUNTER   counter2;
#endif
 
    DC_BEGIN_FN("UHProcessBitmapRect");

    TIMERSTART;
    
    // For screen bitmap rect, we either bitblt to the desktop HDC or the shadow 
    // bitmap HDC, so we need to set the hdcDraw to either shadow bitmap or
    // screen desktop.  With offscreen, the switch surface PDUs are not sent
    // in sync with the screen bitmap rect pdus, so the current hdcDraw may not
    // point to shadow bitmap or screen desktop as required by this function.
    // What we can do is to save the current hdcDraw and then set it to shadow
    // bitmap or screen desktop.  Then restore the hdcDraw to the current value
    // at the end of this function.

    // Save the current hdcDraw
    hdcDrawOld = _UH.hdcDraw;

    TRC_DBG((TB, _T("bitmapLength %#x"), pRectangle->bitmapLength));

    IH_CheckForInput("before decompressing bitmap");
    
    // Set hdcDraw to shadow bitmap or screen desktop appropriately
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
    if (!_UH.DontUseShadowBitmap && _UH.hdcShadowBitmap) {
#else 
    if (_UH.hdcShadowBitmap) {
#endif
        _UH.hdcDraw = _UH.hdcShadowBitmap;
    }
    else {
        _UH.hdcDraw = _UH.hdcOutputWindow;
    }

    // It is possible for us to have failed allocation in UH_Init(), try
    // again here if need be.
    // It requires a misprediction on every PDU. Can we
    // fail init if we don't alloc in UH_Init()?
    if (_UH.bitmapDecompressionBuffer == NULL) {
        _UH.bitmapDecompressionBufferSize = max(UH_DECOMPRESSION_BUFFER_LENGTH,
                UH_CellSizeFromCacheID(_UH.NumBitmapCaches));
        _UH.bitmapDecompressionBuffer = (BYTE FAR*)UT_Malloc( _pUt,
                _UH.bitmapDecompressionBufferSize );
        if (_UH.bitmapDecompressionBuffer == NULL) {
            TRC_ERR((TB,_T("Failing to display BitmapPDU - no decomp buffer")));
            _UH.bitmapDecompressionBufferSize = 0;
            DC_QUIT;
        }
    }

#ifndef OS_WINCE
    if (pRectangle->compressedFlag)
    {
        TRC_ASSERT(((pRectangle->width * pRectangle->height) <=
                UH_DECOMPRESSION_BUFFER_LENGTH),(TB,_T("Bitmap PDU decompressed ")
                _T("size too large for internal buffer")));

#ifdef DC_PERF
        _pUi->UI_QueryPerformanceCounter(&counter1);
#endif

#ifdef DC_HICOLOR
        hr = BD_DecompressBitmap( &(pRectangle->bitmapData[0]),
                             _UH.bitmapDecompressionBuffer,
                             pRectangle->bitmapLength,
                             _UH.bitmapDecompressionBufferSize,
                             pRectangle->compressedFlag & TS_EXTRA_NO_BITMAP_COMPRESSION_HDR,
                             (DCUINT8)pRectangle->bitsPerPixel,
                             pRectangle->width,
                             pRectangle->height);
#else
        hr = BD_DecompressBitmap( &(pRectangle->bitmapData[0]),
                _UH.bitmapDecompressionBuffer, pRectangle->bitmapLength,
                _UH.bitmapDecompressionBufferSize,
                pRectangle->compressedFlag & TS_EXTRA_NO_BITMAP_COMPRESSION_HDR,
                (DCUINT8)pRectangle->bitsPerPixel, pRectangle->width,
                pRectangle->height);
#endif
        DC_QUIT_ON_FAIL(hr);

        /********************************************************************/
        /* Schedule IH to allow input processing when a lot of drawing is   */
        /* being processed.                                                 */
        /********************************************************************/
        IH_CheckForInput("after decompressing bitmap");

#ifdef DC_PERF
        _pUi->UI_QueryPerformanceCounter(&counter2);
        TRC_NRM((TB, _T("Decompress: %u"),
                           _pUi->UI_PerformanceCounterDiff(&counter1, &counter2) ));
#endif

        // Note that ulBitmapBitsLen may be the maxiumum amount of the data in 
        // the decompression buffer and not how many bits have actually been 
        // written into that buffer.
        pBitmapBits = _UH.bitmapDecompressionBuffer;
        ulBitmapBitsLen = _UH.bitmapDecompressionBufferSize;
        TRC_DBG((TB, _T("Decompressed bitmap PDU")));
    }
    else
    {
        pBitmapBits = &(pRectangle->bitmapData[0]);
        ulBitmapBitsLen = pRectangle->bitmapLength;
    }

#else // OS_WINCE
    /************************************************************************/
    /* Windows CE does not support StretchDIBits.  Copy the bitmap data     */
    /* into a DIB Section and BitBlt to the target.                         */
    /************************************************************************/
    hdcMem = _UH.hdcMemCached;
    if (hdcMem == NULL)
    {
        TRC_ERR((TB, _T("No memory hdc")));
    }
    else
    {
#ifdef DC_HICOLOR
        if (_UH.protocolBpp <= 8)
        {
#endif
            hpalOld = SelectPalette( hdcMem,
                           _UH.hpalCurrent,
                           FALSE );
#ifdef DC_HICOLOR
        }
#endif

        _UH.bitmapInfo.hdr.biWidth = pRectangle->width;
        _UH.bitmapInfo.hdr.biHeight = pRectangle->height;

        hbm = CreateDIBSection(hdcMem,
                               (BITMAPINFO *)&_UH.bitmapInfo.hdr,
#ifdef DC_HICOLOR
                               _UH.DIBFormat,
#else
                               DIB_PAL_COLORS,
#endif
                               &pv,
                               NULL,
                               0);
        if (hbm == NULL)
        {
            TRC_ERR((TB, _T("Unable to CreateDIBSection")));
        }
        else
        {
            if (pRectangle->compressedFlag)
            {
                nDibBitsLen = (((_UH.bitmapInfo.hdr.biBitCount *
                    _UH.bitmapInfo.hdr.biWidth + 31) & ~31) >> 3) * 
                    _UH.bitmapInfo.hdr.biHeight;
#ifdef DC_HICOLOR
                hr = BD_DecompressBitmap( &(pRectangle->bitmapData[0]),
                                     (PDCUINT8)pv,
                                     pRectangle->bitmapLength,
                                     nDibBitsLen,
                                     pRectangle->compressedFlag &
                                     TS_EXTRA_NO_BITMAP_COMPRESSION_HDR,
                                     (DCUINT8)pRectangle->bitsPerPixel,
                                     pRectangle->width,
                                     pRectangle->height);
#else
                hr = BD_DecompressBitmap( &(pRectangle->bitmapData[0]),
                                     pv,
                                     pRectangle->bitmapLength,
                                     nDibBitsLen,
                                     pRectangle->compressedFlag &
                                     TS_EXTRA_NO_BITMAP_COMPRESSION_HDR,
                                     (DCUINT8)pRectangle->bitsPerPixel,
                                     pRectangle->width,
                                     pRectangle->height );
#endif
                DC_QUIT_ON_FAIL(hr);
            }
            else
            {
                DC_MEMCPY(pv, &(pRectangle->bitmapData[0]),
                        pRectangle->bitmapLength);
            }
        }
    }
#endif // OS_WINCE

    _UH.bitmapInfo.hdr.biWidth = pRectangle->width;
    _UH.bitmapInfo.hdr.biHeight = pRectangle->height;
    TRC_NRM((TB, _T("bitmap width %ld, height %ld"), _UH.bitmapInfo.hdr.biWidth,
                                                 _UH.bitmapInfo.hdr.biHeight));

    /************************************************************************/
    /* The rectangle in the PDU is in INCLUSIVE coordinates, so we must     */
    /* add 1 to get the width and height correct.                           */
    /************************************************************************/
    bltSize.width = (pRectangle->destRight - pRectangle->destLeft) + 1;
    bltSize.height = (pRectangle->destBottom - pRectangle->destTop) + 1;

    /************************************************************************/
    /* Ensure that the clip region is reset (clipping is neither required   */
    /* nor desired).                                                        */
    /************************************************************************/
    UH_ResetClipRegion();

#ifdef DC_PERF
    _pUi->UI_QueryPerformanceCounter(&counter1);
#endif
#ifndef OS_WINCE

#ifdef USE_DIBSECTION
    // We can only use UHDIBCopyBits if this is a simple copy and the shadow
    // bitmap is enabled - ie we're drawing to it.
#ifdef USE_GDIPLUS
    if ((_UH.usingDIBSection) && (_UH.hdcDraw == _UH.hdcShadowBitmap) &&
            (_UH.shadowBitmapBpp == _UH.protocolBpp))
#else // USE_GDIPLUS
    if ((_UH.usingDIBSection) && (_UH.hdcDraw == _UH.hdcShadowBitmap))
#endif // USE_GDIPLUS
    {

        // Verify that the height, width, and bitcount are valid for a bitmap that
        // first into the decompression buffer.  Note that ulBitmapBitsLen may be
        // the maxiumum amount of the data in the decompression buffer and not 
        // how many bits have actually been written into that buffer.  Thus, while
        // we will not read off the end of a buffer, we may read uninitialized
        // bitmap data from the buffer.
        if (!UHDIBCopyBits(_UH.hdcDraw, pRectangle->destLeft,
                pRectangle->destTop, bltSize.width, bltSize.height, 0, 0,
                pBitmapBits, ulBitmapBitsLen, (BITMAPINFO *)&(_UH.bitmapInfo.hdr),
                _UH.bitmapInfo.bIdentityPalette))
        {
            TRC_ERR((TB, _T("UHDIBCopyBits failed")));
        }
    }
    else
#endif /* USE_DIBSECTION */
    /*if (StretchDIBits( _UH.hdcDraw,
                       pRectangle->destLeft,
                       pRectangle->destTop,
                       bltSize.width,
                       bltSize.height,
                       0,
                       0,
                       bltSize.width,
                       bltSize.height,
                       pBitmapBits,
                       (BITMAPINFO *)&(_UH.bitmapInfo.hdr),
#ifdef DC_HICOLOR
                       _UH.DIBFormat,
#else
                       DIB_PAL_COLORS,  
#endif
                       SRCCOPY ) == 0)   */

    if (SetDIBitsToDevice( _UH.hdcDraw,
                           pRectangle->destLeft,
                           pRectangle->destTop,
                           bltSize.width,
                           bltSize.height,
                           0,
                           0,
                           0,
                           bltSize.height,
                           pBitmapBits,
                           (BITMAPINFO *)&(_UH.bitmapInfo.hdr),
#ifdef DC_HICOLOR
                           _UH.DIBFormat) == 0)
#else
                           DIB_PAL_COLORS) == 0)
#endif
    {
        TRC_ERR((TB, _T("StretchDIBits failed")));
    }
#else
    if ((hdcMem != NULL) && (hbm != NULL))
    {
        hbmOld = (HBITMAP)SelectObject(hdcMem, hbm);
        if (!BitBlt(_UH.hdcDraw,
                    pRectangle->destLeft,
                    pRectangle->destTop,
                    bltSize.width,
                    bltSize.height,
                    hdcMem,
                    0,
                    0,
                    SRCCOPY))
        {
            TRC_ERR((TB, _T("BitBlt failed")));
        }
        SelectBitmap(hdcMem, hbmOld);

#ifdef DC_HICOLOR
        if(_UH.protocolBpp <= 8)
        {
#endif

        SelectPalette( hdcMem,
                       hpalOld,
                       FALSE );

#ifdef DC_HICOLOR
        }
#endif
        
        DeleteObject(hbm);
    }
#endif // OS_WINCE

#ifdef DC_PERF
    _pUi->UI_QueryPerformanceCounter(&counter2);
    TRC_NRM((TB, _T("StretchDIBits: %u"),
                           _pUi->UI_PerformanceCounterDiff(&counter1, &counter2) ));
#endif

#ifdef DC_DEBUG
    // Draw hatching over the bitmap data if the option is enabled.
    if (_UH.hatchBitmapPDUData)
    {
        UH_HatchRect( pRectangle->destLeft,
                     pRectangle->destTop,
                     pRectangle->destLeft + bltSize.width,
                     pRectangle->destTop + bltSize.height,
                     UH_RGB_RED,
                     UH_BRUSHTYPE_FDIAGONAL);
    }
#endif /* DC_DEBUG */

    /************************************************************************/
    /* If the destination for the drawing we just did was not the output    */
    /* window, ie the shadow bitmap is enabled, then copy the output to the */
    /* output window (screen) now.                                          */
    /************************************************************************/
    if (_UH.hdcDraw == _UH.hdcShadowBitmap) 
    {
        RECT    rect;

        rect.left   = pRectangle->destLeft;
        rect.top    = pRectangle->destTop;
        rect.right  = rect.left + bltSize.width;
        rect.bottom = rect.top + bltSize.height;

        IH_CheckForInput("before updating screen");

        // Ensure that there is no clip region.
        SelectClipRgn(_UH.hdcOutputWindow, NULL);

#ifdef SMART_SIZING
        if (!_pOp->OP_CopyShadowToDC(_UH.hdcOutputWindow, pRectangle->destLeft, 
                pRectangle->destTop, bltSize.width, bltSize.height)) {
            TRC_ERR((TB, _T("OP_CopyShadowToDC failed")));
        }
#else // SMART_SIZING
        if (!BitBlt( _UH.hdcOutputWindow,
                     pRectangle->destLeft,
                     pRectangle->destTop,
                     bltSize.width,
                     bltSize.height,
                     _UH.hdcShadowBitmap,
                     pRectangle->destLeft,
                     pRectangle->destTop,
                     SRCCOPY ))
        {
            TRC_ERR((TB, _T("BitBlt failed")));
        }
#endif // SMART_SIZING
        TRC_DBG((TB, _T("Shadow bitmap updated at %d, %d for %u, %u"),
                                                        pRectangle->destLeft,
                                                        pRectangle->destTop,
                                                        bltSize.width,
                                                        bltSize.height));

#ifdef DC_LATENCY
        if ((rect.right - rect.left) > 5)
        {
            /****************************************************************/
            /* If this is a reasonably large piece of screen-data then      */
            /* increment the fake keypress count.                           */
            /****************************************************************/
            TRC_DBG((TB, _T("L:%u R:%u T:%u B:%u"),
                     rect.left,
                     rect.right,
                     rect.top,
                     rect.bottom));
            TRC_NRM((TB, _T("Inc fake keypress count")));

            _UH.fakeKeypressCount++;
        }
#endif /* DC_LATENCY */
    }
    
DC_EXIT_POINT:
    // Restore the current hdcDraw to what it had at the beginning of the function
    _UH.hdcDraw = hdcDrawOld;

    TIMERSTOP;
    UPDATECOUNTER(FC_MEM2SCRN_BITBLT);
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// UH_ProcessOrders
//
// Processes a received set of orders.
/****************************************************************************/
HRESULT DCAPI CUH::UH_ProcessOrders(unsigned NumOrders, BYTE FAR *pOrders,
    DCUINT dataLen)
{
    HRESULT hr = S_OK;
    unsigned i;
    unsigned ordersDrawn;
    PUH_ORDER pOrder;
    BYTE FAR *pEncodedOrder;
    DCSIZE desktopSize;
    TS_ORDER_HEADER UNALIGNED FAR *pOrderHeader;
    unsigned OrderType;
    unsigned orderSize;
    BYTE FAR *pEnd = pOrders + dataLen;

    DC_BEGIN_FN("UH_ProcessOrders");
    desktopSize.width = desktopSize.height = 0;

    pEncodedOrder = pOrders;

    TRC_DBG((TB, _T("Begin replaying %u orders (("), NumOrders));

    // If we're using the shadow bitmap, then we need to know the current
    // size of the desktop we're blitting around.
    if (_UH.hdcOutputWindow != _UH.hdcDraw)
        _pUi->UI_GetDesktopSize(&desktopSize);

    // Reset the update region to be empty.
#ifdef SMART_SIZING
    UHClearUpdateRegion();
#else // SMART_SIZING
    SetRectRgn(_UH.hrgnUpdate, 0, 0, 0, 0);
#endif // SMART_SIZING

    ordersDrawn = 0;
    for (i = 0; i < NumOrders; i++) {

        // SECURITY: 552403
        CHECK_READ_N_BYTES(pEncodedOrder, pEnd, sizeof(TS_ORDER_HEADER), hr,
            (TB, _T("Bad order header")));
        
        pOrderHeader = (TS_ORDER_HEADER UNALIGNED FAR *)pEncodedOrder;

        IH_CheckForInput("before decoding order");

        // Decode differently based on primary, secondary, or alternate
        // secondary formats.
        switch (pOrderHeader->controlFlags & 0x03) {
            case 0:
                // Currently unused and unsupported.
                TRC_ASSERT(((pOrderHeader->controlFlags & 0x03) != 0),
                        (TB, _T("unsupported control flag encoding type: 0x%02X"),
                        pOrderHeader->controlFlags));
                break;


            case 1:
                // TS_STANDARD only - primary order.
                TRC_NRM((TB, _T("Primary order pEncodedOrder(%p)"),
                        pEncodedOrder));
                hr = _pOd->OD_DecodeOrder(
                        (PVOID *)&pEncodedOrder, pEnd - pEncodedOrder, &pOrder);
                DC_QUIT_ON_FAIL(hr);
                if (NULL == pOrder) {
                    TRC_ERR(( TB, _T("Primary order OD_DecodeOrder failed")));
                    hr = E_TSC_CORE_LENGTH;
                    DC_QUIT;
                }

                // Add the bounds of the order to the Update Region - but
                // only if this is used below.
                if (_UH.hdcDraw == _UH.hdcShadowBitmap) {
                    UHAddUpdateRegion(pOrder, _UH.hrgnUpdate);

                    // If the order threshold has been reached, draw the
                    // orders now.
                    ordersDrawn++;
                    if (ordersDrawn >= _UH.drawThreshold) {
                        TRC_NRM((TB, _T("Draw threshold reached")));
                        ordersDrawn = 0;


#ifdef SMART_SIZING
                        if (!_pOp->OP_CopyShadowToDC(_UH.hdcOutputWindow, 0, 0, desktopSize.width, 
                                desktopSize.height, TRUE)) {
                            TRC_ERR((TB, _T("OP_CopyShadowToDC failed")));
                        }
#else // SMART_SIZING
                        SelectClipRgn(_UH.hdcOutputWindow, _UH.hrgnUpdate);

                        if (!BitBlt(_UH.hdcOutputWindow, 0, 0,
                                desktopSize.width, desktopSize.height,
                                _UH.hdcShadowBitmap, 0, 0, SRCCOPY)) {
                            TRC_ERR((TB, _T("BitBlt failed")));
                        }
#endif // SMART_SIZING

                        // Reset the update region to be empty.
#ifdef SMART_SIZING
                        UHClearUpdateRegion();
#else // SMART_SIZING
                        SetRectRgn(_UH.hrgnUpdate, 0, 0, 0, 0);
#endif // SMART_SIZING
                    }
                }

                break;


        case 2:
#ifdef DRAW_GDIPLUS
                // Now we add Gdiplus drawing in alternate secondary order
                // So need to this just like primary order.
                if (ordersDrawn >= _UH.drawThreshold) {
                    TRC_NRM((TB, _T("Draw threshold reached")));
                    ordersDrawn = 0;
#ifdef SMART_SIZING
                    if (!_pOp->OP_CopyShadowToDC(_UH.hdcOutputWindow, 0, 0, desktopSize.width, 
                            desktopSize.height, TRUE)) {
                        TRC_ERR((TB, _T("OP_CopyShadowToDC failed")));
                    }
#else // SMART_SIZING
                    SelectClipRgn(_UH.hdcOutputWindow, _UH.hrgnUpdate);

                    if (!BitBlt(_UH.hdcOutputWindow, 0, 0,
                            desktopSize.width, desktopSize.height,
                             UH.hdcShadowBitmap, 0, 0, SRCCOPY)) {
                        TRC_ERR((TB, _T("BitBlt failed")));
                    }
#endif // SMART_SIZING

                    // Reset the update region to be empty.
#ifdef SMART_SIZING
                    UHClearUpdateRegion();
#else // SMART_SIZING
                    SetRectRgn(_UH.hrgnUpdate, 0, 0, 0, 0);
#endif // SMART_SIZING
                }
#endif // DRAW_GDIPLUS

                // Alternate secondary order -- TS_SECONDARY without
                // TS_STANDARD.
                OrderType = (*pEncodedOrder & TS_ALTSEC_ORDER_TYPE_MASK) >>
                        TS_ALTSEC_ORDER_TYPE_SHIFT;
                
                if (OrderType == TS_ALTSEC_SWITCH_SURFACE) {

                    // SECURITY: 552403
                    CHECK_READ_N_BYTES(pEncodedOrder, pEnd, sizeof(TS_SWITCH_SURFACE_ORDER), hr,
                        (TB, _T("Bad TS_SWITCH_SURFACE_ORDER")));
                    
                    TRC_NRM((TB, _T("TS_SWITCH_SURFACE")));
                    hr = UHSwitchBitmapSurface((PTS_SWITCH_SURFACE_ORDER)
                            pEncodedOrder, pEnd - pEncodedOrder);
                    DC_QUIT_ON_FAIL(hr);
                    pEncodedOrder += sizeof(TS_SWITCH_SURFACE_ORDER);
                }
                else if (OrderType == TS_ALTSEC_CREATE_OFFSCR_BITMAP) {

                    // SECURITY: 552403
                    CHECK_READ_N_BYTES(pEncodedOrder, pEnd, 
                        FIELDOFFSET( TS_CREATE_OFFSCR_BITMAP_ORDER, variableBytes ), 
                        hr, (TB, _T("Bad TS_CREATE_OFFSCR_BITMAP_ORDER ")));
                    
                    TRC_NRM((TB, _T("TS_CREATE_OFFSCR_BITMAP")));
                    hr = UHCreateOffscrBitmap(
                            (PTS_CREATE_OFFSCR_BITMAP_ORDER)pEncodedOrder, 
                            pEnd - pEncodedOrder, &orderSize);
                    DC_QUIT_ON_FAIL(hr);
                    pEncodedOrder += orderSize;
                }
#ifdef DRAW_NINEGRID
                else if (OrderType == TS_ALTSEC_STREAM_BITMAP_FIRST) {

                    // SECURITY: 552403
                    CHECK_READ_N_BYTES(pEncodedOrder, pEnd, sizeof( TS_STREAM_BITMAP_FIRST_PDU ), hr,
                        (TB, _T("Bad TS_STREAM_BITMAP_FIRST_PDU ")));
                    
                    TRC_NRM((TB, _T("TS_STREAM_BITMAP_FIRST")));
                    hr = UHCacheStreamBitmapFirstPDU(
                            (PTS_STREAM_BITMAP_FIRST_PDU)pEncodedOrder, 
                            pEnd - pEncodedOrder, &orderSize);
                    DC_QUIT_ON_FAIL(hr);
                    pEncodedOrder += orderSize;         
                }
                else if (OrderType == TS_ALTSEC_STREAM_BITMAP_NEXT) {

                    // SECURITY: 552403
                    CHECK_READ_N_BYTES(pEncodedOrder, pEnd, sizeof( TS_STREAM_BITMAP_NEXT_PDU), hr,
                        (TB, _T("Bad TS_STREAM_BITMAP_NEXT_PDU ")));
                
                    TRC_NRM((TB, _T("TS_STREAM_BITMAP_NEXT")));
                    hr = UHCacheStreamBitmapNextPDU(
                            (PTS_STREAM_BITMAP_NEXT_PDU)pEncodedOrder, 
                            pEnd - pEncodedOrder, &orderSize);
                    DC_QUIT_ON_FAIL(hr);
                    pEncodedOrder += orderSize;             
                }
                else if (OrderType == TS_ALTSEC_CREATE_NINEGRID_BITMAP) {

                    // SECURITY: 552403
                    CHECK_READ_N_BYTES(pEncodedOrder, pEnd, sizeof( TS_CREATE_NINEGRID_BITMAP_ORDER ), hr,
                        (TB, _T("Bad TS_CREATE_NINEGRID_BITMAP_ORDER ")));
                    
                    TRC_NRM((TB, _T("TS_CREATE_NINEGRID_BITMAP")));
                    hr = UHCreateNineGridBitmap(
                            (PTS_CREATE_NINEGRID_BITMAP_ORDER)pEncodedOrder, 
                            pEnd - pEncodedOrder, &orderSize);
                    DC_QUIT_ON_FAIL(hr);
                    pEncodedOrder += orderSize; 
                }
#endif
#ifdef DRAW_GDIPLUS
                else if (OrderType == TS_ALTSEC_GDIP_CACHE_FIRST) {

                    // SECURITY: 552403
                    CHECK_READ_N_BYTES(pEncodedOrder, pEnd, sizeof( TS_DRAW_GDIPLUS_CACHE_ORDER_FIRST ), hr,
                        (TB, _T("Bad TS_DRAW_GDIPLUS_CACHE_ORDER_FIRST ")));
                   
                    TRC_NRM((TB, _T("TS_ALTSEC_GDIP_CACHE_FIRST")));
                    hr = UHDrawGdiplusCachePDUFirst(
                            (PTS_DRAW_GDIPLUS_CACHE_ORDER_FIRST)pEncodedOrder, 
                            pEnd - pEncodedOrder, &orderSize);
                    DC_QUIT_ON_FAIL(hr);
                    pEncodedOrder += orderSize;           
                }
                else if (OrderType == TS_ALTSEC_GDIP_CACHE_NEXT) {

                    // SECURITY: 552403
                    CHECK_READ_N_BYTES(pEncodedOrder, pEnd, sizeof( TS_DRAW_GDIPLUS_CACHE_ORDER_NEXT ), hr,
                        (TB, _T("Bad TS_DRAW_GDIPLUS_CACHE_ORDER_NEXT ")));
                    
                    TRC_NRM((TB, _T("TS_ALTSEC_GDIP_CACHE_NEXT")));
                    hr = UHDrawGdiplusCachePDUNext(
                            (PTS_DRAW_GDIPLUS_CACHE_ORDER_NEXT)pEncodedOrder, 
                            pEnd - pEncodedOrder, &orderSize);
                    DC_QUIT_ON_FAIL(hr);
                    pEncodedOrder += orderSize;                     
                }
                else if (OrderType == TS_ALTSEC_GDIP_CACHE_END) {

                    // SECURITY: 552403
                    CHECK_READ_N_BYTES(pEncodedOrder, pEnd, sizeof( TS_DRAW_GDIPLUS_CACHE_ORDER_END ), hr,
                        (TB, _T("Bad TS_DRAW_GDIPLUS_CACHE_ORDER_END ")));
                     
                    TRC_NRM((TB, _T("TS_ALTSEC_GDIP_CACHE_END")));
                    hr = UHDrawGdiplusCachePDUEnd(
                            (PTS_DRAW_GDIPLUS_CACHE_ORDER_END)pEncodedOrder, 
                            pEnd - pEncodedOrder, &orderSize);
                    DC_QUIT_ON_FAIL(hr);
                    pEncodedOrder += orderSize;                      
                }
                else if (OrderType == TS_ALTSEC_GDIP_FIRST) {

                    // SECURITY: 552403
                    CHECK_READ_N_BYTES(pEncodedOrder, pEnd, sizeof( TS_DRAW_GDIPLUS_ORDER_FIRST ), hr,
                        (TB, _T("Bad TS_DRAW_GDIPLUS_ORDER_FIRST ")));
                    
                    TRC_NRM((TB, _T("TS_ALTSEC_GDIP_FIRST")));
                    hr = UHDrawGdiplusPDUFirst(
                            (PTS_DRAW_GDIPLUS_ORDER_FIRST)pEncodedOrder, 
                            pEnd - pEncodedOrder, &orderSize);
                    DC_QUIT_ON_FAIL(hr);
                    pEncodedOrder += orderSize;                    
                    ordersDrawn++;
                }
                else if (OrderType == TS_ALTSEC_GDIP_NEXT) {

                    // SECURITY: 552403
                    CHECK_READ_N_BYTES(pEncodedOrder, pEnd, sizeof( TS_DRAW_GDIPLUS_ORDER_NEXT ), hr,
                        (TB, _T("Bad TS_DRAW_GDIPLUS_ORDER_NEXT ")));
                   
                    TRC_NRM((TB, _T("TS_ALTSEC_GDIP_NEXT")));
                    hr = UHDrawGdiplusPDUNext(
                            (PTS_DRAW_GDIPLUS_ORDER_NEXT)pEncodedOrder, 
                            pEnd - pEncodedOrder, &orderSize);
                    DC_QUIT_ON_FAIL(hr);
                    pEncodedOrder += orderSize;                      
                }
                else if (OrderType == TS_ALTSEC_GDIP_END) {

                    // SECURITY: 552403
                    CHECK_READ_N_BYTES(pEncodedOrder, pEnd, sizeof( TS_DRAW_GDIPLUS_ORDER_END ), hr,
                        (TB, _T("Bad TS_DRAW_GDIPLUS_ORDER_END ")));
                                        
                    TRC_NRM((TB, _T("TS_ALTSEC_GDIP_END")));
                    hr = UHDrawGdiplusPDUEnd(
                            (PTS_DRAW_GDIPLUS_ORDER_END)pEncodedOrder, 
                            pEnd - pEncodedOrder, &orderSize);
                    DC_QUIT_ON_FAIL(hr);
                    pEncodedOrder += orderSize;                    
                    ordersDrawn++;
                }
#endif // DRAW_GDIPLUS

                else {
                    TRC_ASSERT((OrderType < TS_NUM_ALTSEC_ORDERS),
                            (TB,_T("Unsupported alt secondary order type %u"),
                            OrderType)); 
                }

                break;


            case 3:
            {

                // Regular secondary order.
                unsigned secondaryOrderLength;
                TS_SECONDARY_ORDER_HEADER UNALIGNED FAR *pSecondaryOrderHeader;

                // SECURITY: 552403
                CHECK_READ_N_BYTES(pEncodedOrder, pEnd, sizeof(TS_SECONDARY_ORDER_HEADER), hr,
                    (TB, _T("Bad TS_SECONDARY_ORDER_HEADER")));

                TRC_NRM((TB,_T("Secondary order pEncodedOrder(%p)"),
                        pEncodedOrder));

                pSecondaryOrderHeader =
                        (TS_SECONDARY_ORDER_HEADER UNALIGNED FAR *)pOrderHeader;
                OrderType = pSecondaryOrderHeader->orderType;

#ifdef DC_HICOLOR
//#ifdef DC_DEBUG
                // For high color testing, we want to confirm that we've
                // received each of the order types.
                _pOd->_OD.orderHit[TS_FIRST_SECONDARY_ORDER + OrderType] += 1;
//#endif
#endif

                if (OrderType == TS_CACHE_GLYPH) {

                    // SECURITY: 552403
                    CHECK_READ_N_BYTES(pEncodedOrder, pEnd, sizeof(TS_CACHE_GLYPH_ORDER_REV2), hr,
                        (TB, _T("Bad TS_CACHE_GLYPH_ORDER_REV2")));
                    
                    PTS_CACHE_GLYPH_ORDER_REV2 pOrderRev2 =
                            (PTS_CACHE_GLYPH_ORDER_REV2)pSecondaryOrderHeader;

                    TRC_NRM((TB, _T("TS_CACHE_GLYPH")));

                    if (pOrderRev2->header.extraFlags &
                            TS_CacheGlyphRev2_Mask) {
                        // Rev2 glyph order.
                        orderSize = TS_DECODE_SECONDARY_ORDER_ORDERLENGTH(
                                  (INT16)pOrderRev2->header.orderLength) -
                                  sizeof(TS_CACHE_GLYPH_ORDER_REV2) +
                                  sizeof(pOrderRev2->glyphData);
                        // SECURITY: 552403
                        CHECK_READ_N_BYTES(pOrderRev2->glyphData, pEnd, orderSize, hr,
                            (TB, _T("Bad TS_CACHE_GLYPH secondary order length")));

                        hr = UHProcessCacheGlyphOrderRev2(
                                (BYTE)(pOrderRev2->header.extraFlags &
                                  TS_CacheGlyphRev2_CacheID_Mask),
                                (pOrderRev2->header.extraFlags &
                                  TS_CacheGlyphRev2_cGlyphs_Mask) >> 8,
                                pOrderRev2->glyphData,
                                orderSize);
                        DC_QUIT_ON_FAIL(hr);
                    }
                    else {
                        // We get rev1 glyph order
                        // SECURITY: 552403
                        CHECK_READ_N_BYTES(pSecondaryOrderHeader, pEnd, FIELDOFFSET(TS_CACHE_GLYPH_ORDER, glyphData), hr,
                            (TB, _T("Bad TS_CACHE_GLYPH_ORDER")));
                        
                        hr = UHProcessCacheGlyphOrder(
                                (PTS_CACHE_GLYPH_ORDER)pSecondaryOrderHeader, pEnd - (BYTE*)pSecondaryOrderHeader);
                        DC_QUIT_ON_FAIL(hr);
                    }
                }
                else if (OrderType == TS_CACHE_BRUSH) {
                    // SECURITY: 552403
                    CHECK_READ_N_BYTES(pSecondaryOrderHeader, pEnd, 
                        FIELDOFFSET(TS_CACHE_BRUSH_ORDER,brushData), hr,
                        (TB, _T("Bad TS_CACHE_BRUSH_ORDER"))); 
                    
                    TRC_NRM((TB, _T("TS_CACHE_BRUSH")));
                    hr = UHProcessCacheBrushOrder(
                            (PTS_CACHE_BRUSH_ORDER)pSecondaryOrderHeader, pEnd - (BYTE*)pSecondaryOrderHeader);
                    DC_QUIT_ON_FAIL(hr);
                }
                else if (OrderType == TS_CACHE_COLOR_TABLE) {
                    // SECURITY: 552403
                    CHECK_READ_N_BYTES(pSecondaryOrderHeader, pEnd, 
                        FIELDOFFSET(TS_CACHE_COLOR_TABLE_ORDER, colorTable), hr,
                        (TB, _T("Bad TS_CACHE_COLOR_TABLE_ORDER")));
                    
                    TRC_NRM((TB, _T("TS_CACHE_COLOR_TABLE")));
                    hr = UHProcessCacheColorTableOrder(
                             (PTS_CACHE_COLOR_TABLE_ORDER)pSecondaryOrderHeader, pEnd - (BYTE*)pSecondaryOrderHeader );
                    DC_QUIT_ON_FAIL(hr);
                }
                else {
                    TRC_ASSERT((OrderType == TS_CACHE_BITMAP_UNCOMPRESSED ||
                            OrderType == TS_CACHE_BITMAP_UNCOMPRESSED_REV2 ||
                            OrderType == TS_CACHE_BITMAP_COMPRESSED ||
                            OrderType == TS_CACHE_BITMAP_COMPRESSED_REV2),
                            (TB, _T("Unknown secondary order type (%u)"),
                            OrderType));

                    if (OrderType == TS_CACHE_BITMAP_UNCOMPRESSED ||
                            OrderType == TS_CACHE_BITMAP_UNCOMPRESSED_REV2 ||
                            OrderType == TS_CACHE_BITMAP_COMPRESSED ||
                            OrderType == TS_CACHE_BITMAP_COMPRESSED_REV2) {
                        TRC_NRM((TB, _T("TS_CACHE_BITMAP_XXX")));

                        hr = UHProcessCacheBitmapOrder(pSecondaryOrderHeader, pEnd - (BYTE*)pSecondaryOrderHeader);
                        DC_QUIT_ON_FAIL(hr);
                    }
                }

                // Need to cast the orderLength to INT16 because compressed
                // bitmap data (w/o BC header) can be less than
                // TS_SECONDARY_ORDER_LENGTH_FUDGE_FACTOR which makes
                // orderLength negative.
                secondaryOrderLength = TS_DECODE_SECONDARY_ORDER_ORDERLENGTH(
                        (short)pSecondaryOrderHeader->orderLength);

                pEncodedOrder += secondaryOrderLength;
                break;
            }
        }
    }

    TRC_DBG((TB, _T("End replaying orders ))")));

    if (ordersDrawn != 0) {
        ordersDrawn = 0;

#ifdef SMART_SIZING
        // Get the OP to use the update region as the clip region.
        if (!_pOp->OP_CopyShadowToDC(_UH.hdcOutputWindow, 0, 0, desktopSize.width, 
                desktopSize.height, TRUE)) {
            TRC_ERR((TB, _T("OP_CopyShadowToDC failed")));
        }
#else // SMART_SIZING
        // Use the update region as the clip region.
        SelectClipRgn(_UH.hdcOutputWindow, _UH.hrgnUpdate);

        if (!BitBlt(_UH.hdcOutputWindow, 0, 0, desktopSize.width,
                desktopSize.height, _UH.hdcShadowBitmap, 0, 0, SRCCOPY))
        {
            TRC_ERR((TB, _T("BitBlt failed")));
        }
#endif // SMART_SIZING
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
/* Function to determine if the supplied color matches any of the VGA       */
/* colors at the 'high' end of the supplied color table                     */
/****************************************************************************/
inline DCBOOL DCINTERNAL CUH::UHIsHighVGAColor(DCUINT8 red,
                                           DCUINT8 green,
                                           DCUINT8 blue)
{
    DCBOOL rc = FALSE;

    DC_BEGIN_FN("UHIsHighVGAColor");

    switch (red)
    {
        case 255:
        {
            if ((green == 251) && (blue == 240))
            {
                rc = TRUE;
                break;
            }
        }
        /* NOTE DELIBERATE DROP THROUGH */
        case 0:
        {
            if ((green == 0) || (green == 255))
            {
                if ((blue == 0) || (blue == 255))
                {
                    rc = TRUE;
                }
            }
        }
        break;

        case 160:
        {
            if ((green == 160) && (blue == 164))
            {
                rc = TRUE;
            }
        }
        break;

        case 128:
        {
            if ((green == 128) && (blue == 128))
            {
                rc = TRUE;
            }
        }
        break;

        default:
        {
            /* rc = FALSE; */
        }
        break;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* Name:      UHProcessPalettePDU                                           */
/*                                                                          */
/* Purpose:   Processes a received Palette PDU.                             */
/*                                                                          */
/* Operation: Creates a Windows palette containing the received colors      */
/****************************************************************************/
HRESULT DCAPI CUH::UH_ProcessPalettePDU(
        TS_UPDATE_PALETTE_PDU_DATA UNALIGNED FAR *pPalettePDU, 
        DCUINT dataLength)
{
    HRESULT hr = S_OK;
    /************************************************************************/
    /* logPaletteBuffer is a large structure (~1K), but if we can get away  */
    /* with it on the stack, its better than having it statically           */
    /* allocated, or having to do a dynamic allocation.                     */
    /************************************************************************/
    DCUINT8         logPaletteBuffer[ sizeof(LOGPALETTE) +
                                      (UH_NUM_8BPP_PAL_ENTRIES *
                                                      sizeof(PALETTEENTRY)) ];
    PLOGPALETTE     pLogPalette;
    DCUINT          i;
    LPPALETTEENTRY  pPaletteEntry;
    TS_COLOR UNALIGNED FAR *pColor;
    HPALETTE        hpalNew;
    DCINT           cacheId;
    BYTE *      pDataEnd = (PBYTE)pPalettePDU + dataLength;

    DC_BEGIN_FN("UHProcessPalettePDU");
#ifdef DC_HICOLOR
    if (_UH.protocolBpp > 8)
    {
        TRC_ERR((TB, _T("Received palette PDU in Hi color mode!")));
        DC_QUIT;
    }
#endif

#if defined (OS_WINCE)
    _UH.validBrushDC = NULL;
#endif

    TIMERSTART;

    /************************************************************************/
    /* Increment our count of received palette PDUs.  This is decremented   */
    /* inside OP_PaletteChanged, where we process the resulting             */
    /* WM_PALETTECHANGED message.                                           */
    /************************************************************************/
    _pOp->OP_IncrementPalettePDUCount();

    /************************************************************************/
    /* Create a new palette from the received packet.                       */
    /*                                                                      */
    /* We cannot just update the current palette colors (using              */
    /* SetPaletteEntries) because Windows does not handle the repainting    */
    /* of other local Palette Manager apps correctly (it does not           */
    /* broadcast the WM_PALETTE.. messages as the palette mapping does      */
    /* not change).                                                         */
    /************************************************************************/

    /************************************************************************/
    /* We currently only support 8bpp protocol data.                        */
    /************************************************************************/
    if (UH_NUM_8BPP_PAL_ENTRIES != pPalettePDU->numberColors) {
        TRC_ERR(( TB, _T("Invalid palette entries(%u)"), 
            pPalettePDU->numberColors));
        hr = E_TSC_CORE_PALETTE;
        DC_QUIT;
    }

    // SECURITY: 552403
    CHECK_READ_N_BYTES(pPalettePDU, pDataEnd,
        FIELDOFFSET(TS_UPDATE_PALETTE_PDU_DATA, palette) + 
        (pPalettePDU->numberColors * sizeof(TS_COLOR)),
        hr, ( TB, _T("Invalid palette PDU; size %u"), dataLength ));

    /************************************************************************/
    /* Set up a logical palette structure containing the new colors.        */
    /************************************************************************/
    pLogPalette = (LPLOGPALETTE)logPaletteBuffer;
    pLogPalette->palVersion    = UH_LOGPALETTE_VERSION;
    pLogPalette->palNumEntries = (DCUINT16)UH_NUM_8BPP_PAL_ENTRIES;

    /************************************************************************/
    /* The palette PDU contains an array of TS_COLOR structures which each  */
    /* contain 3 fields (RGB).  We have to convert each of these structures */
    /* to a PALETTEENTRY structure which has the same 3 fields (RGB) plus   */
    /* some flags.                                                          */
    /************************************************************************/
    pPaletteEntry = &(pLogPalette->palPalEntry[0]);
    pColor = &(pPalettePDU->palette[0]);

    for (i = 0; i < UH_NUM_8BPP_PAL_ENTRIES; i++)
    {
        pPaletteEntry->peRed   = pColor->red;
        pPaletteEntry->peGreen = pColor->green;
        pPaletteEntry->peBlue  = pColor->blue;

        /********************************************************************/
        /* We want the created palette to have the given colors at the      */
        /* given indices, and for each color to draw with a pixel value     */
        /* identical to the palette index.  This is because we want the     */
        /* client pixel values to be identical to the server values (if     */
        /* possible) so that awkward ROPs that rely on the destination      */
        /* pixel value (DSTBLT rops e.g.  0x55) come out correctly.  In     */
        /* some cases this is simply not possible (e.g.  if the client is   */
        /* not running 8bpp).                                               */
        /*                                                                  */
        /* There may be duplicated colors in the palette, so we must        */
        /* specify PC_NOCOLLAPSE for non-system colors to prevent these     */
        /* entries from being mapped to identical colors elsewhere in the   */
        /* palette.                                                         */
        /********************************************************************/
#ifdef OS_WINCE
        pPaletteEntry->peFlags = (BYTE)0;
#else // OS_WINCE
        pPaletteEntry->peFlags = (BYTE)
                            (UH_IS_SYSTEM_COLOR_INDEX(i) ? 0 : PC_NOCOLLAPSE);
#endif

        /********************************************************************/
        /* We also have to avoid the problem of one of the system colors    */
        /* mapping onto another color in the palette.  We do this by        */
        /* ensuring that no entries exactly match a system color            */
        /* Don't need to worry for 4bpp Client.                             */
        /********************************************************************/
        if (_pUi->UI_GetColorDepth() != 4)
        {
            if (!UH_IS_SYSTEM_COLOR_INDEX(i))
            {
                if (UHIsHighVGAColor(pColor->red,
                                     pColor->green,
                                     pColor->blue))
                {
                    TRC_NRM((TB, _T("Tweaking entry %2x"), i));
                    UH_TWEAK_COLOR_COMPONENT(pPaletteEntry->peBlue);
                }
            }

            TRC_DBG((TB, _T("%2x: r(%3u) g(%3u) b(%3u) flags(%#x)"),
                        i,
                        pPaletteEntry->peRed,
                        pPaletteEntry->peGreen,
                        pPaletteEntry->peBlue,
                        pPaletteEntry->peFlags));
        }

        _UH.rgbQuadTable[i].rgbRed      = pPaletteEntry->peRed;
        _UH.rgbQuadTable[i].rgbGreen    = pPaletteEntry->peGreen;
        _UH.rgbQuadTable[i].rgbBlue     = pPaletteEntry->peBlue;
        _UH.rgbQuadTable[i].rgbReserved = 0;

        pPaletteEntry++;
        pColor++;
    }
#ifdef DRAW_GDIPLUS
    pPaletteEntry = &(pLogPalette->palPalEntry[0]);
    if (_UH.pfnGdipPlayTSClientRecord != NULL) {
        _UH.pfnGdipPlayTSClientRecord(NULL, DrawTSClientPaletteChange, (BYTE *)pPaletteEntry, 
                                      sizeof(PALETTEENTRY) * UH_NUM_8BPP_PAL_ENTRIES, NULL);
    }
#endif

    // Now copy the RGBquad array into the color table used for brushes.
    if (_UH.pColorBrushInfo != NULL) {
        memcpy(_UH.pColorBrushInfo->bmi.bmiColors, _UH.rgbQuadTable,
               sizeof(_UH.rgbQuadTable));
    }

#ifdef USE_DIBSECTION
#ifndef OS_WINCE
    /************************************************************************/
    /* It is supposed to be legitimate to ignore this on WinCE. WinCE has   */
    /* simplified things such that when you create a DIB section and use    */
    /* specify a palette, it actually just uses the palette of the DC into  */
    /* which you select the DIB. That leaves the expectation that the Blt   */
    /* operations between those DCs can still be fast. So far that's not    */
    /* what we've seen.                                                     */
    /************************************************************************/
    if (_UH.usingDIBSection)
    {
        if (NULL != _UH.hdcShadowBitmap)
        {
            TRC_NRM((TB, _T("Update the shadow bitmap color table")));
            SetDIBColorTable(_UH.hdcShadowBitmap,
                             0,
                             UH_NUM_8BPP_PAL_ENTRIES,
                             (RGBQUAD *)&_UH.rgbQuadTable);
        }

        if (NULL != _UH.hdcSaveScreenBitmap)
        {
            TRC_NRM((TB, _T("Update the save screen bitmap color table")));
            SetDIBColorTable(_UH.hdcSaveScreenBitmap,
                             0,
                             UH_NUM_8BPP_PAL_ENTRIES,
                             (RGBQUAD *)&_UH.rgbQuadTable);
        }       
    }
#endif
#endif /* USE_DIBSECTION */

    // Create the palette.
    hpalNew = CreatePalette(pLogPalette);
    if (hpalNew == NULL)
    {
        TRC_ERR((TB, _T("Failed to create palette")));
    }
    TRC_NRM((TB, _T("Set new palette: %p"), hpalNew));

#ifdef OS_WINCE
    // On a fixed palette device don't try to set and realize a palette.
    // This only applies to Maxall, always do this on WBT
    if (!_UH.paletteIsFixed || CE_CONFIG_WBT == g_CEConfig)
    {
#endif
        if (_UH.hdcShadowBitmap != NULL)
        {
            SelectPalette( _UH.hdcShadowBitmap,
                           hpalNew,
                           FALSE );
            RealizePalette(_UH.hdcShadowBitmap);
        }

        if (_UH.hdcSaveScreenBitmap != NULL)
        {
            SelectPalette( _UH.hdcSaveScreenBitmap,
                           hpalNew,
                           FALSE );
            RealizePalette(_UH.hdcSaveScreenBitmap);
        }

        if (_UH.hdcOutputWindow != NULL)
        {
            SelectPalette( _UH.hdcOutputWindow,
                           hpalNew,
                           FALSE );
            RealizePalette(_UH.hdcOutputWindow);
        }

        if (_UH.hdcOffscreenBitmap != NULL)
        {
            SelectPalette( _UH.hdcOffscreenBitmap,
                           hpalNew,
                           FALSE );
            RealizePalette(_UH.hdcOffscreenBitmap);
        }

#ifdef OS_WINCE
    }
#endif

    if (_UH.hdcBrushBitmap != NULL)
    {
        SelectPalette( _UH.hdcBrushBitmap,
                       hpalNew,
                           FALSE );
        RealizePalette(_UH.hdcBrushBitmap);
    }

    if ((_UH.hpalCurrent != NULL) && (_UH.hpalCurrent != _UH.hpalDefault))
    {
        TRC_DBG((TB, _T("Delete current palette %p"), _UH.hpalCurrent));
        DeletePalette(_UH.hpalCurrent);
    }
    _UH.hpalCurrent = hpalNew;

    // Recalculate the cached Color Table mappings.
    for (cacheId = 0; cacheId <= _UH.maxColorTableId; cacheId++)
    {
        TRC_NRM((TB, _T("Recalculate mapping %u"), cacheId));
        UHCalculateColorTableMapping(cacheId);
    }

DC_EXIT_POINT:

    TIMERSTOP;
    UPDATECOUNTER(FC_UHPROCESSPALETTEPDU);
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// UHUseBrush and UHUseSolidPaletteBrush create the correct brush to use.
// We rely on UHUseTextColor and UseBKColor being called before this routine
// to set up _UH.lastTextColor and _UH.lastBkColor correctly.
/****************************************************************************/
/****************************************************************************/
/* Name:      UHUseBrush                                                    */
/*                                                                          */
/* Purpose:   Creates and selects a given brush into the current output     */
/*            DC.                                                           */
/*                                                                          */
/* Params:    IN: style     - brush style                                   */
/*            IN: hatch     - brush hatch                                   */
/*            IN: color     - brush color                                   */
/*            IN: colorType - type of color                                 */
/*            IN: extra     - array of bitmap bits for custom brushes       */
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHUseBrush(
        unsigned style,
        unsigned hatch,
        DCCOLOR  color,
        unsigned colorType,
        BYTE extra[7] )
{
    HRESULT hr = S_OK;
    HBRUSH hBrushNew = NULL;
    UINT32 iBitmapFormat;
    BOOL bUsingPackedDib = FALSE;
#ifdef DC_HICOLOR
    PVOID pDib = NULL;
#endif

    DC_BEGIN_FN("UHUseBrush");

#if defined (OS_WINCE)
    COLORREF colorref = UHGetColorRef(color, colorType, this);

    if ((style != _UH.lastLogBrushStyle) ||
        (hatch != _UH.lastLogBrushHatch) ||
        (colorref != _UH.lastLogBrushColorRef) ||
        (DC_MEMCMP(extra, _UH.lastLogBrushExtra, sizeof(_UH.lastLogBrushExtra))) ||
        (_UH.validBrushDC != _UH.hdcDraw) ||
        (((_UH.lastLogBrushStyle == BS_PATTERN) ||
          (_UH.lastLogBrushStyle & TS_CACHED_BRUSH)) &&
           ((_UH.lastTextColor != _UH.lastBrushTextColor) ||
            (_UH.lastBkColor   != _UH.lastBrushBkColor) ||
            (_UH.validTextColorDC != _UH.hdcDraw) ||
            (_UH.validBkColorDC != _UH.hdcDraw))))
#endif
    {
        _UH.lastLogBrushStyle = style;
        _UH.lastLogBrushHatch = hatch;
#if defined (OS_WINCE)
        _UH.lastLogBrushColorRef = colorref;
#else
        _UH.lastLogBrushColor = color;
#endif
        memcpy(_UH.lastLogBrushExtra, extra, sizeof(_UH.lastLogBrushExtra));

#if defined (OS_WINCE)
        _UH.validBrushDC = _UH.hdcDraw;
#endif

        if ((style & TS_CACHED_BRUSH) || (style == BS_PATTERN))
        {
            BYTE patternData[64];

            // Pull the brush from the cache if supplied.
            if (style & TS_CACHED_BRUSH) {

                iBitmapFormat = style & 0x0F;
                switch (iBitmapFormat) {

                // monochrome brush (BMF_1BPP)
                case 1:
                    hr = UHIsValidMonoBrushCacheIndex(hatch);
                    DC_QUIT_ON_FAIL(hr);
                    
#ifndef OS_WINCE
                    SetBitmapBits(_UH.bmpMonoPattern, 8*2,
                                  _UH.pMonoBrush[hatch].data);
#else
                    DeleteObject(_UH.bmpMonoPattern);
                    _UH.bmpMonoPattern = CreateBitmap(8,8,1,1,
                                                     _UH.pMonoBrush[hatch].data);
#endif
                    _UH.bmpPattern = _UH.bmpMonoPattern;
                    break;

                // 256 color brush (BMF_8BPP)
                case 3:
                    hr = UHIsValidColorBrushCacheIndex(hatch);
                    DC_QUIT_ON_FAIL(hr);
                    
                    // set up the packed DIB
                    memcpy(_UH.pColorBrushInfo->bytes,
                           _UH.pColorBrush[hatch].data,
                           UH_COLOR_BRUSH_SIZE);

                    _UH.pColorBrushInfo->bmi.bmiHeader.biBitCount = 8;
                    _UH.bmpPattern = NULL;
#ifdef DC_HICOLOR
                    pDib = _UH.pColorBrushInfo;
#endif
                    bUsingPackedDib = TRUE;

                    break;

#ifdef DC_HICOLOR
                // 16bpp brush (BMF_16BPP)
                case 4:
                    hr = UHIsValidColorBrushCacheIndex(hatch);
                    DC_QUIT_ON_FAIL(hr);
                    
                    _UH.pHiColorBrushInfo->bmiHeader.biBitCount = 16;
                    if (_UH.protocolBpp == 16)
                    {
                        // set up the bmp format to use
                        _UH.pHiColorBrushInfo->bmiHeader.biClrUsed = 3;
                        _UH.pHiColorBrushInfo->bmiHeader.biCompression =
                                                                 BI_BITFIELDS;

                        // set up the packed DIB
                        memcpy(_UH.pHiColorBrushInfo->bytes,
                               _UH.pColorBrush[hatch].data,
                               UH_COLOR_BRUSH_SIZE_16);
                    }
                    else
                    {
                        // set up the bmp format to use
                        _UH.pHiColorBrushInfo->bmiHeader.biClrUsed = 0;
                        _UH.pHiColorBrushInfo->bmiHeader.biCompression =
                                                                       BI_RGB;

                        // set up the packed DIB, overwriting the unused color
                        // masks
                        memcpy(_UH.pHiColorBrushInfo->bmiColors,
                               _UH.pColorBrush[hatch].data,
                               UH_COLOR_BRUSH_SIZE_16);
                    }
                    _UH.bmpPattern   = NULL;
                    pDib            = _UH.pHiColorBrushInfo;
                    bUsingPackedDib = TRUE;

                    break;


                // 24bpp brush (BMF_24BPP)
                case 5:
                    hr = UHIsValidColorBrushCacheIndex(hatch);
                    DC_QUIT_ON_FAIL(hr);
                    
                    // set up the packed DIB
                    memcpy(_UH.pHiColorBrushInfo->bytes,
                           _UH.pColorBrush[hatch].data,
                           UH_COLOR_BRUSH_SIZE_24);

                    _UH.pHiColorBrushInfo->bmiHeader.biBitCount = 24;
                    _UH.bmpPattern   = NULL;
                    pDib            = _UH.pHiColorBrushInfo;
                    bUsingPackedDib = TRUE;

                    break;
#endif

                default:
                    _UH.bmpPattern = NULL;
                    TRC_ASSERT((iBitmapFormat == 1) ||
                               (iBitmapFormat == 3),
                               (TB, _T("Invalid cached brush depth: %ld cacheId: %u"),
                                iBitmapFormat, hatch));

                }
            }

            /************************************************************/
            /* Place the bitmap bits into an array of bytes in the      */
            /* correct form for SetBitmapBits which uses 16 bits per    */
            /* scanline.                                                */
            /************************************************************/
            else {
                patternData[14] = (DCUINT8)hatch;
                patternData[12] = extra[0];
                patternData[10] = extra[1];
                patternData[8]  = extra[2];
                patternData[6]  = extra[3];
                patternData[4]  = extra[4];
                patternData[2]  = extra[5];
                patternData[0]  = extra[6];
#ifndef OS_WINCE
                SetBitmapBits(_UH.bmpMonoPattern, 8*2, patternData);
#else
                DeleteObject(_UH.bmpMonoPattern);
                _UH.bmpMonoPattern = CreateBitmap(8,8,1,1,patternData);
#endif
                _UH.bmpPattern = _UH.bmpMonoPattern;
            }


            // Mono brush creation
            if (_UH.bmpPattern)
            {
                hBrushNew = CreatePatternBrush(_UH.bmpPattern);
                if (hBrushNew != NULL)
                {
                    _UH.lastBrushTextColor = _UH.lastTextColor;
                    _UH.lastBrushBkColor   = _UH.lastBkColor;
                }
                else
                {
                    TRC_ERR((TB, _T("Failed to create pattern brush")));
                }
            }

            // Color brush creation
            else if (bUsingPackedDib) {
#ifdef DC_HICOLOR
                hBrushNew = CreateDIBPatternBrushPt(pDib, DIB_RGB_COLORS);
#else
                hBrushNew = CreateDIBPatternBrushPt(_UH.pColorBrushInfo,
                                                    DIB_RGB_COLORS);
#endif
                if (hBrushNew != NULL)
                {
                    _UH.lastBrushTextColor = _UH.lastTextColor;
                    _UH.lastBrushBkColor   = _UH.lastBkColor;
                }
                else
                {
                    TRC_ERR((TB, _T("CreateDIBPatternBrushPt Failed")));
                }
            }


        }
        else
        {
#ifndef OS_WINCE
            // Only allow through those operations we know will succeed.  If we
            // send any other style of brush, then the hatch will be interpretted
            // as a pointer or a handle and can crash GDI32.
            // Only allow through what we know is good.
            if (BS_SOLID == _UH.lastLogBrushStyle ||
                BS_HOLLOW == _UH.lastLogBrushStyle ||
                BS_HATCHED == _UH.lastLogBrushStyle ) { 
                LOGBRUSH logBrush;

                logBrush.lbStyle = _UH.lastLogBrushStyle;
                logBrush.lbHatch = _UH.lastLogBrushHatch;
                logBrush.lbColor = UHGetColorRef(_UH.lastLogBrushColor, colorType, this);
                hBrushNew = CreateBrushIndirect(&logBrush);
            }
            else {
                TRC_ABORT((TB,_T("Unsupported brush style: %d"), _UH.lastLogBrushStyle));
                hBrushNew = NULL;
                hr = E_TSC_CORE_DECODETYPE;
                DC_QUIT;
            }
#else // OS_WINCE
            TRC_ASSERT((_UH.lastLogBrushStyle == BS_SOLID),
                      (TB,_T("Unsupported brush type %d"), _UH.lastLogBrushStyle));
            hBrushNew = CECreateSolidBrush(colorref);
#endif // OS_WINCE
        }

        if (hBrushNew == NULL)
        {
            TRC_ERR((TB, _T("Failed to create brush")));
        }
        else
        {
            HBRUSH  hbrOld;

            TRC_DBG((TB, _T("Selecting new brush %p"), hBrushNew));

            hbrOld = SelectBrush(_UH.hdcDraw, hBrushNew);
            if(hbrOld)
            {
#ifndef OS_WINCE
                DeleteObject(hbrOld);
#else
                CEDeleteBrush(hbrOld);
#endif
            }
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// UHUseSolidPaletteBrush
//
// Used to switch the main DC to use the given solid color brush.
// We hard-code for 16- or 256-color palettes because that's all we support
// in this version, so why create extra branches?
// Differentiated from UHUseBrush() because solid color brushes are the most
// common (OpaqueRect).
/****************************************************************************/
void DCINTERNAL CUH::UHUseSolidPaletteBrush(DCCOLOR color)
{
    HBRUSH hBrushNew;

    DC_BEGIN_FN("UHUseSolidPaletteBrush");
#if defined (OS_WINCE)
    COLORREF colorref = UHGetColorRef(color, UH_COLOR_PALETTE, this);
    if ((_UH.lastLogBrushStyle != BS_SOLID) ||
            (_UH.lastLogBrushHatch != 0) ||
            (colorref != _UH.lastLogBrushColorRef) ||
            (_UH.validBrushDC != _UH.hdcDraw))
#endif
    {
        _UH.lastLogBrushStyle = BS_SOLID;
        _UH.lastLogBrushHatch = 0;
#if defined (OS_WINCE)
        _UH.lastLogBrushColorRef = colorref;
#else
        _UH.lastLogBrushColor = color;
#endif

        memset(_UH.lastLogBrushExtra, 0, sizeof(_UH.lastLogBrushExtra));

#if defined (OS_WINCE)
        _UH.validBrushDC = _UH.hdcDraw;
#endif

        {
#ifndef OS_WINCE
            LOGBRUSH logBrush;

            logBrush.lbStyle = _UH.lastLogBrushStyle;
            logBrush.lbHatch = _UH.lastLogBrushHatch;
            logBrush.lbColor = UHGetColorRef(_UH.lastLogBrushColor,
                    UH_COLOR_PALETTE, this);
            hBrushNew = CreateBrushIndirect(&logBrush);
#else // OS_WINCE
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
            // When in multimon and two desktops have different color depths
            // glyph color don't look right in 256 color connection
            // Here is the temporary solution, need to investigate more later.
            // SergeyS: This slows rdp down considerably, and the code is not
            // relevant in CE case anyway
            // if (_UH.protocolBpp <= 8)
            //    rgb = GetNearestColor(_UH.hdcDraw, rgb);
#endif //DISABLE_SHADOW_IN_FULLSCREEN
            hBrushNew = CECreateSolidBrush(colorref);
#endif // OS_WINCE
        }

        if (hBrushNew != NULL) {
            TRC_DBG((TB, _T("Selecting new brush %p"), hBrushNew));
#ifndef OS_WINCE
            DeleteObject(SelectBrush(_UH.hdcDraw, hBrushNew));
#else
            CEDeleteBrush(SelectBrush(_UH.hdcDraw, hBrushNew));
#endif
        }
        else {
            TRC_ERR((TB, _T("Failed to create brush")));
        }
    }

    DC_END_FN();
}


/****************************************************************************/
/* Name:      UHUsePen                                                      */
/*                                                                          */
/* Purpose:   Creates and selects a given pen into the current output DC.   */
/*                                                                          */
/* Params:    IN: style     - pen style                                     */
/*            IN: width     - pen width in pixels                           */
/*            IN: color     - pen color                                     */
/*            IN: colorType - type of color                                 */
/****************************************************************************/
inline void DCINTERNAL CUH::UHUsePen(
        unsigned style,
        unsigned width,
        DCCOLOR color,
        unsigned colorType)
{
    HPEN     hPenNew;
    HPEN     hPenOld;
    COLORREF rgb;

    DC_BEGIN_FN("UHUsePen");

    rgb = UHGetColorRef(color, colorType, this);

#if defined (OS_WINCE)
    if ((style != _UH.lastPenStyle) ||
        (rgb   != _UH.lastPenColor) ||
        (width != _UH.lastPenWidth) ||
        (_UH.validPenDC != _UH.hdcDraw))
#endif
    {
        hPenNew = CreatePen(style, width, rgb);
        hPenOld = SelectPen(_UH.hdcDraw, hPenNew);
        if(hPenOld)
        {
            DeleteObject(hPenOld);
        }

        _UH.lastPenStyle = style;
        _UH.lastPenColor = rgb;
        _UH.lastPenWidth = width;

#if defined (OS_WINCE)
        _UH.validPenDC = _UH.hdcDraw;
#endif
    }

    DC_END_FN();
}


/****************************************************************************/
/* Name:      UHResetDCState                                                */
/*                                                                          */
/* Purpose:   Ensures that the output DC's state matches the _UH.last...     */
/*            variables.                                                    */
/****************************************************************************/
void DCINTERNAL CUH::UHResetDCState()
{
    DCCOLOR colorWhite = {0xFF,0xFF,0xFF};
    BYTE brushExtra[7] = {0,0,0,0,0,0,0};
#if !defined(OS_WINCE) || defined(OS_WINCE_TEXTALIGN)
    unsigned textAlign;
#endif // !defined(OS_WINCE) || defined(OS_WINCE_TEXTALIGN)

    DC_BEGIN_FN("UHResetDCState");

    /************************************************************************/
    /* We ensure that the values within the output DC match our _UH.last...  */
    /* variables by setting a value into the _UH.last...  variable directly, */
    /* then setting a different value indirectly using the appropriate      */
    /* function.  This forces the new value to be selected into the DC and  */
    /* the _UH.last...  variable and the DC are guaranteed to be in sync.    */
    /************************************************************************/

    /************************************************************************/
    /* Background color.                                                    */
    /************************************************************************/
    _UH.lastBkColor = 0;
    UHUseBkColor(colorWhite, UH_COLOR_RGB, this);

    /************************************************************************/
    /* Text color.                                                          */
    /************************************************************************/
    _UH.lastTextColor = 0;
    UHUseTextColor(colorWhite, UH_COLOR_RGB, this);

    /************************************************************************/
    /* Background mode.                                                     */
    /************************************************************************/
    _UH.lastBkMode = TRANSPARENT;
    UHUseBkMode(OPAQUE, this);

    /************************************************************************/
    /* ROP2.                                                                */
    /************************************************************************/
    _UH.lastROP2 = R2_BLACK;
    UHUseROP2(R2_COPYPEN, this);

    /************************************************************************/
    /* Brush origin.                                                        */
    /************************************************************************/
    UHUseBrushOrg(0, 0, this);

    /************************************************************************/
    /* Pen.                                                                 */
    /************************************************************************/
    _UH.lastPenStyle = PS_DASH;
    _UH.lastPenWidth = 2;
    _UH.lastPenColor = 0;
    UHUsePen(PS_SOLID, 1, colorWhite, UH_COLOR_RGB);

    /************************************************************************/
    /* Brush.                                                               */
    /************************************************************************/
    _UH.lastLogBrushStyle = BS_NULL;
#if ! defined (OS_WINCE)
    _UH.lastLogBrushHatch = HS_VERTICAL;
    _UH.lastLogBrushColor.u.rgb.red = 0;
    _UH.lastLogBrushColor.u.rgb.green = 0;
    _UH.lastLogBrushColor.u.rgb.blue = 0;
#else
    _UH.lastLogBrushHatch = 1;	// This does not exist - we are just resetting the brush
    _UH.lastLogBrushColorRef = 0;
#endif
    _UH.lastBrushBkColor = 0;
    _UH.lastBrushTextColor = 0;
    // SECURITY: not checking return code, hatch value will be correct here
    UHUseBrush(BS_SOLID,
#if ! defined (OS_WINCE)
    	HS_HORIZONTAL,
#else
        0,
#endif
    	colorWhite, UH_COLOR_RGB, brushExtra);

    /************************************************************************/
    /* All fonts are sent with baseline alignment - so set this mode here.  */
    /************************************************************************/
#if !defined(OS_WINCE) || defined(OS_WINCE_TEXTALIGN)
    textAlign = GetTextAlign(_UH.hdcDraw);
    textAlign &= ~TA_TOP;
    textAlign |= TA_BASELINE;
    SetTextAlign(_UH.hdcDraw, textAlign);
#endif // !defined(OS_WINCE) || defined(OS_WINCE_TEXTALIGN)

    /************************************************************************/
    /* Clip region.                                                         */
    /*                                                                      */
    /* Force it to be reset.                                                */
    /************************************************************************/
    _UH.rectReset = FALSE;
    UH_ResetClipRegion();

    DC_END_FN();
}


/****************************************************************************/
/* Name:      UHProcessCacheBitmapOrder                                     */
/*                                                                          */
/* Purpose:   Processes a received CacheBitmap order by storing the         */
/*            bitmap data in the local cache.                               */
/****************************************************************************/

inline unsigned Decode2ByteField(PBYTE *ppDecode)
{
    unsigned Val;

    // The first bit of the first byte indicates if the field is 1 byte or 2
    // bytes -- 0 if 1 byte.
    if (!(**ppDecode & 0x80)) {
        Val = **ppDecode;
        (*ppDecode)++;
    }
    else {
        Val = ((**ppDecode & 0x7F) << 8) + *(*ppDecode + 1);
        (*ppDecode) += 2;
    }

    return Val;
}

inline long Decode4ByteField(PBYTE *ppDecode)
{
    long Val;
    unsigned FieldLength;

    // The next 2 bits of the first byte indicate the field length --
    // 00=1 byte, 01=2 bytes, 10=3 bytes, 11=4 bytes.
    FieldLength = ((**ppDecode & 0xC0) >> 6) + 1;

    switch (FieldLength) {
        case 1:
            Val = **ppDecode & 0x3F;
            break;

        case 2:
            Val = ((**ppDecode & 0x3F) << 8) + *(*ppDecode + 1);
            break;

        case 3:
            Val = ((**ppDecode & 0x3F) << 16) + (*(*ppDecode + 1) << 8) +
                    *(*ppDecode + 2);
            break;

        default:
            Val = ((**ppDecode & 0x3F) << 24) + (*(*ppDecode + 1) << 16) +
                    (*(*ppDecode + 2) << 8) + *(*ppDecode + 3);
            break;
    }

    *ppDecode += FieldLength;
    return Val;
}


#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

/**************************************************************************/
// UHSendBitmapCacheErrorPDU
//
// Send an bitmap error pdu for the cache with cacheId
// request the server to clear the cache
/**************************************************************************/
BOOL DCINTERNAL CUH::UHSendBitmapCacheErrorPDU(ULONG_PTR cacheId)
{
    unsigned short PktLen;
    SL_BUFHND hBuffer;
    PTS_BITMAPCACHE_ERROR_PDU pBitmapCacheErrorPDU;
    BOOL rc = FALSE;

    //
    // CD passes params as PVOID
    //
    DC_BEGIN_FN("UHSendBitmapCacheErrorPDU");

    PktLen = sizeof(TS_BITMAPCACHE_ERROR_PDU);
    if (_pSl->SL_GetBuffer(PktLen, (PPDCUINT8)&pBitmapCacheErrorPDU, &hBuffer)) {
        TRC_NRM((TB, _T("Successfully alloc'd bitmap cache error packet")));

        pBitmapCacheErrorPDU->shareDataHeader.shareControlHeader.pduType =
                TS_PDUTYPE_DATAPDU | TS_PROTOCOL_VERSION;
        pBitmapCacheErrorPDU->shareDataHeader.shareControlHeader.totalLength = PktLen;
        pBitmapCacheErrorPDU->shareDataHeader.shareControlHeader.pduSource =
                _pUi->UI_GetClientMCSID();
        pBitmapCacheErrorPDU->shareDataHeader.shareID = _pUi->UI_GetShareID();
        pBitmapCacheErrorPDU->shareDataHeader.pad1 = 0;
        pBitmapCacheErrorPDU->shareDataHeader.streamID = TS_STREAM_LOW;
        pBitmapCacheErrorPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_BITMAPCACHE_ERROR_PDU;
        pBitmapCacheErrorPDU->shareDataHeader.generalCompressedType = 0;
        pBitmapCacheErrorPDU->shareDataHeader.generalCompressedLength = 0;

        pBitmapCacheErrorPDU->NumInfoBlocks = 1;
        pBitmapCacheErrorPDU->Pad1 = 0;
        pBitmapCacheErrorPDU->Pad2 = 0;

        pBitmapCacheErrorPDU->Info[0].CacheID = (TSUINT8) cacheId;
        pBitmapCacheErrorPDU->Info[0].bFlushCache = 1;
        pBitmapCacheErrorPDU->Info[0].bNewNumEntriesValid = 0;
        pBitmapCacheErrorPDU->Info[0].Pad1 = 0;
        pBitmapCacheErrorPDU->Info[0].Pad2 = 0;
        pBitmapCacheErrorPDU->Info[0].NewNumEntries = 0;

        TRC_NRM((TB, _T("Send bitmap cache error PDU")));

        _pSl->SL_SendPacket((PDCUINT8)pBitmapCacheErrorPDU, PktLen, RNS_SEC_ENCRYPT,
                hBuffer, _pUi->UI_GetClientMCSID(), _pUi->UI_GetChannelID(), TS_MEDPRIORITY);

        rc = TRUE;
    }
    else {
        TRC_ALT((TB, _T("Failed to alloc bitmap cache error packet")));
        pBitmapCacheErrorPDU = NULL;
    }

    DC_END_FN();
    return rc;
}

#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

/**************************************************************************/
// UHSendOffscrCacheErrorPDU
//
// Send an offscreen cache error pdu to request the server to disable
// offscreen rendering and refresh the screen
/**************************************************************************/
BOOL DCINTERNAL CUH::UHSendOffscrCacheErrorPDU(unsigned unused)
{
    unsigned short PktLen;
    SL_BUFHND hBuffer;
    PTS_OFFSCRCACHE_ERROR_PDU pOffscrCacheErrorPDU;
    BOOL rc = FALSE;
    UNREFERENCED_PARAMETER(unused);

    DC_BEGIN_FN("UHSendOffscrCacheErrorPDU");

    if (!_UH.sendOffscrCacheErrorPDU) {
        PktLen = sizeof(TS_OFFSCRCACHE_ERROR_PDU);
        if (_pSl->SL_GetBuffer(PktLen, (PPDCUINT8)&pOffscrCacheErrorPDU, &hBuffer)) {
            TRC_NRM((TB, _T("Successfully alloc'd offscreen cache error packet")));

            pOffscrCacheErrorPDU->shareDataHeader.shareControlHeader.pduType =
                    TS_PDUTYPE_DATAPDU | TS_PROTOCOL_VERSION;
            pOffscrCacheErrorPDU->shareDataHeader.shareControlHeader.totalLength = PktLen;
            pOffscrCacheErrorPDU->shareDataHeader.shareControlHeader.pduSource =
                    _pUi->UI_GetClientMCSID();
            pOffscrCacheErrorPDU->shareDataHeader.shareID = _pUi->UI_GetShareID();
            pOffscrCacheErrorPDU->shareDataHeader.pad1 = 0;
            pOffscrCacheErrorPDU->shareDataHeader.streamID = TS_STREAM_LOW;
            pOffscrCacheErrorPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_OFFSCRCACHE_ERROR_PDU;
            pOffscrCacheErrorPDU->shareDataHeader.generalCompressedType = 0;
            pOffscrCacheErrorPDU->shareDataHeader.generalCompressedLength = 0;

            pOffscrCacheErrorPDU->flags = 1;

            TRC_NRM((TB, _T("Send offscreen cache error PDU")));

            _pSl->SL_SendPacket((PDCUINT8)pOffscrCacheErrorPDU, PktLen, RNS_SEC_ENCRYPT,
                          hBuffer, _pUi->UI_GetClientMCSID(), _pUi->UI_GetChannelID(), TS_MEDPRIORITY);

            _UH.sendOffscrCacheErrorPDU = TRUE;

            rc = TRUE;
        } else {
            TRC_ALT((TB, _T("Failed to alloc offscreen cache error packet")));
            pOffscrCacheErrorPDU = NULL;
        }
    }

    DC_END_FN();
    return rc;
}

#ifdef DRAW_NINEGRID
/**************************************************************************/
// UHSendDrawNineGridErrorPDU
//
// Send an drawninegrid cache error pdu to request the server to disable
// drawninegrid rendering and refresh the screen
/**************************************************************************/
BOOL DCINTERNAL CUH::UHSendDrawNineGridErrorPDU(unsigned unused)
{
    unsigned short PktLen;
    SL_BUFHND hBuffer;
    PTS_DRAWNINEGRID_ERROR_PDU pDNGErrorPDU;
    BOOL rc = FALSE;
    UNREFERENCED_PARAMETER(unused);

    DC_BEGIN_FN("UHSendDrawNineGridErrorPDU");

    if (!_UH.sendDrawNineGridErrorPDU) {
        PktLen = sizeof(TS_DRAWNINEGRID_ERROR_PDU);
        if (_pSl->SL_GetBuffer(PktLen, (PPDCUINT8)&pDNGErrorPDU, &hBuffer)) {
            TRC_NRM((TB, _T("Successfully alloc'd drawninegrid error packet")));

            pDNGErrorPDU->shareDataHeader.shareControlHeader.pduType =
                    TS_PDUTYPE_DATAPDU | TS_PROTOCOL_VERSION;
            pDNGErrorPDU->shareDataHeader.shareControlHeader.totalLength = PktLen;
            pDNGErrorPDU->shareDataHeader.shareControlHeader.pduSource =
                    _pUi->UI_GetClientMCSID();
            pDNGErrorPDU->shareDataHeader.shareID = _pUi->UI_GetShareID();
            pDNGErrorPDU->shareDataHeader.pad1 = 0;
            pDNGErrorPDU->shareDataHeader.streamID = TS_STREAM_LOW;
            pDNGErrorPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_DRAWNINEGRID_ERROR_PDU;
            pDNGErrorPDU->shareDataHeader.generalCompressedType = 0;
            pDNGErrorPDU->shareDataHeader.generalCompressedLength = 0;

            pDNGErrorPDU->flags = 1;

            TRC_NRM((TB, _T("Send drawninegrid error PDU")));

            _pSl->SL_SendPacket((PDCUINT8)pDNGErrorPDU, PktLen, RNS_SEC_ENCRYPT,
                          hBuffer, _pUi->UI_GetClientMCSID(), _pUi->UI_GetChannelID(), TS_MEDPRIORITY);

            _UH.sendDrawNineGridErrorPDU = TRUE;

            rc = TRUE;
        } else {
            TRC_ALT((TB, _T("Failed to alloc drawninegrid error packet")));
            pDNGErrorPDU = NULL;
        }
    }

    DC_END_FN();
    return rc;
}
#endif

#ifdef DRAW_GDIPLUS
/**************************************************************************/
// UHSendDrawGdiplusErrorPDU
//
// Send an drawgdiplus cache error pdu to request the server to disable
// drawgdiplus rendering and refresh the screen
/**************************************************************************/
BOOL DCINTERNAL CUH::UHSendDrawGdiplusErrorPDU(unsigned unused)
{
    unsigned short PktLen;
    SL_BUFHND hBuffer;
    PTS_DRAWGDIPLUS_ERROR_PDU pGdipErrorPDU;
    BOOL rc = FALSE;
    UNREFERENCED_PARAMETER(unused);

    DC_BEGIN_FN("UHSendDrawGdiplusErrorPDU");

    if (!_UH.fSendDrawGdiplusErrorPDU) {
        PktLen = sizeof(TS_DRAWGDIPLUS_ERROR_PDU);
        if (_pSl->SL_GetBuffer(PktLen, (PPDCUINT8)&pGdipErrorPDU, &hBuffer)) {
            TRC_NRM((TB, _T("Successfully alloc'd drawgdiplus error packet")));

            pGdipErrorPDU->shareDataHeader.shareControlHeader.pduType =
                    TS_PDUTYPE_DATAPDU | TS_PROTOCOL_VERSION;
            pGdipErrorPDU->shareDataHeader.shareControlHeader.totalLength = PktLen;
            pGdipErrorPDU->shareDataHeader.shareControlHeader.pduSource =
                    _pUi->UI_GetClientMCSID();
            pGdipErrorPDU->shareDataHeader.shareID = _pUi->UI_GetShareID();
            pGdipErrorPDU->shareDataHeader.pad1 = 0;
            pGdipErrorPDU->shareDataHeader.streamID = TS_STREAM_LOW;
            pGdipErrorPDU->shareDataHeader.pduType2 = TS_PDUTYPE2_DRAWGDIPLUS_ERROR_PDU;
            pGdipErrorPDU->shareDataHeader.generalCompressedType = 0;
            pGdipErrorPDU->shareDataHeader.generalCompressedLength = 0;

            pGdipErrorPDU->flags = 1;

            TRC_NRM((TB, _T("Send drawgdiplus error PDU")));

            _pSl->SL_SendPacket((PDCUINT8)pGdipErrorPDU, PktLen, RNS_SEC_ENCRYPT,
                          hBuffer, _pUi->UI_GetClientMCSID(), _pUi->UI_GetChannelID(), TS_MEDPRIORITY);

            _UH.fSendDrawGdiplusErrorPDU = TRUE;

            rc = TRUE;
        } else {
            TRC_ALT((TB, _T("Failed to alloc drawgdiplus error packet")));
            pGdipErrorPDU = NULL;
        }
    }

    DC_END_FN();
    return rc;
}
#endif


/**************************************************************************/
// UHCacheBitmap
//
// Depending on whether it is a rev1 or rev2 order, we cache the bitmap
// in memory and save it to disk if it is persistent
/**************************************************************************/
// SECURITY 550811: Caller must verify cacheId and cacheIndex
HRESULT DCINTERNAL CUH::UHCacheBitmap(
        UINT cacheId,
        UINT32 cacheIndex,
        TS_SECONDARY_ORDER_HEADER *pHdr,
        PUHBITMAPINFO pBitmapInfo,
        PBYTE pBitmapData)
{
    HRESULT hr = S_OK;
    PUHBITMAPCACHEENTRYHDR pCacheEntryHdr;
    BYTE FAR *pCacheEntryData;

    DC_BEGIN_FN("UHCacheBitmap");

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

    // Check if this bitmap should be placed in the bitmap cache or not
    // If the noCacheFlag is set, we use the last entry of the bitmapcache
    // for this noncachable bitmap for temp storage.
    if (pHdr->extraFlags & TS_CacheBitmapRev2_bNotCacheFlag &&
        _UH.BitmapCacheVersion > TS_BITMAPCACHE_REV1 ) {
        pCacheEntryHdr = &_UH.bitmapCache[cacheId].Header[
                _UH.bitmapCache[cacheId].BCInfo.NumEntries];
        pCacheEntryData = _UH.bitmapCache[cacheId].Entries +
                UHGetOffsetIntoCache(
                _UH.bitmapCache[cacheId].BCInfo.NumEntries, cacheId);

        goto ProcessBitmapData;
    }

    if (_UH.bitmapCache[cacheId].BCInfo.bSendBitmapKeys) {
        ULONG                   memEntry;
        PUHBITMAPCACHEPTE       pPTE;

        // The persistent key for this cache is set.  So we need to update
        // the page table as well as cache the bitmap into memory
        pPTE = &(_UH.bitmapCache[cacheId].PageTable.PageEntries[cacheIndex]);

        TRC_NRM((TB,_T("K1: 0x%x K2: 0x%x (w/h %d,%d)"),
                 pBitmapInfo->Key1,
                 pBitmapInfo->Key2,
                 pBitmapInfo->bitmapWidth,
                 pBitmapInfo->bitmapHeight ));

#ifdef DC_DEBUG
        if (pPTE->bmpInfo.Key1 != 0 && pPTE->bmpInfo.Key2 != 0) {
            // Server side eviction.
            UHCacheEntryEvictedFromDisk((unsigned)cacheId, cacheIndex);
        }
#endif

        if (pPTE->iEntryToMem < _UH.bitmapCache[cacheId].BCInfo.NumEntries) {
            // we are evicting an entry that are already in memory,
            // so we can simply use the memory to cache our bitmap
            memEntry = pPTE->iEntryToMem;
        }
        else {
            // we need to find a free cache memory or evict an existing
            // entry so that we can cache this entry in memory
            TRC_ASSERT((pPTE->iEntryToMem == _UH.bitmapCache[cacheId].BCInfo.NumEntries),
                    (TB, _T("Page Table %d entry %d is broken"), cacheId, cacheIndex));
            // see if we can find a free memory entry
            memEntry = UHFindFreeCacheEntry(cacheId);

            if (memEntry >= _UH.bitmapCache[cacheId].BCInfo.NumEntries) {
                // all cache memory entries are full.
                // We need to evict an entry from the cache memory
                memEntry = UHEvictLRUCacheEntry(cacheId);

                TRC_ASSERT((memEntry < _UH.bitmapCache[cacheId].BCInfo.NumEntries),
                           (TB, _T("MRU list is broken")));
            }
        }

        // update the mru list
        UHTouchMRUCacheEntry(cacheId, cacheIndex);

        // update the page table entry
        (pPTE->bmpInfo).Key1 = pBitmapInfo->Key1;
        (pPTE->bmpInfo).Key2 = pBitmapInfo->Key2;
        pPTE->iEntryToMem = memEntry;

        // Since this bitmap cache is persistent, we need to save this bitmap
        // to disk.

        // try to save the bitmap on disk
#ifndef VM_BMPCACHE
        if (UHSavePersistentBitmap(_UH.bitmapCache[cacheId].PageTable.CacheFileInfo.hCacheFile,
#else
        if (UHSavePersistentBitmap(cacheId,
#endif
                cacheIndex * (UH_CellSizeFromCacheID(cacheId) + sizeof(UHBITMAPFILEHDR)),
                pBitmapData, pHdr->extraFlags & TS_EXTRA_NO_BITMAP_COMPRESSION_HDR, pBitmapInfo)) {
            TRC_NRM((TB, _T("bitmap file %s is saved on disk"), _UH.PersistCacheFileName));
        }
        else {
            TRC_ERR((TB, _T("failed to save the bitmap file on disk")));

            // if this is the first time we failed to save the bitmap on disk,
            // we should display a warning message to the user.
            if (!_UH.bWarningDisplayed) {
                _UH.bWarningDisplayed = TRUE;


                _pCd->CD_DecoupleSimpleNotification(CD_UI_COMPONENT,
                        _pUi, CD_NOTIFICATION_FUNC(CUI,UI_DisplayBitmapCacheWarning), 0);
            }
        }

        // set where bitmap bits should be located
        pCacheEntryHdr = &_UH.bitmapCache[cacheId].Header[memEntry];
        #ifdef DC_HICOLOR
        pCacheEntryData = _UH.bitmapCache[cacheId].Entries +
                          UHGetOffsetIntoCache(memEntry, cacheId);
        #else
        pCacheEntryData = _UH.bitmapCache[cacheId].Entries + memEntry *
                UH_CellSizeFromCacheID(cacheId);
        #endif
    }
    else {
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
        // set where bitmap bits should be locatedvalues
        pCacheEntryHdr = &_UH.bitmapCache[cacheId].Header[cacheIndex];
#ifdef DC_HICOLOR
        pCacheEntryData = _UH.bitmapCache[cacheId].Entries +
                          UHGetOffsetIntoCache(cacheIndex, cacheId);
#else
        pCacheEntryData = _UH.bitmapCache[cacheId].Entries + cacheIndex *
                UH_CellSizeFromCacheID(cacheId);
#endif //DC_HICOLOR
#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    }
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))


ProcessBitmapData:

    // Fill in the bitmap header info for this cache entry
    pCacheEntryHdr->bitmapWidth  = (DCUINT16)pBitmapInfo->bitmapWidth;
    pCacheEntryHdr->bitmapHeight = (DCUINT16)pBitmapInfo->bitmapHeight;
    pCacheEntryHdr->hasData = TRUE;

#ifdef DC_HICOLOR
    // Calculate the decompressed bitmap length.
    pCacheEntryHdr->bitmapLength = pBitmapInfo->bitmapWidth *
                                   pBitmapInfo->bitmapHeight *
                                   _UH.copyMultiplier;
#else
    // Calculate the decompressed bitmap length.  The bitmap is always at
    // 8bpp.
    pCacheEntryHdr->bitmapLength = pBitmapInfo->bitmapWidth *
                                   pBitmapInfo->bitmapHeight;
#endif    

    // Store the bitmap bits in the target cache cell.
    if (pHdr->orderType == TS_CACHE_BITMAP_COMPRESSED_REV2 ||
            pHdr->orderType == TS_CACHE_BITMAP_COMPRESSED) {
        // Decompress the bitmap into the target cache cell.
        TRC_NRM((TB, _T("Decompress %u:%u (%u -> %u bytes) (%u x %u)"),
                cacheId, cacheIndex, pBitmapInfo->bitmapLength,
                pCacheEntryHdr->bitmapLength, pBitmapInfo->bitmapWidth,
                pBitmapInfo->bitmapHeight));

        if(pCacheEntryHdr->bitmapLength >
            (unsigned)UH_CellSizeFromCacheID(cacheId)) {
            TRC_ABORT((TB, _T("Bitmap bits too large for cell! (cacheid=%u, len=%u, ")
                _T("cell size=%u)"), cacheId, pCacheEntryHdr->bitmapLength,
                UH_CellSizeFromCacheID(cacheId)));
            hr = E_TSC_CORE_CACHEVALUE;
            DC_QUIT;
        }
           
#ifdef DC_HICOLOR
        hr = BD_DecompressBitmap(pBitmapData,
                            pCacheEntryData,
                            (UINT) pBitmapInfo->bitmapLength,
                            pCacheEntryHdr->bitmapLength,
                            pHdr->extraFlags & TS_EXTRA_NO_BITMAP_COMPRESSION_HDR,
                            (DCUINT8)_UH.protocolBpp,
                            (DCUINT16)pBitmapInfo->bitmapWidth,
                            (DCUINT16)pBitmapInfo->bitmapHeight);
#else
        hr = BD_DecompressBitmap(pBitmapData, pCacheEntryData,
                (UINT) pBitmapInfo->bitmapLength,
                pCacheEntryHdr->bitmapLength,
                pHdr->extraFlags & TS_EXTRA_NO_BITMAP_COMPRESSION_HDR,
                8, pBitmapInfo->bitmapWidth, pBitmapInfo->bitmapHeight);
#endif
        DC_QUIT_ON_FAIL(hr);

    }
    else {
        // Copy the data.
        TRC_NRM((TB, _T("Memcpy %u:%u (%u bytes) (%u x %u)"),
                 (unsigned)cacheId, (unsigned)cacheIndex,
                 (unsigned)pBitmapInfo->bitmapLength,
                 (unsigned)pBitmapInfo->bitmapWidth,
                 (unsigned)pBitmapInfo->bitmapHeight));

        if(pBitmapInfo->bitmapLength >
            (unsigned)UH_CellSizeFromCacheID(cacheId)) {
            TRC_ABORT((TB, _T("Bitmap bits too large for cell! (cacheid=%u, len=%u, ")
                _T("cell size=%u)"), cacheId, pBitmapInfo->bitmapLength,
                UH_CellSizeFromCacheID(cacheId)));
            hr = E_TSC_CORE_CACHEVALUE;
            DC_QUIT;
        }
                   
        memcpy(pCacheEntryData, pBitmapData, pBitmapInfo->bitmapLength);
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}

inline HRESULT DCINTERNAL CUH::UHProcessCacheBitmapOrder(VOID *pOrder, 
    DCUINT orderLen)
{
    HRESULT hr = S_OK;
    UINT CacheID;
    UINT32 CacheIndex;
    PBYTE pBitmapData;
    UHBITMAPINFO BitmapInfo;
    TS_SECONDARY_ORDER_HEADER *pHdr;
    BYTE * pEnd = (BYTE *)pOrder + orderLen;

    DC_BEGIN_FN("UHProcessCacheBitmapOrder");

    // SECURITY: 552403
    CHECK_READ_N_BYTES(pOrder, pEnd, sizeof(TS_SECONDARY_ORDER_HEADER), hr,
        (TB, _T("Bad UHProcessCacheBitmapOrder; orderLen %u"), orderLen)); 

    // Decode the order based on whether it's revision 1 or 2. Unpack data
    // into the local variables. Note that if we receive a rev2 order
    // our global caps must have been set to rev2.
    pHdr = (TS_SECONDARY_ORDER_HEADER *)pOrder;
    if (pHdr->orderType == TS_CACHE_BITMAP_COMPRESSED_REV2 ||
            pHdr->orderType == TS_CACHE_BITMAP_UNCOMPRESSED_REV2)
    {
        PBYTE pDecode;
        TS_CACHE_BITMAP_ORDER_REV2_HEADER *pCacheOrderHdr;

        CHECK_READ_N_BYTES(pOrder, pEnd, sizeof(TS_CACHE_BITMAP_ORDER_REV2_HEADER), hr,
            (TB, _T("Bad UHProcessCacheBitmapOrder; orderLen %u"), orderLen));

        pCacheOrderHdr = (TS_CACHE_BITMAP_ORDER_REV2_HEADER *)pOrder;

        TRC_NRM((TB,_T("Rev2 cache bitmap order")));

        CacheID = (UINT) (pCacheOrderHdr->header.extraFlags &
                TS_CacheBitmapRev2_CacheID_Mask);

        // Check that bits per pel is what we expect.
#ifdef DC_HICOLOR
#else
        TRC_ASSERT(((pCacheOrderHdr->header.extraFlags &
                TS_CacheBitmapRev2_BitsPerPixelID_Mask) ==
                TS_CacheBitmapRev2_8BitsPerPel),
                (TB,_T("Invalid BitsPerPelID %d"), (pCacheOrderHdr->header.
                extraFlags & TS_CacheBitmapRev2_BitsPerPixelID_Mask)));
#endif

        // Grab or skip the key depending on the cache settings.
        if (pCacheOrderHdr->header.extraFlags &
                TS_CacheBitmapRev2_bKeyPresent_Mask)
        {
            BitmapInfo.Key1 = pCacheOrderHdr->Key1;
            BitmapInfo.Key2 = pCacheOrderHdr->Key2;
            pDecode = (PDCUINT8)pOrder +
                    sizeof(TS_CACHE_BITMAP_ORDER_REV2_HEADER);
        }
        else
        {
            BitmapInfo.Key1 = BitmapInfo.Key2 = 0;

            // Account for the lack of keys in the order sent.
            pDecode = (PDCUINT8)pOrder +
                    sizeof(TS_CACHE_BITMAP_ORDER_REV2_HEADER) -
                    2 * sizeof(TSUINT32);
        }

        // Decode the variable-length Width field.
        CHECK_READ_N_BYTES(pDecode, pEnd, sizeof(DCUINT16), hr,
            ( TB, _T("Decode off end of data") ));
        BitmapInfo.bitmapWidth = (DCUINT16) Decode2ByteField(&pDecode);

        // Height is present only if bHeightSameAsWidth is false.
        if (pCacheOrderHdr->header.extraFlags &
                TS_CacheBitmapRev2_bHeightSameAsWidth_Mask)
            BitmapInfo.bitmapHeight = BitmapInfo.bitmapWidth;
        else {
            CHECK_READ_N_BYTES(pDecode, pEnd, sizeof(DCUINT16), hr,
            ( TB, _T("Decode off end of data") ));
            
            BitmapInfo.bitmapHeight = (DCUINT16) Decode2ByteField(&pDecode);
        }

        // BitmapDataLength.
        CHECK_READ_N_BYTES(pDecode, pEnd, 6, hr,
                    ( TB, _T("Decode off end of data") ));        
        
        BitmapInfo.bitmapLength = Decode4ByteField(&pDecode);
//TODO: Not currently checking streaming flag or parsing the streaming extended info field.
        // CacheIndex.
        CacheIndex = Decode2ByteField(&pDecode);

        // Calculate pBitmapData.
        pBitmapData = pDecode;
    }
    else
    {
        TS_CACHE_BITMAP_ORDER *pCacheOrder;

        CHECK_READ_N_BYTES(pOrder, pEnd, sizeof(TS_CACHE_BITMAP_ORDER), hr,
            ( TB, _T("Bad UHProcessCacheBitmapOrder; orderLen %u"), orderLen)); 

        pCacheOrder = (TS_CACHE_BITMAP_ORDER *)pOrder;

        TRC_NRM((TB,_T("Rev1 cache bitmap order")));
        TRC_ASSERT((pCacheOrder->bitmapBitsPerPel == 8),
                (TB, _T("Invalid bitmapBitsPerPel: %u"),
                pCacheOrder->bitmapBitsPerPel));

        CacheID = pCacheOrder->cacheId;
        BitmapInfo.bitmapWidth = pCacheOrder->bitmapWidth;
        BitmapInfo.bitmapHeight = pCacheOrder->bitmapHeight;
        BitmapInfo.bitmapLength = pCacheOrder->bitmapLength;
        CacheIndex = pCacheOrder->cacheIndex;
        pBitmapData = pCacheOrder->bitmapData;

        // No hash keys in rev 1 order.
        BitmapInfo.Key1 = BitmapInfo.Key2 = 0;
    }
    
    TRC_DBG((TB, _T("Cache %u, entry %u, dataLength %u"), CacheID, CacheIndex,
            BitmapInfo.bitmapLength));

    // SECURITY 550811: Cache Index and ID must be verified
    hr = UHIsValidBitmapCacheID(CacheID);
    DC_QUIT_ON_FAIL(hr);

    hr = UHIsValidBitmapCacheIndex(CacheID, CacheIndex);
    DC_QUIT_ON_FAIL(hr);

    CHECK_READ_N_BYTES(pBitmapData, pEnd, BitmapInfo.bitmapLength, hr,
        (TB, _T("Bad UHProcessCacheBitmapOrder; orderLen %u"), orderLen));
        
    // cache this bitmap in cache memory
    hr = UHCacheBitmap(CacheID, CacheIndex, pHdr, &BitmapInfo, pBitmapData);
    DC_QUIT_ON_FAIL(hr);

#ifdef DC_DEBUG
    if (CacheIndex != BITMAPCACHE_WAITING_LIST_INDEX) {
        UHCacheDataReceived(CacheID, CacheIndex);
    }
#endif /* DC_DEBUG */

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}

/****************************************************************************/
// UHProcessCacheGlyphOrderRev2
//
// Handles new-format cache-glyph order containing tighter order packing.
/****************************************************************************/
inline int Decode2ByteSignedField(PDCUINT8 *ppDecode)
{
   int Val;

    // The first bit of the first byte indicates if the field is 1 byte or 2
    // bytes -- 0 if 1 byte.
    if (!(**ppDecode & 0x80)) {
        if (!(**ppDecode & 0x40)) {
            Val = **ppDecode;
        }
        else {
            Val = - (**ppDecode & 0x3F);
        }
        (*ppDecode)++;
    }
    else {
        Val = ((**ppDecode & 0x3F) << 8) | *(*ppDecode + 1);

        if ((**ppDecode & 0x40)) {
            Val = -Val;
        }
        (*ppDecode) += 2;
    }

    return Val;
}

HRESULT DCAPI CUH::UHIsValidGlyphCacheIDIndex(unsigned cacheId, 
    unsigned cacheIndex) 
{
    HRESULT hr = UHIsValidGlyphCacheID(cacheId);
    if (SUCCEEDED(hr)) {
        hr = cacheIndex < _pCc->_ccCombinedCapabilities.glyphCacheCapabilitySet.GlyphCache[cacheId].CacheEntries ?
            S_OK : E_TSC_CORE_CACHEVALUE;
    }
    return  hr;
}

HRESULT DCAPI CUH::UHIsValidOffsreenBitmapCacheIndex(unsigned cacheIndex)
{
    return cacheIndex < 
        _pCc->_ccCombinedCapabilities.offscreenCapabilitySet.offscreenCacheEntries ? 
        S_OK : E_TSC_CORE_CACHEVALUE;
}

HRESULT DCINTERNAL CUH::UHProcessCacheGlyphOrderRev2(
        BYTE cacheId,
        unsigned cGlyphs,
        BYTE FAR *pGlyphDataOrder,
        unsigned length)
{
    HRESULT hr = S_OK;
    UINT16 i;
    BYTE FAR *pGlyphData;
    unsigned cbDataSize, cacheIndex;
    HPDCUINT8             pCacheEntryData;
    PUHGLYPHCACHEENTRYHDR pCacheEntryHdr;
    HPUHGLYPHCACHE        pCache;
    UINT16 UNALIGNED FAR *pUnicode;
    PBYTE pEnd = (BYTE*)pGlyphDataOrder + length;

    DC_BEGIN_FN("UHProcessCacheGlyphOrderRev2");

    // SECURITY 550811 - must validate cacheIndex
    hr = UHIsValidGlyphCacheID(cacheId);
    DC_QUIT_ON_FAIL(hr);

    pCache = &(_UH.glyphCache[cacheId]);
    pGlyphData = pGlyphDataOrder;

    pUnicode = (UINT16 UNALIGNED FAR *)(pGlyphData + length - cGlyphs *
            sizeof(UINT16));

    for (i = 0; i < cGlyphs; i++) {

        cacheIndex = *pGlyphData++;

        hr = UHIsValidGlyphCacheIDIndex(cacheId, cacheIndex);
        DC_QUIT_ON_FAIL(hr);

        pCacheEntryHdr  = &(pCache->pHdr[cacheIndex]);
        pCacheEntryData = &(pCache->pData[cacheIndex * pCache->cbEntrySize]);

        // Copy the data.
        pCacheEntryHdr->unicode = 0;
        CHECK_READ_N_BYTES(pGlyphData, pEnd, 8, hr,
            (TB, _T("Read past end of data")));

        pCacheEntryHdr->x  = Decode2ByteSignedField(&pGlyphData);
        pCacheEntryHdr->y  = Decode2ByteSignedField(&pGlyphData);
        pCacheEntryHdr->cx = Decode2ByteField(&pGlyphData);
        pCacheEntryHdr->cy = Decode2ByteField(&pGlyphData);

        cbDataSize = (unsigned)(((pCacheEntryHdr->cx + 7) / 8) *
                pCacheEntryHdr->cy);
        cbDataSize = (cbDataSize + 3) & ~3;

        if (cbDataSize > pCache->cbEntrySize) {
            TRC_ABORT((TB, _T("Invalid cache cbDataSize: %u, %u"), cbDataSize,
               pCache->cbEntrySize));
            hr = E_TSC_CORE_LENGTH;
            DC_QUIT;
        }

        CHECK_READ_N_BYTES(pGlyphData, pEnd, cbDataSize, hr,
            (TB, _T("Read past end of glyph data")));

        memcpy(pCacheEntryData, pGlyphData, cbDataSize);

        pGlyphData += cbDataSize;

        pCacheEntryHdr->unicode = *pUnicode;
        pUnicode++;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
/* Name:      UHProcessCacheGlyphOrder                                      */
/*                                                                          */
/* Purpose:   Processes a received CacheGlyphe order by storing the given   */
/*            glyphs in the requested cache                                 */
/*                                                                          */
/* Params:    pOrder - pointer to the CacheGlyph order                      */
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHProcessCacheGlyphOrder(PTS_CACHE_GLYPH_ORDER pOrder, 
    DCUINT orderLen)
{
    HRESULT hr = S_OK;
    UINT16                i;
    unsigned              cbDataSize;
    PUHGLYPHCACHEENTRYHDR pCacheEntryHdr;
    HPDCUINT8             pCacheEntryData;
    HPUHGLYPHCACHE        pCache;
    PTS_CACHE_GLYPH_DATA  pGlyphData;
    UINT16 UNALIGNED FAR *pUnicode;
    BYTE *              pEnd = (BYTE *)pOrder + orderLen;

    DC_BEGIN_FN("UHProcessCacheGlyphOrder");

    hr = UHIsValidGlyphCacheID(pOrder->cacheId);
    DC_QUIT_ON_FAIL(hr);

    pCache = &(_UH.glyphCache[pOrder->cacheId]);   
    pGlyphData = pOrder->glyphData;

    for (i = 0; i < pOrder->cGlyphs; i++) {      
        
        CHECK_READ_N_BYTES(pGlyphData, pEnd, FIELDOFFSET(TS_CACHE_GLYPH_DATA, aj), hr,
            ( TB, _T("Bad glyph length")));


        hr = UHIsValidGlyphCacheIDIndex(pOrder->cacheId, pGlyphData->cacheIndex);
        DC_QUIT_ON_FAIL(hr);
        
        cbDataSize = ((pGlyphData->cx + 7) / 8) * pGlyphData->cy;
        cbDataSize = (cbDataSize + 3) & ~3;

        // SECURITY: 552403
        CHECK_READ_N_BYTES(pGlyphData, pEnd, FIELDOFFSET(TS_CACHE_GLYPH_DATA, aj) + cbDataSize, hr,
            ( TB, _T("Bad glyph length")));

        // SECURITY: 552403
        if(cbDataSize > pCache->cbEntrySize) {
            TRC_ABORT((TB, _T("Invalid cache cbDataSize: %u, %u"), cbDataSize,
                pCache->cbEntrySize));
            hr = E_TSC_CORE_LENGTH;
            DC_QUIT;
        }
                
        pCacheEntryHdr  = &(pCache->pHdr[pGlyphData->cacheIndex]);
        pCacheEntryData = &(pCache->pData[pGlyphData->cacheIndex *
                pCache->cbEntrySize]);

        // Copy the data.
        pCacheEntryHdr->unicode = 0;
        pCacheEntryHdr->x  = pGlyphData->x;
        pCacheEntryHdr->y  = pGlyphData->y;
        pCacheEntryHdr->cx = pGlyphData->cx;
        pCacheEntryHdr->cy = pGlyphData->cy;

        memcpy(pCacheEntryData, pGlyphData->aj, cbDataSize);

        pGlyphData = (PTS_CACHE_GLYPH_DATA)(&pGlyphData->aj[cbDataSize]);
    }

    pUnicode = (UINT16 UNALIGNED FAR *)pGlyphData;

    if (pOrder->header.extraFlags & TS_EXTRA_GLYPH_UNICODE) {

        // SECURITY: 552403
        CHECK_READ_N_BYTES(pUnicode, pEnd, pOrder->cGlyphs * sizeof(UINT16), hr,
            (TB, _T("Unicode data length larger than packet")));
        
        pGlyphData = pOrder->glyphData;

        for (i = 0; i < pOrder->cGlyphs; i++) {
            pCacheEntryHdr = &(pCache->pHdr[pGlyphData->cacheIndex]);
            pCacheEntryHdr->unicode = *pUnicode;
            pUnicode++;

            cbDataSize = ((pGlyphData->cx + 7) / 8) * pGlyphData->cy;
            cbDataSize = (cbDataSize + 3) & ~3;

            if (cbDataSize > pCache->cbEntrySize) {   
                TRC_ABORT((TB, _T("Invalid cache cbDataSize: %u, %u"), cbDataSize,
                    pCache->cbEntrySize));
                hr = E_TSC_CORE_LENGTH;
                DC_QUIT;
            }
            pGlyphData = (PTS_CACHE_GLYPH_DATA)(&pGlyphData->aj[cbDataSize]);
       }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
/* Name:      UHProcessCacheBrushOrder                                      */
/*                                                                          */
/* Purpose:   Processes a received cached brush order by storing the given  */
/*            brush in the requested cache                                  */
/*                                                                          */
/* Params:    pOrder - pointer to the CacheBrush order                      */
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHProcessCacheBrushOrder(
    const TS_CACHE_BRUSH_ORDER *pOrder,  DCUINT orderLen)
{
    HRESULT hr = S_OK;
    UINT32 entry;
    PBYTE pData;
    PBYTE pEnd = (BYTE*)pOrder + orderLen;

    DC_BEGIN_FN("UHProcessCacheBrushOrder");

    entry = pOrder->cacheEntry;

#if defined (OS_WINCE)
    _UH.validBrushDC = NULL;
#endif

    // SECURITY: 552403
    CHECK_READ_N_BYTES(pOrder,pEnd,FIELDOFFSET(TS_CACHE_BRUSH_ORDER,brushData) +
        pOrder->iBytes, hr,
        (TB, _T("Invalid UHProcessCacheBrushOrder: OrderLen %u"), orderLen ));

    switch (pOrder->iBitmapFormat) {

    // monochrome brush (BMF_1BPP)
    case 1:       
        hr = UHIsValidMonoBrushCacheIndex(pOrder->cacheEntry);
        DC_QUIT_ON_FAIL(hr);
        
        TRC_NRM((TB, _T("Mono Brush[%ld]: format(%ld), cx(%ld), cy(%ld), bytes(%ld)"),
                entry, pOrder->iBitmapFormat, pOrder->cx, pOrder->cy, pOrder->iBytes));

        _UH.pMonoBrush[entry].hdr.iBitmapFormat = pOrder->iBitmapFormat;
        _UH.pMonoBrush[entry].hdr.cx = pOrder->cx;
        _UH.pMonoBrush[entry].hdr.cy = pOrder->cy;
        _UH.pMonoBrush[entry].hdr.iBytes = pOrder->iBytes;

        // reverse the row order since we use SetBitmapBits / CreateBitmap later
        memset(_UH.pMonoBrush[entry].data, 0, sizeof(_UH.pMonoBrush[entry].data));
        pData = _UH.pMonoBrush[entry].data;
        pData[14] = pOrder->brushData[0];
        pData[12] = pOrder->brushData[1];
        pData[10] = pOrder->brushData[2];
        pData[8]  = pOrder->brushData[3];
        pData[6]  = pOrder->brushData[4];
        pData[4]  = pOrder->brushData[5];
        pData[2]  = pOrder->brushData[6];
        pData[0]  = pOrder->brushData[7];
        break;

    // 256 color brush (BMF_8BPP)
    case 3:
        {
            DCUINT32 i;

            hr = UHIsValidColorBrushCacheIndex(pOrder->cacheEntry);
            DC_QUIT_ON_FAIL(hr);

            TRC_NRM((TB, _T("Color Brush[%ld]: format(%ld), cx(%ld), cy(%ld), bytes(%ld)"),
                    entry, pOrder->iBitmapFormat, pOrder->cx, pOrder->cy, pOrder->iBytes));

            _UH.pColorBrush[entry].hdr.iBitmapFormat = pOrder->iBitmapFormat;
            _UH.pColorBrush[entry].hdr.cx = pOrder->cx;
            _UH.pColorBrush[entry].hdr.cy = pOrder->cy;

            // Unpack the data if necessary
            pData = _UH.pColorBrush[entry].data;
            if (pOrder->iBytes == 20) {
                DCUINT32 currIndex ;
                DCUINT8  decode[4], color;

                // get the decoding table from the end of the list
                for (i = 0; i < 4; i++) {
                    decode[i] = pOrder->brushData[16 + i];
                }

                // unpack to 1 pixel per byte
                for (i = 0; i < 16; i++) {
                    currIndex = i * 4;
                    color = pOrder->brushData[i];
                    pData[currIndex] = decode[(color & 0xC0) >> 6];
                    pData[currIndex + 1] = decode[(color & 0x30) >> 4];
                    pData[currIndex + 2] = decode[(color & 0x0C) >> 2] ;
                    pData[currIndex + 3] = decode[(color & 0x03)];
                }
                _UH.pColorBrush[entry].hdr.iBytes = 64;
            }

            // Else brush is non-encoded byte stream
            else {
                if (pOrder->iBytes > sizeof(_UH.pColorBrush[entry].data)) {
                    TRC_ABORT((TB, _T("Invalid color brush iBytes: %u"), pOrder->iBytes));
                    hr = E_TSC_CORE_LENGTH;
                    DC_QUIT;            
                }
                
                _UH.pColorBrush[entry].hdr.iBytes = pOrder->iBytes;
                memcpy(pData, pOrder->brushData, pOrder->iBytes);
            }
        }
        break;

#ifdef DC_HICOLOR
    // 16bpp brush (BMF_16BPP)
    case 4:
    {
        DCUINT32 i;

        hr = UHIsValidColorBrushCacheIndex(pOrder->cacheEntry);
        DC_QUIT_ON_FAIL(hr);

        TRC_NRM((TB, _T("Color Brush[%ld]: format(%ld), cx(%ld), cy(%ld), bytes(%ld)"),
                entry, pOrder->iBitmapFormat, pOrder->cx, pOrder->cy, pOrder->iBytes));

        _UH.pColorBrush[entry].hdr.iBitmapFormat = pOrder->iBitmapFormat;
        _UH.pColorBrush[entry].hdr.cx = pOrder->cx;
        _UH.pColorBrush[entry].hdr.cy = pOrder->cy;

        // Unpack the data if necessary
        pData = _UH.pColorBrush[entry].data;

        if (pOrder->iBytes == 24)
        {
            DCUINT32  currIndex ;
            DCUINT8   color;
            PDCUINT16 pIntoData    = (PDCUINT16)pData;
            UINT16 UNALIGNED *pDecodeTable = (UINT16 UNALIGNED *)&(pOrder->brushData[16]);

            // unpack to 2 bytes per pel
            for (i = 0; i < 16; i++)
            {
                color     = pOrder->brushData[i];

                currIndex = i * 4; // we decode 4 bytes at a pass

                pIntoData[currIndex]     = pDecodeTable[(color & 0xC0) >> 6];
                pIntoData[currIndex + 1] = pDecodeTable[(color & 0x30) >> 4];
                pIntoData[currIndex + 2] = pDecodeTable[(color & 0x0C) >> 2] ;
                pIntoData[currIndex + 3] = pDecodeTable[(color & 0x03)];
            }
            _UH.pColorBrush[entry].hdr.iBytes = 128;
        }

        // Else brush is non-encoded byte stream
        else
        {
            if (pOrder->iBytes > sizeof(_UH.pColorBrush[entry].data)) {
                TRC_ABORT((TB, _T("Invalid color brush iBytes: %u"), pOrder->iBytes));
                hr = E_TSC_CORE_LENGTH;
                DC_QUIT;            
            }
            
            _UH.pColorBrush[entry].hdr.iBytes = pOrder->iBytes;
            memcpy(pData, pOrder->brushData, pOrder->iBytes);
        }
    }
    break;

    // 24bpp brush (BMF_24BPP)
    case 5:
    {
        DCUINT32 i;

        hr = UHIsValidColorBrushCacheIndex(pOrder->cacheEntry);
        DC_QUIT_ON_FAIL(hr);
        
        TRC_NRM((TB, _T("Color Brush[%ld]: format(%ld), cx(%ld), cy(%ld), bytes(%ld)"),
                entry, pOrder->iBitmapFormat, pOrder->cx, pOrder->cy, pOrder->iBytes));

        _UH.pColorBrush[entry].hdr.iBitmapFormat = pOrder->iBitmapFormat;
        _UH.pColorBrush[entry].hdr.cx = pOrder->cx;
        _UH.pColorBrush[entry].hdr.cy = pOrder->cy;

        // Unpack the data if necessary
        pData = _UH.pColorBrush[entry].data;

        if (pOrder->iBytes == 28)
        {
            DCUINT32    currIndex;

            RGBTRIPLE * pIntoData    = (RGBTRIPLE *)pData;
            RGBTRIPLE * pDecodeTable = (RGBTRIPLE *)&(pOrder->brushData[16]);

            DCUINT8   color;

            // unpack to 3 bytes per pel
            for (i = 0; i < 16; i++)
            {
                color     = pOrder->brushData[i];

                currIndex = i * 4; // we decode 4 bytes at a pass

                pIntoData[currIndex]     = pDecodeTable[(color & 0xC0) >> 6];
                pIntoData[currIndex + 1] = pDecodeTable[(color & 0x30) >> 4];
                pIntoData[currIndex + 2] = pDecodeTable[(color & 0x0C) >> 2];
                pIntoData[currIndex + 3] = pDecodeTable[(color & 0x03)];
            }
            _UH.pColorBrush[entry].hdr.iBytes = 192;
        }

        // Else brush is non-encoded byte stream
        else
        {
            if (pOrder->iBytes > sizeof(_UH.pColorBrush[entry].data)) {
                TRC_ABORT((TB, _T("Invalid color brush iBytes: %u"), pOrder->iBytes));
                hr = E_TSC_CORE_LENGTH;
                DC_QUIT;            
            }
            
            _UH.pColorBrush[entry].hdr.iBytes = pOrder->iBytes;
            memcpy(pData, pOrder->brushData, pOrder->iBytes);
        }
    }
    break;
#endif
    
    default:
        TRC_ASSERT((pOrder->iBitmapFormat == 1) ||
                   (pOrder->iBitmapFormat == 3),
                   (TB, _T("Invalid cached brush depth: %ld cacheId: %u"),
                    pOrder->iBitmapFormat, pOrder->cacheEntry));
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
/* Name:      UHProcessCacheColorTableOrder                                 */
/*                                                                          */
/* Purpose:   Processes a received CacheColorTable order by storing the     */
/*            color table in the local cache.                               */
/*                                                                          */
/* Params:    pOrder - pointer to the CacheColorTable order                 */
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHProcessCacheColorTableOrder(
        PTS_CACHE_COLOR_TABLE_ORDER pOrder, DCUINT orderLen)
{
    HRESULT hr = S_OK;
    unsigned i;
    PBYTE pEnd = (PBYTE)pOrder + orderLen;

    DC_BEGIN_FN("UHProcessCacheColorTableOrder");

    // Check that the cache index is within range.
    hr = UHIsValidColorTableCacheIndex(pOrder->cacheIndex);
    DC_QUIT_ON_FAIL(hr);

    // This PDU should only come down in an 8-bit connection.
    if (pOrder->numberColors != 256) {
            TRC_ABORT((TB, _T("Invalid numberColors: %u"), pOrder->numberColors));
            hr = E_TSC_CORE_PALETTE;         
            DC_QUIT;            
    }

    // SECURITY: 552403
    CHECK_READ_N_BYTES(pOrder, pEnd, pOrder->numberColors*sizeof(TS_COLOR_QUAD) +
            FIELDOFFSET(TS_CACHE_COLOR_TABLE_ORDER, colorTable),
            hr, ( TB, _T("Invalid UHProcessCacheColorTableOrder; packet size %u"), orderLen));

    // Copy the supplied color table data into the specified color table
    // cache entry.
    TRC_DBG((TB, _T("Updating color table cache %u"), pOrder->cacheIndex));
    for (i = 0; i < UH_NUM_8BPP_PAL_ENTRIES; i++) {
        // Definition of TS_RGB_QUAD in T.128 does not match what
        // server sends (RGB, should be BGR), so the assignments below are
        // swapped around to get the correct result.
        _UH.pColorTableCache[pOrder->cacheIndex].rgb[i].rgbtRed =
                pOrder->colorTable[i].blue;
        _UH.pColorTableCache[pOrder->cacheIndex].rgb[i].rgbtGreen =
                pOrder->colorTable[i].green;
        _UH.pColorTableCache[pOrder->cacheIndex].rgb[i].rgbtBlue =
                pOrder->colorTable[i].red;

        // We also have to avoid the problem of one of the system colors
        // mapping onto another color in the palette. We do this by
        // ensuring that no entries exactly match a system color.
        if (!UH_IS_SYSTEM_COLOR_INDEX(i)) {
            if (UHIsHighVGAColor(
                    _UH.pColorTableCache[pOrder->cacheIndex].rgb[i].rgbtRed,
                    _UH.pColorTableCache[pOrder->cacheIndex].rgb[i].rgbtGreen,
                    _UH.pColorTableCache[pOrder->cacheIndex].rgb[i].rgbtBlue))
            {
                UH_TWEAK_COLOR_COMPONENT(
                    _UH.pColorTableCache[pOrder->cacheIndex].rgb[i].rgbtBlue);
            }
        }
    }

    // Track the maximum color table id.
    _UH.maxColorTableId = DC_MAX(_UH.maxColorTableId, pOrder->cacheIndex);

    // Calculate a mapping table from the received color table to the
    // current palette.
    UHCalculateColorTableMapping(pOrder->cacheIndex);

DC_EXIT_POINT:    
    DC_END_FN();
    return hr;
}


/****************************************************************************/
// Name:      UHCreateOffscrBitmap                                 
//                                                                          
// Purpose:   Processes a received CreateOffscrBitmap order by creating the     
//            offscreen bitmap in the local cache. Returns the size of the
//            order to subtract from the encoding stream.
//
// Params:    pOrder - pointer to the CreateOffscrBitmap order.
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHCreateOffscrBitmap(
       PTS_CREATE_OFFSCR_BITMAP_ORDER pOrder,
       DCUINT   orderLen,
       unsigned *pOrderSize)
{
    HRESULT hr = S_OK;
    unsigned cacheId;
    HBITMAP  hBitmap = NULL;
    HDC      hdcDesktop = NULL;
    DCSIZE   desktopSize;
    unsigned OrderSize;
    PBYTE pEnd = (BYTE*)pOrder + orderLen;

    DC_BEGIN_FN("UHCreateOffscrBitmap");

    // Get the offscreen bitmap Id
    cacheId = pOrder->Flags & 0x7FFF;
    hr = UHIsValidOffsreenBitmapCacheIndex(cacheId);
    DC_QUIT_ON_FAIL(hr);

    // Check if bitmap delete list is appended, if so, delete the bitmaps 
    // first
    if (!(pOrder->Flags & 0x8000)) {
        OrderSize = sizeof(TS_CREATE_OFFSCR_BITMAP_ORDER) -
                sizeof(pOrder->variableBytes);
    }
    else {
        unsigned numBitmaps, i, bitmapId;
        TSUINT16 UNALIGNED *pData;

        CHECK_READ_N_BYTES(pOrder->variableBytes, pEnd, sizeof(TSUINT16), hr,
            (TB,_T("Not enough data to read number of delete bitmaps")));

        numBitmaps = pOrder->variableBytes[0];
        pData = (TSUINT16 UNALIGNED *)(pOrder->variableBytes);
        pData++;

        // SECURITY: 552403
        CHECK_READ_N_BYTES(pData, pEnd, sizeof(TSUINT16) * numBitmaps, hr,
            ( TB, _T("Bad bitmap count %u"), numBitmaps));

        for (i = 0; i < numBitmaps; i++) {
            bitmapId = *pData++;

            hr = UHIsValidOffsreenBitmapCacheIndex(bitmapId);
            DC_QUIT_ON_FAIL(hr);
            
            if (_UH.offscrBitmapCache[bitmapId].offscrBitmap != NULL) {
                SelectBitmap(_UH.hdcOffscreenBitmap, _UH.hUnusedOffscrBitmap);
                DeleteObject(_UH.offscrBitmapCache[bitmapId].offscrBitmap);
                _UH.offscrBitmapCache[bitmapId].offscrBitmap = NULL;
            }
        }

        OrderSize = sizeof(TS_CREATE_OFFSCR_BITMAP_ORDER) + sizeof(UINT16) *
                numBitmaps;
    }

    CHECK_READ_N_BYTES(pOrder, pEnd, OrderSize, hr,
        (TB, _T("offscreen size invalid: size %u; orderLen %u"),
            OrderSize, orderLen));

    // Get the current desktop size
    _pUi->UI_GetDesktopSize(&desktopSize);
    TRC_ASSERT((pOrder->cx <= desktopSize.width) && 
        (pOrder->cy <= desktopSize.height),
        (TB, _T("invalid offscreen dimensions [cx %u cy %u]")
        _T("[width %u height %u]"), pOrder->cx, pOrder->cy,
        desktopSize.width, desktopSize.height));

    TRC_NRM((TB, _T("Create an offscreen bitmap of size (%d, %d)"), pOrder->cx,
             pOrder->cy));
    // Delete the bitmap if there is one already exists.
    if (_UH.offscrBitmapCache[cacheId].offscrBitmap != NULL) {
        // JOYC: TODO: reuse bitmap
        //if (UH.offscrBitmapCache[cacheId].cx >= pOrder->cx &&
        //        UH.offscrBitmapCache[cacheId].cy >= pOrder->cy) {
        //    return;
        //}
        SelectBitmap(_UH.hdcOffscreenBitmap, _UH.hUnusedOffscrBitmap);  
        DeleteObject(_UH.offscrBitmapCache[cacheId].offscrBitmap);
        _UH.offscrBitmapCache[cacheId].offscrBitmap = NULL;
    }

    // Create an offscreen bitmap

#ifdef DISABLE_SHADOW_IN_FULLSCREEN
    if (!_UH.DontUseShadowBitmap && (_UH.hdcShadowBitmap != NULL)) {
#else // DISABLE_SHADOW_IN_FULLSCREEN
    if (_UH.hdcShadowBitmap != NULL) {
#endif // DISABLE_SHADOW_IN_FULLSCREEN
        hBitmap = CreateCompatibleBitmap(_UH.hdcShadowBitmap, pOrder->cx, pOrder->cy);
    }
    else {
        hBitmap = CreateCompatibleBitmap(_UH.hdcOutputWindow, pOrder->cx, pOrder->cy);
    }

    if (hBitmap != NULL) {
        DCCOLOR colorWhite;

        // set the unused bitmap
        if (_UH.hUnusedOffscrBitmap == NULL)
            _UH.hUnusedOffscrBitmap = SelectBitmap(_UH.hdcOffscreenBitmap,
                    hBitmap); 

        SelectBitmap(_UH.hdcOffscreenBitmap, hBitmap);
        
        //SetDIBColorTable(UH.hdcOffscreenBitmap,
        //                 0,
        //                 UH_NUM_8BPP_PAL_ENTRIES,
        //                 (RGBQUAD *)&UH.rgbQuadTable);

        if (_UH.protocolBpp <= 8) {
            SelectPalette(_UH.hdcOffscreenBitmap, _UH.hpalCurrent, FALSE);
        }
        
        colorWhite.u.rgb.blue = 255;
        colorWhite.u.rgb.green = 255;
        colorWhite.u.rgb.red = 255;

        UHUseBkColor(colorWhite, UH_COLOR_RGB, this);
        UHUseTextColor(colorWhite, UH_COLOR_RGB, this);

        _UH.offscrBitmapCache[cacheId].offscrBitmap = hBitmap;
        _UH.offscrBitmapCache[cacheId].cx = pOrder->cx;
        _UH.offscrBitmapCache[cacheId].cy = pOrder->cy;
    } else {
        // Unable to create the bitmap, send error pdu to the server
        // to disable offscreen rendering
        _UH.offscrBitmapCache[cacheId].offscrBitmap = NULL;
        _UH.offscrBitmapCache[cacheId].cx = 0;
        _UH.offscrBitmapCache[cacheId].cy = 0;

        if (!_UH.sendOffscrCacheErrorPDU)
            _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                    CD_NOTIFICATION_FUNC(CUH, UHSendOffscrCacheErrorPDU),
                    0);
    }

    *pOrderSize = OrderSize;

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}

/****************************************************************************/
// Name:      UHSwitchBitmapSurface                                 
//                                                                          
// Purpose:   Processes a received SwitchBitmapSurface order by switching the     
//            drawing surface (hdcDraw) to the right surface.                               
//                                                                          
// Params:    pOrder - pointer to the SwitchBitmapSurface order                 
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHSwitchBitmapSurface(PTS_SWITCH_SURFACE_ORDER pOrder,
    DCUINT orderLen)
{
    HRESULT hr = S_OK;
    unsigned cacheId;
    HBITMAP  hBitmap;

    // SECURITY: 552403
    DC_IGNORE_PARAMETER(orderLen);

    DC_BEGIN_FN("UHSwitchBitmapSurface");

    cacheId = pOrder->BitmapID;

    if (cacheId != SCREEN_BITMAP_SURFACE) {
        hr = UHIsValidOffsreenBitmapCacheIndex(cacheId);
        DC_QUIT_ON_FAIL(hr);
    }
            
    _UH.lastHDC = _UH.hdcDraw;

    if (cacheId != SCREEN_BITMAP_SURFACE) {
        hBitmap = _UH.offscrBitmapCache[cacheId].offscrBitmap;

        if (hBitmap) {
            // Select the bitmap into the offscreen DC
            SelectObject(_UH.hdcOffscreenBitmap, hBitmap);
        }
        else {
            // the bitmap is NULL, we use the unused bitmap in the 
            // mean time
            SelectObject(_UH.hdcOffscreenBitmap, _UH.hUnusedOffscrBitmap);
        }

        _UH.hdcDraw = _UH.hdcOffscreenBitmap;                
    }
    else {
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
        if (!_UH.DontUseShadowBitmap && _UH.hdcShadowBitmap) {
#else
        if (_UH.hdcShadowBitmap) {
#endif // DISABLE_SHADOW_IN_FULLSCREEN
            _UH.hdcDraw = _UH.hdcShadowBitmap;
        }
        else {
            _UH.hdcDraw = _UH.hdcOutputWindow;
        }
    }
    
#if defined (OS_WINCE)
    _UH.validClipDC      = NULL;
    _UH.validBkColorDC   = NULL;
    _UH.validBkModeDC    = NULL;
    _UH.validROPDC       = NULL;
    _UH.validTextColorDC = NULL;
    _UH.validPenDC       = NULL;
    _UH.validBrushDC     = NULL;
#endif

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}

#ifdef DRAW_GDIPLUS
/****************************************************************************/
// Name:      UHDrawGdiplusCachePDUFirst                                 
//
// Handle the First PDU of Gdiplus Cache Order
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHDrawGdiplusCachePDUFirst(
    PTS_DRAW_GDIPLUS_CACHE_ORDER_FIRST pOrder,
    DCUINT orderLen,
    unsigned *pOrderSize)
{
    HRESULT hr = S_OK;
    unsigned OrderSize;
    PTS_DRAW_GDIPLUS_CACHE_ORDER_FIRST pTSDrawGdiplusCache;
    ULONG cbSize, cbTotalSize;
    PTSEmfPlusRecord pTSEmfRecord;
    BYTE *pCacheData;
    TSUINT16 CacheID, CacheType;
    TSUINT16 i, RemoveCacheNum = 0, *pRemoveCacheList;
    PBYTE pEnd = (BYTE*)pOrder + orderLen;

    DC_BEGIN_FN("UHDrawGdiplusCachePDUFirst");
    
    OrderSize = sizeof(TS_DRAW_GDIPLUS_CACHE_ORDER_FIRST) + pOrder->cbSize;

    // SECURITY: 552403   
    CHECK_READ_N_BYTES(pOrder, pEnd, OrderSize, hr,
       (TB, _T("Bad UHDrawGdiplusCachePDUFirst, size %u"), OrderSize));

    // Set the return once we know we have enough data.  If the alloc fails below, still return
    // the packet size so decode continues
    *pOrderSize = OrderSize;

    if (TS_DRAW_GDIPLUS_SUPPORTED != _pCc->_ccCombinedCapabilities.
        drawGdiplusCapabilitySet.drawGdiplusCacheLevel) {
        TRC_ERR((TB, _T("Gdip order when gdip not supported")));
        DC_QUIT;
    }

    pTSDrawGdiplusCache = (PTS_DRAW_GDIPLUS_CACHE_ORDER_FIRST)pOrder; 
    
    TRC_NRM((TB, _T("Get GdiplusCachePDU, Type: %d, ID: %d"), 
        pTSDrawGdiplusCache->CacheType, pTSDrawGdiplusCache->CacheID));
    cbSize = pTSDrawGdiplusCache->cbSize;
    cbTotalSize = pTSDrawGdiplusCache->cbTotalSize;
    
    CacheType = pTSDrawGdiplusCache->CacheType;
    if (FAILED(UHIsValidGdipCacheType(CacheType)))
    {
        // Ignore all failures for invalid cache type
        DC_QUIT;
    }
    CacheID = pTSDrawGdiplusCache->CacheID;
    hr = UHIsValidGdipCacheTypeID(CacheType, CacheID);
    DC_QUIT_ON_FAIL(hr);

    _UH.drawGdipCacheBuffer = (BYTE *)UT_Malloc(_pUt, cbTotalSize);
    if (NULL == _UH.drawGdipCacheBuffer) {
        TRC_ERR((TB, _T("LocalAlloc failes in UHDrawGdiplusCachePDUFirst")));
        _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                    CD_NOTIFICATION_FUNC(CUH, UHSendDrawGdiplusErrorPDU), 0);
        DC_QUIT;
    }
    _UH.drawGdipCacheBufferOffset = _UH.drawGdipCacheBuffer;
    _UH.drawGdipCacheBufferSize = (NULL == _UH.drawGdipCacheBuffer) ? 0 : cbTotalSize;
    pCacheData = (BYTE *)(pTSDrawGdiplusCache + 1);
    
    if (pTSDrawGdiplusCache->Flags & TS_GDIPLUS_CACHE_ORDER_REMOVE_CACHEENTRY) {
        // This order contain the RemoveCacheList
        CHECK_READ_N_BYTES(pCacheData, pEnd, sizeof(TSUINT16), hr,
            ( TB, _T("not enough data for remove cache entry orders")));
        RemoveCacheNum = *(TSUINT16 *)pCacheData;
        CHECK_READ_N_BYTES(pCacheData, pEnd, ((RemoveCacheNum + 1) * sizeof(TSUINT16)), hr,
            ( TB, _T("remove cache entry orders too large")));
        
        pRemoveCacheList = (TSUINT16 *)(pTSDrawGdiplusCache + 1) + 1;
        for (i=0; i<RemoveCacheNum; i++) {
            hr = UHIsValidGdipCacheTypeID(GDIP_CACHE_OBJECT_IMAGE,
                *pRemoveCacheList);
            DC_QUIT_ON_FAIL(hr);
            UHDrawGdipRemoveImageCacheEntry(*pRemoveCacheList);
            TRC_NRM((TB, _T("Remove chche ID %d"), *pRemoveCacheList));
            pRemoveCacheList++;
        }
        pCacheData = (BYTE *)pRemoveCacheList;

        if (cbSize <= (sizeof(TSUINT16) * (RemoveCacheNum + 1))) {
            TRC_ERR(( TB, _T("DrawDGIPlusCachePDUFirst invalid sizes")
                _T("[cbSize %u cbTotalSize %u]"), cbSize, cbTotalSize));
            hr = E_TSC_CORE_LENGTH;
            DC_QUIT;
        }
        cbSize -= sizeof(TSUINT16) * (RemoveCacheNum + 1);
    }

    // SECURITY - other size checks above should permit this assert to exist        
    TRC_ASSERT(_UH.drawGdipCacheBufferSize - (_UH.drawGdipCacheBufferOffset -
        _UH.drawGdipCacheBuffer) >= cbSize, (TB, _T("DrawDGIPlusCachePDUFirst size invalid")));
    
    memcpy(_UH.drawGdipCacheBufferOffset, pCacheData, cbSize);
    _UH.drawGdipCacheBufferOffset += cbSize;
    
    if (cbSize > cbTotalSize) {
        TRC_ERR(( TB, _T("DrawDGIPlusCachePDUFirst invalid sizes")
            _T("[cbSize %u cbTotalSize %u]"), cbSize, cbTotalSize));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }

    if (cbSize == cbTotalSize) {
        // The cache order only has one block
        hr = UHDrawGdiplusCacheData(CacheType, CacheID, cbTotalSize);
        DC_QUIT_ON_FAIL(hr);
    }

DC_EXIT_POINT:  
    DC_END_FN();
    
    return hr;
}


/****************************************************************************/
// Name:      UHDrawGdiplusCachePDUNext                                 
//
// Handle the subsequent PDU of Gdiplus Cache Order
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHDrawGdiplusCachePDUNext(
    PTS_DRAW_GDIPLUS_CACHE_ORDER_NEXT pOrder, DCUINT orderLen,
    unsigned *pOrderSize)
{
    HRESULT hr = S_OK;
    unsigned OrderSize;
    PTS_DRAW_GDIPLUS_CACHE_ORDER_NEXT pTSDrawGdiplusCache;
    ULONG cbSize;
    RECT rect;
    DrawTSClientEnum drawGdiplusType = DrawTSClientRecord;
    PBYTE pEnd = (BYTE*)pOrder + orderLen;

    DC_BEGIN_FN("UHDrawGdiplusCachePDUNext");

    OrderSize = sizeof(TS_DRAW_GDIPLUS_CACHE_ORDER_NEXT) + pOrder->cbSize;
    
    // SECURITY: 552403
    CHECK_READ_N_BYTES(pOrder, pEnd, OrderSize, hr,
        ( TB, _T("Bad UHDrawGdiplusCachePDUNext; size %u"), OrderSize));

    *pOrderSize = OrderSize;

    if (TS_DRAW_GDIPLUS_SUPPORTED != _pCc->_ccCombinedCapabilities.
        drawGdiplusCapabilitySet.drawGdiplusCacheLevel) {
        TRC_ERR((TB, _T("Gdip order when gdip not supported")));
        DC_QUIT;
    }

    if (NULL == _UH.drawGdipCacheBuffer) {
        DC_QUIT;
    }

    pTSDrawGdiplusCache = (PTS_DRAW_GDIPLUS_CACHE_ORDER_NEXT)pOrder;
    cbSize = pTSDrawGdiplusCache->cbSize;

    CHECK_WRITE_N_BYTES(_UH.drawGdipCacheBufferOffset, _UH.drawGdipCacheBuffer + _UH.drawGdipCacheBufferSize,
        cbSize, hr, (TB, _T("UHDrawGdiplusCachePDUNext size invalid")));
        
    memcpy(_UH.drawGdipCacheBufferOffset, pTSDrawGdiplusCache + 1, cbSize);
    _UH.drawGdipCacheBufferOffset += cbSize;

DC_EXIT_POINT:
    DC_END_FN();
    
    return hr;
}


/****************************************************************************/
// Name:      UHDrawGdiplusCachePDUEnd                                 
//
// Handle the last PDU of Gdiplus Cache Order
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHDrawGdiplusCachePDUEnd(
    PTS_DRAW_GDIPLUS_CACHE_ORDER_END pOrder, DCUINT orderLen,
    unsigned *pOrderSize)
{
    HRESULT hr = S_OK;
    unsigned OrderSize;
    PTS_DRAW_GDIPLUS_CACHE_ORDER_END pTSDrawGdiplusCache;
    ULONG cbSize, cbTotalSize;
    TSUINT16 CacheID, CacheType;
    PBYTE pEnd = (PBYTE)pOrder + orderLen;

    DC_BEGIN_FN("UHDrawGdiplusCachePDUEnd");

    OrderSize = sizeof(TS_DRAW_GDIPLUS_CACHE_ORDER_END) + pOrder->cbSize;

    // SECURITY: 552403
    CHECK_READ_N_BYTES(pOrder, pEnd, OrderSize, hr,
        ( TB, _T("Bad UHDrawGdiplusCachePDUEnd, size %u"), OrderSize));

    *pOrderSize = OrderSize;

    if (TS_DRAW_GDIPLUS_SUPPORTED != _pCc->_ccCombinedCapabilities.
        drawGdiplusCapabilitySet.drawGdiplusCacheLevel) {
        TRC_ERR((TB, _T("Gdip order when gdip not supported")));
        DC_QUIT;
    }

    if (NULL == _UH.drawGdipCacheBuffer) {
        DC_QUIT;
    }

    pTSDrawGdiplusCache = (PTS_DRAW_GDIPLUS_CACHE_ORDER_END)pOrder;
    cbSize = pTSDrawGdiplusCache->cbSize;
    cbTotalSize = pTSDrawGdiplusCache->cbTotalSize;
    CacheType = pTSDrawGdiplusCache->CacheType;
    if (FAILED(UHIsValidGdipCacheType(CacheType)))
    {
        // Ignore all failures for invalid cache type
        DC_QUIT;
    }
    
    CacheID = pTSDrawGdiplusCache->CacheID;
    hr = UHIsValidGdipCacheTypeID(CacheType, CacheID);
    DC_QUIT_ON_FAIL(hr);

    if (_UH.drawGdipCacheBufferOffset + cbSize != _UH.drawGdipCacheBuffer + _UH.drawGdipCacheBufferSize ||
        cbTotalSize != _UH.drawGdipCacheBufferSize ) {
        TRC_ABORT((TB, _T("Sizes are off") ));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }

    memcpy(_UH.drawGdipCacheBufferOffset, pTSDrawGdiplusCache + 1, cbSize);

    hr = UHDrawGdiplusCacheData(CacheType, CacheID, cbTotalSize);
    DC_QUIT_ON_FAIL(hr);

    *pOrderSize = OrderSize;
    
DC_EXIT_POINT:
    if (_UH.drawGdipCacheBuffer != NULL) {
        UT_Free(_pUt, _UH.drawGdipCacheBuffer);
        _UH.drawGdipCacheBuffer = NULL;
        _UH.drawGdipCacheBufferOffset = NULL;
        _UH.drawGdipCacheBufferSize = 0;
    }
    DC_END_FN(); 
    
    
    return hr;
}


/****************************************************************************/
// Name:      UHDrawGdiplusCacheData                                 
//
// Put the received gdiplus cache data into free chunks
/****************************************************************************/
// SECURITY - caller should verify CacheType, CacheID
HRESULT DCINTERNAL CUH::UHDrawGdiplusCacheData(TSUINT16 CacheType, 
    TSUINT16 CacheID, unsigned cbTotalSize)
{
    HRESULT hr = S_OK;
    PUHGDIPLUSOBJECTCACHE pGdipObjectCache = NULL;
    PUHGDIPLUSIMAGECACHE pGdipImageCache;
    BOOL IsImageCache = FALSE;
    BYTE *pCacheDataOffset, *pCacheSrcDataOffset;
    INT16 NextIndex, CurrentIndex;
    TSUINT16 ChunkNum, i;
    unsigned SizeRemain, ChunkSize;

    DC_BEGIN_FN("UHAssembleGdipEmfRecord");

    switch (CacheType) {
        case GDIP_CACHE_GRAPHICS_DATA:
            pGdipObjectCache = &_UH.GdiplusGraphicsCache[CacheID];
            break;
        case GDIP_CACHE_OBJECT_BRUSH:
            pGdipObjectCache = &_UH.GdiplusObjectBrushCache[CacheID];
            break;
        case GDIP_CACHE_OBJECT_PEN:
            pGdipObjectCache = &_UH.GdiplusObjectPenCache[CacheID];
            break;
        case GDIP_CACHE_OBJECT_IMAGE:
            pGdipImageCache = &_UH.GdiplusObjectImageCache[CacheID];
            IsImageCache = TRUE;
            break;
        case GDIP_CACHE_OBJECT_IMAGEATTRIBUTES:
            pGdipObjectCache = &_UH.GdiplusObjectImageAttributesCache[CacheID];
            break;
        default:
            // Can't get here
            break;
    }

    ChunkSize = UHGdipCacheChunkSize(CacheType);
    TRC_ASSERT( ChunkSize != 0, (TB, _T("Invalid ChunkSize")));

    if (IsImageCache) {       
        TRC_NRM((TB, _T("Image Cache ID %d"), CacheID));
        // Remove previous cache to free the used chunks
        UHDrawGdipRemoveImageCacheEntry(CacheID);
        SizeRemain = cbTotalSize;
        ChunkNum = (TSUINT16)ActualSizeToChunkSize(cbTotalSize, _UH.GdiplusObjectImageCacheChunkSize);
        pGdipImageCache->CacheSize = cbTotalSize;
        pGdipImageCache->ChunkNum = ChunkNum;
        pCacheSrcDataOffset = _UH.drawGdipCacheBuffer;
        CurrentIndex = _UH.GdipImageCacheFreeListHead;
        pCacheDataOffset = _UH.GdipImageCacheData + CurrentIndex * _UH.GdiplusObjectImageCacheChunkSize;

        for (i=0; i<ChunkNum - 1; i++) {           
            hr = UHIsValidGdipCacheTypeID(CacheType, CacheID);
            DC_QUIT_ON_FAIL(hr);
            
            memcpy(pCacheDataOffset, pCacheSrcDataOffset, _UH.GdiplusObjectImageCacheChunkSize);
            pGdipImageCache->CacheDataIndex[i] = CurrentIndex;
            _UH.GdipImageCacheFreeListHead = _UH.GdipImageCacheFreeList[CurrentIndex];
            _UH.GdipImageCacheFreeList[CurrentIndex] = GDIP_CACHE_INDEX_DEFAULT;
            CurrentIndex = _UH.GdipImageCacheFreeListHead;
            pCacheDataOffset = _UH.GdipImageCacheData + CurrentIndex * _UH.GdiplusObjectImageCacheChunkSize;
            pCacheSrcDataOffset += _UH.GdiplusObjectImageCacheChunkSize;
            SizeRemain -= _UH.GdiplusObjectImageCacheChunkSize;
        }

        hr = UHIsValidGdipCacheTypeID(CacheType, CacheID);
        DC_QUIT_ON_FAIL(hr);
            
        memcpy(pCacheDataOffset, pCacheSrcDataOffset, SizeRemain);
        pGdipImageCache->CacheDataIndex[ChunkNum - 1] = CurrentIndex;
        _UH.GdipImageCacheFreeListHead = _UH.GdipImageCacheFreeList[CurrentIndex];
        _UH.GdipImageCacheFreeList[CurrentIndex] = GDIP_CACHE_INDEX_DEFAULT;
    }
    else {
        if (cbTotalSize > ChunkSize) {
            TRC_ABORT(( TB, _T("TotalSize too large [totalSize %u ChunkSize %u]"),
                cbTotalSize, ChunkSize));
            hr = E_TSC_CORE_LENGTH;
            DC_QUIT;
        }

        if (pGdipObjectCache) {
            pGdipObjectCache->CacheSize = cbTotalSize;
            memcpy(pGdipObjectCache->CacheData, _UH.drawGdipCacheBuffer, cbTotalSize);
        }
    }

DC_EXIT_POINT:
    if (_UH.drawGdipCacheBuffer != NULL) {
        UT_Free(_pUt, _UH.drawGdipCacheBuffer);
        _UH.drawGdipCacheBuffer = NULL;
        _UH.drawGdipCacheBufferOffset = NULL;
        _UH.drawGdipCacheBufferSize = 0;
    }
    DC_END_FN();
    
    return hr;
}


/****************************************************************************/
// Name:      UHAssembleGdipEmfRecord                                 
//
// When receiving whole EMF+ record, assemble it, i.e. convert cachID to real cache data
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHAssembleGdipEmfRecord(unsigned cbEmfSize, 
    unsigned cbTotalSize)
{
    HRESULT hr = S_OK;
    ULONG cbSize;
    RECT rect;
    DrawTSClientEnum drawGdiplusType = DrawTSClientRecord;
    PTSEmfPlusRecord pTSEmfRecord;
    ULONG Size, CopyDataSize, SizeRemain;
    BYTE * pData;
    TSUINT16 CacheID;
    unsigned int CacheSize;
    PUHGDIPLUSOBJECTCACHE pGdipObjectCache;
    PUHGDIPLUSIMAGECACHE pGdipImageCache;
    BOOL IsCache;
    BOOL IsImageCache = FALSE;
    BYTE *pCacheSrcDataOffset;
    INT16 NextIndex, CurrentIndex;
    TSUINT16 ChunkNum;
    TSUINT16 i;
    TSUINT16 CacheType;


    DC_BEGIN_FN("UHAssembleGdipEmfRecord");

    _UH.drawGdipEmfBuffer = (BYTE *)UT_Malloc(_pUt, cbEmfSize);
    if (_UH.drawGdipEmfBuffer == NULL) {
        TRC_ERR((TB, _T("LocalAlloc failes in UHAssembleGdipEmfRecord")));
        _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                    CD_NOTIFICATION_FUNC(CUH, UHSendDrawGdiplusErrorPDU), 0);
        DC_QUIT;
    }
    _UH.drawGdipEmfBufferOffset = _UH.drawGdipEmfBuffer;

    cbSize = cbTotalSize;

    CHECK_READ_N_BYTES(_UH.drawGdipBuffer, 
        _UH.drawGdipBuffer + _UH.drawGdipBufferSize,
        sizeof(TSEmfPlusRecord), hr,
        (TB, _T("Not enough data for emfplusrecord")));
    
    pTSEmfRecord = (PTSEmfPlusRecord)_UH.drawGdipBuffer;
    pData = _UH.drawGdipBuffer;
    Size = cbTotalSize;

    while (Size > 0) {

        CHECK_READ_N_BYTES(pData, _UH.drawGdipBuffer + _UH.drawGdipBufferSize,
            sizeof(TSEmfPlusRecord), hr,
            (TB, _T("Not enough data for emfplusrecord")));
        
        pTSEmfRecord = (PTSEmfPlusRecord)pData;
        IsCache = FALSE;
        IsImageCache = FALSE;

        //   Fix for bug #660993. If this size is 0 we will be stuck
        //   in this loop.
        if (pTSEmfRecord->Size != 0) {
            if (pTSEmfRecord->Type == (enum EmfPlusRecordType)EmfPlusRecordTypeSetTSGraphics) {
                pGdipObjectCache = _UH.GdiplusGraphicsCache;
                CacheType = GDIP_CACHE_GRAPHICS_DATA;
                IsCache = TRUE;
            }
            else if (pTSEmfRecord->Type == EmfPlusRecordTypeObject) {
                switch ((enum ObjectType)(pTSEmfRecord->Flags >> 8)) {
                case ObjectTypeBrush:
                    pGdipObjectCache = _UH.GdiplusObjectBrushCache;
                    CacheType = GDIP_CACHE_OBJECT_BRUSH;
                    IsCache = TRUE;
                    break;
                case ObjectTypePen:
                    pGdipObjectCache = _UH.GdiplusObjectPenCache;
                    CacheType = GDIP_CACHE_OBJECT_PEN;
                    IsCache = TRUE;
                    break;
                case ObjectTypeImage:
                    pGdipImageCache = _UH.GdiplusObjectImageCache;
                    CacheType = GDIP_CACHE_OBJECT_IMAGE;
                    IsCache = TRUE;
                    IsImageCache = TRUE;
                    break;
                case ObjectTypeImageAttributes:
                    pGdipObjectCache = _UH.GdiplusObjectImageAttributesCache;
                    CacheType = GDIP_CACHE_OBJECT_IMAGEATTRIBUTES;
                    IsCache = TRUE;
                    break;
                default:
                    IsCache = FALSE;
                    break;
                }           
            }
            if (!IsCache) {
                // This record is not cached
                CHECK_READ_N_BYTES(pData, _UH.drawGdipBuffer + _UH.drawGdipBufferSize, 
                    pTSEmfRecord->Size, hr, ( TB, _T("Reading from data past end")));
                CHECK_WRITE_N_BYTES(_UH.drawGdipEmfBufferOffset, _UH.drawGdipEmfBuffer + cbEmfSize,
                    pTSEmfRecord->Size, hr, ( TB, _T("Writing past data end")));           
                memcpy(_UH.drawGdipEmfBufferOffset, pData, pTSEmfRecord->Size);
                _UH.drawGdipEmfBufferOffset += pTSEmfRecord->Size;
                Size -= pTSEmfRecord->Size;
                pData += pTSEmfRecord->Size;
            }
            else {    
                CacheSize = pTSEmfRecord->Size;

                // Ensure that we have enough to read the following UINT16...
                CHECK_READ_N_BYTES(pData, _UH.drawGdipBuffer + _UH.drawGdipBufferSize,
                    sizeof(TSEmfPlusRecord) + sizeof(TSUINT16), hr,
                    (TB, _T("Not enough data for cache ID")));

                CacheID = *(TSUINT16 *)(pTSEmfRecord + 1);
                if (CacheSize & 0x80000000) {
                    // This is Cached record
                    if (IsImageCache) {
                        // Image cache
                        hr = UHIsValidGdipCacheTypeID(CacheType, CacheID);
                        DC_QUIT_ON_FAIL(hr);
                        pGdipImageCache += CacheID;

                        pTSEmfRecord->Size = sizeof(TSEmfPlusRecord) + 
                            pGdipImageCache->CacheSize;

                        CHECK_READ_N_BYTES(pData, 
                            _UH.drawGdipBuffer + _UH.drawGdipBufferSize, 
                            sizeof(TSEmfPlusRecord), hr, 
                            ( TB, _T("Reading from data past end")));
                        CHECK_WRITE_N_BYTES(_UH.drawGdipEmfBufferOffset, 
                            _UH.drawGdipEmfBuffer + cbEmfSize,
                            sizeof(TSEmfPlusRecord), hr, 
                            ( TB, _T("Writing past data end")));                     
                        memcpy(_UH.drawGdipEmfBufferOffset, pData, sizeof(TSEmfPlusRecord));
                        Size -= sizeof(TSEmfPlusRecord);
                        pData += sizeof(TSEmfPlusRecord);
                        _UH.drawGdipEmfBufferOffset += sizeof(TSEmfPlusRecord);

                        SizeRemain = pGdipImageCache->CacheSize;

                        CHECK_WRITE_N_BYTES(_UH.drawGdipEmfBufferOffset, 
                            _UH.drawGdipEmfBuffer + cbEmfSize,
                            SizeRemain, hr, ( TB, _T("Writing past data end"))); 
                        
                        for (i=0; i<pGdipImageCache->ChunkNum-1; i++) {
                            CurrentIndex = pGdipImageCache->CacheDataIndex[i];

                            pCacheSrcDataOffset = _UH.GdipImageCacheData + _UH.GdiplusObjectImageCacheChunkSize * CurrentIndex;
                            memcpy(_UH.drawGdipEmfBufferOffset, pCacheSrcDataOffset, _UH.GdiplusObjectImageCacheChunkSize);
                            SizeRemain -= _UH.GdiplusObjectImageCacheChunkSize;
                            _UH.drawGdipEmfBufferOffset += _UH.GdiplusObjectImageCacheChunkSize;                      
                        }
                        CurrentIndex = pGdipImageCache->CacheDataIndex[pGdipImageCache->ChunkNum - 1];

                        pCacheSrcDataOffset = _UH.GdipImageCacheData + _UH.GdiplusObjectImageCacheChunkSize * CurrentIndex;
                        memcpy(_UH.drawGdipEmfBufferOffset, pCacheSrcDataOffset, SizeRemain);
                        _UH.drawGdipEmfBufferOffset += SizeRemain;

                        // We already checked above that we had enough data to read for this UINT16
                        Size -= sizeof(TSUINT16);
                        pData += sizeof(TSUINT16);
                    }
                    else {
                        // Other caches
                        pGdipObjectCache += CacheID;
                        hr = UHIsValidGdipCacheTypeID(CacheType, CacheID);
                        DC_QUIT_ON_FAIL(hr);

                        pTSEmfRecord->Size = sizeof(TSEmfPlusRecord) +  pGdipObjectCache->CacheSize;

                        CHECK_READ_N_BYTES(pData,
                            _UH.drawGdipBuffer + _UH.drawGdipBufferSize, 
                            sizeof(TSEmfPlusRecord), hr, 
                            ( TB, _T("Reading from data past end")));
                        CHECK_WRITE_N_BYTES(_UH.drawGdipEmfBufferOffset, 
                            _UH.drawGdipEmfBuffer + cbEmfSize,
                            sizeof(TSEmfPlusRecord) + pGdipObjectCache->CacheSize, 
                            hr, ( TB, _T("Writing past data end")));    
                           
                        memcpy(_UH.drawGdipEmfBufferOffset, pData, sizeof(TSEmfPlusRecord));
                        Size -= sizeof(TSEmfPlusRecord);
                        pData += sizeof(TSEmfPlusRecord);
                        _UH.drawGdipEmfBufferOffset += sizeof(TSEmfPlusRecord);
                   
                        memcpy(_UH.drawGdipEmfBufferOffset, pGdipObjectCache->CacheData, pGdipObjectCache->CacheSize);
                        _UH.drawGdipEmfBufferOffset += pGdipObjectCache->CacheSize;

                        // We already checked above that we had enough data to read for this UINT16
                        Size -= sizeof(TSUINT16);
                        pData += sizeof(TSUINT16);
                    }
                }
                else {
                    // Not cached record, so copy it
                    CHECK_READ_N_BYTES(pData, 
                        _UH.drawGdipBuffer + _UH.drawGdipBufferSize, 
                        pTSEmfRecord->Size, hr, 
                        ( TB, _T("Reading from data past end")));
                    CHECK_WRITE_N_BYTES(_UH.drawGdipEmfBufferOffset, 
                        _UH.drawGdipEmfBuffer + cbEmfSize,
                        pTSEmfRecord->Size, hr, ( TB, _T("Writing past data end")));  
                    
                    memcpy(_UH.drawGdipEmfBufferOffset, pData, pTSEmfRecord->Size);
                    _UH.drawGdipEmfBufferOffset += pTSEmfRecord->Size;
                    Size -= pTSEmfRecord->Size;
                    pData += pTSEmfRecord->Size;
                }
            }
        } else {        
            TRC_ABORT((TB, _T("Invalid TSEmfRecord size")));
            hr = E_TSC_CORE_GDIPLUS;
            DC_QUIT;
        }
    }

    if (_UH.drawGdipEmfBufferOffset != 
        (_UH.drawGdipEmfBuffer+cbEmfSize)) {
            TRC_ABORT((TB, _T("Error unpacking the EMF record.")));
            hr = E_TSC_CORE_GDIPLUS;
            DC_QUIT;
    }
    
    TRC_ASSERT((Size == 0), (TB, _T("Invalid EMF+ Record Size")));

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}

HRESULT DCINTERNAL CUH::UHDrawGdiplusPDUComplete( ULONG cbEmfSize, 
    ULONG cbTotalSize)
{
    HRESULT hr = S_OK;
    RECT rect;
    DrawTSClientEnum drawGdiplusType = DrawTSClientRecord;
    UH_ORDER UHOrder;

    DC_BEGIN_FN("UHDrawGdiplusPDUComplete");
    
    hr = UHAssembleGdipEmfRecord(cbEmfSize, cbTotalSize);
    DC_QUIT_ON_FAIL(hr);
    
    if (_UH.pfnGdipPlayTSClientRecord != NULL) {
        if (_UH.pfnGdipPlayTSClientRecord(_UH.hdcDraw, drawGdiplusType, 
            _UH.drawGdipEmfBuffer, cbEmfSize, &rect) == 0) {
            // success
            _UH.DrawGdiplusFailureCount = 0;
        }
        else {
            TRC_ERR((TB, _T("GdiPlay:DrawTSClientRecord failed")));
            _UH.DrawGdiplusFailureCount++;
            if (_UH.DrawGdiplusFailureCount >= DRAWGDIPLUSFAILURELIMIT) {
                _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                    CD_NOTIFICATION_FUNC(CUH, UHSendDrawGdiplusErrorPDU), 0);
                _UH.DrawGdiplusFailureCount = 0;
                hr = E_TSC_CORE_GDIPLUS;
                DC_QUIT;
            }
        }

        // $TODO - IVAN - If pfnGdipPlayTSClientRecord failed, rect is probably not initialized
        // _UH.DrawGdiplusFailureCount < DRAWGDIPLUSFAILURELIMIT
        if (_UH.hdcDraw == _UH.hdcShadowBitmap) {
            UHOrder.dstRect.left = rect.left;
            UHOrder.dstRect.bottom = rect.bottom;
            UHOrder.dstRect.right = rect.right;
            UHOrder.dstRect.top = rect.top;
            UHAddUpdateRegion(&UHOrder, _UH.hrgnUpdate);
        }
    }       

DC_EXIT_POINT:
    if (_UH.drawGdipBuffer != NULL) {
        UT_Free(_pUt, _UH.drawGdipBuffer);
        _UH.drawGdipBuffer = NULL;
        _UH.drawGdipBufferOffset = NULL;
        _UH.drawGdipBufferSize = 0;
    }
    if (_UH.drawGdipEmfBuffer != NULL) {
        UT_Free(_pUt, _UH.drawGdipEmfBuffer);
        _UH.drawGdipEmfBuffer = NULL;
        _UH.drawGdipEmfBufferOffset = NULL;
    }   
    DC_END_FN();
    
    return hr;
}

/****************************************************************************/
// Name:      UHDrawGdiplusPDUFirst                                 
//
// Handle the first PDU of Gdiplus Order
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHDrawGdiplusPDUFirst(
    PTS_DRAW_GDIPLUS_ORDER_FIRST pOrder, DCUINT orderLen,
    unsigned *pOrderSize)
{
    HRESULT hr = S_OK;
    unsigned OrderSize;
    PTS_DRAW_GDIPLUS_ORDER_FIRST pTSDrawGdiplus;
    ULONG cbSize, cbTotalSize, cbEmfSize;
    RECT rect;
    DrawTSClientEnum drawGdiplusType = DrawTSClientRecord;
    PTSEmfPlusRecord pTSEmfRecord;
    ULONG Size;
    BYTE * pData;
    UH_ORDER UHOrder;
    PBYTE pEnd = (PBYTE)pOrder + orderLen;
    
    DC_BEGIN_FN("UHDrawGdiplusPDUFirst");

    TRC_NRM((TB, _T("UHDrawGdiplusPDUFirst")));

    OrderSize = sizeof(TS_DRAW_GDIPLUS_ORDER_FIRST) + pOrder->cbSize;

    //SECURITY: 552403
    CHECK_READ_N_BYTES(pOrder, pEnd, OrderSize, hr,
        ( TB, _T("Bad UHDrawGdiplusPDUFirst; Size %u"), OrderSize));

    *pOrderSize = OrderSize;

    if (TS_DRAW_GDIPLUS_SUPPORTED != _pCc->_ccCombinedCapabilities.
        drawGdiplusCapabilitySet.drawGdiplusCacheLevel) {
        TRC_ERR((TB, _T("Gdip order when gdip not supported")));
        DC_QUIT;
    }

    pTSDrawGdiplus = (PTS_DRAW_GDIPLUS_ORDER_FIRST)pOrder;
    cbSize = pTSDrawGdiplus->cbSize;
    cbTotalSize = pTSDrawGdiplus->cbTotalSize;
    if (cbSize > cbTotalSize) {
        TRC_ERR(( TB, _T("invalid sizes [cbSize %u cbTotalSize %u]"),
            cbSize, cbTotalSize));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }
    
    cbEmfSize = pTSDrawGdiplus->cbTotalEmfSize;

    _UH.drawGdipBuffer = (BYTE *)UT_Malloc(_pUt, cbTotalSize);
    if (_UH.drawGdipBuffer == NULL) {
        TRC_ERR((TB, _T("LocalAlloc failes in UHDrawGdiplusPDUFirst")));
        _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                    CD_NOTIFICATION_FUNC(CUH, UHSendDrawGdiplusErrorPDU), 0);
        DC_QUIT;
    }
    _UH.drawGdipBufferOffset = _UH.drawGdipBuffer;
    _UH.drawGdipBufferSize = cbTotalSize;

    // SECURITY: we can copy cbSize bytes since it is <= cbTotalSize,
    // which is the buffer length
    memcpy(_UH.drawGdipBufferOffset, (BYTE *)(pTSDrawGdiplus + 1), cbSize);
    _UH.drawGdipBufferOffset += cbSize;

    if (cbSize == cbTotalSize) {
        hr = UHDrawGdiplusPDUComplete(cbEmfSize, cbTotalSize);
        DC_QUIT_ON_FAIL(hr);
    }

DC_EXIT_POINT:
    DC_END_FN();
    
    return hr;
}

/****************************************************************************/
// Name:      UHDrawGdiplusPDUFirst                                 
//
// Handle the subsequent PDU of Gdiplus Order
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHDrawGdiplusPDUNext(
    PTS_DRAW_GDIPLUS_ORDER_NEXT pOrder, DCUINT orderLen, unsigned *pOrderSize)
{
    HRESULT hr = S_OK;
    unsigned OrderSize;
    PTS_DRAW_GDIPLUS_ORDER_NEXT pTSDrawGdiplus;
    ULONG cbSize;
    PBYTE pEnd = (PBYTE)pOrder + orderLen;

    DC_BEGIN_FN("UHDrawGdiplusPDUNext");

    OrderSize = sizeof(TS_DRAW_GDIPLUS_ORDER_NEXT) + pOrder->cbSize;

    //SECURITY: 552403
    CHECK_READ_N_BYTES(pOrder, pEnd, OrderSize, hr,
            ( TB, _T("Bad UHDrawGdiplusPDUNext; Size %u"), OrderSize));

    *pOrderSize = OrderSize;

    if (TS_DRAW_GDIPLUS_SUPPORTED != _pCc->_ccCombinedCapabilities.
        drawGdiplusCapabilitySet.drawGdiplusCacheLevel) {
        TRC_ERR((TB, _T("Gdip order when gdip not supported")));
        DC_QUIT;
    }

    if (NULL == _UH.drawGdipBufferOffset) {
        DC_QUIT;
    }

    pTSDrawGdiplus = (PTS_DRAW_GDIPLUS_ORDER_NEXT)pOrder;
    cbSize = pTSDrawGdiplus->cbSize;

    CHECK_WRITE_N_BYTES(_UH.drawGdipBufferOffset, _UH.drawGdipBuffer + _UH.drawGdipBufferSize,
        cbSize, hr, (TB, _T("UHDrawGdiplusPDUNext size invalid")));
        
    memcpy(_UH.drawGdipBufferOffset, (BYTE *)(pTSDrawGdiplus + 1), cbSize);
    _UH.drawGdipBufferOffset += cbSize;
    
DC_EXIT_POINT:
    DC_END_FN();
    
    return hr;
}


/****************************************************************************/
// Name:      UHDrawGdiplusPDUFirst                                 
//
// Handle the last PDU of Gdiplus Order
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHDrawGdiplusPDUEnd(
    PTS_DRAW_GDIPLUS_ORDER_END pOrder, DCUINT orderLen, unsigned *pOrderSize)
{
    HRESULT hr = S_OK;
    unsigned OrderSize;
    PTS_DRAW_GDIPLUS_ORDER_END pTSDrawGdiplus;
    ULONG cbSize, cbTotalSize, cbEmfSize;
    RECT rect;
    DrawTSClientEnum drawGdiplusType = DrawTSClientRecord;
    UH_ORDER UHOrder;
    PBYTE pEnd = (PBYTE)pOrder + orderLen;

    DC_BEGIN_FN("UHDrawGdiplusPDUEnd");

    OrderSize = sizeof(TS_DRAW_GDIPLUS_ORDER_END) + pOrder->cbSize;

    //SECURITY: 552403
    CHECK_READ_N_BYTES(pOrder, pEnd, OrderSize, hr,
            ( TB, _T("Bad UHDrawGdiplusPDUEnd; Size %u"), OrderSize));

    *pOrderSize = OrderSize;

    if (TS_DRAW_GDIPLUS_SUPPORTED != _pCc->_ccCombinedCapabilities.
        drawGdiplusCapabilitySet.drawGdiplusCacheLevel) {
        TRC_ERR((TB, _T("Gdip order when gdip not supported")));
        DC_QUIT;
    }
    
    if (NULL == _UH.drawGdipBufferOffset) {
        DC_QUIT;
    }

    pTSDrawGdiplus = (PTS_DRAW_GDIPLUS_ORDER_END)pOrder;
    cbSize = pTSDrawGdiplus->cbSize;
    cbTotalSize = pTSDrawGdiplus->cbTotalSize;
    if (cbSize > cbTotalSize) {
        TRC_ERR(( TB, _T("invalid sizes [cbSize %u cbTotalSize %u]"),
            cbSize, cbTotalSize));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }
    if (cbTotalSize != _UH.drawGdipBufferSize) {
        TRC_ERR(( TB, _T("cbTotalSize has changed [original %u, now %u]"),
            _UH.drawGdipBufferSize, cbTotalSize));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;        
    }
    
    cbEmfSize = pTSDrawGdiplus->cbTotalEmfSize;

    CHECK_WRITE_N_BYTES(_UH.drawGdipBufferOffset, _UH.drawGdipBuffer + _UH.drawGdipBufferSize,
        cbSize, hr, (TB, _T("UHDrawGdiplusPDUEnd size invalid")));
    memcpy(_UH.drawGdipBufferOffset, (BYTE *)(pTSDrawGdiplus + 1), cbSize);
    _UH.drawGdipBufferOffset += cbSize;

    hr = UHDrawGdiplusPDUComplete(cbEmfSize, cbTotalSize);
    DC_QUIT_ON_FAIL(hr);

DC_EXIT_POINT:

    DC_END_FN();
    
    return hr;
}


// Remove a gdiplus image cache entry and add the free memory to the free list
// SECURITY - callers must verify the CacheID
BOOL DCINTERNAL CUH::UHDrawGdipRemoveImageCacheEntry(TSUINT16 CacheID)
{
    unsigned i;
    BOOL rc = FALSE;
    PUHGDIPLUSIMAGECACHE pGdipImageCache;
    INT16 CurrentIndex;

    DC_BEGIN_FN("UHDrawGdipRemoveImageCacheEntry");
    pGdipImageCache = _UH.GdiplusObjectImageCache + CacheID;

    for (i=0; i<pGdipImageCache->ChunkNum; i++) {
        CurrentIndex = pGdipImageCache->CacheDataIndex[i];
        _UH.GdipImageCacheFreeList[CurrentIndex] = _UH.GdipImageCacheFreeListHead;
        _UH.GdipImageCacheFreeListHead = CurrentIndex;
    }
    pGdipImageCache->ChunkNum = 0;
    DC_END_FN();
    return rc;
}
#endif // DRAW_GDIPLUS


#ifdef DRAW_NINEGRID
/****************************************************************************/
// Name:      UHCacheStreamBitmapFirstPDU                                 
//
// Cache streamed bitmap, this is the first block
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHCacheStreamBitmapFirstPDU(
        PTS_STREAM_BITMAP_FIRST_PDU pOrder, DCUINT orderLen, 
        unsigned *pOrderSize)
{
    HRESULT hr = S_OK;
    unsigned OrderSize;
    PBYTE pEnd = (PBYTE)pOrder + orderLen;
    TS_STREAM_BITMAP_FIRST_PDU_REV2 OrderRev2;
    PTS_STREAM_BITMAP_FIRST_PDU_REV2 pOrderRev2;
    BYTE *pOrderData;

    DC_BEGIN_FN("UHCacheStreamBitmapFirstPDU");

    pOrderRev2 = &OrderRev2;
    if (pOrder->BitmapFlags & TS_STREAM_BITMAP_REV2) {
        // TS_STREAM_BITMAP_FIRST_PDU_REV2
        CHECK_READ_N_BYTES(pOrder, pEnd, sizeof( TS_STREAM_BITMAP_FIRST_PDU_REV2 ), hr,
                        (TB, _T("Bad TS_STREAM_BITMAP_FIRST_PDU ")));
        OrderSize = sizeof(TS_STREAM_BITMAP_FIRST_PDU_REV2) + ((PTS_STREAM_BITMAP_FIRST_PDU_REV2)pOrder)->BitmapBlockLength;
        pOrderData = (BYTE *)((PTS_STREAM_BITMAP_FIRST_PDU_REV2)pOrder + 1);

        memcpy(pOrderRev2, pOrder, sizeof(TS_STREAM_BITMAP_FIRST_PDU_REV2));
    }
    else {
        OrderSize = sizeof(TS_STREAM_BITMAP_FIRST_PDU) + pOrder->BitmapBlockLength;
        pOrderData = (BYTE *)(pOrder + 1);

        pOrderRev2->ControlFlags = pOrder->ControlFlags;
        pOrderRev2->BitmapFlags = pOrder->BitmapFlags;
        pOrderRev2->BitmapLength = pOrder->BitmapLength;
        pOrderRev2->BitmapId = pOrder->BitmapId;
        pOrderRev2->BitmapBpp = pOrder->BitmapBpp;
        pOrderRev2->BitmapWidth = pOrder->BitmapWidth;
        pOrderRev2->BitmapHeight = pOrder->BitmapHeight;
        pOrderRev2->BitmapBlockLength = pOrder->BitmapBlockLength;
    }

    // SECURITY: 552403
    CHECK_READ_N_BYTES(pOrder, pEnd, OrderSize, hr,
            ( TB, _T("Bad UHCacheStreamBitmapFirstPDU; Size %u"), OrderSize));

    *pOrderSize = OrderSize;

    if (pOrderRev2->BitmapId == TS_DRAW_NINEGRID_BITMAP_CACHE) {

        _UH.drawNineGridAssembleBuffer = 
                (PDCUINT8)UT_Malloc(_pUt, pOrderRev2->BitmapLength);

        _UH.drawNineGridDecompressionBufferSize = pOrderRev2->BitmapWidth * pOrderRev2->BitmapHeight *
                pOrderRev2->BitmapBpp / 8;
        _UH.drawNineGridDecompressionBuffer = 
                (PDCUINT8)UT_Malloc(_pUt, _UH.drawNineGridDecompressionBufferSize);

        if (_UH.drawNineGridAssembleBuffer != NULL &&
                _UH.drawNineGridDecompressionBuffer != NULL &&
                pOrderRev2->BitmapBlockLength <= pOrderRev2->BitmapLength && 
                pOrderRev2->BitmapLength <= (TSUINT32)(pOrderRev2->BitmapWidth * pOrderRev2->BitmapHeight *
                pOrderRev2->BitmapBpp / 8)) {
        
            _UH.drawNineGridAssembleBufferWidth = pOrderRev2->BitmapWidth;
            _UH.drawNineGridAssembleBufferHeight = pOrderRev2->BitmapHeight;
            _UH.drawNineGridAssembleBufferBpp = pOrderRev2->BitmapBpp;
            _UH.drawNineGridAssembleBufferSize = pOrderRev2->BitmapLength;
            _UH.drawNineGridAssembleCompressed = pOrderRev2->BitmapFlags & TS_STREAM_BITMAP_COMPRESSED;
            _UH.drawNineGridAssembleBufferOffset = pOrderRev2->BitmapBlockLength;
    
            if (pOrderRev2->BitmapFlags & TS_STREAM_BITMAP_END) {
                if (_UH.drawNineGridAssembleCompressed) {
                    hr = BD_DecompressBitmap((PDCUINT8)pOrderData, _UH.drawNineGridDecompressionBuffer, 
                            pOrderRev2->BitmapBlockLength, 
                            _UH.drawNineGridDecompressionBufferSize,
                            TRUE, pOrderRev2->BitmapBpp, pOrderRev2->BitmapWidth, 
                            pOrderRev2->BitmapHeight);
                    DC_QUIT_ON_FAIL(hr);
                }
                else {
                    // Save to the assemble buffer uncompressed bitmap
                    memcpy(_UH.drawNineGridAssembleBuffer, pOrderData, pOrderRev2->BitmapBlockLength);
                }
            }
            else {
                // Save to the assemble buffer for decompression when full bitmap stream received
                memcpy(_UH.drawNineGridAssembleBuffer, pOrderData, pOrderRev2->BitmapBlockLength);                        
            }
        }
        else {

            if (_UH.drawNineGridAssembleBuffer != NULL) {
                UT_Free(_pUt, _UH.drawNineGridAssembleBuffer);
                _UH.drawNineGridAssembleBuffer = NULL;
            }

            if (_UH.drawNineGridDecompressionBuffer != NULL) {
                UT_Free(_pUt, _UH.drawNineGridDecompressionBuffer);
                _UH.drawNineGridDecompressionBuffer = NULL;
                _UH.drawNineGridDecompressionBufferSize = 0;
            }

            // Send error PDU
            if (!_UH.sendDrawNineGridErrorPDU)
                _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                        CD_NOTIFICATION_FUNC(CUH, UHSendDrawNineGridErrorPDU), 0);
        }
    }
    else {
        TRC_ASSERT((FALSE), (TB, _T("Invalid bitmapId for stream bitmap first pdu")));
        // ignore
    }

    
    
DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}

/****************************************************************************/
// Name:      UHCacheStreamBitmapNextPDU                                 
//
// Cache streamed bitmap, this is the subsequent block
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHCacheStreamBitmapNextPDU(
        PTS_STREAM_BITMAP_NEXT_PDU pOrder, DCUINT orderLen, 
        unsigned *pOrderSize)
{
    HRESULT hr = S_OK;
    unsigned OrderSize;
    PBYTE pEnd = (PBYTE)pOrder + orderLen;

    DC_BEGIN_FN("UHCacheStreamBitmapNextPDU");

    OrderSize = sizeof(TS_STREAM_BITMAP_NEXT_PDU) +
            pOrder->BitmapBlockLength;

    // SECURITY: 552403
    CHECK_READ_N_BYTES(pOrder, pEnd, OrderSize, hr,
            ( TB, _T("Bad UHCacheStreamBitmapNextPDU; Size %u"), OrderSize));    

    *pOrderSize = OrderSize;

    if (pOrder->BitmapId == TS_DRAW_NINEGRID_BITMAP_CACHE) {

        if ((_UH.drawNineGridAssembleBufferOffset + pOrder->BitmapBlockLength <= 
                _UH.drawNineGridAssembleBufferSize) &&
            (_UH.drawNineGridAssembleBuffer != NULL)) {
            // Save to assemble buffer
            memcpy(_UH.drawNineGridAssembleBuffer + _UH.drawNineGridAssembleBufferOffset, 
                    pOrder + 1, pOrder->BitmapBlockLength);
            _UH.drawNineGridAssembleBufferOffset += pOrder->BitmapBlockLength;
    
            if (pOrder->BitmapFlags & TS_STREAM_BITMAP_END) {
                if (_UH.drawNineGridAssembleCompressed) {
                    hr = BD_DecompressBitmap(_UH.drawNineGridAssembleBuffer, _UH.drawNineGridDecompressionBuffer, 
                                    _UH.drawNineGridAssembleBufferOffset, _UH.drawNineGridDecompressionBufferSize, 
                                    TRUE, 
                                    (BYTE)_UH.drawNineGridAssembleBufferBpp, 
                                    (TSUINT16)_UH.drawNineGridAssembleBufferWidth, 
                                    (TSUINT16)_UH.drawNineGridAssembleBufferHeight);
                    DC_QUIT_ON_FAIL(hr);
                }            
            }
        }
        else {
            if (_UH.drawNineGridAssembleBuffer != NULL) {
                UT_Free(_pUt, _UH.drawNineGridAssembleBuffer);
                _UH.drawNineGridAssembleBuffer = NULL;
            }

            if (_UH.drawNineGridDecompressionBuffer != NULL) {
                UT_Free(_pUt, _UH.drawNineGridDecompressionBuffer);
                _UH.drawNineGridDecompressionBuffer = NULL;
                _UH.drawNineGridDecompressionBufferSize = 0;
            }

            // Send error PDU
            if (!_UH.sendDrawNineGridErrorPDU)
                _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                        CD_NOTIFICATION_FUNC(CUH, UHSendDrawNineGridErrorPDU), 0);

        }
    }
    else {
        TRC_ASSERT((FALSE), (TB, _T("Invalid bitmapId for stream bitmap first pdu")));
        // ignore
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}

/****************************************************************************/
// Name:      UHCreateNineGridBitmap                                 
//
// Create DrawNineGrid bitmap
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHCreateNineGridBitmap(
       PTS_CREATE_NINEGRID_BITMAP_ORDER pOrder, DCUINT orderLen, 
       unsigned *pOrderSize)
{
    HRESULT hr = S_OK;
    unsigned orderSize;
    unsigned cacheId;
    HBITMAP  hBitmap = NULL;
    HDC hdc;
    BITMAPINFO bi = { 0 };
    void * pvBits = NULL;
    struct {
        BITMAPINFOHEADER	bmih;
        ULONG 				masks[3];
    } bmi;
    PBYTE pEnd = (PBYTE)pOrder + orderLen;


    DC_BEGIN_FN("UHCreateNineGridBitmap");

    orderSize = sizeof(TS_CREATE_NINEGRID_BITMAP_ORDER);

    // SECURITY: 552403
    CHECK_READ_N_BYTES(pOrder, pEnd, orderSize, hr,
                ( TB, _T("Bad UHCreateNineGridBitmap")));       

    TRC_NRM((TB, _T("Create a drawninegrid bitmap of size (%d, %d)"), pOrder->cx,
             pOrder->cy));

    // Get the DrawNineGrid bitmap Id
    cacheId = pOrder->BitmapID;

    hr = UHIsValidNineGridCacheIndex(cacheId);
    DC_QUIT_ON_FAIL(hr);

    if (_UH.drawNineGridDecompressionBuffer != NULL && 
            _UH.drawNineGridAssembleBuffer != NULL) {

        TRC_ASSERT((pOrder->BitmapBpp == 32), (TB, _T("Invalid bitmap bpp")));
    
        // Create a drawninegrid bitmap
#ifdef DISABLE_SHADOW_IN_FULLSCREEN
        if (!_UH.DontUseShadowBitmap && (_UH.hdcShadowBitmap != NULL)) {
#else // DISABLE_SHADOW_IN_FULLSCREEN
        if (_UH.hdcShadowBitmap != NULL) {
#endif // DISABLE_SHADOW_IN_FULLSCREEN
            hdc = _UH.hdcShadowBitmap;
        }
        else {
            hdc = _UH.hdcOutputWindow;
        }
        
        // Delete the bitmap if there is one already exists.
        if (_UH.drawNineGridBitmapCache[cacheId].drawNineGridBitmap != NULL) {
            SelectBitmap(_UH.hdcDrawNineGridBitmap, _UH.hUnusedDrawNineGridBitmap);  
            DeleteObject(_UH.drawNineGridBitmapCache[cacheId].drawNineGridBitmap);
            _UH.drawNineGridBitmapCache[cacheId].drawNineGridBitmap = NULL;
        }
    
#if 0
        bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
        bi.bmiHeader.biWidth = _UH.drawNineGridAssembleBufferWidth;
        bi.bmiHeader.biHeight = 0 - _UH.drawNineGridAssembleBufferHeight;
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biBitCount = pOrder->BitmapBpp;
        bi.bmiHeader.biCompression = BI_RGB;
    
        hBitmap = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, 
                                   (VOID**)&pvBits, NULL, 0);
    
    
        if (_UH.drawNineGridAssembleCompressed) {
            memcpy(pvBits, _UH.drawNineGridDecompressionBuffer, _UH.drawNineGridAssembleBufferWidth * 
                   _UH.drawNineGridAssembleBufferHeight * pOrder->BitmapBpp / 8);
        }
        else {
            memcpy(pvBits, _UH.drawNineGridAssembleBuffer, _UH.drawNineGridAssembleBufferWidth * 
                   _UH.drawNineGridAssembleBufferHeight * pOrder->BitmapBpp / 8);            
        }    
#else

        bmi.bmih.biSize = sizeof(bmi.bmih);
        bmi.bmih.biWidth = _UH.drawNineGridAssembleBufferWidth;
        bmi.bmih.biHeight = _UH.drawNineGridAssembleBufferHeight;
        bmi.bmih.biPlanes = 1;
        bmi.bmih.biBitCount = 32;
        bmi.bmih.biCompression = BI_BITFIELDS;
        bmi.bmih.biSizeImage = 0;
        bmi.bmih.biXPelsPerMeter = 0;
        bmi.bmih.biYPelsPerMeter = 0;
        bmi.bmih.biClrUsed = 3;
        bmi.bmih.biClrImportant = 0;
        bmi.masks[0] = 0xff0000;	// red
        bmi.masks[1] = 0x00ff00;	// green
        bmi.masks[2] = 0x0000ff;	// blue
        
        if (_UH.drawNineGridAssembleCompressed) {
            hBitmap = CreateDIBitmap(hdc, &bmi.bmih, CBM_INIT | 0x2, 
                    _UH.drawNineGridDecompressionBuffer, (BITMAPINFO*)&bmi.bmih, DIB_RGB_COLORS);
        }
        else {
            hBitmap = CreateDIBitmap(hdc, &bmi.bmih, CBM_INIT | 0x2, 
                    _UH.drawNineGridAssembleBuffer, (BITMAPINFO*)&bmi.bmih, DIB_RGB_COLORS);
        }
#endif
    
        if (_UH.drawNineGridAssembleBuffer != NULL) {
            UT_Free(_pUt, _UH.drawNineGridAssembleBuffer);
            _UH.drawNineGridAssembleBuffer = NULL;
        }
        
        if (_UH.drawNineGridDecompressionBuffer != NULL) {
            UT_Free(_pUt, _UH.drawNineGridDecompressionBuffer);
            _UH.drawNineGridDecompressionBuffer = NULL;
            _UH.drawNineGridDecompressionBufferSize = 0;
        }

        if (hBitmap != NULL) {
            // set the unused bitmap
            if (_UH.hUnusedDrawNineGridBitmap == NULL)
                _UH.hUnusedDrawNineGridBitmap = SelectBitmap(_UH.hdcDrawNineGridBitmap,
                        hBitmap); 
    
#if 0
            SelectBitmap(_UH.hdcDrawNineGridBitmap, hBitmap);
            SelectPalette(_UH.hdcDrawNineGridBitmap, _UH.hpalCurrent, FALSE);
#endif
            _UH.drawNineGridBitmapCache[cacheId].drawNineGridBitmap = hBitmap;
            _UH.drawNineGridBitmapCache[cacheId].cx = pOrder->cx;
            _UH.drawNineGridBitmapCache[cacheId].cy = pOrder->cy;

            _UH.drawNineGridBitmapCache[cacheId].dngInfo.crTransparent = pOrder->nineGridInfo.crTransparent;
            _UH.drawNineGridBitmapCache[cacheId].dngInfo.flFlags = pOrder->nineGridInfo.flFlags;
            _UH.drawNineGridBitmapCache[cacheId].dngInfo.ulBottomHeight = pOrder->nineGridInfo.ulBottomHeight;
            _UH.drawNineGridBitmapCache[cacheId].dngInfo.ulLeftWidth = pOrder->nineGridInfo.ulLeftWidth;
            _UH.drawNineGridBitmapCache[cacheId].dngInfo.ulRightWidth = pOrder->nineGridInfo.ulRightWidth;
            _UH.drawNineGridBitmapCache[cacheId].dngInfo.ulTopHeight = pOrder->nineGridInfo.ulTopHeight;

            _UH.drawNineGridBitmapCache[cacheId].bitmapBpp = pOrder->BitmapBpp;
    
        } else {

            TRC_ERR((TB, _T("CreateDIBitmap failed\n")));

            // Unable to create the bitmap, send error pdu to the server
            // to disable drawninegrid rendering
            _UH.drawNineGridBitmapCache[cacheId].drawNineGridBitmap = NULL;
            _UH.drawNineGridBitmapCache[cacheId].cx = 0;
            _UH.drawNineGridBitmapCache[cacheId].cy = 0;
            _UH.drawNineGridBitmapCache[cacheId].bitmapBpp = 0;

            if (!_UH.sendDrawNineGridErrorPDU)
                _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                        CD_NOTIFICATION_FUNC(CUH, UHSendDrawNineGridErrorPDU), 0);    
        }
    }
    else {
        _UH.drawNineGridBitmapCache[cacheId].drawNineGridBitmap = NULL;
        _UH.drawNineGridBitmapCache[cacheId].cx = 0;
        _UH.drawNineGridBitmapCache[cacheId].cy = 0;
        _UH.drawNineGridBitmapCache[cacheId].bitmapBpp = 0;        
    }

    *pOrderSize = orderSize;

DC_EXIT_POINT:   
    
    DC_END_FN();
    return hr;
}

/****************************************************************************/
// Name:      UH_DrawNineGrid                                 
//
// DrawNineGrid
/****************************************************************************/
HRESULT DCAPI CUH::UH_DrawNineGrid(PUH_ORDER pOrder, unsigned bitmapId, RECT* psrcRect)
{
    HRESULT hr = S_OK;
    HBITMAP hBitmap;
    TS_DRAW_NINEGRID	stream;
    DS_NINEGRIDINFO ngInfo;
    TSCOLORREF colorRef;
    TS_BITMAPOBJ srcBmpObj;

    DC_BEGIN_FN("UH_DrawNineGrid");

    if (_pCc->_ccCombinedCapabilities.drawNineGridCapabilitySet.drawNineGridSupportLevel < TS_DRAW_NINEGRID_SUPPORTED) {
        TRC_ERR((TB, _T("Recieved draw nine grid order when not expected")));
        DC_QUIT;
    }

    hr = UHIsValidNineGridCacheIndex(bitmapId);
    DC_QUIT_ON_FAIL(hr);

    // Get the drawninegrid bitmap from bitmapid
    hBitmap = _UH.drawNineGridBitmapCache[bitmapId].drawNineGridBitmap;

#if 0 
    SelectObject(_UH.hdcDrawNineGridBitmap, hBitmap);
#endif

    // setup the ninegrid info
    ngInfo.flFlags = _UH.drawNineGridBitmapCache[bitmapId].dngInfo.flFlags;
    ngInfo.ulLeftWidth = _UH.drawNineGridBitmapCache[bitmapId].dngInfo.ulLeftWidth;
    ngInfo.ulRightWidth = _UH.drawNineGridBitmapCache[bitmapId].dngInfo.ulRightWidth;
    ngInfo.ulTopHeight = _UH.drawNineGridBitmapCache[bitmapId].dngInfo.ulTopHeight;
    ngInfo.ulBottomHeight = _UH.drawNineGridBitmapCache[bitmapId].dngInfo.ulBottomHeight;

    // the color ref from server needs to be switched to BGR format
    colorRef = _UH.drawNineGridBitmapCache[bitmapId].dngInfo.crTransparent;
    ngInfo.crTransparent = (colorRef & 0xFF00FF00) | ((colorRef & 0xFF) << 0x10) |  
            ((colorRef & 0xFF0000) >> 0x10);

    // render
    stream.hdr.magic = DS_MAGIC;

    stream.cmdSetTarget.ulCmdID = DS_SETTARGETID;
    stream.cmdSetTarget.hdc = (ULONG)((ULONG_PTR)(_UH.hdcDraw));
    stream.cmdSetTarget.rclDstClip.left = pOrder->dstRect.left;
    stream.cmdSetTarget.rclDstClip.top = pOrder->dstRect.top;
    stream.cmdSetTarget.rclDstClip.right = pOrder->dstRect.right;
    stream.cmdSetTarget.rclDstClip.bottom = pOrder->dstRect.bottom;

    stream.cmdSetSource.ulCmdID = DS_SETSOURCEID;

#if 0
    stream.cmdSetSource.hbm = (ULONG)_UH.hdcDrawNineGridBitmap;
#else
    stream.cmdSetSource.hbm = (ULONG)((ULONG_PTR)hBitmap);
#endif

    stream.cmdNineGrid.ulCmdID = DS_NINEGRIDID;
        
    if (ngInfo.flFlags & DSDNG_MUSTFLIP) {
        stream.cmdNineGrid.rclDst.left = pOrder->dstRect.right;
        stream.cmdNineGrid.rclDst.right = pOrder->dstRect.left;
    }
    else {
        stream.cmdNineGrid.rclDst.left = pOrder->dstRect.left;
        stream.cmdNineGrid.rclDst.right = pOrder->dstRect.right;
    }

    stream.cmdNineGrid.rclDst.top = pOrder->dstRect.top;
    stream.cmdNineGrid.rclDst.bottom = pOrder->dstRect.bottom;

    stream.cmdNineGrid.rclSrc.left = psrcRect->left;
    stream.cmdNineGrid.rclSrc.top = psrcRect->top;
    stream.cmdNineGrid.rclSrc.right = psrcRect->right;
    stream.cmdNineGrid.rclSrc.bottom = psrcRect->bottom;

    stream.cmdNineGrid.ngi = ngInfo;
    
    if (_UH.pfnGdiDrawStream != NULL) {    
        if (!_UH.pfnGdiDrawStream(_UH.hdcDraw, sizeof(stream), &stream)) {
            TRC_ASSERT((FALSE), (TB, _T("GdiDrawStream call failed")));
        }
    }
    else {
        TS_DS_NINEGRID drawNineGridInfo;

        drawNineGridInfo.dng = stream.cmdNineGrid;
        drawNineGridInfo.pfnAlphaBlend = _UH.pfnGdiAlphaBlend;
        drawNineGridInfo.pfnTransparentBlt = _UH.pfnGdiTransparentBlt;
 
        TRC_ASSERT((_UH.pfnGdiAlphaBlend != NULL && _UH.pfnGdiTransparentBlt != NULL),
                   (TB, _T("Can't find AlphaBlend or TransparentBlt funcs")));
        
        srcBmpObj.hdc = _UH.hdcDrawNineGridBitmap;
        
        // The bitmap sent to us is always dword aligned width
        srcBmpObj.sizlBitmap.cx = (_UH.drawNineGridBitmapCache[bitmapId].cx + 3) & ~3;
        srcBmpObj.sizlBitmap.cy = _UH.drawNineGridBitmapCache[bitmapId].cy;

        // We would get 32bpp always for now
        TRC_ASSERT((_UH.drawNineGridBitmapCache[bitmapId].bitmapBpp == 32), 
            (TB, _T("Get non 32bpp source bitmap for drawninegrid")));                

        srcBmpObj.cjBits = srcBmpObj.sizlBitmap.cx * _UH.drawNineGridBitmapCache[bitmapId].cy * 
                _UH.drawNineGridBitmapCache[bitmapId].bitmapBpp / 8;
        srcBmpObj.lDelta = srcBmpObj.sizlBitmap.cx * sizeof(ULONG);
        srcBmpObj.iBitmapFormat = _UH.drawNineGridBitmapCache[bitmapId].bitmapBpp;    
        
        srcBmpObj.pvBits = (PDCUINT8)UT_Malloc(_pUt, srcBmpObj.cjBits);
        if (srcBmpObj.pvBits != NULL) {
            GetBitmapBits(hBitmap, srcBmpObj.cjBits, srcBmpObj.pvBits);
            DrawNineGrid(_UH.hdcDraw, &srcBmpObj, &drawNineGridInfo);
            UT_Free(_pUt, srcBmpObj.pvBits);
        }
        else {
            // send an error pdu for redraw
            if (!_UH.sendDrawNineGridErrorPDU) {
                _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                        CD_NOTIFICATION_FUNC(CUH, UHSendDrawNineGridErrorPDU), 0);  
                DC_QUIT;
            }
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}

#if 0
void DCINTERNAL CUH::UHCreateDrawStreamBitmap(
       PTS_CREATE_DRAW_STREAM_ORDER pOrder)
{
    unsigned cacheId;
    HBITMAP  hBitmap = NULL;
    HDC      hdcDesktop = NULL;
    
    DC_BEGIN_FN("UHCreateDrawStreamBitmap");

    // Get the DrawStream bitmap Id
    cacheId = pOrder->BitmapID;
    
    //TRC_ASSERT((cacheId < _UH.offscrCacheEntries), (TB, _T("Invalid offscreen ")
    //        _T("cache ID")));
    
    TRC_NRM((TB, _T("Create a drawstream bitmap of size (%d, %d)"), pOrder->cx,
             pOrder->cy));

    // Delete the bitmap if there is one already exists.
    if (_UH.drawStreamBitmapCache[cacheId].drawStreamBitmap != NULL) {
        // JOYC: TODO: reuse bitmap
        //if (UH.offscrBitmapCache[cacheId].cx >= pOrder->cx &&
        //        UH.offscrBitmapCache[cacheId].cy >= pOrder->cy) {
        //    return;
        //}
        SelectBitmap(_UH.hdcDrawStreamBitmap, _UH.hUnusedDrawStreamBitmap);  
        DeleteObject(_UH.drawStreamBitmapCache[cacheId].drawStreamBitmap);
        _UH.drawStreamBitmapCache[cacheId].drawStreamBitmap = NULL;
    }

    // Create an offscreen bitmap

    if (_UH.hdcShadowBitmap != NULL) {
        BITMAPINFO bi = { 0 };
        void * pvBits = NULL;

        bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
        bi.bmiHeader.biWidth = pOrder->cx;
        bi.bmiHeader.biHeight = -pOrder->cy;
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biBitCount = pOrder->bitmapBpp;
        bi.bmiHeader.biCompression = BI_RGB;

	
        hBitmap = CreateDIBSection(_UH.hdcShadowBitmap, &bi, DIB_RGB_COLORS, 
                                   (VOID**)&pvBits, NULL, 0);

        if (_UH.drawStreamAssembleBufferWidth == pOrder->cx) {
        
            if (_UH.drawStreamAssembleCompressed) {
                memcpy(pvBits, _UH.drawStreamDecompressionBuffer, pOrder->cx * pOrder->cy * 
                    pOrder->bitmapBpp / 8);
            }
            else {
                memcpy(pvBits, _UH.drawStreamAssembleBuffer, pOrder->cx * pOrder->cy * 
                    pOrder->bitmapBpp / 8);
            }
        }        
    }
    else {
        
        BITMAPINFO bi = { 0 };
        void * pvBits = NULL;

        bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
        bi.bmiHeader.biWidth = pOrder->cx;
        bi.bmiHeader.biHeight = -pOrder->cy;
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biBitCount = pOrder->bitmapBpp;
        bi.bmiHeader.biCompression = BI_RGB;

	
        hBitmap = CreateDIBSection(_UH.hdcOutputWindow, &bi, DIB_RGB_COLORS, 
                                   (VOID**)&pvBits, NULL, 0);

        if (_UH.drawStreamAssembleCompressed) {
            memcpy(pvBits, _UH.drawStreamDecompressionBuffer, pOrder->cx * pOrder->cy * 
                pOrder->bitmapBpp / 8);
        }
        else {
            memcpy(pvBits, _UH.drawStreamAssembleBuffer, pOrder->cx * pOrder->cy * 
                pOrder->bitmapBpp / 8);
        }
    }

    if (hBitmap != NULL) {
        // set the unused bitmap
        if (_UH.hUnusedDrawStreamBitmap == NULL)
            _UH.hUnusedDrawStreamBitmap = SelectBitmap(_UH.hdcDrawStreamBitmap,
                    hBitmap); 

        SelectBitmap(_UH.hdcDrawStreamBitmap, hBitmap);
        
        SelectPalette(_UH.hdcDrawStreamBitmap, _UH.hpalCurrent, FALSE);

        _UH.drawStreamBitmapCache[cacheId].drawStreamBitmap = hBitmap;
        _UH.drawStreamBitmapCache[cacheId].cx = pOrder->cx;
        _UH.drawStreamBitmapCache[cacheId].cy = pOrder->cy;
    } else {
        // Unable to create the bitmap, send error pdu to the server
        // to disable offscreen rendering
        _UH.drawStreamBitmapCache[cacheId].drawStreamBitmap = NULL;
        _UH.drawStreamBitmapCache[cacheId].cx = 0;
        _UH.drawStreamBitmapCache[cacheId].cy = 0;

        //if (!_UH.sendOffscrCacheErrorPDU)
        //    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
        //            CD_NOTIFICATION_FUNC(CUH, UHSendOffscrCacheErrorPDU),
        //            0);
    }

    if (TRUE) {
        
        UHBITMAPINFOPALINDEX bmpInfo = { 0 };

        if (_UH.drawStreamAssembleBufferBpp != 32) {
            memcpy(&bmpInfo, &_UH.pMappedColorTableCache[0], sizeof(UHBITMAPINFOPALINDEX));
    
            bmpInfo.hdr.biWidth = _UH.drawStreamAssembleBufferWidth;
            bmpInfo.hdr.biHeight = _UH.drawStreamAssembleBufferHeight;
            bmpInfo.hdr.biBitCount = (TSUINT16)_UH.drawStreamAssembleBufferBpp;            
        }
        else {
            bmpInfo.hdr.biSize = sizeof(bmpInfo.hdr);
            bmpInfo.hdr.biWidth = _UH.drawStreamAssembleBufferWidth;
            bmpInfo.hdr.biHeight = _UH.drawStreamAssembleBufferHeight;
            bmpInfo.hdr.biPlanes = 1;
            bmpInfo.hdr.biBitCount = (TSUINT16)_UH.drawStreamAssembleBufferBpp;
            bmpInfo.hdr.biCompression = BI_RGB;
        }
        
        if (_UH.drawStreamAssembleCompressed) {
            StretchDIBits(
                    _UH.hdcDrawStreamBitmap,
                    0,
                    0,
                    (int)pOrder->cx,
                    (int)pOrder->cy,
                    0,
                    0,
                    _UH.drawStreamAssembleBufferWidth,
                    _UH.drawStreamAssembleBufferHeight,
                    _UH.drawStreamDecompressionBuffer,
                    (PBITMAPINFO)&bmpInfo.hdr,
                    DIB_RGB_COLORS,
                    SRCCOPY);
        }
        else {

            StretchDIBits(
                    _UH.hdcDrawStreamBitmap,
                    0,
                    0,
                    (int)pOrder->cx,
                    (int)pOrder->cy,   
                    0,
                    0,
                    _UH.drawStreamAssembleBufferWidth,
                    _UH.drawStreamAssembleBufferHeight,
                    _UH.drawStreamAssembleBuffer,
                    (PBITMAPINFO)&bmpInfo.hdr,
                    DIB_RGB_COLORS,
                    SRCCOPY);           
        }
    }

    DC_END_FN();
}

unsigned drawStreamSize = 0;
unsigned drawStreamPktSize = 0;
unsigned drawStreamClipSize = 0;
unsigned numDrawStreams = 0;

void DCINTERNAL CUH::UHDecodeDrawStream(PBYTE streamIn, unsigned streamSize, PBYTE streamOut,
                                        unsigned *streamSizeOut)
{
    PBYTE pul = (PBYTE) streamIn;
    ULONG cjIn = streamSize;

    DC_BEGIN_FN("UHDecodeDrawStream");

    *streamSizeOut = 0;

    while(cjIn > 0)
    {
        BYTE   command = *pul;
        unsigned commandSize;

        switch(command)
        {
        
        case DS_COPYTILEID: 
        {        
            RDP_DS_COPYTILE * rdpcmd = (RDP_DS_COPYTILE *) pul;
            DS_COPYTILE * cmd = (DS_COPYTILE *) streamOut;
            
            commandSize = sizeof(*rdpcmd);

            if (cjIn < commandSize) {
                DC_QUIT;
            }

            cmd->ulCmdID = rdpcmd->ulCmdID;
            TSRECT16_TO_RECTL(cmd->rclDst, rdpcmd->rclDst);
            TSRECT16_TO_RECTL(cmd->rclSrc, rdpcmd->rclSrc);
            TSPOINT16_TO_POINTL(cmd->ptlOrigin, rdpcmd->ptlOrigin);

            *streamSizeOut += sizeof(DS_COPYTILE);
            streamOut += sizeof(DS_COPYTILE);
        }
        break;
    
        case DS_SOLIDFILLID: 
        {         
            RDP_DS_SOLIDFILL * rdpcmd = (RDP_DS_SOLIDFILL *) pul;
            DS_SOLIDFILL * cmd = (DS_SOLIDFILL *) streamOut;
    
            commandSize = sizeof(*rdpcmd);
    
            if (cjIn < commandSize) {
                DC_QUIT;
            }

            cmd->ulCmdID = rdpcmd->ulCmdID;
            cmd->crSolidColor = rdpcmd->crSolidColor;

            TSRECT16_TO_RECTL(cmd->rclDst, rdpcmd->rclDst);
            
            *streamSizeOut += sizeof(DS_SOLIDFILL);
            streamOut += sizeof(DS_SOLIDFILL);
        }
        break;
    
        case DS_TRANSPARENTTILEID: 
        {         
            RDP_DS_TRANSPARENTTILE * rdpcmd = (RDP_DS_TRANSPARENTTILE *) pul;
            DS_TRANSPARENTTILE * cmd = (DS_TRANSPARENTTILE *) streamOut;
    
            commandSize = sizeof(*rdpcmd);
    
            if (cjIn < commandSize) {
                DC_QUIT;
            }
    
            cmd->ulCmdID = rdpcmd->ulCmdID;
            cmd->crTransparentColor = rdpcmd->crTransparentColor;
            TSRECT16_TO_RECTL(cmd->rclDst, rdpcmd->rclDst);
            TSRECT16_TO_RECTL(cmd->rclSrc, rdpcmd->rclSrc);
            TSPOINT16_TO_POINTL(cmd->ptlOrigin, rdpcmd->ptlOrigin);

            *streamSizeOut += sizeof(DS_TRANSPARENTTILE);
            streamOut += sizeof(DS_TRANSPARENTTILE);
    
        }
        break;
    
        case DS_ALPHATILEID: 
        {         
            RDP_DS_ALPHATILE * rdpcmd = (RDP_DS_ALPHATILE *) pul;
            DS_ALPHATILE * cmd = (DS_ALPHATILE *) streamOut;
    
            commandSize = sizeof(*rdpcmd);
    
            if (cjIn < commandSize) {
                DC_QUIT;
            }
    
            cmd->ulCmdID = rdpcmd->ulCmdID;
            cmd->blendFunction.AlphaFormat = rdpcmd->blendFunction.AlphaFormat;
            cmd->blendFunction.BlendFlags = rdpcmd->blendFunction.BlendFlags;
            cmd->blendFunction.BlendOp = rdpcmd->blendFunction.BlendOp;
            cmd->blendFunction.SourceConstantAlpha = rdpcmd->blendFunction.SourceConstantAlpha;

            TSRECT16_TO_RECTL(cmd->rclDst, rdpcmd->rclDst);
            TSRECT16_TO_RECTL(cmd->rclSrc, rdpcmd->rclSrc);
            TSPOINT16_TO_POINTL(cmd->ptlOrigin, rdpcmd->ptlOrigin);

            *streamSizeOut += sizeof(DS_ALPHATILE);
            streamOut += sizeof(DS_ALPHATILE);
        }
        break;
    
        case DS_STRETCHID: 
        {         
            RDP_DS_STRETCH * rdpcmd = (RDP_DS_STRETCH *) pul;
            DS_STRETCH * cmd = (DS_STRETCH *) streamOut;
    
            commandSize = sizeof(*rdpcmd);
    
            if (cjIn < commandSize) {
                DC_QUIT;
            }
    
            cmd->ulCmdID = rdpcmd->ulCmdID;
            TSRECT16_TO_RECTL(cmd->rclDst, rdpcmd->rclDst);
            TSRECT16_TO_RECTL(cmd->rclSrc, rdpcmd->rclSrc);
            
            *streamSizeOut += sizeof(DS_STRETCH);
            streamOut += sizeof(DS_STRETCH);                
        }
        break;
    
        case DS_TRANSPARENTSTRETCHID: 
        {         
            RDP_DS_TRANSPARENTSTRETCH * rdpcmd = (RDP_DS_TRANSPARENTSTRETCH *) pul;
            DS_TRANSPARENTSTRETCH * cmd = (DS_TRANSPARENTSTRETCH *) streamOut;
    
            commandSize = sizeof(*rdpcmd);
    
            if (cjIn < commandSize) {
                DC_QUIT;
            }
    
            cmd->ulCmdID = rdpcmd->ulCmdID;
            cmd->crTransparentColor = rdpcmd->crTransparentColor;
            TSRECT16_TO_RECTL(cmd->rclDst, rdpcmd->rclDst);
            TSRECT16_TO_RECTL(cmd->rclSrc, rdpcmd->rclSrc);
            
            *streamSizeOut += sizeof(DS_TRANSPARENTSTRETCH);
            streamOut += sizeof(DS_TRANSPARENTSTRETCH);
        }
        break;
    
        case DS_ALPHASTRETCHID: 
        {         
            RDP_DS_ALPHASTRETCH * rdpcmd = (RDP_DS_ALPHASTRETCH *) pul;
            DS_ALPHASTRETCH * cmd = (DS_ALPHASTRETCH *) streamOut;
    
            commandSize = sizeof(*rdpcmd);
    
            if (cjIn < commandSize) {
                DC_QUIT;
            }

            cmd->ulCmdID = rdpcmd->ulCmdID;
            cmd->blendFunction.AlphaFormat = rdpcmd->blendFunction.AlphaFormat;
            cmd->blendFunction.BlendFlags = rdpcmd->blendFunction.BlendFlags;
            cmd->blendFunction.BlendOp = rdpcmd->blendFunction.BlendOp;
            cmd->blendFunction.SourceConstantAlpha = rdpcmd->blendFunction.SourceConstantAlpha;


            TSRECT16_TO_RECTL(cmd->rclDst, rdpcmd->rclDst);
            TSRECT16_TO_RECTL(cmd->rclSrc, rdpcmd->rclSrc);
    
    
            *streamSizeOut += sizeof(DS_ALPHASTRETCH);
            streamOut += sizeof(DS_ALPHASTRETCH);
        }
        break;
    
        default: 
        {
            DC_QUIT;
        }
        
        }
    
        cjIn -= commandSize;
        pul += commandSize;
    }

DC_EXIT_POINT:

    DC_END_FN();
}

/****************************************************************************/
// Name:      UHDrawStream
/****************************************************************************/
unsigned DCINTERNAL CUH::UHDrawStream(PTS_DRAW_STREAM_ORDER pOrder)
{
    typedef struct _DSSTREAM
    {
        DS_HEADER				hdr;
        DS_SETTARGET			cmdSetTarget;
        DS_SETSOURCE			cmdSetSource;        
    } DSSTREAM;

    unsigned bitmapId;
    unsigned orderSize, streamSize;
    HBITMAP hBitmap;
    DSSTREAM	*stream;
    ULONG	magic = 'DrwQ';
    PBYTE streamData;
    TS_RECTANGLE16 *clipRects;
    
    DC_BEGIN_FN("UHDrawStream");

    bitmapId = pOrder->BitmapID;

    hBitmap = _UH.drawStreamBitmapCache[bitmapId].drawStreamBitmap;
    SelectObject(_UH.hdcDrawStreamBitmap, hBitmap);

    orderSize = sizeof(TS_DRAW_STREAM_ORDER) + pOrder->StreamLen +
            sizeof(TS_RECTANGLE16) * pOrder->nClipRects;

    drawStreamPktSize += orderSize;
    drawStreamSize += pOrder->StreamLen;
    drawStreamClipSize += sizeof(TS_RECTANGLE16) * pOrder->nClipRects;
    numDrawStreams += 1;

    // JOYC: todo need to lookinto how much to allocate.
    stream = (DSSTREAM *) UT_Malloc(_pUt, sizeof(DSSTREAM) + pOrder->StreamLen * 2);

    if (stream) {
        HRGN hrgnUpdate;

        // render
        stream->hdr.magic = DS_MAGIC;
    
    	  stream->cmdSetTarget.ulCmdID = DS_SETTARGETID;
    	  stream->cmdSetTarget.hdc = _UH.hdcDraw;
    	  stream->cmdSetTarget.rclDstClip.left = pOrder->Bounds.left;
    	  stream->cmdSetTarget.rclDstClip.top = pOrder->Bounds.top;
    	  stream->cmdSetTarget.rclDstClip.right = pOrder->Bounds.right;
    	  stream->cmdSetTarget.rclDstClip.bottom = pOrder->Bounds.bottom;
    
    	  stream->cmdSetSource.ulCmdID = DS_SETSOURCEID;
    	  stream->cmdSetSource.hdc = _UH.hdcDrawStreamBitmap;
    
        // Need to setup the clip region
        clipRects = (TS_RECTANGLE16 *)(pOrder + 1);
    
        streamData = (PBYTE)clipRects + sizeof(TS_RECTANGLE16) * pOrder->nClipRects;
    
        UHDecodeDrawStream(streamData, pOrder->StreamLen, (PBYTE)(stream + 1), &streamSize);
        streamSize += sizeof(DSSTREAM);

        hrgnUpdate = CreateRectRgn(0, 0, 0, 0);
        SetRectRgn(hrgnUpdate, 0, 0, 0, 0);

        for (int i = 0; i < pOrder->nClipRects; i++) {
            UH_ORDER OrderRect;

            OrderRect.dstRect.left = clipRects[i].left;
            OrderRect.dstRect.top = clipRects[i].top;
            OrderRect.dstRect.right = clipRects[i].right;
            OrderRect.dstRect.bottom = clipRects[i].bottom;

            UHAddUpdateRegion(&OrderRect, hrgnUpdate);            

#if 0
            UH_HatchRectDC(_UH.hdcOutputWindow, OrderRect.dstRect.left,
                       OrderRect.dstRect.top,
                       OrderRect.dstRect.right,
                       OrderRect.dstRect.bottom,
                       UH_RGB_GREEN,
                       UH_BRUSHTYPE_FDIAGONAL );
#endif
        }

        UH_ResetClipRegion();

        if (pOrder->nClipRects) {
#if defined (OS_WINCE)
            _UH.validClipDC = NULL;
#endif
            SelectClipRgn(_UH.hdcDraw, hrgnUpdate);
        }

        if (ExtEscape(_UH.hdcDraw, 201, sizeof(magic), (char *) &magic, 0, NULL))
    	  {

            ExtEscape(NULL, 200, streamSize, (char *) stream, 0, NULL);
    	  }
    	  else
    	  {
    	      // Emulate
    	      DrawStream(streamSize, stream);
		  }


        if (_UH.hdcDraw == _UH.hdcShadowBitmap) {

            SelectClipRgn(_UH.hdcOutputWindow, NULL);

            if (pOrder->nClipRects) {
                SelectClipRgn(_UH.hdcOutputWindow, hrgnUpdate);
                DeleteRgn(hrgnUpdate);
            }
    
    //#ifdef SMART_SIZING
    //        if (!_pOp->OP_CopyShadowToDC(_UH.hdcOutputWindow, pRectangle->destLeft, 
    //                pRectangle->destTop, bltSize.width, bltSize.height)) {
    //            TRC_ERR((TB, _T("OP_CopyShadowToDC failed")));
    //        }
    //#else // SMART_SIZING

            if (!BitBlt( _UH.hdcOutputWindow,
                         pOrder->Bounds.left,
                         pOrder->Bounds.top,
                         pOrder->Bounds.right - pOrder->Bounds.left,
                         pOrder->Bounds.bottom - pOrder->Bounds.top,
                         _UH.hdcShadowBitmap,
                         pOrder->Bounds.left,
                         pOrder->Bounds.top,
                         SRCCOPY ))
            {
                TRC_ERR((TB, _T("BitBlt failed")));
            }
        }
		  else {
			   DeleteRgn(hrgnUpdate);
	     }
      
        // cleanup
    }

    return orderSize;
}

unsigned DCINTERNAL CUH::UHDrawNineGrid(PTS_DRAW_NINEGRID_ORDER pOrder)
{
    typedef struct _DSSTREAM
    {
        DS_HEADER				hdr;
        DS_SETTARGET			cmdSetTarget;
        DS_SETSOURCE			cmdSetSource;  
        DS_NINEGRID        cmdNineGrid;
    } DSSTREAM;

    unsigned bitmapId;
    unsigned orderSize;
    HBITMAP hBitmap;
    DSSTREAM	stream;
    ULONG	magic = 'DrwQ';
    TS_RECTANGLE16 *clipRects;
    DS_NINEGRIDINFO ngInfo;
    BYTE BitmapBits[32 * 1024];
    
    DC_BEGIN_FN("UHDrawStream");

    bitmapId = pOrder->BitmapID;

    hBitmap = _UH.drawStreamBitmapCache[bitmapId].drawStreamBitmap;
    ngInfo.flFlags = _UH.drawStreamBitmapCache[bitmapId].dngInfo.flFlags;
    ngInfo.ulLeftWidth = _UH.drawStreamBitmapCache[bitmapId].dngInfo.ulLeftWidth;
    ngInfo.ulRightWidth = _UH.drawStreamBitmapCache[bitmapId].dngInfo.ulRightWidth;
    ngInfo.ulTopHeight = _UH.drawStreamBitmapCache[bitmapId].dngInfo.ulTopHeight;
    ngInfo.ulBottomHeight = _UH.drawStreamBitmapCache[bitmapId].dngInfo.ulBottomHeight;
    ngInfo.crTransparent = _UH.drawStreamBitmapCache[bitmapId].dngInfo.crTransparent;
    
    SelectObject(_UH.hdcDrawStreamBitmap, hBitmap);

    orderSize = sizeof(TS_DRAW_NINEGRID_ORDER) + pOrder->nClipRects *
            sizeof(TS_RECTANGLE16);

    drawStreamPktSize += orderSize;
    drawStreamClipSize += sizeof(TS_RECTANGLE16) * pOrder->nClipRects;
    numDrawStreams += 1;

    
    HRGN hrgnUpdate;

    // render
    stream.hdr.magic = DS_MAGIC;

    stream.cmdSetTarget.ulCmdID = DS_SETTARGETID;
    stream.cmdSetTarget.hdc = _UH.hdcDraw;
    stream.cmdSetTarget.rclDstClip.left = pOrder->Bounds.left;
    stream.cmdSetTarget.rclDstClip.top = pOrder->Bounds.top;
    stream.cmdSetTarget.rclDstClip.right = pOrder->Bounds.right;
    stream.cmdSetTarget.rclDstClip.bottom = pOrder->Bounds.bottom;

    stream.cmdSetSource.ulCmdID = DS_SETSOURCEID;
    stream.cmdSetSource.hdc = (HDC)hBitmap;

    stream.cmdNineGrid.ulCmdID = DS_NINEGRIDID;
    stream.cmdNineGrid.rclDst.left = pOrder->Bounds.left;
    stream.cmdNineGrid.rclDst.top = pOrder->Bounds.top;
    stream.cmdNineGrid.rclDst.right = pOrder->Bounds.right;
    stream.cmdNineGrid.rclDst.bottom = pOrder->Bounds.bottom;
    stream.cmdNineGrid.rclSrc.left = pOrder->srcBounds.left;
    stream.cmdNineGrid.rclSrc.top = pOrder->srcBounds.top;
    stream.cmdNineGrid.rclSrc.right = pOrder->srcBounds.right;
    stream.cmdNineGrid.rclSrc.bottom = pOrder->srcBounds.bottom;
    stream.cmdNineGrid.ngi = ngInfo;
    
    // Need to setup the clip region
    clipRects = (TS_RECTANGLE16 *)(pOrder + 1);
    
    hrgnUpdate = CreateRectRgn(0, 0, 0, 0);
    SetRectRgn(hrgnUpdate, 0, 0, 0, 0);

    for (int i = 0; i < pOrder->nClipRects; i++) {
        UH_ORDER OrderRect;

        OrderRect.dstRect.left = clipRects[i].left;
        OrderRect.dstRect.top = clipRects[i].top;
        OrderRect.dstRect.right = clipRects[i].right;
        OrderRect.dstRect.bottom = clipRects[i].bottom;

        UHAddUpdateRegion(&OrderRect, hrgnUpdate);            
    }

    UH_ResetClipRegion();

    if (pOrder->nClipRects) {
#if defined (OS_WINCE)
        _UH.validClipDC = NULL;
#endif
        SelectClipRgn(_UH.hdcDraw, hrgnUpdate);
    }
  
    ExtEscape(_UH.hdcDraw, 200, sizeof(stream), (char*) &stream, 0, NULL);

    if (_UH.hdcDraw == _UH.hdcShadowBitmap) {

        SelectClipRgn(_UH.hdcOutputWindow, NULL);

        if (pOrder->nClipRects) {
            SelectClipRgn(_UH.hdcOutputWindow, hrgnUpdate);
            DeleteRgn(hrgnUpdate);
        }

//#ifdef SMART_SIZING
//        if (!_pOp->OP_CopyShadowToDC(_UH.hdcOutputWindow, pRectangle->destLeft, 
//                pRectangle->destTop, bltSize.width, bltSize.height)) {
//            TRC_ERR((TB, _T("OP_CopyShadowToDC failed")));
//        }
//#else // SMART_SIZING

        if (!BitBlt( _UH.hdcOutputWindow,
                     pOrder->Bounds.left,
                     pOrder->Bounds.top,
                     pOrder->Bounds.right - pOrder->Bounds.left,
                     pOrder->Bounds.bottom - pOrder->Bounds.top,
                     _UH.hdcShadowBitmap,
                     pOrder->Bounds.left,
                     pOrder->Bounds.top,
                     SRCCOPY ))
        {
            TRC_ERR((TB, _T("BitBlt failed")));
        }
    }
    else {
        DeleteRgn(hrgnUpdate);
    }
  
    // cleanup
    return orderSize;    
}

#endif
#endif //DRAW_NINEGRID

/****************************************************************************/
/* Name:      UHCalculateColorTableMapping                                  */
/*                                                                          */
/* Purpose:   Calculates a Mapped Color Table from a given Color Table      */
/*            Cache entry to the current palette. The mapping is stored     */
/*            in _UH.pMappedColorTableCache[cachId].                         */
/****************************************************************************/
// SECURITY: Caller must verify the cacheId
void DCINTERNAL CUH::UHCalculateColorTableMapping(unsigned cacheId)
{
    BOOL bIdentityPalette;
    unsigned i;

    DC_BEGIN_FN("UHCalculateColorTableMapping");

    bIdentityPalette = TRUE;
    for (i = 0; i < 256; i++) {
        _UH.pMappedColorTableCache[cacheId].paletteIndexTable[i] = (UINT16)
                GetNearestPaletteIndex(_UH.hpalCurrent,
                RGB(_UH.pColorTableCache[cacheId].rgb[i].rgbtRed,
                _UH.pColorTableCache[cacheId].rgb[i].rgbtGreen,
                _UH.pColorTableCache[cacheId].rgb[i].rgbtBlue));

        TRC_DBG((TB, _T("Mapping %#2x->%#2x"), i,
                _UH.pMappedColorTableCache[cacheId].paletteIndexTable[i]));

        // An identity palette has palette indices that match the index number
        // (i.e. the array contents look like [0, 1, 2, 3, ..., 255]).
        if (_UH.pMappedColorTableCache[cacheId].paletteIndexTable[i] != i)
            bIdentityPalette = FALSE;
    }

    // Cache the identity palette flag for use during UHDIBCopyBits().
    _UH.pMappedColorTableCache[cacheId].bIdentityPalette = bIdentityPalette;

    DC_END_FN();
}


/****************************************************************************/
// Name:      UHDrawOffscrBitmapBits                                        
//
// Draw the offscreen bitmap onto the screen or another offscreen bitmap
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHDrawOffscrBitmapBits(HDC hdc, MEMBLT_COMMON FAR *pMB)
{
    HRESULT hr = S_OK;
    UINT32 windowsROP = UHConvertToWindowsROP((unsigned)pMB->bRop);
    unsigned cacheId;
    HBITMAP  hBitmap, hbmOld;

    DC_BEGIN_FN("UHDrawOffscrBitmapBits");

    cacheId = pMB->cacheIndex;
    hr = UHIsValidOffsreenBitmapCacheIndex(cacheId);
    DC_QUIT_ON_FAIL(hr);

    hBitmap = _UH.offscrBitmapCache[cacheId].offscrBitmap;

    if (hBitmap != NULL) {
#if defined (OS_WINCE)
        _UH.validClipDC = NULL;
#endif
        hbmOld = (HBITMAP)SelectObject(_UH.hdcOffscreenBitmap, hBitmap);
        if (_UH.protocolBpp <= 8) {
            SelectPalette(_UH.hdcOffscreenBitmap, _UH.hpalCurrent, FALSE);
        }

        if (!BitBlt(hdc, (int)pMB->nLeftRect, (int)pMB->nTopRect,
                    (int)pMB->nWidth, (int)pMB->nHeight, _UH.hdcOffscreenBitmap,
                    (int)pMB->nXSrc,
                    (int)pMB->nYSrc,
                    windowsROP))
        {
            TRC_ERR((TB, _T("BitBlt failed")));
        }
        else {
            _pClx->CLX_ClxOffscrOut(_UH.hdcOffscreenBitmap, 
                                    (int)pMB->nLeftRect, (int)pMB->nTopRect);
        }
    }

#if 0
    
    UH_HatchRect((int)pMB->nLeftRect, (int)pMB->nTopRect,
                 (int)(pMB->nLeftRect + pMB->nWidth),
                 (int)(pMB->nTopRect + pMB->nHeight),
                 UH_RGB_YELLOW,
                 UH_BRUSHTYPE_FDIAGONAL );
    
#endif

    //hbmOld = SelectObject(UH.hdcOffscreenBitmap, 
    //                      hbmOld);
    //hpalOld = SelectPalette(UH.hdcOffscreenBitmap, 
    //                        hpalOld, FALSE);

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}

/**********************************************************************/
// UHLoadBitmapBits
//
// Find the memory entry where the cached bitmap is stored
// In the persistent caching case, the bitmap may not be in memory
// at this time.  So we need to load it into the memory
/**********************************************************************/
// SECURITY - caller must verify cacheId and cacheIndex
inline void DCINTERNAL CUH::UHLoadBitmapBits(
        UINT cacheId,
        UINT32 cacheIndex,
        PUHBITMAPCACHEENTRYHDR *ppCacheEntryHdr,
        PBYTE *ppBitmapBits)
{
    DC_BEGIN_FN("UHLoadBitmapBits");

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    // If the bitmap is noncachable, i.e. in the waiting list, we
    // retrieve the bitmap bits from the last cache entry
    if (cacheIndex == BITMAPCACHE_WAITING_LIST_INDEX) {
        *ppCacheEntryHdr = &(_UH.bitmapCache[cacheId].Header[
                _UH.bitmapCache[cacheId].BCInfo.NumEntries]);

        *ppBitmapBits = _UH.bitmapCache[cacheId].Entries +
                UHGetOffsetIntoCache(
                _UH.bitmapCache[cacheId].BCInfo.NumEntries, cacheId);

        DC_QUIT;
    }

    if (_UH.bitmapCache[cacheId].BCInfo.bSendBitmapKeys) {
        ULONG memEntry;
        PUHBITMAPCACHEPTE pPTE;

        // this cache is marked persistent.  So we need to check if the bitmap
        // is in memory or not
        pPTE = &(_UH.bitmapCache[cacheId].PageTable.PageEntries[cacheIndex]);
        if (pPTE->iEntryToMem < _UH.bitmapCache[cacheId].BCInfo.NumEntries) {
            // the bitmap is in memory, so we can just reference it, done
            *ppCacheEntryHdr = &_UH.bitmapCache[cacheId].Header[pPTE->iEntryToMem];

#ifdef DC_HICOLOR
            *ppBitmapBits = _UH.bitmapCache[cacheId].Entries +
                            UHGetOffsetIntoCache(pPTE->iEntryToMem, cacheId);
#else
            *ppBitmapBits = _UH.bitmapCache[cacheId].Entries +
                    pPTE->iEntryToMem * UH_CellSizeFromCacheID(cacheId);
#endif
        }
        else {
            // the entry is not in memory.  We have to load it to memory

            // try to find a free memory entry if it is possible
            memEntry = UHFindFreeCacheEntry(cacheId);
            if (memEntry >= _UH.bitmapCache[cacheId].BCInfo.NumEntries) {
                // All cache memory entries are full.
                // We need to evict an entry from the cache memory
                memEntry = UHEvictLRUCacheEntry(cacheId);
                TRC_ASSERT((memEntry < _UH.bitmapCache[cacheId].BCInfo.NumEntries),
                        (TB, _T("Broken MRU list")));
            }

            // now we are ready to load the bitmap to memory
            pPTE->iEntryToMem = memEntry;
            *ppCacheEntryHdr = &_UH.bitmapCache[cacheId].Header[memEntry];
#ifdef DC_HICOLOR
            *ppBitmapBits = _UH.bitmapCache[cacheId].Entries +
                            UHGetOffsetIntoCache(memEntry, cacheId);
#else
            *ppBitmapBits = _UH.bitmapCache[cacheId].Entries + memEntry *
                    UH_CellSizeFromCacheID(cacheId);
#endif
            // try to load the bitmap file into memory
            if (SUCCEEDED(UHLoadPersistentBitmap(
                    _UH.bitmapCache[cacheId].PageTable.CacheFileInfo.hCacheFile,
                    cacheIndex * (UH_CellSizeFromCacheID(cacheId) + sizeof(UHBITMAPFILEHDR)),
                    cacheId, memEntry, pPTE))) {
                TRC_NRM((TB, _T("Load the bitmap file %s to memory"),
                        _UH.PersistCacheFileName));

#ifdef DC_DEBUG
                // Update the bitmap cache monitor display
                UHCacheEntryLoadedFromDisk(cacheId, cacheIndex);
#endif

            }
            else {
                UINT32 currentTickCount;

                // invalidate the pte entry by setting the bitmap data length on disk to 0
                pPTE->bmpInfo.Key1 = 0;
                pPTE->bmpInfo.Key2 = 0;

                // since we failed to load the bitmap in memory,
                // we need to create a replacement bitmap
                (*ppCacheEntryHdr)->bitmapWidth =
                (*ppCacheEntryHdr)->bitmapHeight =
                        (DCUINT16) (UH_CACHE_0_DIMENSION << cacheId);
#ifdef DC_HICOLOR
                (*ppCacheEntryHdr)->bitmapLength = (*ppCacheEntryHdr)->bitmapWidth
                                                   * (*ppCacheEntryHdr)->bitmapHeight
                                                   * _UH.copyMultiplier;
#else
                (*ppCacheEntryHdr)->bitmapLength = (*ppCacheEntryHdr)->bitmapWidth *
                        (*ppCacheEntryHdr)->bitmapHeight;
#endif
                (*ppCacheEntryHdr)->hasData = TRUE;

                // we just use a black bitmap to replace the missing one
                DC_MEMSET(*ppBitmapBits, 0, (*ppCacheEntryHdr)->bitmapLength);

                TRC_ALT((TB, _T("Unable to load the specified bitmap, use a replacement ")
                        _T("bitmap instead")));

                // for the duration of a session, we can only send maximum
                // MAX_NUM_ERROR_PDU_SEND numbers of error pdus to the server
                // this is to avoid client flooding the server with error pdus
                if (_UH.totalNumErrorPDUs < MAX_NUM_ERROR_PDU_SEND) {
                    // get the current tick count
                    currentTickCount = GetTickCount();

                    // if the last time we sent an error pdu is over a minute
                    // (60000 milli seconds) ago or if the system tick count gets
                    // rolled over after the last sent error pdu (so current tick
                    // count is less than last time error pdu sent), we will allow
                    // a new error pdu to be sent.  otherwise, we will not allow
                    // a new error pdu to be sent
                    if (currentTickCount < _UH.lastTimeErrorPDU[cacheId]
                            || currentTickCount - _UH.lastTimeErrorPDU[cacheId] > 60000) {

                        // update counters and flags
                        _UH.totalNumErrorPDUs++;
                        _UH.lastTimeErrorPDU[cacheId] = currentTickCount;

                        _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                            CD_NOTIFICATION_FUNC(CUH,UHSendBitmapCacheErrorPDU), cacheId);
                    }
                }
                else {
                    // we can't send anymore error pdus, so we have to inform
                    // the user at this point
                    if (!_UH.bWarningDisplayed) {
                        // we should display a warning message to the user
                        // if we haven't already done so.
                        _UH.bWarningDisplayed = TRUE;

                        _pCd->CD_DecoupleSimpleNotification(CD_UI_COMPONENT,
                                _pUi, CD_NOTIFICATION_FUNC(CUI,UI_DisplayBitmapCacheWarning), 0);
                    }
                }
            }
        }
        // update the mru list
        UHTouchMRUCacheEntry(cacheId, cacheIndex);
    }
    else {
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

        // without persistent caching, the bitmap is definitely in memory
        // so we can simply reference to the cache memory
        *ppCacheEntryHdr = &(_UH.bitmapCache[cacheId].Header[cacheIndex]);
#ifdef DC_HICOLOR
        *ppBitmapBits = _UH.bitmapCache[cacheId].Entries +
                        UHGetOffsetIntoCache(cacheIndex, cacheId);
#else
        *ppBitmapBits = _UH.bitmapCache[cacheId].Entries +
                        cacheIndex * UH_CellSizeFromCacheID(cacheId);
#endif
#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
    }
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

DC_EXIT_POINT:
    DC_END_FN();
}


/****************************************************************************/
/* Name:      UHGetMemBltBits                                               */
/*                                                                          */
/* Purpose:   Get the bits to draw for a MemBlt order                       */
/*                                                                          */
/* Returns:   pointer to the bitmap bits                                    */
/*                                                                          */
/* Params:                                                                  */
/* IN                                                                       */
/*     hdc              : destination Device Context                        */
/*     cacheId          : the color table and bitmap cache ids to use       */
/*     bitmapCacheEntry : the bitmap cache entry to use                     */
/*                                                                          */
/* OUT                                                                      */
/*     colorTablecacheEntry : the col table cache entry to use              */
/*     pCacheEntryHeader    : the cacheentry                                */
/****************************************************************************/
PBYTE DCINTERNAL CUH::UHGetMemBltBits(
        HDC hdc,
        unsigned cacheId,
        unsigned bitmapCacheEntry,
        unsigned *pColorTableCacheEntry,
        PUHBITMAPCACHEENTRYHDR *ppCacheEntryHdr)
{
    unsigned bitmapCacheId;
    PBYTE pBitmapBits;

    DC_BEGIN_FN("UHGetMemBltBits");

    DC_IGNORE_PARAMETER(hdc);

    *pColorTableCacheEntry = DCHI8(cacheId);
    bitmapCacheId        = DCLO8(cacheId);

    TRC_DBG((TB,
        _T("colorTableCacheEntry(%u) bitmapCacheId(%u) bitmapCacheEntry(%u)"),
                      *pColorTableCacheEntry, bitmapCacheId, bitmapCacheEntry));

    if (SUCCEEDED(UHIsValidBitmapCacheID(bitmapCacheId)) && 
        SUCCEEDED(UHIsValidBitmapCacheIndex(bitmapCacheId, bitmapCacheEntry)))
    {
#ifdef DC_DEBUG
        if (_UH.MonitorEntries[0] != NULL && 
                bitmapCacheEntry != BITMAPCACHE_WAITING_LIST_INDEX) {
            UHCacheEntryUsed(bitmapCacheId, bitmapCacheEntry, *pColorTableCacheEntry);
            if (hdc == _UH.hdcDraw)
            {
                /********************************************************************/
                /* Increment the usage count. The Bitmap Cache Monitor calls this   */
                /* function - and we don't want to update the usage count for its   */
                /* calls, only orders that arrived in PDUs.                         */
                /********************************************************************/
                _UH.MonitorEntries[bitmapCacheId][bitmapCacheEntry].UsageCount++;
            }
        }
#endif
        // find the memory entry where the cached bitmap is stored
        UHLoadBitmapBits(bitmapCacheId, bitmapCacheEntry, ppCacheEntryHdr,
                         &pBitmapBits);
    }
    else
    {
        pBitmapBits = NULL;
        DC_QUIT;
    }

    if ((*ppCacheEntryHdr)->hasData)
    {
        _UH.pMappedColorTableCache[*pColorTableCacheEntry].hdr.biWidth =
                (*ppCacheEntryHdr)->bitmapWidth;
        _UH.pMappedColorTableCache[*pColorTableCacheEntry].hdr.biHeight =
                (*ppCacheEntryHdr)->bitmapHeight;

        TRC_ASSERT(((*ppCacheEntryHdr)->bitmapHeight < 65536),
                (TB, _T("cache entry bitmap height unexpectedly exceeds 16-bits")));

#ifdef DC_HICOLOR
        TRC_ASSERT(!IsBadReadPtr(pBitmapBits,
                                 (DCUINT)((*ppCacheEntryHdr)->bitmapWidth *
                                          (*ppCacheEntryHdr)->bitmapHeight *
                                          _UH.copyMultiplier)),
                   (TB, _T("Decompressed %ux%u bitmap: not %u bytes readable"),
                      (DCUINT)(*ppCacheEntryHdr)->bitmapWidth,
                      (DCUINT)(*ppCacheEntryHdr)->bitmapHeight,
                      (DCUINT)((*ppCacheEntryHdr)->bitmapWidth *
                               (*ppCacheEntryHdr)->bitmapHeight *
                               _UH.copyMultiplier)));
#else
        TRC_ASSERT(!IsBadReadPtr(pBitmapBits,
                                 (DCUINT)((*ppCacheEntryHdr)->bitmapWidth *
                                          (*ppCacheEntryHdr)->bitmapHeight)),
                      (TB, _T("Decompressed %ux%u bitmap: not %u bytes readable"),
                      (DCUINT)(*ppCacheEntryHdr)->bitmapWidth,
                      (DCUINT)(*ppCacheEntryHdr)->bitmapHeight,
                      (DCUINT)((*ppCacheEntryHdr)->bitmapWidth *
                               (*ppCacheEntryHdr)->bitmapHeight)));
#endif
    }
    else {
        TRC_ERR((TB, _T("Cache entry %u:%u referenced before being filled"),
                                            bitmapCacheId, bitmapCacheEntry));
        pBitmapBits = NULL;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return pBitmapBits;
}


/****************************************************************************/
/* Name:      UHDrawMemBltOrder                                             */
/*                                                                          */
/* Purpose:   Draws a MemBlt order into _UH.hdcDraw                          */
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHDrawMemBltOrder(HDC hdc, MEMBLT_COMMON FAR *pMB)
{
    HRESULT hr = S_OK;
    unsigned colorTableCacheEntry;
    unsigned bitmapCacheId;
    UINT     cbBitmapBits;
    PUHBITMAPCACHEENTRYHDR pCacheEntryHdr;
    PDCUINT8 pBitmapBits;
    UINT32 windowsROP = UHConvertToWindowsROP((unsigned)pMB->bRop);
#ifdef OS_WINCE
    DCUINT   row;
    PDCUINT8 pSrc;
    PDCUINT8 pDst;
    HBITMAP  hbmOld;
    HPALETTE hpalOld;
#endif

    DC_BEGIN_FN("UHDrawMemBltOrder");

    bitmapCacheId = DCLO8(pMB->cacheId);
    /************************************************************************/
    /* get the actual bits to draw                                          */
    /************************************************************************/
    // SECURITY - the cacheId and cacheIndex will be verified by UHGetMemBltBits
    pBitmapBits = UHGetMemBltBits(hdc, pMB->cacheId, pMB->cacheIndex,
            &colorTableCacheEntry, &pCacheEntryHdr);
    
    if (pBitmapBits != NULL)
    {
        TRC_NRM((TB,
            _T("dstLeft(%d) dstTop(%d) srcLeft(%d) srcTop(%d) ")
            _T("bltWidth(%d) bltHeight(%d), rop(%#x/%#x)"),
            (int)pMB->nLeftRect,
            (int)pMB->nTopRect,
            (int)pMB->nXSrc,
            (int)pCacheEntryHdr->bitmapHeight - (int)pMB->nYSrc - (int)pMB->nHeight,
            (int)pMB->nWidth, (int)pMB->nHeight,
            pMB->bRop, windowsROP));

#ifdef DC_HICOLOR
        cbBitmapBits = pCacheEntryHdr->bitmapWidth *
            pCacheEntryHdr->bitmapHeight * _UH.copyMultiplier;
#else
        cbBitmapBits = pCacheEntryHdr->bitmapWidth * pCacheEntryHdr->bitmapHeight;
#endif // DC_HICOLOR

        // Draw!
        TIMERSTART;

#ifdef USE_DIBSECTION
        // We can only use UHDIBCopyBits if this is a simple copy and the shadow
        // bitmap is enabled.
        if ((_UH.usingDIBSection) && (windowsROP == SRCCOPY) &&
#ifdef USE_GDIPLUS
                          (_UH.shadowBitmapBpp == _UH.protocolBpp) &&
#endif // USE_GDIPLUS
                                                 (hdc == _UH.hdcShadowBitmap))
        {
            TRC_DBG((TB, _T("Using UH DI blt...")));
            if (!UHDIBCopyBits(hdc, (int)pMB->nLeftRect, (int)pMB->nTopRect,
                    (int)pMB->nWidth, (int)pMB->nHeight, (int)pMB->nXSrc,
                    (int)pCacheEntryHdr->bitmapHeight - (int)pMB->nYSrc - (int)pMB->nHeight,
                    pBitmapBits, cbBitmapBits,
                    (PBITMAPINFO)&(_UH.pMappedColorTableCache[colorTableCacheEntry].hdr),
                    _UH.pMappedColorTableCache[colorTableCacheEntry].
                    bIdentityPalette))
            {
                TRC_ERR((TB, _T("UHDIBCopyBits failed")));
            }
        }
        else
#endif /* USE_DIBSECTION */

#ifndef OS_WINCE
        {
#ifdef DC_HICOLOR
            TRC_DBG((TB, _T("Stretch blt size %d x %d"), pMB->nWidth, pMB->nHeight));
            if (StretchDIBits(
                    hdc,
                    (int)pMB->nLeftRect,
                    (int)pMB->nTopRect,
                    (int)pMB->nWidth,
                    (int)pMB->nHeight,
                    (int)pMB->nXSrc,
                    (int)pCacheEntryHdr->bitmapHeight - (int)pMB->nYSrc - (int)pMB->nHeight,
                    (int)pMB->nWidth,
                    (int)pMB->nHeight,
                    pBitmapBits,
                    (PBITMAPINFO)&(_UH.pMappedColorTableCache[colorTableCacheEntry].hdr),
                    _UH.DIBFormat,
                    windowsROP) == 0)
#else
            if (StretchDIBits(hdc,
                    (int)pMB->nLeftRect,
                    (int)pMB->nTopRect,
                    (int)pMB->nWidth,
                    (int)pMB->nHeight,
                    (int)pMB->nXSrc,
                    (int)pCacheEntryHdr->bitmapHeight - (int)pMB->nYSrc - (int)pMB->nHeight,
                    (int)pMB->nWidth,
                    (int)pMB->nHeight,
                    pBitmapBits,
                    (PBITMAPINFO)&(_UH.pMappedColorTableCache[
                        colorTableCacheEntry].hdr),
                    DIB_PAL_COLORS,
                    windowsROP) == 0)
#endif
            {
                TRC_ERR((TB, _T("StretchDIBits failed")));
            }
        }

#else // OS_WINCE
        {
            // Workaround for missing StretchDIBits in WinCE. Copy bits into a
            // cached DIB Section and Blt to the target.
#ifdef DC_HICOLOR
            if (_UH.protocolBpp <= 8)
            {
#endif
            hpalOld = SelectPalette(_UH.hdcMemCached, _UH.hpalCurrent, FALSE);
#ifdef DC_HICOLOR
            }
#endif

            // Copy into the cached DIB Section.
            pSrc = pBitmapBits;
            pDst = _UH.hBitmapCacheDIBits;

            TRC_DBG((TB, _T("cache size (%d %d)"), pCacheEntryHdr->bitmapWidth,
                                               pCacheEntryHdr->bitmapHeight));

            if (pCacheEntryHdr->bitmapWidth >
                    (UH_CACHE_0_DIMENSION << (_UH.NumBitmapCaches - 1))) {
                    TRC_ABORT((TB, _T("Cache tile is too big")));
                    hr = E_TSC_CORE_LENGTH;
                    DC_QUIT;
            }

            if (pCacheEntryHdr->bitmapHeight >
                    (UH_CACHE_0_DIMENSION << (_UH.NumBitmapCaches - 1))) {
                    TRC_ABORT((TB, _T("Cache tile is too big")));
                    hr = E_TSC_CORE_LENGTH;
                    DC_QUIT;
            }

#ifdef DC_HICOLOR
            DWORD dwDstInc = (UH_CACHE_0_DIMENSION << (_UH.NumBitmapCaches - 1)) * _UH.copyMultiplier;
            DWORD dwSrcInc = pCacheEntryHdr->bitmapWidth * _UH.copyMultiplier;
            DWORD dwLineWidth = pCacheEntryHdr->bitmapWidth * _UH.copyMultiplier;

            for (row = 0; row < pCacheEntryHdr->bitmapHeight; row++) {
                DC_MEMCPY(pDst, pSrc, dwLineWidth);
                pDst += dwDstInc;
                pSrc += dwSrcInc;
            }
#else
            for (row = 0; row < pCacheEntryHdr->bitmapHeight; row++) {
                DC_MEMCPY(pDst, pSrc, pCacheEntryHdr->bitmapWidth);
                pDst += (UH_CACHE_0_DIMENSION << (_UH.NumBitmapCaches - 1));
                pSrc += pCacheEntryHdr->bitmapWidth;
            }
#endif
            // Copy to the screen / shadow.
            hbmOld = (HBITMAP)SelectObject(_UH.hdcMemCached, _UH.hBitmapCacheDIB);
            if (!BitBlt(hdc, (int)pMB->nLeftRect, (int)pMB->nTopRect,
                    (int)pMB->nWidth, (int)pMB->nHeight, _UH.hdcMemCached,
                    (int)pMB->nXSrc,
                    (UH_CACHE_0_DIMENSION << (_UH.NumBitmapCaches - 1)) -
                        pCacheEntryHdr->bitmapHeight + (int)pMB->nYSrc,
                        windowsROP))
            {
                TRC_ERR((TB, _T("BitBlt failed")));
            }

            SelectBitmap(_UH.hdcMemCached, hbmOld);
#ifdef DC_HICOLOR
            if (_UH.protocolBpp <= 8)
            {
#endif
            hpalOld = SelectPalette(_UH.hdcMemCached, hpalOld, FALSE);

#ifdef DC_HICOLOR
            }
#endif
        }
#endif // OS_WINCE

        TIMERSTOP;
        UPDATECOUNTER(FC_MEMBLT_TYPE);

#ifdef VLADIMIS           // future CLX extension
        _pClx->CLX_ClxBitmap((UINT)pCacheEntryHdr->bitmapWidth,
                      (UINT)pCacheEntryHdr->bitmapHeight,
                      pBitmapBits,
                      (UINT)sizeof(_UH.pMappedColorTableCache[colorTableCacheEntry]),
                      &_UH.pMappedColorTableCache[colorTableCacheEntry].hdr);
#endif

    }
    else if (bitmapCacheId > _UH.NumBitmapCaches){

        hr = UHDrawOffscrBitmapBits(hdc, pMB);
        DC_QUIT_ON_FAIL(hr);
    }

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


#ifdef USE_DIBSECTION

/****************************************************************************/
// UHDIBCopyBits
//
// Fast Blt from bitmap cache to DIB section shadow bitmap. Work-around for
// the fact that StretchDIBits is over 6x slower when drawing to a DIB than
// when drawing to a normal bitmap. This routine runs between 5x and 25x
// faster, but is limited in that it assumes a bottom-up source (bitmap cache)
// and a top-down dest (shadow bitmap), both 8bpp. Returns nonzero on success.
/****************************************************************************/
BOOL DCINTERNAL CUH::UHDIBCopyBits(
        HDC hdc,
        int xDst,
        int yDst,
        int bltWidth,
        int bltHeight,
        int xSrc,
        int ySrc,
        PBYTE pSrcBits,
        UINT cbSrcBits, // This length may be longer than what needs to be read
        PBITMAPINFO pSrcInfo,
        BOOL bIdentityPalette)
{
    BOOL rc = FALSE;
    HBITMAP dstBitmap;
    DIBSECTION dibSection;
    PBYTE pDstBits;
    PBYTE pDstBitsEnd;
    PBYTE pSrcBitsEnd;
    PBYTE pSrcRow;
    PBYTE pDstRow;
    PBYTE pSrcPel;
    PBYTE pDstPel;
    int rowsCopied;
    UINT uiBMPSize;
    BYTE *endRow;
    UINT16 FAR *colorTable = (UINT16 FAR *)pSrcInfo->bmiColors;
    int xOffset;
    int yOffset;
#ifdef DC_HICOLOR
    unsigned srcIncrement;
    unsigned dstIncrement;
#endif

    DC_BEGIN_FN("UHDIBCopyBits");

    TRC_ASSERT( ((xDst >= 0) && (yDst >= 0)),
        (TB,_T("Invalid offset [xDst=%d yDst=%d]"), xDst, yDst ));

    dstBitmap = (HBITMAP)GetCurrentObject(hdc, OBJ_BITMAP);
    if (dstBitmap != NULL) {
        if (sizeof(dibSection) !=
                GetObject(dstBitmap, sizeof(dibSection), &dibSection)) {
            TRC_ERR((TB, _T("GetObject failed")));
            DC_QUIT;
        }
    }
    else {
        TRC_ERR((TB, _T("Failed GetCurrentObject")));
        DC_QUIT;
    }

    TRC_DBG((TB, _T("Blt: src(%d,%d), dest(%d,%d), size %dx%d"),
                 xSrc, ySrc, xDst, yDst, bltWidth, bltHeight));

#ifdef DC_DEBUG
    if (_UH.protocolBpp > 8) {
        TRC_ASSERT((bIdentityPalette),(TB,_T("Non-palette depth but identity FALSE")));
    }
    else {
        BOOL bIdent = TRUE;
        unsigned i;

        // Make sure the passed-in identity flag matches reality.
        for (i = 0; i < UH_NUM_8BPP_PAL_ENTRIES; i++) {
            if ((BYTE)colorTable[i] != (BYTE)i) {
                bIdent = FALSE;
                break;
            }
        }

        TRC_ASSERT((bIdent && bIdentityPalette) || (!bIdent && !bIdentityPalette),
                (TB,_T("Cached ident flag %u does not match real data"),
                bIdentityPalette));
    }
#endif  // DC_DEBUG

    TRC_DBG((TB, _T("%s color map"), bIdentityPalette ? _T("identity") : _T("complex")));

    if (_UH.rectReset) {
        TRC_DBG((TB, _T("No clipping in force")));
    }
    else {
        TRC_NRM((TB, _T("Clip rect in force (%d,%d)-(%d,%d)"),
                _UH.lastLeft, _UH.lastTop, _UH.lastRight, _UH.lastBottom));

        // x clip calculations.
        xOffset = _UH.lastLeft - xDst;
        if (xOffset > 0) {
            xDst = _UH.lastLeft;
            xSrc += xOffset;
            bltWidth -= xOffset;
        }
        bltWidth = DC_MIN(bltWidth, _UH.lastRight - xDst + 1);

        // y clip calculations (remember source is bottom-up!).
        yOffset = _UH.lastTop - yDst;
        if (yOffset > 0) {
            yDst = _UH.lastTop;
            bltHeight -= yOffset;
        }
        yOffset = (yDst + bltHeight - 1) - _UH.lastBottom;
        if (yOffset > 0) {
            ySrc += yOffset;
            bltHeight -= yOffset;
        }

        TRC_DBG((TB, _T("Post-clip: src(%d,%d), dest(%d,%d), %dx%d"),
                xSrc, ySrc, xDst, yDst, bltWidth, bltHeight));
    }

    pDstBits = (PBYTE)dibSection.dsBm.bmBits;
    pDstBitsEnd = pDstBits + 
        (dibSection.dsBm.bmHeight * dibSection.dsBm.bmWidthBytes);

    // Check that we do not over read the bitmap data
    uiBMPSize = BMP_SIZE(pSrcInfo->bmiHeader);
    if (uiBMPSize > cbSrcBits) {
        TRC_ERR((TB,_T("Copying bitmap bits would overread")));
        DC_QUIT;
    }

    pSrcBitsEnd = pSrcBits + uiBMPSize;

#ifndef DC_HICOLOR
    // Get starting points for copy.
    pSrcRow = pSrcBits + ((ySrc + bltHeight - 1) *
            pSrcInfo->bmiHeader.biWidth) + xSrc;
    pDstRow = pDstBits + (yDst * dibSection.dsBm.bmWidth) + xDst;
#endif

    if (bIdentityPalette || _UH.protocolBpp > 8) {
        // Fast path - just copy row-by-row.

#ifdef DC_HICOLOR
        // We duplicate the start points calculation below to avoid any
        // overhead from a multiplication by 1.
        pSrcRow = pSrcBits +
                (((ySrc + bltHeight - 1) * pSrcInfo->bmiHeader.biWidth) + xSrc) *
                _UH.copyMultiplier;

        pDstRow = pDstBits +
               ((yDst * dibSection.dsBm.bmWidth) + xDst) * _UH.copyMultiplier;

        srcIncrement = pSrcInfo->bmiHeader.biWidth * _UH.copyMultiplier;
        dstIncrement = dibSection.dsBm.bmWidth     * _UH.copyMultiplier;

        if (bltHeight) {
            CHECK_READ_N_BYTES_2ENDED_NO_HR(pSrcRow-((bltHeight-1)*srcIncrement),
                pSrcBits, pSrcBitsEnd, 
                ((bltHeight-1)*srcIncrement) + (bltWidth * _UH.copyMultiplier),
                (TB, _T("Blt will buffer overread")));
            
            CHECK_WRITE_N_BYTES_2ENDED_NO_HR(pDstRow, pDstBits, pDstBitsEnd, 
                ((bltHeight-1)*dstIncrement) + (bltWidth * _UH.copyMultiplier), 
                (TB,_T("Blt will BO")));
        }
        
        for (rowsCopied = 0; rowsCopied < bltHeight; rowsCopied++) {
            memcpy(pDstRow, pSrcRow, bltWidth * _UH.copyMultiplier);
            pSrcRow -= srcIncrement;
            pDstRow += dstIncrement;
        }
#else
        if (bltHeight) {
            CHECK_READ_N_BYTES_2ENDED_NO_HR(
                pSrcRow-((bltHeight-1)*pSrcInfo->bmiHeader.biWidth),
                pSrcBits, pSrcBitsEnd, 
                ((bltHeight-1)*pSrcInfo->bmiHeader.biWidth) + bltWidth,
                (TB, _T("Blt will buffer overread")));
            
            CHECK_WRITE_N_BYTES_2ENDED_NO_HR(pDstRow, pDstBits, pDstBitsEnd, 
                ((bltHeight-1)*dibSection.dsBm.bmWidth) + bltWidth, 
                (TB,_T("Blt will BO")));
        }
        
        for (rowsCopied = 0; rowsCopied < bltHeight; rowsCopied++) {
            memcpy(pDstRow, pSrcRow, bltWidth);
            pSrcRow -= pSrcInfo->bmiHeader.biWidth;
            pDstRow += dibSection.dsBm.bmWidth;
        }
#endif
    }
    else {
        // Copy pixel-by-pixel, doing color table mapping as we go.
#ifdef DC_HICOLOR
        // This code duplicates that above except for the copy multiplier,
        // which we know *must* be one for this (8bpp) arm.
        TRC_ASSERT((_UH.copyMultiplier == 1),
                (TB, _T("Copy multiplier %d must be 1"), _UH.copyMultiplier));
        pSrcRow = pSrcBits + ((ySrc + bltHeight - 1) *
                pSrcInfo->bmiHeader.biWidth) + xSrc;
        pDstRow = pDstBits + (yDst * dibSection.dsBm.bmWidth) + xDst;
#endif

        if (bltHeight) {
            CHECK_READ_N_BYTES_2ENDED_NO_HR(
                pSrcRow-((bltHeight-1)*pSrcInfo->bmiHeader.biWidth),
                pSrcBits, pSrcBitsEnd, 
                ((bltHeight-1)*pSrcInfo->bmiHeader.biWidth) + bltWidth,
                (TB, _T("Blt will buffer overread")));

            CHECK_WRITE_N_BYTES_2ENDED_NO_HR(pDstRow, pDstBits, pDstBitsEnd, 
                ((bltHeight-1) * dibSection.dsBm.bmWidth) + bltWidth,
                (TB,_T("Blt will BO")));
        }
        
        for (rowsCopied = 0; rowsCopied < bltHeight; rowsCopied++) {
            for (pDstPel = pDstRow,
                    pSrcPel = pSrcRow,
                    endRow = pDstRow + bltWidth;
                    pDstPel < endRow;
                    pDstPel++, pSrcPel++)
            {
                *pDstPel = (BYTE)colorTable[*pSrcPel];
            }

            pSrcRow -= pSrcInfo->bmiHeader.biWidth;
            pDstRow += dibSection.dsBm.bmWidth;
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}

#endif /* USE_DIBSECTION */


#ifdef DC_DEBUG
/****************************************************************************/
/* Name:      UHLabelMemBltOrder                                            */
/*                                                                          */
/* Purpose:   Labels a MemBlt order by drawing text into _UH.hdcDraw         */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    dstLeft     : destination left coordinate                     */
/*            dstTop      : destination top coordinate                      */
/*            cacheId     : the color table and bitmap cache ids to use     */
/*            bitmapCacheEntry: the bitmap cache entry to use               */
/****************************************************************************/
void DCINTERNAL CUH::UHLabelMemBltOrder(
        int dstLeft,
        int dstTop,
        unsigned cacheId,
        unsigned bitmapCacheEntry)
{
    unsigned bitmapCacheId;
    TCHAR outputString[20];
    int             oldBkMode;
    HFONT           hFont;
    HFONT           hFontOld;
    COLORREF        oldBkColor;
    COLORREF        oldTextColor;
    LOGFONT         lf;
    HRESULT         hr;
#ifndef OS_WINCE
    UINT            oldAlign;
#endif

    DC_BEGIN_FN("UHLabelMemBltOrder");

    bitmapCacheId = DCLO8(cacheId);

    if (_UH.MonitorEntries[0] != NULL) {
        hr = StringCchPrintf(
            outputString,
            SIZE_TCHARS(outputString),
            _T("%u:%u(%u) "),
            bitmapCacheId, bitmapCacheEntry,
            _UH.MonitorEntries[bitmapCacheId][bitmapCacheEntry].UsageCount);
    }
    else {
        hr = StringCchPrintf(outputString, SIZE_TCHARS(outputString),
                         _T("%u:%u "), bitmapCacheId, bitmapCacheEntry);
    }
    //Fixed buffer so the sprintf should not fail
    TRC_ASSERT(SUCCEEDED(hr),
               (TB,_T("Error copying printf'ing outputString: 0x%x"), hr));



    lf.lfHeight         = 8;
    lf.lfWidth          = 0;
    lf.lfEscapement     = 0;
    lf.lfOrientation    = 0;
    lf.lfWeight         = FW_NORMAL;
    lf.lfItalic         = 0;
    lf.lfUnderline      = 0;
    lf.lfStrikeOut      = 0;
    lf.lfCharSet        = 0;
    lf.lfOutPrecision   = 0;
    lf.lfClipPrecision  = 0;
    lf.lfQuality        = 0;
    lf.lfPitchAndFamily = 0;
    StringCchCopy(lf.lfFaceName, SIZE_TCHARS(lf.lfFaceName),
                  _T("Small Fonts"));

    hFont = CreateFontIndirect(&lf);
    hFontOld = SelectFont(_UH.hdcDraw, hFont);

    oldBkColor = SetBkColor(_UH.hdcDraw, RGB(255,0,0));
    oldTextColor = SetTextColor(_UH.hdcDraw, RGB(255,255,255));

#ifndef OS_WINCE
    // WinCE doesn't support this call, but these would be the defaults anyway.
    oldAlign = SetTextAlign(_UH.hdcDraw, TA_TOP | TA_LEFT);
#endif
    oldBkMode = SetBkMode(_UH.hdcDraw, OPAQUE);

    ExtTextOut( _UH.hdcDraw,
                dstLeft,
                dstTop,
                0,
                NULL,
                outputString,
                DC_TSTRLEN(outputString),
                NULL );

#ifndef OS_WINCE
    SetTextAlign(_UH.hdcDraw, oldAlign);
#endif // OS_WINCE
    SetBkMode(_UH.hdcDraw, oldBkMode);

    SetTextColor(_UH.hdcDraw, oldTextColor);
    SetBkColor(_UH.hdcDraw, oldBkColor);

    SelectFont(_UH.hdcDraw, hFontOld);
    DeleteFont(hFont);

DC_EXIT_POINT:
    DC_END_FN();
}


/****************************************************************************/
/* Name:      UHInitBitmapCacheMonitor                                      */
/*                                                                          */
/* Purpose:   Initializes the Bitmap Cache Monitor.                         */
/****************************************************************************/
void DCINTERNAL CUH::UHInitBitmapCacheMonitor()
{
    WNDCLASS wndclass;
    WNDCLASS tmpWndClass;

    DC_BEGIN_FN("UHInitBitmapCacheMonitor");

    // Create the bitmap monitor window.

#if !defined(OS_WINCE) || defined(OS_WINCEOWNEDDC)
    wndclass.style         = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
#else // !defined(OS_WINCE) || defined(OS_WINCEOWNEDDC)
    wndclass.style         = CS_HREDRAW | CS_VREDRAW;
#endif // !defined(OS_WINCE) || defined(OS_WINCEOWNEDDC)

    if(!GetClassInfo(_pUi->UI_GetInstanceHandle(),UH_BITMAP_CACHE_MONITOR_CLASS_NAME, &tmpWndClass))
    {
        wndclass.lpfnWndProc   = UHStaticBitmapCacheWndProc;
        wndclass.cbClsExtra    = 0;
        wndclass.cbWndExtra    = sizeof(void*);
        wndclass.hInstance     = _pUi->UI_GetInstanceHandle();
        wndclass.hIcon         = NULL;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
        wndclass.lpszMenuName  = NULL;
        wndclass.lpszClassName = UH_BITMAP_CACHE_MONITOR_CLASS_NAME;

        RegisterClass(&wndclass);
    }

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

#ifndef WS_THICKFRAME
#define WS_THICKFRAME       0x00040000L
#endif

    _UH.hwndBitmapCacheMonitor = CreateWindow(
            UH_BITMAP_CACHE_MONITOR_CLASS_NAME, _T("Bitmap cache monitor"),
            WS_OVERLAPPED | WS_THICKFRAME, 0, 0, 400, 600, NULL, NULL,
            _pUi->UI_GetInstanceHandle(), this);
#else  // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

    _UH.hwndBitmapCacheMonitor = CreateWindow(
            UH_BITMAP_CACHE_MONITOR_CLASS_NAME, _T("Bitmap cache monitor"),
            WS_OVERLAPPED | WS_BORDER, 0, 0, 400, 500, NULL, NULL,
            _pUi->UI_GetInstanceHandle(), this);

#endif  // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

    DC_END_FN();
}

/****************************************************************************/
/* Name:      UHTermBitmapCacheMonitor                                      */
/*                                                                          */
/* Purpose:   Terminates the Bitmap Cache Monitor.                          */
/****************************************************************************/
void DCINTERNAL CUH::UHTermBitmapCacheMonitor()
{
    DC_BEGIN_FN("UHTermBitmapCacheMonitor");

    /************************************************************************/
    /* Destroy the Bitmap Cache Monitor window and unregister its class     */
    /************************************************************************/
    DestroyWindow(_UH.hwndBitmapCacheMonitor);
    UnregisterClass(UH_BITMAP_CACHE_MONITOR_CLASS_NAME,
                    _pUi->UI_GetInstanceHandle());

    DC_END_FN();
}


/****************************************************************************/
// UHEnableBitmapCacheMonitor
//
// Initializes the bitmap cache monitor with the current session's
// negotiated bitmap cache settings.
/****************************************************************************/
void DCINTERNAL CUH::UHEnableBitmapCacheMonitor(void)
{
    unsigned i;
    ULONG NumEntries;

    DC_BEGIN_FN("UHEnableBitmapCacheMonitor");

    TRC_ASSERT((_UH.MonitorEntries[0] == NULL),(TB,_T("BCMonitor already has ")
            _T("allocated memory")));

    // Total the number of entries we have, allocate memory for corresponding
    // monitor entries.
    NumEntries = 0;
    for (i = 0; i < _UH.NumBitmapCaches; i++) {
        if (_UH.bitmapCache[i].BCInfo.bSendBitmapKeys)
            NumEntries += _UH.bitmapCache[i].BCInfo.NumVirtualEntries;
        else
            NumEntries += _UH.bitmapCache[i].BCInfo.NumEntries;

    }
    _UH.MonitorEntries[0] = (UH_CACHE_MONITOR_ENTRY_DATA*)UT_MallocHuge(_pUt, NumEntries *
            sizeof(UH_CACHE_MONITOR_ENTRY_DATA));
    if (_UH.MonitorEntries[0] != NULL) {
        // Init the per-cache entry pointers.
        for (i = 1; i < _UH.NumBitmapCaches; i++) {
            if (_UH.bitmapCache[i - 1].BCInfo.bSendBitmapKeys)
                _UH.MonitorEntries[i] = _UH.MonitorEntries[i - 1] +
                        _UH.bitmapCache[i - 1].BCInfo.NumVirtualEntries;
            else
                _UH.MonitorEntries[i] = _UH.MonitorEntries[i - 1] +
                        _UH.bitmapCache[i - 1].BCInfo.NumEntries;
        }
        // Init all the entries to an unused state.
        memset(_UH.MonitorEntries[0], 0, NumEntries *
                sizeof(UH_CACHE_MONITOR_ENTRY_DATA));

        _UH.displayedCacheId = 0;
        _UH.displayedCacheEntry = 0;

        // Recalc the cell display characteristics based on the now-negotiated
        // capabilities.
        SendMessage(_UH.hwndBitmapCacheMonitor, WM_RECALC_CELL_SPACING, 0, 0);

        /********************************************************************/
        // Force the window to repaint with the new values.
        /********************************************************************/
        InvalidateRect(_UH.hwndBitmapCacheMonitor, NULL, FALSE);
    }
    else {
        TRC_ERR((TB,_T("Failed to alloc bitmap monitor memory")));
    }

    DC_END_FN();
}


/****************************************************************************/
// UHDisconnectBitmapCacheMonitor
//
// Closes down the cache monitor and deallocates memory at end of session.
/****************************************************************************/
void DCINTERNAL CUH::UHDisconnectBitmapCacheMonitor(void)
{
    DC_BEGIN_FN("UHDisconnectBitmapCacheMonitor");

    TRC_ASSERT((_UH.NumBitmapCaches == 0),(TB,_T("Cache settings not reset yet")));

    // Free the cache memory and reset the pointers.
    if (_UH.MonitorEntries[0] != NULL) {
        UT_Free( _pUt, _UH.MonitorEntries[0]);
        memset(_UH.MonitorEntries, 0, sizeof(UH_CACHE_MONITOR_ENTRY_DATA *) *
                TS_BITMAPCACHE_MAX_CELL_CACHES);
    }
    // Recalc the cell display characteristics based on the reset
    // capabilities.
    SendMessage(_UH.hwndBitmapCacheMonitor, WM_RECALC_CELL_SPACING, 0, 0);

    /************************************************************************/
    /* Force the window to repaint with the new values.                     */
    /************************************************************************/
    InvalidateRect(_UH.hwndBitmapCacheMonitor, NULL, FALSE);

    DC_END_FN();
}

/****************************************************************************/
/* Name:      UHStaticBitmapCacheWndProc                                    */
/*                                                                          */
/* Purpose:   Bitmap Cache Window WndProc (static version)                  */
/****************************************************************************/

LRESULT CALLBACK CUH::UHStaticBitmapCacheWndProc( HWND hwnd,
                                           UINT message,
                                           WPARAM wParam,
                                           LPARAM lParam )
{
    CUH* pUH = (CUH*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(WM_CREATE == message)
    {
        //pull out the this pointer and stuff it in the window class
        LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
        pUH = (CUH*)lpcs->lpCreateParams;

        SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)pUH);
    }

    //
    // Delegate the message to the appropriate instance
    //

    return pUH->UHBitmapCacheWndProc(hwnd, message, wParam, lParam);
}


/****************************************************************************/
/* Name:      UHBitmapCacheWndProc                                          */
/*                                                                          */
/* Purpose:   Bitmap Cache Window WndProc                                   */
/****************************************************************************/
LRESULT CALLBACK CUH::UHBitmapCacheWndProc( HWND hwnd,
                                       UINT message,
                                       WPARAM wParam,
                                       LPARAM lParam )
{
    LRESULT rc = 0;

    DC_BEGIN_FN("UHBitmapCacheWndProc");

    switch (message)
    {
        case WM_SHOWWINDOW:
        {
            DCBOOL  shown;

            shown = (DCBOOL)wParam;

            /****************************************************************/
            /* Only run the timer when the window is visible.               */
            /****************************************************************/
            if (shown)
            {
                _UH.timerBitmapCacheMonitor =
                      SetTimer(hwnd, 0, UH_CACHE_MONITOR_UPDATE_PERIOD, NULL);
                TRC_NRM((TB, _T("Timer started")));
            }
            else
            {
                KillTimer(hwnd, _UH.timerBitmapCacheMonitor);
                _UH.timerBitmapCacheMonitor = 0;
                TRC_NRM((TB, _T("Timer stopped")));
            }
        }
        break;

        case WM_TIMER:
        {
            UINT32   timeNow;
            ULONG    Entry, NumEntries;
            unsigned cacheId;
            RECT     rect;

            if (_UH.MonitorEntries[0] != NULL) {
                timeNow = GetTickCount();

                /****************************************************************/
                /* Update the timers for every cache entry, and if necessary    */
                /* invalidate the corresponding cache blob to force a repaint   */
                /* in the new state.                                            */
                /****************************************************************/
                for (cacheId = 0; cacheId < _UH.NumBitmapCaches; cacheId++) {
                    if (!_UH.bitmapCache[cacheId].BCInfo.bSendBitmapKeys)
                        NumEntries = _UH.bitmapCache[cacheId].BCInfo.NumEntries;
                    else
                        NumEntries = _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries;

                    for (Entry = 0; Entry < NumEntries; Entry++) {
                        if (_UH.MonitorEntries[cacheId][Entry].EventTime != 0 &&
                                (timeNow - _UH.MonitorEntries[cacheId][Entry].
                                EventTime) > UH_CACHE_FLASH_PERIOD) {
                            // Reset the transition and timer.
                            _UH.MonitorEntries[cacheId][Entry].EventTime = 0;
                            _UH.MonitorEntries[cacheId][Entry].FlashTransition =
                                    UH_CACHE_TRANSITION_NONE;
                            UHGetCacheBlobRect(cacheId, Entry, &rect);
                            InvalidateRect(_UH.hwndBitmapCacheMonitor, &rect,
                                    FALSE);
                        }
                    }
                }
            }
        }
        break;

        case WM_LBUTTONDOWN:
        {
            POINT mousePos;
            ULONG cacheEntry;
            unsigned cacheId;

            mousePos.x = LOWORD(lParam);
            mousePos.y = HIWORD(lParam);

            /****************************************************************/
            /* The left button has been clicked.  Update the displayed      */
            /* bitmap if the current position maps to a different cache     */
            /* entry.                                                       */
            /****************************************************************/
            if (UHGetCacheBlobFromPoint( &mousePos,
                                         &cacheId,
                                         &cacheEntry ))
            {
                if ( (cacheId != _UH.displayedCacheId) ||
                     (cacheEntry != _UH.displayedCacheEntry) )
                {
                    _UH.displayedCacheId = cacheId;
                    _UH.displayedCacheEntry = cacheEntry;
                    UHRefreshDisplayedCacheEntry();
                }
            }
        }
        break;

        case WM_MOUSEMOVE:
        {
            POINT mousePos;
            ULONG cacheEntry;
            unsigned cacheId;

            mousePos.x = LOWORD(lParam);
            mousePos.y = HIWORD(lParam);

            /****************************************************************/
            /* If the left button is pressed then update the displayed      */
            /* bitmap if the current position maps to a different cache     */
            /* entry.                                                       */
            /****************************************************************/
            if (wParam & MK_LBUTTON)
            {
                if (UHGetCacheBlobFromPoint(&mousePos, &cacheId, &cacheEntry))
                {
                    if ( (cacheId != _UH.displayedCacheId) ||
                         (cacheEntry != _UH.displayedCacheEntry) )
                    {
                        _UH.displayedCacheId = cacheId;
                        _UH.displayedCacheEntry = cacheEntry;
                        UHRefreshDisplayedCacheEntry();
                    }
                }
            }
        }
        break;

        case WM_SIZE:
        {
            DCUINT  clientWidth;
            DCUINT  outputAreaWidth;

            /****************************************************************/
            /* The window has been sized.  Calculate the positions to       */
            /* draw each cache and the displayed bitmap.                    */
            /****************************************************************/
            clientWidth = LOWORD(lParam);

            outputAreaWidth =
                             clientWidth - (2 * UH_CACHE_WINDOW_BORDER_WIDTH);

            _UH.numCacheBlobsPerRow = outputAreaWidth /
                                                    UH_CACHE_BLOB_TOTAL_WIDTH;

            SendMessage(hwnd, WM_RECALC_CELL_SPACING, 0, 0);
        }
        break;

        case WM_RECALC_CELL_SPACING:
        {
            unsigned i;
            ULONG NumEntries;

            _UH.yCacheStart[0] = UH_CACHE_WINDOW_BORDER_WIDTH;
            if (_UH.numCacheBlobsPerRow > 0) {
                for (i = 1; i < _UH.NumBitmapCaches; i++) {
                    if (!_UH.bitmapCache[i - 1].BCInfo.bSendBitmapKeys)
                        NumEntries = _UH.bitmapCache[i - 1].BCInfo.NumEntries;
                    else
                        NumEntries = _UH.bitmapCache[i - 1].BCInfo.NumVirtualEntries;

                    _UH.yCacheStart[i] = _UH.yCacheStart[i - 1] + (unsigned)
                            (((NumEntries / _UH.numCacheBlobsPerRow) + 1) *
                            UH_CACHE_BLOB_TOTAL_HEIGHT) +
                            UH_INTER_CACHE_SPACING;
                }

                if (_UH.NumBitmapCaches)
                {
                    if (!_UH.bitmapCache[_UH.NumBitmapCaches - 1].BCInfo.bSendBitmapKeys)
                        NumEntries = _UH.bitmapCache[_UH.NumBitmapCaches - 1].BCInfo.NumEntries;
                    else
                        NumEntries = _UH.bitmapCache[_UH.NumBitmapCaches - 1].BCInfo.NumVirtualEntries;

                    _UH.yDisplayedCacheBitmapStart = _UH.yCacheStart[
                            _UH.NumBitmapCaches - 1] + (unsigned)
                            (((NumEntries / _UH.numCacheBlobsPerRow) + 1) *
                            UH_CACHE_BLOB_TOTAL_HEIGHT) + UH_INTER_CACHE_SPACING;
                }
                else
                {
                    NumEntries = 0;
                }                          
            }
        }
        break;

        case WM_PAINT:
        {
            HDC         hdc;
            PAINTSTRUCT ps;
            RECT        clientRect;
            RECT        rect;
            HBRUSH      StateBrush[UH_CACHE_NUM_STATES];
            HBRUSH      TransitionBrush[UH_CACHE_NUM_TRANSITIONS];
            HBRUSH      hbrToUse;
            HBRUSH      hbrGray;
            ULONG       i, NumEntries;
            DCINT       outputAreaWidth;
            DCUINT      numBlobsPerRow;
            DCUINT      cacheId;
            HPALETTE    hpalOld;

            hdc = BeginPaint(hwnd, &ps);
            if (hdc == NULL)
            {
                TRC_SYSTEM_ERROR("BeginPaint failed");
                break;
            }

#ifdef DC_HICOLOR
            if (_UH.protocolBpp <= 8)
            {
#endif
                /****************************************************************/
                /* Use the current palette, so that the colors are drawn        */
                /* correctly by UHDisplayCacheEntry.                            */
                /****************************************************************/
                hpalOld = SelectPalette(hdc, _UH.hpalCurrent, FALSE);
                RealizePalette(hdc);
#ifdef DC_HICOLOR
            }
#endif
            /****************************************************************/
            // Create a bunch of useful brushes.
            /****************************************************************/
            hbrGray = (HBRUSH)GetStockObject(GRAY_BRUSH);

            StateBrush[UH_CACHE_STATE_UNUSED] = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
#ifndef OS_WINCE
            StateBrush[UH_CACHE_STATE_IN_MEMORY] =
                    CreateSolidBrush(UH_RGB_GREEN);
            StateBrush[UH_CACHE_STATE_ON_DISK] =
                    CreateSolidBrush(UH_RGB_BLUE);

            TransitionBrush[UH_CACHE_TRANSITION_NONE] = NULL;
            TransitionBrush[UH_CACHE_TRANSITION_TOUCHED] =
                    (HBRUSH)CreateSolidBrush(UH_RGB_YELLOW);
            TransitionBrush[UH_CACHE_TRANSITION_EVICTED] =
                    (HBRUSH)GetStockObject(BLACK_BRUSH);
            TransitionBrush[UH_CACHE_TRANSITION_LOADED_FROM_DISK] =
                    (HBRUSH)GetStockObject(WHITE_BRUSH);
            TransitionBrush[UH_CACHE_TRANSITION_KEY_LOAD_ON_SESSION_START] =
                    (HBRUSH)CreateSolidBrush(UH_RGB_MAGENTA);
            TransitionBrush[UH_CACHE_TRANSITION_SERVER_UPDATE] =
                    (HBRUSH)CreateSolidBrush(UH_RGB_RED);
#else
            StateBrush[UH_CACHE_STATE_IN_MEMORY] =
                    CECreateSolidBrush(UH_RGB_GREEN);
            StateBrush[UH_CACHE_STATE_ON_DISK] =
                    CECreateSolidBrush(UH_RGB_BLUE);

            TransitionBrush[UH_CACHE_TRANSITION_NONE] = NULL;
            TransitionBrush[UH_CACHE_TRANSITION_TOUCHED] =
                    (HBRUSH)CECreateSolidBrush(UH_RGB_YELLOW);
            TransitionBrush[UH_CACHE_TRANSITION_EVICTED] =
                    (HBRUSH)GetStockObject(BLACK_BRUSH);
            TransitionBrush[UH_CACHE_TRANSITION_LOADED_FROM_DISK] =
                    (HBRUSH)GetStockObject(WHITE_BRUSH);
            TransitionBrush[UH_CACHE_TRANSITION_KEY_LOAD_ON_SESSION_START] =
                    (HBRUSH)CECreateSolidBrush(UH_RGB_MAGENTA);
            TransitionBrush[UH_CACHE_TRANSITION_SERVER_UPDATE] =
                    (HBRUSH)CECreateSolidBrush(UH_RGB_RED);
#endif

            /****************************************************************/
            /* Paint the background                                         */
            /****************************************************************/
            GetClientRect(hwnd, &clientRect);
            FillRect(hdc, &clientRect, hbrGray);

            /****************************************************************/
            /* Draw the cache blobs.                                        */
            /****************************************************************/
            outputAreaWidth = (clientRect.right - clientRect.left) -
                    (2 * UH_CACHE_WINDOW_BORDER_WIDTH);
            numBlobsPerRow = outputAreaWidth / UH_CACHE_BLOB_TOTAL_WIDTH;

            if (_UH.MonitorEntries[0] != NULL) {
                for (cacheId = 0; cacheId < _UH.NumBitmapCaches; cacheId++) {
                    if (!_UH.bitmapCache[cacheId].BCInfo.bSendBitmapKeys)
                        NumEntries = _UH.bitmapCache[cacheId].BCInfo.NumEntries;
                    else
                        NumEntries = _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries;

                    for (i = 0; i < NumEntries; i++) {
                        /********************************************************/
                        /* Get the rectangle that represents this cache entry.  */
                        /********************************************************/
                        UHGetCacheBlobRect(cacheId, i, &rect);

                        // Determine the brush to use according to transition and
                        // state.
                        if (_UH.MonitorEntries[cacheId][i].FlashTransition ==
                                UH_CACHE_TRANSITION_NONE)
                            hbrToUse = StateBrush[_UH.MonitorEntries[cacheId][i].
                                    State];
                        else
                            hbrToUse = TransitionBrush[_UH.MonitorEntries[
                                    cacheId][i].FlashTransition];

                        /********************************************************/
                        /* Color the blob appropriately.                        */
                        /********************************************************/
                        FillRect(hdc, &rect, hbrToUse);
                    }
                }
            }

            /****************************************************************/
            /* If the update region includes any part of the displayed      */
            /* cache bitmap area, and we've not exited the session then     */
            /* paint it.                                                    */
            /*                                                              */
            /* This test avoids repainting the displayed cache bitmap       */
            /* every time a cache blob flashes (which is very often!).      */
            /****************************************************************/
            if (ps.rcPaint.bottom > (int)_UH.yDisplayedCacheBitmapStart &&
                    _UH.NumBitmapCaches > 0)
                UHDisplayCacheEntry(hdc, _UH.displayedCacheId,
                        _UH.displayedCacheEntry);

            // Clean up.
#ifndef OS_WINCE
            for (i = 0; i < UH_CACHE_NUM_STATES; i++)
                DeleteBrush(StateBrush[i]);
            for (i = 1; i < UH_CACHE_NUM_TRANSITIONS; i++)
                DeleteBrush(TransitionBrush[i]);
#else
            CEDeleteBrush(StateBrush[UH_CACHE_STATE_IN_MEMORY]);
            CEDeleteBrush(StateBrush[UH_CACHE_STATE_ON_DISK]);
            CEDeleteBrush(TransitionBrush[UH_CACHE_TRANSITION_TOUCHED]);
            CEDeleteBrush(TransitionBrush[UH_CACHE_TRANSITION_KEY_LOAD_ON_SESSION_START]);
            CEDeleteBrush(TransitionBrush[UH_CACHE_TRANSITION_SERVER_UPDATE]);
#endif

#ifdef DC_HICOLOR
            if (_UH.protocolBpp <= 8)
            {
#endif
                SelectPalette(hdc, hpalOld, FALSE);
#ifdef DC_HICOLOR
            }
#endif
            EndPaint(hwnd, &ps);
        }
        break;

        default:
        {
            rc = DefWindowProc(hwnd, message, wParam, lParam);
        }
        break;
    }

    DC_END_FN();
    return rc;
} /* UHBitmapCacheWndProc */


/****************************************************************************/
// UHSetMonitorEntryState
//
// Common function to change a cache entry to a new state and cause the
// UI to be redrawn.
/****************************************************************************/
void DCINTERNAL CUH::UHSetMonitorEntryState(
        unsigned CacheID,
        ULONG    CacheIndex,
        BYTE     State,
        BYTE     Transition)
{
    RECT rect;

    DC_BEGIN_FN("UHSetMonitorEntryState");

    if (_UH.MonitorEntries[0] != NULL ) {
        // The state type marks whether this entry in now on disk or in memory.
        TRC_ASSERT((State < UH_CACHE_NUM_STATES),
                (TB,_T("State out of bounds %d"), State));
        _UH.MonitorEntries[CacheID][CacheIndex].State = State;

        TRC_NRM((TB, _T("CacheID %d, Index %d: State %d Trans %d"), CacheID,
                CacheIndex, State, Transition));

        // If this transition is more important (higher in number) than the
        // current transition, the timer gets reset to the current time and
        // the new transition takes over.
        TRC_ASSERT((Transition < UH_CACHE_NUM_TRANSITIONS),
                (TB,_T("Transition out of bounds %d"), Transition));
        if (Transition > _UH.MonitorEntries[CacheID][CacheIndex].FlashTransition) {
            _UH.MonitorEntries[CacheID][CacheIndex].FlashTransition = Transition;
            _UH.MonitorEntries[CacheID][CacheIndex].EventTime = GetTickCount();
        }

        // Force a repaint of the corresponding cache blob.
        UHGetCacheBlobRect(CacheID, CacheIndex, &rect);
        InvalidateRect(_UH.hwndBitmapCacheMonitor, &rect, FALSE);
    }

    DC_END_FN();
}


/****************************************************************************/
/* Name:      UHCacheDataReceived                                           */
/*                                                                          */
/* Purpose:   Performs required actions when new data for a cache entry is  */
/*            received.                                                     */
/*                                                                          */
/* Params:    cacheId    - cache id                                         */
/*            cacheEntry - cache entry                                      */
/****************************************************************************/
void DCINTERNAL CUH::UHCacheDataReceived(unsigned cacheId, ULONG cacheEntry)
{
    DC_BEGIN_FN("UHCacheDataReceived");

    if (_UH.MonitorEntries[0] != NULL) {
        /************************************************************************/
        /* Reset the usage count.                                               */
        /************************************************************************/
        _UH.MonitorEntries[cacheId][cacheEntry].UsageCount = 0;

        // Change the state.
        UHSetMonitorEntryState(cacheId, cacheEntry, UH_CACHE_STATE_IN_MEMORY,
                UH_CACHE_TRANSITION_SERVER_UPDATE);

        /************************************************************************/
        /* If the new data is for the cache entry currently displayed           */
        /* (unlikely, but it can happen!).                                      */
        /************************************************************************/
        if (cacheId == _UH.displayedCacheId &&
                cacheEntry == _UH.displayedCacheEntry)
            UHRefreshDisplayedCacheEntry();
    }

    DC_END_FN();
}


/****************************************************************************/
/* Name:      UHCacheEntryUsed                                              */
/*                                                                          */
/* Purpose:   Performs required actions when a cache entry is used.         */
/*                                                                          */
/* Params:    cacheId    - cache id                                         */
/*            cacheEntry - cache entry                                      */
/****************************************************************************/
// SECURITY - caller must verify cacheId and cacheIndex
void DCINTERNAL CUH::UHCacheEntryUsed(
        unsigned cacheId,
        ULONG    cacheEntry,
        unsigned colorTableCacheEntry)
{
    DC_BEGIN_FN("UHCacheEntryUsed");

    if (_UH.MonitorEntries[0] != NULL) {
        // Store the color table.
        _UH.MonitorEntries[cacheId][cacheEntry].ColorTable =
                (BYTE)colorTableCacheEntry;

        UHSetMonitorEntryState(cacheId, cacheEntry, UH_CACHE_STATE_IN_MEMORY,
                UH_CACHE_TRANSITION_TOUCHED);
    }

    DC_END_FN();
}


/****************************************************************************/
/* Name:      UHRefreshDisplayedCacheEntry                                  */
/*                                                                          */
/* Purpose:   Forces a repaint of the displayed cache entry.                */
/****************************************************************************/
void DCINTERNAL CUH::UHRefreshDisplayedCacheEntry()
{
    RECT rect;

    DC_BEGIN_FN("UHRefreshDisplayedCacheEntry");

    if (_UH.MonitorEntries[0] != NULL) {
        // Set the "touched" transition to color the bitmap entry.
        if (_UH.MonitorEntries[_UH.displayedCacheId][_UH.displayedCacheEntry].
                FlashTransition < UH_CACHE_TRANSITION_TOUCHED) {
            _UH.MonitorEntries[_UH.displayedCacheId][_UH.displayedCacheEntry].
                    FlashTransition = UH_CACHE_TRANSITION_TOUCHED;
            _UH.MonitorEntries[_UH.displayedCacheId][_UH.displayedCacheEntry].
                    EventTime = GetTickCount();

            // Force a repaint of the corresponding cache blob.
            UHGetCacheBlobRect(_UH.displayedCacheId, _UH.displayedCacheEntry,
                    &rect);
            InvalidateRect(_UH.hwndBitmapCacheMonitor, &rect, FALSE);
        }

        GetClientRect(_UH.hwndBitmapCacheMonitor, &rect);
        rect.top = _UH.yDisplayedCacheBitmapStart;
        InvalidateRect(_UH.hwndBitmapCacheMonitor, &rect, FALSE);
    }

    DC_END_FN();
}


/****************************************************************************/
/* Name:      UHDisplayCacheEntry                                           */
/*                                                                          */
/* Purpose:   Displays a given cache entry bitmap.                          */
/*                                                                          */
/* Params:    hdc        - DC handle                                        */
/*            cacheId    - cache id                                         */
/*            cacheEntry - cache entry                                      */
/****************************************************************************/
// SECURITY - caller should verify cacheId and cacheEntry
void DCINTERNAL CUH::UHDisplayCacheEntry(
        HDC      hdc,
        unsigned cacheId,
        ULONG    cacheEntry)
{
    PUHBITMAPCACHEENTRYHDR pCacheEntryHdr;
    HBRUSH                 hbrGray;
    RECT                   rect;
    HFONT                  hFont;
    HFONT                  hFontOld;
    DCTCHAR                stringBuffer[160];
    SIZE                   stringSize;
    LOGFONT                lf;
    ULONG                  MemEntry;
    MEMBLT_COMMON          MB;
    HRESULT                hr;

    DC_BEGIN_FN("UHDisplayCacheEntry");

    if (_UH.MonitorEntries[0] != NULL) {
        /************************************************************************/
        /* Erase the background.                                                */
        /************************************************************************/
        hbrGray = (HBRUSH)GetStockObject(GRAY_BRUSH);
        GetClientRect(_UH.hwndBitmapCacheMonitor, &rect);
        rect.top  = _UH.yDisplayedCacheBitmapStart;
        FillRect(hdc, &rect, hbrGray);

        // Do some initial checks to see if we should continue.
        TRC_ASSERT((cacheId < _UH.NumBitmapCaches),
                (TB,_T("CacheID received (%u) is out of range!"), cacheId));
        if (_UH.MonitorEntries[cacheId][cacheEntry].State == UH_CACHE_STATE_UNUSED)
            DC_QUIT;

        /************************************************************************/
        // Load the font for the descriptive text.
        /************************************************************************/
        lf.lfHeight         = UH_CACHE_DISPLAY_FONT_SIZE;
        lf.lfWidth          = 0;
        lf.lfEscapement     = 0;
        lf.lfOrientation    = 0;
        lf.lfWeight         = UH_CACHE_DISPLAY_FONT_WEIGHT;
        lf.lfItalic         = 0;
        lf.lfUnderline      = 0;
        lf.lfStrikeOut      = 0;
        lf.lfCharSet        = 0;
        lf.lfOutPrecision   = 0;
        lf.lfClipPrecision  = 0;
        lf.lfQuality        = 0;
        lf.lfPitchAndFamily = 0;
        StringCchCopy(lf.lfFaceName, SIZE_TCHARS(lf.lfFaceName),
                      UH_CACHE_DISPLAY_FONT_NAME);

        hFont = CreateFontIndirect(&lf);
        hFontOld = SelectFont(hdc, hFont);
        SetBkMode(hdc, TRANSPARENT);

        /************************************************************************/
        // Locate the cached bitmap information. If we're using a persistent
        // cache with a PTE table, make sure the entry is in memory.
        /************************************************************************/
        if (_UH.bitmapCache[cacheId].BCInfo.bSendBitmapKeys) {
            // Persistent cache.
            MemEntry = _UH.bitmapCache[cacheId].PageTable.PageEntries[cacheEntry].
                    iEntryToMem;
            if (MemEntry >= _UH.bitmapCache[cacheId].BCInfo.NumEntries) {
                // Entry not in memory.
                StringCchCopy(stringBuffer, SIZE_TCHARS(stringBuffer),
                              _T("Entry not in memory"));
                goto DisplayText;
            }
        }
        else {
            // Memory cache.
            MemEntry = cacheEntry;
        }
        pCacheEntryHdr = &_UH.bitmapCache[cacheId].Header[MemEntry];

        hr = StringCchPrintf(stringBuffer,
                    SIZE_TCHARS(stringBuffer),
                    _T("entry(%u:%u) cx(%u) cy(%u) size(%u) cellsize(%u) usage(%u)"),
                    cacheId, cacheEntry, pCacheEntryHdr->bitmapWidth,
                    pCacheEntryHdr->bitmapHeight, pCacheEntryHdr->bitmapLength,
                    pCacheEntryHdr->bitmapWidth * pCacheEntryHdr->bitmapHeight,
                    _UH.MonitorEntries[cacheId][cacheEntry].UsageCount);
        TRC_ASSERT(SUCCEEDED(hr),
                   (TB,_T("Error copying printf'ing stringBuffer: 0x%x"), hr));


        /************************************************************************/
        /* Query the string height (so we know where to position the bitmap).   */
        /************************************************************************/
        GetTextExtentPoint(hdc, stringBuffer, DC_TSTRLEN(stringBuffer),
                &stringSize);

        /************************************************************************/
        // Draw the cached bitmap. Must be sure here that the entry in question
        // is already in memory since we don't want debug code to cause memory
        // cache evictions and disk loads.
        /************************************************************************/
        MB.cacheId = (UINT16)(cacheId |
                ((unsigned)(_UH.MonitorEntries[cacheId][cacheEntry].ColorTable) <<
                8));
        MB.cacheIndex = (UINT16)cacheEntry;
        MB.nLeftRect = UH_CACHE_WINDOW_BORDER_WIDTH;
        MB.nTopRect = _UH.yDisplayedCacheBitmapStart + stringSize.cy +
                UH_CACHE_TEXT_SPACING;
        MB.nWidth = pCacheEntryHdr->bitmapWidth;
        MB.nHeight = pCacheEntryHdr->bitmapHeight;
        MB.bRop = 0xCC;
        MB.nXSrc = 0;
        MB.nYSrc = 0;

        UHDrawMemBltOrder(hdc, &MB);

DisplayText:
        ExtTextOut(hdc, UH_CACHE_WINDOW_BORDER_WIDTH,
                _UH.yDisplayedCacheBitmapStart, 0, NULL, stringBuffer,
                DC_TSTRLEN(stringBuffer), NULL);
        SelectFont(hdc, hFontOld);
        DeleteFont(hFont);
    }

DC_EXIT_POINT:
    DC_END_FN();
}


/****************************************************************************/
/* Name:      GetCacheBlobRect                                              */
/*                                                                          */
/* Purpose:   Returns the rectangle (in client coords) that the given       */
/*            cache entry is displayed in.                                  */
/*                                                                          */
/* Params:    IN:  cacheId - cache Id                                       */
/*            IN:  cacheEntry - cache entry                                 */
/*            OUT: pRect - pointer to rect that receives the coordinates    */
/****************************************************************************/
void DCINTERNAL CUH::UHGetCacheBlobRect(
        unsigned cacheId,
        ULONG    cacheEntry,
        LPRECT   pRect)
{
    DC_BEGIN_FN("UHGetCacheBlobRect");

    /************************************************************************/
    /* Check for invisible window.                                          */
    /************************************************************************/
    if (_UH.numCacheBlobsPerRow == 0)
    {
        pRect->left = 0;
        pRect->top = 0;
        pRect->right = 0;
        pRect->bottom = 0;

        DC_QUIT;
    }

    /************************************************************************/
    /* Do the calculation.                                                  */
    /************************************************************************/
    pRect->left = (int)(UH_CACHE_WINDOW_BORDER_WIDTH +
            (cacheEntry % _UH.numCacheBlobsPerRow) *
            UH_CACHE_BLOB_TOTAL_WIDTH);
    pRect->top = (int)(_UH.yCacheStart[cacheId] +
           (cacheEntry / _UH.numCacheBlobsPerRow) *
           UH_CACHE_BLOB_TOTAL_HEIGHT);
    pRect->right = pRect->left + UH_CACHE_BLOB_WIDTH;
    pRect->bottom = pRect->top + UH_CACHE_BLOB_HEIGHT;

DC_EXIT_POINT:
    DC_END_FN();
}


/****************************************************************************/
/* Name:      UHGetCacheBlobFromPoint                                       */
/*                                                                          */
/* Purpose:   Returns the cache entry (blob) displayed at a given point     */
/*            in the Bitmap Cache Monitor Window.                           */
/*                                                                          */
/* Returns:   TRUE if the given point maps to a cache blob, FALSE otherwise */
/*                                                                          */
/* Params:    IN:  pPoint - pointer to coordinates to test                  */
/*                                                                          */
/*            OUT: pCacheId - pointer to variable that receives the cache   */
/*                            id, if return code is TRUE.                   */
/*                                                                          */
/*            OUT: pCacheEntry - pointer to variable that receives the      */
/*                               cache entry, if return code is TRUE.       */
/****************************************************************************/
BOOL DCINTERNAL CUH::UHGetCacheBlobFromPoint(
        LPPOINT  pPoint,
        unsigned *pCacheId,
        ULONG    *pCacheEntry)
{
    int x, y;
    BOOL  rc = FALSE;
    ULONG cacheEntry;
    unsigned cacheId;

    DC_BEGIN_FN("UHGetCacheBlobFromPoint");

    /************************************************************************/
    /* Calculate the x-coord of the selected blob.                          */
    /************************************************************************/
    x = (pPoint->x - UH_CACHE_WINDOW_BORDER_WIDTH) /
                                                    UH_CACHE_BLOB_TOTAL_WIDTH;

    /************************************************************************/
    /* If the x-coord is outside the displayed range then exit immediately. */
    /************************************************************************/
    if (x < 0 || x >= (DCINT)_UH.numCacheBlobsPerRow)
        DC_QUIT;

    /************************************************************************/
    /* Go through each cache in turn, and see if the supplied point         */
    /* corresponds to a valid blob for that cache.                          */
    /************************************************************************/
    for (cacheId = 0; cacheId < _UH.NumBitmapCaches; cacheId++)
    {
        if (pPoint->y >= (DCINT)_UH.yCacheStart[cacheId])
        {
            y = (pPoint->y - _UH.yCacheStart[cacheId]) /
                                                   UH_CACHE_BLOB_TOTAL_HEIGHT;

            cacheEntry = x + (y * _UH.numCacheBlobsPerRow);

            if ((!_UH.bitmapCache[cacheId].BCInfo.bSendBitmapKeys &&
                    cacheEntry < _UH.bitmapCache[cacheId].BCInfo.NumEntries) ||
                    (_UH.bitmapCache[cacheId].BCInfo.bSendBitmapKeys &&
                    cacheEntry < _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries))
            {
                /************************************************************/
                /* This is a valid cacheEntry - return it.                  */
                /************************************************************/
                *pCacheId = cacheId;
                *pCacheEntry = cacheEntry;
                rc = TRUE;
                DC_QUIT;
            }
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}

#endif /* DC_DEBUG */


/****************************************************************************/
/* Name:      UHAllocColorTableCacheMemory                                  */
/*                                                                          */
/* Purpose:   Dynamically allocates memory for the color table cache.       */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/****************************************************************************/
BOOL DCINTERNAL CUH::UHAllocColorTableCacheMemory()
{
    UINT32 colorTableCacheSize;
    UINT32 mappedColorTableCacheSize;
    DCBOOL rc = FALSE;

    DC_BEGIN_FN("UHAllocColorTableCacheMemory");

    // Calculate the total byte size of the color table cache.
    colorTableCacheSize = sizeof(*(_UH.pColorTableCache)) *
            UH_COLOR_TABLE_CACHE_ENTRIES;
    mappedColorTableCacheSize = sizeof(*(_UH.pMappedColorTableCache)) *
            UH_COLOR_TABLE_CACHE_ENTRIES;

    // Get the memory.
    _UH.pColorTableCache = (PUHCACHEDCOLORTABLE)UT_Malloc(_pUt,
            (unsigned)colorTableCacheSize);
    if (_UH.pColorTableCache != NULL) {
        // Alloc the color map table.
        TRC_DBG((TB, _T("Try for color mapped table")));
        _UH.pMappedColorTableCache = (PUHBITMAPINFOPALINDEX)UT_Malloc(_pUt,
                (unsigned)mappedColorTableCacheSize);
        if (_UH.pMappedColorTableCache != NULL) {
            // Successfully allocated color table cache memory.
            TRC_NRM((TB, _T("Allocated %#x bytes for color table cache"),
                    (DCUINT)colorTableCacheSize));
            TRC_NRM((TB, _T("Allocated %#x bytes for mapped color table cache"),
                    (DCUINT)mappedColorTableCacheSize));
            rc = TRUE;
        }
        else {
            // Memory allocation failure. Free what we allocated already.
            TRC_ERR((TB, _T("Failed to allocate %#x bytes for mapped color ")
                    _T("table cache"), (unsigned)mappedColorTableCacheSize));
            UT_Free( _pUt, _UH.pColorTableCache);
            _UH.pColorTableCache = NULL;
        }
    }
    else {
        // Memory allocation failure.
        TRC_ERR((TB, _T("Failed to allocate %#x bytes for color table cache"),
                (unsigned)colorTableCacheSize));
    }

    DC_END_FN();
    return rc;
}


#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

/****************************************************************************/
// UHEvictLRUCacheEntry
//
// Evict the least recently used Cache Entry
/****************************************************************************/
// SECURITY - caller must verify cacheId
UINT32 DCINTERNAL CUH::UHEvictLRUCacheEntry(UINT cacheId)
{
    ULONG memEntry;
    ULONG iEntry;
    ULONG inext;
    ULONG iprev;

    DC_BEGIN_FN("UHEvictLRUCacheEntry");

    TRC_ASSERT((cacheId < TS_BITMAPCACHE_MAX_CELL_CACHES),
            (TB, _T("Invalid cache ID %u"), cacheId));

    // Evict the last entry in the MRU list
    iEntry = _UH.bitmapCache[cacheId].PageTable.MRUTail;
    TRC_NRM((TB, _T("Select %u for eviction"), iEntry));
    TRC_ASSERT((iEntry < _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries),
               (TB, _T("Broken/empty MRU list")));

    // We need to update the MRU chain
    inext = _UH.bitmapCache[cacheId].PageTable.PageEntries[iEntry].mruList.next;
    iprev = _UH.bitmapCache[cacheId].PageTable.PageEntries[iEntry].mruList.prev;
    TRC_ASSERT((inext == _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries),
            (TB,_T("The MRU Chain is broken")));

    if (iprev < _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries) {
        // remove this entry from the MRU chain
        _UH.bitmapCache[cacheId].PageTable.PageEntries[iprev].mruList.next = inext;
    }
    else {
        // this entry is the head entry from MRU chain, leaving MRU chain empty
        _UH.bitmapCache[cacheId].PageTable.MRUHead = inext;
    }
    // update the tail of the MRU chain
    _UH.bitmapCache[cacheId].PageTable.MRUTail = iprev;

    // Find the iEntry in the physical cache
    memEntry = _UH.bitmapCache[cacheId].PageTable.PageEntries[iEntry].iEntryToMem;

    // reset this node's page table entry
    _UH.bitmapCache[cacheId].PageTable.PageEntries[iEntry].iEntryToMem =
                            _UH.bitmapCache[cacheId].BCInfo.NumEntries;
    _UH.bitmapCache[cacheId].PageTable.PageEntries[iEntry].mruList.prev =
                            _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries;
    _UH.bitmapCache[cacheId].PageTable.PageEntries[iEntry].mruList.next =
                            _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries;

#ifdef DC_DEBUG
    UHCacheEntryEvictedFromMem((unsigned)cacheId, iEntry);
#endif

    DC_END_FN();
    return memEntry;
}


/****************************************************************************/
// UHFindFreeCacheEntry
//
// Find a free cache entry:
/****************************************************************************/
// SECURITY - caller must verify cacheId
UINT32 DCINTERNAL CUH::UHFindFreeCacheEntry (UINT cacheId)
{
    UINT32 memEntry;

    DC_BEGIN_FN("UHFindFreeCacheEntry");

    TRC_ASSERT((cacheId < TS_BITMAPCACHE_MAX_CELL_CACHES),
            (TB, _T("Invalid cache ID %u"), cacheId));

    TRC_NRM((TB, _T("Searching cache %u for free entry"), cacheId));

    // Get the entry pointed to by free list
    memEntry = _UH.bitmapCache[cacheId].PageTable.FreeMemList;

    if (memEntry == _UH.bitmapCache[cacheId].BCInfo.NumEntries) {
        TRC_NRM((TB, _T("Physical cache %u memory is full"), cacheId));
    }
    else {
        TRC_NRM((TB, _T("Free entry at %u"), memEntry));
        // update our free list
        _UH.bitmapCache[cacheId].PageTable.FreeMemList =
                *(PDCUINT32)(&_UH.bitmapCache[cacheId].Header[memEntry]);
    }

    DC_END_FN();
    return memEntry;
}


/****************************************************************************/
// UHTouchMRUCacheEntry
//
// Move a PTE cache entry to the head of the MRU PTE list
/****************************************************************************/
// SECURITY - caller must verify cacheId and iEntry
VOID DCINTERNAL CUH::UHTouchMRUCacheEntry(UINT cacheId, UINT32 iEntry)
{
    ULONG inext;
    ULONG iprev;
    HPUHBITMAPCACHEPTE pageEntry;

    DC_BEGIN_FN("UHTouchMRUCacheEntry");

    TRC_ASSERT((cacheId < TS_BITMAPCACHE_MAX_CELL_CACHES),
            (TB, _T("Invalid cache ID %u"), cacheId));

    // point to the page table entry for this cache
    pageEntry = _UH.bitmapCache[cacheId].PageTable.PageEntries;

    /************************************************************************/
    // Move this entry to the head of the MRU list
    /************************************************************************/
    if (_UH.bitmapCache[cacheId].PageTable.MRUHead != iEntry) {
       iprev = pageEntry[iEntry].mruList.prev;
       inext = pageEntry[iEntry].mruList.next;

       TRC_NRM((TB, _T("Add/Remove entry %u which was chained off %u to %u"),
                iEntry, iprev, inext));

       if (iprev != _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries) {
          // This entry is currently chained in the MRU list
          // Need to remove the entry from the current MRU List first
          pageEntry[iprev].mruList.next = inext;
          if (inext != _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries) {
             pageEntry[inext].mruList.prev = iprev;
          }
          else  {
             // this entry was the tail of the mru list.  So we need
             // to update the MRU tail.
             _UH.bitmapCache[cacheId].PageTable.MRUTail = iprev;
          }
       }

       /*********************************************************************/
       // Add this entry to the head of the MRU List
       /*********************************************************************/
       // this entry's next should point to the head of current MRU list
       // its prev should point to an invalid entry
       inext = _UH.bitmapCache[cacheId].PageTable.MRUHead;
       pageEntry[iEntry].mruList.next = inext;
       pageEntry[iEntry].mruList.prev = _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries;

       // we also need to update the MRU head to point to this entry
       _UH.bitmapCache[cacheId].PageTable.MRUHead = iEntry;

       if (inext != _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries) {
           // link this new head entry to the rest of the mru list
           pageEntry[inext].mruList.prev = iEntry;
       }
       else {
           // mru list was empty. This entry is actually the first node
           // added to the mru list.
           // so the mru tail should point to this node too
           _UH.bitmapCache[cacheId].PageTable.MRUTail = iEntry;
       }

       TRC_NRM((TB, _T("Cache %u entry %u to head of MRU list"), cacheId, iEntry));
    }
    else {
        // this entry is already at the head of MRU list.  No update is needed
        TRC_NRM((TB, _T("Cache %u entry %u already at head of MRU List"),
                cacheId, iEntry));
    }

    DC_END_FN();
}


/****************************************************************************/
// UHInitBitmapCachePageTable
//
// Initialize the MRU, Free List, etc of a bitmap page table
/****************************************************************************/
// SECURITY - caller must verify cacheId
_inline VOID DCINTERNAL CUH::UHInitBitmapCachePageTable(UINT cacheId)
{
    UINT32 i;
    PDCUINT32 pFreeList;

    DC_BEGIN_FN("UHInitBitmapCachePageTable");

    _UH.bitmapCache[cacheId].PageTable.MRUHead = _UH.bitmapCache[cacheId]
            .BCInfo.NumVirtualEntries;
    _UH.bitmapCache[cacheId].PageTable.MRUTail = _UH.bitmapCache[cacheId]
            .BCInfo.NumVirtualEntries;
    _UH.bitmapCache[cacheId].PageTable.FreeMemList = 0;

    // set up the free list
    pFreeList = (PDCUINT32) (_UH.bitmapCache[cacheId].Header);
    for (i = 0; i < _UH.bitmapCache[cacheId].BCInfo.NumEntries; i++) {
         *pFreeList = i+1;
         pFreeList = (PDCUINT32) &(_UH.bitmapCache[cacheId].Header[i+1]);
    }

    // initialize the mru list
    for (i = 0; i < _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries; i++) {
         _UH.bitmapCache[cacheId].PageTable.PageEntries[i].bmpInfo.Key1 = 0;
         _UH.bitmapCache[cacheId].PageTable.PageEntries[i].bmpInfo.Key2 = 0;
         _UH.bitmapCache[cacheId].PageTable.PageEntries[i].mruList.prev =
                 _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries;
         _UH.bitmapCache[cacheId].PageTable.PageEntries[i].mruList.next =
                 _UH.bitmapCache[cacheId].BCInfo.NumVirtualEntries;
         _UH.bitmapCache[cacheId].PageTable.PageEntries[i].iEntryToMem =
                 _UH.bitmapCache[cacheId].BCInfo.NumEntries;
    }
    DC_END_FN();
}

/****************************************************************************/
// UHAllocBitmapCachePageTable
//
// Dynamically allocates memory for UH bitmap cache Page Table of cacheId
/****************************************************************************/
// SECURITY - caller must verify cacheId
inline BOOL DCINTERNAL CUH::UHAllocBitmapCachePageTable(
        UINT32 NumEntries,
        UINT   cacheId)
{
    DCBOOL   rc = FALSE;
    DCUINT32 dataSize;

    DC_BEGIN_FN("UHAllocBitmapCachePageTable");

    if (NumEntries) {

       /************************************************************************/
       /* Calculate the total byte size to allocate for this cache.            */
       /************************************************************************/
       dataSize = (ULONG)NumEntries * (ULONG) sizeof(UHBITMAPCACHEPTE);
       TRC_NRM((TB, _T("Allocate Bitmap Page Table with %u entries: %#lx bytes"),
               NumEntries, dataSize));

       /************************************************************************/
       /* Get the memory for the cache data                                    */
       /************************************************************************/
       _UH.bitmapCache[cacheId].PageTable.PageEntries = (PUHBITMAPCACHEPTE)UT_MallocHuge( _pUt, dataSize);

       if (_UH.bitmapCache[cacheId].PageTable.PageEntries != NULL) {
           TRC_DBG((TB, _T("Allocated %#lx bytes for bitmap cache page table"), dataSize));
           UHInitBitmapCachePageTable(cacheId);
           rc = TRUE;
       }
       else {
           TRC_ERR((TB, _T("Failed to allocate %#lx bytes for bitmap cache page table"),
                   dataSize));
       }
    }
    else {
        TRC_ALT((TB, _T("0 bytes are allocated for bitmap cache page table")));
    }

    DC_END_FN();
    return rc;
}

/****************************************************************************/
// UHCreateCacheDirectory
//
// Try to create the bitmap cache directory
/****************************************************************************/
BOOL DCINTERNAL CUH::UHCreateCacheDirectory(void)
{
    BOOL rc = TRUE;
    int i = 0;

    DC_BEGIN_FN("UHCreateCacheDirectory");

    // Skip the first : to make sure the directory path contains
    // the drive letter
    while (_UH.PersistCacheFileName[i] != 0 &&
            _UH.PersistCacheFileName[i++] != _T(':'));

    // Skip the first \ because it's the one after drive letter
    // assuming \ is right after :
    if (_UH.PersistCacheFileName[i] != 0) {
        i++;
    }

    // From the root, go through each subdirectory and try to
    // create the directory
    while (rc && _UH.PersistCacheFileName[i] != 0) {
        if (_UH.PersistCacheFileName[i] == _T('\\')) {
            _UH.PersistCacheFileName[i] = 0;

            if (!CreateDirectory(_UH.PersistCacheFileName, NULL)) {
                // we can't create the directory, return failed
                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    _UH.bPersistenceDisable = TRUE;
                    rc = FALSE;
                }
            }
            _UH.PersistCacheFileName[i] = _T('\\');
        }

        i++;
    }

    DC_END_FN();
    return rc;
}
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))


/****************************************************************************/
/* Name:      UHAllocOneBitmapCache                                         */
/*                                                                          */
/* Purpose:   Dynamically allocates memory for one UH bitmap cache.         */
/*                                                                          */
#ifdef DC_HICOLOR
/* Returns:   Number of bytes actually allocated                            */
#else
/* Returns:   TRUE if successful, FALSE otherwise                           */
#endif
/*                                                                          */
/*                                                                          */
/* Params:    IN  maxMemToUse - max cache size which can be alloc'ed        */
/*            IN  entrySize   - size of each cache entry                    */
/*            OUT ppCacheData - address of buffer to receive cache data     */
/*                              pointer                                     */
/*            OUT ppCacheHdr  - address of buffer to receive cache header   */
/*                              pointer                                     */
/****************************************************************************/
#ifdef DC_HICOLOR
DCUINT32 DCINTERNAL CUH::UHAllocOneBitmapCache(DCUINT32  maxMemToUse,
                                          DCUINT         entrySize,
                                          HPDCVOID DCPTR ppCacheData,
                                          HPDCVOID DCPTR ppCacheHdr)
#else
DCBOOL DCINTERNAL CUH::UHAllocOneBitmapCache(DCUINT32       maxMemToUse,
                                        DCUINT         entrySize,
                                        HPDCVOID DCPTR ppCacheData,
                                        HPDCVOID DCPTR ppCacheHdr)
#endif
{
#ifdef DC_HICOLOR
    DCUINT32 sizeAlloced = 0;
#else
    DCBOOL   rc = FALSE;
#endif
    DCUINT32 dataSize;
    DCUINT   numEntries;
    DCUINT32 hdrSize;

    DC_BEGIN_FN("UHAllocOneBitmapCache");

    TRC_ASSERT((entrySize != 0), (TB, _T("Invalid cache entry size (0)")));
    TRC_ASSERT((entrySize <= maxMemToUse),
                         (TB, _T("Cache entry size exceeds max memory to use")));
    TRC_ASSERT(!IsBadWritePtr(ppCacheData, sizeof(ppCacheData)),
                                       (TB, _T("Invalid ppCacheData")));
    TRC_ASSERT(!IsBadWritePtr(ppCacheHdr, sizeof(ppCacheHdr)),
                                       (TB, _T("Invalid ppCacheHdr")));

    /************************************************************************/
    /* Calculate the total byte size to allocate for this cache.            */
    /************************************************************************/
    numEntries = (unsigned)(maxMemToUse / entrySize);
    dataSize = (DCUINT32)numEntries * (DCUINT32)entrySize;
    
    TRC_NRM((TB, _T("Allocate %u entries: %#lx bytes from possible %#lx"),
                                          numEntries, dataSize, maxMemToUse));

    /************************************************************************/
    /* Get the memory for the cache data                                    */
    /************************************************************************/
    *ppCacheData = UT_MallocHuge( _pUt, dataSize);
    if (*ppCacheData != NULL) {
        TRC_DBG((TB, _T("Allocated %#lx bytes for bitmap cache data"), dataSize));

#ifdef DC_DEBUG
        // Only zero in debug.
        DC_MEMSET(*ppCacheData, 0, dataSize);
#endif

        // Get the memory for the cache headers.
        hdrSize = (DCUINT32)numEntries * (DCUINT32)
                sizeof(UHBITMAPCACHEENTRYHDR);
        *ppCacheHdr = UT_MallocHuge( _pUt, hdrSize);
        if (*ppCacheHdr != NULL) {
            TRC_DBG((TB, _T("Allocated %#lx bytes for bitmap cache header"),
                    hdrSize));
            DC_MEMSET(*ppCacheHdr, 0, hdrSize);
#ifdef DC_HICOLOR
            sizeAlloced = dataSize;
#else
            rc = TRUE;
#endif
        }
        else {
            TRC_ERR((TB, _T("Failed to allocate %#lx bytes for bitmap cache hdrs"),
                    hdrSize));

            // Free what we already allocated.
            UT_Free( _pUt, *ppCacheData);
            *ppCacheData = NULL;
        }
    }
    else {
        TRC_ERR((TB, _T("Failed to allocate %#lx bytes for bitmap cache"),
                dataSize));
    }

    DC_END_FN();
#ifdef DC_HICOLOR
    return(sizeAlloced);
#else
    return rc;
#endif
}


/****************************************************************************/
// UHAllocBitmapCacheMemory
//
// Prepares the cache client-to-server capabilities and allocates cache memory
// according to the determined server support. Should be called after server
// caps are processed after receipt of a DemandActivePDU.
/****************************************************************************/
void DCINTERNAL CUH::UHAllocBitmapCacheMemory(void)
{
    unsigned i, j;
    DCUINT32 CacheSize, NumEntries;
    unsigned TotalProportion, TotalVirtualProp;

    DC_BEGIN_FN("UHAllocBitmapCacheMemory");

    // We assume _pCc->_ccCombinedCapabilities.bitmapCacheCaps has been initialized
    // before calling this function. See UH_Enable().

    /************************************************************************/
    // Set up _pCc->_ccCombinedCapabilities.bitmapCacheCaps according to the
    // advertised server version.
    /************************************************************************/
    if (_UH.BitmapCacheVersion > TS_BITMAPCACHE_REV1) {
        TS_BITMAPCACHE_CAPABILITYSET_REV2 *pRev2Caps;

        // Rev2 caps.
        pRev2Caps = (TS_BITMAPCACHE_CAPABILITYSET_REV2 *)
                &_pCc->_ccCombinedCapabilities.bitmapCacheCaps;

        TRC_ALT((TB,_T("Preparing REV2 caps for server\n")));

        pRev2Caps->capabilitySetType = TS_CAPSETTYPE_BITMAPCACHE_REV2;
        pRev2Caps->NumCellCaches = (TSUINT8)_UH.RegNumBitmapCaches;
        pRev2Caps->bAllowCacheWaitingList = TRUE;

        // create cache directory

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

        if (!_UH.bPersistenceDisable) {
            _UH.PersistCacheFileName[_UH.EndPersistCacheDir - 1] = _T('\0');
            if (!CreateDirectory(_UH.PersistCacheFileName, NULL)) {
                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    // since we can't directly create the cache directory, we need to
                    // start from the root, traverse every level and see if all the
                    // subdirectories are properly created
                    _UH.PersistCacheFileName[_UH.EndPersistCacheDir - 1] = _T('\\');
                    UHCreateCacheDirectory();
                    _UH.PersistCacheFileName[_UH.EndPersistCacheDir - 1] = _T('\0');
                }
            }

            // For non WinCE 32bit client, we want to set the file
            // attribute so that it doesn't do content indexing
#ifndef OS_WINCE
            if (GetFileAttributes(_UH.PersistCacheFileName) != -1) {
                SetFileAttributes(_UH.PersistCacheFileName,
                        GetFileAttributes( _UH.PersistCacheFileName ) |
                        FILE_ATTRIBUTE_NOT_CONTENT_INDEXED );
            }
#endif
            _UH.PersistCacheFileName[_UH.EndPersistCacheDir - 1] = _T('\\');
        }

        // Read in the Persistence flag registry setting
        // We read this registry here because the persistent flag
        // can change after UH_Init
        if (!_UH.bPersistenceDisable) {
            _UH.RegPersistenceActive = (UINT16) _pUi->UI_GetBitmapPersistence();
        }
        else {
            _UH.RegPersistenceActive = FALSE;
        }
#endif  // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

        // Gather proportion total and persistent flag info.
        TotalProportion = TotalVirtualProp = 0;
#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
        _UH.bPersistenceActive = FALSE;
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

        for (i = 0; i < _UH.RegNumBitmapCaches; i++) {
            TotalProportion += _UH.RegBCProportion[i];

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

            if (_UH.RegPersistenceActive) {
                // We will send a persistent key PDU if any cache is marked
                // persistent.
                pRev2Caps->CellCacheInfo[i].bSendBitmapKeys =
                        _UH.RegBCInfo[i].bSendBitmapKeys;

                if (_UH.RegBCInfo[i].bSendBitmapKeys) {
                    TotalVirtualProp += _UH.RegBCProportion[i];
                    pRev2Caps->bPersistentKeysExpected = TRUE;
                    _UH.bPersistenceActive = TRUE;
                }
            }
            else
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
                pRev2Caps->CellCacheInfo[i].bSendBitmapKeys = 0;
        }

        // Now set up the number of physical cache entries according to the
        // proportion of the total, and allocate the memory.
        _UH.NumBitmapCaches = _UH.RegNumBitmapCaches;
        for (i = 0; i < _UH.RegNumBitmapCaches; i++) {
            // the cache size allocated for this cache
            if (TotalProportion != 0) {
                CacheSize = _UH.RegBCProportion[i] * (_UH.RegBitmapCacheSize *
                        (_UH.RegScaleBitmapCachesByBPP ? _UH.copyMultiplier :
                        1) / TotalProportion);
            }
            else {
                CacheSize = 0;
            }

            // Determine the number of entries for this cache
            pRev2Caps->CellCacheInfo[i].NumEntries = (CacheSize /
                    UH_CellSizeFromCacheID(i));
            pRev2Caps->CellCacheInfo[i].NumEntries = min(
                    pRev2Caps->CellCacheInfo[i].NumEntries,
                    _UH.RegBCMaxEntries[i]);
#ifdef DC_HICOLOR
            // Allocate an extra cache entry for the noncached bitmap that's in 
            // the waiting list to be cached later.
            CacheSize = UHGetOffsetIntoCache(pRev2Caps->CellCacheInfo[i].NumEntries + 1, i);
#else
            CacheSize = UH_CellSizeFromCacheID(i) *
                    pRev2Caps->CellCacheInfo[i].NumEntries;
#endif
            // Update our local bitmap cache info
            _UH.bitmapCache[i].BCInfo.NumEntries = pRev2Caps->CellCacheInfo[i].NumEntries;
#ifdef DC_HICOLOR
            _UH.bitmapCache[i].BCInfo.OrigNumEntries = _UH.bitmapCache[i].BCInfo.NumEntries;
#endif
            _UH.bitmapCache[i].BCInfo.bSendBitmapKeys = pRev2Caps->CellCacheInfo[i].bSendBitmapKeys;

            // allocate memory
#ifdef DC_HICOLOR
            if (CacheSize)
            {
                _UH.bitmapCache[i].BCInfo.MemLen =
                        UHAllocOneBitmapCache(
                        CacheSize,
                        UH_CellSizeFromCacheID(i),
                        (void**)&_UH.bitmapCache[i].Entries,
                        (void**)&_UH.bitmapCache[i].Header);
            }

            if ((CacheSize == 0) || (_UH.bitmapCache[i].BCInfo.MemLen == 0))
#else
            if (CacheSize == 0 || !UHAllocOneBitmapCache(CacheSize, UH_CellSizeFromCacheID(i),
                    (void**)&_UH.bitmapCache[i].Entries, (void**)&_UH.bitmapCache[i].Header))
#endif
            {
                // Alloc failure. We can only support as many cell caches as
                // we've already allocated.
                pRev2Caps->NumCellCaches = (TSUINT8)i;
                _UH.NumBitmapCaches = i;

                TRC_ERR((TB,_T("Failed to alloc cell cache %d, setting to %d cell ")
                        _T("caches"), i + 1, i));
                break;
            }
        }

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

        // Allocate Bitmap Virtual Cache Page Table
        if (_UH.bPersistenceActive && TotalVirtualProp != 0) {
            for (i = 0; i < _UH.NumBitmapCaches; i++) {
                if (_UH.RegBCInfo[i].bSendBitmapKeys) {
                    // the disk cache size allocated for this virtual cache
                    CacheSize = _UH.RegBCProportion[i] *
                            (UH_PropVirtualCacheSizeFromMult(_UH.copyMultiplier) /
                            TotalVirtualProp);
                    // determine the number of entries for this cache
                    NumEntries = CacheSize /
                            (UH_CellSizeFromCacheID(i) +
                            sizeof(UHBITMAPFILEHDR));
                    NumEntries = min(NumEntries, _UH.RegBCMaxEntries[i]);

                    _UH.bitmapCache[i].BCInfo.NumVirtualEntries = NumEntries;
                    // setup cache file for this bitmap cache
                    // 8bpp caching uses the same file as win2k
                    // higher color depths use a different name
                    // to prevent collisions due to the different cell sizes
                    //
                    UHSetCurrentCacheFileName(i, _UH.copyMultiplier);

                    _UH.bitmapCache[i].PageTable.CacheFileInfo.hCacheFile =
                        CreateFile( _UH.PersistCacheFileName,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_ALWAYS, //create if not exist
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

                    if (INVALID_HANDLE_VALUE !=
                        _UH.bitmapCache[i].PageTable.CacheFileInfo.hCacheFile) {
#ifdef VM_BMPCACHE
                        _UH.bitmapCache[i].PageTable.CacheFileInfo.pMappedView = NULL;
                        HANDLE hMap = 
                            CreateFileMapping(_UH.bitmapCache[i].PageTable.CacheFileInfo.hCacheFile,
                                              NULL,
                                              PAGE_READWRITE,
                                              0,
                                              CacheSize,
                                              NULL);
                        if (hMap)
                        {
                            _UH.bitmapCache[i].PageTable.CacheFileInfo.pMappedView =
                                (LPBYTE)MapViewOfFile( hMap, FILE_MAP_WRITE, 0, 0, CacheSize);

                            CloseHandle(hMap);
                            hMap = INVALID_HANDLE_VALUE;
                        }
                        else
                        {
                            TRC_ERR((TB,_T("CreateFileMapping for cache file failed: %s - x%x"),
                                     _UH.PersistCacheFileName, GetLastError()));
                            _UH.bitmapCache[i].BCInfo.NumVirtualEntries = 0;
                            break;
                        }

                        if(!_UH.bitmapCache[i].PageTable.CacheFileInfo.pMappedView)
                        {
                            TRC_ERR((TB,_T("MapViewOfFile failed 0x%x"),
                                     GetLastError()));
                            _UH.bitmapCache[i].BCInfo.NumVirtualEntries = 0;
                            break;
                        }
#endif

                        // allocate memory for cache page table
                        if (UHAllocBitmapCachePageTable(NumEntries, i)) {
                            pRev2Caps->CellCacheInfo[i].NumEntries = NumEntries;
                        }
                        else {
                            _UH.bitmapCache[i].BCInfo.NumVirtualEntries = 0;
                            break;
                        }
                    }
                    else {
                        TRC_ERR((TB,_T("CreateFile for cache file failed: %s - x%x"),
                                 _UH.PersistCacheFileName, GetLastError()));
                        pRev2Caps->CellCacheInfo[i].bSendBitmapKeys = 0;
                        _UH.bitmapCache[i].BCInfo.bSendBitmapKeys = 0;
                        _UH.bitmapCache[i].BCInfo.NumVirtualEntries = 0;
                    }
                }
            }
        }
        else {
            // No persistency for this session
            // below we redetermine the cache persistency.  Here we
            // need to set i  to 0 so that we will iterate through
            // all caches to reset the persistence flag
            i = 0;
        }

        // Need to redetermine cache persistence flag
        _UH.bPersistenceActive = FALSE;
        for (j = i; j < _UH.NumBitmapCaches; j++) {
            _UH.bitmapCache[j].BCInfo.bSendBitmapKeys = 0;
            pRev2Caps->CellCacheInfo[j].bSendBitmapKeys = 0;
        }

        for (j = 0; j < i; j++) {
            if (_UH.bitmapCache[j].BCInfo.bSendBitmapKeys) {
                _UH.bPersistenceActive = TRUE;
            }
        }

#if DC_DEBUG
        TRC_NRM((TB, _T("Num cell caches = %d, params:"), _UH.NumBitmapCaches));
        for (i = 0; i < _UH.NumBitmapCaches; i++) {
            TRC_NRM((TB,_T("    %d: Proportion=%d, persistent=%s, cellsize=%u"),
                    i, _UH.RegBCProportion[i],
                    (_UH.RegBCInfo[i].bSendBitmapKeys ? "TRUE" : "FALSE"),
                    UH_CellSizeFromCacheID(i)));
#ifdef DC_HICOLOR
        TRC_ALT((TB,_T("Cache %d created with %d entries"), i,
                            _UH.bitmapCache[i].BCInfo.NumEntries));
#endif
        }
#endif

#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))


        TRC_NRM((TB,_T("Allocated REV2 buffers OK\n")));
    }
    else {
        TS_BITMAPCACHE_CAPABILITYSET *pRev1Caps;

        TRC_ALT((TB,_T("Preparing REV1 caps for server\n")));

        // Set up rev1 capabilities by treating _pCc->_ccCombinedCapabilities.
        // bitmapCacheCaps as a rev1 structure.
        pRev1Caps = (TS_BITMAPCACHE_CAPABILITYSET *)&_pCc->_ccCombinedCapabilities.
                bitmapCacheCaps;
        pRev1Caps->capabilitySetType = TS_CAPSETTYPE_BITMAPCACHE;

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
        _UH.bPersistenceActive = FALSE;
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

        // If we don't have at least three caches configured, we can simply
        // send all zeroes in the caps -- rev1 bitmap caching is disabled
        // if any cache is unavailable.
        if (_UH.RegNumBitmapCaches >= 3) {
            // Gather proportion total.
            TotalProportion = _UH.RegBCProportion[0] + _UH.RegBCProportion[1] +
                    _UH.RegBCProportion[2];

            _UH.NumBitmapCaches = 3;

            // Now set up the number of cache entries according to the
            // proportion of the total, and allocate the memory.

            // CacheID 0.
            CacheSize = _UH.RegBCProportion[0] * _UH.RegBitmapCacheSize *
                    (_UH.RegScaleBitmapCachesByBPP ? _UH.copyMultiplier : 1) /
                    TotalProportion;
            pRev1Caps->Cache1MaximumCellSize = (TSUINT16)
                    UH_CellSizeFromCacheID(0);
            _UH.bitmapCache[0].BCInfo.bSendBitmapKeys = FALSE;

#ifdef DC_HICOLOR
            _UH.bitmapCache[0].BCInfo.MemLen =
                                UHAllocOneBitmapCache(
                                    CacheSize,
                                    pRev1Caps->Cache1MaximumCellSize,
                                    (void**)&_UH.bitmapCache[0].Entries,
                                    (void**)&_UH.bitmapCache[0].Header);

            if (_UH.bitmapCache[0].BCInfo.MemLen == 0)
            {
#else
            if (!UHAllocOneBitmapCache(CacheSize,
                    pRev1Caps->Cache1MaximumCellSize,
                    (void**)&_UH.bitmapCache[0].Entries, (void**)&_UH.bitmapCache[0].Header)) {
#endif
                // Alloc failure. No caches will be supported on the server.
                TRC_ERR((TB,_T("Failed alloc CacheID 0, rev1 caching disabled")));
                goto AllocErr;
            }
            pRev1Caps->Cache1Entries = (TSUINT16)(CacheSize /
                    UH_CellSizeFromCacheID(0));
            _UH.bitmapCache[0].BCInfo.NumEntries = pRev1Caps->Cache1Entries;
#ifdef DC_HICOLOR
            _UH.bitmapCache[0].BCInfo.OrigNumEntries = _UH.bitmapCache[0].BCInfo.NumEntries;
#endif
            // CacheID 1.
            CacheSize = _UH.RegBCProportion[1] * _UH.RegBitmapCacheSize *
                    (_UH.RegScaleBitmapCachesByBPP ? _UH.copyMultiplier : 1) /
                    TotalProportion;
            pRev1Caps->Cache2MaximumCellSize = (TSUINT16)
                    UH_CellSizeFromCacheID(1);
            _UH.bitmapCache[1].BCInfo.bSendBitmapKeys = FALSE;

#ifdef DC_HICOLOR
            _UH.bitmapCache[1].BCInfo.MemLen =
                                UHAllocOneBitmapCache(
                                    CacheSize,
                                    pRev1Caps->Cache2MaximumCellSize,
                                    (void**)&_UH.bitmapCache[1].Entries,
                                    (void**)&_UH.bitmapCache[1].Header);

            if (_UH.bitmapCache[1].BCInfo.MemLen == 0)
            {
#else
            if (!UHAllocOneBitmapCache(CacheSize,
                    pRev1Caps->Cache2MaximumCellSize,
                    (void**)&_UH.bitmapCache[1].Entries, (void**)&_UH.bitmapCache[1].Header)) {
#endif
                // Alloc failure. No caches will be supported on the server.
                TRC_ERR((TB,_T("Failed alloc CacheID 1, rev1 caching disabled")));
                goto AllocErr;
            }
            pRev1Caps->Cache2Entries = (TSUINT16)(CacheSize /
                    UH_CellSizeFromCacheID(1));
            _UH.bitmapCache[1].BCInfo.NumEntries = pRev1Caps->Cache2Entries;
#ifdef DC_HICOLOR
            _UH.bitmapCache[1].BCInfo.OrigNumEntries = _UH.bitmapCache[1].BCInfo.NumEntries;
#endif
            // CacheID 2.
            CacheSize = _UH.RegBCProportion[2] * _UH.RegBitmapCacheSize *
                    (_UH.RegScaleBitmapCachesByBPP ? _UH.copyMultiplier : 1) /
                    TotalProportion;
            pRev1Caps->Cache3MaximumCellSize = (TSUINT16)
                    UH_CellSizeFromCacheID(2);
            _UH.bitmapCache[2].BCInfo.bSendBitmapKeys = FALSE;

#ifdef DC_HICOLOR
            _UH.bitmapCache[2].BCInfo.MemLen =
                                UHAllocOneBitmapCache(
                                    CacheSize,
                                    pRev1Caps->Cache3MaximumCellSize,
                                    (void**)&_UH.bitmapCache[2].Entries,
                                    (void**)&_UH.bitmapCache[2].Header);

            if (_UH.bitmapCache[2].BCInfo.MemLen == 0)
            {
#else
            if (!UHAllocOneBitmapCache(CacheSize,
                    pRev1Caps->Cache3MaximumCellSize,
                    (void**)&_UH.bitmapCache[2].Entries, (void**)&_UH.bitmapCache[2].Header)) {
#endif
                // Alloc failure. No caches will be supported on the server.
                TRC_ERR((TB,_T("Failed alloc CacheID 2, rev1 caching disabled")));
                goto AllocErr;
            }
            pRev1Caps->Cache3Entries = (TSUINT16)(CacheSize /
                    UH_CellSizeFromCacheID(2));
            _UH.bitmapCache[2].BCInfo.NumEntries = pRev1Caps->Cache3Entries;
#ifdef DC_HICOLOR
            _UH.bitmapCache[2].BCInfo.OrigNumEntries = _UH.bitmapCache[2].BCInfo.NumEntries;
#endif
            TRC_NRM((TB,_T("Allocated rev1 buffers")));

            TRC_NRM((TB,_T("Allocated REV1 buffers OK\n")));
        }
        else {
            TRC_ALT((TB,_T("Need at least 3 configured caches for rev1 ")
                    _T("server, BC disabled")));
            goto ExitFunc;
        }
    }


#ifdef OS_WINCE //
    /************************************************************************/
    /* Create a cached memory DC and DIB for use by bitmap caching code.    */
    /* The memory DC can also be used for the StretchDIBits workaround in   */
    /* BitmapUpdatePDU handling.                                            */
    /************************************************************************/
    _UH.hdcMemCached = CreateCompatibleDC(NULL);
    if (_UH.hdcMemCached == NULL)
    {
        TRC_ERR((TB, _T("Unable to create memory hdc")));
        goto AllocErr;
    }

    // Use protocol-implied tile sizes scaled to the number of caches we have.
    _UH.bitmapInfo.hdr.biWidth = _UH.bitmapInfo.hdr.biHeight =
            (UH_CACHE_0_DIMENSION << (_UH.NumBitmapCaches - 1));

    _UH.hBitmapCacheDIB = CreateDIBSection(_UH.hdcMemCached,
                                         (BITMAPINFO *)&_UH.bitmapInfo.hdr,
#ifdef DC_HICOLOR
                                         _UH.DIBFormat,
#else
                                         DIB_PAL_COLORS,
#endif
                                         (VOID**)&_UH.hBitmapCacheDIBits,
                                         NULL,
                                         0);
    if (_UH.hBitmapCacheDIB == NULL)
    {
        TRC_ERR((TB, _T("Failed to create DIB, disabling bitmap caching: %d"),
                 GetLastError()));
        DeleteDC(_UH.hdcMemCached);
        _UH.hdcMemCached = NULL;
        goto AllocErr;
    }
#endif



ExitFunc:
    DC_END_FN();
    return;


// Error handling
AllocErr:
    // Since we failed to allocate everything we needed we therefore need to
    // free the memory to return resources to the client machine, then
    // disable bitmap caching from the server based on the cache version.
    for (i = 0; i < TS_BITMAPCACHE_MAX_CELL_CACHES; i++) {
        if (_UH.bitmapCache[i].Header != NULL) {
            UT_Free( _pUt, _UH.bitmapCache[i].Header);
            _UH.bitmapCache[i].Header = NULL;
        }
        if (_UH.bitmapCache[i].Entries != NULL) {
            UT_Free( _pUt, _UH.bitmapCache[i].Entries);
            _UH.bitmapCache[i].Entries = NULL;
        }

        _UH.NumBitmapCaches = 0;

        if (_UH.BitmapCacheVersion > TS_BITMAPCACHE_REV1) {
            TS_BITMAPCACHE_CAPABILITYSET_REV2 *pRev2Caps;

            pRev2Caps = (TS_BITMAPCACHE_CAPABILITYSET_REV2 *)
                    &_pCc->_ccCombinedCapabilities.bitmapCacheCaps;
            pRev2Caps->NumCellCaches = 0;
        }
        else {
            TS_BITMAPCACHE_CAPABILITYSET *pRev1Caps;

            // If any of the CacheNNumEntries values is zero a rev1 server
            // will disable caching.
            pRev1Caps = (TS_BITMAPCACHE_CAPABILITYSET *)
                    &_pCc->_ccCombinedCapabilities.bitmapCacheCaps;
            pRev1Caps->Cache1Entries = 0;
        }
    }
}

/****************************************************************************/
// UHReadBitmapCacheSettings
//
// Called at init time to preload the bitmap cache registry settings so we
// will not have to take the performance hit during connect.
/****************************************************************************/
VOID DCINTERNAL CUH::UHReadBitmapCacheSettings(VOID)
{
    unsigned i;

    DC_BEGIN_FN("UHReadBitmapCacheSettings");

    /************************************************************************/
    // Find out how much memory we can use for the cell caches.
    /************************************************************************/

    // Physical memory cache size.
    _UH.RegBitmapCacheSize = _pUi->_UI.RegBitmapCacheSize;

    if (_UH.RegBitmapCacheSize < UH_BMC_LOW_THRESHOLD) {
        // The total cache size is too low to be of any use - set to
        // the low threshold
        TRC_ALT((TB, _T("Bitmap cache size set to %#x. Must be at least %#x"),
                (unsigned)_UH.RegBitmapCacheSize, UH_BMC_LOW_THRESHOLD));
        _UH.RegBitmapCacheSize = UH_BMC_LOW_THRESHOLD;
    }

    TRC_NRM((TB, _T("%#x (%u) Kbytes configured for bitmap physical caches"),
            (unsigned)_UH.RegBitmapCacheSize,
            (unsigned)_UH.RegBitmapCacheSize));
    _UH.RegBitmapCacheSize *= 1024;  // Convert to bytes.

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

    // Virtual memory cache size
    // for each of the 3 copy multiplier settings
    //

    _UH.PropBitmapVirtualCacheSize[0] = 
        _pUi->_UI.RegBitmapVirtualCache8BppSize;
      // Convert to bytes.
    _UH.PropBitmapVirtualCacheSize[0] *= (UINT32)1024 * (UINT32)1024;

    _UH.PropBitmapVirtualCacheSize[1] = 
        _pUi->_UI.RegBitmapVirtualCache16BppSize;
      // Convert to bytes.
    _UH.PropBitmapVirtualCacheSize[1] *= (UINT32)1024 * (UINT32)1024;

    _UH.PropBitmapVirtualCacheSize[2] = 
        _pUi->_UI.RegBitmapVirtualCache24BppSize;
      // Convert to bytes.
    _UH.PropBitmapVirtualCacheSize[2] *= (UINT32)1024 * (UINT32)1024;


    if (UH_PropVirtualCacheSizeFromMult(_UH.copyMultiplier) <
        _UH.RegBitmapCacheSize) {
        // The total virtual cache size is too low - set to memory cache size.
        TRC_ALT((TB, _T("Bitmap virtual cache size set to %#x.  Must be at least %#x"),
                (unsigned)UH_PropVirtualCacheSizeFromMult(_UH.copyMultiplier),
                (unsigned)_UH.RegBitmapCacheSize));
        //
        // Be careful to correctly map to the array (-1 for 0 based)
        //
        _UH.PropBitmapVirtualCacheSize[_UH.copyMultiplier-1] = _UH.RegBitmapCacheSize;
    }

    TRC_NRM((TB, _T("%#x (%u) Mbytes configured for bitmap virtual caches"),
            (unsigned)UH_PropVirtualCacheSizeFromMult(_UH.copyMultiplier),
            (unsigned)UH_PropVirtualCacheSizeFromMult(_UH.copyMultiplier)));

    // Get the persistent disk cache location
    _pUt->UT_ReadRegistryString(UTREG_SECTION,
                                UTREG_UH_BM_PERSIST_CACHE_LOCATION,
                                _T(""),
                                _UH.PersistCacheFileName,
                                MAX_PATH - 1);
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

    // Get the high-color scaling flag for the caches. If this value is
    // nonzero, we scale the mem sizes specified for memory and persistent
    // caches by the bit depth of the protocol at connection time.
    _UH.RegScaleBitmapCachesByBPP = _pUi->_UI.RegScaleBitmapCachesByBPP;

    /************************************************************************/
    // Get the number of cell caches configured .
    /************************************************************************/
    _UH.RegNumBitmapCaches = (TSUINT8)_pUi->_UI.RegNumBitmapCaches;

    if (_UH.RegNumBitmapCaches > TS_BITMAPCACHE_MAX_CELL_CACHES)
        _UH.RegNumBitmapCaches = TS_BITMAPCACHE_MAX_CELL_CACHES;

    /************************************************************************/
    // Grab cell cache params: Proportion, persistence and MaxEntries.
    /************************************************************************/
    for (i = 0; i < _UH.RegNumBitmapCaches; i++)
    {
        _UH.RegBCProportion[i] = _pUi->_UI.RegBCProportion[i];
#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
        _UH.RegBCInfo[i].bSendBitmapKeys = _pUi->_UI.bSendBitmapKeys[i];
#endif
        _UH.RegBCMaxEntries[i] = _pUi->_UI.RegBCMaxEntries[i];
    }

    DC_END_FN();
}


#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))


#ifndef VM_BMPCACHE
/****************************************************************************/
// UHSavePersistentBitmap
//
// Disk write logic to write out a bitmap in the persistent cache.
// Returns FALSE on failure -- file was unseekable or a write error occurred.
// The bitmap is saved in compressed form.
/****************************************************************************/
BOOL DCINTERNAL CUH::UHSavePersistentBitmap(
        HANDLE                 hFile,
        UINT32                 fileOffset,
        PDCUINT8               pBitmapBits,
        UINT                   noBCHeader,
        PUHBITMAPINFO          pBitmapInfo)
{
    BOOL rc = FALSE;
    UHBITMAPFILEHDR fileHdr;

    DC_BEGIN_FN("UHSavePersistentBitmap");

    TRC_ASSERT((pBitmapBits != NULL), (TB, _T("Empty bitmap data")));
    TRC_ASSERT((pBitmapInfo != NULL), (TB, _T("Empty bitmap info")));
    TRC_ASSERT((hFile != INVALID_HANDLE_VALUE), (TB, _T("Invalid file handle")));

    TRC_NRM((TB, _T("Saving bitmap at offset: %x"), fileOffset));

    if (SetFilePointer( hFile, fileOffset, NULL, FILE_BEGIN) !=
        INVALID_SET_FILE_POINTER)
    {
        // fill in the file header information
        fileHdr.bmpInfo.Key1 = pBitmapInfo->Key1;
        fileHdr.bmpInfo.Key2 = pBitmapInfo->Key2;
        fileHdr.bmpInfo.bitmapWidth = pBitmapInfo->bitmapWidth;
        fileHdr.bmpInfo.bitmapHeight = pBitmapInfo->bitmapHeight;
        fileHdr.bmpInfo.bitmapLength = pBitmapInfo->bitmapLength;

        fileHdr.bmpVersion = TS_BITMAPCACHE_REV2;
        fileHdr.pad = 0;

        // bitmap data is compressed or not
#ifdef DC_HICOLOR
        if (pBitmapInfo->bitmapLength < (UINT32) (fileHdr.bmpInfo.bitmapWidth *
                fileHdr.bmpInfo.bitmapHeight * _UH.copyMultiplier)) {
#else
        if (pBitmapInfo->bitmapLength < (UINT32) (fileHdr.bmpInfo.bitmapWidth *
                fileHdr.bmpInfo.bitmapHeight)) {
#endif
            fileHdr.bCompressed = TRUE;
        }
        else {
            fileHdr.bCompressed = FALSE;
        }

        // bitmap data contains compression header or not
        if (noBCHeader) {
            fileHdr.bNoBCHeader = TRUE;
        }
        else {
            fileHdr.bNoBCHeader = FALSE;
        }

        
        DWORD cbWritten=0;
        if(WriteFile( hFile, &fileHdr, sizeof(fileHdr),
                      &cbWritten, NULL) && sizeof(fileHdr) == cbWritten)
        {
            if(WriteFile( hFile, pBitmapBits,
                          (UINT)fileHdr.bmpInfo.bitmapLength, &cbWritten,
                          NULL) &&
               ((DWORD)cbWritten == fileHdr.bmpInfo.bitmapLength))
            {
                TRC_NRM((TB, _T("Bitmap file is saved successfully")));
                rc = TRUE;
            }
            else
            {
                TRC_ERR((TB, _T("Failed to write bitmap file 0x%x"),GetLastError()));
            }
        }
        else
        {
            TRC_ERR((TB, _T("Failed to write bitmap file 0x%x"),GetLastError()));
        }
    }
    else {
        TRC_ERR((TB, _T("failed to save to file: x%x"),GetLastError()));
    }

    DC_END_FN();
    return rc;
}

/****************************************************************************/
// UHLoadPersistentCellBitmap
//
// Load the bitmap file on disk to memory cache entry
/****************************************************************************/
// SECURITY - caller must verify cacheId and cacheIndex
HRESULT DCINTERNAL CUH::UHLoadPersistentBitmap(
        HANDLE      hFile,
        UINT32      offset,
        UINT        cacheId,
        UINT32      cacheIndex,
        PUHBITMAPCACHEPTE pPTE)
{
     HRESULT hr = E_FAIL;
     PUHBITMAPCACHEENTRYHDR pHeader;
     BYTE FAR *pBitmapData;
     UHBITMAPFILEHDR fileHdr;
     DWORD cbRead = 0;

     DC_BEGIN_FN("UHLoadPersistentBitmap");

     TRC_ASSERT((hFile != INVALID_HANDLE_VALUE), (TB, _T("Invalid FILE handle")));
     TRC_ASSERT((cacheId < TS_BITMAPCACHE_MAX_CELL_CACHES),
             (TB, _T("Invalid cache ID %u"), cacheId));

     if (SetFilePointer( hFile, offset, NULL, FILE_BEGIN) !=
         INVALID_SET_FILE_POINTER)
     {
         // Read the bitmap contents into the cell cache
         pHeader = &_UH.bitmapCache[cacheId].Header[cacheIndex];
#ifdef DC_HICOLOR
         pBitmapData = _UH.bitmapCache[cacheId].Entries +
                       UHGetOffsetIntoCache(cacheIndex, cacheId);
#else
         pBitmapData = _UH.bitmapCache[cacheId].Entries + cacheIndex *
                 UH_CellSizeFromCacheID(cacheId);
#endif

         // Read the header and load the bitmap contents
#ifdef DC_HICOLOR
        if (ReadFile( hFile, &fileHdr, sizeof(fileHdr), &cbRead, NULL) &&
            sizeof(fileHdr) == cbRead &&
            fileHdr.bmpVersion == TS_BITMAPCACHE_REV2 &&
            fileHdr.bmpInfo.bitmapLength <= (unsigned)fileHdr.bmpInfo.bitmapHeight
                                            * fileHdr.bmpInfo.bitmapWidth
                                            * _UH.copyMultiplier &&
            fileHdr.bmpInfo.bitmapLength <= (unsigned)UH_CellSizeFromCacheID(cacheId) &&
            fileHdr.bmpInfo.Key1 == pPTE->bmpInfo.Key1 &&
            fileHdr.bmpInfo.Key2 == pPTE->bmpInfo.Key2)
#else
            if (ReadFile( hFile, &fileHdr, sizeof(fileHdr), &cbRead, NULL) &&
                sizeof(fileHdr) == cbRead &&
                 fileHdr.bmpVersion == TS_BITMAPCACHE_REV2 &&
                 fileHdr.bmpInfo.bitmapLength <= (unsigned)fileHdr.bmpInfo.bitmapHeight *
                 fileHdr.bmpInfo.bitmapWidth &&
                 fileHdr.bmpInfo.bitmapLength <= (unsigned)UH_CellSizeFromCacheID(cacheId) &&
                 fileHdr.bmpInfo.Key1 == pPTE->bmpInfo.Key1 &&
                 fileHdr.bmpInfo.Key2 == pPTE->bmpInfo.Key2)
#endif             
             {
             if (fileHdr.bCompressed == TRUE)
                 {
                 // Allocate bitmap decompression buffer if it's not already
                 // allocated
                 if (_UH.bitmapDecompressionBuffer == NULL) {
                    _UH.bitmapDecompressionBufferSize = max(
                             UH_DECOMPRESSION_BUFFER_LENGTH,
                             UH_CellSizeFromCacheID(_UH.NumBitmapCaches));
                     _UH.bitmapDecompressionBuffer = (PDCUINT8)UT_Malloc( _pUt, _UH.bitmapDecompressionBufferSize);
                     if (_UH.bitmapDecompressionBuffer == NULL) {
                         TRC_ERR((TB,_T("Failing to allocate decomp buffer")));
                         _UH.bitmapDecompressionBufferSize = 0;
                         DC_QUIT;
                     }
                 }
                 if (ReadFile( hFile, _UH.bitmapDecompressionBuffer,
                               (UINT)fileHdr.bmpInfo.bitmapLength, &cbRead, NULL) &&
                                (UINT) fileHdr.bmpInfo.bitmapLength == cbRead)
                 {
#ifdef DC_HICOLOR
                     hr = BD_DecompressBitmap(_UH.bitmapDecompressionBuffer,
                                         pBitmapData,
                                         (UINT) fileHdr.bmpInfo.bitmapLength,
                                         _UH.bitmapDecompressionBufferSize,
                                         (UINT) fileHdr.bNoBCHeader,
                                         (DCUINT8)_UH.protocolBpp,
                                         (DCUINT16)fileHdr.bmpInfo.bitmapWidth,
                                         (DCUINT16)fileHdr.bmpInfo.bitmapHeight);
#else
                     hr = BD_DecompressBitmap(_UH.bitmapDecompressionBuffer, 
                        pBitmapData,
                         (UINT) fileHdr.bmpInfo.bitmapLength,  
                         _UH.bitmapDecompressionBufferSize, 
                         (UINT) fileHdr.bNoBCHeader,
                         8, fileHdr.bmpInfo.bitmapWidth, 
                         fileHdr.bmpInfo.bitmapHeight);
#endif
                    DC_QUIT_ON_FAIL(hr);

                 }
                 else {
                     TRC_ERR((TB, _T("Error reading bitmap bits 0x%x"),GetLastError()));
                     DC_QUIT;
                 }
             }
             else {
                if (!(ReadFile( hFile, pBitmapData,
                               (UINT)fileHdr.bmpInfo.bitmapLength, &cbRead, NULL) &&
                               (UINT) fileHdr.bmpInfo.bitmapLength == cbRead))
                    {
                        TRC_ERR((TB, _T("Error reading bitmap bits 0x%x"),GetLastError()));
                        DC_QUIT;
                    }
             }

             pHeader->bitmapWidth = fileHdr.bmpInfo.bitmapWidth;
             pHeader->bitmapHeight = fileHdr.bmpInfo.bitmapHeight;
#ifdef DC_HICOLOR
             pHeader->bitmapLength = fileHdr.bmpInfo.bitmapWidth * fileHdr.bmpInfo.bitmapHeight
                                     * _UH.copyMultiplier;
#else
             pHeader->bitmapLength = fileHdr.bmpInfo.bitmapWidth * fileHdr.bmpInfo.bitmapHeight;
#endif
             pHeader->hasData = TRUE;

             TRC_NRM((TB, _T("Bitmap loaded: cache %u entry %u"), cacheId, cacheIndex));

             hr = S_OK;
         }
         else {
             TRC_ERR((TB, _T("Error reading bitmap file")));
         }
     }
     else {
         TRC_NRM((TB, _T("Bad bitmap file. Seek error 0x%x"),GetLastError()));
     }

DC_EXIT_POINT:
     DC_END_FN();
     return hr;
}
#else  //VM_BMPCACHE

/****************************************************************************/
// UHSavePersistentBitmap (VM Version)
//
// Disk write logic to write out a bitmap in the persistent cache.
// Returns FALSE on failure -- file was unseekable or a write error occurred.
// The bitmap is saved in compressed form.
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHSavePersistentBitmap(
        UINT                   cacheId,
        UINT32                 fileOffset,
        PDCUINT8               pBitmapBits,
        UINT                   noBCHeader,
        PUHBITMAPINFO          pBitmapInfo)
{
    HRESULT hr = E_FAIL;
    PUHBITMAPFILEHDR pFileHdr;
    LPBYTE pMappedView = NULL;
    LPBYTE pWritePtr = NULL;
    DWORD status = ERROR_SUCCESS;

    DC_BEGIN_FN("UHSavePersistentBitmap");

    TRC_ASSERT((cacheId < TS_BITMAPCACHE_MAX_CELL_CACHES),
            (TB, _T("Invalid cache ID %u"), cacheId));

    pMappedView = _UH.bitmapCache[cacheId].PageTable.CacheFileInfo.pMappedView;
    TRC_ASSERT(pMappedView,
               (TB, _T("Invalid mapped view for cacheId %d"), cacheId));

    TRC_ASSERT((pBitmapBits != NULL), (TB, _T("Empty bitmap data")));
    TRC_ASSERT((pBitmapInfo != NULL), (TB, _T("Empty bitmap info")));

    TRC_NRM((TB, _T("Saving bitmap at offset: %x"), fileOffset));
    pWritePtr = pMappedView + fileOffset;
    __try
    {
        pFileHdr = (PUHBITMAPFILEHDR)pWritePtr;

        // fill in the file header information
        pFileHdr->bmpInfo.Key1 = pBitmapInfo->Key1;
        pFileHdr->bmpInfo.Key2 = pBitmapInfo->Key2;
        pFileHdr->bmpInfo.bitmapWidth = pBitmapInfo->bitmapWidth;
        pFileHdr->bmpInfo.bitmapHeight = pBitmapInfo->bitmapHeight;
        pFileHdr->bmpInfo.bitmapLength = pBitmapInfo->bitmapLength;

        pFileHdr->bmpVersion = TS_BITMAPCACHE_REV2;
        pFileHdr->pad = 0;

        if (pBitmapInfo->bitmapLength < (UINT32) (pFileHdr->bmpInfo.bitmapWidth *
                pFileHdr->bmpInfo.bitmapHeight * _UH.copyMultiplier)) {
            pFileHdr->bCompressed = TRUE;
        }
        else {
            pFileHdr->bCompressed = FALSE;
        }

        // bitmap data contains compression header or not
        if (noBCHeader) {
            pFileHdr->bNoBCHeader = TRUE;
        }
        else {
            pFileHdr->bNoBCHeader = FALSE;
        }

        pWritePtr += sizeof(UHBITMAPFILEHDR);
        //
        // Write the actual bitmap bits
        //
        memcpy(pWritePtr, pBitmapBits,
               pFileHdr->bmpInfo.bitmapLength);
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
    }

    if (ERROR_SUCCESS == status && SUCCEEDED(hr))
    {
        return hr;
    }
    else
    {
        TRC_ERR((TB,
         _T("Failed to save file-0x%x hdr:%d status:%d"),
            status, hr));
        return hr;
    }

    DC_END_FN();
    return hr;
}

/****************************************************************************/
// UHLoadPersistentCellBitmap (VM version)
//
// Load the bitmap file on disk to memory cache entry
/****************************************************************************/
HRESULT DCINTERNAL CUH::UHLoadPersistentBitmap(
                                           HANDLE      hFile,
                                           UINT32      offset,
                                           UINT        cacheId,
                                           UINT32      cacheIndex,
                                           PUHBITMAPCACHEPTE pPTE)
{
    BOOL rc = FALSE;
    PUHBITMAPCACHEENTRYHDR pHeader;
    BYTE FAR *pBitmapData;
    PUHBITMAPFILEHDR pFileHdr = NULL;
    DWORD cbRead = 0;
    LPBYTE pMappedView = NULL;
    LPBYTE pReadPtr = NULL;
    DWORD status = ERROR_SUCCESS;
    BOOL  fFileHdrOK = FALSE;
    BOOL  fReadOK = FALSE;

    DC_BEGIN_FN("UHLoadPersistentBitmap");

    UNREFERENCED_PARAMETER(hFile);


    TRC_ASSERT((cacheId < TS_BITMAPCACHE_MAX_CELL_CACHES),
               (TB, _T("Invalid cache ID %u"), cacheId));

    pMappedView = _UH.bitmapCache[cacheId].PageTable.CacheFileInfo.pMappedView;
    TRC_ASSERT(pMappedView,
               (TB, _T("Invalid mapped view for cacheId %d"), cacheId));

    __try
    {
        pHeader = &_UH.bitmapCache[cacheId].Header[cacheIndex];
        pBitmapData = _UH.bitmapCache[cacheId].Entries +
                      UHGetOffsetIntoCache(cacheIndex, cacheId);

        // Read the header and load the bitmap contents
        pFileHdr = (PUHBITMAPFILEHDR)(pMappedView + offset);
        if (pFileHdr->bmpVersion == TS_BITMAPCACHE_REV2     &&
            pFileHdr->bmpInfo.bitmapLength <=
                (unsigned)pFileHdr->bmpInfo.bitmapHeight *
                pFileHdr->bmpInfo.bitmapWidth            *
                _UH.copyMultiplier                          &&
            pFileHdr->bmpInfo.bitmapLength <=
                (unsigned)UH_CellSizeFromCacheID(cacheId)   &&
            pFileHdr->bmpInfo.Key1 == pPTE->bmpInfo.Key1 &&
            pFileHdr->bmpInfo.Key2 == pPTE->bmpInfo.Key2)
        {
            fFileHdrOK = TRUE;

            //
            // Read the bitmap bits
            // In the compressed case we decompress directly within
            // the exception handler otherwise we make a copy so that we
            // don't need to wrap every possible access in try/except.
            //
            pReadPtr = (LPBYTE)(pFileHdr + 1);
            if (pFileHdr->bCompressed == TRUE)
            {
                // Allocate bitmap decompression buffer if it's not already
                // allocated
                hr = BD_DecompressBitmap(pReadPtr,
                                    pBitmapData,
                                    (UINT) pFileHdr->bmpInfo.bitmapLength,
                                    UH_CellSizeFromCacheID(cacheId),
                                    (UINT) pFileHdr->bNoBCHeader,
                                    (DCUINT8)_UH.protocolBpp,
                                    (DCUINT16)pFileHdr->bmpInfo.bitmapWidth,
                                    (DCUINT16)pFileHdr->bmpInfo.bitmapHeight);
                DC_QUIT_ON_FAIL(hr);
            }
            else
            {
                memcpy(pBitmapData,
                       pReadPtr,
                       pFileHdr->bmpInfo.bitmapLength);
            }

            pHeader->bitmapWidth  = pFileHdr->bmpInfo.bitmapWidth;
            pHeader->bitmapHeight = pFileHdr->bmpInfo.bitmapHeight;
            pHeader->bitmapLength = pFileHdr->bmpInfo.bitmapWidth *
                                    pFileHdr->bmpInfo.bitmapHeight *
                                    _UH.copyMultiplier;
            pHeader->hasData = TRUE;
            fReadOK = TRUE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
    }

    if (ERROR_SUCCESS == status && fReadOK)
    {
        return TRUE;
    }
    else
    {
        TRC_ERR((TB,
         _T("Header read from mapped file failed status-0x%x hdr:%d readok:%d"),
            status, fFileHdrOK, fReadOK));
        return FALSE;
    }

    DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


#endif //VM_BMPCACHE
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))


/****************************************************************************/
/* Name:      UHAllocOneGlyphCache                                          */
/*                                                                          */
/* Purpose:   Dynamically allocates memory for one UH glyph cache.          */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:    IN  maxMemToUse - max cache size which can be alloc'ed        */
/*            IN  pCache      - address of glyph cache struct               */
/****************************************************************************/
DCBOOL DCINTERNAL CUH::UHAllocOneGlyphCache(PUHGLYPHCACHE  pCache,
                                       DCUINT32       numEntries)
{
    DCBOOL   rc = FALSE;
    DCUINT32 dataSize;
    DCUINT32 hdrSize;

    DC_BEGIN_FN("UHAllocOneGlyphCache");

    TRC_ASSERT((pCache->cbEntrySize != 0),
               (TB, _T("Invalid cache entry size (0)")));

    /************************************************************************/
    /* Calculate the total byte size to allocate for this cache.            */
    /************************************************************************/
    dataSize = numEntries * pCache->cbEntrySize;

    /************************************************************************/
    /* Get the memory for the cache data                                    */
    /************************************************************************/
    pCache->pData = (PDCUINT8)UT_MallocHuge( _pUt, dataSize);

    if (pCache->pData == NULL)
    {
        /********************************************************************/
        /* Memory allocation failure.                                       */
        /********************************************************************/
        TRC_ERR((TB, _T("Failed to alloc %#lx bytes for glyph cache"), dataSize));
        DC_QUIT;
    }

    /************************************************************************/
    /* Get the memory for the cache headers                                 */
    /************************************************************************/
    hdrSize = (DCUINT32) numEntries * sizeof(pCache->pHdr[0]);

    pCache->pHdr = (PUHGLYPHCACHEENTRYHDR)UT_MallocHuge( _pUt, hdrSize);

    if (pCache->pHdr == NULL)
    {
        /********************************************************************/
        /* Memory allocation failure.                                       */
        /********************************************************************/
        TRC_ERR((TB, _T("Failed to alloc %#lx bytes for glyph cache hdrs"), hdrSize));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* Name:      UHAllocOneFragCache                                           */
/*                                                                          */
/* Purpose:   Dynamically allocates memory for one UH glyph cache.          */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise                           */
/*                                                                          */
/* Params:    IN  maxMemToUse - max cache size which can be alloc'ed        */
/*            IN  pCache      - address of glyph cache struct               */
/****************************************************************************/
DCBOOL DCINTERNAL CUH::UHAllocOneFragCache(PUHFRAGCACHE   pCache,
                                      DCUINT32       numEntries)
{
    DCBOOL   rc = FALSE;
    DCUINT32 dataSize;
    DCUINT32 hdrSize;

    DC_BEGIN_FN("UHAllocOneFragCache");

    TRC_ASSERT((pCache->cbEntrySize != 0),
               (TB, _T("Invalid cache entry size (0)")));

    /************************************************************************/
    /* Calculate the total byte size to allocate for this cache.            */
    /************************************************************************/
    dataSize = numEntries * pCache->cbEntrySize;

    /************************************************************************/
    /* Get the memory for the cache data                                    */
    /************************************************************************/
    pCache->pData = (PDCUINT8)UT_MallocHuge( _pUt, dataSize);

    if (pCache->pData == NULL)
    {
        /********************************************************************/
        /* Memory allocation failure.                                       */
        /********************************************************************/
        TRC_ERR((TB, _T("Failed to alloc %#lx bytes for frag cache"), dataSize));
        DC_QUIT;
    }

    /************************************************************************/
    /* Get the memory for the cache headers                                 */
    /************************************************************************/
    hdrSize = (DCUINT32) numEntries * sizeof(pCache->pHdr[0]);

    pCache->pHdr = (PUHFRAGCACHEENTRYHDR)UT_MallocHuge( _pUt, hdrSize);

    if (pCache->pHdr == NULL)
    {
        /********************************************************************/
        /* Memory allocation failure.                                       */
        /********************************************************************/
        TRC_ERR((TB, _T("Failed to alloc %#lx bytes for glyph cache hdrs"), hdrSize));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* Name:      UHAllocGlyphCacheMemory                                       */
/*                                                                          */
/* Purpose:   Dynamically allocates memory for the UH glyph caches.         */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise.                          */
/****************************************************************************/
DCBOOL DCINTERNAL CUH::UHAllocGlyphCacheMemory()
{
    DCINT   i;
    DCINT   j;
    DCBOOL  rc;
    DCINT   GlyphSupportLevel;
    DCINT   CellSize;
    DCUINT  CellEntries;

    DC_BEGIN_FN("UHAllocGlyphCacheMemory");

    rc = FALSE;

    /************************************************************************/
    /* Determine Glyph Support Level                                        */
    /************************************************************************/
    GlyphSupportLevel = _pUi->_UI.GlyphSupportLevel;

    if ((GlyphSupportLevel < 0) || (GlyphSupportLevel > 3))
        GlyphSupportLevel = UTREG_UH_GL_SUPPORT_DFLT;

    _pCc->_ccCombinedCapabilities.glyphCacheCapabilitySet.
                GlyphSupportLevel = (DCUINT16) GlyphSupportLevel;

    if (GlyphSupportLevel > 0)
    {
        /********************************************************************/
        /* Determine Glyph cache cell sizes                                 */
        /********************************************************************/
        for(i=0; i<UH_GLC_NUM_CACHES; i++)
        {
            _UH.glyphCache[i].cbEntrySize = _pUi->_UI.cbGlyphCacheEntrySize[i];
        }

        /************************************************************************/
        /* Allocate each of the glyph caches.                                   */
        /************************************************************************/
        for (i = 0; i<UH_GLC_NUM_CACHES; i++)
        {
            CellSize = (int)(_UH.glyphCache[i].cbEntrySize >> 1);

            if (CellSize > 0)
            {
                for (j = 0; CellSize > 0; j++)
                    CellSize >>= 1;

                CellSize = DC_MIN(1 << j, UH_GLC_CACHE_MAXIMUMCELLSIZE);
                CellEntries = (unsigned)((128L * 1024) / CellSize);
                CellEntries = DC_MIN(CellEntries, UH_GLC_CACHE_MAXIMUMCELLCOUNT);
                CellEntries = DC_MAX(CellEntries, UH_GLC_CACHE_MINIMUMCELLCOUNT);

                _UH.glyphCache[i].cbEntrySize = CellSize;

                if (UHAllocOneGlyphCache(&_UH.glyphCache[i], CellEntries))
                {
                    _pCc->_ccCombinedCapabilities.glyphCacheCapabilitySet.
                        GlyphCache[i].CacheEntries = (DCUINT16) CellEntries;

                    _pCc->_ccCombinedCapabilities.glyphCacheCapabilitySet.GlyphCache[i].
                        CacheMaximumCellSize = (DCUINT16) _UH.glyphCache[i].cbEntrySize;

                    rc = TRUE;
                }
#ifdef OS_WINCE
                else
                {
                    rc = FALSE;
                    break;
                }
#endif
            }
        }

        /************************************************************************/
        /* Allocate the fragment cache.                                         */
        /************************************************************************/
        if (rc == TRUE)
        {
            /********************************************************************/
            /* Determine fragment cell size                                     */
            /********************************************************************/
            CellSize = _pUi->_UI.fragCellSize;
            if (CellSize > 0)
            {
                _UH.fragCache.cbEntrySize =
                        DC_MIN(CellSize, UH_FGC_CACHE_MAXIMUMCELLSIZE);

                if (UHAllocOneFragCache(&_UH.fragCache, UH_FGC_CACHE_MAXIMUMCELLCOUNT))
                {
                    _pCc->_ccCombinedCapabilities.glyphCacheCapabilitySet.
                        FragCache.CacheEntries = UH_FGC_CACHE_MAXIMUMCELLCOUNT;

                    _pCc->_ccCombinedCapabilities.glyphCacheCapabilitySet.FragCache.
                        CacheMaximumCellSize = (DCUINT16) _UH.fragCache.cbEntrySize;
                }
#ifdef OS_WINCE
                else
                {
                    rc = FALSE;
                }
#endif
            }
        }
    }

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* Name:      UHAllocBrushCacheMemory                                       */
/*                                                                          */
/* Purpose:   Dynamically allocates memory for the UH brush caches.         */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise.                          */
/****************************************************************************/
DCBOOL DCINTERNAL CUH::UHAllocBrushCacheMemory()
{
    DCBOOL  rc;
    DCINT   brushSupportLevel;
    DCSIZE  bitmapSize;
#ifndef OS_WINCE
    HWND    hwndDesktop;
#endif
    HDC     hdcScreen;

    DC_BEGIN_FN("UHAllocBrushCacheMemory");

    rc = FALSE;

    /************************************************************************/
    /* Determine Brush Support Level                                        */
    /************************************************************************/
    brushSupportLevel = _pUi->_UI.brushSupportLevel;

    if ((brushSupportLevel < TS_BRUSH_DEFAULT) ||
        (brushSupportLevel > TS_BRUSH_COLOR_FULL))
        brushSupportLevel = UTREG_UH_BRUSH_SUPPORT_DFLT;

    _pCc->_ccCombinedCapabilities.brushCapabilitySet.brushSupportLevel =
                                                            brushSupportLevel;
    TRC_NRM((TB, _T("Read Brush support level %d"), brushSupportLevel));

    /**********************************************************************/
    /* Allocate the mono brush cache                                      */
    /**********************************************************************/
    _UH.pMonoBrush = (PUHMONOBRUSHCACHE)UT_Malloc( _pUt, sizeof(UHMONOBRUSHCACHE) * UH_MAX_MONO_BRUSHES);
    _UH.bmpMonoPattern = CreateBitmap(8,8,1,1,NULL);

    /**********************************************************************/
    /* Create a compatible bitmap for color brushes since we can't be sure*/
    /* how the actual pixel data is represented on each OS version.  The  */
    /* server always sends 8bpp brush data and SetDIBits() is used to     */
    /* convert to the native format.                                      */
    /**********************************************************************/
    _UH.pColorBrush = (PUHCOLORBRUSHCACHE)UT_Malloc( _pUt, sizeof(UHCOLORBRUSHCACHE) * UH_MAX_COLOR_BRUSHES);
    _UH.pColorBrushInfo = (PUHCOLORBRUSHINFO)UT_Malloc( _pUt, sizeof(UHCOLORBRUSHINFO));
#ifdef DC_HICOLOR
    _UH.pHiColorBrushInfo = (PUHHICOLORBRUSHINFO)UT_Malloc( _pUt, sizeof(UHHICOLORBRUSHINFO));
#endif

#ifdef DC_HICOLOR
    if (_UH.pColorBrushInfo && _UH.pHiColorBrushInfo)
    {
        // Set up the brush bitmap info header
        _UH.pColorBrushInfo->bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        _UH.pColorBrushInfo->bmi.bmiHeader.biWidth         = 8;
        _UH.pColorBrushInfo->bmi.bmiHeader.biHeight        = 8;
        _UH.pColorBrushInfo->bmi.bmiHeader.biPlanes        = 1;
        _UH.pColorBrushInfo->bmi.bmiHeader.biBitCount      = 8;
        _UH.pColorBrushInfo->bmi.bmiHeader.biCompression   = BI_RGB;
        _UH.pColorBrushInfo->bmi.bmiHeader.biSizeImage     = 0;
        _UH.pColorBrushInfo->bmi.bmiHeader.biXPelsPerMeter = 0;
        _UH.pColorBrushInfo->bmi.bmiHeader.biYPelsPerMeter = 0;
        _UH.pColorBrushInfo->bmi.bmiHeader.biClrUsed       = 0;
        _UH.pColorBrushInfo->bmi.bmiHeader.biClrImportant  = 0;

        // and copy it to the hicolor brush header
        memcpy(_UH.pHiColorBrushInfo,
               _UH.pColorBrushInfo,
               sizeof(BITMAPINFOHEADER));

        // Setup the bitmasks used at 16bpp
        *((PDCUINT32)&_UH.pHiColorBrushInfo->bmiColors[0]) =
                                                        TS_RED_MASK_16BPP;
        *((PDCUINT32)&_UH.pHiColorBrushInfo->bmiColors[1]) =
                                                        TS_GREEN_MASK_16BPP;
        *((PDCUINT32)&_UH.pHiColorBrushInfo->bmiColors[2]) =
                                                        TS_BLUE_MASK_16BPP;

        // Set up the other brush related resources
        bitmapSize.width = 8;
        bitmapSize.height = 8;
#ifndef OS_WINCE
        hwndDesktop = GetDesktopWindow();
        hdcScreen = GetWindowDC(hwndDesktop);
#else  // !OS_WINCE
        hdcScreen = GetDC(NULL);
#endif // !OS_WINCE
        if (hdcScreen) {
            _UH.bmpColorPattern = CreateCompatibleBitmap(hdcScreen, 8, 8);
            _UH.hdcBrushBitmap = CreateCompatibleDC(hdcScreen);
#ifndef OS_WINCE
            ReleaseDC(hwndDesktop, hdcScreen);
#else  // !OS_WINCE
            DeleteDC(hdcScreen);
#endif // !OS_WINCE
        }
    }
#else
    if (_UH.pColorBrushInfo) {
        _UH.pColorBrushInfo->bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        _UH.pColorBrushInfo->bmi.bmiHeader.biWidth         = 8;
        _UH.pColorBrushInfo->bmi.bmiHeader.biHeight        = 8;
        _UH.pColorBrushInfo->bmi.bmiHeader.biPlanes        = 1;
        _UH.pColorBrushInfo->bmi.bmiHeader.biBitCount      = 8;
        _UH.pColorBrushInfo->bmi.bmiHeader.biCompression   = BI_RGB;
        _UH.pColorBrushInfo->bmi.bmiHeader.biSizeImage     = 0;
        _UH.pColorBrushInfo->bmi.bmiHeader.biXPelsPerMeter = 0;
        _UH.pColorBrushInfo->bmi.bmiHeader.biYPelsPerMeter = 0;
        _UH.pColorBrushInfo->bmi.bmiHeader.biClrUsed       = 0;
        _UH.pColorBrushInfo->bmi.bmiHeader.biClrImportant  = 0;
        bitmapSize.width = 8;
        bitmapSize.height = 8;
#ifndef OS_WINCE
        hwndDesktop = GetDesktopWindow();
        hdcScreen = GetWindowDC(hwndDesktop);
#else  // !OS_WINCE
                hdcScreen = GetDC(NULL);
#endif // !OS_WINCE
        _UH.bmpColorPattern = CreateCompatibleBitmap(hdcScreen, 8, 8);
        _UH.hdcBrushBitmap = CreateCompatibleDC(hdcScreen);

#ifndef OS_WINCE
        ReleaseDC(hwndDesktop, hdcScreen);
#else  // !OS_WINCE
                DeleteDC(hdcScreen);
#endif // !OS_WINCE
    }

#endif

#ifdef DC_HICOLOR
    if (_UH.pMonoBrush &&
        _UH.pColorBrush && _UH.pColorBrushInfo && _UH.pHiColorBrushInfo &&
        _UH.bmpMonoPattern && _UH.bmpColorPattern)
#else
    if (_UH.pMonoBrush &&
        _UH.pColorBrush && _UH.pColorBrushInfo &&
        _UH.bmpMonoPattern && _UH.bmpColorPattern)
#endif
    {
        TRC_NRM((TB, _T("Brush support OK")));
        rc = TRUE;
    }
    else
    {
        TRC_NRM((TB, _T("Failure - Brush support level set to Default")));
        _pCc->_ccCombinedCapabilities.brushCapabilitySet.brushSupportLevel = TS_BRUSH_DEFAULT;

        if (_UH.pMonoBrush)
        {
            UT_Free( _pUt, _UH.pMonoBrush);
            _UH.pMonoBrush = NULL;
        }
        if (_UH.pColorBrushInfo)
        {
            UT_Free( _pUt, _UH.pColorBrushInfo);
            _UH.pColorBrushInfo = NULL;
        }
#ifdef DC_HICOLOR
        if (_UH.pHiColorBrushInfo)
        {
            UT_Free( _pUt, _UH.pHiColorBrushInfo);
            _UH.pHiColorBrushInfo = NULL;
        }
#endif
        if (_UH.pColorBrush)
        {
            UT_Free( _pUt, _UH.pColorBrush);
            _UH.pColorBrush = NULL;
        }
        if (_UH.bmpColorPattern)
        {
            DeleteObject(_UH.bmpColorPattern);
            _UH.bmpColorPattern = NULL;
        }
        DC_QUIT;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}

/****************************************************************************/
// Name:      UHAllocOffscreenCacheMemory                                       
//                                                                          
// Purpose:   Dynamically allocates memory for the UH offscreen caches.         
//                                                                          
// Returns:   TRUE if successful, FALSE otherwise.                          
/****************************************************************************/
DCBOOL DCINTERNAL CUH::UHAllocOffscreenCacheMemory()
{
    DCBOOL  rc;
    DCINT   offscrSupportLevel;    
    HDC     hdcDesktop;

    DC_BEGIN_FN("UHAllocOffscreenCacheMemory");

    rc = FALSE;

    /************************************************************************/
    // Determine Offscreen Support Level                                        
    /************************************************************************/
    offscrSupportLevel = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                            UTREG_UH_OFFSCREEN_SUPPORT,
                                            UTREG_UH_OFFSCREEN_SUPPORT_DFLT);

    _UH.offscrCacheSize = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH_OFFSCREEN_CACHESIZE,
                                         UTREG_UH_OFFSCREEN_CACHESIZE_DFLT *
                                         _UH.copyMultiplier);

    _UH.offscrCacheEntries = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH_OFFSCREEN_CACHEENTRIES,
                                         UTREG_UH_OFFSCREEN_CACHEENTRIES_DFLT);

    // Check boundary values for offscreen cache parameters
    if ((offscrSupportLevel < TS_OFFSCREEN_DEFAULT))
        offscrSupportLevel = UTREG_UH_OFFSCREEN_SUPPORT_DFLT;

    if (_UH.offscrCacheSize < UH_OBC_LOW_CACHESIZE || 
            _UH.offscrCacheSize > UH_OBC_HIGH_CACHESIZE) {
        _UH.offscrCacheSize = TS_OFFSCREEN_CACHE_SIZE_CLIENT_DEFAULT * _UH.copyMultiplier;
    }

    if (_UH.offscrCacheEntries < UH_OBC_LOW_CACHEENTRIES ||
            _UH.offscrCacheEntries > UH_OBC_HIGH_CACHEENTRIES) {
        _UH.offscrCacheEntries = TS_OFFSCREEN_CACHE_ENTRIES_DEFAULT;
    }

    if (offscrSupportLevel > TS_OFFSCREEN_DEFAULT) {

        // Create DC for the offscreen drawing
        hdcDesktop = GetWindowDC(HWND_DESKTOP);

        if (hdcDesktop) {
            _UH.hdcOffscreenBitmap = CreateCompatibleDC(hdcDesktop);
            
            if (_UH.hdcOffscreenBitmap) {
                unsigned size;

                SelectPalette(_UH.hdcOffscreenBitmap, _UH.hpalCurrent, FALSE);
                RealizePalette(_UH.hdcOffscreenBitmap);

                // Create offscreen cache 
                size = sizeof(UHOFFSCRBITMAPCACHE) * _UH.offscrCacheEntries;

                _UH.offscrBitmapCache = (HPUHOFFSCRBITMAPCACHE)UT_MallocHuge(_pUt, size);

                if (_UH.offscrBitmapCache != NULL) {
                    memset(_UH.offscrBitmapCache, 0, size); 
                    rc = TRUE;
                } else {
                    DeleteDC(_UH.hdcOffscreenBitmap);
                    _UH.hdcOffscreenBitmap = NULL;
                    offscrSupportLevel = TS_OFFSCREEN_DEFAULT;    
                }
            }
            else {
                offscrSupportLevel = TS_OFFSCREEN_DEFAULT;
            }

            ReleaseDC(HWND_DESKTOP, hdcDesktop);
        }
        else {
            offscrSupportLevel = TS_OFFSCREEN_DEFAULT;
        }
    }
    
    TRC_NRM((TB, _T("Read Offscreen support level %d"), offscrSupportLevel));

    if (offscrSupportLevel > TS_OFFSCREEN_DEFAULT) {
        _pCc->_ccCombinedCapabilities.offscreenCapabilitySet.offscreenSupportLevel =
                offscrSupportLevel;
        _pCc->_ccCombinedCapabilities.offscreenCapabilitySet.offscreenCacheSize =
                (DCUINT16) _UH.offscrCacheSize;
        _pCc->_ccCombinedCapabilities.offscreenCapabilitySet.offscreenCacheEntries =
                (DCUINT16) _UH.offscrCacheEntries;
    }
    else {
        _pCc->_ccCombinedCapabilities.offscreenCapabilitySet.offscreenSupportLevel =
                TS_OFFSCREEN_DEFAULT;
        _pCc->_ccCombinedCapabilities.offscreenCapabilitySet.offscreenCacheSize = 0;
        _pCc->_ccCombinedCapabilities.offscreenCapabilitySet.offscreenCacheEntries = 0;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return rc;
}

#ifdef DRAW_NINEGRID
/****************************************************************************/
// Name:      UHAllocDrawNineGridCacheMemory                                       
//                                                                          
// Purpose:   Dynamically allocates memory for the UH drawninegrid caches.         
//                                                                          
// Returns:   TRUE if successful, FALSE otherwise.                          
/****************************************************************************/
DCBOOL DCINTERNAL CUH::UHAllocDrawNineGridCacheMemory()
{
    DCBOOL  rc;
    DCINT   dngSupportLevel; 
    DCINT   dngEmulate;
    HDC     hdcDesktop = NULL;

    DC_BEGIN_FN("UHAllocDrawNineGridCacheMemory");

    rc = FALSE;

    /************************************************************************/
    // Determine DrawNineGrid Support Level                                        
    /************************************************************************/
    dngSupportLevel = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                            UTREG_UH_DRAW_NINEGRID_SUPPORT,
                                            UTREG_UH_DRAW_NINEGRID_SUPPORT_DFLT);
    
    dngEmulate = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                          UTREG_UH_DRAW_NINEGRID_EMULATE,
                                          UTREG_UH_DRAW_NINEGRID_EMULATE_DFLT);

    _UH.drawNineGridCacheSize = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH_DRAW_NINEGRID_CACHESIZE,
                                         UTREG_UH_DRAW_NINEGRID_CACHESIZE_DFLT);

    _UH.drawNineGridCacheEntries = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH_DRAW_NINEGRID_CACHEENTRIES,
                                         UTREG_UH_DRAW_NINEGRID_CACHEENTRIES_DFLT);

    // Check boundary values for drawninegrid cache parameters
    if ((dngSupportLevel < TS_DRAW_NINEGRID_DEFAULT))
        dngSupportLevel = UTREG_UH_DRAW_NINEGRID_SUPPORT_DFLT;

    if (_UH.drawNineGridCacheSize < UH_OBC_LOW_CACHESIZE || 
            _UH.drawNineGridCacheSize > UH_OBC_HIGH_CACHESIZE) {
        _UH.drawNineGridCacheSize = TS_DRAW_NINEGRID_CACHE_SIZE_DEFAULT;
    }

    if (_UH.drawNineGridCacheEntries < UH_OBC_LOW_CACHEENTRIES ||
            _UH.drawNineGridCacheEntries > UH_OBC_HIGH_CACHEENTRIES) {
        _UH.drawNineGridCacheEntries = TS_DRAW_NINEGRID_CACHE_ENTRIES_DEFAULT;
    }

    if (dngSupportLevel > TS_DRAW_NINEGRID_DEFAULT) {
        if (_pUi->UI_GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_NT) {
    
            if (dngEmulate == 0) {
                // get the handle to gdi32.dll library
                _UH.hModuleGDI32 = LoadLibrary(TEXT("GDI32.DLL"));
                    
                if (_UH.hModuleGDI32 != NULL) {
                    // get the proc address for GdiDrawStream
                    _UH.pfnGdiDrawStream = (FNGDI_DRAWSTREAM *)GetProcAddress(_UH.hModuleGDI32, 
                            "GdiDrawStream");
    
                    if (_UH.pfnGdiDrawStream == NULL) {
                        dngSupportLevel = TS_DRAW_NINEGRID_DEFAULT;
                    }
                }
                else {
                    dngSupportLevel = TS_DRAW_NINEGRID_DEFAULT;
                }
            }
            else {
                dngSupportLevel = TS_DRAW_NINEGRID_DEFAULT;
            }
            
            // If the platform doesn't support GdiDrawStream, see if it supports alphablend
            // and transparent blt, if so, we can emulate the GdiDrawStream call
            if (dngSupportLevel == TS_DRAW_NINEGRID_DEFAULT) {
                _UH.hModuleMSIMG32 = LoadLibrary(TEXT("MSIMG32.DLL"));

                if (_UH.hModuleMSIMG32 != NULL) {
                    // get the proc address for GdiAlphaBlend
                    _UH.pfnGdiAlphaBlend = (FNGDI_ALPHABLEND *)GetProcAddress(_UH.hModuleMSIMG32, 
                            "AlphaBlend");

                    // get the proc address for GdiTransparentBlt
                    _UH.pfnGdiTransparentBlt = (FNGDI_TRANSPARENTBLT *)GetProcAddress(_UH.hModuleMSIMG32, 
                            "TransparentBlt");
    
                    if (_UH.pfnGdiAlphaBlend != NULL && _UH.pfnGdiTransparentBlt != NULL) {
                        dngSupportLevel = TS_DRAW_NINEGRID_SUPPORTED_REV2;                       
                    }
                }
                else {
                    dngSupportLevel = TS_DRAW_NINEGRID_DEFAULT;
                }
            }
        } 
        else {
            // We don't support drawninegrid on win9x so far
            dngSupportLevel = TS_DRAW_NINEGRID_DEFAULT;
        }
    }

    if (dngSupportLevel > TS_DRAW_NINEGRID_DEFAULT) {

        // Create DC for the drawNineGrid drawing
        hdcDesktop = GetWindowDC(HWND_DESKTOP);

        if (hdcDesktop) {
            
            _UH.hdcDrawNineGridBitmap = CreateCompatibleDC(hdcDesktop);
            if (_UH.hdcDrawNineGridBitmap) {
                unsigned size;

                SelectPalette(_UH.hdcDrawNineGridBitmap, _UH.hpalCurrent, FALSE);
                RealizePalette(_UH.hdcDrawNineGridBitmap);

                _UH.hDrawNineGridClipRegion = CreateRectRgn(0, 0, 0, 0);

                if (_UH.hDrawNineGridClipRegion != NULL) {
                
                    // Create drawNineGrid cache 
                    size = sizeof(UHDRAWSTREAMBITMAPCACHE) * _UH.drawNineGridCacheEntries;
    
                    _UH.drawNineGridBitmapCache = (PUHDRAWSTREAMBITMAPCACHE)UT_Malloc(_pUt, size);
    
                    if (_UH.drawNineGridBitmapCache != NULL) {
                        memset(_UH.drawNineGridBitmapCache, 0, size); 
                        rc = TRUE;
                        DC_QUIT;                        
                    } 
                }
            }            
        }   
    }
    
    dngSupportLevel = TS_DRAW_NINEGRID_DEFAULT;

    if (_UH.hdcDrawNineGridBitmap != NULL) {
        DeleteDC(_UH.hdcDrawNineGridBitmap);
        _UH.hdcDrawNineGridBitmap = NULL;
    }

    if (_UH.hDrawNineGridClipRegion != NULL) {
        DeleteObject(_UH.hDrawNineGridClipRegion);
        _UH.hDrawNineGridClipRegion = NULL;
    }

    if (_UH.drawNineGridBitmapCache != NULL) {
        UT_Free(_pUt, _UH.drawNineGridBitmapCache);
        _UH.drawNineGridBitmapCache = NULL;
    }
   
DC_EXIT_POINT:
    
    TRC_NRM((TB, _T("Read draw nine grid support level %d"), dngSupportLevel));

    if (hdcDesktop != NULL) {
        ReleaseDC(HWND_DESKTOP, hdcDesktop);
    }

    if (dngSupportLevel > TS_DRAW_NINEGRID_DEFAULT) {
        _pCc->_ccCombinedCapabilities.drawNineGridCapabilitySet.drawNineGridSupportLevel =
                dngSupportLevel;
        _pCc->_ccCombinedCapabilities.drawNineGridCapabilitySet.drawNineGridCacheSize =
                (DCUINT16) _UH.drawNineGridCacheSize;
        _pCc->_ccCombinedCapabilities.drawNineGridCapabilitySet.drawNineGridCacheEntries =
                (DCUINT16) _UH.drawNineGridCacheEntries;
    }
    else {
        _pCc->_ccCombinedCapabilities.drawNineGridCapabilitySet.drawNineGridSupportLevel =
                TS_DRAW_NINEGRID_DEFAULT;
        _pCc->_ccCombinedCapabilities.drawNineGridCapabilitySet.drawNineGridCacheSize = 0;
        _pCc->_ccCombinedCapabilities.drawNineGridCapabilitySet.drawNineGridCacheEntries = 0;
    }


    DC_END_FN();
    return rc;
}
#endif


#ifdef DRAW_GDIPLUS
/****************************************************************************/
// Name:      UHAllocDrawescapeCacheMemory                                       
//                                                                          
// Purpose:   Dynamically allocates memory for the UH drawescape caches.         
//                                                                          
// Returns:   TRUE if successful, FALSE otherwise.                          
/****************************************************************************/
DCBOOL DCINTERNAL CUH::UHAllocDrawGdiplusCacheMemory()
{
    DCBOOL  rc;
    UINT GdipVersion;
    UINT32 GdiplusSupportLevel;
    unsigned size;
    unsigned i;

    DC_BEGIN_FN("UHAllocDrawEscapeCacheMemory");

    rc = FALSE;

    /************************************************************************/
    // Determine DrawGdiplus Support Level                                        
    /************************************************************************/
    GdiplusSupportLevel = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                        UTREG_UH_DRAW_GDIPLUS_SUPPORT,
                                        UTREG_UH_DRAW_GDIPLUS_SUPPORT_DFLT);

    _UH.GdiplusCacheLevel = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                        UTREG_UH_DRAW_GDIPLUS_CACHE_LEVEL,
                                        UTREG_UH_DRAW_GDIPLUS_CACHE_LEVEL_DFLT);
    
    _UH.GdiplusGraphicsCacheEntries = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH__GDIPLUS_GRAPHICS_CACHEENTRIES,
                                         UTREG_UH_DRAW_GDIP_GRAPHICS_CACHEENTRIES_DFLT);
    _UH.GdiplusObjectBrushCacheEntries = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH__GDIPLUS_BRUSH_CACHEENTRIES,
                                         UTREG_UH_DRAW_GDIP_BRUSH_CACHEENTRIES_DFLT);
    _UH.GdiplusObjectPenCacheEntries = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH__GDIPLUS_PEN_CACHEENTRIES,
                                         UTREG_UH_DRAW_GDIP_PEN_CACHEENTRIES_DFLT);
    _UH.GdiplusObjectImageCacheEntries = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH__GDIPLUS_IMAGE_CACHEENTRIES,
                                         UTREG_UH_DRAW_GDIP_IMAGE_CACHEENTRIES_DFLT);
    _UH.GdiplusGraphicsCacheChunkSize = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH__GDIPLUS_GRAPHICS_CACHE_CHUNKSIZE,
                                         UTREG_UH_DRAW_GDIP_GRAPHICS_CACHE_CHUNKSIZE_DFLT);
    _UH.GdiplusObjectBrushCacheChunkSize = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH__GDIPLUS_BRUSH_CACHE_CHUNKSIZE,
                                         UTREG_UH_DRAW_GDIP_BRUSH_CACHE_CHUNKSIZE_DFLT);
    _UH.GdiplusObjectPenCacheChunkSize = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH__GDIPLUS_PEN_CACHE_CHUNKSIZE,
                                         UTREG_UH_DRAW_GDIP_PEN_CACHE_CHUNKSIZE_DFLT);
    _UH.GdiplusObjectImageAttributesCacheChunkSize = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH__GDIPLUS_IMAGEATTRIBUTES_CACHE_CHUNKSIZE,
                                         UTREG_UH_DRAW_GDIP_IMAGEATTRIBUTES_CACHE_CHUNKSIZE_DFLT);
    _UH.GdiplusObjectImageCacheChunkSize = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH__GDIPLUS_IMAGE_CACHE_CHUNKSIZE,
                                         UTREG_UH_DRAW_GDIP_IMAGE_CACHE_CHUNKSIZE_DFLT);
    _UH.GdiplusObjectImageCacheTotalSize = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH__GDIPLUS_IMAGE_CACHE_TOTALSIZE,
                                         UTREG_UH_DRAW_GDIP_IMAGE_CACHE_TOTALSIZE_DFLT);
    _UH.GdiplusObjectImageCacheMaxSize = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH__GDIPLUS_IMAGE_CACHE_MAXSIZE,
                                         UTREG_UH_DRAW_GDIP_IMAGE_CACHE_MAXSIZE_DFLT);
    _UH.GdiplusObjectImageAttributesCacheEntries = _pUt->UT_ReadRegistryInt(UTREG_SECTION,
                                         UTREG_UH__GDIPLUS_IMAGEATTRIBUTES_CACHEENTRIES,
                                         UTREG_UH_DRAW_GDIP_IMAGEATTRIBUTES_CACHEENTRIES_DFLT);

    // Check boundary values for drawgdiplus cache parameters

    if (_UH.GdiplusGraphicsCacheEntries < UH_GDIP_LOW_CACHEENTRIES ||
            _UH.GdiplusGraphicsCacheEntries > UH_GDIP_HIGH_CACHEENTRIES) {
        _UH.GdiplusGraphicsCacheEntries = TS_GDIP_GRAPHICS_CACHE_ENTRIES_DEFAULT;
    }
    if (_UH.GdiplusObjectBrushCacheEntries < UH_GDIP_LOW_CACHEENTRIES ||
            _UH.GdiplusObjectBrushCacheEntries > UH_GDIP_HIGH_CACHEENTRIES) {
        _UH.GdiplusObjectBrushCacheEntries = TS_GDIP_BRUSH_CACHE_ENTRIES_DEFAULT;
    }
    if (_UH.GdiplusObjectPenCacheEntries < UH_GDIP_LOW_CACHEENTRIES ||
            _UH.GdiplusObjectPenCacheEntries > UH_GDIP_HIGH_CACHEENTRIES) {
        _UH.GdiplusObjectPenCacheEntries = TS_GDIP_PEN_CACHE_ENTRIES_DEFAULT;
    }
    if (_UH.GdiplusObjectImageCacheEntries < UH_GDIP_LOW_CACHEENTRIES ||
            _UH.GdiplusObjectImageCacheEntries > UH_GDIP_HIGH_CACHEENTRIES) {
        _UH.GdiplusObjectImageCacheEntries = TS_GDIP_IMAGE_CACHE_ENTRIES_DEFAULT;
    }
    if (_UH.GdiplusObjectImageAttributesCacheEntries < UH_GDIP_LOW_CACHEENTRIES ||
            _UH.GdiplusObjectImageAttributesCacheEntries > UH_GDIP_HIGH_CACHEENTRIES) {
        _UH.GdiplusObjectImageAttributesCacheEntries = TS_GDIP_IMAGEATTRIBUTES_CACHE_ENTRIES_DEFAULT;
    }

    _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusSupportLevel =
                TS_DRAW_GDIPLUS_DEFAULT;
    
    // Adjust the client gdiplus support level to server support level
    if (GdiplusSupportLevel > _UH.ServerGdiplusSupportLevel) {
        GdiplusSupportLevel = _UH.ServerGdiplusSupportLevel;
    }
    if (GdiplusSupportLevel < TS_DRAW_GDIPLUS_SUPPORTED) {
        DC_QUIT;
    }

    _UH.fSendDrawGdiplusErrorPDU = FALSE;
    _UH.DrawGdiplusFailureCount = 0;
    // get the handle to gdiplus.dll library
    // Here we use LoadLibrarayA is because we want to avoid unicode wrapper
    //  it will be replace with IsolationAwareLoadLibraryA so that we can load the right 
    //  version of gdiplus.dll
    _UH.hModuleGDIPlus = LoadLibraryA("GDIPLUS.DLL");
                    
    if (_UH.hModuleGDIPlus != NULL) {
        // get the proc address for GdipPlayTSClientRecord
        _UH.pfnGdipPlayTSClientRecord = (FNGDIPPLAYTSCLIENTRECORD *)GetProcAddress(_UH.hModuleGDIPlus, 
                            "GdipPlayTSClientRecord");
        _UH.pfnGdiplusStartup = (FNGDIPLUSSTARTUP *)GetProcAddress(_UH.hModuleGDIPlus, 
                            "GdiplusStartup");
        _UH.pfnGdiplusShutdown = (FNGDIPLUSSHUTDOWN *)GetProcAddress(_UH.hModuleGDIPlus, 
                            "GdiplusShutdown");
        if ((NULL == _UH.pfnGdipPlayTSClientRecord) ||
            (NULL == _UH.pfnGdiplusStartup) ||
            (NULL == _UH.pfnGdiplusShutdown)) {
            TRC_ERR((TB, _T("Can't load GdipPlayTSClientRecord")));
            DC_QUIT;
        }
        else {
            // Gdiplus Startup
            if (!UHDrawGdiplusStartup(0)){
                TRC_ERR((TB, _T("UHDrawGdiplusStartup failed")));
                DC_QUIT;
            }

            _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusSupportLevel =
                        TS_DRAW_GDIPLUS_SUPPORTED;
            _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.GdipCacheEntries.GdipGraphicsCacheEntries = 
                (TSINT16)_UH.GdiplusGraphicsCacheEntries;
            _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.GdipCacheEntries.GdipObjectBrushCacheEntries = 
                (TSINT16)_UH.GdiplusObjectBrushCacheEntries;
            _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.GdipCacheEntries.GdipObjectPenCacheEntries = 
                (TSINT16)_UH.GdiplusObjectPenCacheEntries;
            _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.GdipCacheEntries.GdipObjectImageCacheEntries = 
                (TSINT16)_UH.GdiplusObjectImageCacheEntries;
            _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.GdipCacheEntries.GdipObjectImageAttributesCacheEntries = 
                (TSINT16)_UH.GdiplusObjectImageAttributesCacheEntries;

            _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.GdipCacheChunkSize.GdipGraphicsCacheChunkSize = 
                (TSINT16)_UH.GdiplusGraphicsCacheChunkSize;
            _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.GdipCacheChunkSize.GdipObjectBrushCacheChunkSize = 
                (TSINT16)_UH.GdiplusObjectBrushCacheChunkSize;
            _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.GdipCacheChunkSize.GdipObjectPenCacheChunkSize = 
                (TSINT16)_UH.GdiplusObjectPenCacheChunkSize;
            _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.GdipCacheChunkSize.GdipObjectImageAttributesCacheChunkSize = 
                (TSINT16)_UH.GdiplusObjectImageAttributesCacheChunkSize;
            _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.GdipImageCacheProperties.GdipObjectImageCacheChunkSize = 
                (TSINT16)_UH.GdiplusObjectImageCacheChunkSize;
            _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.GdipImageCacheProperties.GdipObjectImageCacheTotalSize = 
                (TSINT16)_UH.GdiplusObjectImageCacheTotalSize;
            _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.GdipImageCacheProperties.GdipObjectImageCacheMaxSize = 
                (TSINT16)_UH.GdiplusObjectImageCacheMaxSize;
        }
    }
    else   {
        TRC_ERR((TB, _T("Can't load gdiplus.dll")));
        DC_QUIT;
    }
    if (_UH.GdiplusCacheLevel < TS_DRAW_GDIPLUS_CACHE_LEVEL_ONE) {
        TRC_NRM((TB, _T("Don't support drawGdiplus Cache")));
        _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusCacheLevel = 
            TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;       
        goto NO_CACHE;
    }

    size = sizeof(UHGDIPLUSOBJECTCACHE) * _UH.GdiplusGraphicsCacheEntries;   
    _UH.GdiplusGraphicsCache = (PUHGDIPLUSOBJECTCACHE)UT_Malloc(_pUt, size);
    if (_UH.GdiplusGraphicsCache != NULL) {
        memset(_UH.GdiplusGraphicsCache, 0, size); 
    } 
    else {
        TRC_ERR((TB, _T("Can't allocate memory for gdiplus cache")));
        _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusCacheLevel = 
            TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;       
        goto NO_CACHE;
    }

    size = sizeof(UHGDIPLUSOBJECTCACHE) * _UH.GdiplusObjectBrushCacheEntries;   
    _UH.GdiplusObjectBrushCache = (PUHGDIPLUSOBJECTCACHE)UT_Malloc(_pUt, size);
    if (_UH.GdiplusObjectBrushCache != NULL) {
        memset(_UH.GdiplusObjectBrushCache, 0, size); 
    } 
    else {
        TRC_ERR((TB, _T("Can't allocate memory for gdiplus cache")));
        _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusCacheLevel = 
            TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;       
        goto NO_CACHE;
    }

    size = sizeof(UHGDIPLUSOBJECTCACHE) * _UH.GdiplusObjectPenCacheEntries;   
    _UH.GdiplusObjectPenCache = (PUHGDIPLUSOBJECTCACHE)UT_Malloc(_pUt, size);
    if (_UH.GdiplusObjectPenCache != NULL) {
        memset(_UH.GdiplusObjectPenCache, 0, size); 
    }
    else {
        TRC_ERR((TB, _T("Can't allocate memory for gdiplus cache")));
        _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusCacheLevel = 
            TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;       
        goto NO_CACHE;
    }

    size = sizeof(UHGDIPLUSOBJECTCACHE) * _UH.GdiplusObjectImageAttributesCacheEntries;   
    _UH.GdiplusObjectImageAttributesCache = (PUHGDIPLUSOBJECTCACHE)UT_Malloc(_pUt, size);
    if (_UH.GdiplusObjectImageAttributesCache != NULL) {
        memset(_UH.GdiplusObjectImageAttributesCache, 0, size);
    }
    else {
        TRC_ERR((TB, _T("Can't allocate memory for gdiplus cache")));
        _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusCacheLevel = 
            TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;       
        goto NO_CACHE;
    }

    size = sizeof(UHGDIPLUSIMAGECACHE) * _UH.GdiplusObjectImageCacheEntries;   
    _UH.GdiplusObjectImageCache = (PUHGDIPLUSIMAGECACHE)UT_Malloc(_pUt, size);
    if (_UH.GdiplusObjectImageCache != NULL) {
        memset(_UH.GdiplusObjectImageCache, 0, size); 
    }
    else {
        TRC_ERR((TB, _T("Can't allocate memory for gdiplus cache")));
        _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusCacheLevel = 
            TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;       
        goto NO_CACHE;
    }

    size = _UH.GdiplusGraphicsCacheChunkSize * _UH.GdiplusGraphicsCacheEntries;   
    _UH.GdipGraphicsCacheData = (BYTE *)UT_Malloc(_pUt, size);
    if (_UH.GdipGraphicsCacheData != NULL) {
        memset(_UH.GdipGraphicsCacheData, 0, size); 
    }
    else {
        TRC_ERR((TB, _T("Can't allocate memory for gdiplus cache")));
        _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusCacheLevel = 
            TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;       
        goto NO_CACHE;
    }
    for (i=0; i<_UH.GdiplusGraphicsCacheEntries; i++) {
        _UH.GdiplusGraphicsCache[i].CacheData = _UH.GdipGraphicsCacheData + i * _UH.GdiplusGraphicsCacheChunkSize;
    }

    size = _UH.GdiplusObjectBrushCacheChunkSize * _UH.GdiplusObjectBrushCacheEntries;   
    _UH.GdipBrushCacheData = (BYTE *)UT_Malloc(_pUt, size);
    if (_UH.GdipBrushCacheData != NULL) {
        memset(_UH.GdipBrushCacheData, 0, size); 
    }
    else {
        TRC_ERR((TB, _T("Can't allocate memory for gdiplus cache")));
        _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusCacheLevel = 
            TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;       
        goto NO_CACHE;
    }
    for (i=0; i<_UH.GdiplusObjectBrushCacheEntries; i++) {
        _UH.GdiplusObjectBrushCache[i].CacheData = _UH.GdipBrushCacheData + i * _UH.GdiplusObjectBrushCacheChunkSize;
    }

    size = _UH.GdiplusObjectPenCacheChunkSize * _UH.GdiplusObjectPenCacheEntries;   
    _UH.GdipPenCacheData = (BYTE *)UT_Malloc(_pUt, size);
    if (_UH.GdipPenCacheData != NULL) {
        memset(_UH.GdipPenCacheData, 0, size); 
    }
    else {
        TRC_ERR((TB, _T("Can't allocate memory for gdiplus cache")));
        _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusCacheLevel = 
            TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;       
        goto NO_CACHE;
    }
    for (i=0; i<_UH.GdiplusObjectPenCacheEntries; i++) {
        _UH.GdiplusObjectPenCache[i].CacheData = _UH.GdipPenCacheData + i * _UH.GdiplusObjectPenCacheChunkSize;
    }

    size = _UH.GdiplusObjectImageAttributesCacheChunkSize * _UH.GdiplusObjectImageAttributesCacheEntries;   
    _UH.GdipImageAttributesCacheData = (BYTE *)UT_Malloc(_pUt, size);
    if (_UH.GdipImageAttributesCacheData != NULL) {
        memset(_UH.GdipImageAttributesCacheData, 0, size); 
    }
    else {
        TRC_ERR((TB, _T("Can't allocate memory for gdiplus cache")));
        _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusCacheLevel = 
            TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;       
        goto NO_CACHE;
    }
    for (i=0; i<_UH.GdiplusObjectImageAttributesCacheEntries; i++) {
        _UH.GdiplusObjectImageAttributesCache[i].CacheData = _UH.GdipImageAttributesCacheData + i * _UH.GdiplusObjectImageAttributesCacheChunkSize;
    }

    size = _UH.GdiplusObjectImageCacheChunkSize * _UH.GdiplusObjectImageCacheTotalSize;   
    _UH.GdipImageCacheData = (BYTE *)UT_Malloc(_pUt, size);
    if (_UH.GdipImageCacheData != NULL) {
        memset(_UH.GdipImageCacheData, 0, size); 
    }
    else {
        TRC_ERR((TB, _T("Can't allocate memory for gdiplus cache")));
        _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusCacheLevel = 
            TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;       
        goto NO_CACHE;
    }

    size = sizeof(INT16) * _UH.GdiplusObjectImageCacheTotalSize;   
    _UH.GdipImageCacheFreeList = (INT16 *)UT_Malloc(_pUt, size);
    if (_UH.GdipImageCacheFreeList != NULL) {
        memset(_UH.GdipImageCacheFreeList, GDIP_CACHE_INDEX_DEFAULT, size);
    }
    else {
        TRC_ERR((TB, _T("Can't allocate memory for gdiplus cache")));
        _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusCacheLevel = 
            TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;       
        goto NO_CACHE;
    }

    size = sizeof(INT16) * _UH.GdiplusGraphicsCacheEntries * _UH.GdiplusObjectImageCacheMaxSize;   
    _UH.GdipImageCacheIndex = (INT16 *)UT_Malloc(_pUt, size);
    if (_UH.GdipImageCacheIndex != NULL) {
        memset(_UH.GdipImageCacheIndex, GDIP_CACHE_INDEX_DEFAULT, size); 
    }
    else {
        TRC_ERR((TB, _T("Can't allocate memory for gdiplus cache")));
        _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusCacheLevel = 
            TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;       
        goto NO_CACHE;
    }

    for (i=0; i<_UH.GdiplusObjectImageCacheEntries; i++) {
        _UH.GdiplusObjectImageCache[i].CacheDataIndex = (_UH.GdipImageCacheIndex + i * (TSINT16)_UH.GdiplusObjectImageCacheMaxSize);
    }
    for (i=0; i<_UH.GdiplusObjectImageCacheTotalSize - 1; i++) {
        _UH.GdipImageCacheFreeList[i] = i + 1;
    }
    _UH.GdipImageCacheFreeList[_UH.GdiplusObjectImageCacheTotalSize - 1] = GDIP_CACHE_INDEX_DEFAULT;
    _UH.GdipImageCacheFreeListHead = 0;
    _pCc->_ccCombinedCapabilities.drawGdiplusCapabilitySet.drawGdiplusCacheLevel = 
            TS_DRAW_GDIPLUS_CACHE_LEVEL_ONE;

NO_CACHE:
    rc = TRUE;
    return rc;
DC_EXIT_POINT:
    if (_UH.hModuleGDIPlus != NULL) {
        FreeLibrary(_UH.hModuleGDIPlus);
        _UH.pfnGdipPlayTSClientRecord = NULL;
        _UH.hModuleGDIPlus = NULL;
    }
    DC_END_FN();
    return rc;
}
#endif // DRAW_GDIPLUS

/****************************************************************************/
/* Name:      UHFreeCacheMemory                                             */
/*                                                                          */
/* Purpose:   Frees memory allocated for the UH caches. Called at app exit. */
/****************************************************************************/
void DCINTERNAL CUH::UHFreeCacheMemory()
{
    DCUINT i;

    DC_BEGIN_FN("UHFreeCacheMemory");

    // Color table cache
    if (_UH.pColorTableCache != NULL) {
        UT_Free(_pUt, _UH.pColorTableCache);
    }

    if (_UH.pMappedColorTableCache != NULL) {
        UT_Free(_pUt, _UH.pMappedColorTableCache);
    }

    // Bitmap cache. These should already have been freed in UH_Disable(),
    // but check again here on exit.
    for (i = 0; i < TS_BITMAPCACHE_MAX_CELL_CACHES; i++)
    {
        if (_UH.bitmapCache[i].Header != NULL) {
            UT_Free( _pUt, _UH.bitmapCache[i].Header);
            _UH.bitmapCache[i].Header = NULL;
        }
        if (_UH.bitmapCache[i].Entries != NULL) {
            UT_Free( _pUt, _UH.bitmapCache[i].Entries);
            _UH.bitmapCache[i].Entries = NULL;
        }

#if ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))
        // free the bitmap page table
        if (_UH.bitmapCache[i].PageTable.PageEntries != NULL) {
            UT_Free( _pUt, _UH.bitmapCache[i].PageTable.PageEntries);
            _UH.bitmapCache[i].PageTable.PageEntries = NULL;
        }

        // free the bitmap key database
        if (_UH.pBitmapKeyDB[i] != NULL) {
            UT_Free( _pUt, _UH.pBitmapKeyDB[i]);
            _UH.pBitmapKeyDB[i] = NULL;
        }
#endif // ((!defined(OS_WINCE)) || (defined(ENABLE_BMP_CACHING_FOR_WINCE)))

    }
    _UH.NumBitmapCaches = 0;

    // Glyph cache
    for (i = 0; i < UH_GLC_NUM_CACHES; i++) {
        if (_UH.glyphCache[i].pHdr != NULL) {
            UT_Free( _pUt, _UH.glyphCache[i].pHdr);
            _UH.glyphCache[i].pHdr = NULL;
        }

        if (_UH.glyphCache[i].pData != NULL) {
            UT_Free( _pUt, _UH.glyphCache[i].pData);
            _UH.glyphCache[i].pData = NULL;
        }
    }

    // Frag cache
    if (_UH.fragCache.pHdr != NULL) {
        UT_Free( _pUt, _UH.fragCache.pHdr);
        _UH.fragCache.pHdr = NULL;
    }
    if (_UH.fragCache.pData != NULL) {
        UT_Free( _pUt, _UH.fragCache.pData);
        _UH.fragCache.pData = NULL;
    }

    // Brush caches and bitmap patterns
    if (_UH.pMonoBrush)
    {
        UT_Free( _pUt, _UH.pMonoBrush);
        _UH.pMonoBrush = NULL;
    }
    if (_UH.bmpMonoPattern) {
        DeleteObject(_UH.bmpMonoPattern);
        _UH.bmpMonoPattern = NULL;
    }
    if (_UH.pColorBrushInfo)
    {
        UT_Free( _pUt, _UH.pColorBrushInfo);
        _UH.pColorBrushInfo = NULL;
    }
#ifdef DC_HICOLOR
    if (_UH.pHiColorBrushInfo)
    {
        UT_Free( _pUt, _UH.pHiColorBrushInfo);
        _UH.pHiColorBrushInfo = NULL;
    }
#endif
    if (_UH.pColorBrush)
    {
        UT_Free( _pUt, _UH.pColorBrush);
        _UH.pColorBrush = NULL;
    }
    if (_UH.bmpColorPattern)
    {
        DeleteObject(_UH.bmpColorPattern);
        _UH.bmpColorPattern = NULL;
    }

#ifdef OS_WINCE //
    if (_UH.hdcMemCached != NULL)
        DeleteDC(_UH.hdcMemCached);

    if (_UH.hBitmapCacheDIB != NULL)
    {
        DeleteBitmap(_UH.hBitmapCacheDIB);
        _UH.hBitmapCacheDIBits = NULL;
    }
#endif
    
    // Offscreen Cache
    if (_UH.offscrBitmapCache != NULL) {

        UT_Free(_pUt, _UH.offscrBitmapCache);
    }

#ifdef DRAW_NINEGRID
    // DrawNineGrid Cache
    if (_UH.drawNineGridBitmapCache != NULL) {

        UT_Free(_pUt, _UH.drawNineGridBitmapCache);
    }
#endif

#ifdef DRAW_GDIPLUS
    // DrawGdiplus Cache Index
    if (_UH.GdiplusGraphicsCache != NULL) {

        UT_Free(_pUt, _UH.GdiplusGraphicsCache);
    }
    if (_UH.GdiplusObjectBrushCache != NULL) {

        UT_Free(_pUt, _UH.GdiplusObjectBrushCache);
    }
    if (_UH.GdiplusObjectPenCache != NULL) {

        UT_Free(_pUt, _UH.GdiplusObjectPenCache);
    }
    if (_UH.GdiplusObjectImageCache != NULL) {

        UT_Free(_pUt, _UH.GdiplusObjectImageCache);
    }
    if (_UH.GdiplusObjectImageAttributesCache != NULL) {

        UT_Free(_pUt, _UH.GdiplusObjectImageAttributesCache);
    }
    // DrawGdiplus Cache Data
    if (_UH.GdipGraphicsCacheData != NULL) {

        UT_Free(_pUt, _UH.GdipGraphicsCacheData);
    }
    if (_UH.GdipBrushCacheData != NULL) {

        UT_Free(_pUt, _UH.GdipBrushCacheData);
    }
    if (_UH.GdipPenCacheData != NULL) {

        UT_Free(_pUt, _UH.GdipPenCacheData);
    }
    if (_UH.GdipImageAttributesCacheData != NULL) {

        UT_Free(_pUt, _UH.GdipImageAttributesCacheData);
    }
    // DrawGdiplus Image Cache Free Chunk List
    if (_UH.GdipImageCacheFreeList != NULL) {

        UT_Free(_pUt, _UH.GdipImageCacheFreeList);
    }
    if (_UH.GdipImageCacheIndex != NULL) {

        UT_Free(_pUt, _UH.GdipImageCacheIndex);
    }
    if (_UH.GdipImageCacheData != NULL) {

        UT_Free(_pUt, _UH.GdipImageCacheData);
    }
#endif // DRAW_GDIPLUS

    DC_END_FN();
}

/****************************************************************************/
/* Name:      UHCreateBitmap                                                */
/*                                                                          */
/* Purpose:   Creates a bitmap of the specified size and selects it into    */
/*            the specified device context.                                 */
/*                                                                          */
/* Returns:   TRUE if successful, FALSE otherwise.                          */
/*                                                                          */
/* Params:       OUT  phBitmap       -  handle to new bitmap                */
/*               OUT  phdcBitmap     -  new DC handle                       */
/*               OUT  phUnusedBitmap -  handle of DC's previous bitmap      */
/*            IN      bitmapSize     -  requested bitmap size               */
/*        IN OPTIONAL nForceBmpBpp   -  forces bpp to specific value        */
/*                                                                          */
/****************************************************************************/
DCBOOL DCINTERNAL CUH::UHCreateBitmap(
        HBITMAP *phBitmap,
        HDC *phdcBitmap,
        HBITMAP *phUnusedBitmap,
        DCSIZE bitmapSize,
        INT nForceBmpBpp)
{
    HDC hdcDesktop = NULL;
    BOOL rc = TRUE;
#ifdef USE_DIBSECTION
    unsigned size;
    UINT16 FAR *pColors;
    unsigned i;
    LPBITMAPINFO pbmi = NULL;
    PVOID      pBitmapBits;
#endif /* USE_DIBSECTION */

    DC_BEGIN_FN("UHCreateBitmap");

    TRC_ASSERT((NULL == *phBitmap),
               (TB, _T("phBitmap non-NULL: %p"), *phBitmap));

    TRC_ASSERT(NULL == (*phdcBitmap),
               (TB, _T("phdcBitmap non-NULL: %p"), *phdcBitmap));

    TRC_ASSERT((NULL == *phUnusedBitmap),
               (TB, _T("phUnusedBitmap non-NULL: %p"), *phUnusedBitmap));

    TRC_NRM((TB, _T("Bitmap size: (%u x %u)"), bitmapSize.width,
                                           bitmapSize.height));

    hdcDesktop = GetWindowDC(HWND_DESKTOP);

    // Create the bitmap DC.
    TRC_DBG((TB, _T("Create the bitmap DC")));
    *phdcBitmap = CreateCompatibleDC(hdcDesktop);
    if (NULL == *phdcBitmap)
    {
        TRC_ERR((TB, _T("Failed to create phdcBitmap")));
        rc = FALSE;
        DC_QUIT;
    }

#ifdef USE_DIBSECTION
    /************************************************************************/
    /* Don't use DibSection on 4bpp displays - it slows down the Win32      */
    /* Client something rotten.                                             */
    /************************************************************************/
    if (_pUi->UI_GetColorDepth() != 4)
    {
        /********************************************************************/
        /* Calcuate the amount of memory that we need to allocate.  This is */
        /* the size of the bitmap header plus a color table.                */
        /********************************************************************/
        size = sizeof(BITMAPINFOHEADER) +
                                 (UH_NUM_8BPP_PAL_ENTRIES * sizeof(DCUINT16));

        /********************************************************************/
        /* Now allocate the memory.                                         */
        /********************************************************************/
        pbmi = (LPBITMAPINFO) UT_Malloc( _pUt, size);
        if (NULL == pbmi)
        {
            TRC_ERR((TB, _T("Failed to allocate %u bytes for bitmapinfo"), size));
            DC_QUIT;
        }

        /********************************************************************/
        /* Now fill-in the bitmap info header.                              */
        /*                                                                  */
        /* Use a negative value for the height to create a "top-down"       */
        /* bitmap.  This makes little (no) difference for the current code, */
        /* but will make things easier in future if we access the shadow    */
        /* DibSection bits directly.                                        */
        /********************************************************************/
        pbmi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth         = (int)bitmapSize.width;
        pbmi->bmiHeader.biHeight        = -(int)bitmapSize.height;

        pbmi->bmiHeader.biPlanes        = 1;
#ifdef DC_HICOLOR
#ifdef USE_GDIPLUS
        pbmi->bmiHeader.biBitCount      = 32;
#else // USE_GDIPLUS
        if (!nForceBmpBpp) {
            pbmi->bmiHeader.biBitCount      = (WORD)_UH.bitmapBpp;
        }
        else {
            pbmi->bmiHeader.biBitCount      = (WORD)nForceBmpBpp;
        }
        
#endif // USE_GDIPLUS
#else
        pbmi->bmiHeader.biBitCount      = 8;
#endif
        pbmi->bmiHeader.biCompression   = BI_RGB;
        pbmi->bmiHeader.biSizeImage     = 0;
        pbmi->bmiHeader.biXPelsPerMeter = 0;
        pbmi->bmiHeader.biYPelsPerMeter = 0;
        pbmi->bmiHeader.biClrUsed       = 0;
        pbmi->bmiHeader.biClrImportant  = 0;

        if (!nForceBmpBpp) {
#ifndef USE_GDIPLUS
#ifdef DC_HICOLOR
        /********************************************************************/
        /* Do color depth-specific setup                                    */
        /********************************************************************/
        if (_UH.protocolBpp == 16)
        {
            /****************************************************************/
            /* 16 bpp uses two bytes, with the color masks defined in the   */
            /* bmiColors field in the order R, G, B.  We use                */
            /* - LS   5 bits = blue       = 0x001f                          */
            /* - next 6 bits = green mask = 0x07e0                          */
            /* - next 5 bits = red mask   = 0xf800                          */
            /****************************************************************/
            pbmi->bmiHeader.biCompression = BI_BITFIELDS;
            pbmi->bmiHeader.biClrUsed     = 3;

            *((PDCUINT32)&pbmi->bmiColors[0]) = TS_RED_MASK_16BPP;
            *((PDCUINT32)&pbmi->bmiColors[1]) = TS_GREEN_MASK_16BPP;
            *((PDCUINT32)&pbmi->bmiColors[2]) = TS_BLUE_MASK_16BPP;
        }
        else
        if (_UH.protocolBpp < 15)
        {
#endif
        /********************************************************************/
        /* Fill in the color table.  The color indexes we use are indexes   */
        /* into the currently selected palette.  However, the values used   */
        /* are irrelevant (so we simply use 0 for every color) as we will   */
        /* always receive a new palette before we receive any updates, and  */
        /* UHProcessPalettePDU will set the DIBSection color table          */
        /* correctly.                                                       */
        /********************************************************************/
        pColors = (PDCUINT16) pbmi->bmiColors;

        for (i = 0; i < UH_NUM_8BPP_PAL_ENTRIES; i++)
        {
            *pColors = (DCUINT16) 0;
            pColors++;
        }

#ifdef DC_HICOLOR
        }
#endif
#endif // USE_GDIPLUS
        }
        /********************************************************************/
        /* Attempt to create the DIB section.                               */
        /********************************************************************/
        *phBitmap = CreateDIBSection(hdcDesktop,
                                     pbmi,
#ifdef DC_HICOLOR
                                     _UH.DIBFormat,
#else
                                     DIB_PAL_COLORS,
#endif
                                     &pBitmapBits,
                                     NULL,
                                     0);

#ifdef DC_HICOLOR
        if (NULL == *phBitmap)
        {
            TRC_ERR((TB, _T("Failed to create dib section, last error %d"),
                                                            GetLastError() ));
        }
#endif
        TRC_NRM((TB, _T("Using DIBSection")));
        _UH.usingDIBSection = TRUE;
    }
    else
#endif /* USE_DIBSECTION */
    {
        /********************************************************************/
        /* Create the bitmap.                                               */
        /********************************************************************/
        *phBitmap = CreateCompatibleBitmap(hdcDesktop,
                                          (int)bitmapSize.width,
                                          (int)bitmapSize.height);
        TRC_NRM((TB, _T("Not using DIBSection")));
        _UH.usingDIBSection = FALSE;
    }


    if (NULL == *phBitmap)
    {
        TRC_ERR((TB, _T("Failed to create bitmap of size (%u, %u)"),
                 bitmapSize.width, bitmapSize.height));

        /********************************************************************/
        /* if the bitmap creation failed tidy up the DC we created          */
        /********************************************************************/
        DeleteDC(*phdcBitmap);
        *phdcBitmap = NULL;

        /********************************************************************/
        /* and quit                                                         */
        /********************************************************************/
        rc = FALSE;
        DC_QUIT;
    }

    /************************************************************************/
    /* Select the bitmap into hdcBitmap.                                    */
    /************************************************************************/
    *phUnusedBitmap = SelectBitmap(*phdcBitmap, *phBitmap);

    TRC_NRM((TB, _T("Created Bitmap(%u x %u): %p"), bitmapSize.width,
                                                 bitmapSize.height,
                                                 *phBitmap));

#ifdef DC_HICOLOR
    if (_UH.protocolBpp <= 8)
    {
#endif
    /************************************************************************/
    /* Also select the default palette.                                     */
    /************************************************************************/
    TRC_DBG((TB, _T("Select default palette %p"), _UH.hpalDefault));
    SelectPalette(*phdcBitmap, _UH.hpalDefault, FALSE);
#ifdef DC_HICOLOR
    }
#endif

DC_EXIT_POINT:
    if (NULL != hdcDesktop)
    {
        ReleaseDC(HWND_DESKTOP, hdcDesktop);
    }

#ifdef USE_DIBSECTION
    /************************************************************************/
    /* Free the memory that we allocated for the bitmap info header.        */
    /************************************************************************/
    if (NULL != pbmi)
    {
        TRC_NRM((TB, _T("Freeing mem (at %p) for bitmap info header"), pbmi));
        UT_Free( _pUt, pbmi);
    }
#endif /* USE_DIBSECTION */

    DC_END_FN();
    return rc;
}


/****************************************************************************/
/* Name:      UHDeleteBitmap                                                */
/*                                                                          */
/* Purpose:   Deletes a Bitmap.                                             */
/*                                                                          */
/* Params:    IN/OUT  phdcBitmap -  handle of DC to be deleted              */
/*            IN/OUT  phBitmap   -  handle of bitmap to be deleted          */
/*            IN/OUT  phUnused   -  handle of DC's previous bitmap          */
/*                                                                          */
/* Operation: All parameters set to NULL on return                          */
/****************************************************************************/
DCVOID DCINTERNAL CUH::UHDeleteBitmap(HDC*     phdcBitmap,
                                 HBITMAP* phBitmap,
                                 HBITMAP* phUnused)
{
    HBITMAP  hBitmapScratch;
    HPALETTE hpalCurrent;

    DC_BEGIN_FN("UHDeleteBitmap");

    TRC_ASSERT((NULL != *phBitmap),
               (TB, _T("phBitmap is NULL")));

    TRC_NRM((TB, _T("Delete Bitmap: %#hx"), *phBitmap));

#ifdef DC_HICOLOR
    if (_UH.protocolBpp <= 8)
    {
#endif
    /************************************************************************/
    /* Restore the default palette.  But DO NOT delete the returned         */
    /* palette, as it may be in use by other DCs.                           */
    /************************************************************************/
    hpalCurrent = SelectPalette(*phdcBitmap,
                                _UH.hpalDefault,
                                FALSE);

#ifndef DC_HICOLOR // consider the case where we previously had no palette...
    TRC_ASSERT((hpalCurrent == _UH.hpalCurrent),
               (TB, _T("Palettes differ: (%p) (%p)"),
                               hpalCurrent, _UH.hpalCurrent));
#endif
#ifdef DC_HICOLOR
    }
#endif

    /************************************************************************/
    /* Deselect the bitmap from the DC.                                     */
    /************************************************************************/
    hBitmapScratch = SelectBitmap(*phdcBitmap, *phUnused);
    TRC_ASSERT((hBitmapScratch == *phBitmap), (TB,_T("Bad bitmap deselected")));

    /************************************************************************/
    /* Now delete the bitmap and DC.                                        */
    /************************************************************************/
    DeleteBitmap(*phBitmap);
    DeleteDC(*phdcBitmap);

    *phUnused = NULL;
    *phBitmap = NULL;
    *phdcBitmap = NULL;

    DC_END_FN();
}


/****************************************************************************/
/* Name:      GHSetShadowBitmapInfo                                         */
/*                                                                          */
/* Purpose:   Sets UH shadow bitmap bitmap info.                            */
/****************************************************************************/
DCVOID DCINTERNAL CUH::GHSetShadowBitmapInfo(DCVOID)
{
#ifdef USE_DIBSECTION
    DIBSECTION  dibSection;
#endif

    DC_BEGIN_FN("GHSetShadowBitmapInfo");

    _UH.bmShadowBits = NULL;
    _UH.bmShadowWidth = 0;
    _UH.bmShadowHeight = 0;

#ifdef USE_DIBSECTION

    if ((_UH.hShadowBitmap != NULL) && _UH.usingDIBSection)
    {
        if (sizeof(dibSection) == GetObject(_UH.hShadowBitmap,
                                            sizeof(dibSection), &dibSection))
        {
            _UH.bmShadowBits = (PDCUINT8)dibSection.dsBm.bmBits;
            _UH.bmShadowWidth = dibSection.dsBm.bmWidth;
            _UH.bmShadowHeight = dibSection.dsBm.bmHeight;
        }
    }

#endif

#ifdef OS_WINCE
#ifdef HDCL1171PARTIAL
    if (_UH.bmShadowBits == NULL)
    {
        int     cx;
        int     cy;
        int     cbSize;
        LPVOID  pvPhysical;
        LPVOID  pvVirtual;

        cx = GetDeviceCaps((HDC)NULL, HORZRES);
        cy = GetDeviceCaps((HDC)NULL, VERTRES);

        cbSize = cx * cy + (cx << 1);

        pvPhysical = (LPVOID) 0xaa000000;

        if ((pvVirtual = VirtualAlloc(0, cbSize, MEM_RESERVE, PAGE_NOACCESS))
                != NULL)
        {
            if (VirtualCopy(pvVirtual, pvPhysical, cbSize,
                            PAGE_NOCACHE | PAGE_READWRITE))
            {
                _UH.bmShadowBits = (PDCUINT8) pvVirtual + (cx << 1);
                _UH.bmShadowWidth = cx;
                _UH.bmShadowHeight = cy;
            }
        }
    }
#endif // HDCL1171PARTIAL
#endif // OS_WINCE
DC_EXIT_POINT:
    DC_END_FN();
}


/****************************************************************************/
/* Name:      UHMaybeCreateShadowBitmap                                     */
/*                                                                          */
/* Purpose:   Decides whether to create the Shadow Bitmap for this          */
/*            connection.                                                   */
/****************************************************************************/
DCVOID DCINTERNAL CUH::UHMaybeCreateShadowBitmap(DCVOID)
{
    DCSIZE desktopSize;
    DC_BEGIN_FN("UHMaybeCreateShadowBitmap");

    if (NULL != _UH.hShadowBitmap)
    {
        /********************************************************************/
        /* A Shadow Bitmap exists.  If it's the wrong size or has been      */
        /* disabled, delete it.                                             */
        /********************************************************************/
        BITMAP  bitmapDetails;

        /********************************************************************/
        /* See if the bitmap size matches the current desktop size.         */
        /********************************************************************/
        if (sizeof(bitmapDetails) != GetObject(_UH.hShadowBitmap,
                                               sizeof(bitmapDetails),
                                               &bitmapDetails))
        {
            TRC_ERR((TB, _T("Failed to get bitmap details (%#hx)"),
                                                           _UH.hShadowBitmap));
        }

        _pUi->UI_GetDesktopSize(&desktopSize);

        TRC_NRM((TB, _T("desktop(%u x %u) bitmap(%u x %u)"),
                      desktopSize.width, desktopSize.height,
                      bitmapDetails.bmWidth, bitmapDetails.bmHeight));

        if ((bitmapDetails.bmWidth != (int)desktopSize.width) ||
                (bitmapDetails.bmHeight != (int)desktopSize.height) ||
#ifdef DC_HICOLOR
                (_UH.shadowBitmapBpp != _UH.protocolBpp) ||
#endif
                !_UH.shadowBitmapRequested)
        {
            /****************************************************************/
            /* Size is wrong or bitmap is no longer wanted.  Delete it and  */
            /* clear the 'enabled' flag.                                    */
            /****************************************************************/
            TRC_NRM((TB, _T("Shadow Bitmap size incorrect or unwanted")));
            UHDeleteBitmap(&_UH.hdcShadowBitmap,
                           &_UH.hShadowBitmap,
                           &_UH.hunusedBitmapForShadowDC);

            _UH.shadowBitmapEnabled = FALSE;
        }
    }

    if ((_UH.shadowBitmapRequested) && (NULL == _UH.hShadowBitmap))
    {
        /********************************************************************/
        /* The Shadow Bitmap was enabled, so attempt to create it.          */
        /********************************************************************/
        TRC_DBG((TB, _T("Shadow Bitmap specified")));

        /********************************************************************/
        /* Get the current desktop size.                                    */
        /* The desktop size is specified by CC before calling this          */
        /* function, so assert that this has happened.                      */
        /********************************************************************/
        _pUi->UI_GetDesktopSize(&desktopSize);
        if ((desktopSize.width == 0) &&
             (desktopSize.height == 0))
        {
            TRC_ABORT((TB, _T("Desktop size not yet initialized")));
            DC_QUIT;
        }

        if (UHCreateBitmap(&_UH.hShadowBitmap,
                           &_UH.hdcShadowBitmap,
                           &_UH.hunusedBitmapForShadowDC,
                           desktopSize))
        {
            TRC_NRM((TB, _T("Created Shadow Bitmap")));
            _UH.shadowBitmapEnabled = TRUE;
#ifdef USE_GDIPLUS
            _UH.shadowBitmapBpp = 32;
#else // USE_GDIPLUS
            _UH.shadowBitmapBpp = _UH.protocolBpp;
#endif // USE_GDIPLUS
            // inform CLX for the new shadow bitmap
            _pClx->CLX_ClxEvent(CLX_EVENT_SHADOWBITMAPDC, (WPARAM)_UH.hdcShadowBitmap);
            _pClx->CLX_ClxEvent(CLX_EVENT_SHADOWBITMAP, (WPARAM)_UH.hShadowBitmap);
        }
        else
        {
            TRC_ALT((TB, _T("Failed to create shadow bitmap")));
        }
    }

    /********************************************************************/
    /* Make sure the shadow bitmap info is correct                      */
    /********************************************************************/
    GHSetShadowBitmapInfo();

DC_EXIT_POINT:
    DC_END_FN();
} /* UHMaybeCreateShadowBitmap */


/****************************************************************************/
/* Name:      UHMaybeCreateSaveScreenBitmap                                 */
/*                                                                          */
/* Purpose:   Decides whether to create the SSB bitmap                      */
/****************************************************************************/
DCVOID DCINTERNAL CUH::UHMaybeCreateSaveScreenBitmap(DCVOID)
{
    DCSIZE size;
    DC_BEGIN_FN("UHMaybeCreateSaveScreenBitmap");

    if (_UH.shadowBitmapEnabled || _UH.dedicatedTerminal)
    {
        /********************************************************************/
        /* Need an SSB bitmap                                               */
        /********************************************************************/
        if (_UH.hSaveScreenBitmap == NULL)
        {
            /****************************************************************/
            /* Attempt to create the SSB bitmap, provided it doesn't exist  */
            /* already.  We will only get this far if                       */
            /*  - we have created a Shadow Bitmap OR                        */
            /*  - we're running Full Screen mode and don't need the shadow. */
            /****************************************************************/
            TRC_NRM((TB, _T("Attempt to create SSB bitmap")));
            size.width = UH_SAVE_BITMAP_WIDTH;
            size.height = UH_SAVE_BITMAP_HEIGHT;
            if (UHCreateBitmap(&_UH.hSaveScreenBitmap,
                               &_UH.hdcSaveScreenBitmap,
                               &_UH.hunusedBitmapForSSBDC,
                               size))
            {
                TRC_NRM((TB, _T("SSB bitmap created")));
            }
            else
            {
                /************************************************************/
                /* We failed to create the save screen bitmap.  Just        */
                /* return.                                                  */
                /************************************************************/
                TRC_ALT((TB, _T("Failed to create SaveScreen bitmap")));
            }
        }
    }
    else if (_UH.hSaveScreenBitmap != NULL)
    {
        /********************************************************************/
        /* We have an unwanted SSB bitmap.  Delete it.                      */
        /* This happens if it was created in a previous connection and we   */
        /* have now specified to run without the Shadow Bitmap and are not  */
        /* a dedicated terminal.                                            */
        /********************************************************************/
        TRC_NRM((TB, _T("Delete unwanted SSB bitmap")));
        UHDeleteBitmap(&_UH.hdcSaveScreenBitmap,
                       &_UH.hSaveScreenBitmap,
                       &_UH.hunusedBitmapForSSBDC);
    }

    DC_END_FN();
} /* UHMaybeCreateSaveScreenBitmap */

#ifdef OS_WINCE
/**PROC+*********************************************************************/
/* Name:      UHGetPaletteCaps                                              */
/*                                                                          */
/* Purpose:   Determine the palette capabilities for the device             */
/*            This function is NEVER called by WBT only by                  */
/*            MAXALL/MINSHELL/etc... configs                                */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCINTERNAL CUH::UHGetPaletteCaps(DCVOID)
{
    HDC hdcGlobal;
    int iRasterCaps;

    hdcGlobal = GetDC(NULL);
    iRasterCaps = GetDeviceCaps(hdcGlobal, RASTERCAPS);

    _UH.paletteIsFixed = (iRasterCaps & RC_PALETTE) ? FALSE : TRUE;

    // Special hack for devices which return bogus information above.
    // "CLIO" -> Vadem Clio
    // "PV-6000" -> Sharp PV-6000
    // "PC companion" -> Compaq C-Series
    // "C600 I.T." -> NTS DreamWriter
    if (!_UH.paletteIsFixed)
    {
        TCHAR szOEMInfo[32];
        if (SystemParametersInfo(SPI_GETOEMINFO, sizeof(szOEMInfo)/sizeof(TCHAR), szOEMInfo, 0))
        {
            if ((_wcsnicmp(szOEMInfo, L"CLIO", 4) == 0) ||
                (_wcsnicmp(szOEMInfo, L"PV-6000", 7) == 0) ||
                (_wcsnicmp(szOEMInfo, L"PC companion", 12) == 0) ||
                (_wcsnicmp(szOEMInfo, L"C600 I.T.", 9) == 0))
                _UH.paletteIsFixed = TRUE;
        }
    }

    // Allow users or OEMs to override the default palette settings with a registry key
    if(_pUi->_UI.fOverrideDefaultPaletteIsFixed)
    {
        _UH.paletteIsFixed = _pUi->_UI.paletteIsFixed ? TRUE : FALSE;
    }

    ReleaseDC(NULL, hdcGlobal);

} /* UHGetPaletteCaps */
#endif // OS_WINCE

/****************************************************************************/
/* Name:      UHGetANSICodePage                                             */
/*                                                                          */
/* Purpose:   Get the local ANSI code page                                  */
/*                                                                          */
/* Operation: Look at the version info for GDI.EXE                          */
/****************************************************************************/
DCUINT DCINTERNAL CUH::UHGetANSICodePage(DCVOID)
{
    DCUINT     codePage;

    DC_BEGIN_FN("UHGetANSICodePage");

    //
    // Get the ANSI code page.  This function always returns a valid value.
    //
    codePage = GetACP();

    TRC_NRM((TB, _T("Return codepage %u"), codePage));

    DC_END_FN();
    return(codePage);
} /* UHGetANSICodePage */

#if (defined(OS_WINCE) && defined (WINCE_SDKBUILD) && defined(SHx))
#pragma optimize("", off)
#endif

VOID CUH::UHResetAndRestartEnumeration()
{
    DC_BEGIN_FN("UHResetAndRestartEnumeration");

    TRC_NRM((TB,_T("Reseting and re-enumerating keys")));

    //
    // This fn is intended to be called to re-enumerate
    // for a different color-depth
    //
    TRC_ASSERT(_UH.bBitmapKeyEnumComplete,
               (TB,_T("Prev enum should be complete bBitmapKeyEnumComplete")));

    UINT i = 0;
    for (i = 0; i<_UH.NumBitmapCaches; i++)
    {
        _UH.numKeyEntries[i] = 0;
    }
    for (i=0; i<TS_BITMAPCACHE_MAX_CELL_CACHES; i++)
    {
        if (_UH.pBitmapKeyDB[i])
        {
            UT_Free( _pUt, _UH.pBitmapKeyDB[i]);
            _UH.pBitmapKeyDB[i] = NULL;
        }
    }
    _UH.currentFileHandle = INVALID_HANDLE_VALUE;
    _UH.currentBitmapCacheId = 0;

    _UH.bBitmapKeyEnumerating = FALSE;
    _UH.bBitmapKeyEnumComplete = FALSE;

    TRC_NRM((TB,_T("Re-enumerating for different color depth")));
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
        CD_NOTIFICATION_FUNC(CUH,UHEnumerateBitmapKeyList), 0);

    DC_END_FN();
}
#if (defined(OS_WINCE) && defined (WINCE_SDKBUILD) && defined(SHx))
#pragma optimize("", on)
#endif

//
// Figure out the cache file name based on cacheId and copyMult
//
HRESULT CUH::UHSetCurrentCacheFileName(UINT cacheId, UINT copyMultiplier)
{
    HRESULT hr = E_FAIL;
    UINT    cchLenRemain;
    DC_BEGIN_FN("UHSetCurrentCacheFileName");

    cchLenRemain = SIZE_TCHARS(_UH.PersistCacheFileName) - 
                   (_UH.EndPersistCacheDir + 1);

    if (1 == copyMultiplier) {
        hr = StringCchPrintf(
                    &_UH.PersistCacheFileName[_UH.EndPersistCacheDir],
                    cchLenRemain,
                    _T("bcache%d.bmc"),
                    cacheId);
    }
    else {
        hr = StringCchPrintf(
                    &_UH.PersistCacheFileName[_UH.EndPersistCacheDir],
                    cchLenRemain,
                    _T("bcache%d%d.bmc"),
                    cacheId,
                    copyMultiplier);
    }

    if (FAILED(hr)) {
        TRC_ERR((TB,_T("Failed to printf cache file name: 0x%x"), hr));
    }

    TRC_NRM((TB,_T("Set cachefilename to %s"),
             _UH.PersistCacheFileName));

    DC_END_FN();
    return hr;
}

BOOL CUH::UHCreateDisconnectedBitmap()
{
    BOOL fResult = FALSE;
    DCSIZE desktopSize;

    DC_BEGIN_FN("UHCreateDisconnectedBitmap");

    _pUi->UI_GetDesktopSize(&desktopSize);
    if ((desktopSize.width == 0) &&
        (desktopSize.height == 0)) {
        TRC_ABORT((TB, _T("Desktop size not yet initialized")));
        DC_QUIT;
    }

    //
    // Delete any existing disabled bitmaps
    //
    if (_UH.hbmpDisconnectedBitmap && _UH.hdcDisconnected) {
        UHDeleteBitmap(&_UH.hdcDisconnected,
                       &_UH.hbmpDisconnectedBitmap,
                       &_UH.hbmpUnusedDisconnectedBitmap);
    }

    //
    // Create the disconnected backing bitmap
    //
    if (UHCreateBitmap(&_UH.hbmpDisconnectedBitmap,
                       &_UH.hdcDisconnected,
                       &_UH.hbmpUnusedDisconnectedBitmap,
                       desktopSize,
                       24)) {
        TRC_NRM((TB, _T("Created UH disabled bitmap")));
        fResult = TRUE;
    }
    else {
        TRC_ALT((TB, _T("Failed to create UH disabled bitmap")));
    }

    //
    // Get the window contents
    //
    if (fResult) {

        HDC hdc = UH_GetCurrentOutputDC();
        
        if (hdc) {
            fResult = BitBlt(_UH.hdcDisconnected,
                             0, 0,
                             desktopSize.width,
                             desktopSize.height,
                             hdc,
                             0, 0,
                             SRCCOPY);
        }

        if (!fResult) {
            TRC_ERR((TB, _T("BitBlt from screen to disconnect bmp failed")));
        }
    }

DC_EXIT_POINT:
    DC_END_FN();
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\wspint.h ===
/**INC+**********************************************************************/
/* Header:  wspint.h                                                        */
/*                                                                          */
/* Purpose: Sound Player - Windows specific internal header.                */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/hydra/tshrclnt/core/wspint.h_v  $
 * 
 *    Rev 1.1   25 Sep 1997 14:48:58   KH
 * SFR1037: Initial Sound player implementation
**/
/**INC-**********************************************************************/
#ifndef _H_WSPINT
#define _H_WSPINT

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Platform specific headers.                                               */
/****************************************************************************/
#include <nspint.h>

#endif /* _H_WSPINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\wcmint.cpp ===
/****************************************************************************/
// wcmint.c
//
// Cursor Manager internal functions
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/


#include <adcg.h>
extern "C" {
#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "wcmint"
#include <atrcapi.h>
}
#define TSC_HR_FILEID TSC_HR_WCMINT_CPP

#include "autil.h"
#include "wui.h"
#include "cm.h"
#include "uh.h"

#define ROUND_UP( x, to ) (((x) + (to-1)) & ~(to-1))
#define BMP_LENGTH_CALC( BPP, WIDTH, HEIGHT, BITSPADDING ) \
    (ROUND_UP( (BPP) * (WIDTH), (BITSPADDING)) / 8 * HEIGHT)

/****************************************************************************/
/* Name:      CMCreateMonoCursor                                            */
/*                                                                          */
/* Purpose:   Create a monochrome cursor from the MonoPointerAttributes     */
/*                                                                          */
/* Returns:   Cursor handle (NULL if failed)                                */
/****************************************************************************/
HRESULT DCINTERNAL CCM::CMCreateMonoCursor(
        TS_MONOPOINTERATTRIBUTE UNALIGNED FAR *pMono,
        DCUINT dataLen, HCURSOR *phcursor)
{
    HRESULT hr = S_OK;
    HCURSOR rc = CM_DEFAULT_ARROW_CURSOR_HANDLE;
    unsigned xorLen;

    DC_BEGIN_FN("CMCreateMonoCursor");

    *phcursor = NULL;

    // SECURITY 555587: CMCreate<XXX>Cursor must validate input
    if (pMono->lengthPointerData + 
        FIELDOFFSET(TS_MONOPOINTERATTRIBUTE, monoPointerData) > dataLen) {
        TRC_ERR(( TB, _T("Invalid mono cursor data length; size %u"), dataLen));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }

    TRC_ASSERT(pMono->width <= 32 && pMono->height <= 32,
        (TB, _T("Invalid mono cursor; height %d width %d"), pMono->height, 
        pMono->width));

    // Data contains XOR followed by AND mask.
    xorLen = ((pMono->width + 15) & 0xFFF0) * pMono->height;
    TRC_DATA_DBG("AND mask", pMono->monoPointerData + xorLen, xorLen);
    TRC_DATA_DBG("XOR bitmap", pMono->monoPointerData, xorLen);

    // SECURITY 555587: CMCreate<XXX>Cursor must validate input
    if (2 * xorLen != pMono->lengthPointerData)
    {
        TRC_ERR(( TB, _T("Invalid mono cursor data lengths")));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }

#ifndef OS_WINCE
    rc = CreateCursor(_pUi->UI_GetInstanceHandle(),
                      pMono->hotSpot.x,
                      pMono->hotSpot.y,
                      pMono->width,
                      pMono->height,
                      pMono->monoPointerData + xorLen,
                      pMono->monoPointerData);
#else
        /******************************************************************/
        /*  In Windows CE environments, we're not guaranteed that         */
        /*  CreateCursor is part of the OS, so we do a GetProcAddress on  */
        /*  it so we can be sure.  If it's not there, this usually means  */
        /*  we're on a touch screen device where these cursor doesn't     */
        /*  matter anyway.                                                */
        /******************************************************************/
        if (g_pCreateCursor)
        {
            rc = g_pCreateCursor(_pUi->UI_GetInstanceHandle(),
                              pMono->hotSpot.x,
                              pMono->hotSpot.y,
                              pMono->width,
                              pMono->height,
                              pMono->monoPointerData + xorLen,
                              pMono->monoPointerData);
        }
        else
        {
            rc = CM_DEFAULT_ARROW_CURSOR_HANDLE;
        }

#endif

    *phcursor = rc;

DC_EXIT_POINT:
    DC_END_FN();
    return hr;
}


/****************************************************************************/
/* Name:      CMCreateColorCursor                                           */
/*                                                                          */
/* Purpose:   Create a color cursor from the ColorPointerAttributes         */
/*                                                                          */
/* Returns:   handle of cursor (NULL if failed)                             */
/*                                                                          */
/* Params:    IN      pColorData  - pointer to pointer data in PointerPDU   */
/*                                                                          */
/* Operation: Use CreateIconIndirect to create a color icon                 */
/*            Win16: not supported                                          */
/*            Windows CE: not supported, according to SDK                   */
/****************************************************************************/
HRESULT DCINTERNAL CCM::CMCreateColorCursor(
        unsigned bpp,
        TS_COLORPOINTERATTRIBUTE UNALIGNED FAR *pColor,
        DCUINT dataLen, HCURSOR *phcursor)
{
    HRESULT hr          = E_FAIL;
    HCURSOR rc          = NULL;
    HDC     hdcMem      = NULL;
    HBITMAP hbmANDMask  = NULL;
    HWND    hwndDesktop = NULL;
    HBITMAP hbmXORBitmap = NULL;
    PBYTE   maskData    = NULL;

    *phcursor = NULL;

    /************************************************************************/
    /* Static buffer to hold the (temporary) bitmap info.                   */
    /*                                                                      */
    /* We need a BITMAPINFO structure plus 255 additional RGBQUADs          */
    /* (remember that there is one included within the BITMAPINFO).  The    */
    /* number of these we use depends on the bitmap we're passed:           */
    /*                                                                      */
    /* - XOR bitmap at 24bpp needs no color table                           */
    /* - XOR bitmap at 8bpp needs a 256 entry color table                   */
    /* - 1bpp AND mask requires only 2 colors                               */
    /************************************************************************/
    static char  bmi[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    LPBITMAPINFO pbmi = (LPBITMAPINFO)bmi;

#ifdef OS_WINCE
    void *pv;
#endif // OS_WINCE

    DC_BEGIN_FN("CMCreateColorCursor");

    TRC_NRM((TB, _T("bpp(%d) xhs(%u) yhs(%u) cx(%u) cy(%u) cbXOR(%u) cbAND(%u)"),
            bpp,
            pColor->hotSpot.x,
            pColor->hotSpot.y,
            pColor->width,
            pColor->height,
            pColor->lengthXORMask,
            pColor->lengthANDMask));

    TRC_DATA_DBG("AND mask",
                 pColor->colorPointerData + pColor->lengthXORMask,
                 pColor->lengthANDMask);
    TRC_DATA_DBG("XOR bitmap",
                 pColor->colorPointerData,
                 pColor->lengthXORMask);

    if (pColor->lengthANDMask + pColor->lengthXORMask + 
        FIELDOFFSET(TS_COLORPOINTERATTRIBUTE,colorPointerData) >
        dataLen) {
        TRC_ERR(( TB, _T("Invalid Color Cursor data; expected %u have %u"), 
            pColor->lengthANDMask + pColor->lengthXORMask + 
            FIELDOFFSET(TS_COLORPOINTERATTRIBUTE,colorPointerData),
            dataLen));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;
    }

    TRC_ASSERT(pColor->width <= 32 && pColor->height <= 32,
        ( TB, _T("Invalid color cursor; height %d width %d"), pColor->height, 
        pColor->width));

    // SECURITY 555587: must validate sizes read from packet
    // Color pointer: XOR mask should be WORD aligned
    if (BMP_LENGTH_CALC( (WORD)bpp, pColor->width, pColor->height, 16) != pColor->lengthXORMask ) { 
        TRC_ABORT((TB,_T("xor mask is not of proper length; bpp %d got %u expected %u"),
            (WORD)bpp, pColor->lengthXORMask, 
            BMP_LENGTH_CALC((WORD)bpp, pColor->width, pColor->height, 16)));
        hr = E_TSC_CORE_LENGTH;
        DC_QUIT;        
    }

    // Color pointer: AND mask should be DWORD aligned
    TRC_ASSERT(
        (BMP_LENGTH_CALC( 1, pColor->width, pColor->height, 16) == 
        pColor->lengthANDMask) ||
        (BMP_LENGTH_CALC( 1, pColor->width, pColor->height, 32) == 
        pColor->lengthANDMask ),
        (TB,_T("and mask is not of proper length; got %u expected %u or %u"), 
        pColor->lengthANDMask, 
        BMP_LENGTH_CALC( 1, pColor->width, pColor->height, 16),
        BMP_LENGTH_CALC( 1, pColor->width, pColor->height, 32)));

    /************************************************************************/
    /* Initialize the bitmap header for the XOR data.                       */
    /************************************************************************/
    pbmi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth         = pColor->width;
    pbmi->bmiHeader.biHeight        = pColor->height;
    pbmi->bmiHeader.biPlanes        = 1;
    pbmi->bmiHeader.biBitCount      = (WORD)bpp;
    pbmi->bmiHeader.biCompression   = BI_RGB;
    pbmi->bmiHeader.biSizeImage     = pColor->lengthXORMask;
    pbmi->bmiHeader.biXPelsPerMeter = 0;
    pbmi->bmiHeader.biYPelsPerMeter = 0;
    pbmi->bmiHeader.biClrUsed       = 0;
    pbmi->bmiHeader.biClrImportant  = 0;

    /************************************************************************/
    /* Get a device dependent bitmap containing the XOR data.               */
    /************************************************************************/
    hbmXORBitmap = CMCreateXORBitmap(pbmi, pColor);
    if (hbmXORBitmap == NULL)
    {
        TRC_ERR((TB, _T("Failed to create XOR bitmap")));
        DC_QUIT;
    }

    /************************************************************************/
    /* For the mono bitmap, use CreateCompatibleDC - this makes no          */
    /* difference on NT, but allows this code to work on Windows 95.        */
    /************************************************************************/
    hdcMem = CreateCompatibleDC(NULL);
    if (hdcMem == NULL)
    {
        TRC_ALT((TB, _T("Failed to create DC")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Create AND Mask (1bpp) - set the RGB colors to black and white.      */
    /************************************************************************/
    pbmi->bmiHeader.biBitCount  = 1;
    pbmi->bmiHeader.biClrUsed   = 2;
    pbmi->bmiHeader.biSizeImage = pColor->lengthANDMask;
    
    pbmi->bmiColors[0].rgbRed      = 0x00;
    pbmi->bmiColors[0].rgbGreen    = 0x00;
    pbmi->bmiColors[0].rgbBlue     = 0x00;
    pbmi->bmiColors[0].rgbReserved = 0x00;

    pbmi->bmiColors[1].rgbRed      = 0xFF;
    pbmi->bmiColors[1].rgbGreen    = 0xFF;
    pbmi->bmiColors[1].rgbBlue     = 0xFF;
    pbmi->bmiColors[1].rgbReserved = 0x00;

#ifdef OS_WINCE
    hbmANDMask = CreateDIBSection(hdcMem, pbmi,
            DIB_RGB_COLORS, &pv, NULL, 0);

    if (hbmANDMask != NULL)
        DC_MEMCPY(pv, pColor->colorPointerData + pColor->lengthXORMask,
                pColor->lengthANDMask);
#else // !OS_WINCE

    if (!(pColor->width & 3)) {
        maskData = pColor->colorPointerData + pColor->lengthXORMask;
    } else {
        PBYTE sourceData;
        PBYTE destData;
        DWORD widthBytes;

        unsigned i;

        sourceData = pColor->colorPointerData + pColor->lengthXORMask;
        widthBytes = ((pColor->width + 15) & ~15) / 8;

        pbmi->bmiHeader.biSizeImage = ((widthBytes + 3) & ~3) * pColor->height;

        maskData = (PBYTE) UT_Malloc(_pUt, ((DCUINT)pbmi->bmiHeader.biSizeImage));

        if (maskData) {
            destData = maskData;

            for (i = 0; i < pColor->height; i++) {
                memcpy(destData, sourceData, widthBytes);
                sourceData += (widthBytes + 1) & ~1;
                destData += (widthBytes + 3) & ~3;
            }
        } else {
            // We failed to allocate, so we'll just use the wire format
            // color bitmap data.  The cursor would be wrong, but
            // it's better than no cursor
            maskData = pColor->colorPointerData + pColor->lengthXORMask;
        }
    }

    hbmANDMask = CreateDIBitmap(hdcMem,
                                (LPBITMAPINFOHEADER)pbmi,
                                CBM_INIT,
                                maskData,
                                pbmi,
                                DIB_RGB_COLORS);
#endif // OS_WINCE

    /************************************************************************/
    /* Free the DC.                                                         */
    /************************************************************************/
    DeleteDC(hdcMem);

    if (hbmANDMask == NULL)
    {
        TRC_ALT((TB, _T("Failed to create AND mask")));
        DC_QUIT;
    }

//  /****************************************************************************/
//  /* Testing...                                                               */
//  /****************************************************************************/
//  {
//      HWND    hwndDesktop = GetDesktopWindow();
//      HDC     hdcScreen   = GetWindowDC(hwndDesktop);
//      HDC     hdcMemory   = CreateCompatibleDC(hdcScreen);
//      HBITMAP hbmOld;
//
//      hbmOld = SelectBitmap(hdcMemory, hbmANDMask);
//      BitBlt(hdcScreen, 1000, 800, 1031, 831, hdcMemory, 0, 0, SRCCOPY);
//
//      SelectBitmap(hdcMemory, hbmXORBitmap);
//      BitBlt(hdcScreen, 1032, 800, 1063, 831, hdcMemory, 0, 0, SRCCOPY);
//
//      SelectBitmap(hdcMemory, hbmOld);
//      DeleteDC(hdcMemory);
//      ReleaseDC(hwndDesktop, hdcScreen);
//  }


    /************************************************************************/
    /* Create the cursor.                                                   */
    /************************************************************************/
    rc = CMCreatePlatformCursor(pColor, hbmXORBitmap, hbmANDMask);
    TRC_NRM((TB, _T("CreateCursor(%p) cx(%u)cy(%u)"),
                                          rc, pColor->width, pColor->height));
    *phcursor = rc;
	hr = S_OK;

DC_EXIT_POINT:

#ifndef OS_WINCE
    if (hbmXORBitmap != NULL)
    {
        DeleteBitmap(hbmXORBitmap);
    }

    if (hbmANDMask != NULL)
    {
        DeleteBitmap(hbmANDMask);
    }
#else // OS_WINCE
    if (hbmXORBitmap != NULL)
    {
        DeleteObject((HGDIOBJ)hbmXORBitmap);
    }

    if (hbmANDMask != NULL)
    {
        DeleteObject((HGDIOBJ)hbmANDMask);
    }

#endif // OS_WINCE

    if (maskData != NULL && 
        maskData != (pColor->colorPointerData + pColor->lengthXORMask)) {
        UT_Free(_pUt, maskData);
    }

    /************************************************************************/
    /* Check that we have successfully managed to create the cursor.  If    */
    /* not then substitute the default cursor.                              */
    /************************************************************************/
    if (*phcursor == NULL)
    {
        /********************************************************************/
        /* Substitute the default arrow cursor.                             */
        /********************************************************************/
        *phcursor = CM_DEFAULT_ARROW_CURSOR_HANDLE;

        TRC_ERR((TB, _T("Could not create cursor - substituting default arrow")));
    }

    DC_END_FN();
    return hr;
} /* CMCreateColorCursor */


#if defined(OS_WINCE)
/****************************************************************************/
/* Name:      CMMakeMonoDIB                                                 */
/*                                                                          */
/* Purpose:   Create a mono DIB from the supplied color DIB                 */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    IN      hdc - device context applying to the DIB              */
/*            IN/OUT  pbmi - pointer to bitmap info for source/target       */
/*            IN      pColorDIB - pointer to source bits                    */
/*            OUT     pMonoDIB - address of buffer to receive mono bits     */
/*                                                                          */
/* Operation: Currently supports 32x32xNbpp source. The bitmap header       */
/*            passed in (source) is updated to match the target.            */
/****************************************************************************/
DCVOID DCINTERNAL CCM::CMMakeMonoDIB(HDC          hdc,
                                LPBITMAPINFO pbmi,
                                PDCUINT8     pColorDIB,
                                PDCUINT8     pMonoDIB)
{
    COLORREF  dcBackColor;
    LONG      i;
    RGBTRIPLE bkCol;
    DCUINT8   monoMask;
    DCUINT8   monoByte;
    PDCUINT32 pBMIColor;
    PBYTE     colorData = NULL;
    BYTE      swap;

    DC_BEGIN_FN("CMMakeMonoDIB");

    // Find out the background color for this DC.
    dcBackColor         = GetBkColor(hdc);
    bkCol.rgbtRed   = (BYTE)(dcBackColor);
    bkCol.rgbtGreen = (BYTE)(((DCUINT16)dcBackColor) >> 8);
    bkCol.rgbtBlue  = (BYTE)(dcBackColor >> 16);

    // The color pointer data width is WORD aligned on the wire.
    // We need to pass the DWORD aligned raw bitmap data to CreateDIBitmap
    // to create the actual cursor bitmap.
    // Also, we pad the cursor bitmap to 32x32 if it is not
    if (pbmi->bmiHeader.biWidth == CM_CURSOR_WIDTH && 
            pbmi->bmiHeader.biHeight == CM_CURSOR_HEIGHT) {
        colorData = pColorDIB;
    } else {
        PBYTE sourceData;
        PBYTE destData;

        DWORD WidthBytes;

        sourceData = pColorDIB;

        WidthBytes = pbmi->bmiHeader.biWidth *
                           pbmi->bmiHeader.biBitCount / 8;
        
        colorData = (PBYTE) UT_Malloc( _pUt, CM_CURSOR_WIDTH * CM_CURSOR_HEIGHT * 
                                      pbmi->bmiHeader.biBitCount / 8);

        if (colorData) {
            memset(colorData, 0, pbmi->bmiHeader.biSizeImage);

            destData = colorData;

            for (i = 0; i < pbmi->bmiHeader.biHeight; i++) {
                memcpy(destData, sourceData, WidthBytes);
                sourceData += (WidthBytes + 1) & ~1;
                destData += CM_CURSOR_WIDTH * pbmi->bmiHeader.biBitCount / 8;
            }
        } else {
            DC_QUIT;
        }
    }

    // Convert the bitmap.  Any pixels which match the DC's background
    // color map to 1 (white) in the mono DIB; all other pixels map to 0
    // (black).
    TRC_NRM((TB, _T("bitmap color depth %u"), pbmi->bmiHeader.biBitCount));
    if (pbmi->bmiHeader.biBitCount == 24) {
        for (i = 0; i < ((CM_CURSOR_WIDTH * CM_CURSOR_HEIGHT) / 8); i++) {
            // Initialise the next target byte to all 0 pixels.
            monoByte = 0;

            // Get the next 8 pixels ie, one target byte's worth.
            for (monoMask = 0x80; monoMask != 0; monoMask >>= 1) {
                /************************************************************/
                /* Determine if the next Pel in the source matches the DC   */
                /* background color.  If not, it is unnecessary to          */
                /* explicitly write a zero as each target byte is zeroed    */
                /* before writing any data, ie each pixel is zero by        */
                /* default.                                                 */
                /* 24bpp gives 3 bytes per pel                              */
                /************************************************************/
                if ( (colorData[0] == bkCol.rgbtBlue) &&
                     (colorData[1] == bkCol.rgbtGreen) &&
                     (colorData[2] == bkCol.rgbtRed) )
                {
                    // Background color match - write a 1 to the mono DIB.
                    monoByte |= monoMask;
                }

                // Advance the source pointer to the next pel.
                colorData += 3;
            }

            // Save the target value in the target buffer.
            *pMonoDIB = monoByte;

            // Advance the target pointer to the next byte.
            pMonoDIB++;
        }
    }
#ifdef DC_HICOLOR
    else if ((pbmi->bmiHeader.biBitCount == 16) ||
             (pbmi->bmiHeader.biBitCount == 15))
    {
        BYTE     red, green, blue;
        DCUINT16 redMask, greenMask, blueMask;

        if (pbmi->bmiHeader.biBitCount == 16)
        {
            redMask   = TS_RED_MASK_16BPP;
            greenMask = TS_GREEN_MASK_16BPP;
            blueMask  = TS_BLUE_MASK_16BPP;
        }
        else
        {
            redMask   = TS_RED_MASK_15BPP;
            greenMask = TS_GREEN_MASK_15BPP;
            blueMask  = TS_BLUE_MASK_15BPP;
        }


        for ( i = 0; i < ((CM_CURSOR_WIDTH * CM_CURSOR_HEIGHT) / 8); i++ )
        {
            /****************************************************************/
            /* Initialise the next target byte to all 0 pixels.             */
            /****************************************************************/
            monoByte = 0;

            /****************************************************************/
            /* Get the next 8 pixels ie, one target byte's worth.           */
            /****************************************************************/
            for ( monoMask = 0x80; monoMask != 0; monoMask >>= 1 )
            {
                /************************************************************/
                /* Determine if the next Pel in the source matches the DC   */
                /* background color.  If not, it is unnecessary to          */
                /* explicitly write a zero as each target byte is zeroed    */
                /* before writing any data, ie each pixel is zero by        */
                /* default.                                                 */
                /*                                                          */
                /* 15 and 16bpp give 2 bytes per pel                        */
                /************************************************************/
#if defined (OS_WINCE) && defined (DC_NO_UNALIGNED)
                blue  = ((*((DCUINT16 UNALIGNED *)pColorDIB)) & blueMask)  << 3;
                green = ((*((DCUINT16 UNALIGNED *)pColorDIB)) & greenMask) >> 3;
                red   = ((*((DCUINT16 UNALIGNED *)pColorDIB)) & redMask)   >> 8;
#else
                blue  = ((*((PDCUINT16)pColorDIB)) & blueMask)  << 3;
                green = ((*((PDCUINT16)pColorDIB)) & greenMask) >> 3;
                red   = ((*((PDCUINT16)pColorDIB)) & redMask)   >> 8;
#endif

#ifndef OS_WINCE
                if ( (blue  == bkCol.rgbtBlue)  &&
                     (green == bkCol.rgbtGreen) &&
                     (red   == bkCol.rgbtRed) )
#else
                if (dcBackColor == GetNearestColor(hdc, RGB(red, green, blue)))
#endif
                {
                    /********************************************************/
                    /* Background color match - write a 1 to the mono DIB.  */
                    /********************************************************/
                    monoByte |= monoMask;
                }

                /************************************************************/
                /* Advance the source pointer to the next pel.              */
                /************************************************************/
                pColorDIB += 2;
            }

            /****************************************************************/
            /* Save the target value in the target buffer.                  */
            /****************************************************************/
            *pMonoDIB = monoByte;

            /****************************************************************/
            /* Advance the target pointer to the next byte.                 */
            /****************************************************************/
            pMonoDIB++;
        }
    }
#endif
    else if (pbmi->bmiHeader.biBitCount == 8)
    {
        // we need to set up a color table to go with the bmp
        //
        pbmi->bmiHeader.biClrUsed = 1 << pbmi->bmiHeader.biBitCount;
        TRC_NRM((TB, _T("XOR clr used %d"), pbmi->bmiHeader.biClrUsed));

        GetPaletteEntries( _pUh->UH_GetCurrentPalette(),
                          0,
                          (UINT)pbmi->bmiHeader.biClrUsed,
                          (LPPALETTEENTRY)pbmi->bmiColors);

        /********************************************************************/
        /* now we have to flip the red and blue components - paletteentries */
        /* go R-G-B-flags, while the RGBQUADs required for color tables go  */
        /* B-G-R-reserved                                                   */
        /********************************************************************/
        for (i = 0; i < pbmi->bmiHeader.biClrUsed; i++)
        {
            swap                       = pbmi->bmiColors[i].rgbRed;
            pbmi->bmiColors[i].rgbRed  = pbmi->bmiColors[i].rgbBlue;
            pbmi->bmiColors[i].rgbBlue = swap;
        }

        for ( i = 0; i < ((CM_CURSOR_WIDTH * CM_CURSOR_HEIGHT) / 8); i++ ) {
            // Initialise the next target byte to all 0 pixels.
            monoByte = 0;

            // Get the next 8 pixels ie, one target byte's worth.
            for ( monoMask = 0x80; monoMask != 0; monoMask >>= 1 ) {
                /************************************************************/
                /* Determine if the next Pel in the source matches the DC   */
                /* background color.  If not, it is unnecessary to          */
                /* explicitly write a zero as each target byte is zeroed    */
                /* before writing any data, ie each pixel is zero by        */
                /* default.                                                 */
                /*                                                          */
                /* 8bpp gives one byte per pel, and each byte is an index   */
                /* into the supplied color table rather than an RGB value   */
                /************************************************************/
                if (
                  (pbmi->bmiColors[*colorData].rgbBlue  == bkCol.rgbtBlue)  &&
                  (pbmi->bmiColors[*colorData].rgbGreen == bkCol.rgbtGreen) &&
                  (pbmi->bmiColors[*colorData].rgbRed   == bkCol.rgbtRed)) {
                    // Background color match - write a 1 to the mono DIB.
                    monoByte |= monoMask;
                }

                // Advance the source pointer to the next pel.
                colorData ++;
            }

            // Save the target value in the target buffer.
            *pMonoDIB = monoByte;

            // Advance the target pointer to the next byte.
            pMonoDIB++;
        }
    }
    else {
        TRC_ERR((TB, _T("Unsupported BPP %d"), pbmi->bmiHeader.biBitCount));
    }

DC_EXIT_POINT:

    // Update the bitmap header to reflect the mono DIB.
#ifdef OS_WINCE
    if (!(pbmi->bmiHeader.biWidth == CM_CURSOR_WIDTH && 
            pbmi->bmiHeader.biHeight == CM_CURSOR_HEIGHT)) {
#else
    if (colorData != pColorDIB) {
#endif
        UT_Free( _pUt, colorData);
    }

    pbmi->bmiHeader.biBitCount = 1;
    pbmi->bmiHeader.biClrUsed  = 2;
    pBMIColor = (PDCUINT32)pbmi->bmiColors;
    pBMIColor[0] = RGB(0, 0, 0);
    pBMIColor[1] = RGB(0xff, 0xff, 0xff);

    DC_END_FN();
}
#endif


#ifdef OS_WINCE
/****************************************************************************/
// CMCreateXORBitmap
//
// Windows CE version.
/****************************************************************************/
HBITMAP CCM::CMCreateXORBitmap(
        LPBITMAPINFO pbmi,
        TS_COLORPOINTERATTRIBUTE UNALIGNED FAR *pColor)
{
    struct {
        BITMAPINFO  bmi;
        RGBQUAD     bmiColors2;
    } bigbmi;

    PDCUINT32 pBMIColor;
    HDC hdcMem;
    HBITMAP hbmXORBitmap;
    void *pv;

    DC_BEGIN_FN("CMCreateXORBitmap");

    // Create a copy of the bitmapinfo
    DC_MEMCPY(&bigbmi, pbmi, sizeof(bigbmi));

    // Make it a mono DIB
    bigbmi.bmi.bmiHeader.biBitCount = 1;
    bigbmi.bmi.bmiHeader.biSizeImage = 0;
    pBMIColor = (PDCUINT32)bigbmi.bmi.bmiColors;
    pBMIColor[0] = RGB(0, 0, 0);
    pBMIColor[1] = RGB(0xff, 0xff, 0xff);

    hdcMem = CreateCompatibleDC(NULL);
    if (hdcMem != 0) {
        // Create a 1bpp compatible bitmap.
        hbmXORBitmap = CreateDIBSection(hdcMem, &bigbmi.bmi, DIB_PAL_COLORS,
            &pv, NULL, 0);

        if (hbmXORBitmap != NULL) {
            // Convert the XOR bitmap into 1bpp format. Avoid using
            // Windows for this as display drivers are unreliable for DIB
            // conversions.
            CMMakeMonoDIB(hdcMem, pbmi, pColor->colorPointerData, (PDCUINT8)pv);
        }

        // Free the DC.
        DeleteDC(hdcMem);
    }
    else {
        // DC creation failure.
        TRC_ERR((TB, _T("Failed to create memory DC")));
        hbmXORBitmap = 0;
    }

    DC_END_FN();
    return hbmXORBitmap;
}


HCURSOR CCM::CMCreatePlatformCursor(
        TS_COLORPOINTERATTRIBUTE UNALIGNED FAR *pColor,
        HBITMAP hbmXORBitmap,
        HBITMAP hbmANDMask)
{
    // Set this to use the cursor workaround. Note that we would fix this
    // differently were we going to ship this code, but since this should
    // be fixed in the OS, this will do in the mean time.
#define WINCE_CURSOR_BUG

    HCURSOR  hCursor = NULL;
    ICONINFO ii;
#ifdef WINCE_CURSOR_BUG
    HBITMAP hbmDst;
    HDC hdcSrc, hdcDst;
    HGDIOBJ gdiOldSrc, gdiOldDst;
    struct {
        BITMAPINFO  bmi;
        RGBQUAD     bmiColors2;
    } bigbmi;
    PDCUINT32 pBMIColor;
    void *pv;
#endif // WINCE_CURSOR_BUG

    DC_BEGIN_FN("CMCreatePlatformCursor");

#ifdef WINCE_CURSOR_BUG
    hdcSrc = CreateCompatibleDC(NULL);
    if (hdcSrc != NULL) {
        hdcDst = CreateCompatibleDC(NULL);
        if (hdcDst != NULL) {
            bigbmi.bmi.bmiHeader.biSize = sizeof(bigbmi.bmi);
            bigbmi.bmi.bmiHeader.biWidth = pColor->width;
            bigbmi.bmi.bmiHeader.biHeight = pColor->height * 2;
            bigbmi.bmi.bmiHeader.biPlanes = 1;
            bigbmi.bmi.bmiHeader.biBitCount = 1;
            bigbmi.bmi.bmiHeader.biCompression = BI_RGB;
            bigbmi.bmi.bmiHeader.biSizeImage = 0;
            bigbmi.bmi.bmiHeader.biXPelsPerMeter = 0;
            bigbmi.bmi.bmiHeader.biXPelsPerMeter = 0;
            bigbmi.bmi.bmiHeader.biClrUsed = 0;
            bigbmi.bmi.bmiHeader.biClrImportant = 0;
            pBMIColor = (PDCUINT32)bigbmi.bmi.bmiColors;
            pBMIColor[0] = RGB(0, 0, 0);
            pBMIColor[1] = RGB(0xff, 0xff, 0xff);

            hbmDst = CreateDIBSection(hdcDst, &bigbmi.bmi, DIB_PAL_COLORS, &pv,
                    NULL, 0);

            if (NULL != hbmDst) {
                gdiOldSrc = SelectObject(hdcSrc, (HGDIOBJ) hbmANDMask);
                gdiOldDst = SelectObject(hdcDst, (HGDIOBJ) hbmDst);
                BitBlt(hdcDst, 0, 0, pColor->width, pColor->height, hdcSrc,
                        0, 0, SRCCOPY);

                SelectObject(hdcSrc, (HGDIOBJ) hbmXORBitmap);
                BitBlt(hdcDst, 0, pColor->height, pColor->width,
                        pColor->height, hdcSrc, 0, 0, SRCCOPY);

                SelectObject(hdcSrc, gdiOldSrc);
                SelectObject(hdcDst, gdiOldDst);

                ii.fIcon = FALSE;
                ii.xHotspot = pColor->hotSpot.x;
                ii.yHotspot = pColor->hotSpot.y;
                ii.hbmMask = hbmDst;
                ii.hbmColor = hbmDst;

                hCursor = CreateIconIndirect(&ii);
                DeleteObject(hbmDst);
            }
            else {
                TRC_SYSTEM_ERROR("CreateDIBSection");
            }

            DeleteDC(hdcDst);
        }
        else {
            TRC_SYSTEM_ERROR("CreateCompatibleDC (2)");
        }

        DeleteDC(hdcSrc);
    }
    else {
        TRC_SYSTEM_ERROR("CreateCompatibleDC (1)");
    }

#else // WINCE_CURSOR_BUG

    ii.fIcon = FALSE;
    ii.xHotspot = pColor->hotSpot.x;
    ii.yHotspot = pColor->hotSpot.y;
    ii.hbmMask = hbmANDMask;
    ii.hbmColor = hbmXORBitmap;

    hCursor = CreateIconIndirect(&ii);
#endif // WINCE_CURSOR_BUG

    DC_END_FN();
    return hCursor;
}

#else  // OS_WINCE
HBITMAP CCM::CMCreateXORBitmap(
        LPBITMAPINFO pbmi,
        TS_COLORPOINTERATTRIBUTE UNALIGNED FAR *pColor)
{
    HWND     hwndDesktop;
    HDC      hdcScreen;
    HBITMAP  hbmXORBitmap;
    PBYTE    colorData = NULL;
    unsigned fUsage;
    unsigned i;
    BYTE     swap;

    DC_BEGIN_FN("CMCreateXORBitmap");

    // Get a screen DC that we can pass to CreateDIBitmap.  We do not use
    // CreateCompatibleDC(NULL) here because that results in Windows
    // creating a mono bitmap (since the DC generated has a stock mono
    // bitmap selected into it and CreateDIBitmap generates a bitmap of the
    // same format as that already selected in the DC).
    hwndDesktop = GetDesktopWindow();
    hdcScreen = GetWindowDC(hwndDesktop);

    if (hdcScreen != 0) {
        // Set up the usage flag
#ifdef DC_HICOLOR
        if (pbmi->bmiHeader.biBitCount > 8) {
            TRC_NRM((TB, _T("Hi color so usage is DIB_RGB_COLORS")));
            /****************************************************************/
            /* The bitmap contains RGBS so there's no color table           */
            /****************************************************************/
            fUsage = DIB_RGB_COLORS;
        }
#else
        if (pbmi->bmiHeader.biBitCount == 24) {
            TRC_NRM((TB, _T("24 bpp so usage is DIB_RGB_COLORS")));
            // The bitmap contains RGBS so there's no color table.
            fUsage = DIB_RGB_COLORS;
        }
#endif
        else {
            TRC_DBG((TB, _T("%d bpp, usage DIB_RGB_COLORS"),
                                                 pbmi->bmiHeader.biBitCount));

            // The bitmap has a color table containing RGB colors.
            fUsage = DIB_RGB_COLORS;
            pbmi->bmiHeader.biClrUsed = 1 << pbmi->bmiHeader.biBitCount;
            TRC_NRM((TB, _T("XOR clr used %d"), pbmi->bmiHeader.biClrUsed));

            i = GetPaletteEntries(_pUh->UH_GetCurrentPalette(),
                                  0,
                                  pbmi->bmiHeader.biClrUsed,
                                  (LPPALETTEENTRY)pbmi->bmiColors);

            TRC_NRM((TB, _T("Entries returned %d"), i));
            if (i != pbmi->bmiHeader.biClrUsed) {
                TRC_SYSTEM_ERROR("GetPaletteEntries");
            }

            // Now we have to flip the red and blue components -
            // paletteentries go R-G-B-flags, while the RGBQUADs required
            // for color tables go B-G-R-reserved.
            for (i = 0; i < pbmi->bmiHeader.biClrUsed; i++) {
                swap                       = pbmi->bmiColors[i].rgbRed;
                pbmi->bmiColors[i].rgbRed  = pbmi->bmiColors[i].rgbBlue;
                pbmi->bmiColors[i].rgbBlue = swap;
            }
        }

        //  The color pointer XOR data width is WORD aligned on the wire.
        //  We need to pass the DWORD aligned raw bitmap data to CreateDIBitmap
        //  to create the actual cursor bitmap
        if (!(pColor->width & 3)) {
            colorData = pColor->colorPointerData;
        } else {
            PBYTE sourceData;
            PBYTE destData;
            DWORD widthBytes;

            unsigned i;

            sourceData = pColor->colorPointerData;
            widthBytes = pColor->width * pbmi->bmiHeader.biBitCount / 8;

            pbmi->bmiHeader.biSizeImage = ((pColor->width + 3) & ~3) * pColor->height * 
                                          pbmi->bmiHeader.biBitCount / 8;

            colorData = (PBYTE) UT_Malloc(_pUt, ((DCUINT)pbmi->bmiHeader.biSizeImage));

            if (colorData) {
                destData = colorData;

                for (i = 0; i < pColor->height; i++) {
                    memcpy(destData, sourceData, widthBytes);
                    sourceData += (widthBytes + 1) & ~1;
                    destData += (widthBytes + 3) & ~3;
                }
            } else {
                // We failed to allocate, so we'll just use the wire format
                // color bitmap data.  The cursor would be wrong, but
                // it's better than no cursor
                colorData = pColor->colorPointerData;
            }
        }

        // Create XOR Bitmap.
        hbmXORBitmap = CreateDIBitmap(hdcScreen,
                                      (LPBITMAPINFOHEADER)pbmi,
                                      CBM_INIT,
                                      colorData,
                                      pbmi,
                                      fUsage);

        // Release the DC.
        ReleaseDC(hwndDesktop, hdcScreen);
    }
    else {
        // Error getting the screen DC.
        TRC_ERR((TB, _T("Failed to create screen DC")));
        hbmXORBitmap = 0;
    }

    DC_END_FN();

    if (colorData != pColor->colorPointerData) {
        UT_Free(_pUt, colorData);
    }

    return hbmXORBitmap;
}


HCURSOR CCM::CMCreatePlatformCursor(
        TS_COLORPOINTERATTRIBUTE UNALIGNED FAR *pColor,
        HBITMAP hbmXORBitmap,
        HBITMAP hbmANDMask)
{
    ICONINFO iconInfo;

    DC_BEGIN_FN("CMCreatePlatformCursor");

    // Create a color cursor using the mask and color bitmaps.
    iconInfo.fIcon = FALSE;
    iconInfo.xHotspot = pColor->hotSpot.x;
    iconInfo.yHotspot = pColor->hotSpot.y;
    iconInfo.hbmMask  = hbmANDMask;
    iconInfo.hbmColor = hbmXORBitmap;

    TRC_DBG((TB,_T("Create icon with hs x %d y %d"),
            iconInfo.xHotspot, iconInfo.yHotspot));

    DC_END_FN();
    return CreateIconIndirect(&iconInfo);
}


#endif  // OS_WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\wtdapi.cpp ===
/****************************************************************************/
// wtdapi.c
//
// Transport driver - Windows specific API
//
// Copyright(C) 1997-1999 Microsoft Corporation
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_FILE "wtdapi"
#define TRC_GROUP TRC_GROUP_NETWORK
#include <atrcapi.h>
#include <adcgfsm.h>
}

#include "autil.h"
#include "td.h"
#include "nl.h"


/****************************************************************************/
/* Name:      TD_Recv                                                       */
/*                                                                          */
/* Purpose:   Called to receive X bytes from WinSock and store them in the  */
/*            buffer pointed to by pData.                                   */
/*                                                                          */
/* Returns:   The number of bytes received.                                 */
/*                                                                          */
/* Params:    IN  pData - pointer to buffer to receive the data.            */
/*            IN  size  - number of bytes to receive.                       */
/****************************************************************************/
DCUINT DCAPI CTD::TD_Recv(PDCUINT8 pData,
                     DCUINT   size)
{
    unsigned bytesToRecv;
    unsigned bytesCopied;
    unsigned BytesRecv;
    unsigned BytesToCopy;

    DC_BEGIN_FN("TD_Recv");

    /************************************************************************/
    /* Check that we're being asked to receive some data, that the pointer  */
    /* is not NULL, that the memory range to receive the data into is       */
    /* writable by us and that there is data available.                     */
    /************************************************************************/
    TRC_ASSERT((pData != NULL), (TB, _T("Data pointer is NULL")));
    TRC_ASSERT((size != 0), (TB, _T("No data to receive")));

    TRC_ASSERT((0 == IsBadWritePtr(pData, size)),
               (TB, _T("Don't have write access to memory %p (size %u)"),
                pData,
                size));
    TRC_ASSERT((_TD.dataInTD), (TB, _T("TD_Recv called when dataInTD is FALSE")));
    TRC_DBG((TB, _T("Request for %u bytes"), size));

    /************************************************************************/
    /* TD has a recv buffer into which it attempts to receive sufficient    */
    /* data to fill the buffer.                                             */
    /* Initially this buffer is empty. On a call to TD_Recv, the following  */
    /* sequence occurs.                                                     */
    /* Data is copied from the recv buffer to the caller's buffer. If this  */
    /* satisfies the caller's request, no further action is needed.         */
    /* If this does not satisfy the caller, ie the recv buffer was empty or */
    /* had less data then requested (so is now empty), another call is made */
    /* to WinSock.                                                          */
    /* The buffer used for this recv is the recv buffer is the caller       */
    /* requires fewer bytes than the recv buffer holds, the caller's buffer */
    /* otherwise.                                                           */
    /* Whenever the recv buffer is used, WinSock is asked for as many bytes */
    /* as the buffer holds (rather than the number of bytes the caller      */
    /* wants). This means there may be some data left in the recv buffer    */
    /* ready for the next call to TD_Recv.                                  */
    /************************************************************************/

    bytesToRecv = size;

    /************************************************************************/
    /* Copy as much data as possible from the recv buffer.                  */
    /************************************************************************/
    // If the recv buffer contains data then copy up to bytesToCopy to the
    // caller's buffer, otherwise just quit.
    if (_TD.recvBuffer.dataLength == 0) {
        // The recv buffer is empty, so zero bytes copied.
        TRC_DBG((TB, _T("recv buffer is empty, need to go to WinSock")));
        bytesCopied = 0;
    }
    else {
        // Copy the lesser of the number of bytes requested and the number of
        // bytes in the buffer.
        bytesCopied = DC_MIN(bytesToRecv, _TD.recvBuffer.dataLength);
        TRC_ASSERT(((bytesCopied + _TD.recvBuffer.dataStart) <=
                _TD.recvBuffer.size),
                (TB, _T("Want %u bytes from buffer, but start %u, size %u"),
                bytesCopied,
                _TD.recvBuffer.dataStart,
                _TD.recvBuffer.size));

        memcpy(pData, &_TD.recvBuffer.pData[_TD.recvBuffer.dataStart],
                bytesCopied);
        TRC_DBG((TB, _T("Copied %u bytes from recv buffer"), bytesCopied));

        // Update the recv buffer to take account of the data copied.
        _TD.recvBuffer.dataLength -= bytesCopied;
        if (0 == _TD.recvBuffer.dataLength)
            // Used all the data from the recv buffer so reset the start pos.
            _TD.recvBuffer.dataStart = 0;
        else
            // Still some data left in recv buffer.
            _TD.recvBuffer.dataStart += bytesCopied;

        TRC_DBG((TB, _T("recv buffer now has %u bytes starting at %u"),
                _TD.recvBuffer.dataLength, _TD.recvBuffer.dataStart));

        // Update the number of bytes still to receive.
        bytesToRecv -= bytesCopied;
        if (0 == bytesToRecv) {
            TRC_DBG((TB, _T("Received all necessary data")));
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* Now try to get any data which may still be required by recv'ing from */
    /* WinSock. Offset the address of the caller's buffer by the amount of  */
    /* data copied from the recv buffer.                                    */
    /************************************************************************/
    TRC_ASSERT(((_TD.recvBuffer.dataStart == 0) &&
            (_TD.recvBuffer.dataLength == 0)),
            (TB, _T("About to recv into buffer, but existing recv ")
            _T("length %u, start %u"), _TD.recvBuffer.dataStart,
            _TD.recvBuffer.dataLength));

    // Select the buffer into which we recv the data. This is the recv
    // buffer if all the data required fits into it, the caller's buffer
    // otherwise.
    if (bytesToRecv < _TD.recvBuffer.size) {
        // Caller requires less than the recv buffer size, so attempt to
        // have Winsock fill the recv buffer and copy to the caller's
        // buffer.
        BytesRecv = TDDoWinsockRecv(_TD.recvBuffer.pData, _TD.recvBuffer.size);
        if (BytesRecv != 0) {
            // Successful WinSock recv. Copy data from the recv buffer to the
            // caller's buffer (offset by bytesCopied, the end of the recv
            // buffer copy).
            BytesToCopy = DC_MIN(bytesToRecv, BytesRecv);
            memcpy(pData + bytesCopied, _TD.recvBuffer.pData, BytesToCopy);
            bytesCopied = BytesToCopy;

            // If we copied less than we recv'ed then there is some data left
            // in the recv buffer for next time.
            if (BytesRecv > bytesCopied) {
                _TD.recvBuffer.dataLength = BytesRecv - bytesCopied;
                _TD.recvBuffer.dataStart = bytesCopied;
                TRC_DBG((TB, _T("recv buffer now has %u bytes starting %u"),
                        _TD.recvBuffer.dataLength, _TD.recvBuffer.dataStart));
            }

            TRC_DBG((TB, _T("%u bytes read to recv buffer, %u copied to caller ")
                    _T("still need %u"), BytesRecv, bytesCopied,
                    bytesToRecv - bytesCopied));
        }
        else {
            TRC_DBG((TB, _T("Didn't receive any data")));
            bytesCopied = 0;
        }

        TRC_DBG((TB, _T("%u bytes in recv buffer starting %u"),
                _TD.recvBuffer.dataLength, _TD.recvBuffer.dataStart));
    }
    else {
        // Caller requires more than the recv buffer size, so attempt to
        // have Winsock fill the caller's buffer.
        bytesCopied = TDDoWinsockRecv(pData + bytesCopied, bytesToRecv);
        TRC_DBG((TB, _T("Read %u bytes to caller's buffer, still need %u"),
                bytesCopied, bytesToRecv - bytesCopied));
    }

    /************************************************************************/
    /* Update the number of bytes to receive.                               */
    /************************************************************************/
    bytesToRecv -= bytesCopied;

DC_EXIT_POINT:
    /************************************************************************/
    /* If we have received more than the maximum we allow without resetting */
    /* the data available flag OR we didn't get all the bytes we requested  */
    /* then we can't allow TD to continue reporting data available.         */
    /************************************************************************/
    if (bytesToRecv != 0 || _TD.recvByteCount >= TD_MAX_UNINTERRUPTED_RECV) {
        // We didn't get all the bytes that we wanted, or we have received
        // more than TD_MAX_UNINTERRUPTED_RECV so need to get back to the
        // message loop.  So, update our global data available flag and
        // reset the per-FD_READ byte count.
        TRC_DBG((TB, _T("Only got %u bytes of %u requested, total %u"),
                 size - bytesToRecv, size, _TD.recvByteCount));

        _TD.dataInTD = FALSE;
        _TD.recvByteCount = 0;
    }

    DC_END_FN();
    return (size - bytesToRecv);
} /* TD_Recv */


/****************************************************************************/
/* Name:      TDDoWinsockRecv                                               */
/*                                                                          */
/* Purpose:   Wrapper round the WinSock recv function which handles any     */
/*            errors returned.                                              */
/*                                                                          */
/* Returns:   The number of bytes copied.                                   */
/*                                                                          */
/* Params:    IN  pData - pointer to buffer to receive the data.            */
/*            IN  bytesToRecv - number of bytes to receive.                 */
/****************************************************************************/
unsigned DCINTERNAL CTD::TDDoWinsockRecv(BYTE FAR *pData, unsigned bytesToRecv)
{
    unsigned bytesReceived;
    int WSAErr;

    DC_BEGIN_FN("TDDoWinsockRecv");

    // Check that we are requesting some bytes. This will work if we ask
    // for zero bytes, but it implies there is a flaw in the logic.
    TRC_ASSERT((bytesToRecv != 0), (TB, _T("Requesting recv of 0 bytes")));

    // In the debug build we can constrain the amount of data received,
    // to simulate low-bandwidth scenarios.
#ifdef DC_NLTEST
#pragma message("NL Test code compiled in")
    bytesToRecv = 1;

#elif DC_DEBUG
    // Calculate how many bytes we can receive and then decrement the count
    // of bytes left to send in this period.
    if (0 != _TD.hThroughputTimer) {
        bytesToRecv = (unsigned)DC_MIN(bytesToRecv, _TD.periodRecvBytesLeft);
        _TD.periodRecvBytesLeft -= bytesToRecv;

        if (0 == bytesToRecv) {
            // We won't recv any data, but still need to make the call to
            // ensure the FD_READ messages keep flowing.
            TRC_ALT((TB, _T("constrained READ bytes")));
        }

        TRC_DBG((TB, _T("periodRecvBytesLeft:%u"), _TD.periodRecvBytesLeft));
    }
#endif

#ifdef OS_WINCE
    // Check to see we already called WinSock recv() for this FD_READ.
    if (_TD.enableWSRecv) {
        // set enableWSRecv to FALSE to indicate that we performed a recv()
        // call for this FD_READ.
        _TD.enableWSRecv = FALSE;
#endif // OS_WINCE

        //
        // Try to get bytesToRecv bytes from WinSock.
        //
        bytesReceived = (unsigned)recv(_TD.hSocket, (char *)pData,
            (int)bytesToRecv, 0);

        // Do any necessary error handling. We are OK if no error or if the
        // error is WOULDBLOCK (or INPROGRESS on CE).
        if (bytesReceived != SOCKET_ERROR) {
            // Successful WinSock recv.
            TRC_DBG((TB, _T("Requested %d bytes, got %d"),
                     bytesToRecv, bytesReceived));

            // Update the performance counter.
            PRF_ADD_COUNTER(PERF_BYTES_RECV, bytesReceived);

            // Add this lot of data to the total amount received since last
            // resetting the counter, ie since we last returned to the
            // message loop.
            _TD.recvByteCount += bytesReceived;
        }
        else {
            WSAErr = WSAGetLastError();

#ifndef OS_WINCE
            if (WSAErr == WSAEWOULDBLOCK) {
#else
            if (WSAErr == WSAEWOULDBLOCK || WSAErr == WSAEINPROGRESS) {
#endif

                // On a blocking call, we simply set received length to zero and
                // continue.
                bytesReceived = 0;
            }
            else {
                // Zero bytes received on error.
                bytesReceived = 0;

                // Call the FSM to begin disconnect processing.
                TRC_ERR((TB, _T("Error on call to recv, rc:%d"), WSAErr));
                TDConnectFSMProc(TD_EVT_ERROR,
                        NL_MAKE_DISCONNECT_ERR(NL_ERR_TDONCALLTORECV));

                TRC_ALT((TB, _T("WinSock recv error")));
            }
        }

#ifdef OS_WINCE
    }
    else {
        // recv is called once for this FD_READ.
        TRC_DBG((TB, _T("recv() already called.")));
        bytesReceived = 0;
    }
#endif // OS_WINCE

    DC_END_FN();
    return bytesReceived;
}


#ifdef DC_DEBUG
/****************************************************************************/
/* Name:      TD_GetNetworkThroughput                                       */
/*                                                                          */
/* Purpose:   Get the current network throughput setting.                   */
/*                                                                          */
/* Returns:   Current network throughput.                                   */
/****************************************************************************/
DCUINT32 DCAPI CTD::TD_GetNetworkThroughput(DCVOID)
{
    DCUINT32 retVal;

    DC_BEGIN_FN("TD_GetNetworkThroughput");

    /************************************************************************/
    /* Calculate the actual throughput.  This is the                        */
    /************************************************************************/
    retVal = _TD.currentThroughput * (1000 / TD_THROUGHPUTINTERVAL);

    TRC_NRM((TB, _T("Returning network throughput of:%lu"), retVal));

    DC_END_FN();
    return(retVal);
} /* TD_GetNetworkThroughput */


/****************************************************************************/
/* Name:      TD_SetNetworkThroughput                                       */
/*                                                                          */
/* Purpose:   Sets the network throughput.  This is the number of bytes     */
/*            that can be passed into or out of the network layer per       */
/*            second.  For example setting this to 3000 is roughly          */
/*            equivalent to a 24000bps modem connection.                    */
/*                                                                          */
/* Params:    throughput - the number of bytes to be allowed into and out   */
/*                         of the network layer per second.                 */
/****************************************************************************/
DCVOID DCAPI CTD::TD_SetNetworkThroughput(DCUINT32 throughput)
{
    DC_BEGIN_FN("TD_SetNetworkThroughput");

    /************************************************************************/
    /* Check to determine if the throughput throttling has been enabled     */
    /* or disabled.                                                         */
    /************************************************************************/
    if (0 == throughput)
    {
        /********************************************************************/
        /* Throughput throttling has been disabled so kill the throughput   */
        /* timer.                                                           */
        /********************************************************************/
        TRC_ALT((TB, _T("Throughput throttling disabled")));

        if (_TD.hThroughputTimer != 0)
        {
            TRC_NRM((TB, _T("Kill throttling timer")));
            KillTimer(_TD.hWnd, TD_THROUGHPUTTIMERID);
            _TD.hThroughputTimer = 0;
        }

        _TD.currentThroughput = 0;
    }
    else
    {
        /********************************************************************/
        /* Throughput throttling has been enabled so update the throughput  */
        /* byte counts and set the timer.                                   */
        /********************************************************************/
        _TD.currentThroughput   = (throughput * TD_THROUGHPUTINTERVAL) / 1000;
        _TD.periodSendBytesLeft = _TD.currentThroughput;
        _TD.periodRecvBytesLeft = _TD.currentThroughput;

        _TD.hThroughputTimer = SetTimer(_TD.hWnd,
                                       TD_THROUGHPUTTIMERID,
                                       TD_THROUGHPUTINTERVAL,
                                       NULL);

        TRC_ALT((TB, _T("Throughput throttling enabled interval:%u"),
                 throughput));
    }

    DC_END_FN();
} /* TD_SetNetworkThroughput */

#endif /* DC_DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\wtdint.cpp ===
/****************************************************************************/
// wtdint.cpp
//
// Transport driver - Windows specific internal functions.
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_FILE "wtdint"
#define TRC_GROUP TRC_GROUP_NETWORK
#include <atrcapi.h>
}

#include "autil.h"
#include "td.h"
#include "xt.h"
#include "nl.h"
#include "wui.h"
#include "objs.h"

/****************************************************************************/
/* Name:      TDInit                                                        */
/*                                                                          */
/* Purpose:   Initializes _TD.  This function allocates the send buffers,    */
/*            creates the TD window and then initializes WinSock.           */
/*                                                                          */
/* Operation: On error this function calls the UT fatal error handler.      */
/****************************************************************************/
DCVOID DCINTERNAL CTD::TDInit(DCVOID)
{
    DCUINT   i;
    DCUINT   pubSndBufSizes[TD_SNDBUF_PUBNUM] = TD_SNDBUF_PUBSIZES;
    DCUINT   priSndBufSizes[TD_SNDBUF_PRINUM] = TD_SNDBUF_PRISIZES;
    WORD     versionRequested;
    WSADATA  wsaData;
    int      intRC;

    DC_BEGIN_FN("TDInit");

    /************************************************************************/
    /* Allocate a buffer into which data will be recieved from Winsock.     */
    /************************************************************************/
    _TD.recvBuffer.pData = (PDCUINT8)UT_Malloc( _pUt, TD_RECV_BUFFER_SIZE);
    if (NULL != _TD.recvBuffer.pData)
    {
        // Got the buffer memory. Record the buffer size. Note we need to
        // record slightly less than the allocated size to account for
        // the fact that the current MPPC decompression code looks ahead one
        // byte, which means that a fault can occur if this lookahead goes
        // over the page boundary of this buffer. Leaving a couple of bytes
        // at the end of the buffer prevents this. This does not seriously
        // affect decoding efficiency -- the server itself sends less than
        // a full 8K buffer per send.
        TRC_NRM((TB, _T("Allocated %u bytes for recv buffer"),
                 TD_RECV_BUFFER_SIZE));
        _TD.recvBuffer.size = TD_RECV_BUFFER_SIZE - 2;
    }
    else
    {
        /********************************************************************/
        /* Didn't get the memory. We can live without it, just keep the     */
        /* size set at zero.                                                */
        /********************************************************************/
        TRC_ALT((TB, _T("Failed to alloc %u bytes for recv buffer"),
                 TD_RECV_BUFFER_SIZE));
    }

    /************************************************************************/
    /* Now loop through the public send buffer array and initialize the     */
    /* array members.                                                       */
    /************************************************************************/
    for (i = 0; i < TD_SNDBUF_PUBNUM; i++)
    {
        /********************************************************************/
        /* Initialize the buffer information structure and allocate memory  */
        /* for the actual buffer.                                           */
        /********************************************************************/
        TDInitBufInfo(&_TD.pubSndBufs[i]);
        TDAllocBuf(&_TD.pubSndBufs[i], pubSndBufSizes[i]);

        TRC_DBG((TB, _T("Initialised public buffer:%u size:%u"),
                 i,
                 pubSndBufSizes[i]));
    }

    /************************************************************************/
    /* Loop through the private send buffer array and initialize the array  */
    /* members.                                                             */
    /************************************************************************/
    for (i = 0; i < TD_SNDBUF_PRINUM; i++)
    {
        /********************************************************************/
        /* Initialize the buffer.                                           */
        /********************************************************************/
        TDInitBufInfo(&_TD.priSndBufs[i]);
        TDAllocBuf(&_TD.priSndBufs[i], priSndBufSizes[i]);

        TRC_DBG((TB, _T("Initialised private buffer:%u size:%u"),
                 i,
                 priSndBufSizes[i]));
    }

    /************************************************************************/
    /* Create the TD window.                                                */
    /************************************************************************/
    TDCreateWindow();

#ifdef OS_WINCE
#if (_WIN32_WCE > 300)
    if (NULL == (_TD.hevtAddrChange = CreateEvent(NULL, TRUE, FALSE, NULL)))
    {
        TRC_ABORT((TB, _T("Failed to create addr change notify event:%d"), GetLastError()));
        _pUi->UI_FatalError(DC_ERR_OUTOFMEMORY);
        DC_QUIT;
    }
#endif
#endif

    /************************************************************************/
    /* We want to use version 1.1 of WinSock.                               */
    /************************************************************************/
    versionRequested = MAKEWORD(1, 1);

    /************************************************************************/
    /* Initialize WinSock.                                                  */
    /************************************************************************/
    intRC = WSAStartup(versionRequested, &wsaData);

    if (intRC != 0)
    {
        /********************************************************************/
        // Trace out the error code - note that we can't use WSAGetLastError
        // at this point as WinSock has failed to initialize and so
        // WSAGetLastError will just fail.
        /********************************************************************/
        TRC_ABORT((TB, _T("Failed to initialize WinSock rc:%d"), intRC));
        _pUi->UI_FatalError(DC_ERR_WINSOCKINITFAILED);
        DC_QUIT;
    }

    /************************************************************************/
    /* Now confirm that this WinSock supports version 1.1.  Note that if    */
    /* the DLL supports versions greater than 1.1 in addition to 1.1 then   */
    /* it will still return 1.1 in the version information as that is the   */
    /* version requested.                                                   */
    /************************************************************************/
    if ((LOBYTE(wsaData.wVersion) != 1) ||
        (HIBYTE(wsaData.wVersion) != 1))
    {
        /********************************************************************/
        /* Oops - this WinSock doesn't support version 1.1.                 */
        /********************************************************************/
        WSACleanup();

        TRC_ABORT((TB, _T("This WinSock doesn't support version 1.1")));
        _pUi->UI_FatalError(DC_ERR_WINSOCKINITFAILED);
        DC_QUIT;
    }

    TRC_NRM((TB, _T("WinSock init version %u:%u"),
             HIBYTE(wsaData.wVersion),
             LOBYTE(wsaData.wVersion)));

    TRC_NRM((TB, _T("TD successfully initialized")));

DC_EXIT_POINT:
    DC_END_FN();
} /* TDInit */


/****************************************************************************/
/* Name:      TDTerm                                                        */
/*                                                                          */
/* Purpose:   Terminates _TD.  It frees the send buffers, cleans up WinSock, */
/*            destroys the TD window and then unregisters the TD window     */
/*            class.                                                        */
/****************************************************************************/
DCVOID DCINTERNAL CTD::TDTerm(DCVOID)
{
    DCUINT i;
    int    intRC;

    DC_BEGIN_FN("TDTerm");

    /************************************************************************/
    /* Loop through the public and private send buffers and free the        */
    /* memory.                                                              */
    /************************************************************************/
    for (i = 0; i < TD_SNDBUF_PUBNUM; i++)
    {
        UT_Free( _pUt, _TD.pubSndBufs[i].pBuffer);
    }

    for (i = 0; i < TD_SNDBUF_PRINUM; i++)
    {
        UT_Free( _pUt, _TD.priSndBufs[i].pBuffer);
    }

    /************************************************************************/
    /* Cleanup WinSock.                                                     */
    /************************************************************************/
    intRC = WSACleanup();

    if (SOCKET_ERROR == intRC)
    {
        TRC_ALT((TB, _T("Failed to cleanup WinSock:%d"), WSAGetLastError()));
    }

#ifdef OS_WINCE
#if (_WIN32_WCE > 300)
    TRC_ASSERT((_TD.hevtAddrChange), (TB, _T("hevtAddrChange  is null")));

	CloseHandle(_TD.hevtAddrChange);
    _TD.hevtAddrChange = NULL;
#endif
#endif

    /************************************************************************/
    /* Destroy the window.                                                  */
    /************************************************************************/
    intRC = DestroyWindow(_TD.hWnd);
    _TD.hWnd = NULL;

    if (0 == intRC)
    {
        TRC_SYSTEM_ERROR("Destroy Window");
    }

    /************************************************************************/
    /* Unregister the class.                                                */
    /************************************************************************/
    UnregisterClass(TD_WNDCLASSNAME, _pUi->UI_GetInstanceHandle());

    /************************************************************************/
    /* Release the recv buffer (if allocated).                              */
    /************************************************************************/
    if (0 != _TD.recvBuffer.size)
    {
        TRC_ASSERT((!IsBadWritePtr(_TD.recvBuffer.pData, _TD.recvBuffer.size)),
                   (TB, _T("recv buffer %p size %u is invalid"),
                    _TD.recvBuffer.pData,
                    _TD.recvBuffer.size));

        UT_Free( _pUt, _TD.recvBuffer.pData);
        _TD.recvBuffer.pData = NULL;
    }

    TRC_NRM((TB, _T("TD successfully terminated")));

    DC_END_FN();
} /* TDTerm */


LRESULT CALLBACK CTD::StaticTDWndProc(HWND   hwnd,
                           UINT   message,
                           WPARAM wParam,
                           LPARAM lParam)
{
    CTD* pTD = (CTD*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(WM_CREATE == message)
    {
        //pull out the this pointer and stuff it in the window class
        LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
        pTD = (CTD*)lpcs->lpCreateParams;

        SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)pTD);
    }
    
    //
    // Delegate the message to the appropriate instance
    //

    return pTD->TDWndProc(hwnd, message, wParam, lParam);
}



/****************************************************************************/
/* Name:      TDWndProc                                                     */
/*                                                                          */
/* Purpose:   The TD window procedure.                                      */
/*                                                                          */
/* Params:    See Windows documentation.                                    */
/****************************************************************************/
LRESULT CALLBACK CTD::TDWndProc(HWND   hWnd,
                           UINT   uMsg,
                           WPARAM wParam,
                           LPARAM lParam)
{
    LRESULT rc = 0;
    WORD    eventWSA;
    WORD    errorWSA;
    u_long  address;

    DC_BEGIN_FN("TDWndProc");

    // Trace the interesting parameters.
    TRC_DBG((TB, _T("uMsg:%u wP:%u lP:%lu"), uMsg, wParam, lParam));

    // Special-case FD_READ (most important) and FD_WRITE (happens often).
    if (uMsg == TD_WSA_ASYNC) {
        if (WSAGETSELECTEVENT(lParam) == FD_READ) {
            TRC_DBG((TB, _T("FD_READ recvd")));

            // Check for an error.
            if (WSAGETSELECTERROR(lParam) == 0) {
                // If we're no longer connected, we just ignore the data.
                if (_TD.fsmState == TD_ST_CONNECTED) {
                    // There is now some data available so set the
                    // global variable.
                    _TD.dataInTD = TRUE;

#ifdef OS_WINCE
                    // Enable Winsock receive. We perform only one
                    // WinSock recv per FD_READ.
                    TD_EnableWSRecv();
#endif // OS_WINCE

                    // Tell XT.
                    _pXt->XT_OnTDDataAvailable();
                }
                else {
                    TRC_NRM((TB, _T("FD_READ when not connected")));
                }
            }
            else {
                TRC_ALT((TB, _T("WSA_ASYNC error:%hu"),
                        WSAGETSELECTERROR(lParam)));
            }

            DC_QUIT;
        }
        else if (WSAGETSELECTEVENT(lParam) == FD_WRITE) {
            TRC_NRM((TB, _T("FD_WRITE received")));

            // Check for an error.
            if (WSAGETSELECTERROR(lParam) == 0) {
                // Make sure we're still connected.
                if (_TD.fsmState == TD_ST_CONNECTED) {
                    // We're on the receiver thread, notify sender
                    // thread to flush the send queue.


                    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                            CD_NOTIFICATION_FUNC(CTD,TDFlushSendQueue), 0);

                    // Call up to XT to inform the higher layers
                    // that the back pressure situation has been
                    // relieved.
                    _pXt->XT_OnTDBufferAvailable();
                }
                else {
                    TRC_ALT((TB, _T("FD_WRITE when not connected")));
                }
            }
            else {
                TRC_ALT((TB, _T("WSA_ASYNC error:%hu"),
                        WSAGETSELECTERROR(lParam)));
            }

            DC_QUIT;
        }
    }
    
    // Now switch on the message type for other messages.
    switch (uMsg) {
        case WM_TIMER:
            /****************************************************************/
            /* Check that the ID of the timer is as expected.               */
            /****************************************************************/
            if (TD_TIMERID == wParam)
            {
                /************************************************************/
                /* OK it is our connection time out timer, so call the      */
                /* state machine.                                           */
                /************************************************************/
                TRC_NRM((TB, _T("WM_TIMER recvd")));
                TDConnectFSMProc(TD_EVT_WMTIMER,
                                 NL_MAKE_DISCONNECT_ERR(NL_ERR_TDTIMEOUT));
            }
#ifdef DC_DEBUG
            else if (TD_THROUGHPUTTIMERID == wParam)
            {
                /************************************************************/
                /* This is the throughput throttling timer.  Reset the      */
                /* byte counts.                                             */
                /************************************************************/
                TRC_DBG((TB, _T("Throughput timer, reset byte counts to:%u"),
                         _TD.currentThroughput));
                _TD.periodSendBytesLeft = _TD.currentThroughput;
                _TD.periodRecvBytesLeft = _TD.currentThroughput;

                /************************************************************/
                /* If we're connected then generate FD_READ and FD_WRITE    */
                /* messages to get the network layer running along.         */
                /************************************************************/
                if (TD_ST_CONNECTED == _TD.fsmState)
                {
                    PostMessage(_TD.hWnd,
                                TD_WSA_ASYNC,
                                (WPARAM)0,
                                (LPARAM)MAKELONG(FD_READ, 0));
                    PostMessage(_TD.hWnd,
                                TD_WSA_ASYNC,
                                (WPARAM)0,
                                (LPARAM)MAKELONG(FD_WRITE, 0));
                }
            }
#endif /* DC_DEBUG */
            else
            {
                TRC_ALT((TB, _T("Unexpected timer message id:%u"), wParam));
            }
            break;


        case TD_WSA_ASYNC:
            /****************************************************************/
            /* We've received a WSAAsyncSelect() FD_x notification message. */
            /* Parse the message to extract the FD_ value and error value   */
            /* (if there is one).                                           */
            /****************************************************************/
            eventWSA = WSAGETSELECTEVENT(lParam);
            errorWSA = WSAGETSELECTERROR(lParam);

            TRC_DBG((TB, _T("WSA_ASYNC event:%#hx error:%hu"),
                     eventWSA,
                     errorWSA));

            /****************************************************************/
            /* Everything is OK so now switch on the event.                 */
            /****************************************************************/
            switch (eventWSA) {

                case FD_CONNECT:
                    TRC_NRM((TB, _T("FD_CONNECT recvd")));
                    /********************************************************/
                    /* Under some circumstances, we can receive FD_CONNECT  */
                    /* for a socket which we have lost interest in.         */
                    /********************************************************/
                    if (wParam != _TD.hSocket)
                    {
                        TRC_ALT((TB, _T("FD_CONNECT for socket %d, using %d"),
                                wParam, _TD.hSocket));
                        DC_QUIT;
                    }

                    /********************************************************/
                    /* Check for an error.                                  */
                    /********************************************************/
                    if (0 != errorWSA)
                    {
                        TRC_ALT((TB, _T("WSA_ASYNC error:%hu"), errorWSA));
                        TDConnectFSMProc(TD_EVT_ERROR,
                           NL_MAKE_DISCONNECT_ERR(NL_ERR_TDSKTCONNECTFAILED));
                        DC_QUIT;
                    }

                    /********************************************************/
                    /* Advance the state machine.                           */
                    /********************************************************/
                    TDConnectFSMProc(TD_EVT_OK, 0);
                    break;


                case FD_CLOSE:
                {
                    DCBOOL keepOnReceiving = TRUE;
                    int    intRC;

                    TRC_NRM((TB, _T("FD_CLOSE recvd")));

                    /********************************************************/
                    /* Check for the remote system aborting the connection. */
                    /********************************************************/
                    if (0 != errorWSA)
                    {
                        /****************************************************/
                        /* The server sends a TCP RST instead of a FIN,     */
                        /* even when a clean disconnection is made.         */
                        /* However, this is handled by the UI (see          */
                        /* UIGoDisconnected).                                 */
                        /****************************************************/
                        TRC_ALT((TB, _T("Abortive server close:%hu"), errorWSA));

                        TDConnectFSMProc(TD_EVT_ERROR,
                                    NL_MAKE_DISCONNECT_ERR(NL_ERR_TDFDCLOSE));

                        DC_QUIT;
                    }

                    /********************************************************/
                    /* If we get here then this a response to a graceful    */
                    /* close (i.e. we made a call to shutdown(SD_SEND)      */
                    /* earlier).                                            */
                    /*                                                      */
                    /* All of the data should have already been read from   */
                    /* the socket before WinSock posted the FD_CLOSE, but   */
                    /* to be safe we loop on recv.                          */
                    /********************************************************/
                    while (keepOnReceiving)
                    {
                        intRC = recv(_TD.hSocket,
                                     (char *)_TD.priSndBufs[0].pBuffer,
                                     _TD.priSndBufs[0].size,
                                     0);

                        if ((0 == intRC) || (SOCKET_ERROR == intRC))
                        {
                            keepOnReceiving = FALSE;
                            TRC_ALT((TB, _T("No more data in WS (rc:%d)"),
                                     intRC));
                        }
                        else
                        {
                            TRC_ALT((TB, _T("Throwing away %d bytes from WS"),
                                     intRC));
                        }
                    }

                    /********************************************************/
                    /* Finally call the FSM.                                */
                    /********************************************************/
                    TDConnectFSMProc(TD_EVT_OK, NL_DISCONNECT_LOCAL);
                }
                break;


                default:
                    TRC_ALT((TB, _T("Unknown FD event %hu recvd"), eventWSA));
                    break;
            }
            break;


        case TD_WSA_GETHOSTBYNAME:
            /****************************************************************/
            /* We've received the result of a WSAAsyncGetHostByName         */
            /* operation.  Split the message apart and call the FSM.        */
            /****************************************************************/
            errorWSA = WSAGETASYNCERROR(lParam);

            if (0 != errorWSA)
            {
                TRC_ALT((TB, _T("GHBN failed:%hu"), errorWSA));

                /************************************************************/
                /* Call the state machine with the error event.             */
                /************************************************************/
                TDConnectFSMProc(TD_EVT_ERROR,
                                 NL_MAKE_DISCONNECT_ERR(NL_ERR_TDGHBNFAILED));
                break;
            }

            /****************************************************************/
            /* Now get the primary interface address.                       */
            /****************************************************************/
            address = *((u_long DCPTR)
                  (((struct hostent DCPTR)_TD.priSndBufs[0].pBuffer)->h_addr));

            TRC_ASSERT((address != 0),
                       (TB, _T("GetHostByName returned success but 0 address")));

            TRC_NRM((TB, _T("GHBN - address is:%#lx"), address));

            TDConnectFSMProc(TD_EVT_OK, (DCUINT32)address);
            break;

#if (defined(OS_WINCE) && (_WIN32_WCE > 300))
        case TD_WSA_NETDOWN:
            TRC_NRM((TB, _T("TD_WSA_NETDOWN recvd")));
            TDConnectFSMProc(TD_EVT_ERROR, NL_MAKE_DISCONNECT_ERR(NL_ERR_TDONCALLTOSEND));
            break;
#endif
        default:
            rc = DefWindowProc(hWnd, uMsg, wParam, lParam);
            break;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
} /* TDWndProc */


/****************************************************************************/
/* Name:      TDCreateWindow                                                */
/*                                                                          */
/* Purpose:   Creates the TD window.  This function registers the TD        */
/*            window class and then creates a window of that class.  On     */
/*            error it calls UI_FatalError.                                 */
/****************************************************************************/
DCVOID DCINTERNAL CTD::TDCreateWindow(DCVOID)
{
    WNDCLASS wc;
    WNDCLASS tmpWndClass;
    ATOM     intRC;

    DC_BEGIN_FN("TDCreateWindow");

    if(!GetClassInfo(_pUi->UI_GetInstanceHandle(),TD_WNDCLASSNAME, &tmpWndClass))
    {
        /************************************************************************/
        /* Fill in the class structure.                                         */
        /************************************************************************/
        wc.style         = 0;
        wc.lpfnWndProc   = StaticTDWndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = sizeof(void*); //for instance pointer
        wc.hInstance     = _pUi->UI_GetInstanceHandle();
        wc.hIcon         = NULL;
        wc.hCursor       = NULL;
        wc.hbrBackground = NULL;
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = TD_WNDCLASSNAME;
    
        /************************************************************************/
        /* Register the class used by the TD window.                            */
        /************************************************************************/
        intRC = RegisterClass(&wc);

        if (0 == intRC)
        {
            TRC_ERR((TB, _T("Failed to register WinSock window class")));
            _pUi->UI_FatalError(DC_ERR_CLASSREGISTERFAILED);
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* Now create the window.                                               */
    /************************************************************************/
    _TD.hWnd = CreateWindow(TD_WNDCLASSNAME,        /* class name            */
                           NULL,                   /* window title          */
                           0,                      /* window style          */
                           0,                      /* x-pos                 */
                           0,                      /* y-pos                 */
                           0,                      /* width                 */
                           0,                      /* height                */
                           NULL,                   /* parent                */
                           NULL,                   /* menu                  */
                           _pUi->UI_GetInstanceHandle(), /* instance              */
                           this);                  /* ptr to creation data  */

    if (NULL == _TD.hWnd)
    {
        TRC_ERR((TB, _T("Failed to create TD window")));
        _pUi->UI_FatalError(DC_ERR_WINDOWCREATEFAILED);
        DC_QUIT;
    }

    TRC_NRM((TB, _T("Created window:%p"), _TD.hWnd));

DC_EXIT_POINT:
    DC_END_FN();
} /* TDCreateWindow */


/****************************************************************************/
/* Name:      TDBeginDNSLookup                                              */
/*                                                                          */
/* Purpose:   Starts the address resolution process.  On error this         */
/*            function calls into the state machine with an error code.     */
/*                                                                          */
/* Params:    IN  pServerAddress - pointer to the server address name.      */
/****************************************************************************/
DCVOID DCINTERNAL CTD::TDBeginDNSLookup(PDCACHAR pServerAddress)
{
    DC_BEGIN_FN("TDBeginDNSLookup");

    /************************************************************************/
    /* This is an asynchronous operation and will result in us getting a    */
    /* callback sometime later.  We need to provide a buffer which can be   */
    /* filled in with DNS information, so we make use of the first private  */
    /* send buffer.                                                         */
    /************************************************************************/
    TRC_ASSERT((_TD.priSndBufs[0].size >= MAXGETHOSTSTRUCT),
         (TB, _T("Private snd buf size (%u) too small for DNS lookup (need:%u)"),
          _TD.priSndBufs[0].size,
          MAXGETHOSTSTRUCT));

    /************************************************************************/
    /* Issue the call.                                                      */
    /************************************************************************/
    _TD.hGHBN = WSAAsyncGetHostByName(_TD.hWnd,
                                     TD_WSA_GETHOSTBYNAME,
                                     pServerAddress,
                                     (char DCPTR) _TD.priSndBufs[0].pBuffer,
                                     MAXGETHOSTSTRUCT);
    if (0 == _TD.hGHBN)
    {
        /********************************************************************/
        /* We failed to initiate the operation - so find out what went      */
        /* wrong.                                                           */
        /********************************************************************/
        TRC_ALT((TB, _T("Failed to initiate GetHostByName - GLE:%d"),
                 WSAGetLastError()));

        /********************************************************************/
        /* Call the state machine with an error.                            */
        /********************************************************************/
        TDConnectFSMProc(TD_EVT_ERROR,
                         NL_MAKE_DISCONNECT_ERR(NL_ERR_TDDNSLOOKUPFAILED));
        DC_QUIT;
    }

    TRC_NRM((TB, _T("Initiated GetHostByName OK")));

DC_EXIT_POINT:
    DC_END_FN();
} /* TDBeginDNSLookup */


/****************************************************************************/
/* Name:      TDBeginSktConnectWithConnectedEndpoint                        */
/*                                                                          */
/* Purpose:   Establish connection with server already connect              */
/*            on some socket                                                */
/*                                                                          */
/* Params:                                                                  */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL CTD::TDBeginSktConnectWithConnectedEndpoint()
{
    DCBOOL      failure = FALSE;
#ifndef OS_WINCE
    int         lastError;
#endif
    int         intRC;

    DC_BEGIN_FN("TDBeginSktConnectWithConnectedEndpoint");

    /************************************************************************/
    /* Socket already connect, setup FD_XXX event with our window           */
    /* we are assuming mstscax client already make necessary error checking */
    /************************************************************************/
    _TD.hSocket = _pUi->UI_GetTDSocket();

    TRC_ASSERT( 
        (_TD.hSocket != INVALID_SOCKET), 
        (TB, _T("Connected socket not setup properly")) );

    if( INVALID_SOCKET == _TD.hSocket )
    {
        failure = TRUE;
        DC_QUIT;
    }

    /************************************************************************/
    /* Set the required options on this socket.  We do the following:       */
    /*                                                                      */
    /*  - disable the NAGLE algorithm.                                      */
    /*  - enable the don't linger option.  This means the closesocket call  */
    /*    will return immediately while any data queued for transmission    */
    /*    will be sent, if possible, before the underlying socket is        */
    /*    closed.                                                           */
    /*                                                                      */
    /* Note that further options are set when the connection is             */
    /* established.                                                         */
    /************************************************************************/
    TDSetSockOpt(IPPROTO_TCP, TCP_NODELAY,   1);
    TDSetSockOpt(SOL_SOCKET,  SO_DONTLINGER, 1);

    /************************************************************************/
    /* Now request async notifications for all events on this socket.       */
    /************************************************************************/
    intRC = WSAAsyncSelect(_TD.hSocket,
                           _TD.hWnd,
                           TD_WSA_ASYNC,
                           FD_READ | FD_WRITE | FD_CLOSE); 

    if (SOCKET_ERROR == intRC)
    {
        TRC_ERR((TB, _T("Failed to select async - GLE:%d"), WSAGetLastError()));
        failure = TRUE;
        DC_QUIT;
    }

DC_EXIT_POINT:
    if (failure)
    {
        TRC_ALT((TB, _T("Failed to begin socket connection process")));

        /********************************************************************/
        /* Call the FSM.                                                    */
        /********************************************************************/
        TDConnectFSMProc(TD_EVT_ERROR,
                         NL_MAKE_DISCONNECT_ERR(NL_ERR_TDSKTCONNECTFAILED));
    }
    else
    {
        // use existing code path to setup rest.
        PostMessage(_TD.hWnd,
                    TD_WSA_ASYNC,
                    (WPARAM) _TD.hSocket,
                    (LPARAM)MAKELONG(FD_CONNECT, 0));
    }

    DC_END_FN();
} /* TDBeginSktConnectWithConnectedEndpoint */


/****************************************************************************/
/* Name:      TDBeginSktConnect                                             */
/*                                                                          */
/* Purpose:   Issues a connect at the WinSock socket level.                 */
/*                                                                          */
/* Params:    IN  address - the address to call (this is a numeric value    */
/*                          in network (big-endian) byte order).            */
/****************************************************************************/
DCVOID DCINTERNAL CTD::TDBeginSktConnect(u_long address)
{
    DCBOOL      failure = FALSE;
    int         intRC;
    int         lastError;
    SOCKADDR_IN stDstAddr;

    DC_BEGIN_FN("TDBeginSktConnect");

    /************************************************************************/
    /* First of all get a socket.                                           */
    /************************************************************************/
    _TD.hSocket = socket(AF_INET, SOCK_STREAM, 0);

    if (INVALID_SOCKET == _TD.hSocket)
    {
        TRC_ERR((TB, _T("Failed to get a socket - GLE:%d"), WSAGetLastError()));
        DC_QUIT;
    }

    _pUi->UI_SetTDSocket(_TD.hSocket);

    TRC_NRM((TB, _T("Acquired socket:%#x"), _TD.hSocket));

    /************************************************************************/
    /* Set the required options on this socket.  We do the following:       */
    /*                                                                      */
    /*  - disable the NAGLE algorithm.                                      */
    /*  - enable the don't linger option.  This means the closesocket call  */
    /*    will return immediately while any data queued for transmission    */
    /*    will be sent, if possible, before the underlying socket is        */
    /*    closed.                                                           */
    /*                                                                      */
    /* Note that further options are set when the connection is             */
    /* established.                                                         */
    /************************************************************************/
    TDSetSockOpt(IPPROTO_TCP, TCP_NODELAY,   1);
    TDSetSockOpt(SOL_SOCKET,  SO_DONTLINGER, 1);

    /************************************************************************/
    /* Now request async notifications for all events on this socket.       */
    /************************************************************************/
    intRC = WSAAsyncSelect(_TD.hSocket,
                           _TD.hWnd,
                           TD_WSA_ASYNC,
                           FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE);

    if (SOCKET_ERROR == intRC)
    {
        TRC_ERR((TB, _T("Failed to select async - GLE:%d"), WSAGetLastError()));
        failure = TRUE;
        DC_QUIT;
    }

    /************************************************************************/
    /* Now kick off a timer - if the connect does not complete before we    */
    /* get the WM_TIMER message then we'll abort the connection attempt.    */
    /************************************************************************/
/*    _TD.hTimer = TDSetTimer(TD_CONNECTTIMEOUT);

    if (0 == _TD.hTimer)
    {
        failure = TRUE;
        DC_QUIT;
    }
*/
    /************************************************************************/
    /* Fill in the address of the remote system we want to connect to.      */
    /************************************************************************/
    stDstAddr.sin_family      = PF_INET;
    stDstAddr.sin_port        = htons(_pUi->UI_GetMCSPort());
    stDstAddr.sin_addr.s_addr = (u_long) address;

#ifdef OS_WINCE
#if (_WIN32_WCE > 300)
    TRC_ASSERT((_TD.hevtAddrChange), (TB, _T("hevtAddrChange  is null")));
    TRC_ASSERT((_TD.hAddrChangeThread == NULL), (TB, _T("hAddrChangeThread is not null")));
    _TD.hAddrChangeThread = CreateThread(NULL, 0, TDAddrChangeProc, &_TD, 0, NULL);
    if (_TD.hAddrChangeThread == NULL)
    {
        TRC_ERR((TB, _T("CreatThread failed - GLE:%d"), GetLastError()));
        failure = TRUE;
        DC_QUIT;
    }

#endif
#endif

    /************************************************************************/
    /* We're now in a state where we can try to connect to the remote       */
    /* system so issue the connect now.  We expect this call to fail with   */
    /* an error code of WSAEWOULDBLOCK - any other error code is a genuine  */
    /* problem.                                                             */
    /************************************************************************/
    intRC = connect(_TD.hSocket,
                    (struct sockaddr DCPTR) &stDstAddr,
                    sizeof(stDstAddr));

    if (SOCKET_ERROR == intRC)
    {
        /********************************************************************/
        /* Get the last error.                                              */
        /********************************************************************/
        lastError = WSAGetLastError();

        /********************************************************************/
        /* We expect the connect to return an error of WSAEWOULDBLOCK -     */
        /* anything else indicates a genuine error.                         */
        /********************************************************************/
        if (lastError != WSAEWOULDBLOCK)
        {
            TRC_ERR((TB, _T("Connect failed - GLE:%d"), lastError));
            failure = TRUE;
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* We've done as much as we can at this point - all we can do now is    */
    /* wait for the socket connection to complete.                          */
    /************************************************************************/
    TRC_NRM((TB, _T("Waiting for connect to complete...")));

DC_EXIT_POINT:
    if (failure)
    {
        TRC_ALT((TB, _T("Failed to begin socket connection process")));

        /********************************************************************/
        /* Call the FSM.                                                    */
        /********************************************************************/
        TDConnectFSMProc(TD_EVT_ERROR,
                         NL_MAKE_DISCONNECT_ERR(NL_ERR_TDSKTCONNECTFAILED));
    }

    DC_END_FN();
} /* TDBeginSktConnect */


/****************************************************************************/
/* Name:      TDSetSockOpt                                                  */
/*                                                                          */
/* Purpose:   Sets a given WinSock socket option.  Note that this function  */
/*            does not return an error if it fails to set the option as     */
/*            TD can still continue successfully despite failing to set     */
/*            the options to the desired values.                            */
/*                                                                          */
/* Params:    IN level   - the level at which the option is defined (see    */
/*                         docs for setsockopt).                            */
/*            IN optName - the socket option for which the value is to be   */
/*                         set.                                             */
/*            IN value   - the value to set the option to.                  */
/****************************************************************************/
DCVOID DCINTERNAL CTD::TDSetSockOpt(DCINT level, DCINT optName, DCINT value)
{
    int   intRC;
    DCINT size = sizeof(DCINT);
#ifdef DC_DEBUG
    DCINT oldVal;
    DCINT newVal;
#endif /* DC_DEBUG */

    DC_BEGIN_FN("TDSetSockOpt");

#ifdef DC_DEBUG
    /************************************************************************/
    /* For the debug build trace out the current value of the option        */
    /* before setting it.                                                   */
    /************************************************************************/
    getsockopt(_TD.hSocket, level, optName, (char DCPTR) &oldVal, &size);
#endif /* DC_DEBUG */

    /************************************************************************/
    /* Now set the option.                                                  */
    /************************************************************************/
    intRC = setsockopt(_TD.hSocket, level, optName, (char DCPTR) &value, size);

    if (SOCKET_ERROR == intRC)
    {
        TRC_ALT((TB, _T("Failed to set socket option:%d rc:%d (level:%d val:%d)"),
                 optName,
                 WSAGetLastError(),
                 level,
                 value));
        DC_QUIT;
    }

#ifdef DC_DEBUG
    /************************************************************************/
    /* Get the new value of the option.                                     */
    /************************************************************************/
    getsockopt(_TD.hSocket, level, optName, (char DCPTR) &newVal, &size);

    TRC_NRM((TB, _T("Mod socket option %d:%d from %d to %d"),
             level,
             optName,
             oldVal,
             newVal));
#endif /* DC_DEBUG */

DC_EXIT_POINT:
    DC_END_FN();
} /* TDSetSockOpt */


/****************************************************************************/
/* Name:      TDDisconnect                                                  */
/*                                                                          */
/* Purpose:   Disconnects the transport driver.                             */
/****************************************************************************/
DCVOID DCINTERNAL CTD::TDDisconnect(DCVOID)
{
    int intRC;
    SOCKET socket;

    DC_BEGIN_FN("TDDisconnect");

    /************************************************************************/
    /* Kill the timer.                                                      */
    /************************************************************************/
    TDKillTimer();

    /************************************************************************/
    /* Ensure the data-in-TD flag is cleared.                               */
    /************************************************************************/
    _TD.dataInTD = FALSE;

    /************************************************************************/
    /* Cancel the outstanding DNS lookup.  We can't be sure that the async  */
    /* operation has completed already and the message is already sitting   */
    /* on our queue (or being processed by the receive thread).  If that is */
    /* the case then WSACancelAsyncRequest will fail, but it doesn't        */
    /* matter.                                                              */
    /************************************************************************/
    intRC = WSACancelAsyncRequest(_TD.hGHBN);
    if (SOCKET_ERROR == intRC) {
        TRC_NRM((TB, _T("Failed to cancel async DNS request")));
    }

    /************************************************************************/
    /* Decouple to the sender thread and clear the send queue.              */
    /************************************************************************/
    _pCd->CD_DecoupleSyncNotification(CD_SND_COMPONENT, this,
        CD_NOTIFICATION_FUNC(CTD,TDClearSendQueue), 0);

#ifdef OS_WINCE
#if (_WIN32_WCE > 300)
    SetEvent(_TD.hevtAddrChange);

    if (_TD.hAddrChangeThread)
    {
        WaitForSingleObject(_TD.hAddrChangeThread, INFINITE);
        CloseHandle(_TD.hAddrChangeThread);
        _TD.hAddrChangeThread = NULL;
    }
    ResetEvent(_TD.hevtAddrChange);
#endif
#endif

    if (INVALID_SOCKET == _TD.hSocket)
    {
        TRC_NRM((TB, _T("_TD.hSocket is NULL so just quit")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Now close the socket.                                                */
    /************************************************************************/
    TRC_NRM((TB, _T("Close the socket")));

    socket = _TD.hSocket;
    _TD.hSocket = INVALID_SOCKET;
    intRC = closesocket(socket);
    
    if (SOCKET_ERROR == intRC)
    {
        TRC_ALT((TB, _T("closesocket rc:%d"), WSAGetLastError()));
    }

DC_EXIT_POINT:
    
    DC_END_FN();
} /* TDDisconnect */


/****************************************************************************/
/* Name:      TDSetTimer                                                    */
/*                                                                          */
/* Purpose:   Sets the timer.                                               */
/*                                                                          */
/* Returns:   TRUE on success and FALSE otherwise.                          */
/*                                                                          */
/* Params:    IN  timeInterval - the time interval of the timer.            */
/****************************************************************************/
DCBOOL DCINTERNAL CTD::TDSetTimer(DCUINT timeInterval)
{
    DCBOOL rc;

    DC_BEGIN_FN("TDSetTimer");

    /************************************************************************/
    /* Set the timer with the passed time interval.                         */
    /************************************************************************/
    _TD.hTimer = SetTimer(_TD.hWnd, TD_TIMERID, timeInterval, NULL);
    if (_TD.hTimer != 0) {
        // Everything went OK, so set a successful return code.
        rc = TRUE;
        TRC_NRM((TB, _T("Set timer with interval:%u"), timeInterval));
    }
    else {
        TRC_SYSTEM_ERROR("SetTimer");
        rc = FALSE;
    }

    DC_END_FN();
    return rc;
} /* TDSetTimer */


/****************************************************************************/
/* Name:      TDKillTimer                                                   */
/*                                                                          */
/* Purpose:   Cleans up the timer which is used to time-out connect         */
/*            and disconnect attempts.                                      */
/****************************************************************************/
DCVOID DCINTERNAL CTD::TDKillTimer(DCVOID)
{
    BOOL rc;

    DC_BEGIN_FN("TDKillTimer");

    /************************************************************************/
    /* Destroy the connection timeout timer.  If we fail to get rid of this */
    /* timer then there's not much we can do - we'll continue to get        */
    /* WM_TIMER messages which we'll ignore in retail and assert on in the  */
    /* debug version.                                                       */
    /************************************************************************/
    if (_TD.hTimer != 0)
    {
        rc = KillTimer(_TD.hWnd, TD_TIMERID);
        _TD.hTimer = 0;

        TRC_NRM((TB, _T("Timer has %s been killed"), rc ? _T("") : _T(" NOT")));
    }
    else
    {
        TRC_NRM((TB, _T("Timer has not been set")));
    }

    DC_END_FN();
} /* TDKillTimer */


/****************************************************************************/
// TDFlushSendQueue
//
// Tries to send all the packets which are waiting in the send queue.
// Must be called on the sender thread, Can be called through direct calls
// or through a CD_Decouple call.
/****************************************************************************/
void DCINTERNAL CTD::TDFlushSendQueue(ULONG_PTR unused)
{
    DCUINT          bytesSent;
    PTD_SNDBUF_INFO pOldBuf;
    int             bytesToSend;
    DCBOOL          sentABuffer = FALSE;
    int             WSAErr;

    DC_BEGIN_FN("TDFlushSendQueue");

    DC_IGNORE_PARAMETER(unused);

    // Check for rare re-entrancy.
    if (!_TD.inFlushSendQueue) {
        _TD.inFlushSendQueue = TRUE;

        // Check that there are some buffers waiting to be sent.
        if (_TD.pFQBuf != NULL) {
            
            // Run along the send queue and try to send the data.
            // Check for buffers that are inUse because ClearSendQueue could
            // potentially clear some buffers before this call comes in
            //
            while (NULL != _TD.pFQBuf &&
                   _TD.pFQBuf->inUse) {
                // Check that the buffer is in use and that the count of
                // bytes waiting to be sent is more than zero.

                TRC_ASSERT((_TD.pFQBuf->inUse), (TB, _T("Buffer is not in use")));
                TRC_ASSERT((_TD.pFQBuf->bytesLeftToSend > 0),
                           (TB, _T("No bytes waiting to be sent")));

                // Trace out the send buffer information.
                TD_TRACE_SENDINFO(TRC_LEVEL_DBG);

                TRC_DBG((TB, _T("Sending buffer:%p (waiting:%u)"),
                         _TD.pFQBuf,
                         _TD.pFQBuf->bytesLeftToSend));

                // Call WinSock to send the buffer. We expect the call to:
                //  - succeed and send all the bytes requested. In this case
                //    there is little for us to do.
                //  - send some of the bytes we asked to be sent. This
                //    indicates that WinSock is applying back-pressure to us,
                //    so we update our count of bytes sent for this buffer
                //    and then quit. We will get a FD_WRITE later and retry
                //    the send.
                //  - send none of the bytes that we asked to be sent and
                //    return SOCKET_ERROR instead.  We then use
                //    WSAGetLastError to determine why the call failed. If
                //    the reason is WSAEWOULDBLOCK then WinSock has decided
                //    to fail the call due to back-pressure - this is fine
                //    by us, so we just quit. Once again we will get an
                //    FD_WRITE to tell us that back-pressure has been
                //    relieved. Any other reason code is a genuine error
                //    so we decouple a call into the state table with an
                //    error code.
#ifdef DC_DEBUG
                // Calculate how many bytes we can send and then decrement
                // the count of bytes left to send in this period.
                if (0 == _TD.hThroughputTimer) {
                    bytesToSend = (int)_TD.pFQBuf->bytesLeftToSend;
                }
                else {
                    bytesToSend = (int) DC_MIN(_TD.pFQBuf->bytesLeftToSend,
                            _TD.periodSendBytesLeft);
                    TRC_DBG((TB, _T("periodSendBytesLeft:%u"),
                            _TD.periodSendBytesLeft));
                    if (0 == bytesToSend) {
                        TRC_ALT((TB, _T("Constrained SEND network throughput")));
                    }

                    _TD.periodSendBytesLeft -= bytesToSend;
                }
#else
                bytesToSend = (int)_TD.pFQBuf->bytesLeftToSend;
#endif

                bytesSent = (DCUINT)send(_TD.hSocket,
                        (char *)_TD.pFQBuf->pDataLeftToSend, bytesToSend, 0);
                if (SOCKET_ERROR != bytesSent) {
                    TRC_DBG((TB, _T("Sent %u bytes of %u waiting"), bytesSent,
                            _TD.pFQBuf->bytesLeftToSend));

                    // Update the performance counter.
                    PRF_ADD_COUNTER(PERF_BYTES_SENT, bytesSent);

                    // Update the count of bytesWaiting and shuffle the
                    // pointer to the data along as well.
                    _TD.pFQBuf->pDataLeftToSend += bytesSent;
                    _TD.pFQBuf->bytesLeftToSend -= bytesSent;

                    // Check to determine if we managed to send all the data.
                    if (_TD.pFQBuf->bytesLeftToSend == 0) {
                        // We managed to send all the data in this buffer -
                        // so it is no longer in use. Get a pointer to this
                        // buffer.
                        pOldBuf = _TD.pFQBuf;

                        // Now update the head of the send queue with the
                        // next buffer and reset the next field of the buffer
                        // we've just sent.
                        _TD.pFQBuf = pOldBuf->pNext;

                        // Finally update the fields in the old buffer.
                        pOldBuf->pNext           = NULL;
                        pOldBuf->inUse           = FALSE;
                        pOldBuf->pDataLeftToSend = NULL;
                        sentABuffer = TRUE;

                        // Update the performance counter.
                        PRF_INC_COUNTER(PERF_PKTS_FREED);

                        TRC_DBG((TB, _T("Sent buffer completely - move to next")));
                    }
                    else {
                        // We didn't manage to send all the data so trace and
                        // quit.
                        TRC_NRM((TB, _T("Didn't send all data in buffer - quit")));
                        DC_QUIT;
                    }
                }
                else {
                    WSAErr = WSAGetLastError();

                    if (WSAErr == WSAEWOULDBLOCK || WSAErr == WSAENOBUFS) {
                        // WSAEWOULDBLOCK means that the network system is out
                        // of buffer space so we should wait until we receive
                        // a FD_WRITE notification indicating that more buffer
                        // space is available.
                        //
                        // WSAENOBUFS means that no buffer space is available
                        // and indicates a shortage of resources on the
                        // system.
                        bytesSent = 0;
                        PRF_INC_COUNTER(PERF_WINSOCK_SEND_FAIL);
                        TRC_NRM((TB, _T("WinSock send returns WSAEWOULDBLOCK")));

                        // We haven't sent any data, time to get out.
                        DC_QUIT;
                    }
                    else {
                        bytesSent = 0;

                        // If this is not a WSAEWOULDBLOCK and it is not a
                        // WSAENOBUFS error then call the FSM to begin
                        // disconnect processing.

                        // Trace out the buffer structure.
                        TD_TRACE_SENDINFO(TRC_LEVEL_ALT);

                        // We failed to send any data and the socket returned
                        // an error. The connection has probably failed or
                        // ended.
                        TRC_ALT((TB, _T("Failed to send any data, rc:%d"),
                                WSAErr));

                        // Decouple across to the recv side event handler at
                        // this point. It will call the TD FSM.

                        _pCd->CD_DecoupleSimpleNotification(CD_RCV_COMPONENT, this,
                                CD_NOTIFICATION_FUNC(CTD,TDSendError), 0);

                        DC_QUIT;
                    }
                }
            }
        }
        else {
            TRC_NRM((TB, _T("No buffers waiting to be sent")));
        }
    }
    else {
        TRC_ABORT((TB, _T("Re-entered TDFlushSendQueue")));
        goto RealExit;
    }

DC_EXIT_POINT:
    _TD.inFlushSendQueue = FALSE;

    // If we previously failed TD_GetPublicBuffer, and we just
    // succeeded in sending a buffer, call the OnBufferAvailable
    // callbacks now.
    TRC_DBG((TB, _T("Sent a buffer? %d, GetBuffer failed? %d"),
            sentABuffer, _TD.getBufferFailed));
    if (sentABuffer && _TD.getBufferFailed) {
        TRC_NRM((TB, _T("Signal buffer available")));
        _pXt->XT_OnTDBufferAvailable();
        _TD.getBufferFailed = FALSE;
    }

RealExit:
    DC_END_FN();
} /* TDFlushSendQueue */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\wtdint.h ===
/****************************************************************************/
// wtdint.h
//
// Transport driver - Windows specific internal functions.
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/
#ifndef _H_WTDINT
#define _H_WTDINT


#ifdef OS_WINCE
typedef unsigned long u_long;
#endif


/****************************************************************************/
/* Define the window class name.                                            */
/****************************************************************************/
#define TD_WNDCLASSNAME         _T("TDWindowClass")


/****************************************************************************/
/* Define the async message name.                                           */
/****************************************************************************/
#define TD_WSA_ASYNC            (DUC_TD_MESSAGE_BASE + 0)


/****************************************************************************/
/* Define the gethostbyname message name.                                   */
/****************************************************************************/
#define TD_WSA_GETHOSTBYNAME    (DUC_TD_MESSAGE_BASE + 1)

#if (defined(OS_WINCE) && (_WIN32_WCE > 300))
/****************************************************************************/
/* Define the message to handle netdown                                     */
/****************************************************************************/
#define TD_WSA_NETDOWN          (DUC_TD_MESSAGE_BASE + 2)
#endif

/****************************************************************************/
/* Define the connect time-out timer id.                                    */
/****************************************************************************/
#define TD_TIMERID              100


/****************************************************************************/
/* The value of the connect time-out (in milliseconds).                     */
/****************************************************************************/
#define TD_CONNECTTIMEOUT       10000


/****************************************************************************/
/* The value of the disconnect time-out (in milliseconds).                  */
/****************************************************************************/
#define TD_DISCONNECTTIMEOUT    1000


/****************************************************************************/
// WinSock receive and send buffer sizes.
// Receive needs to be tuned to handle general server buffer send.
/****************************************************************************/
#define TD_WSSNDBUFSIZE 4096
#define TD_WSRCVBUFSIZE 8192


#ifdef DC_DEBUG
/****************************************************************************/
/* Throughput timer id and time interval in ms.                             */
/****************************************************************************/
#define TD_THROUGHPUTTIMERID    101
#define TD_THROUGHPUTINTERVAL   100
#endif /* DC_DEBUG */


/****************************************************************************/
/* FUNCTIONS                                                                */
/****************************************************************************/
DCVOID DCINTERNAL TDInit(DCVOID);

DCVOID DCINTERNAL TDTerm(DCVOID);

LRESULT CALLBACK TDWndProc(HWND   hWnd,
                           UINT   uMsg,
                           WPARAM wParam,
                           LPARAM lParam);

//
// Delegates to appropriate TD instance
//
static LRESULT CALLBACK StaticTDWndProc(HWND   hWnd,
                           UINT   uMsg,
                           WPARAM wParam,
                           LPARAM lParam);


DCVOID DCINTERNAL TDCreateWindow(DCVOID);

DCVOID DCINTERNAL TDBeginDNSLookup(PDCACHAR ServerAddress);

DCVOID DCINTERNAL TDBeginSktConnect(u_long Address);

DCVOID DCINTERNAL TDSetSockOpt(DCINT level, DCINT optName, DCINT value);

DCVOID DCINTERNAL TDDisconnect(DCVOID);

DCBOOL DCINTERNAL TDSetTimer(DCUINT timeInterval);

DCVOID DCINTERNAL TDKillTimer(DCVOID);

#ifdef OS_WINCE
static DWORD WINAPI TDAddrChangeProc(LPVOID lpParameter);
#endif
DCVOID DCINTERNAL TDBeginSktConnectWithConnectedEndpoint();

#endif /* _H_WTDINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\wui.h ===
/****************************************************************************/
/* wui.h                                                                    */
/*                                                                          */
/* UI class                                                                 */
/* Serves as the root class of the core. Provides UI functionality.         */
/* (windows and scroll bars)                                                */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1998                             */
/****************************************************************************/

#ifndef _H_WUI
#define _H_WUI

#include <adcgdata.h>
#include <winsock.h>

#if ! defined (OS_WINCE)
#include <ctfutb.h>
#endif

#include "autil.h"
#include "aco.h"
#include "cd.h"
#include "cchan.h"
#include "drapi.h"

#ifdef USE_BBAR
#include "bbar.h"
#endif
#include "arcdlg.h"

class CCLX;
class CTD;
class CCD;
class CUH;

#include "auierr.h"
#include "uidata.h"
#include <wuiids.h>

//
// Disabled feature list (for performance)
//
#include "tsperf.h"

/****************************************************************************/
/* Structure: UI_DATA                                                       */
/*                                                                          */
/* Description: Component data in the User Interface                        */
/****************************************************************************/

#define UI_FILENAME_MAX_LENGTH          15

typedef enum {
    DC_LANG_UNKNOWN,
    DC_LANG_JAPANESE,
    DC_LANG_KOREAN,
    DC_LANG_CHINESE_TRADITIONAL,
    DC_LANG_CHINESE_SIMPLIFIED
} DCLANGID;

//
// From auiapi.h
//

#define UI_SHUTDOWN_SUCCESS 1
#define UI_SHUTDOWN_FAILURE 0

#define UI_MAIN_CLASS        _T("UIMainClass")
#define UI_CONTAINER_CLASS   _T("UIContainerClass")

/****************************************************************************/
/* Constants used to set the 16-bit message queue size. Windows sets a      */
/* limit of 120 and has a default of 8.                                     */
/* We try to set to UI_MAX_MESSAGE_Q_SIZE. If this fails we reduce the      */
/* requested size by UI_DEFAULT_MESSAGE_Q_SIZE. This continues until the    */
/* queue size is set or the requested size drops below                      */
/* UI_MIN_MESSAGE_Q_SIZE.                                                   */
/****************************************************************************/
#define UI_MAX_MESSAGE_Q_SIZE 120
#define UI_MIN_MESSAGE_Q_SIZE 40
#define UI_DEFAULT_MESSAGE_Q_SIZE 8
#define UI_MESSAGE_Q_SIZE_DECREMENT 10

/****************************************************************************/
/* Max size of Window Pos string to be read in                              */
/****************************************************************************/
#define UI_WINDOW_POSITION_STR_LEN           256

#define UI_FRAME_TITLE_RESOURCE_MAX_LENGTH   256
#define UI_DISCONNECT_RESOURCE_MAX_LENGTH    256

#define UI_BUILDNUMBER_STRING_MAX_LENGTH     256
#define UI_VERSION_STRING_MAX_LENGTH         256

#define UI_DISPLAY_STRING_MAX_LENGTH         256

#define UI_INTEGER_STRING_MAX_LENGTH         10

/****************************************************************************/
/*                                                                          */
/****************************************************************************/
#define UI_FONT_SIZE      40
#define UI_FONT_WEIGHT    FW_BOLD
#define UI_FONT_FACENAME  _T("Comic Sans MS")

#define UI_RGB_BLACK  RGB(0x00, 0x00, 0x00)
#define UI_RGB_RED    RGB(0xFF, 0x00, 0x00)
#define UI_RGB_GREEN  RGB(0x00, 0xFF, 0x00)
#define UI_RGB_BLUE   RGB(0x00, 0x00, 0xFF)
#define UI_RGB_WHITE  RGB(0xFF, 0xFF, 0xFF)

#ifdef DC_DEBUG
#define UI_NUMBER_STRING_MAX_LENGTH          ( 18 * sizeof (DCTCHAR) )
#endif /* DC_DEBUG */

/****************************************************************************/
/* UI status constants                                                      */
/****************************************************************************/
#define UI_STATUS_INITIALIZING          1
#define UI_STATUS_DISCONNECTED          2
#define UI_STATUS_CONNECT_PENDING_DNS   3
#define UI_STATUS_CONNECT_PENDING       4
#define UI_STATUS_CONNECTED             5
#define UI_STATUS_PENDING_CONNECTENDPOINT 6

/****************************************************************************/
/* Accelerator passthrough constants                                        */
/****************************************************************************/
#define UI_ACCELERATOR_PASSTHROUGH_ENABLED      1
#define UI_ACCELERATOR_PASSTHROUGH_DISABLED     2

/****************************************************************************/
/* Screen mode constants                                                    */
/****************************************************************************/
#define UI_WINDOWED        1
#define UI_FULLSCREEN      2

/****************************************************************************/
/* Disconnect dialog return codes                                           */
/****************************************************************************/
#define UI_DISCONNECT_RC_NO       0
#define UI_DISCONNECT_RC_YES      1

/****************************************************************************/
/* Scrollbar constants                                                      */
/****************************************************************************/
#define UI_NO_SCROLLBARS      0
#define UI_BOTTOM_SCROLLBAR   1
#define UI_RIGHT_SCROLLBAR    2
#define UI_BOTH_SCROLLBARS    3

/****************************************************************************/
/* Scroll distances.                                                        */
/****************************************************************************/
#define UI_SCROLL_HORZ_PAGE_DISTANCE (_UI.mainWindowClientSize.width / 2);
#define UI_SCROLL_VERT_PAGE_DISTANCE (_UI.mainWindowClientSize.height / 2);
#define UI_SCROLL_LINE_DISTANCE      10
#define UI_SMOOTH_SCROLL_STEP        4

/****************************************************************************/
/* Registry default settings                                                */
/****************************************************************************/
#define UI_NUMBER_FIELDS_TO_READ       6
#define UI_WINDOW_POSITION_INI_FORMAT  _T("%u,%u,%d,%d,%d,%d")

#define UI_ALT_DOWN_MASK 0x8000

/****************************************************************************/
/* Connection timer ID                                                      */
/****************************************************************************/

#define UI_TIMER_OVERALL_CONN          200
#define UI_TIMER_SINGLE_CONN           201
#define UI_TIMER_SHUTDOWN              202
#define UI_TIMER_LICENSING             203
#define UI_TIMER_IDLEINPUTTIMEOUT      204
#define UI_TIMER_BBAR_UNHIDE_TIMERID   205
#define UI_TIMER_DISCONNECT_TIMERID    206

#define UI_WSA_GETHOSTBYNAME           (DUC_UI_MESSAGE_BASE + 1)

#define MIN_MINS_TOIDLETIMEOUT 0       // 0 means no timer
#define MAX_MINS_TOIDLETIMEOUT (4*60)  // 4 hours maximum


//
// Defines time interval allowed between DeactivateAllPDU and a disconnection
// or reconnection (in milliseconds)
//
// Prevents a minor problem if the server sends a deactivate all but then
// doesn't actually disconnect us (e.g can happen if server is powered down).
// The problem is made serious because while we are deactivated there is no
// way to send network traffic so nothing will cause a network disconnect.
// 
// See whistler bug 173679
//
// NOTE: the timeout must be bigger than the shadow timeout as during
// shadow negotiation it is valid for the client to remain in the
// deactivated state for 60 seconds.
//
#define UI_TOTAL_DISCONNECTION_TIMEOUT    75*1000

//
// Placement is important
//
#include "objs.h"

class CUI
{
public:
    CUI();
    ~CUI();

    /****************************************************************************/
    /* UI DATA                                                                  */
    /*                                                                          */
    /* Description: Component data in the User Interface                        */
    /****************************************************************************/

    UI_DATA _UI;

private:
    /****************************************************************************/
    /* UI Internal functions                                                    */
    /*                                                                          */
    /* Description: Component data in the User Interface                        */
    /****************************************************************************/
    DCSIZE DCINTERNAL UIGetMaximizedWindowSize(DCVOID);
    void   DCINTERNAL UIUpdateSessionInfo(TCHAR *, TCHAR *);
    
    static VOID near  FastRect(HDC, int, int, int, int);
    static DWORD near RGB2BGR(DWORD);
    
    void DCINTERNAL   UIRecalcMaxMainWindowSize();
    void DCINTERNAL   UIConnectWithCurrentParams(CONNECTIONMODE);
    void DCINTERNAL   UIRecalculateScrollbars();
    void DCINTERNAL   UIMoveContainerWindow();
    unsigned DCINTERNAL UICalculateVisibleScrollBars(unsigned, unsigned);
    void DCINTERNAL   UIUpdateScreenMode(BOOL fGrabFocus);
    void DCINTERNAL   UIShadowBitmapSettingChanged();
    void DCINTERNAL   UISmoothScrollingSettingChanged();
    void DCINTERNAL   UISetMinMaxPlacement();
    void DCINTERNAL   UIInitiateDisconnection();
    
    UINT32 DCINTERNAL UIGetKeyboardLayout();
    
    BOOL DCINTERNAL   UIValidateCurrentParams(CONNECTIONMODE connMode);
    unsigned DCINTERNAL UISetScrollInfo(int, LPSCROLLINFO, BOOL);
    
    void DCINTERNAL UISetConnectionStatus(unsigned);
    void DCINTERNAL UIInitializeDefaultSettings();
    
    void DCINTERNAL UIRedirectConnection();

    VOID DCINTERNAL UIStartConnectWithConnectedEndpoint();

    void DCINTERNAL UIStartDNSLookup();
    void DCINTERNAL UITryNextConnection();
    void DCINTERNAL UIGoDisconnected(unsigned disconnectCode, BOOL fFireEvent);
    BOOL DCINTERNAL UIValidateServerName(TCHAR *);
    void DCINTERNAL UIFinishDisconnection();
    BOOL            IsConnectingToOwnAddress(u_long connectAddr);
    BOOL            IsRunningOnPTS();
    BOOL            InitInputIdleTimer(LONG minsToTimeout);
    VOID            UISetBBarUnhideTimer(LONG x, LONG y);
    BOOL            UIIsTSOnWin2KOrGreater( VOID );
    BOOL            UIFreeAsyncDNSBuffer();

public:
    //
    // UI API functions
    //
    // Description: Component data in the User Interface
    //
    LRESULT CALLBACK                UIMainWndProc (HWND hwnd, UINT message,
                                                WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK         UIStaticMainWndProc (HWND hwnd, UINT message,
                                                    WPARAM wParam, LPARAM lParam);
    
    LRESULT CALLBACK                UIContainerWndProc (HWND hwndContainer, UINT message,
                                                    WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK         UIStaticContainerWndProc (HWND hwnd, UINT message,
                                                    WPARAM wParam, LPARAM lParam);

    HRESULT DCAPI                   UI_Init(HINSTANCE hInstance,
                                            HINSTANCE hPrevInstance,
                                            HINSTANCE hResInstance,
                                            HANDLE    hEvtNotifyCoreInit);
    HRESULT DCAPI                   UI_Term(DCVOID);
    DCVOID DCAPI                    UI_ToggleFullScreenMode(DCVOID);
    DCVOID DCAPI                    UI_GoFullScreen(DCVOID);
    DCVOID DCAPI                    UI_LeaveFullScreen(DCVOID);
    DCBOOL DCAPI                    UI_IsFullScreen();
    DCVOID DCAPI                    UI_ResetState();
    HRESULT DCAPI                   UI_Connect(CONNECTIONMODE);
    BOOL                            UI_UserInitiatedDisconnect(UINT discReason);
    BOOL                            UI_NotifyAxLayerCoreInit();
    BOOL                            UI_UserRequestedClose();
    
    //
    // Decoupled notification callbacks
    //
    DCVOID DCAPI                    UI_OnCoreInitialized(ULONG_PTR unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_OnCoreInitialized);

    DCVOID DCAPI                    UI_OnInputFocusGained(ULONG_PTR unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_OnInputFocusGained);

    DCVOID DCAPI                    UI_OnInputFocusLost(ULONG_PTR unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_OnInputFocusLost);

    DCVOID DCAPI                    UI_OnConnected(ULONG_PTR unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_OnConnected);
    
    DCVOID DCAPI                    UI_OnDisconnected(ULONG_PTR disconnectID);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_OnDisconnected);
    
    DCVOID DCAPI                    UI_OnShutDown(ULONG_PTR failID);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_OnShutDown);

    DCVOID DCAPI                    UI_OnDeactivateAllPDU(ULONG_PTR reason);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_OnDeactivateAllPDU);
    
    DCVOID DCAPI                    UI_OnDemandActivePDU(ULONG_PTR reason);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_OnDemandActivePDU);
    
    void DCAPI                      UI_DisplayBitmapCacheWarning(ULONG_PTR unusedParm);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_DisplayBitmapCacheWarning);

    void DCAPI                      UI_OnSecurityExchangeComplete(ULONG_PTR unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_OnSecurityExchangeComplete);

    void DCAPI                      UI_OnLicensingComplete(ULONG_PTR unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_OnLicensingComplete);

    void DCAPI                      UI_SetDisconnectReason(ULONG_PTR reason);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_SetDisconnectReason);

    DCVOID DCAPI                    UI_FatalError(DCINT error);
#ifdef OS_WINCE
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_FatalError);
#endif

#ifdef USE_BBAR
    void DCAPI                      UI_OnBBarHotzoneTimerFired(ULONG_PTR unused);
#endif

    void DCAPI                      UI_OnDesktopSizeChange(PDCSIZE pDesktopSize);
    DCVOID DCAPI                    UI_UpdateSessionInfo(PDCWCHAR pDomain, DCUINT   cbDomain,
                                      PDCWCHAR pUserName, DCUINT   cbUsername,
                                      DCUINT32 SessionId);
    #ifdef DC_DEBUG
    DCVOID DCAPI                    UI_CoreDebugSettingChanged(DCVOID);
    DCVOID DCAPI                    UI_SetRandomFailureItem(DCUINT itemID, DCINT percent);
    DCINT  DCAPI                    UI_GetRandomFailureItem(DCUINT itemID);
    DCVOID DCAPI                    UI_SetNetworkThroughput(DCUINT bytesPerSec);
    DCUINT DCAPI                    UI_GetNetworkThroughput();
    #endif /* DC_DEBUG */
    
    void    UI_OnLoginComplete();

    //
    // Autoreconnection notification
    //
    void
    UI_OnAutoReconnecting(
        LONG discReason,
        LONG attemptCount,
        LONG maxAttemptCount,
        BOOL* pfContinueArc);

    
#ifdef USE_BBAR
    BOOL    UI_RequestMinimize();
#endif

#ifndef OS_WINCE
    void    UI_HideLangBar();
    void    UI_RestoreLangBar();
#endif

    /********************************************************************/
    /* Get default langID                                               */
    /********************************************************************/
    DCLANGID UIGetDefaultLangID();
    DCUINT   UIGetDefaultIMEFileName(PDCTCHAR imeFileName, DCUINT Size);
    DCUINT   UIGetIMEMappingTableName(PDCTCHAR ImeMappingTableName, DCUINT Size);
    VOID     UIGetIMEFileName(PDCTCHAR imeFileName, DCUINT Size);
    VOID     UIGetIMEFileName16(PDCTCHAR imeFileName, DCUINT Size);
    VOID     DisableIME(HWND hwnd);

    int UI_BppToColorDepthID(int bpp);
    int UI_GetScreenBpp();

#ifdef SMART_SIZING
    HRESULT DCAPI UI_SetSmartSizing(BOOL fSmartSizing);
#endif // SMART_SIZING

    //
    // Virtual channel plugins to load
    //
    BOOL DCAPI UI_SetVChanAddinList(TCHAR *);
    PDCTCHAR DCAPI UI_GetVChanAddinList()
    {
        return _UI.pszVChanAddinDlls;
    }
    void UI_InitRdpDrSettings();
    void UI_CleanupLBState();

    //
    // Inline property accessors
    // 
    void DCAPI UI_SetCompress(BOOL);
    BOOL DCAPI UI_GetCompress();

    /****************************************************************************/
    /* Name:      UI_SetInstanceHandle                                          */
    /*                                                                          */
    /* Purpose:   Return application hInstance                                  */
    /*                                                                          */
    /* Returns:   hInstance                                                     */
    /****************************************************************************/
    void DCAPI UI_SetInstanceHandle(HINSTANCE hInstance)
    {
        DC_BEGIN_FN("UI_SetInstanceHandle");

        TRC_ASSERT((_UI.hInstance == 0), (TB, _T("Set instance handle twice!")));
        TRC_ASSERT((hInstance != 0), (TB, _T("invalid (zero) instance handle")));

        _UI.hInstance = hInstance;

        DC_END_FN();
    } /* UI_SetInstanceHandle */


    /****************************************************************************/
    /* Name:      UI_GetInstanceHandle                                          */
    /*                                                                          */
    /* Purpose:   Return application hInstance                                  */
    /****************************************************************************/
    HINSTANCE DCAPI UI_GetInstanceHandle()
    {
        HINSTANCE  rc;

        DC_BEGIN_FN("UI_GetInstanceHandle");

        TRC_ASSERT((_UI.hInstance != 0), (TB, _T("Instance handle not set")));
        rc = _UI.hInstance;
        TRC_DBG((TB, _T("Return %p"), rc));

        DC_END_FN();
        return(rc);
    } /* UI_GetInstanceHandle */


    /****************************************************************************/
    /* Name:      UI_SetUIContainerWnd                                          */
    /*                                                                          */
    /* Purpose:   Informs UT of the UI Container Window Handle.                 */
    /****************************************************************************/
    void DCAPI UI_SetUIContainerWindow(HWND hwndUIContainer)
    {
        DC_BEGIN_FN("UI_SetUIContainerWindow");

        TRC_ASSERT((hwndUIContainer != NULL),
                   (TB, _T("Invalid (NULL) Container Window")));
        TRC_ASSERT((_UI.hwndUIContainer == NULL),
                   (TB, _T("Set container window twice!")));
        _UI.hwndUIContainer = hwndUIContai